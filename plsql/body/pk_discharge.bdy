CREATE OR REPLACE PACKAGE BODY pk_discharge IS

    g_syscfg_disch_diag_icd9 CONSTANT sys_config.id_sys_config%TYPE := 'DISCHARGE_DIAG_ICD9';
    g_not_applicable         CONSTANT VARCHAR2(2) := 'NA';
    g_can_edit_inact_epis    CONSTANT VARCHAR2(1) := 'N';

    g_sa_client_registry_sys_id CONSTANT external_sys.id_external_sys%TYPE := 15101;

    FUNCTION set_disch_edis_to_inp_alert
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        CURSOR c_alert IS
            SELECT i_episode id_episode,
                   i_episode id_record,
                   e_edis.id_institution id_institution,
                   NULL id_professional,
                   e_inp.dt_begin_tstz dt_record,
                   decode(e_inp.flg_type,
                          'T',
                          '',
                          'D',
                          (SELECT dpt.code_department
                             FROM department dpt, discharge d, disch_reas_dest drd
                            WHERE d.id_episode = e_edis.id_episode
                              AND d.flg_status NOT IN ('C', 'R')
                              AND drd.id_disch_reas_dest = d.id_disch_reas_dest
                              AND dpt.id_department = drd.id_department)) replace1,
                   NULL id_schedule,
                   decode(e_inp.flg_type, 'T', 31, 'D', 30) id_sys_alert,
                   e_edis.id_episode id_reg_det,
                   NULL id_clinical_service,
                   NULL id_room
              FROM episode e_edis, episode e_inp, epis_ext_sys ees, epis_info ei
             WHERE e_edis.flg_status IN ('A', 'P')
               AND e_inp.flg_type IN ('T', 'D')
               AND e_edis.id_episode = i_episode
               AND ei.id_episode = e_edis.id_episode
               AND e_inp.id_prev_episode = e_edis.id_episode
               AND pk_alert_constant.g_soft_edis =
                   pk_episode.get_soft_by_epis_type(e_edis.id_epis_type, e_edis.id_institution)
               AND ees.id_episode = e_inp.id_episode
               AND ees.id_institution = e_edis.id_institution
               AND ees.id_external_sys =
                   pk_sysconfig.get_config('ID_EXTERNAL_SYS', e_edis.id_institution, ei.id_software)
               AND ees.value IS NULL;
    
        l_alert c_alert%ROWTYPE;
        l_internal_error EXCEPTION;
    BEGIN
    
        g_error := 'OPEN CURSOR C_ALERT';
        pk_alertlog.log_debug(g_error);
        OPEN c_alert;
        FETCH c_alert
            INTO l_alert;
        g_found := c_alert%NOTFOUND;
        CLOSE c_alert;
    
        IF NOT g_found
        THEN
            g_error := 'CALL TO PK_ALERTS.INSERT_SYS_ALERT_EVENT';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_alerts.insert_sys_alert_event(i_lang,
                                                    i_prof,
                                                    l_alert.id_sys_alert,
                                                    l_alert.id_episode,
                                                    l_alert.id_record,
                                                    l_alert.dt_record,
                                                    l_alert.id_professional,
                                                    l_alert.id_room,
                                                    l_alert.id_clinical_service,
                                                    NULL,
                                                    l_alert.replace1,
                                                    o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCH_EDIS_TO_INP_ALERT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCH_EDIS_TO_INP_ALERT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END;
    --
    FUNCTION del_disch_edis_to_inp_alert
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN discharge.id_episode%TYPE,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_alert_event sys_alert_event%ROWTYPE;
        l_internal_error EXCEPTION;
        l_exist_prev_episodes BOOLEAN := TRUE;
    BEGIN
        BEGIN
            g_error := 'GET DATA';
            pk_alertlog.log_debug(g_error);
            SELECT e_edis.id_episode
              INTO l_alert_event.id_episode
              FROM episode e_inp, episode e_edis
             WHERE e_inp.id_episode = i_episode
               AND e_inp.id_prev_episode = e_edis.id_episode;
        EXCEPTION
            WHEN no_data_found THEN
                l_exist_prev_episodes := FALSE;
        END;
    
        IF l_exist_prev_episodes
        THEN
            l_alert_event.id_record := l_alert_event.id_episode;
        
            g_error := 'CALL TO PK_ALERTS.DELETE_SYS_ALERT_EVENT (1)';
            pk_alertlog.log_debug(g_error);
            l_alert_event.id_sys_alert := 30;
            IF NOT pk_alerts.delete_sys_alert_event(i_lang, i_prof, l_alert_event, o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            g_error := 'CALL TO PK_ALERTS.DELETE_SYS_ALERT_EVENT (2)';
            pk_alertlog.log_debug(g_error);
            l_alert_event.id_sys_alert := 31;
            IF NOT pk_alerts.delete_sys_alert_event(i_lang, i_prof, l_alert_event, o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
        RETURN TRUE;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'DEL_DISCH_EDIS_TO_INP_ALERT',
                                              o_error);
            --pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'DEL_DISCH_EDIS_TO_INP_ALERT',
                                              o_error);
            --pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END del_disch_edis_to_inp_alert;
    --
    FUNCTION get_disch_destination
    (
        i_lang              IN language.id_language%TYPE,
        i_id_dep_clin_serv  IN NUMBER,
        i_id_department     IN NUMBER,
        i_id_institution    IN NUMBER,
        i_id_discharge_dest IN NUMBER
    ) RETURN VARCHAR2 IS
        l_return VARCHAR2(4000);
        l_id     NUMBER;
        i        NUMBER;
    BEGIN
    
        IF i_id_dep_clin_serv IS NOT NULL
        THEN
            l_id := i_id_dep_clin_serv;
            i    := 1;
        ELSIF i_id_department IS NOT NULL
        THEN
            l_id := i_id_department;
            i    := 2;
        ELSIF i_id_institution IS NOT NULL
        THEN
            l_id := i_id_institution;
            i    := 3;
        ELSIF i_id_discharge_dest IS NOT NULL
        THEN
            l_id := i_id_discharge_dest;
            i    := 4;
        END IF;
    
        SELECT l_desc
          INTO l_return
          FROM (SELECT pk_translation.get_translation(i_lang, cli.code_clinical_service) l_desc
                  FROM dep_clin_serv dcs, clinical_service cli
                 WHERE i = 1
                   AND dcs.id_dep_clin_serv = l_id
                   AND cli.id_clinical_service = dcs.id_clinical_service
                UNION ALL
                SELECT pk_translation.get_translation(i_lang, dpt.code_department) l_desc
                  FROM department dpt
                 WHERE i = 2
                   AND dpt.id_department = l_id
                UNION ALL
                SELECT pk_translation.get_translation(i_lang, ist.code_institution) l_desc
                  FROM institution ist
                 WHERE i = 3
                   AND ist.id_institution = l_id
                UNION ALL
                SELECT pk_translation.get_translation(i_lang, dde.code_discharge_dest) l_desc
                  FROM discharge_dest dde
                 WHERE i = 4
                   AND dde.id_discharge_dest = l_id) my_destinos;
    
        RETURN l_return;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_disch_destination;
    --
    /**
    * Checks if an episode was already discharged
    *
    * @param   I_LANG language associated to the professional executing the request
    * @param   I_EPISODE episode id
    * @param   I_PROF  professional, institution and software ids
    * @param   I_FLG_TYPE Discharge: D - Medical, M - Administrative
    * @param   I_NOTES discharge notes
    * @param   O_HAS_DISCHARGE Y - episode was already discharged, N - otherwise
    * @param   O_ERROR error message
    *
    * @RETURN  TRUE if sucess, FALSE otherwise
    * @author  Sérgio Santos
    * @since   06-Jan-2009
    */
    FUNCTION check_discharge_exists
    (
        i_lang          IN language.id_language%TYPE,
        i_episode       IN discharge.id_episode%TYPE,
        i_prof          IN profissional,
        i_flg_type      IN VARCHAR2,
        o_has_discharge OUT VARCHAR2,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id       discharge.id_discharge%TYPE;
        l_disch_dt discharge.dt_med_tstz%TYPE;
        --
        CURSOR c_exist IS
            SELECT id_discharge,
                   decode(i_flg_type,
                          g_doctor,
                          dt_med_tstz,
                          g_adm,
                          pk_discharge_core.get_dt_admin(i_lang, i_prof, NULL, d.flg_status_adm, d.dt_admin_tstz),
                          g_disch_type_nurse,
                          dt_nurse,
                          NULL)
              FROM discharge d
             WHERE d.id_episode = i_episode
               AND d.dt_cancel_tstz IS NULL
               AND d.flg_status IN (pk_discharge.g_disch_flg_active, pk_discharge.g_disch_flg_pend);
    BEGIN
        o_has_discharge := g_no;
    
        --Verifica se já existe alta para este tipo, neste episódio
        g_error := 'OPEN CURSOR C_EXIST';
        pk_alertlog.log_debug(g_error);
        OPEN c_exist;
        FETCH c_exist
            INTO l_id, l_disch_dt;
        CLOSE c_exist;
        IF l_disch_dt IS NOT NULL
        THEN
            IF i_flg_type != g_disch_type_nurse
               AND i_flg_type != g_disch_type_therapist_o
            THEN
                -- Já existe alta deste tipo, neste episódio
                o_has_discharge := g_yes;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CHECK_DISCHARGE_EXISTS',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END check_discharge_exists;

    /*
    * Check if the given visit has an ongoing social assistance
    * episode. When it does, this function returns a warning message
    * to be shown to the user.
    *
    * @param i_lang           language identifier
    * @param i_prof           logged professional structure
    * @param i_visit          visit identifier
    * @param o_flg_show       show warning message: Y/N
    * @param o_msg_title      warning message title
    * @param o_msg_text       warning message content
    * @param o_button         warning message buttons
    *
    * @author                 Pedro Carneiro
    * @version                 2.6.0.1
    * @since                  2010/03/01
    */
    PROCEDURE check_sw_episode
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_visit     IN visit.id_visit%TYPE,
        o_flg_show  OUT VARCHAR2,
        o_msg_title OUT VARCHAR2,
        o_msg_text  OUT VARCHAR2,
        o_button    OUT VARCHAR2
    ) IS
        l_sw_prof professional.id_professional%TYPE;
        l_found   BOOLEAN;
    
        CURSOR c_ongoing_epis IS
            SELECT ei.id_professional
              FROM episode e
              JOIN epis_info ei
                ON e.id_episode = ei.id_episode
             WHERE e.id_visit = i_visit
               AND e.id_epis_type = pk_alert_constant.g_epis_type_social
               AND NOT EXISTS (SELECT 1
                      FROM discharge d
                     WHERE d.id_episode = e.id_episode
                       AND d.flg_status = g_disch_flg_status_active);
    BEGIN
        g_error := 'OPEN c_ongoing_epis';
        OPEN c_ongoing_epis;
        FETCH c_ongoing_epis
            INTO l_sw_prof;
        l_found := c_ongoing_epis%FOUND;
        CLOSE c_ongoing_epis;
    
        IF l_found
        THEN
            o_flg_show  := pk_alert_constant.g_yes;
            o_msg_title := pk_message.get_message(i_lang, i_prof, 'COMMON_T013');
            o_msg_text  := REPLACE(pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M027'),
                                   '@1',
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, l_sw_prof));
            o_button    := 'R';
        ELSE
            o_flg_show  := pk_alert_constant.g_no;
            o_msg_title := NULL;
            o_msg_text  := NULL;
            o_button    := NULL;
        END IF;
    END check_sw_episode;

    --
    FUNCTION set_discharge
    (
        i_lang          IN language.id_language%TYPE,
        i_episode       IN discharge.id_episode%TYPE,
        i_prof          IN profissional,
        i_reas_dest     IN discharge.id_disch_reas_dest%TYPE,
        i_disch_type    IN discharge.flg_type%TYPE,
        i_flg_type      IN VARCHAR2,
        i_notes         IN discharge.notes_med%TYPE,
        i_transp        IN transp_entity.id_transp_entity%TYPE,
        i_justify       IN discharge.notes_justify %TYPE,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_flg_surgery   IN VARCHAR2,
        i_clin_serv     IN clinical_service.id_clinical_service%TYPE,
        i_department    IN department.id_department%TYPE,
        o_flg_show      OUT VARCHAR2,
        o_msg_title     OUT VARCHAR2,
        o_msg_text      OUT VARCHAR2,
        o_button        OUT VARCHAR2,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:    Sets discharge Create a record for discharge (DISCHARGE ).
           PARAMETROS:  Entrada: I_LANG - language associated to the professional executing the request
                                    I_EPISODE - ID of episode
                                    I_PROF - professional, institution and software ids
                                 I_REAS_DEST - discharge reason by destination
                                 I_DISCH_TYPE - Discharge Type F - end of episode;
                                                   D - discharge (clinical discharge - )
                                                only being filled on medical discharge
                                 I_FLG_TYPE - Discharge: D - Medical, M- Administrative
                                 I_NOTES - Notes
                                 I_TRANSP - ID of transportation
                                             I_JUSTIFY - discharge justification
                                 I_PROF_CAT_TYPE - type of professional category, returned by PK_LOGIN.GET_PROF_PREF
                                 I_FLG_SURGERY - indicates if the discharge for internment is associated to surgery (Y/N)
                                 I_CLIN_SERV - id_clinical_service of internment speciality, in the case of discharge for internment
                        Saida:   O_ERROR - error
                                  O_MESS_TEMP - Warning message. Indicates if the episode has temporary records.
        
          CRIAÇÃO: CRS 2005/03/31
          NOTAS: (a)dependents            PK_CASE_MANAGEMENT.SET_ENC_DISCHARGE    OUTP
        *********************************************************************************/
    
        l_ret BOOLEAN;
    
    BEGIN
    
        l_ret := pk_alerts.delete_sys_alert_event_episode(i_lang    => i_lang,
                                                          i_prof    => i_prof,
                                                          i_episode => i_episode,
                                                          i_delete  => 'Y',
                                                          o_error   => o_error);
    
        -- LGASPAR, 24-jan-2006
        -- Code in this function was copied to the function beeing called due to appointment price attributes
        RETURN set_discharge(i_lang,
                             i_episode,
                             i_prof,
                             i_reas_dest,
                             i_disch_type,
                             i_flg_type,
                             i_notes,
                             i_transp,
                             i_justify,
                             i_prof_cat_type,
                             NULL,
                             NULL,
                             NULL,
                             i_flg_surgery,
                             i_clin_serv,
                             i_department,
                             o_flg_show,
                             o_msg_title,
                             o_msg_text,
                             o_button,
                             o_error);
    
    END set_discharge;
    --
    /**
    * Sets medical discharge info in enviroments where price is specified.
    *
    * @param   I_LANG language associated to the professional executing the request
    * @param   I_EPISODE episode id
    * @param   I_PROF  professional, institution and software ids
    * @param   I_REAS_DEST discharge reason by destination
    * @param   I_DISCH_TYPE Idischarge type
    * @param   I_FLG_TYPE flag type
    * @param   I_NOTES discharge notes
    * @param   I_TRANSP transport id
    * @param   I_JUSTIFY discharge justify
    * @param   I_PRICE appointment price
    * @param   I_CURRENCY appointment price currency
    * @param   I_FLG_PAYMENT payment condition
    * @param   I_FLG_SURGERY  Y/N, INDICA SE É PRECISO CRIAR CIRURGIA
    * @param   I_FLG_SURGERY - indicates if discharge for internment is associated to a surgery (Y/N)
    * @param   I_CLIN_SERV - id_clinical_service of internment speciality, in case od discharge for internment
    * @param   i_flg_print_report - flg print report
    * @param   i_flg_letter - type of discharge letter: P - print discharge letter; S - send discharge letter message
    * @param   i_flg_task - list of tasks associated with the discharge letter
    
    * @param   O_FLG_SHOW does it shows buttons
    * @param   O_MSG_TITLE warning/error message title
    * @param   O_MSG_TEXT warning/error message
    * @param   O_BUTTON OUT the buttons to show in the warning/error
    *
    * @RETURN  TRUE if sucess, FALSE otherwise
    * @author  Luis Gaspar
    * @version 1.0
    * @since   24-Jan-2006
    * NOTAS: LG 2007-fev-08
    */
    FUNCTION set_discharge_no_commit
    (
        i_lang                IN language.id_language%TYPE,
        i_episode             IN discharge.id_episode%TYPE,
        i_prof                IN profissional,
        i_reas_dest           IN discharge.id_disch_reas_dest%TYPE,
        i_disch_type          IN discharge.flg_type%TYPE,
        i_flg_type            IN VARCHAR2,
        i_notes               IN discharge.notes_med%TYPE,
        i_transp              IN transp_entity.id_transp_entity%TYPE,
        i_justify             IN discharge.notes_justify %TYPE,
        i_prof_cat_type       IN category.flg_type%TYPE,
        i_price               IN discharge.price%TYPE,
        i_currency            IN discharge.currency%TYPE,
        i_flg_payment         IN discharge.flg_payment%TYPE,
        i_flg_surgery         IN VARCHAR2,
        i_dt_surgery          IN VARCHAR2,
        i_clin_serv           IN clinical_service.id_clinical_service%TYPE,
        i_department          IN department.id_department%TYPE,
        i_transaction_id      IN VARCHAR2,
        i_flg_bill_type       IN discharge.flg_bill_type%TYPE,
        i_flg_print_report    IN discharge_detail.flg_print_report%TYPE DEFAULT NULL,
        i_flg_letter          IN discharge_rep_notes.flg_type%TYPE,
        i_flg_task            IN discharge_rep_notes.flg_task%TYPE,
        i_sysdate             IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_pat_condition   IN discharge_detail.flg_pat_condition%TYPE,
        i_flg_hist            IN VARCHAR2,
        i_dt_fw_visit         IN VARCHAR2,
        i_id_dep_clin_serv_fw IN discharge_detail.id_dep_clin_serv_fw%TYPE,
        i_id_prof_fw          IN discharge_detail.id_prof_fw%TYPE,
        i_sched_notes         IN discharge_detail.sched_notes%TYPE,
        i_id_complaint_fw     IN discharge_detail.id_complaint_fw%TYPE,
        i_reason_for_visit_fw IN discharge_detail.reason_for_visit_fw%TYPE,
        i_dt_med              IN VARCHAR2 DEFAULT NULL,
        
        i_id_concept_term         IN concept_term.id_concept_term%TYPE DEFAULT NULL,
        i_id_cncpt_trm_inst_owner IN concept_term.id_inst_owner%TYPE DEFAULT NULL,
        i_id_terminology_version  IN terminology_version.id_terminology_version%TYPE DEFAULT NULL,
        i_flg_type_closure        IN discharge_detail.flg_type_closure%TYPE DEFAULT NULL,
        
        o_reports_pat      OUT reports.id_reports%TYPE,
        o_flg_show         OUT VARCHAR2,
        o_msg_title        OUT VARCHAR2,
        o_msg_text         OUT VARCHAR2,
        o_button           OUT VARCHAR2,
        o_id_episode       OUT episode.id_episode%TYPE,
        o_id_shortcut      OUT sys_shortcut.id_sys_shortcut%TYPE,
        o_discharge        OUT discharge.id_discharge%TYPE,
        o_discharge_detail OUT discharge_detail.id_discharge_detail%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_next               discharge.id_discharge%TYPE;
        l_id                 discharge.id_discharge%TYPE;
        l_id_hist            discharge_hist.id_discharge_hist%TYPE;
        l_disch_dt           discharge.dt_med_tstz%TYPE;
        l_diag               disch_reas_dest.flg_diag%TYPE;
        l_id_epis_diagnosis  epis_diagnosis.id_epis_diagnosis%TYPE;
        l_id_visit           visit.id_visit%TYPE;
        l_id_patient         visit.id_patient%TYPE;
        l_id_epis_type       episode.id_epis_type%TYPE;
        l_flg_payment        VARCHAR2(1);
        l_epis_int           disch_reas_dest.id_epis_type%TYPE;
        l_type_screen        disch_reas_dest.type_screen%TYPE;
        l_type_new_epis      episode.flg_type%TYPE;
        l_id_epis_int        episode.id_episode%TYPE;
        l_dcs                dep_clin_serv.id_dep_clin_serv%TYPE;
        l_id_print_list_jobs table_number := table_number();
        l_cancel_print_jobs_excpt EXCEPTION;
        l_print_jobs table_number := table_number();
        l_ret        BOOLEAN;
        --
        CURSOR c_exist IS
            SELECT id_discharge,
                   decode(i_flg_type,
                          g_doctor,
                          dt_med_tstz,
                          g_adm,
                          pk_discharge_core.get_dt_admin(i_lang, i_prof, NULL, d.flg_status_adm, d.dt_admin_tstz),
                          g_disch_type_nurse,
                          dt_nurse,
                          NULL) --SF 29/05/2008 nurse discharge
              FROM discharge d
             WHERE d.id_episode = i_episode
               AND d.dt_cancel_tstz IS NULL;
    
        CURSOR c_discharge IS
            SELECT id_discharge, /*flg_status,*/ dt_med_tstz
              FROM discharge
             WHERE id_episode = i_episode
               AND flg_status IN (g_epis_disch_act, g_disch_flg_pend);
        --
        CURSOR c_flg_diag IS
            SELECT flg_diag, id_epis_type, type_screen
              FROM disch_reas_dest
             WHERE id_disch_reas_dest = i_reas_dest;
        --
        CURSOR c_diagn IS
            SELECT id_epis_diagnosis
              FROM epis_diagnosis ed
              JOIN episode e
                ON ed.id_episode = e.id_episode
             WHERE e.id_episode = i_episode
                  -- CRS 2007/01/11 has to have final diagnosis
               AND (ed.flg_type IN (g_diagn_def, g_diagn_base) OR
                   (ed.flg_type = pk_diagnosis.g_diag_type_p AND
                   e.id_epis_type IN (pk_alert_constant.g_epis_type_social, pk_alert_constant.g_epis_type_dietitian)))
               AND ed.flg_status NOT IN (g_diagn_canc);
    
        --
        CURSOR c_admin IS
            SELECT 'X'
              FROM epis_anamnesis
             WHERE id_episode = i_episode
               AND flg_type = g_anamnesis_type
               AND flg_class = g_admin_anamnesis;
        --
        CURSOR c_dcs IS
            SELECT id_dep_clin_serv
              FROM dep_clin_serv
             WHERE id_department = i_department
               AND id_clinical_service = i_clin_serv;
    
        --
        CURSOR c_ehr IS
            SELECT flg_ehr
              FROM episode e
             WHERE id_episode = i_episode;
        --
    
        CURSOR c_discharge_report_cfg(i_id_discharge discharge.id_discharge%TYPE) IS
            SELECT t.id_report, t.flg_send, t.flg_send_to_crm, t.generation_rank
              FROM TABLE(pk_discharge_crm.tf_discharge_report_cfg(i_lang => i_lang, i_prof => i_prof)) t
             WHERE NOT EXISTS (SELECT 1
                      FROM discharge_report dr
                     WHERE dr.id_report = t.id_report
                       AND dr.id_discharge = i_id_discharge)
             ORDER BY t.generation_rank;
        --
        l_char                     VARCHAR2(1);
        l_disch_mandatory          sys_config.value%TYPE;
        l_end_episode_on_discharge sys_config.value%TYPE;
        l_diag_mandatory           sys_config.value%TYPE;
        l_flg_end_epis             VARCHAR2(1 CHAR);
    
        l_can_refresh_mviews BOOLEAN := FALSE;
    
        l_dt_med_tstz         discharge.dt_med_tstz%TYPE;
        l_dt_admin_tstz       discharge.dt_admin_tstz%TYPE;
        l_dt_pend_active_tstz discharge.dt_pend_active_tstz%TYPE;
        l_id_disch_reas       discharge.id_disch_reas_dest%TYPE;
        l_flag_status         discharge.flg_status%TYPE;
        l_clinical_desc       pk_translation.t_desc_translation;
        l_department_desc     pk_translation.t_desc_translation;
        l_sys_alert_event     sys_alert_event%ROWTYPE;
        l_flg_status_ei       epis_info.flg_status%TYPE;
    
        l_count NUMBER;
    
        l_flg_ehr episode.flg_ehr%TYPE;
    
        l_sysdate_tstz TIMESTAMP WITH LOCAL TIME ZONE;
    
        -- denormalization variables
        l_rowids    table_varchar;
        l_rowids_ei table_varchar;
        l_common_error   EXCEPTION;
        l_internal_error EXCEPTION;
        l_err_date_begin EXCEPTION;
    
        l_error_message sys_message.desc_message%TYPE;
        --
        l_cosign_disp  sys_config.value%TYPE;
        l_cosign_count NUMBER(6);
        l_flg_state    schedule_outp.flg_state%TYPE;
    
        --Scheduler 3.0 variables
        l_flg_status       discharge.flg_status%TYPE;
        l_transaction_id   VARCHAR2(4000);
        l_discharge_status discharge_status.id_discharge_status%TYPE;
        l_id_schedule      schedule.id_schedule%TYPE;
        l_func_exception EXCEPTION;
        l_id_consult_req consult_req.id_consult_req%TYPE;
        l_patient        patient.id_patient%TYPE;
    
        l_rec_disch_rep_cfg   pk_discharge_crm.t_rec_disch_rep_cfg;
        l_table_disch_rep_cfg pk_discharge_crm.t_table_disch_rep_cfg;
        l_disch_rep_rowids    table_varchar := table_varchar();
    
        l_epis_dt_begin episode.dt_begin_tstz%TYPE;
        l_med_tstz      TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_auto_presc_cancel VARCHAR2(1char);
        l_auto_cancel_msg   sys_message.desc_message%TYPE;
        l_prof_id           professional.id_professional%TYPE;
    
        l_wf_type    VARCHAR2(1 CHAR);
        l_from_state VARCHAR2(1 CHAR);
        l_to_state   VARCHAR2(1 CHAR);
    
        FUNCTION set_rehab_wf
        (
            i_wf_type    IN VARCHAR2,
            i_from_state IN VARCHAR2,
            i_to_state   IN VARCHAR2
        ) RETURN BOOLEAN AS
            l_func_name      VARCHAR2(32) := $$PLSQL_UNIT;
            l_id_episode_aux episode.id_episode%TYPE;
            l_dep_type       sch_event.dep_type%TYPE;
            l_rehab_schedule rehab_schedule.id_rehab_schedule%TYPE;
            l_rehab_sch_need rehab_schedule.id_rehab_sch_need%TYPE;
            l_id_epis_origin rehab_epis_encounter.id_episode_origin%TYPE;
            l_id_epis_rehab  rehab_epis_encounter.id_rehab_epis_encounter%TYPE;
        BEGIN
        
            IF i_wf_type = pk_rehab.g_workflow_type_s
               AND l_id_schedule <> -1
            THEN
                -- get ingredients. no_data_Found sao apanhados pelo when others principal
                BEGIN
                    SELECT rs.id_rehab_schedule, rs.id_rehab_sch_need
                      INTO l_rehab_schedule, l_rehab_sch_need
                      FROM rehab_schedule rs
                     WHERE rs.id_schedule = l_id_schedule;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL;
                END;
                --get id_episode_origin. no_data_Found sao apanhados pelo when others principal
                BEGIN
                    SELECT ree.id_episode_origin, ree.id_rehab_epis_encounter
                      INTO l_id_epis_origin, l_id_epis_rehab
                      FROM rehab_epis_encounter ree
                      JOIN epis_info ei
                        ON ei.id_episode = ree.id_episode_rehab
                     WHERE ei.id_schedule = l_id_schedule;
                EXCEPTION
                    WHEN no_data_found THEN
                        SELECT rsn.id_episode_origin
                          INTO l_id_epis_origin
                          FROM rehab_sch_need rsn
                          JOIN rehab_schedule rs
                            ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
                         WHERE rs.id_schedule = l_id_schedule;
                END;
            ELSIF i_wf_type = pk_rehab.g_workflow_type_w
            --  AND l_id_schedule = -1
            THEN
                SELECT ree.id_episode_origin, ree.id_rehab_epis_encounter, id_rehab_sch_need
                  INTO l_id_epis_origin, l_id_epis_rehab, l_rehab_sch_need
                  FROM rehab_epis_encounter ree
                  JOIN epis_info ei
                    ON ei.id_episode = ree.id_episode_rehab
                 WHERE ei.id_episode = i_episode;
            ELSIF i_wf_type = pk_rehab.g_workflow_type_a
            THEN
                BEGIN
                    SELECT ree.id_episode_origin, ree.id_rehab_epis_encounter
                      INTO l_id_epis_origin, l_id_epis_rehab
                      FROM rehab_epis_encounter ree
                     WHERE ree.id_episode_origin = i_episode
                       AND ree.flg_rehab_workflow_type = i_wf_type
                       AND ree.flg_status = i_from_state;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_id_epis_origin := nvl(l_id_epis_origin, i_episode);
                END;
            END IF;
            g_error := l_id_schedule || 'l_id_patient:' || l_id_patient || 'i_wf_type:' || i_wf_type || 'i_from_state:' ||
                       i_from_state || 'i_to_state:' || i_to_state || 'l_id_epis_rehab:' || l_id_epis_rehab ||
                       'l_rehab_sch_need:' || l_rehab_sch_need || 'l_rehab_schedule:' || l_rehab_schedule;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_rehab.set_rehab_wf_change_nocommit(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_patient        => l_id_patient,
                                                         i_workflow_type     => i_wf_type,
                                                         i_from_state        => i_from_state,
                                                         i_to_state          => i_to_state,
                                                         i_id_rehab_grid     => l_id_epis_rehab,
                                                         i_id_rehab_presc    => l_rehab_sch_need,
                                                         i_id_epis_origin    => l_id_epis_origin,
                                                         i_id_rehab_schedule => l_rehab_schedule,
                                                         i_id_schedule       => l_id_schedule,
                                                         i_id_cancel_reason  => NULL,
                                                         i_cancel_notes      => NULL,
                                                         i_transaction_id    => NULL,
                                                         o_id_episode        => l_id_episode_aux,
                                                         o_error             => o_error)
            THEN
                RETURN FALSE;
            END IF;
            RETURN TRUE;
        END set_rehab_wf;
    
    BEGIN
        -- José Brito 14/11/2008 Variable L_SYSDATE_TSTZ used for  SET_FIRST_OBS,
        -- to assure that  DT_FIRST_OBS it is not not higher than medical discharge.
        IF i_sysdate IS NULL
        THEN
            l_sysdate_tstz := current_timestamp;
            g_sysdate_tstz := current_timestamp;
        ELSE
            l_sysdate_tstz := i_sysdate;
            g_sysdate_tstz := i_sysdate;
        END IF;
    
        g_error := 'GET VISIT AND PATIENT ID';
        SELECT e.dt_begin_tstz
          INTO l_epis_dt_begin
          FROM episode e
         WHERE e.id_episode = i_episode;
    
        IF (i_dt_med = ' ' OR i_dt_med IS NULL)
        THEN
            l_med_tstz := g_sysdate_tstz;
        ELSIF (i_dt_med IS NOT NULL AND l_epis_dt_begin > pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_med, NULL))
        THEN
            l_error_message := pk_message.get_message(i_lang, 'DISCHARGE_M020');
        
            RAISE l_err_date_begin;
        ELSE
            l_med_tstz := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_med, NULL);
        END IF;
    
        --
        g_error                    := 'GET CONFIGURATIONS (1)';
        l_disch_mandatory          := pk_sysconfig.get_config('DOCTOR_DISCH_MANDATORY', i_prof);
        g_disch_social             := pk_sysconfig.get_config('DISCHARGE_SOCIAL', i_prof);
        l_end_episode_on_discharge := pk_sysconfig.get_config('END_EPISODE_ON_DISCHARGE', i_prof);
        l_diag_mandatory           := pk_sysconfig.get_config('DISCHARGE_DIAG_MANDATORY', i_prof);
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
    
        -- checks if the episode is about to end
        g_error := 'SET L_FLG_END_EPIS';
        IF i_flg_type = g_adm
           OR nvl(l_end_episode_on_discharge, g_no) = g_yes
        THEN
            l_flg_end_epis := g_yes;
        ELSE
            l_flg_end_epis := g_no;
        END IF;
    
        g_error := 'GET SCHEDULE ID';
        BEGIN
            SELECT DISTINCT v.id_schedule
              INTO l_id_schedule
              FROM epis_info v
             WHERE v.id_episode = i_episode;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_schedule := NULL;
        END;
    
        g_error        := 'CALL pk_episode.get_epis_type';
        l_id_epis_type := pk_episode.get_epis_type(i_lang => i_lang, i_id_epis => i_episode);
    
        g_error := 'OPEN CURSOR C_EXIST';
        OPEN c_ehr;
        FETCH c_ehr
            INTO l_flg_ehr;
        CLOSE c_ehr;
    
        IF l_flg_ehr = g_ehr_schedule
        THEN
            l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M019');
            RAISE l_common_error;
        END IF;
    
        -- lg 2007-fev-07 for Private Practice set  flg_payment with value 'For Payment' (Por pagar)
        IF (i_flg_payment IS NULL)
        THEN
            g_error       := 'GET CONFIGURATIONS (2)';
            l_flg_payment := pk_sysconfig.get_config(g_sys_config_default_flg_pay, i_prof);
        ELSE
            l_flg_payment := i_flg_payment;
        END IF;
    
        -- Check if dispostion without co-sign is allowed
        l_cosign_disp := pk_sysconfig.get_config('ALLOW_DISPOSITION_WITHOUT_COSIGN', i_prof);
    
        IF l_cosign_disp = g_no
        THEN
            -- Check if there are tasks with pending co-sign
            SELECT COUNT(1)
              INTO l_cosign_count
              FROM TABLE(pk_co_sign_api.tf_pending_co_sign_tasks(i_lang    => i_lang,
                                                                 i_prof    => i_prof,
                                                                 i_episode => i_episode)) c;
        
            IF l_cosign_count > 0
            THEN
                -- There are tasks with pending co-sign. Execution is stopped
                l_error_message := pk_message.get_message(i_lang, 'DISPOSITION_NOCOSIGN_M001');
                RAISE l_common_error;
            END IF;
        END IF;
    
        -- verify is alredy exists a discharge for this episode
        g_error := 'OPEN CURSOR C_EXIST';
        OPEN c_exist;
        FETCH c_exist
            INTO l_id, l_disch_dt;
        CLOSE c_exist;
    
        IF (l_id_epis_type = pk_act_therap_constant.g_activ_therap_epis_type)
        THEN
            l_id       := NULL;
            l_disch_dt := NULL;
        
            g_error := 'OPEN CURSOR C_EXIST';
            OPEN c_discharge;
            FETCH c_discharge
                INTO l_id, l_disch_dt;
            CLOSE c_discharge;
        
        END IF;
    
        IF l_disch_dt IS NOT NULL
           AND l_id_epis_type != pk_act_therap_constant.g_activ_therap_epis_type
        THEN
            IF i_flg_type != g_disch_type_nurse
               AND i_flg_type != g_disch_type_therapist_o
            --SF 29/05/2008 nurse discharge 
            THEN
                -- if alredy exists this kind of discharge for the episode
                l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M004');
                -- MSG: "The discharge has been given and can not be changed." 
                -- " "A alta já foi dada, não pode ser alterada."
                RAISE l_common_error;
            ELSE
                RETURN TRUE;
            END IF;
        END IF;
    
        g_error := 'GET ID_DISCHARGE_STATUS';
        IF NOT pk_discharge.get_disch_flg_status(i_lang         => i_lang,
                                                 i_prof         => i_prof,
                                                 i_flg_status   => g_disch_flg_active,
                                                 i_disch_status => NULL,
                                                 o_flg_status   => l_flg_status,
                                                 o_disch_status => l_discharge_status,
                                                 o_error        => o_error)
        THEN
            RAISE l_common_error;
        END IF;
    
        l_auto_cancel_msg := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_T033');
    
        -- when discharge is administrative, check for ongoing social worker episodes
        IF i_flg_type = g_adm
           AND g_disch_social = g_adm
        THEN
            g_error := 'CALL check_sw_episode';
            check_sw_episode(i_lang      => i_lang,
                             i_prof      => i_prof,
                             i_visit     => pk_episode.get_id_visit(i_episode),
                             o_flg_show  => o_flg_show,
                             o_msg_title => o_msg_title,
                             o_msg_text  => o_msg_text,
                             o_button    => o_button);
            IF o_flg_show = pk_alert_constant.g_yes
            THEN
                l_error_message := o_msg_text;
                RAISE l_common_error;
            END IF;
        END IF;
    
        -- For medical discharge it is necessary to verify the existence of a final diagnosis
        IF i_flg_type = g_doctor
        THEN
            g_error := 'OPEN C_ADMIN';
            OPEN c_admin;
            FETCH c_admin
                INTO l_char;
            g_found := c_admin%NOTFOUND;
            CLOSE c_admin;
            IF g_found
            THEN
                -- if the administrative complaint is not registered
            
                -- Verify it is necessary a diagnosys for the episode
                g_error := 'OPEN CURSOR C_FLG_DIAG';
                OPEN c_flg_diag;
                FETCH c_flg_diag
                    INTO l_diag, l_epis_int, l_type_screen;
                g_found := c_flg_diag%NOTFOUND;
                CLOSE c_flg_diag;
                IF g_found
                THEN
                    -- Unable to verify requirement for diagnosis
                    RAISE l_internal_error;
                END IF;
            
                -- Verify if there exists diagnosis of the episode in EPIS_DIAGNOSYS
                IF l_diag = g_flag_diag
                   AND l_diag_mandatory = pk_alert_constant.g_yes
                THEN
                    g_error := 'OPEN CURSOR C_DIAGN';
                    OPEN c_diagn;
                    FETCH c_diagn
                        INTO l_id_epis_diagnosis;
                    g_found := c_diagn%NOTFOUND;
                    CLOSE c_diagn;
                    IF g_found
                    THEN
                        l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M006'); -- MSG: "Before disposition, you must enter a final diagnosis." - "Para proceder à alta médica é necessário establecer um diagnóstico definitivo ou, pelo menos, enquadrar este episódio num grupo de diagnósticos. "
                        RAISE l_common_error;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        -- CRS 2006-12-12  Allowed to give administrative discharge without a medical discharge
    
        --If you came here, all pre-conditions were satisfied and the discharge will be processed
        IF l_id IS NULL
        THEN
            -- there is no medical discharge for this episode
            IF i_flg_type = g_adm
               AND l_disch_mandatory <> 'Y'
            THEN
                l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M007');
                RAISE l_common_error;
            END IF;
        
            g_error := 'CHECK_DISCHARGE (1)';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_discharge.check_discharge(i_lang               => i_lang,
                                                i_prof               => i_prof,
                                                i_episode            => i_episode,
                                                i_can_edt_inact_epis => g_can_edit_inact_epis,
                                                o_error              => o_error)
            THEN
                RAISE pk_discharge.e_check_discharge;
            END IF;
        
            -- Obtain next ID
            g_error := 'GET SEQ_DISCHARGE.NEXTVAL';
            l_next  := seq_discharge.nextval;
        
            -- INSERT new discharge
            g_error := 'INSERT DISCHARGE';
            INSERT INTO discharge
                (id_discharge,
                 id_disch_reas_dest,
                 id_episode,
                 dt_cancel_tstz,
                 id_prof_cancel,
                 notes_cancel,
                 id_prof_med,
                 dt_med_tstz,
                 notes_med,
                 id_prof_admin,
                 dt_admin_tstz,
                 notes_admin,
                 id_prof_nurse, --SF 29/05/2008 nurse discharge
                 dt_nurse, --SF 29/05/2008 nurse discharge
                 notes_nurse, --SF 29/05/2008 nurse discharge
                 flg_status,
                 id_discharge_status,
                 flg_type,
                 id_transp_ent_med,
                 id_transp_ent_adm,
                 notes_justify,
                 price,
                 currency,
                 flg_payment,
                 flg_type_disch,
                 id_prof_therapist,
                 dt_therapist,
                 notes_therapist,
                 flg_bill_type,
                 flg_status_adm,
                 flg_market,
                 id_concept_term,
                 id_cncpt_trm_inst_owner,
                 id_terminology_version)
            VALUES
                (l_next,
                 i_reas_dest,
                 i_episode,
                 NULL,
                 NULL,
                 NULL,
                 decode(i_flg_type, g_doctor, i_prof.id, g_disch_type_casemanager_c, i_prof.id, NULL),
                 decode(i_flg_type, g_doctor, l_med_tstz, g_disch_type_casemanager_c, g_sysdate_tstz, NULL),
                 decode(i_flg_type, g_doctor, i_notes, g_disch_type_casemanager_c, i_notes, NULL),
                 decode(l_flg_end_epis, pk_alert_constant.g_yes, i_prof.id, NULL),
                 decode(l_flg_end_epis, pk_alert_constant.g_yes, g_sysdate_tstz, NULL),
                 decode(l_flg_end_epis, pk_alert_constant.g_yes, i_notes, NULL),
                 decode(i_flg_type, g_disch_type_nurse, i_prof.id, NULL), --SF 29/05/2008 nurse discharge
                 decode(i_flg_type, g_disch_type_nurse, g_sysdate_tstz, NULL), --SF 29/05/2008 nurse discharge
                 decode(i_flg_type, g_disch_type_nurse, i_notes, NULL), --SF 29/05/2008 nurse discharge
                 g_disch_flg_active,
                 l_discharge_status,
                 i_disch_type,
                 decode(i_flg_type, g_doctor, i_transp, NULL),
                 decode(i_flg_type, g_adm, i_transp, NULL),
                 i_justify,
                 decode(i_flg_type, g_doctor, i_price, g_adm, i_price, NULL),
                 decode(i_flg_type, g_doctor, i_currency, g_adm, i_currency, NULL),
                 l_flg_payment,
                 decode(i_flg_type,
                        g_doctor,
                        g_doctor,
                        g_adm,
                        g_adm,
                        g_disch_type_nurse,
                        g_disch_type_nurse,
                        g_disch_type_therapist_o,
                        g_therapist,
                        g_disch_type_casemanager_c,
                        g_disch_type_casemanager_c,
                        NULL),
                 decode(i_flg_type, g_disch_type_therapist_o, i_prof.id, NULL),
                 decode(i_flg_type, g_disch_type_therapist_o, g_sysdate_tstz, NULL),
                 decode(i_flg_type, g_disch_type_therapist_o, i_notes, NULL),
                 i_flg_bill_type,
                 decode(l_flg_end_epis, pk_alert_constant.g_yes, pk_alert_constant.g_active, NULL),
                 pk_discharge_core.g_disch_type_pt,
                 i_id_concept_term,
                 i_id_cncpt_trm_inst_owner,
                 i_id_terminology_version)
            RETURNING id_disch_reas_dest, dt_med_tstz, dt_admin_tstz, flg_status, dt_pend_active_tstz, id_prof_med INTO l_id_disch_reas, l_dt_med_tstz, l_dt_admin_tstz, l_flag_status, l_dt_pend_active_tstz, l_prof_id;
        
            l_id        := l_next;
            o_discharge := l_next;
        
            IF i_id_dep_clin_serv_fw IS NOT NULL
               AND nvl(pk_sysconfig.get_config('CREATE_DISPOSITION_FE', i_prof), pk_alert_constant.g_yes) =
               pk_alert_constant.g_yes
            THEN
            
                SELECT e.id_patient
                  INTO l_patient
                  FROM episode e
                 WHERE e.id_episode = i_episode;
            
                g_error := 'CALL insert_future_events_nc';
                IF NOT pk_events.insert_future_events_nc(i_lang                => i_lang,
                                                         i_prof                => i_prof,
                                                         i_patient             => l_patient,
                                                         i_episode             => i_episode,
                                                         i_epis_type           => pk_sysconfig.get_config('ID_EPIS_TYPE_MEDICAL',
                                                                                                          i_prof),
                                                         i_request_prof        => table_number(i_id_prof_fw),
                                                         i_inst_req_to         => i_prof.institution,
                                                         i_sch_event           => pk_sysconfig.get_config('ID_SCH_EVENT_DISPOSITION_FE',
                                                                                                          i_prof),
                                                         i_dep_clin_serv       => i_id_dep_clin_serv_fw,
                                                         i_complaint           => i_id_complaint_fw, --10
                                                         i_dt_begin_event      => i_dt_fw_visit,
                                                         i_dt_end_event        => NULL,
                                                         i_priority            => 'R',
                                                         i_contact_type        => NULL,
                                                         i_notes               => NULL,
                                                         i_instructions        => i_sched_notes,
                                                         i_room                => NULL,
                                                         i_request_type        => NULL,
                                                         i_request_responsable => NULL,
                                                         i_request_reason      => NULL, --20
                                                         i_prof_approval       => table_number(),
                                                         i_language            => NULL,
                                                         i_recurrence          => 'N',
                                                         i_status              => 'P',
                                                         i_frequency           => NULL,
                                                         i_dt_rec_begin        => NULL,
                                                         i_dt_rec_end          => NULL,
                                                         i_nr_events           => NULL,
                                                         i_week_day            => NULL,
                                                         i_week_nr             => NULL, --30
                                                         i_month_day           => NULL,
                                                         i_month_nr            => NULL,
                                                         i_reason_for_visit    => i_reason_for_visit_fw,
                                                         o_consult_req_id      => l_id_consult_req,
                                                         o_error               => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            INSERT INTO discharge_detail
                (id_discharge_detail,
                 id_discharge,
                 flg_print_report,
                 id_dep_clin_serv_admiting,
                 flg_surgery,
                 date_surgery_tstz,
                 flg_pat_condition,
                 dt_fw_visit,
                 id_dep_clin_serv_fw,
                 id_prof_fw,
                 sched_notes,
                 id_complaint_fw,
                 reason_for_visit_fw,
                 id_consult_req_fw,
                 flg_type_closure)
            VALUES
                (seq_discharge_detail.nextval,
                 l_id,
                 i_flg_print_report,
                 i_clin_serv,
                 i_flg_surgery,
                 pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_surgery, NULL),
                 i_flg_pat_condition,
                 pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_fw_visit, NULL),
                 i_id_dep_clin_serv_fw,
                 i_id_prof_fw,
                 i_sched_notes,
                 i_id_complaint_fw,
                 i_reason_for_visit_fw,
                 l_id_consult_req,
                 i_flg_type_closure)
            RETURNING id_discharge_detail INTO o_discharge_detail;
        
        ELSE
        
            g_error := 'CHECK_DISCHARGE (1)';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_discharge.check_discharge(i_lang               => i_lang,
                                                i_prof               => i_prof,
                                                i_episode            => i_episode,
                                                i_can_edt_inact_epis => g_can_edit_inact_epis,
                                                o_error              => o_error)
            THEN
                RAISE pk_discharge.e_check_discharge;
            END IF;
        
            g_error := 'UPDATE DISCHARGE';
            UPDATE discharge
               SET id_prof_med       = nvl(id_prof_med,
                                           decode(i_flg_type,
                                                  g_doctor,
                                                  i_prof.id,
                                                  g_disch_type_casemanager_c,
                                                  i_prof.id,
                                                  NULL)),
                   dt_med_tstz       = nvl(dt_med_tstz,
                                           decode(i_flg_type,
                                                  g_doctor,
                                                  l_med_tstz,
                                                  g_disch_type_casemanager_c,
                                                  g_sysdate_tstz,
                                                  NULL)),
                   notes_med         = nvl(notes_med,
                                           decode(i_flg_type,
                                                  g_doctor,
                                                  i_notes,
                                                  g_disch_type_casemanager_c,
                                                  i_notes,
                                                  NULL)),
                   id_prof_admin     = nvl(decode(l_flg_end_epis, pk_alert_constant.g_yes, i_prof.id, NULL),
                                           id_prof_admin),
                   dt_admin_tstz     = nvl(decode(l_flg_end_epis, pk_alert_constant.g_yes, g_sysdate_tstz, NULL),
                                           dt_admin_tstz),
                   notes_admin       = nvl(decode(l_flg_end_epis, pk_alert_constant.g_yes, i_notes, NULL), notes_admin),
                   id_prof_nurse     = nvl(id_prof_nurse, decode(i_flg_type, g_disch_type_nurse, i_prof.id, NULL)), --SF 29/05/2008 nurse discharge
                   dt_nurse          = nvl(dt_nurse, decode(i_flg_type, g_disch_type_nurse, g_sysdate_tstz, NULL)), --SF 29/05/2008 nurse discharge
                   notes_nurse       = nvl(notes_nurse, decode(i_flg_type, g_disch_type_nurse, i_notes, NULL)), --SF 29/05/2008 nurse discharge
                   id_transp_ent_adm = decode(i_flg_type, g_doctor, NULL, i_transp),
                   price             = i_price,
                   currency          = i_currency,
                   flg_payment       = l_flg_payment,
                   id_prof_therapist = decode(i_flg_type, g_disch_type_therapist_o, i_prof.id, NULL),
                   dt_therapist      = decode(i_flg_type, g_disch_type_therapist_o, g_sysdate_tstz, NULL),
                   notes_therapist   = decode(i_flg_type, g_disch_type_therapist_o, i_notes, NULL),
                   flg_status_adm    = decode(i_flg_type, g_adm, pk_alert_constant.g_active, NULL)
             WHERE id_discharge = l_id
            RETURNING id_disch_reas_dest, dt_med_tstz, dt_admin_tstz, flg_status, dt_pend_active_tstz, id_prof_med INTO l_id_disch_reas, l_dt_med_tstz, l_dt_admin_tstz, l_flag_status, l_dt_pend_active_tstz, l_prof_id;
        
            UPDATE discharge_detail dd
               SET dd.flg_print_report          = i_flg_print_report,
                   dd.id_dep_clin_serv_admiting = i_clin_serv,
                   dd.flg_surgery               = i_flg_surgery,
                   dd.date_surgery_tstz         = pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_surgery, NULL),
                   dd.flg_pat_condition         = i_flg_pat_condition,
                   dd.dt_fw_visit               = i_dt_fw_visit,
                   dd.id_dep_clin_serv_fw       = i_id_dep_clin_serv_fw,
                   dd.id_prof_fw                = i_id_prof_fw,
                   dd.sched_notes               = i_sched_notes,
                   dd.id_complaint_fw           = i_id_complaint_fw,
                   dd.reason_for_visit_fw       = i_reason_for_visit_fw,
                   dd.flg_type_closure          = i_flg_type_closure
             WHERE dd.id_discharge = l_id;
        END IF;
    
        g_error := 'SET DISCHARGE_HIST';
        IF nvl(i_flg_hist, pk_alert_constant.g_yes) = pk_alert_constant.g_yes
        THEN
            pk_discharge_core.set_discharge_hist(i_prof       => i_prof,
                                                 i_discharge  => l_id,
                                                 i_outd_prev  => pk_alert_constant.g_no,
                                                 o_disch_hist => l_id_hist);
        END IF;
    
        g_error := 'GET PATIENT AND VISIT ID';
        BEGIN
            SELECT id_visit, id_patient
              INTO l_id_visit, l_id_patient
              FROM episode
             WHERE id_episode = i_episode;
        EXCEPTION
            WHEN no_data_found THEN
                RAISE l_internal_error;
        END;
    
        -- ALERT-41412: AS (03-06-2011)
        g_error := 'CALL PK_ADVANCED_DIRECTIVES.CANCEL_ADV_DIR_RECURR_PLANS';
        pk_alertlog.log_debug(text => g_error);
        IF NOT pk_advanced_directives.cancel_adv_dir_recurr_plans(i_lang    => i_lang,
                                                                  i_prof    => i_prof,
                                                                  i_patient => l_id_patient,
                                                                  i_episode => i_episode,
                                                                  o_error   => o_error)
        THEN
            RAISE l_common_error;
        END IF;
        -- END ALERT-41412   
    
        g_error := 'SET DISCHARGE NOTES REPORT';
        IF NOT pk_discharge.set_discharge_rep_notes(i_lang      => i_lang,
                                                    i_prof      => i_prof,
                                                    i_episode   => i_episode,
                                                    i_patient   => l_id_patient,
                                                    i_discharge => l_id,
                                                    i_flg_type  => i_flg_letter,
                                                    i_flg_task  => i_flg_task,
                                                    o_error     => o_error)
        THEN
            RAISE l_common_error;
        END IF;
    
        --Nuno Neves 24/12/2010 (ALERT-151966) 
    
        g_error := 'CHECK REQUEST PRINT REPORT';
        IF NOT pk_api_discharge.check_request_print_report(i_lang, i_episode, l_id, i_prof, i_currency, o_error)
        
        THEN
            RAISE l_common_error;
        END IF;
    
        --END (ALERT-151966)
    
        --        IF i_flg_status = g_disch_flg_active THEN
    
        g_error := 'GET auto_presc_cancel';
        SELECT drd.flg_auto_presc_cancel
          INTO l_auto_presc_cancel
          FROM disch_reas_dest drd
         WHERE drd.id_disch_reas_dest = l_id_disch_reas;
    
        -- if configuration for cancel prescription
        --is active.
        IF (l_auto_presc_cancel = pk_alert_constant.g_yes AND i_flg_type = g_doctor)
        THEN
            g_error := 'CALL pk_medication_api.set_interrupt_medication';
            IF NOT pk_api_pfh_in.set_cancel_presc(i_lang       => i_lang,
                                                  i_prof       => profissional(nvl(l_prof_id, i_prof.id),
                                                                               i_prof.institution,
                                                                               i_prof.software),
                                                  i_id_episode => i_episode,
                                                  i_notes      => l_auto_cancel_msg,
                                                  o_error      => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
        --      END IF; 
        -- AS 14-12-2009 (ALERT-62112)
        IF (i_flg_print_report IN (pk_alert_constant.g_yes, g_disch_detail_fpr_s, g_disch_detail_fpr_x))
        THEN
            BEGIN
                o_reports_pat := pk_sysconfig.get_config(i_code_cf => 'PRINT_DISPOSITION_REPORT', i_prof => i_prof);
            EXCEPTION
                WHEN no_data_found THEN
                    o_reports_pat := NULL;
            END;
        ELSE
            o_reports_pat := NULL;
        END IF;
    
        ts_epis_info.upd(id_episode_in           => i_episode,
                         id_disch_reas_dest_in   => l_id_disch_reas,
                         id_disch_reas_dest_nin  => FALSE,
                         dt_med_tstz_in          => l_dt_med_tstz,
                         dt_med_tstz_nin         => FALSE,
                         dt_admin_tstz_in        => l_dt_admin_tstz,
                         dt_admin_tstz_nin       => FALSE,
                         dt_pend_active_tstz_in  => l_dt_pend_active_tstz,
                         dt_pend_active_tstz_nin => FALSE,
                         flg_dsch_status_in      => l_flag_status,
                         flg_dsch_status_nin     => FALSE,
                         rows_out                => l_rowids_ei);
    
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_INFO',
                                      i_rowids       => l_rowids_ei,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('ID_DISCH_REAS_DEST',
                                                                      'DT_MED_TSTZ',
                                                                      'DT_ADMIN_TSTZ',
                                                                      'DT_PEND_ACTIVE_TSTZ',
                                                                      'FLG_DSCH_STATUS'));
    
        l_rowids_ei := table_varchar();
    
        g_error := 'UPDATE FLAGS';
        -- Update flags
        IF i_flg_type IN (g_doctor, g_adm, g_disch_type_nurse, g_disch_type_therapist_o, g_disch_type_casemanager_c) --SF 29/05/2008 nurse discharge
        THEN
            g_error := 'GET EPIS_INFO.FLG_STATUS';
            -- when giving a 2 in 1 discharge the status must be updated to administrative discharge
            IF i_flg_type = g_doctor
               AND l_flg_end_epis = pk_alert_constant.g_yes
            THEN
                l_flg_status_ei := g_adm;
            ELSE
                l_flg_status_ei := i_flg_type;
            END IF;
        
            g_error := 'UPDATE EPIS_INFO';
            ts_epis_info.upd(flg_status_in => l_flg_status_ei,
                             where_in      => 'id_episode =' || i_episode || ' AND flg_status != ''' || l_flg_status_ei || '''',
                             rows_out      => l_rowids_ei);
        
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_INFO',
                                          i_rowids       => l_rowids_ei,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('FLG_STATUS'));
        
            IF i_flg_type = g_disch_type_therapist_o
            THEN
                g_error := 'UPDATE SCHEDULE_INTERVENTION';
                UPDATE schedule_intervention
                   SET flg_state = l_flg_status_ei
                 WHERE id_schedule_intervention IN (SELECT DISTINCT si.id_schedule_intervention
                                                      FROM epis_info v, schedule_intervention si
                                                     WHERE v.id_episode = i_episode
                                                       AND si.id_schedule = v.id_schedule)
                   AND flg_state != l_flg_status_ei;
            ELSIF i_flg_type = g_doctor
            THEN
                -- when registering medical discharge in a nursing episode
                -- set the state to "end of nursing appointment"
                IF l_id_epis_type IN (pk_alert_constant.g_epis_type_nurse_care,
                                      pk_alert_constant.g_epis_type_nurse_outp,
                                      pk_alert_constant.g_epis_type_nurse_pp)
                   AND l_flg_end_epis = pk_alert_constant.g_no
                THEN
                    l_flg_state := pk_grid_amb.g_sched_nurse_end;
                ELSIF l_id_epis_type = pk_alert_constant.g_epis_type_dietitian
                THEN
                    l_flg_state := pk_grid_amb.g_sched_nutri_disch;
                ELSIF l_id_epis_type = pk_alert_constant.g_epis_type_cdc_appointment
                THEN
                    l_flg_state := pk_grid.g_sched_cdc_disch;
                ELSE
                    l_flg_state := l_flg_status_ei;
                END IF;
            
                g_error := 'UPDATE SCHEDULE_OUTP';
                IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                           i_prof           => i_prof,
                                                                           i_id_schedule    => l_id_schedule,
                                                                           i_flg_state      => l_flg_state,
                                                                           i_id_patient     => l_id_patient,
                                                                           i_transaction_id => l_transaction_id,
                                                                           o_error          => o_error)
                THEN
                
                    RAISE l_func_exception;
                END IF;
            
            ELSE
                g_error := 'UPDATE SCHEDULE_OUTP';
                IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                           i_prof           => i_prof,
                                                                           i_id_schedule    => l_id_schedule,
                                                                           i_flg_state      => l_flg_status_ei,
                                                                           i_id_patient     => l_id_patient,
                                                                           i_transaction_id => l_transaction_id,
                                                                           o_error          => o_error)
                THEN
                
                    RAISE l_func_exception;
                END IF;
            END IF;
        
            -- If it is a medical discharge, check for temporary records
            IF i_flg_type = g_doctor
            THEN
            
                pk_inp_util.do_log('PK_BMNG_PBL', 'GET EPISODE XXX BED:' || i_episode);
                IF NOT pk_bmng_pbl.set_episode_bed_status_vacant(i_lang                  => i_lang,
                                                                 i_prof                  => i_prof,
                                                                 i_id_episode            => i_episode,
                                                                 i_transaction_id        => l_transaction_id,
                                                                 i_dt_discharge_schedule => pk_date_utils.date_send_tsz(i_lang,
                                                                                                                        l_dt_med_tstz,
                                                                                                                        i_prof),
                                                                 o_error                 => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                pk_inp_util.do_log('PK_BMNG_PBL', 'SET_BMNG_DISCHARGE:' || i_episode);
                IF NOT pk_bmng_pbl.set_bmng_discharge(i_lang           => i_lang,
                                                      i_prof           => i_prof,
                                                      i_epis           => i_episode,
                                                      i_transaction_id => l_transaction_id,
                                                      o_error          => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                IF l_epis_int = pk_sysconfig.get_config('ID_EPIS_TYPE_INPATIENT', i_prof)
                THEN
                    --l_dep := pk_sysconfig.get_config('ID_DEPARTMENT_INTERNMENT', i_prof);
                    g_error := 'OPEN c_dcs';
                    OPEN c_dcs;
                    FETCH c_dcs
                        INTO l_dcs;
                    CLOSE c_dcs;
                
                    l_type_new_epis := substr(l_type_screen, 1, instr(l_type_screen, '|') - 1);
                
                    g_error := 'CALL PK_INP_EPISODE.CALL_INS_EPISODE_DISCH';
                    IF NOT pk_inp_episode.call_ins_episode_disch(i_lang             => i_lang,
                                                                 i_id_visit         => l_id_visit,
                                                                 i_id_professional  => i_prof,
                                                                 i_epis_type        => NULL,
                                                                 i_id_dep_clin_serv => i_clin_serv,
                                                                 i_id_room          => NULL,
                                                                 i_dt_begin         => g_sysdate_tstz,
                                                                 i_id_episode_ext   => NULL,
                                                                 i_flg_type         => nvl(l_type_new_epis, 'T'),
                                                                 i_type             => 'A',
                                                                 i_dt_surgery       => i_dt_surgery,
                                                                 i_flg_surgery      => i_flg_surgery,
                                                                 i_id_prev_episode  => i_episode,
                                                                 i_transaction_id   => l_transaction_id,
                                                                 o_id_episode       => l_id_epis_int,
                                                                 o_error            => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    -- determine service and speciality
                    SELECT pk_translation.get_translation(i_lang, code_clinical_service),
                           pk_translation.get_translation(i_lang, code_department)
                      INTO l_clinical_desc, l_department_desc
                      FROM dep_clin_serv dcs, clinical_service cli, department dpt
                     WHERE dcs.id_department = dpt.id_department
                       AND dcs.id_clinical_service = cli.id_clinical_service
                       AND dcs.id_dep_clin_serv = i_clin_serv;
                
                    l_sys_alert_event.id_sys_alert        := 26;
                    l_sys_alert_event.id_episode          := i_episode;
                    l_sys_alert_event.id_record           := l_id;
                    l_sys_alert_event.dt_record           := nvl(l_dt_med_tstz, l_med_tstz);
                    l_sys_alert_event.id_professional     := NULL;
                    l_sys_alert_event.id_room             := NULL;
                    l_sys_alert_event.id_clinical_service := NULL;
                    l_sys_alert_event.id_dep_clin_serv    := i_clin_serv;
                    l_sys_alert_event.replace1            := (l_department_desc || '-' || l_clinical_desc);
                
                    IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_sys_alert_event => l_sys_alert_event,
                                                            i_flg_type_dest   => 'D',
                                                            o_error           => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                END IF;
                g_error := 'pk_bmng_pbl - GET EPISODE XXX BED: ' || i_episode;
            END IF;
        
            IF i_flg_type IN (g_adm, g_disch_type_nurse, g_disch_type_therapist_o, g_disch_type_casemanager_c)
               OR l_flg_end_epis = pk_alert_constant.g_yes
            THEN
                --If it is a administrative discharge , if the destination is not a department of the institution, closes the episode and visit.
                -- Otherwise, only closes the episode
                -- cmf 14-09-2007 if exists more than an episode on the visit , the visit cannot be closed only the episode
            
                SELECT COUNT(*)
                  INTO l_count
                  FROM episode
                 WHERE id_visit = l_id_visit
                   AND flg_status NOT IN (g_epis_inactive, g_epis_canc);
            
                g_error := 'GET 1 l_count' || l_count;
            
                -- cmf 09-04-2008 correction adw WO11575
                ts_episode.upd(id_episode_in   => i_episode,
                               flg_status_in   => g_epis_inactive,
                               flg_status_nin  => FALSE,
                               dt_end_tstz_in  => g_sysdate_tstz,
                               dt_end_tstz_nin => FALSE,
                               rows_out        => l_rowids);
            
                -- call the function PROCESS_INSERT DO PACKAGE T_DATA_GOV_MNT
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPISODE',
                                              i_rowids       => l_rowids,
                                              o_error        => o_error,
                                              i_list_columns => table_varchar('flg_status', 'dt_end_tstz'));
            
                IF l_count > 1
                THEN
                    NULL;
                ELSE
                
                    g_error  := 'UPDATE VISIT';
                    l_rowids := table_varchar();
                    ts_visit.upd(flg_status_in   => g_visit_inactive,
                                 flg_status_nin  => FALSE,
                                 dt_end_tstz_in  => g_sysdate_tstz,
                                 dt_end_tstz_nin => FALSE,
                                 where_in        => 'id_visit = (SELECT epis.id_visit
                                FROM episode epis
                               WHERE epis.id_episode = ' || i_episode || ')',
                                 rows_out        => l_rowids);
                
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'VISIT',
                                                  i_rowids       => l_rowids,
                                                  o_error        => o_error,
                                                  i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
                
                    --UPDATE visit
                    --   SET flg_status = g_visit_inactive, dt_end_tstz = g_sysdate_tstz
                    -- WHERE id_visit = (SELECT id_visit
                    --                     FROM episode
                    --                    WHERE id_episode = i_episode);
                    IF NOT pk_bmng_pbl.set_episode_bed_status_vacant(i_lang                  => i_lang,
                                                                     i_prof                  => i_prof,
                                                                     i_id_episode            => i_episode,
                                                                     i_transaction_id        => l_transaction_id,
                                                                     i_dt_discharge_schedule => pk_date_utils.date_send_tsz(i_lang,
                                                                                                                            l_dt_med_tstz,
                                                                                                                            i_prof),
                                                                     o_error                 => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    IF NOT pk_bmng_pbl.set_bmng_discharge(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          i_epis           => i_episode,
                                                          i_transaction_id => l_transaction_id,
                                                          o_error          => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                END IF;
            
                IF i_flg_type != g_disch_type_therapist_o
                   AND i_flg_type != g_disch_type_casemanager_c
                THEN
                
                    FOR r_analysis IN (SELECT ard.id_analysis_req_det, ard.id_analysis_req, ar.id_patient
                                         FROM analysis_req_det ard, analysis_req ar
                                        WHERE ar.id_episode = i_episode
                                          AND ard.id_analysis_req = ar.id_analysis_req)
                    LOOP
                        g_error := 'PK_LAB_TESTS_API_DB.SET_LAB_TEST_GRID_TASK';
                        IF NOT pk_lab_tests_api_db.set_lab_test_grid_task(i_lang             => i_lang,
                                                                          i_prof             => i_prof,
                                                                          i_patient          => r_analysis.id_patient,
                                                                          i_episode          => i_episode,
                                                                          i_analysis_req     => r_analysis.id_analysis_req,
                                                                          i_analysis_req_det => r_analysis.id_analysis_req_det,
                                                                          o_error            => o_error)
                        THEN
                            RAISE l_internal_error;
                        END IF;
                    END LOOP;
                
                    FOR r_exam IN (SELECT erd.id_exam_req_det, erd.id_exam_req, erd.id_exam, er.id_episode
                                     FROM exam_req_det erd, exam_req er
                                    WHERE er.id_episode = i_episode
                                      AND erd.id_exam_req = er.id_exam_req)
                    LOOP
                    
                        g_error := 'PK_EXAMS_API_DB.SET_EXAM_GRID_TASK';
                        IF NOT pk_exams_api_db.set_exam_grid_task(i_lang         => i_lang,
                                                                  i_prof         => i_prof,
                                                                  i_patient      => NULL,
                                                                  i_episode      => i_episode,
                                                                  i_exam_req     => r_exam.id_exam_req,
                                                                  i_exam_req_det => r_exam.id_exam_req_det,
                                                                  o_error        => o_error)
                        THEN
                            RAISE l_internal_error;
                        END IF;
                    END LOOP;
                
                END IF;
                l_can_refresh_mviews := TRUE;
            
            END IF;
        
            -- Valida necessidade de criação de alerta
            -- Válido para os alertas 30 e 31
        
            IF NOT set_disch_edis_to_inp_alert(i_lang, i_prof, i_episode, o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            -- Inactivate empty time columns at flowsheets
            IF NOT pk_periodic_observation.set_po_param_reg_inactive(i_lang    => i_lang,
                                                                     i_prof    => i_prof,
                                                                     i_patient => l_id_patient,
                                                                     i_episode => i_episode,
                                                                     o_error   => o_error)
            
            THEN
                RAISE l_internal_error;
            END IF;
        
            -- update the information of observations
            -- José Brito 14/11/2008 ALERT-8235
            -- the call for function SET_FIRST_OBS is made at the end, but the date is given at the begin of the function
            -- to avoid the risk having DT_FIRST_OBS higher than clinical discharge date.
            g_error := ' pk_visit.set_first_obs';
        
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => i_episode,
                                          i_pat                 => l_id_patient,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => i_prof_cat_type,
                                          i_dt_last_interaction => l_sysdate_tstz,
                                          i_dt_first_obs        => l_sysdate_tstz,
                                          o_error               => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            -- explicit refresh os mview
            IF l_can_refresh_mviews
            THEN
                pk_episode.update_mv_episodes();
            END IF;
        END IF;
    
        IF l_id_epis_type IN
           (pk_alert_constant.g_epis_type_rehab_session, pk_alert_constant.g_epis_type_rehab_appointment)
        THEN
            l_from_state := pk_rehab.g_rehab_epis_enc_status_s;
            l_to_state   := pk_rehab.g_rehab_epis_enc_status_o;
            -- REHAB
            IF l_id_epis_type = pk_alert_constant.g_epis_type_rehab_session
               AND l_id_schedule <> -1
            THEN
            
                l_wf_type := pk_rehab.g_workflow_type_s;
            ELSIF l_id_epis_type = pk_alert_constant.g_epis_type_rehab_session
                  AND l_id_schedule = -1
            THEN
                l_wf_type := pk_rehab.g_workflow_type_w;
            ELSE
                l_wf_type := pk_rehab.g_workflow_type_a;
            END IF;
            IF l_wf_type <> pk_rehab.g_workflow_type_w
            THEN
                IF NOT set_rehab_wf(i_wf_type => l_wf_type, i_from_state => l_from_state, i_to_state => l_to_state)
                THEN
                    pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                    RETURN FALSE;
                END IF;
            END IF;
        END IF;
    
        g_error := 'CALL TO REMOVE ALL EXISTING PRINT JOBS IN THE PRINTING LIST';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.cancel_disch_print_jobs(i_lang               => i_lang,
                                                    i_prof               => i_prof,
                                                    i_patient            => l_id_patient,
                                                    i_episode            => i_episode,
                                                    o_id_print_list_jobs => l_id_print_list_jobs,
                                                    o_error              => o_error)
        THEN
            RAISE l_cancel_print_jobs_excpt;
        END IF;
    
        o_id_episode := l_id_epis_int;
    
        IF (i_transaction_id IS NULL)
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
    
        IF i_flg_print_report IN (g_disch_detail_fpr_s)
        THEN
            g_error := 'OPEN c_discharge_report_cfg';
            OPEN c_discharge_report_cfg(l_id);
            FETCH c_discharge_report_cfg BULK COLLECT
                INTO l_table_disch_rep_cfg;
            CLOSE c_discharge_report_cfg;
            FOR i IN 1 .. l_table_disch_rep_cfg.count
            LOOP
                l_rec_disch_rep_cfg := l_table_disch_rep_cfg(i);
            
                IF (l_rec_disch_rep_cfg.flg_send = pk_alert_constant.g_yes OR
                   l_rec_disch_rep_cfg.flg_send_to_crm = pk_alert_constant.g_yes)
                   AND l_rec_disch_rep_cfg.id_report IS NOT NULL
                THEN
                    g_error := 'pk_print_tool.request_gen_report';
                    l_ret   := pk_print_tool.request_gen_report(i_id_episode         => i_episode,
                                                                i_id_patient         => l_id_patient,
                                                                i_id_institution     => i_prof.institution,
                                                                i_id_language        => i_lang,
                                                                i_id_report_type     => l_rec_disch_rep_cfg.id_report,
                                                                i_id_sections        => 'null',
                                                                i_id_professional    => i_prof.id,
                                                                i_id_software        => i_prof.software,
                                                                i_flag_report_origin => 'null');
                
                    g_error := 'ts_discharge_report.ins: id_discharge: ' || l_id || ', id_report: ' ||
                               l_rec_disch_rep_cfg.id_report;
                
                    ts_discharge_report.ins(id_discharge_in => l_id,
                                            id_report_in    => l_rec_disch_rep_cfg.id_report,
                                            flg_status_in   => pk_discharge_crm.g_flg_status_crm_req,
                                            rows_out        => l_disch_rep_rowids);
                END IF;
            END LOOP;
        END IF;
        g_error      := 'CALL PK_PRINT_LIST_DB.GET_PRINT_LIST_JOBS';
        l_print_jobs := pk_print_list_db.get_print_list_jobs(i_lang            => i_lang,
                                                             i_prof            => i_prof,
                                                             i_patient         => l_id_patient,
                                                             i_episode         => i_episode,
                                                             i_print_list_area => NULL);
    
        IF l_print_jobs.exists(1)
           OR (i_flg_print_report IN (pk_alert_constant.g_yes, g_disch_detail_fpr_s, g_disch_detail_fpr_x))
        THEN
            o_id_shortcut := pk_print_list_db.g_print_list_id_shortcut_pat;
        ELSE
            IF pk_tools.get_prof_cat(i_prof) = pk_alert_constant.g_cat_type_doc
            THEN
                o_id_shortcut := nvl(pk_sysconfig.get_config('DISPOSITION_SHORTCUT', i_prof), 38);
            ELSE
                o_id_shortcut := nvl(pk_sysconfig.get_config('DISPOSITION_SHORTCUT_NURSE', i_prof), 38);
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_err_date_begin THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   'DISCHARGE_M020',
                                   l_error_message,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_DISCHARGE_NO_COMMIT',
                                   NULL,
                                   'U',
                                   'COMMON_T013');
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                pk_alert_exceptions.reset_error_state;
                RETURN FALSE;
            END;
        WHEN pk_discharge.e_check_discharge THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN l_common_error THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_DISCHARGE',
                                   NULL,
                                   'U');
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_alert_exceptions.reset_error_state();
            
                pk_utils.undo_changes; -- ROLLBACK
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                RETURN FALSE;
            END;
        
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_NO_COMMIT',
                                              o_error);
        
            pk_alert_exceptions.reset_error_state();
            pk_utils.undo_changes; -- ROLLBACK
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
        
        WHEN l_cancel_print_jobs_excpt THEN
            pk_alert_exceptions.reset_error_state();
            pk_utils.undo_changes; -- ROLLBACK
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_NO_COMMIT',
                                              o_error);
        
            pk_utils.undo_changes; -- ROLLBACK                                              
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
    END set_discharge_no_commit;
    --
    /**
    * Sets medical discharge info in enviroments where price is specified.
    *
    * @param   I_LANG language associated to the professional executing the request
    * @param   I_EPISODE episode id
    * @param   I_PROF  professional, institution and software ids
    * @param   I_REAS_DEST discharge reason by destination
    * @param   I_DISCH_TYPE Idischarge type
    * @param   I_FLG_TYPE flag type
    * @param   I_NOTES discharge notes
    * @param   I_TRANSP transport id
    * @param   I_JUSTIFY discharge justify
    * @param   I_PRICE appointment price
    * @param   I_CURRENCY appointment price currency
    * @param   I_FLG_PAYMENT payment condition
    * @param   I_FLG_SURGERY  Y/N, INDICA SE É PRECISO CRIAR CIRURGIA
    * @param   I_FLG_SURGERY - indicates if discharge for internment is associated to a surgery (Y/N)
    * @param   I_CLIN_SERV - id_clinical_service of internment speciality, in case od discharge for internment
    * @param   i_flg_print_report - flg print report
    * @param   i_flg_letter - type of discharge letter: P - print discharge letter; S - send discharge letter message
    * @param   i_flg_task - list of tasks associated with the discharge letter
    
    * @param   O_FLG_SHOW does it shows buttons
    * @param   O_MSG_TITLE warning/error message title
    * @param   O_MSG_TEXT warning/error message
    * @param   O_BUTTON OUT the buttons to show in the warning/error
    *
    * @RETURN  TRUE if sucess, FALSE otherwise
    * @author  Luis Gaspar
    * @version 1.0
    * @since   24-Jan-2006
    * NOTAS: LG 2007-fev-08
    */
    FUNCTION set_discharge_no_commit
    (
        i_lang             IN language.id_language%TYPE,
        i_episode          IN discharge.id_episode%TYPE,
        i_prof             IN profissional,
        i_reas_dest        IN discharge.id_disch_reas_dest%TYPE,
        i_disch_type       IN discharge.flg_type%TYPE,
        i_flg_type         IN VARCHAR2,
        i_notes            IN discharge.notes_med%TYPE,
        i_transp           IN transp_entity.id_transp_entity%TYPE,
        i_justify          IN discharge.notes_justify %TYPE,
        i_prof_cat_type    IN category.flg_type%TYPE,
        i_price            IN discharge.price%TYPE,
        i_currency         IN discharge.currency%TYPE,
        i_flg_payment      IN discharge.flg_payment%TYPE,
        i_flg_surgery      IN VARCHAR2,
        i_dt_surgery       IN VARCHAR2,
        i_clin_serv        IN clinical_service.id_clinical_service%TYPE,
        i_department       IN department.id_department%TYPE,
        i_transaction_id   IN VARCHAR2,
        i_flg_bill_type    IN discharge.flg_bill_type%TYPE,
        i_flg_print_report IN discharge_detail.flg_print_report%TYPE DEFAULT NULL,
        i_flg_letter       IN discharge_rep_notes.flg_type%TYPE,
        i_flg_task         IN discharge_rep_notes.flg_task%TYPE,
        i_flg_hist         IN VARCHAR2,
        i_dt_med           IN VARCHAR2 DEFAULT NULL,
        i_flg_type_closure IN discharge_detail.flg_type_closure%TYPE DEFAULT NULL,
        o_reports_pat      OUT reports.id_reports%TYPE,
        o_flg_show         OUT VARCHAR2,
        o_msg_title        OUT VARCHAR2,
        o_msg_text         OUT VARCHAR2,
        o_button           OUT VARCHAR2,
        o_id_episode       OUT episode.id_episode%TYPE,
        o_id_shortcut      OUT sys_shortcut.id_sys_shortcut%TYPE,
        o_discharge        OUT discharge.id_discharge%TYPE,
        o_discharge_detail OUT discharge_detail.id_discharge_detail%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN set_discharge_no_commit(i_lang                => i_lang,
                                       i_episode             => i_episode,
                                       i_prof                => i_prof,
                                       i_reas_dest           => i_reas_dest,
                                       i_disch_type          => i_disch_type,
                                       i_flg_type            => i_flg_type,
                                       i_notes               => i_notes,
                                       i_transp              => i_transp,
                                       i_justify             => i_justify,
                                       i_prof_cat_type       => i_prof_cat_type,
                                       i_price               => i_price,
                                       i_currency            => i_currency,
                                       i_flg_payment         => i_flg_payment,
                                       i_flg_surgery         => i_flg_surgery,
                                       i_dt_surgery          => i_dt_surgery,
                                       i_clin_serv           => i_clin_serv,
                                       i_department          => i_department,
                                       i_flg_bill_type       => i_flg_bill_type,
                                       i_flg_print_report    => i_flg_print_report,
                                       i_flg_letter          => i_flg_letter,
                                       i_flg_task            => i_flg_task,
                                       i_transaction_id      => i_transaction_id,
                                       i_sysdate             => NULL,
                                       i_flg_pat_condition   => NULL,
                                       i_flg_hist            => i_flg_hist,
                                       i_dt_fw_visit         => NULL,
                                       i_id_dep_clin_serv_fw => NULL,
                                       i_id_prof_fw          => NULL,
                                       i_sched_notes         => NULL,
                                       i_id_complaint_fw     => NULL,
                                       i_reason_for_visit_fw => NULL,
                                       i_dt_med              => i_dt_med,
                                       i_flg_type_closure    => i_flg_type_closure,
                                       o_reports_pat         => o_reports_pat,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg_text            => o_msg_text,
                                       o_button              => o_button,
                                       o_id_episode          => o_id_episode,
                                       o_id_shortcut         => o_id_shortcut,
                                       o_discharge           => o_discharge,
                                       o_discharge_detail    => o_discharge_detail,
                                       o_error               => o_error);
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_NO_COMMIT',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_discharge_no_commit;

    FUNCTION set_discharge_no_commit
    (
        i_lang           IN language.id_language%TYPE,
        i_episode        IN discharge.id_episode%TYPE,
        i_prof           IN profissional,
        i_reas_dest      IN discharge.id_disch_reas_dest%TYPE,
        i_disch_type     IN discharge.flg_type%TYPE,
        i_flg_type       IN VARCHAR2,
        i_notes          IN discharge.notes_med%TYPE,
        i_transp         IN transp_entity.id_transp_entity%TYPE,
        i_justify        IN discharge.notes_justify %TYPE,
        i_prof_cat_type  IN category.flg_type%TYPE,
        i_price          IN discharge.price%TYPE,
        i_currency       IN discharge.currency%TYPE,
        i_flg_payment    IN discharge.flg_payment%TYPE,
        i_flg_surgery    IN VARCHAR2,
        i_dt_surgery     IN VARCHAR2,
        i_clin_serv      IN clinical_service.id_clinical_service%TYPE,
        i_department     IN department.id_department%TYPE,
        i_transaction_id IN VARCHAR2,
        i_flg_bill_type  IN discharge.flg_bill_type%TYPE,
        -- AS 14-12-2009 (ALERT-62112)
        i_flg_print_report  IN discharge_detail.flg_print_report%TYPE DEFAULT NULL,
        i_flg_letter        IN discharge_rep_notes.flg_type%TYPE,
        i_flg_task          IN discharge_rep_notes.flg_task%TYPE,
        i_sysdate           IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_pat_condition IN discharge_detail.flg_pat_condition%TYPE,
        i_flg_hist          IN VARCHAR2,
        --- CMF
        i_flg_type_closure IN discharge_detail.flg_type_closure%TYPE DEFAULT NULL,
        ---
        o_reports_pat      OUT reports.id_reports%TYPE,
        o_flg_show         OUT VARCHAR2,
        o_msg_title        OUT VARCHAR2,
        o_msg_text         OUT VARCHAR2,
        o_button           OUT VARCHAR2,
        o_id_episode       OUT episode.id_episode%TYPE,
        o_id_shortcut      OUT sys_shortcut.id_sys_shortcut%TYPE,
        o_discharge        OUT discharge.id_discharge%TYPE,
        o_discharge_detail OUT discharge_detail.id_discharge_detail%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN set_discharge_no_commit(i_lang                => i_lang,
                                       i_episode             => i_episode,
                                       i_prof                => i_prof,
                                       i_reas_dest           => i_reas_dest,
                                       i_disch_type          => i_disch_type,
                                       i_flg_type            => i_flg_type,
                                       i_notes               => i_notes,
                                       i_transp              => i_transp,
                                       i_justify             => i_justify,
                                       i_prof_cat_type       => i_prof_cat_type,
                                       i_price               => i_price,
                                       i_currency            => i_currency,
                                       i_flg_payment         => i_flg_payment,
                                       i_flg_surgery         => i_flg_surgery,
                                       i_dt_surgery          => i_dt_surgery,
                                       i_clin_serv           => i_clin_serv,
                                       i_department          => i_department,
                                       i_flg_bill_type       => i_flg_bill_type,
                                       i_flg_print_report    => i_flg_print_report,
                                       i_flg_letter          => i_flg_letter,
                                       i_flg_task            => i_flg_task,
                                       i_transaction_id      => i_transaction_id,
                                       i_sysdate             => NULL,
                                       i_flg_pat_condition   => NULL,
                                       i_flg_hist            => i_flg_hist,
                                       i_dt_fw_visit         => NULL,
                                       i_id_dep_clin_serv_fw => NULL,
                                       i_id_prof_fw          => NULL,
                                       i_sched_notes         => NULL,
                                       i_id_complaint_fw     => NULL,
                                       i_reason_for_visit_fw => NULL,
                                       i_dt_med              => NULL,
                                       --cmf
                                       i_flg_type_closure => i_flg_type_closure,
                                       o_reports_pat      => o_reports_pat,
                                       o_flg_show         => o_flg_show,
                                       o_msg_title        => o_msg_title,
                                       o_msg_text         => o_msg_text,
                                       o_button           => o_button,
                                       o_id_episode       => o_id_episode,
                                       o_id_shortcut      => o_id_shortcut,
                                       o_discharge        => o_discharge,
                                       o_discharge_detail => o_discharge_detail,
                                       o_error            => o_error);
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_NO_COMMIT',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_discharge_no_commit;
    --
    /**
    * Sets medical discharge info in enviroments where price is specified.
    *
    * @param   I_LANG language associated to the professional executing the request
    * @param   I_EPISODE episode id
    * @param   I_PROF  professional, institution and software ids
    * @param   I_REAS_DEST discharge reason by destination
    * @param   I_DISCH_TYPE Idischarge type
    * @param   I_FLG_TYPE flag type
    * @param   I_NOTES discharge notes
    * @param   I_TRANSP transport id
    * @param   I_JUSTIFY discharge justify
    * @param   I_PRICE appointment price
    * @param   I_CURRENCY appointment price currency
    * @param   I_FLG_PAYMENT payment condition
    * @param   I_FLG_SURGERY  Y/N, INDICA SE É PRECISO CRIAR CIRURGIA
    * @param   I_FLG_SURGERY - indicates if discharge for internment is associated to a surgery (Y/N)
    * @param   I_CLIN_SERV - id_clinical_service of internment speciality, in case od discharge for internment
    * @param   O_FLG_SHOW does it shows buttons
    * @param   O_MSG_TITLE warning/error message title
    * @param   O_MSG_TEXT warning/error message
    * @param   O_BUTTON OUT the buttons to show in the warning/error
    *
    * @RETURN  TRUE if sucess, FALSE otherwise
    * @author  Luis Gaspar
    * @version 1.0
    * @since   24-Jan-2006
    * NOTAS: LG 2007-fev-08
    */
    FUNCTION set_discharge
    (
        i_lang          IN language.id_language%TYPE,
        i_episode       IN discharge.id_episode%TYPE,
        i_prof          IN profissional,
        i_reas_dest     IN discharge.id_disch_reas_dest%TYPE,
        i_disch_type    IN discharge.flg_type%TYPE,
        i_flg_type      IN VARCHAR2,
        i_notes         IN discharge.notes_med%TYPE,
        i_transp        IN transp_entity.id_transp_entity%TYPE,
        i_justify       IN discharge.notes_justify %TYPE,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_price         IN discharge.price%TYPE,
        i_currency      IN discharge.currency%TYPE,
        i_flg_payment   IN discharge.flg_payment%TYPE,
        i_flg_surgery   IN VARCHAR2,
        i_clin_serv     IN clinical_service.id_clinical_service%TYPE,
        i_department    IN department.id_department%TYPE,
        o_flg_show      OUT VARCHAR2,
        o_msg_title     OUT VARCHAR2,
        o_msg_text      OUT VARCHAR2,
        o_button        OUT VARCHAR2,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_ret          BOOLEAN;
        l_id_episode   episode.id_episode%TYPE;
        l_reports_pat  reports.id_reports%TYPE;
        l_discharge    discharge.id_discharge%TYPE;
        l_disch_detail discharge_detail.id_discharge_detail%TYPE;
        l_id_shortcut  sys_shortcut.id_sys_shortcut%TYPE;
        --Scheduler 3.0 transaction ID
        l_transaction_id VARCHAR2(4000);
        l_internal_error EXCEPTION;
    BEGIN
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(l_transaction_id, i_prof);
    
        l_ret := pk_alerts.delete_sys_alert_event_episode(i_lang    => i_lang,
                                                          i_prof    => i_prof,
                                                          i_episode => i_episode,
                                                          i_delete  => 'Y',
                                                          o_error   => o_error);
    
        l_ret := set_discharge_no_commit(i_lang             => i_lang,
                                         i_episode          => i_episode,
                                         i_prof             => i_prof,
                                         i_reas_dest        => i_reas_dest,
                                         i_disch_type       => i_disch_type,
                                         i_flg_type         => i_flg_type,
                                         i_notes            => i_notes,
                                         i_transp           => i_transp,
                                         i_justify          => i_justify,
                                         i_prof_cat_type    => i_prof_cat_type,
                                         i_price            => i_price,
                                         i_currency         => i_currency,
                                         i_flg_payment      => i_flg_payment,
                                         i_flg_surgery      => i_flg_surgery,
                                         i_dt_surgery       => NULL,
                                         i_clin_serv        => i_clin_serv,
                                         i_department       => i_department,
                                         i_flg_bill_type    => NULL,
                                         i_flg_letter       => NULL,
                                         i_flg_task         => NULL,
                                         i_transaction_id   => l_transaction_id,
                                         i_flg_hist         => pk_alert_constant.g_yes,
                                         o_reports_pat      => l_reports_pat,
                                         o_flg_show         => o_flg_show,
                                         o_msg_title        => o_msg_title,
                                         o_msg_text         => o_msg_text,
                                         o_button           => o_button,
                                         o_id_episode       => l_id_episode,
                                         o_id_shortcut      => l_id_shortcut,
                                         o_discharge        => l_discharge,
                                         o_discharge_detail => l_disch_detail,
                                         o_error            => o_error);
    
        IF NOT l_ret
        THEN
            RAISE l_internal_error;
        END IF;
    
        COMMIT;
        pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        RETURN l_ret;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
    END set_discharge;
    --
    FUNCTION set_nurse_discharge
    (
        i_lang    IN language.id_language%TYPE,
        i_episode IN nurse_discharge.id_episode%TYPE,
        i_prof    IN profissional,
        i_notes   IN nurse_discharge.notes%TYPE,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Criar registo de alta de enfermagem (NURSE_DISCHARGE ).
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                                    I_EPISODE - ID do episódio
                                    I_PROF - profissional q regista
                                      I_NOTES - notas
                                      I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                                                    como é retornada em PK_LOGIN.GET_PROF_PREF
                        Saida:   O_ERROR - erro
        
          CRIAÇÃO: RB 2005/05/05
          NOTAS:Sílvia Freitas 2008/05/29
                Apartir desta função vai ser chamada a função de alta set discharge, para fechar as consultas de enfermagem no Care
                
        *********************************************************************************/
        --l_exist              VARCHAR2(1);
        --l_temp               VARCHAR2(1);
        --l_id                 epis_recomend.id_epis_recomend%TYPE;
        l_id_nurse_discharge nurse_discharge.id_nurse_discharge%TYPE;
        --l_next               nurse_discharge.id_nurse_discharge%TYPE;
    
        -- --SF 29/05/2008 alta de enfermagem
        CURSOR c_epis_type IS
            SELECT id_epis_type
              FROM episode
             WHERE id_episode = i_episode;
        --
        l_epis_type             epis_type.id_epis_type%TYPE;
        l_epis_type_nurse       epis_type.id_epis_type%TYPE;
        l_disch_reas_dest_nurse disch_reas_dest.id_disch_reas_dest%TYPE;
    
        l_flg_show  VARCHAR2(200);
        l_msg_title VARCHAR2(200);
        l_msg_text  VARCHAR2(200);
        l_button    VARCHAR2(200);
    
        l_internal_error EXCEPTION;
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
        l_id_schedule    schedule.id_schedule%TYPE;
        l_func_exception EXCEPTION;
    BEGIN
        g_error        := 'INSERT EPIS_RECOMEND';
        g_sysdate_tstz := current_timestamp;
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(l_transaction_id, i_prof);
    
        g_error := 'GET SCHEDULE ID';
        BEGIN
            SELECT DISTINCT v.id_schedule
              INTO l_id_schedule
              FROM epis_info v
             WHERE v.id_episode = i_episode;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_schedule := NULL;
        END;
    
        ----SF 29/05/2008 alta de enfermagem
        l_epis_type_nurse       := pk_sysconfig.get_config('ID_EPIS_TYPE_NURSE', i_prof);
        l_disch_reas_dest_nurse := pk_sysconfig.get_config('DEFAULT_DISCH_REAS_DEST_NURSE', i_prof);
    
        g_error := 'OPEN C_EPIS_TYPE';
        OPEN c_epis_type;
        FETCH c_epis_type
            INTO l_epis_type;
        CLOSE c_epis_type;
    
        g_error              := 'GET SEQ_NURSE_DISCHARGE.NEXTVAL';
        l_id_nurse_discharge := seq_nurse_discharge.nextval;
        --
        g_error := 'UPDATE NURSE_DISCHARGE';
        INSERT INTO nurse_discharge
            (id_nurse_discharge, dt_nurse_discharge_tstz, id_professional, id_episode, notes, flg_temp)
        VALUES
            (l_id_nurse_discharge, g_sysdate_tstz, i_prof.id, i_episode, i_notes, g_flg_def);
        --
        --
        -- nurse discharge record is closed so send the event
        g_error := 'CALL TO PK_IA_EVENT_COMMIN';
        pk_ia_event_common.nurse_discharge_notes_new(i_id_institution     => i_prof.institution,
                                                     i_id_nurse_discharge => l_id_nurse_discharge);
        --
        g_error := 'CALLING SET_FIRST_OBS';
        --Actualiza dados das observações
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        g_error := 'CALLING SET_DISCHARGE 1';
        ------SF 29/05/2008 alta de enfermagem    
        IF l_epis_type = l_epis_type_nurse
        THEN
            g_error := 'CALLING SET_DISCHARGE 2';
            IF NOT set_discharge(i_lang          => i_lang,
                                 i_episode       => i_episode,
                                 i_prof          => i_prof,
                                 i_reas_dest     => l_disch_reas_dest_nurse,
                                 i_disch_type    => g_disch_type_f,
                                 i_flg_type      => g_disch_type_nurse,
                                 i_notes         => NULL,
                                 i_transp        => NULL,
                                 i_justify       => NULL,
                                 i_prof_cat_type => NULL,
                                 i_flg_surgery   => NULL,
                                 i_clin_serv     => NULL,
                                 i_department    => NULL,
                                 o_flg_show      => l_flg_show,
                                 o_msg_title     => l_msg_title,
                                 o_msg_text      => l_msg_text,
                                 o_button        => l_button,
                                 o_error         => o_error)
            
            THEN
                RAISE l_internal_error;
            END IF;
        ELSE
            g_error := 'UPDATE SCHEDULE_OUTP';
            IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                       i_prof           => i_prof,
                                                                       i_id_schedule    => l_id_schedule,
                                                                       i_flg_state      => g_disch_type_nurse,
                                                                       i_transaction_id => l_transaction_id,
                                                                       o_error          => o_error)
            THEN
            
                RAISE l_func_exception;
            END IF;
        
            g_error := 'CALLING PK_WLCORE.SET_DISCHARGE_INTERNAL';
            IF NOT pk_wlcore.set_discharge_internal(i_lang, i_prof, i_episode, o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        COMMIT;
        pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_NURSE_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_NURSE_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_nurse_discharge;
    --
    /**********************************************************************************************
    *  End of session MFR
    *
    * @param i_lang                   language ID
    * @param i_episode                Id episode
    * @param i_prof                   Professional details
    * @param i_notes                   Notes discharge
    * @param o_error                  Error message
    *
    * @return                         True on success, false otherwise
    *                        
    * @author                         Rita Lopes
    * @version                        2.4.3
    * @since                          2008/06/25
    **********************************************************************************************/

    FUNCTION set_therapist_discharge
    (
        i_lang    IN language.id_language%TYPE,
        i_episode IN nurse_discharge.id_episode%TYPE,
        i_prof    IN profissional,
        i_notes   IN discharge.notes_therapist%TYPE,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- --SF 29/05/2008 alta de enfermagem
        CURSOR c_epis_type IS
            SELECT id_epis_type
              FROM episode
             WHERE id_episode = i_episode;
        --
        l_epis_type                 epis_type.id_epis_type%TYPE;
        l_epis_type_therapist       epis_type.id_epis_type%TYPE;
        l_disch_reas_dest_therapist disch_reas_dest.id_disch_reas_dest%TYPE;
    
        l_flg_show  VARCHAR2(200);
        l_msg_title VARCHAR2(200);
        l_msg_text  VARCHAR2(200);
        l_button    VARCHAR2(200);
    
        l_internal_error EXCEPTION;
    BEGIN
        g_sysdate_tstz              := current_timestamp;
        l_epis_type_therapist       := pk_sysconfig.get_config('ID_EPIS_TYPE_TEHRAPIST', i_prof);
        l_disch_reas_dest_therapist := pk_sysconfig.get_config('DEFAULT_DISCH_REAS_DEST_THERAPIST', i_prof);
    
        g_error := 'OPEN C_EPIS_TYPE';
        OPEN c_epis_type;
        FETCH c_epis_type
            INTO l_epis_type;
        CLOSE c_epis_type;
    
        g_error := 'CALLING SET_DISCHARGE 1';
        IF l_epis_type = l_epis_type_therapist
        THEN
            g_error := 'CALLING SET_DISCHARGE 2';
            IF NOT set_discharge(i_lang          => i_lang,
                                 i_episode       => i_episode,
                                 i_prof          => i_prof,
                                 i_reas_dest     => l_disch_reas_dest_therapist,
                                 i_disch_type    => g_disch_type_therapist_f,
                                 i_flg_type      => g_disch_type_therapist_o,
                                 i_notes         => NULL,
                                 i_transp        => NULL,
                                 i_justify       => NULL,
                                 i_prof_cat_type => NULL,
                                 i_flg_surgery   => NULL,
                                 i_clin_serv     => NULL,
                                 i_department    => NULL,
                                 o_flg_show      => l_flg_show,
                                 o_msg_title     => l_msg_title,
                                 o_msg_text      => l_msg_text,
                                 o_button        => l_button,
                                 o_error         => o_error)
            
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        --Actualiza dados das observações
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        --
        COMMIT;
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_THERAPIST_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_THERAPIST_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_therapist_discharge;
    --
    FUNCTION cancel_nurse_discharge
    (
        i_lang               IN language.id_language%TYPE,
        i_id_nurse_discharge IN nurse_discharge.id_nurse_discharge%TYPE,
        i_prof               IN profissional,
        i_notes              IN nurse_discharge.notes%TYPE,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Cancela alta de enfermagem (NURSE_DISCHARGE ).
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                                    I_EPISODE - ID do episódio
                                    I_PROF - profissional q regista
                                      I_NOTES - notas
                                      I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                                                    como é retornada em PK_LOGIN.GET_PROF_PREF
                        Saida:   O_ERROR - erro
        
          CRIAÇÃO: RB 2005/05/05
          NOTAS:
        *********************************************************************************/
        l_epis nurse_discharge.id_episode%TYPE;
    
        l_internal_error EXCEPTION;
    
    BEGIN
        g_error        := 'CANCEL NURSE DISCHARGE';
        g_sysdate_tstz := current_timestamp;
        --
        UPDATE nurse_discharge
           SET dt_cancel_tstz = g_sysdate_tstz, id_prof_cancel = i_prof.id, notes_cancel = i_notes
         WHERE id_nurse_discharge = i_id_nurse_discharge;
        --
        SELECT nd.id_episode
          INTO l_epis
          FROM nurse_discharge nd
         WHERE nd.id_nurse_discharge = i_id_nurse_discharge;
        --
        --Actualiza dados das observações
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_epis,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        --
        COMMIT;
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_NURSE_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_NURSE_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END cancel_nurse_discharge;
    --

    FUNCTION get_discharge
    (
        i_lang                 IN language.id_language%TYPE,
        i_episode              IN discharge.id_episode%TYPE,
        i_prof                 IN profissional,
        i_category_type        IN category.flg_type%TYPE,
        i_flg_type             IN VARCHAR2,
        o_disch                OUT pk_types.cursor_type,
        o_flg_show             OUT VARCHAR2,
        o_msg_title            OUT VARCHAR2,
        o_msg_text             OUT VARCHAR2,
        o_button               OUT VARCHAR2,
        o_flg_create           OUT VARCHAR2,
        o_sync_client_registry OUT VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_cosign_disp  sys_config.value%TYPE;
        l_cosign_count NUMBER(6);
    
        l_prof_cat         category.flg_type%TYPE;
        l_exists_discharge VARCHAR2(1 CHAR);
        l_type_disch       VARCHAR2(1 CHAR);
        l_flg_type         VARCHAR2(1 CHAR);
    
        l_sa_client_registry sys_config.value%TYPE;
        l_health_id_count    NUMBER(6);
        l_count_discharge    NUMBER;
        l_id_epis_type       episode.id_epis_type%TYPE;
        l_area_access        ehr_access_area_def.area%TYPE := 'INP_EPIS';
        l_acess_permission   VARCHAR2(1 CHAR);
    
    BEGIN
        -- Check if dispostion without co-sign is allowed
        l_cosign_disp := pk_sysconfig.get_config('ALLOW_DISPOSITION_WITHOUT_COSIGN', i_prof);
        l_prof_cat    := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
    
        IF i_flg_type IS NOT NULL
        THEN
            l_flg_type := i_flg_type;
            --   ELSE
            --       l_flg_type := 'R';
        END IF;
        g_error        := 'CALL pk_episode.get_epis_type';
        l_id_epis_type := pk_episode.get_epis_type(i_lang => i_lang, i_id_epis => i_episode);
        IF l_cosign_disp = g_no
           AND l_prof_cat <> g_adm_cat
        THEN
            -- Check if there are tasks with pending co-sign
            SELECT COUNT(1)
              INTO l_cosign_count
              FROM TABLE(pk_co_sign_api.tf_pending_co_sign_tasks(i_lang    => i_lang,
                                                                 i_prof    => i_prof,
                                                                 i_episode => i_episode)) c;
        
            IF l_cosign_count > 0
            THEN
                -- There are tasks with pending co-sign. Execution is stopped, so that
                -- the application returns to the co-sign screen.
                o_flg_show  := 'Y';
                o_msg_title := pk_message.get_message(i_lang, 'DISPOSITION_NOCOSIGN_T001');
                o_msg_text  := pk_message.get_message(i_lang, 'DISPOSITION_NOCOSIGN_M001');
                o_button    := 'C';
                pk_types.open_my_cursor(o_disch);
                RETURN TRUE;
            ELSE
                o_flg_show := 'N';
            END IF;
        END IF;
        IF NOT pk_discharge.check_exists_disch_type(i_lang        => i_lang,
                                                    i_prof        => i_prof,
                                                    i_episode     => i_episode,
                                                    i_flg_type    => NULL,
                                                    o_exist_disch => l_exists_discharge,
                                                    o_type        => l_type_disch,
                                                    o_error       => o_error)
        THEN
            RAISE g_exception;
        END IF;
        IF NOT pk_ehr_access.check_area_create_permission(i_lang    => i_lang,
                                                          i_prof    => i_prof,
                                                          i_episode => i_episode,
                                                          i_area    => l_area_access,
                                                          o_val     => l_acess_permission,
                                                          o_error   => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF l_acess_permission = pk_alert_constant.g_yes
        THEN
        
            IF l_exists_discharge = pk_alert_constant.g_yes
            THEN
                IF (l_type_disch = i_flg_type AND i_flg_type IS NOT NULL)
                   OR (i_flg_type IS NULL AND l_type_disch <> pk_disposition.g_disp_adms)
                THEN
                    o_flg_create := pk_alert_constant.g_yes;
                ELSE
                    o_flg_create := pk_alert_constant.g_no;
                END IF;
            ELSE
                IF l_id_epis_type NOT IN (pk_alert_constant.g_epis_type_rehab_session,
                                          pk_alert_constant.g_epis_type_cdc_appointment,
                                          pk_alert_constant.g_epis_type_rehab_appointment,
                                          pk_alert_constant.g_epis_type_home_health_care)
                   AND i_prof.software = pk_alert_constant.g_soft_rehab
                THEN
                    o_flg_create := pk_alert_constant.g_no;
                ELSE
                
                    o_flg_create := pk_alert_constant.g_yes;
                END IF;
            END IF;
        ELSE
            o_flg_create := pk_alert_constant.g_no;
        END IF;
    
        SELECT COUNT(1)
          INTO l_count_discharge
          FROM discharge d
         WHERE d.id_episode = i_episode
           AND d.flg_status IN (pk_alert_constant.g_active, pk_alert_constant.g_pending);
    
        -- Check if integration with saudi arabian client registry is active and patient info has been synchronized
        l_sa_client_registry := pk_sysconfig.get_config('INTEGRATE_SA_CLIENT_REGISTRY', i_prof);
    
        IF l_sa_client_registry = g_yes
           AND i_flg_type != 'A'
           AND l_count_discharge = 0
        THEN
            -- Check if patient info has been synchronized
            SELECT COUNT(1)
              INTO l_health_id_count
              FROM pat_ext_sys pes
             WHERE pes.id_patient = (SELECT id_patient
                                       FROM episode e
                                      WHERE e.id_episode = i_episode)
               AND pes.id_external_sys = g_sa_client_registry_sys_id;
        
            IF l_health_id_count = 0
            THEN
                -- Data is not synchronized. Execution is stopped, so that
                -- the synchronization process can occur.
                o_flg_show             := 'Y';
                o_msg_title            := pk_message.get_message(i_lang, 'DISPOSITION_NO_CLIENT_REGISTRY_T001');
                o_msg_text             := pk_message.get_message(i_lang, 'DISPOSITION_NO_CLIENT_REGISTRY_M001');
                o_button               := 'C';
                o_sync_client_registry := 'Y';
            END IF;
        END IF;
    
        IF l_id_epis_type NOT IN (pk_alert_constant.g_epis_type_rehab_session,
                                  pk_alert_constant.g_epis_type_cdc_appointment,
                                  pk_alert_constant.g_epis_type_rehab_appointment,
                                  pk_alert_constant.g_epis_type_home_health_care)
           AND i_prof.software = pk_alert_constant.g_soft_rehab
        THEN
            o_flg_show             := 'N';
            o_sync_client_registry := 'N';
            pk_types.open_my_cursor(o_disch);
            RETURN TRUE;
        ELSE
            RETURN pk_discharge_core.get_discharge(i_lang          => i_lang,
                                                   i_episode       => i_episode,
                                                   i_prof          => i_prof,
                                                   i_category_type => i_category_type,
                                                   i_flg_type      => l_flg_type,
                                                   o_disch         => o_disch,
                                                   o_error         => o_error);
        END IF;
    
    END get_discharge;

    FUNCTION get_discharge
    (
        i_lang          IN language.id_language%TYPE,
        i_episode       IN discharge.id_episode%TYPE,
        i_prof          IN profissional,
        i_category_type IN category.flg_type%TYPE,
        o_disch         OUT pk_types.cursor_type,
        o_flg_show      OUT VARCHAR2,
        o_msg_title     OUT VARCHAR2,
        o_msg_text      OUT VARCHAR2,
        o_button        OUT VARCHAR2,
        o_flg_create    OUT VARCHAR2,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dummy VARCHAR2(4000);
    
    BEGIN
        RETURN pk_discharge.get_discharge(i_lang                 => i_lang,
                                          i_episode              => i_episode,
                                          i_prof                 => i_prof,
                                          i_category_type        => i_category_type,
                                          i_flg_type             => NULL,
                                          o_disch                => o_disch,
                                          o_flg_show             => o_flg_show,
                                          o_msg_title            => o_msg_title,
                                          o_msg_text             => o_msg_text,
                                          o_button               => o_button,
                                          o_flg_create           => o_flg_create,
                                          o_sync_client_registry => l_dummy,
                                          o_error                => o_error);
    END get_discharge;
    --
    /**********************************************************************************************
    * Check if the discharge has an associated surgery episode.
    *
    * @param i_id_discharge       Discharge ID
    *                        
    * @return            'Y' if has an associated surgery episode, 'N' otherwise
    *
    * @author            Alexandre Santos
    * @version           1.0  
    * @since             2009/12/14
    **********************************************************************************************/
    FUNCTION get_flg_surgery(i_discharge IN discharge.id_discharge%TYPE) RETURN VARCHAR2 IS
        l_flg_surgery VARCHAR2(1);
    BEGIN
        SELECT decode(oris_epi.id_episode, NULL, pk_alert_constant.g_no, pk_alert_constant.g_yes) flg_surgery
          INTO l_flg_surgery
          FROM discharge d
          LEFT JOIN episode inp_epi
            ON inp_epi.id_prev_episode = d.id_episode
          LEFT JOIN episode oris_epi
            ON oris_epi.id_prev_episode = inp_epi.id_episode
         WHERE d.id_discharge = i_discharge
           AND d.flg_status = pk_alert_constant.g_active;
    
        RETURN l_flg_surgery;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_flg_surgery;
    --
    /********************************************************************************************
    * Get the detail of a discharge record
    *
    * @param   i_lang                language associated to the professional executing the request
    * @param   i_disch               discharge ID
    * @param   i_prof                professional, institution and software ids
    *
    * @param   o_disch               Discharge record
    * @param   o_error               error message
             
    * @RETURN  TRUE if sucess, FALSE otherwise
    *
    * @version 1.0
    * @since   16-07-2005
    ********************************************************************************************/
    FUNCTION get_discharge_detail
    (
        i_lang  IN language.id_language%TYPE,
        i_disch IN discharge.id_discharge%TYPE,
        i_prof  IN profissional,
        o_disch OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        RETURN pk_discharge_core.get_discharge_detail(i_lang  => i_lang,
                                                      i_disch => i_disch,
                                                      i_prof  => i_prof,
                                                      o_disch => o_disch,
                                                      o_error => o_error);
    
    END;
    --
    FUNCTION get_nurse_discharge
    (
        i_lang    IN language.id_language%TYPE,
        i_episode IN discharge.id_episode%TYPE,
        i_prof    IN profissional,
        o_temp    OUT pk_types.cursor_type,
        o_def     OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Obter registo de alta por profissional e tipo.
                           O tipo de alta corresponde à categoria do profissional do registo e podem ser vários na mesma execução,
                            concatenado-se os tipos pretendidos. Ex: 'DC' obtem altas do tipo D- Médica e do tipo C- cancelada
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                                    I_EPISODE - ID do episódio
                                    I_PROF - profissional que regista
                        Saida:   O_TEMP - último registo temporário
                           O_DEF - último registo definitivo registado antes da passagem de temporários para definitivos +
                                   todos os registos definitivos registado após a passagem de temporários para definitivos
                           O_ERROR - erro
        
          CRIAÇÃO: RB 2005/04/11
          ALTERAÇÃO: CRS 2006/08/31 Alteração no formato do ecrã
                   SS 2006/10/12: noção de registos temporários
          NOTAS:
        *********************************************************************************/
    
    BEGIN
        --
        g_error := 'GET O_COMPL';
        OPEN o_temp FOR
            SELECT 'R' reg,
                   e.id_nurse_discharge,
                   e.notes,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) nick_name,
                   pk_date_utils.date_char_tsz(i_lang, e.dt_nurse_discharge_tstz, i_prof.institution, i_prof.software) dt_nurse,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    p.id_professional,
                                                    e.dt_nurse_discharge_tstz,
                                                    e.id_episode) desc_speciality,
                   pk_translation.get_translation(i_lang, c.code_clinical_service) clin_serv,
                   e.flg_temp
              FROM nurse_discharge e, professional p, clinical_service c, episode epis, speciality s
             WHERE e.id_episode = i_episode
               AND e.flg_temp = g_flg_temp
               AND epis.id_episode = e.id_episode
               AND c.id_clinical_service = epis.id_clinical_service
               AND p.id_professional = e.id_professional
               AND s.id_speciality(+) = p.id_speciality
               AND e.dt_nurse_discharge_tstz =
                   (SELECT MAX(e2.dt_nurse_discharge_tstz)
                      FROM nurse_discharge e2
                     WHERE e2.id_episode = e.id_episode
                       AND e2.id_professional = e.id_professional)
             ORDER BY e.flg_temp DESC, dt_nurse_discharge_tstz DESC;
        --
        g_error := 'GET CURSOR O_DEF';
        OPEN o_def FOR
            SELECT e.id_nurse_discharge,
                   e.notes,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) nick_name,
                   pk_date_utils.date_char_tsz(i_lang, e.dt_nurse_discharge_tstz, i_prof.institution, i_prof.software) dt_recomend,
                   e.flg_temp,
                   pk_translation.get_translation(i_lang, c.code_clinical_service) clin_serv,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    p.id_professional,
                                                    e.dt_nurse_discharge_tstz,
                                                    e.id_episode) desc_speciality
              FROM nurse_discharge e, professional p, clinical_service c, episode epis, speciality s
             WHERE e.id_episode = i_episode
               AND e.flg_temp = g_flg_def
               AND p.id_professional = e.id_professional
               AND s.id_speciality(+) = p.id_speciality
               AND epis.id_episode = e.id_episode
               AND c.id_clinical_service = epis.id_clinical_service
             ORDER BY e.flg_temp DESC, e.dt_nurse_discharge_tstz DESC;
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_NURSE_DISCHARGE',
                                              o_error);
            pk_types.open_my_cursor(o_temp);
            pk_types.open_my_cursor(o_def);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_nurse_discharge;
    --
    FUNCTION get_nurse_discharge_det
    (
        i_lang    IN language.id_language%TYPE,
        i_episode IN epis_recomend.id_episode%TYPE,
        i_prof    IN profissional,
        o_det     OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Obter detalhe de recomendações por profissional e tipo.
           PARAMETROS:  Entrada:I_LANG - Língua registada como preferência do profissional
                           I_EPISODE - ID do episódio
                        Saida:  O_DET - Detalhe de recomendações
                        O_ERROR - erro
        
          CRIAÇÃO: SS 2006/10/12
          NOTAS:
        *********************************************************************************/
        l_aux nurse_discharge.id_episode%TYPE;
    BEGIN
        BEGIN
            --verificar se há registos neste episódio
            SELECT DISTINCT id_episode
              INTO l_aux
              FROM nurse_discharge
             WHERE id_episode = i_episode;
            --
            g_error := 'GET O_DET';
            OPEN o_det FOR
                SELECT 'R' reg,
                       e.id_nurse_discharge,
                       e.notes,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) nick_name,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        p.id_professional,
                                                        e.dt_nurse_discharge_tstz,
                                                        e.id_episode) desc_speciality,
                       NULL instit,
                       pk_date_utils.date_char_tsz(i_lang,
                                                   e.dt_nurse_discharge_tstz,
                                                   i_prof.institution,
                                                   i_prof.software) dt_discharge,
                       pk_translation.get_translation(i_lang, c.code_clinical_service) clin_serv,
                       e.flg_temp
                  FROM nurse_discharge e, professional p, clinical_service c, episode epis, speciality s
                 WHERE e.id_episode = i_episode
                   AND epis.id_episode = e.id_episode
                   AND c.id_clinical_service = epis.id_clinical_service
                   AND p.id_professional = e.id_professional
                   AND s.id_speciality(+) = p.id_speciality
                 ORDER BY dt_nurse_discharge_tstz DESC; -- PT 11/09/2008 
            --
        EXCEPTION
            WHEN no_data_found THEN
                --se não houver registos, mostra <nada registado>
                g_error := 'GET CURSOR2';
                OPEN o_det FOR
                    SELECT 'N' reg,
                           NULL id_nurse_discharge,
                           pk_message.get_message(i_lang, i_prof, 'COMMON_M007') notes,
                           NULL nick_name,
                           NULL desc_speciality,
                           NULL instit,
                           NULL dt_discharge,
                           NULL clin_serv,
                           NULL flg_temp
                      FROM dual;
        END;
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_NURSE_DISCHARGE_DET',
                                              o_error);
            pk_types.open_my_cursor(o_det);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_nurse_discharge_det;
    --
    FUNCTION get_admin_discharge
    (
        i_lang    IN language.id_language%TYPE,
        i_episode IN discharge.id_episode%TYPE,
        i_prof    IN profissional,
        o_disch   OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Obter registo de alta administrativa do episódio
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                                    I_EPISODE - ID do episódio
                                    I_PROF - profissional que regista
                        Saida:   O_DISCH - Registos de alta
                                 O_ERROR - erro
        
          CRIAÇÃO: SS 2005/12/13
          ALTERAÇÃO: ASM 2007/01/08
        
          NOTAS: sys_message
        *********************************************************************************/
    BEGIN
        RETURN pk_discharge_core.get_admin_discharge(i_lang    => i_lang,
                                                     i_episode => i_episode,
                                                     i_prof    => i_prof,
                                                     o_disch   => o_disch,
                                                     o_error   => o_error);
    END get_admin_discharge;
    --

    /**********************************************************************************************
    * [DB INTERNAL USE ONLY] Insert new discharge notes (medical or administrative).
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param i_id_episode         Episode ID
    * @param i_id_discharge       Discharge ID
    * @param i_notes              The notes
    * @param i_flg_type           (A) Administrative or (D) Medical discharge notes
    * @param o_error              Error message
    *                        
    * @return            TRUE if sucessful, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/02/10
    **********************************************************************************************/
    FUNCTION call_create_new_disch_notes
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_episode   IN episode.id_episode%TYPE,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_notes        IN VARCHAR2,
        i_flg_type     IN VARCHAR2 DEFAULT 'A',
        i_date         IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_sysdate TIMESTAMP WITH LOCAL TIME ZONE;
        l_exception EXCEPTION;
        l_rowids table_varchar := table_varchar();
    BEGIN
    
        l_sysdate := nvl(i_date, current_timestamp);
    
        IF i_id_discharge IS NULL
        THEN
            g_error := 'DISCHARGE ID NULL';
            pk_alertlog.log_debug(g_error);
            RAISE l_exception;
        ELSE
            g_error := 'INSERT NOTES';
            pk_alertlog.log_debug(g_error);
            ts_disch_prof_notes.ins(id_discharge_in   => i_id_discharge,
                                    dt_creation_in    => l_sysdate,
                                    id_prof_create_in => i_prof.id,
                                    notes_in          => i_notes,
                                    flg_type_in       => i_flg_type,
                                    rows_out          => l_rowids);
        
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'DISCH_PROF_NOTES',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
    
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'T_PARAM_ERROR',
                                              'PARAMETER_ERROR',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CALL_CREATE_NEW_DISCH_NOTES',
                                              o_error);
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CALL_CREATE_NEW_DISCH_NOTES',
                                              o_error);
            RETURN FALSE;
    END call_create_new_disch_notes;
    --

    /**********************************************************************************************
    * Insert new discharge notes (medical or administrative).
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param i_id_episode         Episode ID
    * @param i_id_discharge       Discharge ID
    * @param i_notes              The notes
    * @param i_flg_type           (A) Administrative or (D) Medical discharge notes
    * @param o_error              Error message
    *                        
    * @return            TRUE if sucessful, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/02/10
    **********************************************************************************************/
    FUNCTION create_new_discharge_notes
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_episode   IN episode.id_episode%TYPE,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_notes        IN VARCHAR2,
        i_flg_type     IN VARCHAR2 DEFAULT 'A',
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
    BEGIN
        g_error := 'CALL TO CALL_CREATE_NEW_DISCHARGE_NOTES';
        pk_alertlog.log_debug(g_error);
        IF NOT call_create_new_disch_notes(i_lang         => i_lang,
                                           i_prof         => i_prof,
                                           i_id_episode   => i_id_episode,
                                           i_id_discharge => i_id_discharge,
                                           i_notes        => i_notes,
                                           i_flg_type     => i_flg_type,
                                           i_date         => NULL,
                                           o_error        => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CREATE_NEW_DISCHARGE_NOTES',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CREATE_NEW_DISCHARGE_NOTES',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END create_new_discharge_notes;

    /**********************************************************************************************
    * Get all discharge notes (medical or administrative).
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param i_id_episode         Episode ID
    * @param i_id_discharge       Discharge ID
    * @param i_flg_type           (A) Administrative or (D) Medical discharge notes
    * @param o_notes              The notes
    * @param o_error              Error message
    *                        
    * @return            TRUE if sucessful, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/02/10
    **********************************************************************************************/
    FUNCTION get_disch_prof_notes
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_episode   IN episode.id_episode%TYPE,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_flg_type     IN VARCHAR2,
        o_notes        OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        RETURN pk_discharge_core.get_disch_prof_notes(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_id_episode   => i_id_episode,
                                                      i_id_discharge => i_id_discharge,
                                                      i_flg_type     => i_flg_type,
                                                      o_notes        => o_notes,
                                                      o_error        => o_error);
    END get_disch_prof_notes;

    /**********************************************************************************************
    * Gets the created episodes on medical discharge of 'i_id_episode'.
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param i_id_episode         Episode ID
    * @param o_id_episodes        ID's of the created episodes on discharge
    * @param o_error              Error message
    *                        
    * @return            TRUE if successful, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/02/03
    **********************************************************************************************/
    FUNCTION get_created_episodes_on_disch
    (
        i_lang        IN NUMBER,
        i_prof        IN profissional,
        i_id_episode  IN episode.id_episode%TYPE,
        o_id_episodes OUT table_number,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_type_inp  sys_config.id_sys_config%TYPE;
        l_epis_type_oris sys_config.id_sys_config%TYPE;
        l_inp_epis       episode.id_episode%TYPE;
        l_surg_epis      episode.id_episode%TYPE;
    
        l_id_epis table_number := table_number();
    
        l_configuration_error EXCEPTION;
    
    BEGIN
    
        g_error := 'GET CONFIGURATIONS';
        pk_alertlog.log_debug(g_error);
        l_epis_type_inp  := pk_sysconfig.get_config(i_code_cf => 'ID_EPIS_TYPE_INPATIENT', i_prof => i_prof);
        l_epis_type_oris := pk_sysconfig.get_config(i_code_cf => 'ID_EPIS_TYPE_ORIS', i_prof => i_prof);
    
        IF l_epis_type_inp IS NULL
           OR l_epis_type_oris IS NULL
        THEN
            RAISE l_configuration_error;
        END IF;
    
        -- Get the subsequent episodes, created on discharge
        g_error := 'GET EPISODES';
        pk_alertlog.log_debug(g_error);
    
        BEGIN
            SELECT e2.id_episode inp_epis, e3.id_episode surg_epis
              INTO l_inp_epis, l_surg_epis
              FROM episode e1, episode e2, episode e3
             WHERE e1.id_episode = i_id_episode
               AND e1.id_episode = e2.id_prev_episode
               AND e2.id_episode = e3.id_prev_episode(+)
               AND e2.id_epis_type = l_epis_type_inp
               AND e2.flg_status = 'A'
               AND e3.id_epis_type(+) = l_epis_type_oris
               AND e3.flg_status(+) = 'A'
               AND e1.id_visit = e2.id_visit;
        EXCEPTION
            WHEN no_data_found THEN
                l_inp_epis  := NULL;
                l_surg_epis := NULL;
        END;
    
        -- Fill table with results
        g_error := 'LOOP EPISODES';
        pk_alertlog.log_debug(g_error);
    
        IF l_inp_epis IS NOT NULL
           AND l_surg_epis IS NOT NULL
        THEN
        
            l_id_epis := table_number(l_inp_epis, l_surg_epis);
        
        ELSIF nvl(l_inp_epis, l_surg_epis) IS NOT NULL
        THEN
        
            l_id_epis := table_number(nvl(l_inp_epis, l_surg_epis));
        
        END IF;
    
        o_id_episodes := l_id_epis;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_configuration_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'T_CONFIG_ERROR',
                                              'MISSING_CONFIGURATIONS',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_CREATED_EPISODES_ON_DISCH',
                                              o_error);
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_CREATED_EPISODES_ON_DISCH',
                                              o_error);
            RETURN FALSE;
    END get_created_episodes_on_disch;

    /**********************************************************************************************
    * Check if the episode has associated inpatient or surgery episodes.
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param i_id_episode         Episode ID
    * @param i_id_discharge       Discharge ID
    * @param o_flg_show           Show popup message
    * @param o_msg_title          Message title
    * @param o_msg_text           Message text
    * @param o_button             Popup button
    * @param o_error              Error message
    *                        
    * @return            TRUE if sucessful, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/02/03
    **********************************************************************************************/
    FUNCTION check_created_episodes
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_episode   IN episode.id_episode%TYPE,
        i_id_discharge IN discharge.id_discharge%TYPE,
        o_flg_show     OUT VARCHAR2,
        o_msg_title    OUT VARCHAR2,
        o_msg_text     OUT VARCHAR2,
        o_button       OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_count NUMBER(6) := 0;
        l_unexpected_result EXCEPTION;
        l_internal_error    EXCEPTION;
    
        l_new_episodes table_number;
    
    BEGIN
    
        -- Check if discharge can be cancelled.
        -- It only makes sense to show the confirmation popup, if the discharge can be cancelled.
        g_error := 'CHECK DISCHARGE';
        pk_alertlog.log_debug(g_error);
        SELECT COUNT(*)
          INTO l_count
          FROM discharge d
         WHERE d.id_discharge = i_id_discharge
           AND d.flg_status IN ('A', 'P')
           AND d.dt_med_tstz IS NOT NULL
           AND pk_discharge_core.check_admin_discharge(i_lang, i_prof, NULL, d.flg_status_adm) = pk_alert_constant.g_no
           AND d.dt_cancel_tstz IS NULL;
    
        -- Discharge can be cancelled
        IF l_count > 0
        THEN
            -- Get the subsequent episodes created on discharge
            g_error := 'GET EPISODES';
            pk_alertlog.log_debug(g_error);
            IF NOT get_created_episodes_on_disch(i_lang        => i_lang,
                                                 i_prof        => i_prof,
                                                 i_id_episode  => i_id_episode,
                                                 o_id_episodes => l_new_episodes,
                                                 o_error       => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            IF l_new_episodes.count > 0
            THEN
            
                g_error := 'LOAD POPUP INFO';
                pk_alertlog.log_debug(g_error);
            
                -- Set popup window
                o_flg_show  := 'Y';
                o_msg_title := pk_message.get_message(i_lang, 'DISCHARGE_T038');
                o_button    := 'NC';
            
                IF l_new_episodes.count = 1
                THEN
                    -- Exists at least an inpatient episode
                    o_msg_text := pk_message.get_message(i_lang, 'DISCHARGE_M024');
                
                ELSIF l_new_episodes.count = 2
                THEN
                    -- Exists both inpatient episode and surgery
                    o_msg_text := pk_message.get_message(i_lang, 'DISCHARGE_M025');
                ELSE
                    -- This is not supposed to happen.
                    -- We will use this to find eventual data quality problems.
                    o_flg_show := 'N';
                    RAISE l_unexpected_result;
                END IF;
            
            END IF;
        ELSE
            o_flg_show := 'N';
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CHECK_CREATED_EPISODES',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CHECK_CREATED_EPISODES',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END check_created_episodes;

    /**********************************************************************************************
    * Cancel the episodes created after medical discharge of 'i_id_episode'
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param i_id_episode         Episode ID
    * @param o_error              Error message
    *                        
    * @return            TRUE if sucessful, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/02/03
    **********************************************************************************************/
    FUNCTION cancel_created_episodes
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_id_episode     IN episode.id_episode%TYPE,
        i_transaction_id IN VARCHAR2 DEFAULT NULL,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_epis_type_inp  sys_config.id_sys_config%TYPE;
        l_epis_type_oris sys_config.id_sys_config%TYPE;
        l_dummy          VARCHAR2(200);
        l_unexpected_result EXCEPTION;
        l_cancel_error      EXCEPTION;
    
        l_new_episodes table_number;
        r_episode      episode%ROWTYPE;
    
        l_urg_value epis_ext_sys.value%TYPE;
        l_inp_value epis_ext_sys.value%TYPE;
    
        l_continue BOOLEAN := TRUE;
    
        --Scheduler 3.0 transaction ID
        l_transaction_id VARCHAR2(4000);
        l_external_sys   epis_ext_sys.id_epis_ext_sys%TYPE := pk_sysconfig.get_config('ID_EXTERNAL_SYS', i_prof);
    BEGIN
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
    
        -- Get the parent episode value
        g_error := 'GET URG EPISODE value';
        pk_alertlog.log_debug(g_error);
        BEGIN
            SELECT ees.value
              INTO l_urg_value
              FROM epis_ext_sys ees
             WHERE ees.id_episode = i_id_episode;
        EXCEPTION
            WHEN no_data_found THEN
                l_urg_value := NULL;
        END;
    
        -- Get the episodes created on discharge
        g_error := 'GET EPISODES';
        pk_alertlog.log_debug(g_error);
        IF NOT get_created_episodes_on_disch(i_lang        => i_lang,
                                             i_prof        => i_prof,
                                             i_id_episode  => i_id_episode,
                                             o_id_episodes => l_new_episodes,
                                             o_error       => o_error)
        THEN
            RAISE l_unexpected_result;
        END IF;
    
        IF l_new_episodes.count > 0
        THEN
            g_error := 'GET CONFIGURATIONS';
            pk_alertlog.log_debug(g_error);
            l_epis_type_inp  := pk_sysconfig.get_config(i_code_cf => 'ID_EPIS_TYPE_INPATIENT', i_prof => i_prof);
            l_epis_type_oris := pk_sysconfig.get_config(i_code_cf => 'ID_EPIS_TYPE_ORIS', i_prof => i_prof);
        
            FOR i IN 1 .. l_new_episodes.count
            LOOP
            
                g_error := 'GET EPISODES INFO';
                pk_alertlog.log_debug(g_error);
                -- Get info of episodes created on discharge
                SELECT *
                  INTO r_episode
                  FROM episode e
                 WHERE e.id_episode = l_new_episodes(i);
            
                -- CANCEL INPATIENT EPISODE
                IF r_episode.id_epis_type = l_epis_type_inp
                   AND r_episode.flg_status NOT IN (g_epis_canc, g_epis_inactive)
                THEN
                
                    g_error := 'GET INP EPISODE value';
                    pk_alertlog.log_debug(g_error);
                    -- Get external system value for inpatient episode
                    BEGIN
                        SELECT ees.value
                          INTO l_inp_value
                          FROM epis_ext_sys ees
                         WHERE ees.id_episode = r_episode.id_episode;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_inp_value := NULL;
                    END;
                
                    IF l_inp_value IS NULL -- Then its a temporary episode, it's OK to cancel
                       OR nvl(l_inp_value, 0) = nvl(l_urg_value, 0) -- Then they're the "same" episode and haven't been registered in the external system, it's OK to cancel
                       OR (nvl(l_inp_value, 0) <> nvl(l_urg_value, 0) AND
                       l_external_sys = pk_sysconfig.get_config('ADT_EXTERNAL_SYS_IDENTIFIER', i_prof))
                    THEN
                    
                        g_error := 'CANCEL INPATIENT EPISODE';
                        pk_alertlog.log_debug(g_error);
                        IF NOT pk_visit.call_cancel_episode(i_lang           => i_lang,
                                                            i_id_episode     => r_episode.id_episode,
                                                            i_prof           => i_prof,
                                                            i_cancel_reason  => NULL,
                                                            i_cancel_type    => 'D', -- Cancelled on discharge cancellation
                                                            i_transaction_id => l_transaction_id,
                                                            o_error          => o_error)
                        THEN
                            RAISE l_unexpected_result;
                        END IF;
                    
                        g_error := 'pk_adt.cancel_episode_adt';
                        IF NOT pk_adt.cancel_episode_adt(i_lang    => i_lang,
                                                         i_prof    => i_prof,
                                                         i_episode => r_episode.id_episode,
                                                         o_error   => o_error)
                        THEN
                        
                            RAISE l_unexpected_result;
                        END IF;
                    
                    ELSIF l_inp_value <> l_urg_value -- Then the inpatient episode has been registered in the external system. Don't cancel the episode.
                    THEN
                        -- ERROR: INPATIENT EPISODE CANNOT BE CANCELLED
                        l_continue := FALSE;
                        EXIT;
                    END IF;
                
                    -- CANCEL SURGERY EPISODE
                ELSIF r_episode.id_epis_type = l_epis_type_oris
                      AND r_episode.flg_status NOT IN (g_epis_canc, g_epis_inactive)
                THEN
                    g_error := 'CANCEL SURGERY EPISODE';
                    pk_alertlog.log_debug(g_error);
                
                    --please leave always i_transaction_id as last parameter before output params
                    IF NOT pk_sr_grid.call_set_pat_status(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          i_episode        => r_episode.id_episode,
                                                          i_flg_status_new => 'C',
                                                          i_flg_status_old => r_episode.flg_status,
                                                          i_test           => g_yes,
                                                          i_transaction_id => l_transaction_id,
                                                          o_flg_show       => l_dummy,
                                                          o_msg_title      => l_dummy,
                                                          o_msg_text       => l_dummy,
                                                          o_button         => l_dummy,
                                                          o_error          => o_error)
                    THEN
                        RAISE l_unexpected_result;
                    END IF;
                
                END IF;
            END LOOP;
        END IF;
    
        IF NOT l_continue
        THEN
            -- Error inside loop: inpatient episode cannot be cancelled
            RAISE l_cancel_error;
        END IF;
    
        IF i_transaction_id IS NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_cancel_error THEN
            DECLARE
                l_error_in      t_error_in := t_error_in();
                l_ret           BOOLEAN;
                l_error_message sys_message.desc_message%TYPE := pk_message.get_message(i_lang, 'DISCHARGE_M026');
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'CANCEL_CREATED_EPISODES',
                                   NULL,
                                   'U');
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
            
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        
        WHEN l_unexpected_result THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_CREATED_EPISODES',
                                              o_error);
        
            -- will be needed when new scheduler is active DO NOT REMOVE                                 
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            --pk_utils.undo_changes;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_CREATED_EPISODES',
                                              o_error);
        
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            --pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_created_episodes;

    /**********************************************************************************************
    * Cancel administrative discharge. To be used by Flash.
    *
    * @param i_lang                   language ID
    * @param i_prof                   Professional Info
    * @param i_id_epis                Episode ID
    * @param i_id_discharge           Discharge ID
    * @param i_id_cancel_reason       Cancel reason ID
    * @param i_notes_cancel           Cancellation notes
    * @param o_flg_show               Show message: Y - Yes; N -  No
    * @param o_msg                    Message text
    * @param o_msg_title              Message title
    * @param o_button                 Button to show  
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         José Brito
    * @version                        2.6.0.4
    * @since                          2010/08/19 
    **********************************************************************************************/
    FUNCTION cancel_admin_discharge
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_epis          IN episode.id_episode%TYPE,
        i_id_discharge     IN discharge.id_discharge%TYPE,
        i_id_cancel_reason IN cancel_reason.id_cancel_reason%TYPE,
        i_notes_cancel     IN discharge.notes_cancel%TYPE,
        o_flg_show         OUT VARCHAR2,
        o_msg              OUT VARCHAR2,
        o_msg_title        OUT VARCHAR2,
        o_button           OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200 CHAR) := 'CANCEL_ADMIN_DISCHARGE';
        l_internal_error EXCEPTION;
    BEGIN
    
        IF NOT cancel_admin_discharge(i_lang             => i_lang,
                                      i_prof             => i_prof,
                                      i_id_epis          => i_id_epis,
                                      i_id_discharge     => i_id_discharge,
                                      i_id_cancel_reason => i_id_cancel_reason,
                                      i_notes_cancel     => i_notes_cancel,
                                      i_dt_cancel        => NULL,
                                      o_flg_show         => o_flg_show,
                                      o_msg              => o_msg,
                                      o_msg_title        => o_msg_title,
                                      o_button           => o_button,
                                      o_error            => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_admin_discharge;

    /**********************************************************************************************
    * Cancel administrative discharge
    *
    * @param i_lang                   language ID
    * @param i_prof                   Professional Info
    * @param i_id_epis                Episode ID
    * @param i_id_discharge           Discharge ID
    * @param i_id_cancel_reason       Cancel reason ID
    * @param i_notes_cancel           Cancellation notes
    * @param i_dt_cancel              Cancellation date (to be used by external systems)
    * @param o_flg_show               Show message: Y - Yes; N -  No
    * @param o_msg                    Message text
    * @param o_msg_title              Message title
    * @param o_button                 Button to show  
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         José Brito
    * @version                        2.6.0.4
    * @since                          2010/08/19 
    **********************************************************************************************/
    FUNCTION cancel_admin_discharge
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_epis          IN episode.id_episode%TYPE,
        i_id_discharge     IN discharge.id_discharge%TYPE,
        i_id_cancel_reason IN cancel_reason.id_cancel_reason%TYPE,
        i_notes_cancel     IN discharge.notes_cancel%TYPE,
        i_dt_cancel        IN VARCHAR2,
        o_flg_show         OUT VARCHAR2,
        o_msg              OUT VARCHAR2,
        o_msg_title        OUT VARCHAR2,
        o_button           OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name      VARCHAR2(200) := 'CANCEL_ADMIN_DISCHARGE';
        l_sysdate_tstz   TIMESTAMP WITH LOCAL TIME ZONE;
        l_intf_dt_cancel TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_market_pt CONSTANT discharge.flg_market%TYPE := pk_discharge_core.g_disch_type_pt;
        l_market_us CONSTANT discharge.flg_market%TYPE := pk_discharge_core.g_disch_type_us;
    
        l_cancel_allowed sys_config.value%TYPE;
        l_cancel_period  sys_config.value%TYPE;
        --l_count          NUMBER(6) := 0;
        l_invalid_value  EXCEPTION;
        l_internal_error EXCEPTION;
        l_pat_not_discharged BOOLEAN := FALSE;
        l_timeout_reached    BOOLEAN := FALSE;
    
        l_prof_cat      category.flg_type%TYPE;
        l_id_patient    patient.id_patient%TYPE;
        l_dt_admin      TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_med        TIMESTAMP WITH LOCAL TIME ZONE;
        l_id_prof_admin discharge.id_prof_admin%TYPE;
        l_id_prof_med   discharge.id_prof_med%TYPE;
        l_flg_market    discharge.flg_market%TYPE;
        --l_next                    epis_readmission.id_epis_readmission%TYPE;
        l_epis_type               epis_type.id_epis_type%TYPE;
        l_id_discharge            discharge.id_discharge%TYPE;
        l_id_discharge_hist       discharge_hist.id_discharge_hist%TYPE;
        l_new_id_discharge_hist   discharge_hist.id_discharge_hist%TYPE;
        l_rows                    table_varchar;
        l_rows_ei                 table_varchar;
        l_dt_pend_active_tstz     discharge.dt_pend_active_tstz%TYPE;
        l_disch_flg_status        discharge.flg_status%TYPE;
        l_change_discharge_status BOOLEAN;
    
        l_last_epis       episode.id_episode%TYPE;
        l_last_visit      visit.id_visit%TYPE;
        l_visit           visit.id_visit%TYPE;
        l_can_reopen_epis VARCHAR2(1);
    
        l_epis_status episode.flg_status%TYPE;
    
        CURSOR c_patient IS
            SELECT e.id_patient, e.id_epis_type
              FROM episode e
             WHERE e.id_episode = i_id_epis;
    
        l_last_epis_type epis_type.id_epis_type%TYPE;
    
    BEGIN
        g_error := 'GET DATES';
        pk_alertlog.log_debug(g_error);
        IF i_dt_cancel IS NOT NULL
        THEN
            l_intf_dt_cancel := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                              i_prof      => i_prof,
                                                              i_timestamp => i_dt_cancel,
                                                              i_timezone  => NULL);
            l_sysdate_tstz   := l_intf_dt_cancel;
        ELSE
            l_sysdate_tstz := current_timestamp;
        END IF;
    
        g_error := 'GET PROFESSIONAL CATEGORY';
        pk_alertlog.log_debug(g_error);
        l_prof_cat := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
    
        o_flg_show := 'N';
        o_button   := 'NCR';
    
        g_error := 'GET CONFIGURATIONS';
        pk_alertlog.log_debug(g_error);
        -- Period in which the administrative discharge can be cancelled, starting from the administrative discharge date
        l_cancel_period := to_number(pk_sysconfig.get_config('CANCEL_ADMINISTRATIVE_DISCHARGE_LIMIT',
                                                             i_prof.institution,
                                                             i_prof.software));
        -- Is it allowed to cancel the administrative discharge?
        l_cancel_allowed := pk_sysconfig.get_config('CANCEL_ADMINISTRATIVE_DISCHARGE',
                                                    i_prof.institution,
                                                    i_prof.software);
    
        IF l_cancel_allowed != 'Y'
        THEN
            -- This condition acts as a safeguard, since if the configuration is 'N' this method should not be called anyway.
            g_error := 'INVALID CONFIGURATION FOUND: CANCEL_ADMINISTRATIVE_DISCHARGE';
            RAISE l_invalid_value;
        END IF;
    
        IF i_id_discharge IS NULL
        THEN
            BEGIN
                g_error := 'GET DISCHARGE DATA (1)';
                pk_alertlog.log_debug(g_error);
                SELECT d.id_discharge, d.dt_admin_tstz, d.dt_med_tstz, d.id_prof_med, d.id_prof_admin
                  INTO l_id_discharge, l_dt_admin, l_dt_med, l_id_prof_med, l_id_prof_admin
                  FROM discharge d
                 WHERE d.id_episode = i_id_epis
                   AND d.flg_status = g_disch_active;
            EXCEPTION
                WHEN no_data_found THEN
                    l_pat_not_discharged := TRUE;
            END;
        
            IF l_pat_not_discharged
            THEN
                -- Patient was not discharged, send warning message.
                o_flg_show  := 'Y';
                o_msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_T013');
                o_msg       := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_M037');
                o_button    := 'R';
                RETURN TRUE; --> Terminate if limit was reached
            END IF;
        
        ELSE
            l_id_discharge := i_id_discharge;
        
            g_error := 'GET DISCHARGE DATA (2)';
            pk_alertlog.log_debug(g_error);
            SELECT d.dt_admin_tstz, d.dt_med_tstz, d.id_prof_med, d.id_prof_admin, d.dt_pend_active_tstz
              INTO l_dt_admin, l_dt_med, l_id_prof_med, l_id_prof_admin, l_dt_pend_active_tstz
              FROM discharge d
             WHERE d.id_discharge = l_id_discharge;
        END IF;
    
        -- Check if the period to cancel administrative discharge has reached timeout
        IF l_sysdate_tstz > (l_dt_admin + numtodsinterval(l_cancel_period / 24, 'DAY'))
        THEN
            l_timeout_reached := TRUE;
        END IF;
    
        g_error := 'GET DISCHARGE MARKET';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge_core.get_flg_market(i_lang       => i_lang,
                                                i_prof       => i_prof,
                                                i_discharge  => l_id_discharge,
                                                o_flg_market => l_flg_market,
                                                o_error      => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'OPEN C_PATIENT';
        pk_alertlog.log_debug(g_error);
        OPEN c_patient;
        FETCH c_patient
            INTO l_id_patient, l_epis_type;
        CLOSE c_patient;
    
        g_error := 'GET LAST EPISODE';
        IF NOT pk_episode.get_last_episode(i_lang          => i_lang,
                                           i_prof          => i_prof,
                                           i_patient       => l_id_patient,
                                           i_flg_discharge => pk_alert_constant.g_yes,
                                           o_last_episode  => l_last_epis,
                                           o_flg_reopen    => l_can_reopen_epis,
                                           o_epis_type     => l_last_epis_type,
                                           o_error         => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF l_last_epis <> i_id_epis
           AND (l_epis_type = l_last_epis_type OR
           (l_epis_type IN (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient) AND
           l_last_epis_type IN (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient)))
        THEN
        
            l_last_visit := pk_visit.get_visit(i_episode => l_last_epis, o_error => o_error);
            l_visit      := pk_visit.get_visit(i_episode => i_id_epis, o_error => o_error);
        
            -- This is not the most recent episode of this patient
            o_flg_show  := 'Y';
            o_msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_T013');
        
            IF l_last_visit <> l_visit
            THEN
                o_msg := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_M052');
            ELSE
                o_msg := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_M044');
            END IF;
        
            o_button := 'R';
            RETURN TRUE;
        ELSIF l_can_reopen_epis != pk_alert_constant.g_yes
              AND
              (l_epis_type = l_last_epis_type OR
              (l_epis_type IN (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient) AND
              l_last_epis_type IN (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient)))
        THEN
            -- Episode cannot be reopened so we cannot cancel the administrative discharge
            o_flg_show  := 'Y';
            o_msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_T013');
            o_msg       := pk_message.get_message(i_lang => i_lang, i_code_mess => 'VISIT_M030');
            o_button    := 'R';
            RETURN TRUE; --> Terminate if episode cant be reopened
        ELSIF l_flg_market = l_market_us
              AND l_id_prof_med = l_id_prof_admin -- Medical/Administrative discharge ("2 for 1" discharge)
        THEN
            IF l_prof_cat = g_adm_cat
            THEN
                -- Registrars cannot cancel this type of discharge. Show warning message.
                o_flg_show  := 'Y';
                o_msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_T013');
                o_msg       := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_M036');
                o_button    := 'R';
            
            ELSIF l_timeout_reached
            THEN
                -- Period for cancellation has reached timeout.
                o_flg_show  := 'Y';
                o_msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_T013');
                o_msg       := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_M035');
                o_button    := 'R';
            
            ELSE
                BEGIN
                    g_error := 'GET ID_DISCHARGE_HIST';
                    pk_alertlog.log_debug(g_error);
                    SELECT t.id_discharge_hist
                      INTO l_id_discharge_hist
                      FROM (SELECT id_discharge_hist,
                                   id_discharge,
                                   id_episode,
                                   row_number() over(PARTITION BY dh.id_episode ORDER BY dh.dt_created_hist DESC) row_number
                              FROM discharge_hist dh
                             WHERE dh.flg_status_hist = g_disch_active) t
                     WHERE t.id_episode = i_id_epis
                       AND t.id_discharge = l_id_discharge
                       AND row_number = 1;
                EXCEPTION
                    WHEN no_data_found THEN
                        g_error := 'ID_DISCHARGE_HIST NOT FOUND';
                        pk_alertlog.log_debug(g_error);
                        RAISE l_invalid_value;
                END;
            
                -- Medical and administrative discharge were given by the same professional (USA discharge).
                -- Cancel all discharge records (medical and administrative).
                g_error := 'CHECK TYPE OF DISCHARGE';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_disposition.cancel_disposition(i_lang              => i_lang,
                                                         i_id_discharge      => l_id_discharge,
                                                         i_id_discharge_hist => l_id_discharge_hist,
                                                         i_prof              => i_prof,
                                                         i_notes_cancel      => i_notes_cancel,
                                                         i_dt_cancel         => pk_date_utils.date_send_tsz(i_lang,
                                                                                                            l_sysdate_tstz,
                                                                                                            i_prof),
                                                         i_id_cancel_reason  => i_id_cancel_reason,
                                                         o_error             => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                g_error := 'UPDATE DISCHARGE';
                pk_alertlog.log_debug(g_error);
                UPDATE discharge d
                   SET d.flg_status_adm = g_disch_flg_cancel -- Set administrative discharge as cancelled
                 WHERE d.id_discharge = l_id_discharge;
            
                g_error := 'POPULATE TASKS IN TASK_TIMELINE_EA';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_ea_logic_tasktimeline.reopen_epis_tl_tasks(i_lang       => i_lang,
                                                                     i_prof       => i_prof,
                                                                     i_id_episode => i_id_epis,
                                                                     o_error      => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
            END IF;
        
            RETURN TRUE; --> Terminate execution
        
        ELSIF l_timeout_reached
        THEN
        
            -- Period for cancellation has reached timeout.
            o_flg_show  := 'Y';
            o_msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_T013');
            o_msg       := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_M035');
            o_button    := 'R';
            RETURN TRUE; --> Terminate if limit was reached
        
        ELSE
        
            IF l_flg_market = l_market_pt
               AND l_id_prof_admin IS NOT NULL
               AND l_id_prof_med IS NULL
               AND l_prof_cat = g_adm_cat
            THEN
                -- Administrative discharge (without medical discharge), when left without being seen ("alta por abandono")
                g_error := 'CANCEL DISCHARGE (ADM)';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_discharge.cancel_discharge(i_lang             => i_lang,
                                                     i_id_discharge     => l_id_discharge,
                                                     i_prof             => i_prof,
                                                     i_notes_cancel     => i_notes_cancel,
                                                     i_id_cancel_reason => i_id_cancel_reason,
                                                     o_error            => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                g_error := 'UPDATE DISCH_PROF_NOTES (ADM)';
                pk_alertlog.log_debug(g_error);
                ts_disch_prof_notes.ins(id_discharge_in     => l_id_discharge,
                                        dt_creation_in      => l_sysdate_tstz,
                                        id_prof_create_in   => i_prof.id,
                                        notes_in            => i_notes_cancel,
                                        flg_type_in         => l_prof_cat,
                                        id_cancel_reason_in => i_id_cancel_reason,
                                        rows_out            => l_rows);
            
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'DISCH_PROF_NOTES',
                                              i_rowids     => l_rows,
                                              o_error      => o_error);
            
                l_rows := table_varchar();
            
                -- Create a record in DISCHARGE_HIST to avoid losing the previous DT_ADMIN_TSTZ.
                g_error := 'SET DISCHARGE HISTORY';
                pk_alertlog.log_debug(g_error);
                pk_discharge_core.set_discharge_hist(i_prof       => i_prof,
                                                     i_discharge  => l_id_discharge,
                                                     i_outd_prev  => pk_alert_constant.g_yes,
                                                     o_disch_hist => l_new_id_discharge_hist);
                IF NOT pk_disposition.set_cancel(i_lang,
                                                 l_id_discharge,
                                                 l_new_id_discharge_hist,
                                                 i_prof,
                                                 i_notes_cancel,
                                                 o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                g_error := 'POPULATE TASKS IN TASK_TIMELINE_EA';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_ea_logic_tasktimeline.reopen_epis_tl_tasks(i_lang       => i_lang,
                                                                     i_prof       => i_prof,
                                                                     i_id_episode => i_id_epis,
                                                                     o_error      => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                RETURN TRUE; --> Terminate execution                       
            
            END IF;
        END IF;
    
        IF nvl(l_dt_pend_active_tstz, l_sysdate_tstz) = l_dt_admin
           AND l_id_prof_med <> l_id_prof_admin
        THEN
            -- If pending discharge was set as ACTIVE by the registrar,
            -- restore the discharge status as PENDING.
            l_disch_flg_status        := g_disch_flg_status_pend;
            l_change_discharge_status := TRUE;
        
        ELSE
            -- Otherwise, keep the current status.
            g_error := 'GET DISCHARGE FLG_STATUS';
            pk_alertlog.log_debug(g_error);
            SELECT d.flg_status
              INTO l_disch_flg_status
              FROM discharge d
             WHERE d.id_discharge = l_id_discharge;
        
            l_change_discharge_status := FALSE;
        END IF;
    
        g_error := 'GET EPIS STATUS';
        IF l_epis_type IN (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_urgent_care)
           AND NOT l_change_discharge_status
        THEN
            l_epis_status := pk_alert_constant.g_epis_status_pendent;
        ELSE
            l_epis_status := pk_alert_constant.g_epis_status_active;
        END IF;
    
        g_error := 'UPDATE EPISODE';
        pk_alertlog.log_debug(g_error);
        ts_episode.upd(flg_status_in => l_epis_status, -- Episode returns to the state PENDING.
        flg_status_nin => FALSE, dt_end_tstz_in => CAST(NULL AS TIMESTAMP WITH LOCAL TIME ZONE), dt_end_tstz_nin => FALSE, id_episode_in => i_id_epis, rows_out => l_rows);
    
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPISODE',
                                      i_rowids       => l_rows,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
    
        l_rows := table_varchar();
    
        g_error := 'UPDATE VISIT';
        pk_alertlog.log_debug(g_error);
        ts_visit.upd(flg_status_in   => g_epis_active,
                     flg_status_nin  => FALSE,
                     dt_end_tstz_in  => NULL,
                     dt_end_tstz_nin => FALSE,
                     where_in        => 'id_visit IN (SELECT epis.id_visit
                              FROM episode epis
                             WHERE epis.id_episode = ' || i_id_epis || ')',
                     rows_out        => l_rows);
    
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'VISIT',
                                      i_rowids       => l_rows,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
    
        l_rows := table_varchar();
    
        -- USA discharge type, when the administrative discharge is not registered at the same time:
        -- call the "reopen" method but with the "cancelled" status
        IF NOT l_epis_type = pk_act_therap_constant.g_activ_therap_epis_type
           AND l_id_discharge IS NOT NULL
           AND l_flg_market = l_market_us
        THEN
            g_error := 'REOPEN DISPOSITION';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_disposition.set_reopen_disposition(i_lang, i_prof, i_id_epis, g_disch_flg_cancel, o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        -- Reset care stage as 'Discharged', unless discharge returns to 'pending' state.
        IF NOT l_change_discharge_status
        THEN
            g_error := 'CALL TO PK_PATIENT_TRACKING.SET_CARE_STAGE_DISPOSITION';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_patient_tracking.set_care_stage_disposition(i_lang, i_prof, i_id_epis, o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        g_error := 'UPDATE DISCHARGE';
        pk_alertlog.log_debug(g_error);
        UPDATE discharge d
           SET d.flg_status_adm = g_disch_flg_cancel, -- Set administrative discharge as cancelled
               d.flg_status     = l_disch_flg_status
         WHERE d.id_discharge = l_id_discharge;
    
        g_error := 'UPDATE DISCH_PROF_NOTES';
        pk_alertlog.log_debug(g_error);
        ts_disch_prof_notes.ins(id_discharge_in     => l_id_discharge,
                                dt_creation_in      => l_sysdate_tstz,
                                id_prof_create_in   => i_prof.id,
                                notes_in            => i_notes_cancel,
                                flg_type_in         => l_prof_cat,
                                id_cancel_reason_in => i_id_cancel_reason,
                                rows_out            => l_rows);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'DISCH_PROF_NOTES',
                                      i_rowids     => l_rows,
                                      o_error      => o_error);
    
        g_error := 'UPDATE EPIS_INFO';
        pk_alertlog.log_debug(g_error);
        ts_epis_info.upd(id_episode_in     => i_id_epis,
                         dt_admin_tstz_in  => NULL,
                         dt_admin_tstz_nin => FALSE,
                         rows_out          => l_rows_ei);
    
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_INFO',
                                      i_rowids       => l_rows_ei,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('DT_ADMIN_TSTZ'));
    
        g_error := 'POPULATE TASKS IN TASK_TIMELINE_EA';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_ea_logic_tasktimeline.reopen_epis_tl_tasks(i_lang       => i_lang,
                                                             i_prof       => i_prof,
                                                             i_id_episode => i_id_epis,
                                                             o_error      => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        -- In the activity therapy episodes the request state should be changed to the state undergoing
        IF l_epis_type = pk_act_therap_constant.g_activ_therap_epis_type
        THEN
            g_error := 'CALL update_request_state for id_episode: ' || i_id_epis;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_activity_therapist.update_request_state(i_lang          => i_lang,
                                                              i_prof          => i_prof,
                                                              i_id_episode_at => i_id_epis,
                                                              i_from_states   => table_varchar(pk_opinion.g_opinion_over),
                                                              i_to_state      => pk_opinion.g_opinion_accepted,
                                                              o_error         => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        -- Create a record in DISCHARGE_HIST to avoid losing the previous DT_ADMIN_TSTZ.
        g_error := 'SET DISCHARGE HISTORY';
        pk_alertlog.log_debug(g_error);
        pk_discharge_core.set_discharge_hist(i_prof       => i_prof,
                                             i_discharge  => l_id_discharge,
                                             i_outd_prev  => pk_alert_constant.g_no,
                                             o_disch_hist => l_new_id_discharge_hist);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_invalid_value THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'INVALID value',
                                              g_error,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END cancel_admin_discharge;

    --
    /**
    * NOTA:
    * Quando todos os ecrãs de cancelamento de alta implementarem o motivo de cancelamento,
    * deverá ser removida esta função.
    * -- José Brito 17/05/2009
    **/
    FUNCTION cancel_discharge
    (
        i_lang         IN language.id_language%TYPE,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_prof         IN profissional,
        i_notes_cancel IN discharge.notes_cancel%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'CALL TO CANCEL_DISCHARGE';
        RETURN cancel_discharge(i_lang             => i_lang,
                                i_id_discharge     => i_id_discharge,
                                i_prof             => i_prof,
                                i_notes_cancel     => i_notes_cancel,
                                i_id_cancel_reason => NULL,
                                i_transaction_id   => NULL, -- can receive null-
                                i_dt_cancel        => NULL,
                                o_error            => o_error);
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END cancel_discharge;

    /* override to work with new cancel_discharge that needs transaction id */
    FUNCTION cancel_discharge
    (
        i_lang             IN language.id_language%TYPE,
        i_id_discharge     IN discharge.id_discharge%TYPE,
        i_prof             IN profissional,
        i_notes_cancel     IN discharge.notes_cancel%TYPE,
        i_id_cancel_reason IN cancel_reason.id_cancel_reason%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'CALL TO CANCEL_DISCHARGE';
        RETURN cancel_discharge(i_lang             => i_lang,
                                i_id_discharge     => i_id_discharge,
                                i_prof             => i_prof,
                                i_notes_cancel     => i_notes_cancel,
                                i_id_cancel_reason => i_id_cancel_reason,
                                i_transaction_id   => NULL,
                                i_dt_cancel        => NULL,
                                o_error            => o_error);
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END cancel_discharge;

    FUNCTION cancel_discharge
    (
        i_lang             IN language.id_language%TYPE,
        i_id_discharge     IN discharge.id_discharge%TYPE,
        i_prof             IN profissional,
        i_notes_cancel     IN discharge.notes_cancel%TYPE,
        i_id_cancel_reason IN cancel_reason.id_cancel_reason%TYPE,
        i_transaction_id   IN VARCHAR2,
        i_dt_cancel        IN VARCHAR2 DEFAULT NULL,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Cancela um registo de alta médica (tipo D').
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                                    I_EPISODE - ID do episódio
                                    I_PROF - profissional que regista
                                    i_transaction_id     Scheduler 3.0 transaction ID
                        Saida:   O_DISCH - Registos de alta
                                  O_ERROR - erro
        
          CRIAÇÃO: RB 2005/04/11
          NOTAS: (a) dependents            PK_CASE_MANAGEMENT.CANCEL_ENC_DISCHARGE    OUTP
        *********************************************************************************/
        l_dt_cancel          discharge.dt_cancel_tstz%TYPE;
        l_id_episode         discharge.id_episode%TYPE;
        l_id_epis_type       epis_type.id_epis_type%TYPE;
        l_id_visit           visit.id_visit%TYPE;
        l_vis_status         visit.flg_status%TYPE;
        l_dt_first_obs       epis_info.dt_first_obs_tstz%TYPE;
        l_dt_first_nurse_obs epis_info.dt_first_nurse_obs_tstz%TYPE;
        l_found              BOOLEAN;
        l_epis_info_status   epis_info.flg_status%TYPE;
        l_ret                BOOLEAN;
        l_configuration_error EXCEPTION;
        l_unexpected_result   EXCEPTION;
        l_internal_error      EXCEPTION;
        l_data_error          EXCEPTION;
        l_id_patient patient.id_patient%TYPE;
    
        l_epis_type_urg sys_config.value%TYPE;
        l_epis_type_inp CONSTANT NUMBER := pk_alert_constant.g_epis_type_inpatient;
        l_cancel sys_config.value%TYPE;
    
        l_id_next_episode episode.id_episode%TYPE;
    
        CURSOR c_disch(i_prof_cat IN category.flg_type%TYPE) IS
            SELECT d.dt_cancel_tstz, epi.id_episode, vis.id_visit, vis.flg_status vis_status, epi.id_epis_type
              FROM discharge d, episode epi, visit vis
             WHERE d.id_discharge = i_id_discharge --A alta não pode ser cancelada se já o foi
               AND d.flg_status NOT IN
                   (pk_discharge_core.g_disch_status_cancel, pk_discharge_core.g_disch_status_reopen)
                  -- Physician cannot cancel administrative discharge
               AND ((pk_discharge_core.check_admin_discharge(i_lang, i_prof, NULL, d.flg_status_adm) =
                   pk_alert_constant.g_no AND i_prof_cat <> g_adm_cat) OR
                   -- Only registrars can cancel administrative discharge (and physicians in "2 for 1" discharge, US market)
                   (pk_discharge_core.check_admin_discharge(i_lang, i_prof, NULL, d.flg_status_adm) =
                   pk_alert_constant.g_yes AND (i_prof_cat = g_adm_cat OR d.id_prof_med = d.id_prof_admin)))
               AND d.id_episode = epi.id_episode
               AND epi.id_visit = vis.id_visit;
    
        CURSOR c_epis_task IS
            SELECT dt_first_obs_tstz, dt_first_nurse_obs_tstz, id_schedule
              FROM epis_info
             WHERE id_episode = l_id_episode;
    
        CURSOR c_prev_episode(i_episode IN NUMBER) IS
            SELECT id_episode
              FROM episode e
             WHERE e.id_prev_episode = i_episode
               AND e.flg_status = g_epis_status_active
               AND e.flg_ehr <> g_ehr_schedule;
    
        CURSOR c_transf_discharge IS
            SELECT dd.flg_inst_transfer, dd.id_consult_req_fw
              FROM discharge_detail dd
             WHERE dd.id_discharge = i_id_discharge;
    
        l_flg_inst_transfer discharge_detail.flg_inst_transfer%TYPE;
    
        l_can_refresh_mviews BOOLEAN := FALSE;
        -- denormalization variables
        l_rowids        table_varchar;
        l_error_message sys_message.desc_message%TYPE;
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
        l_id_schedule    schedule.id_schedule%TYPE;
        l_func_exception          EXCEPTION;
        l_cancel_print_jobs_excpt EXCEPTION;
    
        l_prof_cat           category.flg_type%TYPE;
        l_found_cr           VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_id_consult_req     discharge_detail.id_consult_req_fw% TYPE;
        l_id_print_list_jobs table_number := table_number();
    
        --
        --l_grid_task grid_task%ROWTYPE;
    
        l_wf_type    VARCHAR2(1 CHAR);
        l_from_state VARCHAR2(1 CHAR);
        l_to_state   VARCHAR2(1 CHAR);
    
        FUNCTION set_rehab_wf
        (
            i_wf_type    IN VARCHAR2,
            i_from_state IN VARCHAR2,
            i_to_state   IN VARCHAR2
        ) RETURN BOOLEAN AS
            l_func_name      VARCHAR2(32) := $$PLSQL_UNIT;
            l_id_episode_aux episode.id_episode%TYPE;
            l_dep_type       sch_event.dep_type%TYPE;
            l_rehab_schedule rehab_schedule.id_rehab_schedule%TYPE;
            l_rehab_sch_need rehab_schedule.id_rehab_sch_need%TYPE;
            l_id_epis_origin rehab_epis_encounter.id_episode_origin%TYPE;
            l_id_epis_rehab  rehab_epis_encounter.id_rehab_epis_encounter%TYPE;
        BEGIN
        
            IF i_wf_type = pk_rehab.g_workflow_type_s
               AND l_id_schedule <> -1
            THEN
                -- get ingredients. no_data_Found sao apanhados pelo when others principal
                BEGIN
                    SELECT rs.id_rehab_schedule, rs.id_rehab_sch_need
                      INTO l_rehab_schedule, l_rehab_sch_need
                      FROM rehab_schedule rs
                     WHERE rs.id_schedule = l_id_schedule;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL;
                END;
                --get id_episode_origin. no_data_Found sao apanhados pelo when others principal
                BEGIN
                    SELECT ree.id_episode_origin, ree.id_rehab_epis_encounter
                      INTO l_id_epis_origin, l_id_epis_rehab
                      FROM rehab_epis_encounter ree
                      JOIN epis_info ei
                        ON ei.id_episode = ree.id_episode_rehab
                     WHERE ei.id_schedule = l_id_schedule;
                EXCEPTION
                    WHEN no_data_found THEN
                        SELECT rsn.id_episode_origin
                          INTO l_id_epis_origin
                          FROM rehab_sch_need rsn
                          JOIN rehab_schedule rs
                            ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
                         WHERE rs.id_schedule = l_id_schedule;
                END;
            ELSIF i_wf_type = pk_rehab.g_workflow_type_w
            --AND l_id_schedule = -1
            THEN
                SELECT ree.id_episode_origin, ree.id_rehab_epis_encounter, id_rehab_sch_need
                  INTO l_id_epis_origin, l_id_epis_rehab, l_rehab_sch_need
                  FROM rehab_epis_encounter ree
                  JOIN epis_info ei
                    ON ei.id_episode = ree.id_episode_rehab
                 WHERE ei.id_episode = l_id_episode;
            ELSIF i_wf_type = pk_rehab.g_workflow_type_a
            THEN
                BEGIN
                    SELECT ree.id_episode_origin, ree.id_rehab_epis_encounter
                      INTO l_id_epis_origin, l_id_epis_rehab
                      FROM rehab_epis_encounter ree
                     WHERE ree.id_episode_origin = l_id_episode
                       AND ree.flg_rehab_workflow_type = i_wf_type
                       AND ree.flg_status = i_from_state;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_id_epis_origin := nvl(l_id_epis_origin, l_id_episode);
                END;
            END IF;
            g_error := l_id_schedule || 'l_id_patient:' || l_id_patient || 'i_wf_type:' || i_wf_type || 'i_from_state:' ||
                       i_from_state || 'i_to_state:' || i_to_state || 'l_id_epis_rehab:' || l_id_epis_rehab ||
                       'l_rehab_sch_need:' || l_rehab_sch_need || 'l_rehab_schedule:' || l_rehab_schedule;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_rehab.set_rehab_wf_change_nocommit(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_patient        => l_id_patient,
                                                         i_workflow_type     => i_wf_type,
                                                         i_from_state        => i_from_state,
                                                         i_to_state          => i_to_state,
                                                         i_id_rehab_grid     => l_id_epis_rehab,
                                                         i_id_rehab_presc    => l_rehab_sch_need,
                                                         i_id_epis_origin    => l_id_epis_origin,
                                                         i_id_rehab_schedule => l_rehab_schedule,
                                                         i_id_schedule       => l_id_schedule,
                                                         i_id_cancel_reason  => NULL,
                                                         i_cancel_notes      => NULL,
                                                         i_transaction_id    => NULL,
                                                         o_id_episode        => l_id_episode_aux,
                                                         o_error             => o_error)
            THEN
                RETURN FALSE;
            END IF;
            RETURN TRUE;
        END set_rehab_wf;
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
    
        g_error         := 'GET CONFIGURATIONS';
        l_epis_type_urg := pk_sysconfig.get_config(i_code_cf => 'ID_EPIS_TYPE_EDIS', i_prof => i_prof);
        l_cancel        := pk_sysconfig.get_config(i_code_cf => 'CANCEL_DISCHARGE_AND_EPISODES', i_prof => i_prof);
    
        IF l_epis_type_urg IS NULL
        THEN
            RAISE l_configuration_error;
        END IF;
    
        g_error    := 'GET PROF CATEGORY';
        l_prof_cat := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
    
        --Valida se a alta ainda não está cancelada
        g_error := 'GET CURSOR DISCH';
        OPEN c_disch(l_prof_cat);
        FETCH c_disch
            INTO l_dt_cancel, l_id_episode, l_id_visit, l_vis_status, l_id_epis_type;
        g_found := c_disch%FOUND;
        CLOSE c_disch;
        IF NOT g_found
        THEN
            l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M003'); --MSG: "Esta alta já foi cancelada ou então foi dada alta administrativa."
            RAISE l_internal_error;
        END IF;
        l_dt_cancel := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_cancel, NULL);
        l_dt_cancel := nvl(l_dt_cancel, g_sysdate_tstz);
    
        -- Check if there's a subsequent episode to the current episode
        g_error := 'GET CURSOR PREV EPISODE';
        OPEN c_prev_episode(l_id_episode);
        FETCH c_prev_episode
            INTO l_id_next_episode;
        CLOSE c_prev_episode;
    
        IF l_id_next_episode IS NOT NULL
        THEN
        
            IF (l_id_epis_type IN (l_epis_type_urg) AND nvl(l_cancel, g_no) = g_yes)
            THEN
            
                -- If it's an EDIS episode, and cancellation of episodes is allowed,
                -- then call CANCEL_CREATED_EPISODES
                IF NOT cancel_created_episodes(i_lang           => i_lang,
                                               i_prof           => i_prof,
                                               i_id_episode     => l_id_episode,
                                               i_transaction_id => l_transaction_id,
                                               o_error          => o_error)
                THEN
                    RAISE l_unexpected_result;
                END IF;
            
            ELSE
                IF l_id_epis_type != l_epis_type_inp
                THEN
                
                    --jsilva 11-06-2007 não é possivel cancelar uma alta de um episódio que deu origem a outro episódio ainda activo
                    l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M016');
                    --l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M044');
                    RAISE l_internal_error;
                
                END IF;
            
            END IF;
        END IF;
    
        g_error := 'UPDATE DISCHARGE';
        --insere valores do cancelamento
        UPDATE discharge
           SET dt_cancel_tstz   = l_dt_cancel,
               id_prof_cancel   = i_prof.id,
               notes_cancel     = i_notes_cancel,
               flg_status       = g_disch_flg_cancel,
               id_cancel_reason = i_id_cancel_reason,
               -- José Brito 04/03/2009 ALERT-10317
               flg_cancel_type = pk_alert_constant.g_disch_flgcanceltype_n,
               -- 
               flg_status_adm = decode(l_prof_cat, g_adm_cat, 'C', flg_status_adm)
         WHERE id_discharge = i_id_discharge;
    
        -- valida se é uma alta com instituições de transferência
        g_error := 'GET CURSOR DISCH';
        OPEN c_transf_discharge;
        FETCH c_transf_discharge
            INTO l_flg_inst_transfer, l_id_consult_req;
        g_found := c_transf_discharge %FOUND;
        CLOSE c_transf_discharge;
    
        IF g_found
           AND l_flg_inst_transfer = g_yes
        THEN
            g_error := 'PK_DISCHARGE_INST.CANCEL_TRANSF_DISCHARGE';
            IF NOT pk_discharge_inst.cancel_transf_discharge(i_lang, i_prof, i_id_discharge, o_error)
            THEN
                RAISE l_func_exception;
            END IF;
        END IF;
    
        -- cancel future event
        IF l_id_consult_req IS NOT NULL
        THEN
            BEGIN
                SELECT pk_alert_constant.g_yes
                  INTO l_found_cr
                  FROM consult_req cr
                 WHERE cr.id_consult_req = l_id_consult_req
                   AND cr.flg_status NOT IN (pk_consult_req.g_consult_req_stat_proc,
                                             pk_consult_req.g_consult_req_stat_cancel,
                                             pk_consult_req.g_consult_req_stat_sched,
                                             pk_consult_req.g_consult_req_stat_rejected);
            EXCEPTION
                WHEN no_data_found THEN
                    l_found_cr := pk_alert_constant.g_no;
            END;
        
            IF l_found_cr = pk_alert_constant.g_yes
            THEN
                IF NOT pk_consult_req.cancel_future_events_nc(i_lang          => i_lang,
                                                              i_prof          => i_prof,
                                                              i_consult_req   => l_id_consult_req,
                                                              i_cancel_reason => i_id_cancel_reason,
                                                              i_cancel_notes  => i_notes_cancel,
                                                              o_error         => o_error)
                THEN
                    RAISE l_func_exception;
                END IF;
            END IF;
        END IF;
        g_error := 'GET PATIENT ID BY EPISODE';
        SELECT e.id_patient
          INTO l_id_patient
          FROM episode e
         WHERE e.id_episode = l_id_episode;
    
        --Anula fecho do episódio
        ts_episode.upd(id_episode_in => l_id_episode, flg_status_in => g_epis_status_active, flg_status_nin => FALSE, dt_end_tstz_in => CAST(NULL AS TIMESTAMP WITH LOCAL TIME ZONE), dt_end_tstz_nin => FALSE, rows_out => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPISODE',
                                      i_rowids       => l_rowids,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
    
        l_rowids := table_varchar();
        g_error  := 'UPDATE EPIS_INFO';
        ts_epis_info.upd(id_episode_in       => l_id_episode,
                         flg_dsch_status_in  => g_disch_flg_cancel,
                         flg_dsch_status_nin => FALSE,
                         rows_out            => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_INFO',
                                      i_rowids       => l_rowids,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('FLG_DSCH_STATUS'));
    
        --Anula fecho da visita
        IF l_vis_status = g_visit_inactive
        THEN
        
            g_error  := 'UPDATE VISIT';
            l_rowids := table_varchar();
            ts_visit.upd(id_visit_in     => l_id_visit,
                         flg_status_in   => g_visit_active,
                         flg_status_nin  => FALSE,
                         dt_end_tstz_in  => NULL,
                         dt_end_tstz_nin => FALSE,
                         rows_out        => l_rowids);
        
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'VISIT',
                                          i_rowids       => l_rowids,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
        
            --UPDATE visit
            --   SET dt_end_tstz = NULL, flg_status = g_visit_active
            -- WHERE id_visit = l_id_visit;
        END IF;
    
        l_can_refresh_mviews := TRUE;
    
        g_error := 'GET EPIS_TASK';
        --Obtem flag da Epis_task
        OPEN c_epis_task;
        FETCH c_epis_task
            INTO l_dt_first_obs, l_dt_first_nurse_obs, l_id_schedule;
        l_found := c_epis_task%FOUND;
        CLOSE c_epis_task;
    
        IF NOT l_found
        THEN
            RAISE l_data_error;
        END IF;
    
        IF l_dt_first_obs IS NULL
        THEN
            l_epis_info_status := g_epis_status_atend;
        ELSIF l_dt_first_nurse_obs IS NULL
        THEN
            l_epis_info_status := g_epis_status_cons;
        ELSIF l_dt_first_obs IS NOT NULL
              AND l_dt_first_nurse_obs IS NOT NULL
        THEN
            l_epis_info_status := g_epis_status_cons;
        END IF;
    
        IF l_epis_info_status IS NOT NULL
        THEN
            l_rowids := table_varchar();
            g_error  := 'UPDATE EPIS_INFO';
            --Actualiza estado do episódio e do agendamento
            ts_epis_info.upd(id_episode_in => l_id_episode, flg_status_in => l_epis_info_status, rows_out => l_rowids);
        
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_INFO',
                                          i_rowids       => l_rowids,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('FLG_STATUS'));
        
            --l_rowids := table_varchar();
        
            BEGIN
            
                g_error := 'UPDATE SCHEDULE_OUTP';
                IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                           i_prof           => i_prof,
                                                                           i_id_schedule    => l_id_schedule,
                                                                           i_flg_state      => l_epis_info_status,
                                                                           i_transaction_id => l_transaction_id,
                                                                           o_error          => o_error)
                THEN
                
                    RAISE l_func_exception;
                END IF;
            
            EXCEPTION
                WHEN no_data_found THEN
                    --l_id_schedule := NULL;
                    NULL;
            END;
        END IF;
    
        IF l_id_epis_type IN
           (pk_alert_constant.g_epis_type_rehab_session, pk_alert_constant.g_epis_type_rehab_appointment)
        THEN
            -- REHAB
            IF l_id_epis_type = pk_alert_constant.g_epis_type_rehab_session
               AND l_id_schedule <> -1
            THEN
            
                l_wf_type := pk_rehab.g_workflow_type_s;
            ELSIF l_id_epis_type = pk_alert_constant.g_epis_type_rehab_session
                  AND l_id_schedule = -1
            THEN
                l_wf_type := pk_rehab.g_workflow_type_w;
            ELSE
                l_wf_type := pk_rehab.g_workflow_type_a;
            END IF;
            l_from_state := pk_rehab.g_rehab_epis_enc_status_o;
            l_to_state   := pk_rehab.g_rehab_epis_enc_status_s;
            IF l_wf_type <> pk_rehab.g_workflow_type_w
            THEN
                IF NOT set_rehab_wf(i_wf_type => l_wf_type, i_from_state => l_from_state, i_to_state => l_to_state)
                THEN
                    RAISE l_unexpected_result;
                END IF;
            END IF;
        END IF;
        --Actualiza dados das observações
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_id_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_unexpected_result;
        END IF;
    
        g_error := 'UPDATE GRID TASK';
    
        -- Remove from grid task
        IF NOT pk_grid.update_grid_task(i_lang             => i_lang,
                                        i_prof             => i_prof,
                                        i_episode          => l_id_episode,
                                        discharge_pend_in  => NULL,
                                        discharge_pend_nin => FALSE,
                                        o_error            => o_error)
        THEN
            RAISE l_unexpected_result;
        END IF;
    
        g_error := 'REMOVE EPIS REGISTER DISCHARGE_PEND GRID TASK';
        pk_alertlog.log_debug(g_error);
    
        IF NOT pk_grid.delete_epis_grid_task(i_lang => i_lang, i_episode => l_id_episode, o_error => o_error)
        THEN
            RAISE l_unexpected_result;
        END IF;
    
        FOR r_exam IN (SELECT erd.id_exam_req_det, erd.id_exam_req, erd.id_exam, er.id_episode
                         FROM exam_req_det erd, exam_req er
                        WHERE er.id_episode = l_id_episode
                          AND erd.id_exam_req = er.id_exam_req)
        LOOP
        
            g_error := 'PK_EXAMS_API_DB.SET_EXAM_GRID_TASK';
            IF NOT pk_exams_api_db.set_exam_grid_task(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_patient      => NULL,
                                                      i_episode      => l_id_episode,
                                                      i_exam_req     => r_exam.id_exam_req,
                                                      i_exam_req_det => r_exam.id_exam_req_det,
                                                      o_error        => o_error)
            THEN
                RAISE l_unexpected_result;
            END IF;
        END LOOP;
    
        g_error := 'RESTORE CARE STAGE';
        IF NOT pk_patient_tracking.restore_care_stage_disposition(i_lang, i_prof, l_id_episode, i_id_discharge, o_error)
        THEN
            RAISE l_unexpected_result;
        END IF;
    
        IF i_transaction_id IS NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
        --COMMIT;
    
        g_error := 'DELETE DISCH TO INP ALERT';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.del_disch_edis_to_inp_alert(i_lang, i_prof, l_id_episode, o_error)
        THEN
            l_error_message := 'ERROR: DELETE DISCH TO INP ALERT';
            RAISE l_internal_error;
        END IF;
    
        g_error := 'CALL TO REMOVE ALL EXISTING PRINT JOBS IN THE PRINTING LIST';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.cancel_disch_print_jobs(i_lang               => i_lang,
                                                    i_prof               => i_prof,
                                                    i_patient            => l_id_patient,
                                                    i_episode            => l_id_episode,
                                                    o_id_print_list_jobs => l_id_print_list_jobs,
                                                    o_error              => o_error)
        THEN
            RAISE l_cancel_print_jobs_excpt;
        END IF;
    
        IF l_can_refresh_mviews
        THEN
            pk_episode.update_mv_episodes();
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'CANCEL_DISCHARGE',
                                   NULL,
                                   'U');
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                --pk_utils.undo_changes;
                pk_alert_exceptions.reset_error_state();
                RETURN FALSE;
            END;
        
        WHEN l_data_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'T_DATA_ERROR',
                                              'DATA_ERROR',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_DISCHARGE',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            --pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN l_cancel_print_jobs_excpt THEN
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN l_configuration_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'T_CONFIG_ERROR',
                                              'CONFIGURATION_ERROR',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_DISCHARGE',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            --pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN l_unexpected_result THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_DISCHARGE',
                                              o_error);
            --pk_utils.undo_changes;
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_DISCHARGE',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            --pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
    END cancel_discharge;
    --

    FUNCTION get_epis_recomend
    (
        i_lang     IN language.id_language%TYPE,
        i_episode  IN epis_recomend.id_episode%TYPE,
        i_flg_type IN epis_recomend.flg_type%TYPE,
        i_prof     IN profissional,
        o_temp     OUT pk_types.cursor_type,
        o_def      OUT pk_types.cursor_type,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        IF NOT get_epis_recomend_rep(i_lang     => i_lang,
                                     i_episode  => i_episode,
                                     i_flg_type => i_flg_type,
                                     i_flg_rep  => 'N',
                                     i_prof     => i_prof,
                                     o_temp     => o_temp,
                                     o_def      => o_def,
                                     o_error    => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_EPIS_RECOMEND',
                                              o_error);
            pk_types.open_my_cursor(o_temp);
            pk_types.open_my_cursor(o_def);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
    END get_epis_recomend;

    /******************************************************************************************** 
    * @return boolean
    *
    * @author                   Joel Lopes
    * @since                    28/01/2014
    ********************************************************************************************/
    FUNCTION get_epis_recomend_rep
    (
        i_lang     IN language.id_language%TYPE,
        i_episode  IN epis_recomend.id_episode%TYPE,
        i_flg_type IN epis_recomend.flg_type%TYPE,
        i_flg_rep  IN VARCHAR2,
        i_prof     IN profissional,
        o_temp     OUT pk_types.cursor_type,
        o_def      OUT pk_types.cursor_type,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
    
        /******************************************************************************
           OBJECTIVO:   Obter recomendações por profissional e tipo.
           PARAMETROS:  Entrada:I_LANG - Língua registada como preferência do profissional
                           I_EPISODE - ID do episódio
                        I_FLG_TYPE - TIPO:  P - recomendações ao doente
                                      D - recomendações a outro médico
                                      R - receita
                                                    N - diário de enfermagem
                                      A - avaliação
                        Saida:   O_RECOM - Registos de recomendações
                           O_ERROR - erro
        
          CRIAÇÃO: RB 2005/04/12
          ALTERAÇÃO: CRS 2006/08/31 Alteração no formato do ecrã
                   SS 2006/10/12 - mostrar sempre o último temporário qualquer seja o utilizador (independentemente de ser o autor do registo)
          NOTAS:
        *********************************************************************************/
        l_cs_desc pk_translation.t_desc_translation;
    BEGIN
        l_cs_desc := pk_episode.get_cs_desc(i_lang, i_prof, i_episode);
    
        IF i_flg_type IN ('F', 'N', g_type_m)
        THEN
            pk_types.open_my_cursor(o_temp);
        
        ELSE
            g_error := 'GET O_COMPL';
            OPEN o_temp FOR
                SELECT 'R' reg,
                       e.id_epis_recomend,
                       e.flg_type,
                       e.desc_epis_recomend_clob,
                       e.id_epis_recomend_parent,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, e.id_professional) nick_name,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, e.dt_epis_recomend_tstz, i_prof) dt_recomend,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        e.id_professional,
                                                        e.dt_epis_recomend_tstz,
                                                        i_episode) desc_speciality,
                       l_cs_desc clin_serv,
                       e.flg_temp,
                       nvl(e.flg_status, pk_alert_constant.g_active) flg_status,
                       decode(e.flg_status,
                              pk_alert_constant.g_cancelled,
                              pk_alert_constant.g_no,
                              decode(e.id_professional, i_prof.id, pk_alert_constant.g_yes, pk_alert_constant.g_no)) flg_cancel,
                       decode(e.flg_status,
                              pk_alert_constant.g_cancelled,
                              pk_alert_constant.g_no,
                              decode(e.id_professional, i_prof.id, pk_alert_constant.g_yes, pk_alert_constant.g_no)) flg_write
                  FROM epis_recomend e
                 WHERE e.id_episode = i_episode
                   AND e.flg_type = i_flg_type
                   AND e.flg_temp = g_flg_temp
                   AND (i_flg_rep = g_yes OR
                       (e.flg_status IS NULL OR e.flg_status = pk_alert_constant.g_active OR
                       (e.flg_status = pk_alert_constant.g_cancelled AND i_flg_type = 'L') AND i_flg_rep = g_no))
                 ORDER BY e.dt_epis_recomend_tstz DESC;
        
        END IF;
    
        IF i_flg_type IN ('F', 'N', g_type_m)
        THEN
            g_error := 'GET CURSOR';
            OPEN o_def FOR
                SELECT 'R' reg,
                       e.id_epis_recomend,
                       e.desc_epis_recomend_clob,
                       e.id_epis_recomend_parent,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        p.id_professional,
                                                        e.dt_epis_recomend_tstz,
                                                        e.id_episode) desc_speciality,
                       pk_date_utils.date_char_tsz(i_lang, e.dt_epis_recomend_tstz, i_prof.institution, i_prof.software) dt_recomend,
                       flg_type,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) prof_recom,
                       e.dt_epis_recomend_tstz dt_reg
                  FROM epis_recomend e, professional p
                 WHERE e.id_episode = i_episode
                   AND e.flg_type = i_flg_type
                   AND p.id_professional = e.id_professional
                -- José Brito 27/11/2008 ALERT-1501 Show progress notes
                UNION ALL
                SELECT 'R' reg,
                       NULL id_epis_recomend,
                       ed.notes desc_epis_recomend_clob,
                       NULL id_epis_recomend_parent,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        ed.id_professional,
                                                        ed.dt_creation_tstz,
                                                        ed.id_episode) desc_speciality,
                       pk_date_utils.date_char_tsz(i_lang, ed.dt_creation_tstz, i_prof.institution, i_prof.software) dt_recomend,
                       NULL flg_type,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, ed.id_professional) prof_recom,
                       ed.dt_creation_tstz dt_reg
                  FROM epis_documentation ed
                 WHERE ed.id_episode = i_episode
                   AND ed.id_doc_area = pk_summary_page.g_doc_area_nursing_notes
                   AND ed.flg_status = pk_alert_constant.g_active
                   AND i_flg_type = 'N'
                 ORDER BY dt_reg DESC;
        
        ELSE
        
            g_error := 'GET CURSOR O_DEF';
            OPEN o_def FOR
                SELECT e.id_epis_recomend,
                       e.desc_epis_recomend_clob,
                       e.flg_type,
                       e.id_epis_recomend_parent,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, e.id_professional) nick_name,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, e.dt_epis_recomend_tstz, i_prof) dt_recomend,
                       e.flg_temp,
                       l_cs_desc clin_serv,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        e.id_professional,
                                                        e.dt_epis_recomend_tstz,
                                                        e.id_episode) desc_speciality,
                       nvl(e.flg_status, pk_alert_constant.g_active) flg_status,
                       decode(e.flg_status,
                              pk_alert_constant.g_cancelled,
                              pk_alert_constant.g_no,
                              decode(e.id_professional, i_prof.id, pk_alert_constant.g_yes, pk_alert_constant.g_no)) flg_cancel,
                       decode(e.flg_status,
                              pk_alert_constant.g_cancelled,
                              pk_alert_constant.g_no,
                              decode(e.id_professional, i_prof.id, pk_alert_constant.g_yes, pk_alert_constant.g_no)) flg_write,
                       e.dt_epis_recomend_tstz order_date,
                       pk_alert_constant.g_no is_dictation,
                       pk_alert_constant.g_no is_dimmed,
                       NULL dt_dictated,
                       NULL dt_transcribed,
                       NULL dt_signoff,
                       NULL report_status,
                       NULL report_information,
                       NULL prof_dictated,
                       NULL desc_spec_dictated,
                       NULL prof_transcribed,
                       NULL desc_spec_transcribed,
                       NULL prof_signoff,
                       NULL desc_spec_signoff,
                       NULL work_type
                  FROM epis_recomend e
                 WHERE e.flg_type = i_flg_type
                   AND e.id_episode = i_episode
                   AND e.flg_temp = g_flg_def
                   AND (i_flg_rep = g_yes OR
                       (e.flg_status IS NULL OR e.flg_status = pk_alert_constant.g_active OR
                       (e.flg_status = pk_alert_constant.g_cancelled AND i_flg_type = 'L') AND i_flg_rep = g_no))
                UNION ALL
                SELECT NULL id_epis_recomend,
                       NULL desc_epis_recomend_clob,
                       NULL flg_type,
                       NULL id_epis_recomend_parent,
                       NULL nick_name,
                       NULL dt_recomend,
                       g_flg_def flg_temp,
                       NULL clin_serv,
                       NULL desc_speciality,
                       pk_alert_constant.g_active flg_status,
                       pk_alert_constant.g_no flg_cancel,
                       pk_alert_constant.g_no flg_write,
                       dr.last_update_date order_date,
                       pk_alert_constant.g_yes is_dictation,
                       pk_alert_constant.g_no is_dimmed,
                       pk_date_utils.date_char_tsz(i_lang, dr.dictated_date, i_prof.institution, i_prof.software) dt_dictated,
                       pk_date_utils.date_char_tsz(i_lang, dr.transcribed_date, i_prof.institution, i_prof.software) dt_transcribed,
                       pk_date_utils.date_char_tsz(i_lang, dr.signoff_date, i_prof.institution, i_prof.software) dt_signoff,
                       pk_sysdomain.get_domain('DICTATION_REPORT.REPORT_STATUS', dr.report_status, i_lang) report_status,
                       dr.report_information report_information,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, dr.id_prof_dictated) prof_dictated,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        dr.id_prof_dictated,
                                                        dr.last_update_date,
                                                        dr.id_episode) desc_spec_dictated,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, dr.id_prof_transcribed) prof_transcribed,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        dr.id_prof_transcribed,
                                                        dr.last_update_date,
                                                        dr.id_episode) desc_spec_transcribed,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, dr.id_prof_signoff) prof_signoff,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        dr.id_prof_signoff,
                                                        dr.last_update_date,
                                                        dr.id_episode) desc_spec_signoff,
                       pk_translation.get_translation(i_lang, wt.code_work_type) work_type
                  FROM dictation_report dr, work_type wt
                 WHERE dr.id_episode = i_episode
                   AND wt.id_work_type(+) = dr.id_work_type
                   AND dr.id_work_type = g_dictation_area_plan
                   AND i_flg_type = 'L'
                UNION ALL
                SELECT NULL id_epis_recomend,
                       NULL desc_epis_recomend_clob,
                       NULL flg_type,
                       NULL id_epis_recomend_parent,
                       NULL nick_name,
                       NULL dt_recomend,
                       g_flg_def flg_temp,
                       NULL clin_serv,
                       NULL desc_speciality,
                       pk_alert_constant.g_active flg_status,
                       pk_alert_constant.g_no flg_cancel,
                       pk_alert_constant.g_no flg_write,
                       drh.last_update_date order_date,
                       pk_alert_constant.g_yes is_dictation,
                       pk_alert_constant.g_yes is_dimmed,
                       pk_date_utils.date_char_tsz(i_lang, drh.dictated_date, i_prof.institution, i_prof.software) dt_dictated,
                       pk_date_utils.date_char_tsz(i_lang, drh.transcribed_date, i_prof.institution, i_prof.software) dt_transcribed,
                       pk_date_utils.date_char_tsz(i_lang, drh.signoff_date, i_prof.institution, i_prof.software) dt_signoff,
                       pk_sysdomain.get_domain('DICTATION_REPORT.REPORT_STATUS', drh.report_status, i_lang) report_status,
                       drh.report_information report_information,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, drh.id_prof_dictated) prof_dictated,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        drh.id_prof_dictated,
                                                        drh.last_update_date,
                                                        drh.id_episode) desc_spec_dictated,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, drh.id_prof_transcribed) prof_transcribed,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        drh.id_prof_transcribed,
                                                        drh.last_update_date,
                                                        drh.id_episode) desc_spec_transcribed,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, drh.id_prof_signoff) prof_signoff,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        drh.id_prof_signoff,
                                                        drh.last_update_date,
                                                        drh.id_episode) desc_spec_signoff,
                       pk_translation.get_translation(i_lang, wt.code_work_type) work_type
                  FROM dictation_report_hist drh, work_type wt
                 WHERE drh.id_episode = i_episode
                   AND wt.id_work_type(+) = drh.id_work_type
                   AND drh.id_work_type = g_dictation_area_plan
                   AND i_flg_type = 'L'
                 ORDER BY flg_status, flg_temp DESC, order_date DESC;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_EPIS_RECOMEND_REP',
                                              o_error);
            pk_types.open_my_cursor(o_temp);
            pk_types.open_my_cursor(o_def);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_epis_recomend_rep;
    --
    FUNCTION get_epis_recomend_det
    (
        i_lang     IN language.id_language%TYPE,
        i_episode  IN epis_recomend.id_episode%TYPE,
        i_prof     IN profissional,
        i_flg_type IN epis_recomend.flg_type%TYPE,
        o_det      OUT pk_types.cursor_type,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Obter detalhe de recomendações por profissional e tipo.
           PARAMETROS:  Entrada:I_LANG - Língua registada como preferência do profissional
                           I_EPISODE - ID do episódio
                        I_FLG_TYPE - TIPO:  P - recomendações ao doente
                                      D - recomendações a outro médico
                                      R - receita
                                                    N - diário de enfermagem
                                      A - avaliação
                        Saida:   O_DET - Detalhe de recomendações
                           O_ERROR - erro
        
          CRIAÇÃO: SS 2006/10/12
          NOTAS:
        *********************************************************************************/
    BEGIN
        g_error := 'GET O_DET';
        OPEN o_det FOR
            SELECT 'R' reg,
                   e.id_epis_recomend,
                   e.flg_type,
                   e.desc_epis_recomend_clob,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) nick_name,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    p.id_professional,
                                                    e.dt_epis_recomend_tstz,
                                                    e.id_episode) desc_speciality,
                   NULL instit,
                   pk_date_utils.date_char_tsz(i_lang, e.dt_epis_recomend_tstz, i_prof.institution, i_prof.software) dt_recom,
                   pk_translation.get_translation(i_lang, c.code_clinical_service) clin_serv,
                   e.flg_temp order_flag,
                   e.dt_epis_recomend_tstz order_date,
                   pk_alert_constant.g_no is_dictation,
                   pk_alert_constant.g_no is_dimmed,
                   NULL dt_dictated,
                   NULL dt_transcribed,
                   NULL dt_signoff,
                   NULL report_status,
                   NULL report_information,
                   NULL prof_dictated,
                   NULL desc_spec_dictated,
                   NULL prof_transcribed,
                   NULL desc_spec_transcribed,
                   NULL prof_signoff,
                   NULL desc_spec_signoff,
                   NULL work_type
              FROM epis_recomend e, professional p, clinical_service c, episode epis, speciality s --, INSTITUTION I
             WHERE e.id_episode = i_episode
               AND e.flg_type = i_flg_type
               AND (e.flg_status = pk_alert_constant.g_active OR e.flg_status IS NULL)
               AND epis.id_episode = e.id_episode
               AND c.id_clinical_service = epis.id_clinical_service
               AND p.id_professional = e.id_professional
               AND s.id_speciality(+) = p.id_speciality
            
            UNION ALL
            SELECT 'R' reg,
                   NULL id_epis_recomend,
                   NULL desc_epis_recomend_clob,
                   NULL flg_type,
                   NULL nick_name,
                   NULL dt_recomend,
                   NULL flg_temp,
                   NULL clin_serv,
                   NULL desc_speciality,
                   'D' order_flag,
                   dr.last_update_date order_date,
                   pk_alert_constant.g_yes is_dictation,
                   pk_alert_constant.g_no is_dimmed,
                   pk_date_utils.date_char_tsz(i_lang, dr.dictated_date, i_prof.institution, i_prof.software) dt_dictated,
                   pk_date_utils.date_char_tsz(i_lang, dr.transcribed_date, i_prof.institution, i_prof.software) dt_transcribed,
                   pk_date_utils.date_char_tsz(i_lang, dr.signoff_date, i_prof.institution, i_prof.software) dt_signoff,
                   pk_sysdomain.get_domain('DICTATION_REPORT.REPORT_STATUS', dr.report_status, i_lang) report_status,
                   dr.report_information report_information,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, dr.id_prof_dictated) prof_dictated,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    dr.id_prof_dictated,
                                                    dr.last_update_date,
                                                    dr.id_episode) desc_spec_dictated,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, dr.id_prof_transcribed) prof_transcribed,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    dr.id_prof_transcribed,
                                                    dr.last_update_date,
                                                    dr.id_episode) desc_spec_transcribed,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, dr.id_prof_signoff) prof_signoff,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    dr.id_prof_signoff,
                                                    dr.last_update_date,
                                                    dr.id_episode) desc_spec_signoff,
                   pk_translation.get_translation(i_lang, wt.code_work_type) work_type
              FROM dictation_report dr, work_type wt
             WHERE dr.id_episode = i_episode
               AND wt.id_work_type(+) = dr.id_work_type
               AND dr.id_work_type = g_dictation_area_plan
               AND i_flg_type = 'L'
            UNION ALL
            SELECT 'R' reg,
                   NULL id_epis_recomend,
                   NULL desc_epis_recomend_clob,
                   NULL flg_type,
                   NULL nick_name,
                   NULL dt_recomend,
                   NULL flg_temp,
                   NULL clin_serv,
                   NULL desc_speciality,
                   'D' order_flag,
                   drh.last_update_date order_date,
                   pk_alert_constant.g_yes is_dictation,
                   pk_alert_constant.g_yes is_dimmed,
                   pk_date_utils.date_char_tsz(i_lang, drh.dictated_date, i_prof.institution, i_prof.software) dt_dictated,
                   pk_date_utils.date_char_tsz(i_lang, drh.transcribed_date, i_prof.institution, i_prof.software) dt_transcribed,
                   pk_date_utils.date_char_tsz(i_lang, drh.signoff_date, i_prof.institution, i_prof.software) dt_signoff,
                   pk_sysdomain.get_domain('DICTATION_REPORT.REPORT_STATUS', drh.report_status, i_lang) report_status,
                   drh.report_information report_information,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, drh.id_prof_dictated) prof_dictated,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    drh.id_prof_dictated,
                                                    drh.last_update_date,
                                                    drh.id_episode) desc_spec_dictated,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, drh.id_prof_transcribed) prof_transcribed,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    drh.id_prof_transcribed,
                                                    drh.last_update_date,
                                                    drh.id_episode) desc_spec_transcribed,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, drh.id_prof_signoff) prof_signoff,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    drh.id_prof_signoff,
                                                    drh.last_update_date,
                                                    drh.id_episode) desc_spec_signoff,
                   pk_translation.get_translation(i_lang, wt.code_work_type) work_type
              FROM dictation_report_hist drh, work_type wt
             WHERE drh.id_episode = i_episode
               AND wt.id_work_type(+) = drh.id_work_type
               AND drh.id_work_type = g_dictation_area_plan
               AND i_flg_type = 'L'
             ORDER BY order_flag DESC, order_date DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_EPIS_RECOMEND_DET',
                                              o_error);
            pk_types.open_my_cursor(o_det);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_epis_recomend_det;

    /**
    * Get detail and history of epis_recomend record.
    *
    * @param i_lang         language identifier
    * @param i_prof         logged professional structure
    * @param i_epis_rec     record identifier
    * @param o_detail       detail
    * @param o_history      history
    * @param o_error        error
    *
    * @return               false if errors occur, true otherwise
    *
    * @author               Pedro Carneiro
    * @version               2.6.2
    * @since                2012/08/24
    */
    FUNCTION get_epis_recomend_hist
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_epis_rec IN epis_recomend.id_epis_recomend%TYPE,
        o_detail   OUT pk_types.cursor_type,
        o_history  OUT pk_types.cursor_type,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'GET_EPIS_RECOMEND_HIST';
        l_colon     CONSTANT VARCHAR2(2 CHAR) := ': ';
        l_lbl_text     sys_message.desc_message%TYPE;
        l_lbl_canc_rea sys_message.desc_message%TYPE;
        l_lbl_canc_not sys_message.desc_message%TYPE;
        l_lbl_create   sys_message.desc_message%TYPE;
        l_lbl_edit     sys_message.desc_message%TYPE;
        l_lbl_cancel   sys_message.desc_message%TYPE;
    BEGIN
        -- get screen labels
        l_lbl_text     := pk_message.get_message(i_lang      => i_lang,
                                                 i_prof      => i_prof,
                                                 i_code_mess => 'PROGRESS_NOTES_T108') || l_colon;
        l_lbl_canc_rea := pk_message.get_message(i_lang      => i_lang,
                                                 i_prof      => i_prof,
                                                 i_code_mess => 'PROGRESS_NOTES_T111') || l_colon;
        l_lbl_canc_not := pk_message.get_message(i_lang      => i_lang,
                                                 i_prof      => i_prof,
                                                 i_code_mess => 'PROGRESS_NOTES_T112') || l_colon;
        l_lbl_create   := pk_message.get_message(i_lang      => i_lang,
                                                 i_prof      => i_prof,
                                                 i_code_mess => 'PROGRESS_NOTES_T113') || l_colon;
        l_lbl_edit     := pk_message.get_message(i_lang      => i_lang,
                                                 i_prof      => i_prof,
                                                 i_code_mess => 'PROGRESS_NOTES_T114') || l_colon;
        l_lbl_cancel   := pk_message.get_message(i_lang      => i_lang,
                                                 i_prof      => i_prof,
                                                 i_code_mess => 'PROGRESS_NOTES_T115') || l_colon;
    
        g_error := 'OPEN o_detail';
        OPEN o_detail FOR
            SELECT nvl(er.flg_status, pk_alert_constant.g_active) flg_status,
                   decode(er.flg_status,
                          pk_alert_constant.g_cancelled,
                          l_lbl_cancel,
                          decode(er.id_epis_recomend_parent, NULL, l_lbl_create, l_lbl_edit)) status,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, er.dt_epis_recomend_tstz, i_prof) dt_record,
                   pk_tools.get_prof_description(i_lang,
                                                 i_prof,
                                                 er.id_professional,
                                                 er.dt_epis_recomend_tstz,
                                                 er.id_episode) prof,
                   l_lbl_text label_text,
                   er.desc_epis_recomend_clob desc_text,
                   l_lbl_canc_rea label_cancel_reason,
                   decode(er.flg_status,
                          pk_alert_constant.g_cancelled,
                          pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, cid.id_cancel_reason)) desc_cancel_reason,
                   l_lbl_canc_not label_cancel_notes,
                   cid.notes_cancel_long desc_cancel_notes
              FROM epis_recomend er
              LEFT JOIN cancel_info_det cid
                ON er.id_cancel_info_det = cid.id_cancel_info_det
             WHERE er.id_epis_recomend = i_epis_rec;
    
        g_error := 'OPEN o_history';
        OPEN o_history FOR
            SELECT nvl(er.flg_status, pk_alert_constant.g_active) flg_status,
                   decode(er.flg_status,
                          pk_alert_constant.g_cancelled,
                          l_lbl_cancel,
                          decode(er.id_epis_recomend_parent, NULL, l_lbl_create, l_lbl_edit)) status,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, er.dt_epis_recomend_tstz, i_prof) dt_record,
                   pk_tools.get_prof_description(i_lang,
                                                 i_prof,
                                                 er.id_professional,
                                                 er.dt_epis_recomend_tstz,
                                                 er.id_episode) prof,
                   l_lbl_text label_text,
                   er.desc_epis_recomend_clob desc_text,
                   l_lbl_canc_rea label_cancel_reason,
                   decode(er.flg_status,
                          pk_alert_constant.g_cancelled,
                          pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, cid.id_cancel_reason)) desc_cancel_reason,
                   l_lbl_canc_not label_cancel_notes,
                   cid.notes_cancel_long desc_cancel_notes
              FROM epis_recomend er
              LEFT JOIN cancel_info_det cid
                ON er.id_cancel_info_det = cid.id_cancel_info_det
            CONNECT BY PRIOR er.id_epis_recomend_parent = er.id_epis_recomend
             START WITH er.id_epis_recomend = i_epis_rec;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_cursor_if_closed(i_cursor => o_detail);
            pk_types.open_cursor_if_closed(i_cursor => o_history);
            RETURN FALSE;
    END get_epis_recomend_hist;

    FUNCTION get_plan_text
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_patient   IN patient.id_patient%TYPE,
        i_episode   IN table_number,
        o_plan_text OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        /** @headcom
        * Public Function. Retornar um texto predefinido para o plano
        *
        * @param      i_lang              Língua registada como preferência do profissional
        * @param      i_prof              ID do profissional, software e instituição
        * @param      i_patient           ID do paciente
        * @param      i_episode           Array de ids de episódios
        * @param      o_plan_text         cursor
        * @param      o_error             erro
        *
        * @return     boolean
        * @author     ASM
        * @version    0.1
        * @since      2007/05/30
        */
    
        o_analysis       pk_types.cursor_type;
        o_exam           pk_types.cursor_type;
        o_presc_ext      pk_types.cursor_type;
        o_dietary_ext    pk_types.cursor_type;
        o_manip_ext      pk_types.cursor_type;
        o_presc          pk_types.cursor_type;
        o_interv         pk_types.cursor_type;
        o_monitorization pk_types.cursor_type;
        o_nurse_act      pk_types.cursor_type;
        o_nurse_teach    pk_types.cursor_type;
        o_plan           pk_types.cursor_type;
        l_therapeutic    pk_types.cursor_type;
        l_referrals      pk_types.cursor_type;
        l_gp_notes       pk_types.cursor_type;
    
        l_analysis1       VARCHAR2(4000);
        l_analysis2       NUMBER;
        l_exam1           VARCHAR2(4000);
        l_exam2           NUMBER;
        l_presc_ext1      VARCHAR2(4000);
        l_presc_ext2      DATE;
        l_presc_ext3      NUMBER;
        l_presc1          VARCHAR2(4000);
        l_presc2          NUMBER;
        l_interv1         VARCHAR2(4000);
        l_interv2         NUMBER;
        l_monitorization1 VARCHAR2(4000);
        l_monitorization2 NUMBER;
        l_nurse_act1      VARCHAR2(4000);
        l_nurse_act2      NUMBER;
        l_nurse_teach1    VARCHAR2(4000);
        l_nurse_teach2    NUMBER;
    
        aux_plan sys_message.desc_message%TYPE;
    
        l_internal_error EXCEPTION;
        l_found BOOLEAN;
    BEGIN
    
        IF NOT pk_episode.get_summary_p(i_lang,
                                        i_patient,
                                        i_episode,
                                        i_prof,
                                        o_analysis,
                                        o_exam,
                                        o_presc_ext,
                                        o_dietary_ext,
                                        o_manip_ext,
                                        o_presc,
                                        o_interv,
                                        o_monitorization,
                                        o_nurse_act,
                                        o_nurse_teach,
                                        o_plan,
                                        l_therapeutic,
                                        l_referrals,
                                        l_gp_notes,
                                        o_error)
        THEN
        
            RAISE l_internal_error;
        
        END IF;
    
        g_error := 'FETCH O_ANALYSIS';
        FETCH o_analysis
            INTO l_analysis1, l_analysis2;
        g_found := o_analysis%FOUND;
        CLOSE o_analysis;
        g_error := 'G_FOUND O_ANALYSIS';
        IF g_found
        THEN
            aux_plan := pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M001') || ' ' ||
                        pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M002');
        END IF;
    
        g_error := 'FETCH O_EXAM';
        FETCH o_exam
            INTO l_exam1, l_exam2;
        g_found := o_exam%FOUND;
        CLOSE o_exam;
        g_error := 'G_FOUND O_EXAM';
        IF g_found
        THEN
            IF aux_plan IS NOT NULL
            THEN
                aux_plan := aux_plan || ', ' || pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M003');
            ELSE
                aux_plan := pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M001') || ' ' ||
                            pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M003');
            END IF;
        END IF;
    
        g_error := 'FETCH O_PRESC_EXT';
        FETCH o_presc_ext
            INTO l_presc_ext1, l_presc_ext2, l_presc_ext3;
        g_found := o_presc_ext%FOUND;
        CLOSE o_presc_ext;
        g_error := 'G_FOUND O_PRESC_EXT';
        IF g_found
        THEN
            IF aux_plan IS NOT NULL
            THEN
                aux_plan := aux_plan || ', ' || pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M004');
            ELSE
                aux_plan := pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M001') || ' ' ||
                            pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M004');
            END IF;
        END IF;
    
        g_error := 'FETCH O_PRESC';
        FETCH o_presc
            INTO l_presc1, l_presc2;
        g_found := o_presc%FOUND;
        CLOSE o_presc;
        g_error := 'G_FOUND O_PRESC';
        IF g_found
        THEN
            IF aux_plan IS NOT NULL
            THEN
                aux_plan := aux_plan || ', ' || pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M005');
            ELSE
                aux_plan := pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M001') || ' ' ||
                            pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M005');
            END IF;
        END IF;
    
        g_error := 'FETCH O_INTERV';
        FETCH o_interv
            INTO l_interv1, l_interv2;
        g_found := o_interv%FOUND;
        CLOSE o_interv;
    
        /*        g_error := 'FETCH O_INTERVMFR';
            FETCH o_intervmfr
                INTO l_interv1, l_interv2;
            l_found := o_intervmfr%FOUND;
            CLOSE o_intervmfr;
        */
        g_error := 'G_FOUND O_INTERV';
        IF g_found
           OR l_found
        THEN
            IF aux_plan IS NOT NULL
            THEN
                aux_plan := aux_plan || ', ' || pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M006');
            ELSE
                aux_plan := pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M001') || ' ' ||
                            pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M006');
            END IF;
        END IF;
    
        g_error := 'FETCH O_NURSE_ACT';
        FETCH o_nurse_act
            INTO l_nurse_act1, l_nurse_act2;
        g_found := o_nurse_act%FOUND;
        CLOSE o_nurse_act;
        g_error := 'G_FOUND O_NURSE_ACT';
        IF g_found
        THEN
            IF aux_plan IS NOT NULL
            THEN
                aux_plan := aux_plan || ', ' || pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M007');
            ELSE
                aux_plan := pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M001') || ' ' ||
                            pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M007');
            END IF;
        END IF;
    
        g_error := 'FETCH O_MONITORIZATION';
        FETCH o_monitorization
            INTO l_monitorization1, l_monitorization2;
        g_found := o_monitorization%FOUND;
        CLOSE o_monitorization;
        g_error := 'G_FOUND O_MONITORIZATION';
        IF g_found
        THEN
            IF aux_plan IS NOT NULL
            THEN
                aux_plan := aux_plan || ', ' || pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M008');
            ELSE
                aux_plan := pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M001') || ' ' ||
                            pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M008');
            END IF;
        END IF;
    
        g_error := 'FETCH O_NURSE_TEACH';
        FETCH o_nurse_teach
            INTO l_nurse_teach1, l_nurse_teach2;
        g_found := o_nurse_teach%FOUND;
        CLOSE o_nurse_teach;
        g_error := 'G_FOUND O_NURSE_TEACH';
        IF g_found
        THEN
            IF aux_plan IS NOT NULL
            THEN
                aux_plan := aux_plan || ', ' || pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M009');
            ELSE
                aux_plan := pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M001') || ' ' ||
                            pk_message.get_message(i_lang, i_prof, 'PLAN_NOTES_M009');
            END IF;
        END IF;
        IF aux_plan IS NOT NULL
        THEN
            aux_plan := aux_plan || '.';
        ELSE
            aux_plan := NULL;
        END IF;
    
        g_error := 'PLAN';
        OPEN o_plan_text FOR 'SELECT ''' || aux_plan || ''' PLAN_TEXT FROM DUAL';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_PLAN_TEXT',
                                              o_error);
            pk_types.open_my_cursor(o_plan_text);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_PLAN_TEXT',
                                              o_error);
            pk_types.open_my_cursor(o_plan_text);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_plan_text;
    --

    /**
    * Cancels record from epis_recomend.
    *
    * @param i_lang         language identifier
    * @param i_prof         logged professional structure
    * @param i_prof_cat     logged professional category
    * @param i_patient      patient identifier
    * @param i_episode      episode identifier
    * @param i_epis_rec     record identifier
    * @param i_reason       cancel reason identifier
    * @param i_notes        cancel notes
    * @param o_error        error
    *
    * @return               false if errors occur, true otherwise
    *
    * @author               Pedro Carneiro
    * @version               2.6.2
    * @since                2012/08/23
    */
    FUNCTION set_epis_recomend_cancel
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_prof_cat IN category.flg_type%TYPE,
        i_patient  IN patient.id_patient%TYPE,
        i_episode  IN episode.id_episode%TYPE,
        i_epis_rec IN epis_recomend.id_epis_recomend%TYPE,
        i_reason   IN cancel_info_det.id_cancel_reason%TYPE,
        i_notes    IN cancel_info_det.notes_cancel_long%TYPE,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_rec epis_recomend.id_epis_recomend%TYPE;
    BEGIN
        g_error := 'CALL set_epis_recomend_cancel_int';
        IF NOT set_epis_recomend_cancel_int(i_lang     => i_lang,
                                            i_prof     => i_prof,
                                            i_epis_rec => i_epis_rec,
                                            i_reason   => i_reason,
                                            i_notes    => i_notes,
                                            o_epis_rec => l_epis_rec,
                                            o_error    => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL pk_visit.set_first_obs';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        COMMIT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'SET_EPIS_RECOMEND_CANCEL',
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_epis_recomend_cancel;

    /**
    * Cancels record from epis_recomend (no commit).
    *
    * @param i_lang         language identifier
    * @param i_prof         logged professional structure
    * @param i_epis_rec     record identifier
    * @param i_reason       cancel reason identifier
    * @param i_notes        cancel notes
    * @param o_epis_rec     created record identifier
    * @param o_error        error
    *
    * @return               false if errors occur, true otherwise
    *
    * @author               Pedro Carneiro
    * @version               2.6.2
    * @since                2012/08/23
    */
    FUNCTION set_epis_recomend_cancel_int
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_epis_rec IN epis_recomend.id_epis_recomend%TYPE,
        i_reason   IN cancel_info_det.id_cancel_reason%TYPE,
        i_notes    IN cancel_info_det.notes_cancel_long%TYPE,
        o_epis_rec OUT epis_recomend.id_epis_recomend%TYPE,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_er_row epis_recomend%ROWTYPE;
        l_id_er  epis_recomend.id_epis_recomend%TYPE;
        l_id_cid cancel_info_det.id_cancel_info_det%TYPE;
        l_rowids table_varchar;
    BEGIN
        g_error := 'SELECT l_er_row';
        SELECT er.*
          INTO l_er_row
          FROM epis_recomend er
         WHERE er.id_epis_recomend = i_epis_rec;
    
        g_error := 'CALL set_epis_recomend_int';
        IF NOT set_epis_recomend_int(i_lang             => i_lang,
                                     i_prof             => i_prof,
                                     i_episode          => l_er_row.id_episode,
                                     i_patient          => l_er_row.id_patient,
                                     i_flg_type         => l_er_row.flg_type,
                                     i_desc             => l_er_row.desc_epis_recomend_clob,
                                     i_parent           => l_er_row.id_epis_recomend,
                                     o_id_epis_recomend => l_id_er,
                                     o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        -- create cancel information
        l_rowids := table_varchar();
        g_error  := 'CALL ts_cancel_info_det.ins';
        ts_cancel_info_det.ins(id_prof_cancel_in        => i_prof.id,
                               id_cancel_reason_in      => i_reason,
                               dt_cancel_in             => g_sysdate_tstz,
                               notes_cancel_long_in     => i_notes,
                               flg_notes_cancel_type_in => CASE
                                                               WHEN i_notes IS NULL THEN
                                                                NULL
                                                               ELSE
                                                                'L'
                                                           END,
                               id_cancel_info_det_out   => l_id_cid,
                               rows_out                 => l_rowids);
        g_error := 'CALL t_data_gov_mnt.process_insert';
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'CANCEL_INFO_DET',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        -- cancel epis_recomend
        l_rowids := table_varchar();
        g_error  := 'CALL ts_epis_recomend.upd';
        ts_epis_recomend.upd(id_epis_recomend_in    => l_id_er,
                             flg_status_in          => pk_alert_constant.g_cancelled,
                             flg_status_nin         => FALSE,
                             id_cancel_info_det_in  => l_id_cid,
                             id_cancel_info_det_nin => FALSE,
                             rows_out               => l_rowids);
        g_error := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_RECOMEND',
                                      i_rowids       => l_rowids,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('FLG_STATUS', 'ID_CANCEL_INFO_DET'));
    
        o_epis_rec := l_id_er;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'SET_EPIS_RECOMEND_CANCEL_INT',
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_epis_recomend_cancel_int;

    /*******************************************************************************************************************************************
    * set_epis_recomend Guardar recomendações por profissional e tipo
    * DB layer internal function (performs no commit).
    *
    * @param i_lang             language identifier
    * @param i_episode          episode identifier
    * @param i_prof             logged professional structure
    * @param i_patient          patient identifier
    * @param i_flg_type         record type
    * @param i_desc             recomend notes
    * @param i_parent           original record identifier
    * @param o_id_epis_recomend created record identifier
    * @param o_error            error
    *
    * @value i_flg_type {*} 'P' Recomendações ao doente {*} 'M' - Notas do médico {*} 'D' Recomendações a outro médico {*} 'R' Receita {*} 'N' Alta de enfermagem {*} 'A' Avaliação
    *
    * @return                   Return false if exist an error and true otherwise
    *
    * @author                   RB
    * @version                  1.0
    * @since                    2005/04/12
    *
    * Changes:
    *
    * @author                   SS
    * @since                    2005/04/12
    *
    * @author                   SS
    * @since                    2006/10/12
    * reason                           Mostrar sempre o último temporário qualquer seja o utilizador (independentemente de ser o autor do registo)
    *
    * @author                   Ariel Machado
    * @version                  2.4.3-Denormalized
    * @since                    2008/09/16
    * reason                    DB Denormalization - Updates to discharge_notes uses framework
    *
    * @author                   Teresa Coutinho
    * @version                  2.5
    * @since                    2008/03/24
    * reason                    o_id_epis_recomend for Progress notes
    *
    * @author                   Pedro Carneiro
    * @version                  2.6.0.4
    * @since                    2010/10/15
    * reason                    internal function for transaction control
    *******************************************************************************************************************************************/

    FUNCTION set_epis_recomend_int
    (
        i_lang             IN language.id_language%TYPE,
        i_episode          IN epis_recomend.id_episode%TYPE,
        i_prof             IN profissional,
        i_patient          IN patient.id_patient%TYPE,
        i_flg_type         IN epis_recomend.flg_type%TYPE,
        i_desc             IN epis_recomend.desc_epis_recomend_clob%TYPE,
        i_parent           IN epis_recomend.id_epis_recomend%TYPE,
        o_id_epis_recomend OUT epis_recomend.id_epis_recomend%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'SET_EPIS_RECOMEND_INT';
        l_temp             epis_recomend.flg_temp%TYPE;
        l_id_patient       patient.id_patient%TYPE;
        l_rowids           table_varchar;
        l_epis_recomend_nk epis_recomend.id_epis_recomend%TYPE;
    
        CURSOR c_patient IS
            SELECT e.id_patient
              FROM episode e
             WHERE e.id_episode = i_episode;
    
        l_internal_error EXCEPTION;
    
        l_where_in VARCHAR2(2000);
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        -- set patient identifier
        IF i_patient IS NULL
        THEN
            g_error := 'GET PATIENT ID';
            OPEN c_patient;
            FETCH c_patient
                INTO l_id_patient;
            CLOSE c_patient;
        ELSE
            l_id_patient := i_patient;
        END IF;
    
        IF i_parent IS NOT NULL
        THEN
            -- outdate record
            g_error := 'CALL ts_epis_recomend.upd I';
            ts_epis_recomend.upd(id_epis_recomend_in => i_parent,
                                 flg_status_in       => pk_alert_constant.g_outdated,
                                 flg_status_nin      => FALSE,
                                 rows_out            => l_rowids);
            g_error := 'CALL t_data_gov_mnt.process_update I';
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_RECOMEND',
                                          i_rowids       => l_rowids,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('FLG_STATUS'));
        END IF;
    
        IF i_flg_type IN (g_type_n, g_type_m)
        THEN
            g_error            := 'INSERT INTO EPIS_RECOMEND(1)';
            l_rowids           := NULL;
            l_epis_recomend_nk := ts_epis_recomend.next_key();
            ts_epis_recomend.ins(id_epis_recomend_in        => l_epis_recomend_nk,
                                 dt_epis_recomend_tstz_in   => g_sysdate_tstz,
                                 desc_epis_recomend_clob_in => i_desc,
                                 flg_type_in                => i_flg_type,
                                 id_episode_in              => i_episode,
                                 id_patient_in              => l_id_patient,
                                 id_professional_in         => i_prof.id,
                                 flg_temp_in                => g_flg_def,
                                 flg_status_in              => pk_alert_constant.g_active,
                                 id_epis_recomend_parent_in => i_parent,
                                 rows_out                   => l_rowids);
        
            --Process the events associated to an insert on epis_recomend
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_RECOMEND',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
        ELSE
            g_error            := 'INSERT INTO EPIS_RECOMEND(2)';
            l_rowids           := NULL;
            l_epis_recomend_nk := ts_epis_recomend.next_key();
            ts_epis_recomend.ins(id_epis_recomend_in        => l_epis_recomend_nk,
                                 dt_epis_recomend_tstz_in   => g_sysdate_tstz,
                                 desc_epis_recomend_clob_in => i_desc,
                                 flg_type_in                => i_flg_type,
                                 id_episode_in              => i_episode,
                                 id_patient_in              => l_id_patient,
                                 id_professional_in         => i_prof.id,
                                 flg_temp_in                => g_flg_def,
                                 flg_status_in              => pk_alert_constant.g_active,
                                 id_epis_recomend_parent_in => i_parent,
                                 rows_out                   => l_rowids);
        
            --Process the events associated to an insert on epis_recomend
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_RECOMEND',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
            --Actualiza flag dos registos anteriores para H - histórico se ainda não tiver passado registos de temporários para definitivos
            IF l_temp = g_flg_temp
            THEN
                g_error := 'GET SEQ_EPIS_RECOMEND.NEXTVAL';
                --l_next  := ts_epis_recomend.next_key();
                l_where_in := 'flg_temp = ''' || g_flg_temp || ''' AND flg_type = ''' || i_flg_type ||
                              ''' AND id_episode = ' || i_episode || ' AND id_epis_recomend < ' || l_epis_recomend_nk;
                g_error    := 'UPDATE EPIS_RECOMEND';
                l_rowids   := NULL;
                ts_epis_recomend.upd(flg_temp_in => g_flg_hist, where_in => l_where_in, rows_out => l_rowids);
            
                --Process the events associated to an update on epis_recomend
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_RECOMEND',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            END IF; --L_TEMP
        
        END IF; --I_FLG_TYPE
    
        o_id_epis_recomend := l_epis_recomend_nk;
        RETURN TRUE;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_epis_recomend_int;
    --

    /*******************************************************************************************************************************************
    * set_epis_recomend Guardar recomendações por profissional e tipo
    *
    * @param i_lang                   Língua registada como preferência do profissional
    * @param i_episode                ID do episódio
    * @param i_prof                   Profissional que regista
    * @param i_flg_type               Tipo
    * @param i_desc 
    * @param o_error
    *
    * @value i_flg_type {*} 'P' Recomendações ao doente {*} 'M' - Notas do médico {*} 'D' Recomendações a outro médico {*} 'R' Receita {*} 'N' Alta de enfermagem {*} 'A' Avaliação
    *
    * @return                         Return false if exist an error and true otherwise
    *
    * @author                         RB
    * @version                        1.0
    * @since                          2005/04/12
    *
    * Changes:
    *
    * @author                          SS
    * @since                           2005/04/12
    *
    * @author                          SS
    * @since                           2006/10/12
    * reason                           Mostrar sempre o último temporário qualquer seja o utilizador (independentemente de ser o autor do registo)
    *
    * @author                          Ariel Machado
    * @version                         2.4.3-Denormalized
    * @since                           2008/09/16
    * reason                           DB Denormalization - Updates to discharge_notes uses framework
    *
    * @author                          Teresa Coutinho
    * @version                         2.5
    * @since                           2008/03/24
    * reason                           o_id_epis_recomend for Progress notes
    *******************************************************************************************************************************************/
    FUNCTION set_epis_recomend
    (
        i_lang             IN language.id_language%TYPE,
        i_episode          IN epis_recomend.id_episode%TYPE,
        i_prof             IN profissional,
        i_flg_type         IN epis_recomend.flg_type%TYPE,
        i_desc             IN epis_recomend.desc_epis_recomend_clob%TYPE,
        i_parent           IN epis_recomend.id_epis_recomend_parent%TYPE := NULL,
        o_id_epis_recomend OUT epis_recomend.id_epis_recomend%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_prof_cat_type category.flg_type%TYPE;
        l_internal_error EXCEPTION;
    BEGIN
        g_error := 'CALL set_epis_recomend_int';
        IF NOT set_epis_recomend_int(i_lang             => i_lang,
                                     i_prof             => i_prof,
                                     i_episode          => i_episode,
                                     i_patient          => NULL,
                                     i_flg_type         => i_flg_type,
                                     i_desc             => i_desc,
                                     i_parent           => i_parent,
                                     o_id_epis_recomend => o_id_epis_recomend,
                                     o_error            => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF i_flg_type != g_nurse
        THEN
            l_prof_cat_type := g_doctor;
        ELSE
            l_prof_cat_type := g_nurse;
        END IF;
    
        --Actualiza dados das observações
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => l_prof_cat_type,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_EPIS_RECOMEND',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_EPIS_RECOMEND',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_epis_recomend;

    --
    FUNCTION check_exist_clin_disch
    (
        i_lang       IN language.id_language%TYPE,
        i_id_episode IN discharge.id_episode%TYPE,
        o_error      OUT t_error_out
    ) RETURN VARCHAR2 IS
        /******************************************************************************
           OBJECTIVO:   Verifica se para o episódio existe uma alta médica não cancelada
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                                    I_ID_EPISODE - ID do episódio
                        Saida:   O_ERROR - erro
        
          CRIAÇÃO: RB 2005/04/13
          NOTAS:
        *********************************************************************************/
        l_id_discharge discharge.id_discharge%TYPE;
        l_exists_disch VARCHAR2(1);
    
        CURSOR c_disch IS
            SELECT id_discharge
              FROM discharge
             WHERE id_episode = i_id_episode
               AND dt_med_tstz IS NOT NULL
               AND dt_cancel_tstz IS NULL;
    
    BEGIN
    
        g_error        := 'GET CURSOR PROF';
        g_sysdate_tstz := current_timestamp;
    
        --Valida se a alta ainda não está cancelada
        g_error := 'GET CURSOR DISCH';
        OPEN c_disch;
        FETCH c_disch
            INTO l_id_discharge;
        g_found := c_disch%NOTFOUND;
        CLOSE c_disch;
        IF g_found
        THEN
            l_exists_disch := g_found_false;
        ELSE
            l_exists_disch := g_found_true;
        END IF;
    
        RETURN l_exists_disch;
    
    END check_exist_clin_disch;
    --
    FUNCTION get_discharge_type
    (
        i_lang  IN language.id_language%TYPE,
        o_type  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Obter lista de tipos de alta
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                        Saida:   O_TYPE - tipos de alta
                                 O_ERROR - erro
        
          CRIAÇÃO: CRS 2005/07/27
          NOTAS:
        *********************************************************************************/
    BEGIN
        g_error := 'GET CURSOR';
        RETURN pk_sysdomain.get_values_domain(g_domain_disch, i_lang, o_type);
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_TYPE',
                                              o_error);
            pk_types.open_my_cursor(o_type);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END;
    --
    FUNCTION get_transp_entity_list
    (
        i_lang   IN language.id_language%TYPE,
        i_type   IN transp_entity.flg_type%TYPE,
        i_transp IN transp_entity.flg_transp%TYPE,
        i_prof   IN profissional,
        o_transp OUT pk_types.cursor_type,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Obter lista de entidades que transportam doentes
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                            I_TYPE - Tipo: A - administrativa, D - médica
                                 I_TRANSP - Tipo de transporte: A - chegada, D - partida
                        Saida: O_TRANSP - Entidades de Transporte
                         O_ERROR - erro
        
          CRIAÇÃO: AA 2005/09/12
          NOTAS:
        *********************************************************************************/
        l_id_transp_entity     transp_entity.id_transp_entity%TYPE;
        l_id_transp_entity_adm transp_entity.id_transp_entity%TYPE;
    BEGIN
        l_id_transp_entity     := pk_sysconfig.get_config('ID_TRANSP_ENTITY', i_prof);
        l_id_transp_entity_adm := pk_sysconfig.get_config('ID_TRANSP_ENTITY_ADM', i_prof);
        g_error                := 'GET CURSOR';
        OPEN o_transp FOR
            SELECT DISTINCT te.id_transp_entity,
                            pk_translation.get_translation(i_lang, te.code_transp_entity) transp_entity,
                            decode(te.id_transp_entity,
                                   decode(i_type, g_doctor, l_id_transp_entity, l_id_transp_entity_adm),
                                   'Y',
                                   'N') flg_default,
                            te.rank
              FROM transp_entity te, transp_ent_inst tei
             WHERE te.flg_type = i_type
               AND tei.id_transp_entity = te.id_transp_entity
               AND te.flg_transp = i_transp
               AND te.flg_available = g_flg_available
               AND tei.flg_available = g_flg_available
               AND tei.id_institution = i_prof.institution
               AND nvl(tei.flg_type, g_transp_all) IN (g_transp_disch, g_transp_all)
             ORDER BY rank, transp_entity;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_TRANSP_ENTITY_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_transp);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END;
    --
    /************************************************************************************************
    NAME: GET_PATIENT_TRANSPORTATION
    CREATION INFO: CARLOS FERREIRA 2006/10/03
    GOAL: RETURNS CURSOR OF AVAILABLE PATIENT TRANSPORTS
    
    PARAMETERS:
    ---------------------------------------------------------------------------------------------------
    | PARAMETER NAME      |   DATATYPE             | I/O |      DESCRIPTION                           |
    ---------------------------------------------------------------------------------------------------
    I_LANG                | NUMBER                 | IN  | ID OF language                             |
    I_PROF                | PROFISSIONAL     | IN  | ID OF PROFESSIONAL, INSTITUTION, SOFTWARE  |
    I_ID_DISCHARGE_REASON | NUMBER                 | IN  | ID OF language                             |
    O_SQL                 | PK_TYPES.CURSOR_TYPE   | IN  | CONTAINS RESULT OF DOMAIN                  |
    O_ERROR               | VARCHAR2               | OUT | RETURNS ERROR MESSAGE, IF EXISTS           |
    ---------------------------------------------------------------------------------------------------
    OBS: FUNCTION CREATED FOR THE PURPOSE OF EXTRACTING POSSIBLE PATIENT CONDITIONS
    
    Rui Campos 2006/11/23:
        - Changed to return only departing transportations.
    ************************************************************************************************/
    FUNCTION get_patient_transportations
    (
        i_lang                IN NUMBER,
        i_prof                IN profissional,
        i_id_discharge_reason IN NUMBER,
        o_sql                 OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        OPEN o_sql FOR
            SELECT a.id_disch_rea_transp_ent_inst data,
                   pk_translation.get_translation(i_lang, c.code_transp_entity) label
              FROM disch_rea_transp_ent_inst a, transp_ent_inst b, transp_entity c
             WHERE a.id_discharge_reason = i_id_discharge_reason
               AND a.id_transp_ent_inst = b.id_transp_ent_inst
               AND a.flg_available = 'Y'
               AND b.id_transp_entity = c.id_transp_entity
               AND b.id_institution = i_prof.institution
               AND nvl(b.flg_type, g_transp_all) IN (g_transp_disch, g_transp_all)
               AND c.flg_transp = g_transp_depart
               AND c.flg_type = 'D'
             ORDER BY label;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_PATIENT_TRANSPORTATIONS',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_patient_transportations;
    --
    FUNCTION get_caretakers_disch
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        /************************************************************************************************
        NAME: GET_CARETAKERS_DISCH
        CREATION INFO: CARLOS FERREIRA 2006/10/03
        GOAL: RETURNS CURSOR OF AVAILBALE CARETAKERS
        
        PARAMETERS:
        ------------------------------------------------------------------------------------------------
        | PARAMETER NAME   |   DATATYPE             | I/O |      DESCRIPTION                           |
        ------------------------------------------------------------------------------------------------
        I_LANG             | NUMBER                 | IN  | ID OF language                             |
        I_PROF             | PROFISSIONAL     | IN  | ID OF PROFESSIONAL, INSTITUTION, SOFTWARE  |
        O_SQL              | PK_TYPES.CURSOR_TYPE   | IN  | CONTAINS RESULT OF DOMAIN                  |
        O_ERROR            | VARCHAR2               | OUT | RETURNS ERROR MESSAGE, IF EXISTS           |
        ------------------------------------------------------------------------------------------------
        OBS: FUNCTION CREATED FOR THE PURPOSE OF EXTRACTING POSSIBLE PATIENT CONDITIONS
        
        ************************************************************************************************/
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL.FLG_CARETAKER_DISCH';
    
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_CARETAKERS_DISCH',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_caretakers_disch;
    --
    FUNCTION get_caretakers_lwbs
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        /************************************************************************************************
        NAME: GET_CARETAKERS_LWBS
        CREATION INFO: CARLOS FERREIRA 2006/10/03
        GOAL: RETURNS CURSOR OF AVAILBALE CARETAKERS
        
        PARAMETERS:
        ------------------------------------------------------------------------------------------------
        | PARAMETER NAME   |   DATATYPE             | I/O |      DESCRIPTION                           |
        ------------------------------------------------------------------------------------------------
        I_LANG             | NUMBER                 | IN  | ID OF language                             |
        I_PROF             | PROFISSIONAL     | IN  | ID OF PROFESSIONAL, INSTITUTION, SOFTWARE  |
        O_SQL              | PK_TYPES.CURSOR_TYPE   | IN  | CONTAINS RESULT OF DOMAIN                  |
        O_ERROR            | VARCHAR2               | OUT | RETURNS ERROR MESSAGE, IF EXISTS           |
        ------------------------------------------------------------------------------------------------
        OBS: FUNCTION CREATED FOR THE PURPOSE OF EXTRACTING POSSIBLE PATIENT CONDITIONS
        
        ************************************************************************************************/
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL.FLG_CARETAKER_LWBS';
    
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_CARETAKERS_LWBS',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_caretakers_lwbs;
    --
    FUNCTION get_caretakers_ama
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        /************************************************************************************************
        NAME: GET_CARETAKERS_LWBS
        CREATION INFO: CARLOS FERREIRA 2006/10/03
        GOAL: RETURNS CURSOR OF AVAILBALE CARETAKERS
        
        PARAMETERS:
        ------------------------------------------------------------------------------------------------
        | PARAMETER NAME   |   DATATYPE             | I/O |      DESCRIPTION                           |
        ------------------------------------------------------------------------------------------------
        I_LANG             | NUMBER                 | IN  | ID OF language                             |
        I_PROF             | PROFISSIONAL     | IN  | ID OF PROFESSIONAL, INSTITUTION, SOFTWARE  |
        O_SQL              | PK_TYPES.CURSOR_TYPE   | IN  | CONTAINS RESULT OF DOMAIN                  |
        O_ERROR            | VARCHAR2               | OUT | RETURNS ERROR MESSAGE, IF EXISTS           |
        ------------------------------------------------------------------------------------------------
        OBS: FUNCTION CREATED FOR THE PURPOSE OF EXTRACTING POSSIBLE PATIENT CONDITIONS
        
        ************************************************************************************************/
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL.FLG_CARETAKER_AMA';
    
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_CARETAKERS_AMA',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_caretakers_ama;
    --
    FUNCTION set_discharge
    (
        i_lang                         IN NUMBER,
        i_episode                      IN NUMBER,
        i_prof                         IN profissional,
        i_reas_dest                    IN NUMBER,
        i_disch_type                   IN VARCHAR2,
        i_flg_type                     IN VARCHAR2,
        i_notes                        IN VARCHAR2,
        i_transp                       IN NUMBER,
        i_justify                      IN VARCHAR2,
        i_prof_cat_type                IN VARCHAR2,
        i_flg_pat_condition            IN VARCHAR2,
        i_id_transport_type            IN NUMBER,
        i_id_disch_rea_transp_ent_inst IN NUMBER,
        i_flg_caretaker                IN VARCHAR2,
        i_caretaker_notes              IN VARCHAR2,
        i_flg_follow_up_by             IN VARCHAR2,
        i_follow_up_notes              IN VARCHAR2,
        i_follow_up_date               IN DATE,
        i_flg_written_notes            IN VARCHAR2,
        i_flg_voluntary                IN VARCHAR2,
        i_flg_pat_report               IN VARCHAR2,
        i_flg_transfer_form            IN VARCHAR2,
        i_id_prof_admitting            IN NUMBER,
        i_prof_admitting_desc          IN VARCHAR2,
        i_id_dep_clin_serv_admiting    IN NUMBER,
        i_dep_clin_serv_admiting_desc  IN VARCHAR2,
        i_flg_summary_report           IN VARCHAR2,
        i_flg_autopsy_consent          IN VARCHAR2,
        i_autopsy_consent_desc         IN VARCHAR2,
        i_flg_orgn_dntn_info           IN VARCHAR2,
        i_orgn_dntn_info               IN VARCHAR2,
        i_flg_examiner_notified        IN VARCHAR2,
        i_examiner_notified_info       IN VARCHAR2,
        i_flg_orgn_dntn_form_complete  IN VARCHAR2,
        i_flg_ama_form_complete        IN VARCHAR2,
        i_flg_lwbs_form_complete       IN VARCHAR2,
        i_add_notes                    IN VARCHAR2,
        --  i_mse_type                     IN VARCHAR2,
        o_flg_show     OUT VARCHAR2,
        o_msg_title    OUT VARCHAR2,
        o_msg_text     OUT VARCHAR2,
        o_button       OUT VARCHAR2,
        o_id_discharge OUT NUMBER,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        /************************************************************************************************
        NAME: SET_DISCHARGE
        CREATION INFO: CARLOS FERREIRA 2006/10/03
        GOAL: SAVES INFO FROM DISCHARGE
        
        PARAMETERS:
        -----------------------------------------------------------------------------------------------
        | PARAMETER NAME      |   DATATYPE         | I/O |      DESCRIPTION                           |
        -----------------------------------------------------------------------------------------------
        I_LANG                | NUMBER             | IN  | ID OF language                             |
        I_EPISODE             | NUMBER             | IN  | ID OF EPISODE                              |
        I_PROF                | PROFESSIONAL | IN  | ID OF PROFESSIONAL, INSTITUTION, SOFTWARE  |
        I_REAS_DEST           | NUMBER             | IN  | ID OF REASON / DISCHARGE                   |
        I_DISCH_TYPE          | VARCHAR2           | IN  | TYPE OF DISCHARGE ?                        |
        I_FLG_TYPE            | VARCHAR2           | IN  |                                            |
        I_NOTES               | VARCHAR2           | IN  |                                            |
        I_TRANSP              | NUMBER             | IN  |                                            |
        I_JUSTIFY             | VARCHAR2           | IN  |                                            |
        I_PROF_CAT_TYPE       | VARCHAR2           | IN  | PROFESSIONAL CATEGORY                      |
        I_FLG_PAT_CONDITION   | VARCHAR2           | IN  | PATIENT CONDITION                          |
        I_ID_TRANSPORT_TYPE   | NUMBER             | IN  | TIPO DE TRANSPORTE                         |
        I_FLG_CARETAKER       | VARCHAR2           | IN  | CARETAKER TYPE                             |
        I_CARETAKER_NOTES     | VARCHAR2           | IN  | NOTES RELATED TO CARETAKER TYPE            |
        I_FLG_FOLLOW_UP_BY    | VARCHAR2           | IN  | CATEGORY OF WHO IS DOING FOLLOW UP         |
        I_FOLLOW_UP_NOTES     | VARCHAR2           | IN  | NOTES RELATED TO FOLLOW-UP-BY              |
        I_FOLLOW_UP_DATE      | VARCHAR2           | IN  | DATE FOR FOLLOW UP                         |
        I_FLG_WRITTEN_NOTES   | VARCHAR2           | IN  | INDICATES IF WRITTEN HAVE BEEN GIVEN       |
        I_ADD_NOTES           | VARCHAR2           | IN  | ADDITIONAL NOTES                           |
        O_FLG_SHOW            | VARCHAR2           | OUT |                                            |
        O_MSG_TITLE           | VARCHAR2           | OUT |                                            |
        O_MSG_TEXT            | VARCHAR2           | OUT |                                            |
        O_BUTTON              | VARCHAR2           | OUT |                                            |
        O_ID_DISCHARGE        | NUMBER             | OUT | ID OF DISCHARGE CREATED                    |
        O_ERROR               | VARCHAR2           | OUT | RETURNS ERROR MESSAGE, IF EXISTS           |
        -----------------------------------------------------------------------------------------------
        OBS:
        ************************************************************************************************/
        l_ret     BOOLEAN;
        l_date    DATE;
        l_warning VARCHAR2(4000);
    
        l_error_common   EXCEPTION;
        l_internal_error EXCEPTION;
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
    BEGIN
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(l_transaction_id, i_prof);
    
        l_ret := set_discharge_master(i_lang,
                                      i_episode,
                                      i_prof,
                                      i_reas_dest,
                                      i_disch_type,
                                      i_flg_type,
                                      i_notes,
                                      i_transp,
                                      i_justify,
                                      i_prof_cat_type,
                                      l_transaction_id,
                                      o_flg_show,
                                      o_msg_title,
                                      o_msg_text,
                                      o_button,
                                      o_id_discharge,
                                      l_warning,
                                      o_error);
        IF l_ret = FALSE
           AND l_warning IS NOT NULL
        THEN
            RAISE l_error_common;
        END IF;
        IF l_ret = FALSE
           AND l_warning IS NULL
        THEN
            RAISE l_internal_error;
        END IF;
    
        l_date := i_follow_up_date; --TO_DATE( I_FOLLOW_UP_DATE, G_FLASH_MASK );
    
        IF NOT set_discharge_detail(i_lang                         => i_lang,
                                    i_prof                         => i_prof,
                                    i_id_discharge                 => o_id_discharge,
                                    i_flg_pat_condition            => i_flg_pat_condition,
                                    i_id_transport_type            => i_id_transport_type,
                                    i_id_disch_rea_transp_ent_inst => i_id_disch_rea_transp_ent_inst,
                                    i_flg_caretaker                => i_flg_caretaker,
                                    i_caretaker_notes              => i_caretaker_notes,
                                    i_flg_follow_up_by             => i_flg_follow_up_by,
                                    i_follow_up_notes              => i_follow_up_notes,
                                    i_follow_up_date_str           => l_date, ---I_FOLLOW_UP_DATE,
                                    i_flg_written_notes            => i_flg_written_notes,
                                    i_flg_voluntary                => i_flg_voluntary,
                                    i_flg_pat_report               => i_flg_pat_report,
                                    i_flg_transfer_form            => i_flg_transfer_form,
                                    i_id_prof_admitting            => i_id_prof_admitting,
                                    i_prof_admitting_desc          => i_prof_admitting_desc,
                                    i_id_dep_clin_serv_admiting    => i_id_dep_clin_serv_admiting,
                                    i_dep_clin_serv_admiting_desc  => i_dep_clin_serv_admiting_desc,
                                    i_flg_summary_report           => i_flg_summary_report,
                                    i_flg_autopsy_consent          => i_flg_autopsy_consent,
                                    i_autopsy_consent_desc         => i_autopsy_consent_desc,
                                    i_flg_orgn_dntn_info           => i_flg_orgn_dntn_info,
                                    i_orgn_dntn_info               => i_orgn_dntn_info,
                                    i_flg_examiner_notified        => i_flg_examiner_notified,
                                    i_examiner_notified_info       => i_examiner_notified_info,
                                    i_flg_orgn_dntn_form_complete  => i_flg_orgn_dntn_form_complete,
                                    i_flg_ama_form_complete        => i_flg_ama_form_complete,
                                    i_flg_lwbs_form_complete       => i_flg_lwbs_form_complete,
                                    i_notes                        => i_add_notes,
                                    o_error                        => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        -- Valida necessidade de criação de alerta
        -- Válido para os alertas 30 e 31
        IF NOT set_disch_edis_to_inp_alert(i_lang, i_prof, i_episode, o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        l_ret := pk_alerts.delete_sys_alert_event_episode(i_lang    => i_lang,
                                                          i_prof    => i_prof,
                                                          i_episode => i_episode,
                                                          i_delete  => 'Y',
                                                          o_error   => o_error);
    
        pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_error_common THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   'T_DISCH_ERROR',
                                   l_warning,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_DISCHARGE',
                                   l_warning,
                                   'U');
            
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                pk_utils.undo_changes; -- ROLLBACK
                pk_alert_exceptions.reset_error_state();
                RETURN FALSE;
            END;
        
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_discharge;
    --
    /************************************************************************************************
    NAME: SET_DISCHARGE_DETAIL
    CREATION INFO: CARLOS FERREIRA 2006/10/03
    GOAL: SAVES INFO FROM DISCHARGE
    
    PARAMETERS:
    ------------------------------------------------------------------------------------------------
    | PARAMETER NAME   |   DATATYPE             | I/O |      DESCRIPTION                           |
    ------------------------------------------------------------------------------------------------
    I_LANG             | NUMBER                 | IN  | ID OF language                             |
    I_PROF             | PROFISSIONAL     | IN  | ID OF PROFESSIONAL, INSTITUTION, SOFTWARE  |
    O_SQL              | PK_TYPES.CURSOR_TYPE   | IN  | CONTAINS RESULT OF DOMAIN                  |
    O_ERROR            | VARCHAR2               | OUT | RETURNS ERROR MESSAGE, IF EXISTS           |
    ------------------------------------------------------------------------------------------------
    OBS: FUNCTION CREATED FOR THE "ALLOCATING BED" FUNCTIONALITY. DEPENDING OF I_TYPE, THE FUNCTION RETURNS A CURSOR
         OF SERVICES, ROOMS OR BEDS AVAILABLE.
    ************************************************************************************************/
    FUNCTION set_discharge_detail
    (
        i_lang                         IN NUMBER,
        i_prof                         IN profissional,
        i_id_discharge                 IN NUMBER,
        i_flg_pat_condition            IN VARCHAR2,
        i_id_transport_type            IN NUMBER,
        i_id_disch_rea_transp_ent_inst IN NUMBER,
        i_flg_caretaker                IN VARCHAR2,
        i_caretaker_notes              IN VARCHAR2,
        i_flg_follow_up_by             IN VARCHAR2,
        i_follow_up_notes              IN VARCHAR2,
        i_follow_up_date_str           IN VARCHAR2, --SS
        i_flg_written_notes            IN VARCHAR2,
        i_flg_voluntary                IN VARCHAR2,
        i_flg_pat_report               IN VARCHAR2,
        i_flg_transfer_form            IN VARCHAR2,
        i_id_prof_admitting            IN NUMBER,
        i_prof_admitting_desc          IN VARCHAR2,
        i_id_dep_clin_serv_admiting    IN NUMBER,
        i_dep_clin_serv_admiting_desc  IN VARCHAR2,
        i_flg_summary_report           IN VARCHAR2,
        i_flg_autopsy_consent          IN VARCHAR2,
        i_autopsy_consent_desc         IN VARCHAR2,
        i_flg_orgn_dntn_info           IN VARCHAR2,
        i_orgn_dntn_info               IN VARCHAR2,
        i_flg_examiner_notified        IN VARCHAR2,
        i_examiner_notified_info       IN VARCHAR2,
        i_flg_orgn_dntn_form_complete  IN VARCHAR2,
        i_flg_ama_form_complete        IN VARCHAR2,
        i_flg_lwbs_form_complete       IN VARCHAR2,
        i_notes                        IN VARCHAR2,
        i_flg_autopsy                  IN discharge_detail.flg_autopsy%TYPE DEFAULT NULL,
        o_error                        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_next       NUMBER;
        l_id_episode discharge.id_episode%TYPE;
        l_currency   discharge.currency%TYPE;
        l_internal_error EXCEPTION;
    BEGIN
    
        g_error := 'GENERATE PRIMARY KEY';
        SELECT seq_discharge_detail.nextval
          INTO l_next
          FROM dual;
    
        g_error := 'INSERT DETAIL';
        INSERT INTO discharge_detail
            (id_discharge_detail,
             id_discharge,
             flg_pat_condition,
             id_transport_type,
             id_disch_rea_transp_ent_inst,
             flg_caretaker,
             caretaker_notes,
             flg_follow_up_by,
             follow_up_notes,
             follow_up_date_tstz,
             flg_written_notes,
             flg_voluntary,
             flg_pat_report,
             flg_transfer_form,
             id_prof_admitting,
             prof_admitting_desc,
             id_dep_clin_serv_admiting,
             dep_clin_serv_admiting_desc,
             flg_summary_report,
             flg_autopsy_consent,
             autopsy_consent_desc,
             flg_orgn_dntn_info,
             orgn_dntn_info,
             flg_examiner_notified,
             examiner_notified_info,
             flg_orgn_dntn_form_complete,
             flg_ama_form_complete,
             flg_lwbs_form_complete,
             notes,
             flg_autopsy)
        VALUES
            (l_next,
             i_id_discharge,
             i_flg_pat_condition,
             i_id_transport_type,
             i_id_disch_rea_transp_ent_inst,
             i_flg_caretaker,
             i_caretaker_notes,
             i_flg_follow_up_by,
             i_follow_up_notes,
             pk_date_utils.get_string_tstz(i_lang, i_prof, i_follow_up_date_str, NULL),
             i_flg_written_notes,
             i_flg_voluntary,
             i_flg_pat_report,
             i_flg_transfer_form,
             i_id_prof_admitting,
             i_prof_admitting_desc,
             i_id_dep_clin_serv_admiting,
             i_dep_clin_serv_admiting_desc,
             i_flg_summary_report,
             i_flg_autopsy_consent,
             i_autopsy_consent_desc,
             i_flg_orgn_dntn_info,
             i_orgn_dntn_info,
             i_flg_examiner_notified,
             i_examiner_notified_info,
             i_flg_orgn_dntn_form_complete,
             i_flg_ama_form_complete,
             i_flg_lwbs_form_complete,
             i_notes,
             i_flg_autopsy);
    
        --Nuno Neves 24/12/2010 (ALERT-151966) 
    
        SELECT d.id_episode, d.currency
          INTO l_id_episode, l_currency
          FROM discharge d
         WHERE d.id_discharge = i_id_discharge;
    
        g_error := 'CHECK REQUEST PRINT REPORT';
        IF NOT pk_api_discharge.check_request_print_report(i_lang,
                                                           l_id_episode,
                                                           i_id_discharge,
                                                           i_prof,
                                                           l_currency,
                                                           o_error)
        
        THEN
            RAISE l_internal_error;
        END IF;
    
        --END (ALERT-151966)
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_DETAIL',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_discharge_detail;
    --
    /************************************************************************************************
    NAME: SET_DISCHARGE_MASTER
    CREATION INFO: CARLOS FERREIRA 2006/10/03
    GOAL: CREATE DISCHARGE ORDER
    
    HISTORY:    Rui Campos 2006/11/29:
                    - If I_FLG_TYPE=D (Doctor) and episode is an ORIS episode, updates patient status to O (Surgery Room Discharge).
                Rui Campos 2006/12/09:
                    - If I_FLG_TYPE=D (Doctor) and episode is an ORIS episode, closes the visit.
    
    PARAMETERS:
    -------------------------------------------------------------------------------------------------
    | PARAMETER NAME   |   DATATYPE             | I/O |      DESCRIPTION                            |
    -------------------------------------------------------------------------------------------------
    I_LANG             | NUMBER                 | IN  | ID OF language                              |
    I_EPISODE          | NUMBER                 | IN  | ID OF EPISODE                               |
    I_PROF             | PROFISSIONAL     | IN  | ID OF PROFESSIONAL, INSTITUTION, SOFTWARE   |
    I_REAS_DEST        | NUMBER                 | IN  | MOTIVE + DISCHARGE DESTINATION              |
    I_DISCH_TYPE       | VARCHAR2               | IN  | F-EPISOD END, D-DISCHARGE                   |
    I_FLG_TYPE         | VARCHAR2               | IN  | (D)ISCHARGE, AD(M)INISTRATIVE               |
    I_NOTES            | VARCHAR2               | IN  | NOTES                                       |
    I_TRANSP           | NUMBER                 | IN  | ID OF TRANSPORT                             |
    I_JUSTIFY          | VARCHAR2               | IN  | DISCHARGE JUSTIFICATION                     |
    I_PROF_CAT_TYPE    | VARCHAR2               | IN  | CATEGORY TYPE OF PROFESSIONAL               |
    O_MSG_TITLE        | VARCHAR2               | OUT |                                             |
    O_MSG_TEXT         | VARCHAR2               | OUT |                                             |
    O_BUTTON           | VARCHAR2               | OUT |                                             |
    O_ID_DISCHARGE     | NUMBER                 | OUT | ID OF DISCHARGE GENERATED                   |
    O_ERROR            | VARCHAR2               | OUT | RETURNS ERROR MESSAGE, IF EXISTS            |
    -------------------------------------------------------------------------------------------------
    OBS: NONE.
    ************************************************************************************************/
    FUNCTION set_discharge_master
    (
        i_lang           IN language.id_language%TYPE,
        i_episode        IN discharge.id_episode%TYPE,
        i_prof           IN profissional,
        i_reas_dest      IN discharge.id_disch_reas_dest%TYPE,
        i_disch_type     IN discharge.flg_type%TYPE,
        i_flg_type       IN VARCHAR2,
        i_notes          IN discharge.notes_med%TYPE,
        i_transp         IN transp_entity.id_transp_entity%TYPE,
        i_justify        IN discharge.notes_justify %TYPE,
        i_prof_cat_type  IN category.flg_type%TYPE,
        i_transaction_id IN VARCHAR2,
        o_flg_show       OUT VARCHAR2,
        o_msg_title      OUT VARCHAR2,
        o_msg_text       OUT VARCHAR2,
        o_button         OUT VARCHAR2,
        o_id_discharge   OUT NUMBER,
        o_warning        OUT VARCHAR2,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_next              discharge.id_discharge%TYPE;
        l_id                discharge.id_discharge%TYPE;
        l_id_hist           discharge_hist.id_discharge_hist%TYPE;
        l_disch_dt          discharge.dt_med_tstz%TYPE;
        l_diag              disch_reas_dest.flg_diag%TYPE;
        l_id_epis_diagnosis epis_diagnosis.id_epis_diagnosis%TYPE;
        --l_exist_temp        VARCHAR2(1);
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient visit.id_patient%TYPE;
        --
        CURSOR c_exist IS
            SELECT id_discharge,
                   decode(i_flg_type,
                          g_doctor,
                          dt_med_tstz,
                          g_adm,
                          pk_discharge_core.get_dt_admin(i_lang, i_prof, NULL, d.flg_status_adm, d.dt_admin_tstz),
                          NULL)
              FROM discharge d
             WHERE d.id_episode = i_episode
               AND d.flg_status = g_disch_flg_active; --lg 2007-02-28 episode reopening
    
        CURSOR c_flg_diag IS
            SELECT flg_diag
              FROM disch_reas_dest
             WHERE id_disch_reas_dest = i_reas_dest;
    
        -- CRS 2007/01/13
        CURSOR c_diagn IS
            SELECT id_epis_diagnosis
              FROM epis_diagnosis
             WHERE id_episode = i_episode
                  -- CRS 2007/01/11 Exige somente diagnóstico de saída
               AND flg_type IN (g_diagn_def, g_diagn_base)
               AND flg_status NOT IN (g_diagn_canc);
    
        l_type_msg VARCHAR2(0050);
        l_error_common   EXCEPTION;
        l_error_common2  EXCEPTION;
        l_process_event  EXCEPTION;
        l_internal_error EXCEPTION;
    
        xsft             software%ROWTYPE;
        l_id_epis_type   episode.id_epis_type%TYPE;
        l_aux            VARCHAR2(2000);
        l_count          NUMBER;
        l_diag_mandatory sys_config.value%TYPE;
    
        -- denormalization variables
        l_rowids              table_varchar;
        l_dt_admin_tstz       discharge.dt_admin_tstz%TYPE;
        l_dt_med_tstz         discharge.dt_med_tstz%TYPE;
        l_dt_pend_active_tstz discharge.dt_pend_active_tstz%TYPE;
        l_flag_status         discharge.flg_status%TYPE;
        l_id_disch_reas       discharge.id_disch_reas_dest%TYPE;
        l_sysdate_tstz        TIMESTAMP WITH LOCAL TIME ZONE;
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
        l_id_schedule    schedule.id_schedule%TYPE;
        l_func_exception EXCEPTION;
        l_flg_status       discharge.flg_status%TYPE;
        l_discharge_status discharge.id_discharge_status%TYPE;
    
    BEGIN
        o_warning := NULL;
        g_sysdate := SYSDATE;
        -- José Brito 14/11/2008 Variável L_SYSDATE_TSTZ usada apenas para SET_FIRST_OBS, 
        -- para garantir que a DT_FIRST_OBS não é superior à alta médica.
        l_sysdate_tstz := current_timestamp;
        g_sysdate_tstz := current_timestamp;
        --
        l_diag_mandatory := pk_sysconfig.get_config('DISCHARGE_DIAG_MANDATORY', i_prof);
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
        --
    
        g_error := 'GET SCHEDULE ID';
        BEGIN
            SELECT DISTINCT v.id_schedule
              INTO l_id_schedule
              FROM epis_info v
             WHERE v.id_episode = i_episode;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_schedule := NULL;
        END;
    
        g_error := 'GET VISIT AND PATIENT ID';
        SELECT e.id_visit, e.id_patient, e.id_epis_type
          INTO l_id_visit, l_id_patient, l_id_epis_type
          FROM episode e
         WHERE e.id_episode = i_episode;
    
        --
        SELECT COUNT(*)
          INTO l_count
          FROM episode
         WHERE id_visit = l_id_visit
           AND flg_status NOT IN (g_epis_inactive, g_epis_canc);
        --
        -- VERIFICA SE JÁ EXISTE ALTA PARA ESTE TIPO, NESTE EPISÓDIO
        g_error := 'OPEN CURSOR C_EXIST';
        OPEN c_exist;
        FETCH c_exist
            INTO l_id, l_disch_dt;
        CLOSE c_exist;
    
        IF l_disch_dt IS NOT NULL
        THEN
            -- JÁ EXISTE ALTA DESTE TIPO, NESTE EPISÓDIO
            l_type_msg := 'DISCHARGE_M004';
            RAISE l_error_common;
        END IF;
    
        g_error := 'GET ID_DISCHARGE_STATUS';
        IF NOT pk_discharge.get_disch_flg_status(i_lang         => i_lang,
                                                 i_prof         => i_prof,
                                                 i_flg_status   => g_disch_flg_active,
                                                 i_disch_status => NULL,
                                                 o_flg_status   => l_flg_status,
                                                 o_disch_status => l_discharge_status,
                                                 o_error        => o_error)
        THEN
            RAISE l_error_common;
        END IF;
    
        --PARA AS ALTAS MÉDICAS É NECESSÁRIO VERIFICAR A OBRIGATORIEDADE DA EXISTÊNCIA DE DIAGNÓSTICO
        IF i_flg_type = g_doctor
        THEN
        
            --VERIFICA SE OBRIGA A EXISTÊNCIA DE DIAGNÓSTICO DO EPISÓDIO
            g_error := 'OPEN CURSOR C_FLG_DIAG';
            OPEN c_flg_diag;
            FETCH c_flg_diag
                INTO l_diag;
            g_found := c_flg_diag%NOTFOUND;
            CLOSE c_flg_diag;
        
            -- Não foi possível verificar obrigatoriedade de diagnóstico
            IF g_found
            THEN
                l_type_msg := 'COMMON_M001';
                RAISE l_error_common2;
            END IF;
        
            --verifica se existe diagnóstico do episódio na EPIS_DIAGNOSYS
            IF l_diag = g_flag_diag
               AND l_diag_mandatory = pk_alert_constant.g_yes
            THEN
            
                g_error := 'OPEN CURSOR C_DIAGN';
                OPEN c_diagn;
                FETCH c_diagn
                    INTO l_id_epis_diagnosis;
                g_found := c_diagn%NOTFOUND;
                CLOSE c_diagn;
            
                IF g_found
                THEN
                    -- MSG: "Para proceder à alta médica é necessário establecer um diagnóstico definitivo ou, pelo menos, enquadrar este episódio num grupo de diagnósticos. "
                    l_type_msg := 'DISCHARGE_M006';
                    RAISE l_error_common;
                END IF;
            END IF;
        END IF;
    
        --Se chegou aqui, todas as pré-condições foram satisfeitas e a alta irá ser processada
        IF l_id IS NULL
        THEN
            --Ainda não existe alta para este episódio
        
            IF i_flg_type = g_adm
            THEN
                l_type_msg := 'DISCHARGE_M007';
                RAISE l_error_common;
            END IF;
        
            --Obter próximo ID
            g_error := 'GET SEQ_DISCHARGE.NEXTVAL';
            l_next  := seq_discharge.nextval;
        
            --INSERIR NOVA ALTA
            g_error := 'INSERT DISCHARGE';
            INSERT INTO discharge
                (id_discharge,
                 id_disch_reas_dest,
                 id_episode,
                 dt_cancel_tstz,
                 id_prof_cancel,
                 notes_cancel,
                 id_prof_med,
                 dt_med_tstz,
                 notes_med,
                 id_prof_admin,
                 dt_admin_tstz,
                 notes_admin,
                 flg_status,
                 id_discharge_status,
                 flg_type,
                 id_transp_ent_med,
                 notes_justify,
                 flg_type_disch,
                 flg_status_adm,
                 flg_market)
            VALUES
                (l_next,
                 i_reas_dest,
                 i_episode,
                 NULL,
                 NULL,
                 NULL,
                 decode(i_flg_type, g_doctor, i_prof.id, NULL),
                 decode(i_flg_type, g_doctor, g_sysdate_tstz, NULL),
                 decode(i_flg_type, g_doctor, i_notes, NULL),
                 decode(i_flg_type, g_adm, i_prof.id, NULL),
                 decode(i_flg_type, g_adm, g_sysdate_tstz, NULL),
                 decode(i_flg_type, g_adm, i_notes, NULL),
                 g_disch_flg_active,
                 l_discharge_status,
                 i_disch_type,
                 decode(i_flg_type, g_doctor, i_transp, NULL),
                 i_justify,
                 decode(i_flg_type,
                        g_doctor,
                        g_doctor,
                        g_adm,
                        g_adm,
                        g_disch_type_nurse,
                        g_disch_type_nurse,
                        g_disch_type_therapist_o,
                        g_therapist,
                        NULL),
                 decode(i_flg_type, g_adm, pk_alert_constant.g_active, NULL),
                 pk_discharge_core.g_disch_type_pt)
            RETURNING id_disch_reas_dest, dt_med_tstz, dt_admin_tstz, flg_status, dt_pend_active_tstz INTO l_id_disch_reas, l_dt_med_tstz, l_dt_admin_tstz, l_flag_status, l_dt_pend_active_tstz;
        
            o_id_discharge := l_next;
        ELSE
            g_error := 'UPDATE DISCHARGE';
            UPDATE discharge
               SET id_prof_med       = nvl(id_prof_med, decode(i_flg_type, g_doctor, i_prof.id, NULL)),
                   dt_med_tstz       = nvl(dt_med_tstz, decode(i_flg_type, g_doctor, g_sysdate_tstz, NULL)),
                   notes_med         = nvl(notes_med, decode(i_flg_type, g_doctor, i_notes, NULL)),
                   dt_admin_tstz     = nvl(decode(i_flg_type, g_adm, g_sysdate_tstz, NULL), dt_admin_tstz),
                   notes_admin       = nvl(decode(i_flg_type, g_adm, i_notes, NULL), notes_admin),
                   id_prof_admin     = nvl(decode(i_flg_type, g_adm, i_prof.id, NULL), id_prof_admin),
                   id_transp_ent_adm = decode(i_flg_type, g_doctor, NULL, i_transp)
             WHERE id_discharge = l_id
            RETURNING id_disch_reas_dest, dt_med_tstz, dt_admin_tstz, flg_status, dt_pend_active_tstz INTO l_id_disch_reas, l_dt_med_tstz, l_dt_admin_tstz, l_flag_status, l_dt_pend_active_tstz;
        
            o_id_discharge := l_id; -- lg 2007-02-28 episode reopening
        
        END IF;
    
        -- ALERT-41412: AS (03-06-2011)
        g_error := 'CALL PK_ADVANCED_DIRECTIVES.CANCEL_ADV_DIR_RECURR_PLANS';
        pk_alertlog.log_debug(text => g_error);
        IF NOT pk_advanced_directives.cancel_adv_dir_recurr_plans(i_lang    => i_lang,
                                                                  i_prof    => i_prof,
                                                                  i_patient => l_id_patient,
                                                                  i_episode => i_episode,
                                                                  o_error   => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        -- END ALERT-41412
    
        g_error := 'CHECK_DISCHARGE (2)';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.check_discharge(i_lang               => i_lang,
                                            i_prof               => i_prof,
                                            i_episode            => i_episode,
                                            i_can_edt_inact_epis => g_can_edit_inact_epis,
                                            o_error              => o_error)
        THEN
            RAISE pk_discharge.e_check_discharge;
        END IF;
    
        g_error := 'SET DISCHARGE_HIST';
        pk_discharge_core.set_discharge_hist(i_prof       => i_prof,
                                             i_discharge  => l_id,
                                             i_outd_prev  => pk_alert_constant.g_no,
                                             o_disch_hist => l_id_hist);
    
        g_error := 'UPDATE EPIS_INFO';
        ts_epis_info.upd(id_episode_in           => i_episode,
                         id_disch_reas_dest_in   => l_id_disch_reas,
                         id_disch_reas_dest_nin  => FALSE,
                         dt_med_tstz_in          => l_dt_med_tstz,
                         dt_med_tstz_nin         => FALSE,
                         dt_admin_tstz_in        => l_dt_admin_tstz,
                         dt_admin_tstz_nin       => FALSE,
                         dt_pend_active_tstz_in  => l_dt_pend_active_tstz,
                         dt_pend_active_tstz_nin => FALSE,
                         flg_dsch_status_in      => l_flag_status,
                         flg_dsch_status_nin     => FALSE,
                         rows_out                => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_INFO',
                                      i_rowids       => l_rowids,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('ID_DISCH_REAS_DEST',
                                                                      'DT_MED_TSTZ',
                                                                      'DT_ADMIN_TSTZ',
                                                                      'DT_PEND_ACTIVE_TSTZ',
                                                                      'FLG_DSCH_STATUS'));
        l_rowids := table_varchar();
        --Actualiza flags
        IF i_flg_type IN (g_doctor, g_adm)
        THEN
        
            g_error := 'UPDATE EPIS_INFO';
            ts_epis_info.upd(flg_status_in => i_flg_type,
                             where_in      => 'id_episode =' || i_episode || ' AND flg_status != ''' || i_flg_type || '''',
                             rows_out      => l_rowids);
        
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_INFO',
                                          i_rowids       => l_rowids,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('FLG_STATUS'));
            l_rowids := table_varchar();
        
            g_error := 'UPDATE SCHEDULE_OUTP';
            IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                       i_prof           => i_prof,
                                                                       i_id_schedule    => l_id_schedule,
                                                                       i_flg_state      => i_flg_type,
                                                                       i_transaction_id => l_transaction_id,
                                                                       o_error          => o_error)
            THEN
            
                RAISE l_func_exception;
            END IF;
        
        END IF;
    
        IF g_found
        THEN
            l_type_msg := 'COMMON_M001';
            RAISE l_error_common;
        END IF;
    
        --Se for uma alta médica, verificar a existência de registos temporários
        IF i_flg_type = g_doctor
        THEN
        
            SELECT id_software
              INTO xsft.id_software
              FROM software
             WHERE intern_name = 'EDIS';
        
            IF i_prof.software = xsft.id_software
            THEN
                IF i_flg_type = g_adm
                   AND l_count <= 1
                THEN
                    -- Alta administrativa, o episódio de urgência= INACTIVO
                    IF NOT pk_visit.set_visit_end(i_lang          => i_lang,
                                                  i_prof          => i_prof,
                                                  i_prof_cat_type => i_prof_cat_type,
                                                  i_id_visit      => l_id_visit,
                                                  i_sysdate       => g_sysdate, -- tco 11/04/2008
                                                  i_sysdate_tstz  => g_sysdate_tstz, -- tco 11/04/2008
                                                  o_error         => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    -- Alta administrativa, tornar as dietas para o episodio inactivas
                    IF NOT pk_diet.set_diet_interrupt(i_lang  => i_lang,
                                                      i_prof  => i_prof,
                                                      i_visit => l_id_visit,
                                                      o_error => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                ELSE
                    -- Episódio de urgência fica PENDENTE (ET 2007/02/07)
                    g_error := 'UPDATE EPISODE';
                    ts_episode.upd(id_episode_in  => i_episode,
                                   flg_status_in  => g_epis_pend,
                                   flg_status_nin => FALSE,
                                   rows_out       => l_rowids);
                
                    -- CHAMAR A FUNCAO PROCESS_INSERT DO PACKAGE T_DATA_GOV_MNT
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'EPISODE',
                                                  i_rowids       => l_rowids,
                                                  o_error        => o_error,
                                                  i_list_columns => table_varchar('FLG_STATUS'));
                
                END IF;
            END IF;
        
            -- Verifica se o episódio pertence ao bloco operatório (ORIS) e se a alta é médica
            IF l_id_epis_type = g_sr_epis_type
            THEN
                -- Actualiza o estado do paciente.
                IF NOT pk_sr_grid.call_set_pat_status(i_lang           => i_lang,
                                                      i_prof           => i_prof,
                                                      i_episode        => i_episode,
                                                      i_flg_status_new => 'O',
                                                      i_flg_status_old => NULL,
                                                      i_test           => 'N',
                                                      i_transaction_id => l_transaction_id,
                                                      o_flg_show       => l_aux,
                                                      o_msg_title      => l_aux,
                                                      o_msg_text       => l_aux,
                                                      o_button         => l_aux,
                                                      o_error          => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                IF l_count <= 1
                THEN
                    -- Marca a visita como terminada
                    g_error := 'PK_VISIT.SET_VISIT_END';
                    IF NOT pk_visit.set_visit_end(i_lang          => i_lang,
                                                  i_prof          => i_prof,
                                                  i_prof_cat_type => i_prof_cat_type,
                                                  i_id_visit      => l_id_visit,
                                                  i_sysdate       => g_sysdate, -- tco 11/04/2008
                                                  i_sysdate_tstz  => g_sysdate_tstz, -- tco 11/04/2008                                                  
                                                  o_error         => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    -- Alta administrativa, tornar as dietas para o episodio inactivas
                    g_error := 'PK_DIET.SET_DIET_INTERRUPT';
                    IF NOT pk_diet.set_diet_interrupt(i_lang  => i_lang,
                                                      i_prof  => i_prof,
                                                      i_visit => l_id_visit,
                                                      o_error => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                END IF;
            END IF;
        
        ELSIF i_flg_type = g_adm
        THEN
        
            --SE FOR UMA ALTA ADMINISTRATIVA, SE O DESTINO NÃO FOR UM DEPARTAMENTO DA INSTITUIÇÃO, FECHA O EPISÓDIO E A VISITA.
            --  SENÃO, FECHA APENAS O EPISÓDIO
        
            IF l_count <= 1
            THEN
                IF NOT pk_visit.set_visit_end(i_lang          => i_lang,
                                              i_prof          => i_prof,
                                              i_prof_cat_type => i_prof_cat_type,
                                              i_id_visit      => l_id_visit,
                                              i_sysdate       => g_sysdate, -- tco 11/04/2008
                                              i_sysdate_tstz  => g_sysdate_tstz, -- tco 11/04/2008                                              
                                              o_error         => o_error)
                THEN
                
                    RAISE l_internal_error;
                
                END IF;
                -- Alta administrativa, tornar as dietas para o episodio inactivas
                g_error := 'PK_DIET.SET_DIET_INTERRUPT';
                IF NOT pk_diet.set_diet_interrupt(i_lang  => i_lang,
                                                  i_prof  => i_prof,
                                                  i_visit => l_id_visit,
                                                  o_error => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
            ELSE
                l_rowids := table_varchar();
                ts_episode.upd(id_episode_in   => i_episode,
                               flg_status_in   => g_epis_inactive,
                               flg_status_nin  => FALSE,
                               dt_end_tstz_in  => g_sysdate_tstz,
                               dt_end_tstz_nin => FALSE,
                               rows_out        => l_rowids);
            
                -- CHAMAR A FUNCAO PROCESS_INSERT DO PACKAGE T_DATA_GOV_MNT
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPISODE',
                                              i_rowids       => l_rowids,
                                              o_error        => o_error,
                                              i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
            END IF;
        
        END IF;
    
        pk_inp_util.do_log('PK_BMNG_PBL', 'GET EPISODE XXX BED:' || i_episode);
        IF NOT pk_bmng_pbl.set_episode_bed_status_vacant(i_lang                  => i_lang,
                                                         i_prof                  => i_prof,
                                                         i_id_episode            => i_episode,
                                                         i_transaction_id        => l_transaction_id,
                                                         i_dt_discharge_schedule => pk_date_utils.date_send_tsz(i_lang,
                                                                                                                l_dt_med_tstz,
                                                                                                                i_prof),
                                                         o_error                 => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        pk_inp_util.do_log('PK_BMNG_PBL', 'SET_BMNG_DISCHARGE:' || i_episode);
        IF NOT pk_bmng_pbl.set_bmng_discharge(i_lang           => i_lang,
                                              i_prof           => i_prof,
                                              i_epis           => i_episode,
                                              i_transaction_id => l_transaction_id,
                                              o_error          => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        --Actualiza dados das observações
        -- José Brito 14/11/2008 ALERT-8235
        -- Chamada à SET_FIRST_OBS é feita no fim e com a data atribuída no início da função,
        -- para não haver o risco da DT_FIRST_OBS ser superior à data de alta médica.
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => l_id_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF i_transaction_id IS NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
        RETURN TRUE;
    
    EXCEPTION
        WHEN pk_discharge.e_check_discharge THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN l_error_common THEN
            DECLARE
                l_error_in      t_error_in := t_error_in();
                l_ret           BOOLEAN;
                l_error_message sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, l_type_msg);
            BEGIN
                -- Set warning message
                o_warning := l_error_message;
            
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_DISCHARGE_MASTER',
                                   NULL,
                                   'U');
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        
        WHEN l_error_common2 THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'T_DATA_ERROR',
                                              'INVALID DATA',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_MASTER',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
        
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_MASTER',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_MASTER',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_discharge_master;
    --
    FUNCTION get_pat_report_given_admit
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain VARCHAR2(0050);
        l_ret         BOOLEAN;
        l_error_get_domain EXCEPTION;
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL.FLG_PAT_REPORT_ADMIT';
    
        l_ret := pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error);
        IF l_ret = FALSE
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_PAT_REPORT_GIVEN_ADMIT',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_pat_report_given_admit;
    --
    FUNCTION get_pat_report_given_transfer
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL.FLG_PAT_REPORT_TRANSFER';
    
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_PAT_REPORT_GIVEN_TRANSFER',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_pat_report_given_transfer;
    --
    FUNCTION get_follow_up_by_disch
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL.FLG_FOLLOW_UP_BY_DISCH';
    
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_BY_DISCH',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_follow_up_by_disch;
    --
    FUNCTION get_follow_up_by_lwbs
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL.FLG_FOLLOW_UP_BY_LWBS';
    
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_BY_LWBS',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_follow_up_by_lwbs;
    --
    FUNCTION get_follow_up_by_ama
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL.FLG_FOLLOW_UP_BY_AMA';
    
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_BY_AMA',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_follow_up_by_ama;
    --
    FUNCTION get_flg_voluntary
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
        l_code_domain := 'DISCHARGE_DETAIL.FLG_VOLUNTARY';
        --
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FLG_VOLUNTARY',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_flg_voluntary;
    --
    FUNCTION get_flg_orgn_dntn_info
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
        l_code_domain := 'DISCHARGE_DETAIL.FLG_ORGN_DNTN_INFO';
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FLG_ORGN_DNTN_INFO',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_flg_orgn_dntn_info;
    --
    FUNCTION get_professionals
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'GET CURSOR WITH ALL INPATIENT AVAILABLE PROFESSIONALS';
        OPEN o_sql FOR
            SELECT DISTINCT prf.id_professional data,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, prf.id_professional) label,
                            0 rank
              FROM professional prf
             INNER JOIN prof_cat prc
                ON (prc.id_professional = prf.id_professional)
             INNER JOIN category cat
                ON (cat.id_category = prc.id_category)
             INNER JOIN prof_profile_template ppt
                ON (ppt.id_professional = prf.id_professional)
             INNER JOIN prof_institution pi
                ON (prf.id_professional = pi.id_professional)
             WHERE cat.flg_type = 'D'
               AND prf.flg_state = 'A'
               AND pi.id_institution = i_prof.institution
               AND pi.flg_state = pk_alert_constant.g_active
               AND pi.dt_end_tstz IS NULL
               AND prc.id_institution = i_prof.institution
               AND ppt.id_software = pk_alert_constant.g_soft_inpatient
               AND ppt.id_institution = i_prof.institution
               AND pk_prof_utils.is_internal_prof(i_lang, i_prof, prf.id_professional, i_prof.institution) =
                   pk_alert_constant.g_yes
             ORDER BY label;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_PROFESSIONALS',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_professionals;
    --

    /******************************************************************************
    * Used to return the names of all professionals, plus one free-text option ('Other').
    * 
    * @param i_lang            Professional prefered language
    * @param i_prof            Professional information
    * @param o_sql             List of all professionals, plus option 'Other'
    * 
    * @return                  TRUE if sucessfull, FALSE otherwise
    *
    * @author                  José Brito
    * @version                 0.1
    * @since                   2008-05-30
    *
    * NOTES: this function was build to use only on the USA market.
    *
    ******************************************************************************/
    FUNCTION get_all_professionals
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain    VARCHAR2(200);
        l_show_only_spec VARCHAR2(1 CHAR) := pk_sysconfig.get_config('DISCHARGE_ADMISSION_DOCTOR_ONLY_SPECIALIST',
                                                                     i_prof);
    BEGIN
    
        l_code_domain := 'DISCHARGE_DETAIL_HIST.PROF_ADMITTING_DESC';
    
        g_error := 'GET CURSOR';
        OPEN o_sql FOR
        -- José Brito 27/06/2008 to_char necessário para aproveitar o tratamento automático de texto livre feito no multichoice
            SELECT DISTINCT prf.id_professional data,
                            to_char(prf.id_professional) val,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, prf.id_professional) desc_val,
                            0 rank
              FROM prof_institution pi
             INNER JOIN prof_cat prc
                ON (prc.id_professional = pi.id_professional)
             INNER JOIN category cat
                ON (cat.id_category = prc.id_category)
             INNER JOIN professional prf
                ON (prf.id_professional = pi.id_professional)
             INNER JOIN prof_profile_template ppt
                ON prc.id_institution = ppt.id_institution
               AND prc.id_professional = ppt.id_professional
              JOIN profile_template pt
                ON ppt.id_profile_template = pt.id_profile_template
             WHERE cat.flg_type = 'D'
               AND prf.flg_state = 'A'
               AND pi.id_institution = i_prof.institution
               AND pi.flg_state = pk_alert_constant.g_active
               AND pi.dt_end_tstz IS NULL
               AND prc.id_institution = i_prof.institution
               AND pi.flg_external = pk_alert_constant.g_no
               AND ppt.id_software = pk_alert_constant.g_soft_inpatient
               AND nvl(prf.flg_prof_test, pk_alert_constant.g_no) = pk_alert_constant.g_no
               AND (l_show_only_spec = pk_alert_constant.g_no OR
                   (l_show_only_spec = pk_alert_constant.g_yes AND
                   pk_prof_utils.get_flg_mrp(i_lang, i_prof, ppt.id_profile_template) = pk_alert_constant.g_yes AND
                   pt.flg_profile = 'S'))
            
            -- José Brito 30/05/2008 Devolver também opção 'Other'
            UNION ALL
            SELECT
            -- RS 20080625 -1 data,
             g_other_prof_id data,
             g_flg_other val,
             pk_sysdomain.get_domain(l_code_domain, g_flg_other, i_lang) desc_val,
             1 rank
              FROM dual
             ORDER BY rank, desc_val;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_ALL_PROFESSIONALS',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_all_professionals;

    FUNCTION get_services
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR';
        OPEN o_sql FOR
            SELECT t.id_dep_clin_serv data,
                   (SELECT pk_translation.get_translation(i_lang, t.code_clinical_service)
                      FROM dual) label
              FROM (SELECT dcs.id_dep_clin_serv, cli.code_clinical_service, dpt.flg_type
                      FROM clinical_service cli
                      JOIN dep_clin_serv dcs
                        ON dcs.id_clinical_service = cli.id_clinical_service
                      JOIN department dpt
                        ON dpt.id_department = dcs.id_department
                     WHERE dpt.id_institution = i_prof.institution
                       AND rownum > 0) t
             WHERE instr(t.flg_type, 'I') > 0 -- I (inpatient)
             ORDER BY label;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_SERVICES',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_services;

    /**********************************************************************************************
    * Devolve o detalhe da alta
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_id_discharge           discharge id
    * @param o_sql                    cursor with detail of discharge
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         
    * @version                        1.0 
    * @changed                        Emília Taborda
    * @since                          2007/06/18
    **********************************************************************************************/
    FUNCTION get_disch_detail_disch
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_discharge IN NUMBER,
        o_sql          OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN pk_discharge_core.get_disch_detail_disch(i_lang         => i_lang,
                                                        i_prof         => i_prof,
                                                        i_id_discharge => i_id_discharge,
                                                        o_sql          => o_sql,
                                                        o_error        => o_error);
    END get_disch_detail_disch;
    --
    FUNCTION get_disch_detail_admit
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_discharge IN NUMBER,
        o_sql          OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN pk_discharge_core.get_disch_detail_admit(i_lang         => i_lang,
                                                        i_prof         => i_prof,
                                                        i_id_discharge => i_id_discharge,
                                                        o_sql          => o_sql,
                                                        o_error        => o_error);
    END get_disch_detail_admit;
    --
    FUNCTION get_disch_detail_transf
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_discharge IN NUMBER,
        o_sql          OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        RETURN pk_discharge_core.get_disch_detail_transf(i_lang         => i_lang,
                                                         i_prof         => i_prof,
                                                         i_id_discharge => i_id_discharge,
                                                         o_sql          => o_sql,
                                                         o_error        => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCH_DETAIL_TRANSF',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_disch_detail_transf;
    --
    FUNCTION get_disch_detail_expir
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_discharge IN NUMBER,
        o_sql          OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN pk_discharge_core.get_disch_detail_expir(i_lang         => i_lang,
                                                        i_prof         => i_prof,
                                                        i_id_discharge => i_id_discharge,
                                                        o_sql          => o_sql,
                                                        o_error        => o_error);
    END get_disch_detail_expir;
    --
    FUNCTION get_disch_detail_ama
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_discharge IN NUMBER,
        o_sql          OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN pk_discharge_core.get_disch_detail_ama(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_id_discharge => i_id_discharge,
                                                      o_sql          => o_sql,
                                                      o_error        => o_error);
    END get_disch_detail_ama;
    --
    /**********************************************************************************************
    * Devolve os valores possiveis para o compo que indica se é necessário criar cirurgia na alta para internamento o para o bloco
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @o_sql                          cursor with contains result of domain
    * @param o_error                  Error message
    *                        
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         Silvia Freitas
    * @version                        1.0  
    * @since                          2007/06/06
    **********************************************************************************************/
    FUNCTION get_flg_oris
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_sql   OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        --
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
        l_code_domain := 'DISCHARGE_DETAIL.FLG_ORIS';
        --
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_sql, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FLG_ORIS',
                                              o_error);
            pk_types.open_my_cursor(o_sql);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_flg_oris;
    --
    /**********************************************************************************************
    * Devolve os valores possiveis para o campo MSE - Medical screening evaluation
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param o_mse_val                cursor with contains result of domain
    * @param o_error                  Error message
    *                        
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         Emilia Taborda
    * @version                        1.0  
    * @since                          2007/06/18
    **********************************************************************************************/
    FUNCTION get_mse_type_list
    (
        i_lang    IN NUMBER,
        i_prof    IN profissional,
        o_mse_val OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_code_domain VARCHAR2(0050);
        l_error_get_domain EXCEPTION;
    BEGIN
        l_code_domain := 'DISCHARGE_DETAIL.MSE_TYPE';
        --
        IF NOT pk_sysdomain.get_domains(i_lang, l_code_domain, i_prof, o_mse_val, o_error)
        THEN
            RAISE l_error_get_domain;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_MSE_TYPE_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_mse_val);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_mse_type_list;
    --
    FUNCTION get_disch_detail_lwbs
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_discharge IN NUMBER,
        o_sql          OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN pk_discharge_core.get_disch_detail_lwbs(i_lang         => i_lang,
                                                       i_prof         => i_prof,
                                                       i_id_discharge => i_id_discharge,
                                                       o_sql          => o_sql,
                                                       o_error        => o_error);
    END get_disch_detail_lwbs;
    --

    /******************************************************************************
       OBJECTIVO:  Fechar todos os episódios pendentes ao final do dia (DISCHARGE).
       PARAMETROS:
    
      CRIAÇÃO: ASM 2006/12/18
      NOTAS:
    *********************************************************************************/
    PROCEDURE set_end_day_discharges IS
    
        CURSOR c_epis_discharge(i_date IN schedule.dt_begin_tstz%TYPE) IS
            SELECT id_episode_e,
                   id_institution,
                   id_epis_type,
                   id_software,
                   id_visit,
                   id_patient,
                   nvl(dt_discharge,
                       pk_date_utils.add_to_ltstz(pk_date_utils.trunc_insttimezone(profissional(NULL,
                                                                                                id_institution,
                                                                                                NULL),
                                                                                   i_date) + numtodsinterval(1, 'DAY') +
                                                  numtodsinterval(-1, 'SECOND'),
                                                  '-' || (SELECT pk_sysconfig.get_config('DISCHARGE_NR_DAYS',
                                                                                         profissional(0,
                                                                                                      id_institution,
                                                                                                      id_software))
                                                            FROM dual),
                                                  'DAY')) dt_end_inactts_tz,
                   (SELECT x2.id_discharge
                      FROM (SELECT x01.id_discharge, x01.dt_disch
                              FROM (SELECT id_discharge,
                                           decode(id_epis_type,
                                                  pk_alert_constant.g_epis_type_dietitian,
                                                  d.dt_nutritionist,
                                                  g_care_nurse_epis_type,
                                                  d.dt_nurse,
                                                  g_outp_nurse_epis_type,
                                                  d.dt_nurse,
                                                  g_epis_type_nurse_pp,
                                                  d.dt_nurse,
                                                  d.dt_med_tstz) dt_disch
                                      FROM discharge d
                                     WHERE d.id_episode = epis.id_episode_e
                                       AND d.flg_status = g_disch_flg_active) x01
                             ORDER BY x01.dt_disch DESC) x2
                     WHERE x2.dt_disch = dt_discharge
                       AND rownum = 1) id_discharge,
                   flg_ehr,
                   flg_status,
                   id_schedule,
                   id_bed
              FROM (SELECT e.id_episode id_episode_e,
                           e.id_institution,
                           e.id_epis_type,
                           ei.id_software,
                           e.id_visit,
                           e.id_patient,
                           (SELECT MAX(decode(e.id_epis_type,
                                              pk_alert_constant.g_epis_type_dietitian,
                                              d.dt_nutritionist,
                                              pk_alert_constant.g_epis_type_nurse_care,
                                              d.dt_nurse,
                                              pk_alert_constant.g_epis_type_nurse_outp,
                                              d.dt_nurse,
                                              pk_alert_constant.g_epis_type_nurse_pp,
                                              d.dt_nurse,
                                              d.dt_med_tstz)) dt_discharge
                              FROM discharge d
                             WHERE d.id_episode = e.id_episode
                               AND d.flg_status = g_disch_flg_active) dt_discharge,
                           e.flg_ehr,
                           e.flg_status,
                           s.id_schedule,
                           ei.id_bed
                      FROM episode e
                      JOIN epis_info ei
                        ON e.id_episode = ei.id_episode
                      LEFT JOIN schedule s
                        ON ei.id_schedule = s.id_schedule
                       AND ei.id_schedule > 0
                     WHERE e.id_epis_type IN (pk_alert_constant.g_epis_type_outpatient,
                                              pk_alert_constant.g_epis_type_primary_care,
                                              pk_alert_constant.g_epis_type_private_practice,
                                              pk_alert_constant.g_epis_type_nurse_care,
                                              pk_alert_constant.g_epis_type_nurse_outp,
                                              pk_alert_constant.g_epis_type_nurse_pp,
                                              pk_alert_constant.g_epis_type_dietitian,
                                              pk_alert_constant.g_epis_type_social,
                                              pk_alert_constant.g_epis_type_rehab_session,
                                              pk_alert_constant.g_epis_type_rehab_appointment,
                                              pk_alert_constant.g_epis_type_cdc_appointment,
                                              pk_alert_constant.g_epis_type_psychologist,
                                              pk_alert_constant.g_epis_type_resp_therapist)
                       AND e.flg_status IN
                           (pk_alert_constant.g_epis_status_active, pk_alert_constant.g_epis_status_pendent)
                          --AND e.flg_ehr IN (pk_visit.g_flg_ehr_n, pk_visit.g_flg_ehr_s)
                       AND NOT EXISTS
                     (SELECT 1
                              FROM opinion o
                             WHERE o.id_episode_answer = ei.id_episode
                               AND o.flg_state NOT IN (pk_opinion.g_opinion_cancel,
                                                       pk_opinion.g_opinion_rejected,
                                                       pk_opinion.g_opinion_not_approved,
                                                       pk_opinion.g_opinion_over))
                       AND e.dt_cancel_tstz IS NULL
                       AND nvl(s.dt_begin_tstz, e.dt_begin_tstz) <
                           pk_date_utils.add_to_ltstz(pk_date_utils.trunc_insttimezone(profissional(NULL,
                                                                                                    e.id_institution,
                                                                                                    NULL),
                                                                                       i_date) +
                                                      numtodsinterval(1, 'DAY') + numtodsinterval(-1, 'SECOND'),
                                                      '-' || (SELECT pk_sysconfig.get_config('DISCHARGE_NR_DAYS',
                                                                                             profissional(0,
                                                                                                          e.id_institution,
                                                                                                          ei.id_software))
                                                                FROM dual),
                                                      'DAY')
                    UNION ALL
                    --Edis episodes
                    SELECT e.id_episode id_episode_e,
                           e.id_institution,
                           e.id_epis_type,
                           ei.id_software,
                           e.id_visit,
                           e.id_patient,
                           (SELECT MAX(d.dt_med_tstz) dt_discharge
                              FROM discharge d
                             WHERE d.id_episode = e.id_episode
                               AND d.flg_status = g_disch_flg_active) dt_discharge,
                           e.flg_ehr,
                           e.flg_status,
                           NULL id_schedule,
                           ei.id_bed
                      FROM episode e
                      JOIN epis_info ei
                        ON e.id_episode = ei.id_episode
                     WHERE e.id_epis_type IN
                           (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_urgent_care)
                       AND e.flg_status IN
                           (pk_alert_constant.g_epis_status_active, pk_alert_constant.g_epis_status_pendent)
                          --AND e.flg_ehr IN (pk_visit.g_flg_ehr_n, pk_visit.g_flg_ehr_s)
                          --the edis episodes should only be inativated if there is a sys_config defined for EDIS software
                       AND EXISTS (SELECT 1
                              FROM sys_config scf
                             WHERE scf.id_sys_config = 'DISCHARGE_NR_DAYS'
                               AND scf.id_institution = e.id_institution
                               AND scf.id_software = CASE
                                       WHEN e.id_epis_type = pk_alert_constant.g_epis_type_emergency THEN
                                        pk_alert_constant.g_soft_edis
                                       ELSE
                                        pk_alert_constant.g_soft_ubu
                                   END)
                       AND NOT EXISTS (SELECT 1
                              FROM opinion o
                             WHERE o.id_episode_answer = ei.id_episode
                               AND o.flg_state NOT IN (pk_opinion.g_opinion_cancel,
                                                       pk_opinion.g_opinion_rejected,
                                                       pk_opinion.g_opinion_not_approved,
                                                       pk_opinion.g_opinion_over))
                       AND e.dt_cancel_tstz IS NULL
                       AND e.dt_begin_tstz < pk_date_utils.add_to_ltstz(pk_date_utils.trunc_insttimezone(profissional(NULL,
                                                                                                                      e.id_institution,
                                                                                                                      NULL),
                                                                                                         i_date) +
                                                                        numtodsinterval(1, 'DAY') +
                                                                        numtodsinterval(-1, 'SECOND'),
                                                                        '-' || (SELECT pk_sysconfig.get_config('DISCHARGE_NR_DAYS',
                                                                                                               profissional(0,
                                                                                                                            e.id_institution,
                                                                                                                            ei.id_software))
                                                                                  FROM dual),
                                                                        'DAY')
                    UNION ALL
                    
                    --inpatient episodes
                    SELECT e.id_episode id_episode_e,
                           e.id_institution,
                           e.id_epis_type,
                           ei.id_software,
                           e.id_visit,
                           e.id_patient,
                           (SELECT MAX(d.dt_med_tstz) dt_discharge
                              FROM discharge d
                             WHERE d.id_episode = e.id_episode
                               AND d.flg_status = g_disch_flg_active) dt_discharge,
                           e.flg_ehr,
                           e.flg_status,
                           NULL id_schedule,
                           ei.id_bed
                      FROM episode e
                      JOIN epis_info ei
                        ON e.id_episode = ei.id_episode
                     WHERE e.id_epis_type = pk_alert_constant.g_epis_type_inpatient
                       AND e.flg_status IN
                           (pk_alert_constant.g_epis_status_active, pk_alert_constant.g_epis_status_pendent)
                       AND e.flg_ehr IN (pk_visit.g_flg_ehr_n, pk_visit.g_flg_ehr_e)
                          --the inpatient episodes should only be inativated if there is a sys_config defined for INPATIENT software
                       AND EXISTS (SELECT 1
                              FROM sys_config scf
                             WHERE scf.id_sys_config = 'DISCHARGE_NR_DAYS'
                               AND scf.id_institution = e.id_institution
                               AND scf.id_software = pk_alert_constant.g_soft_inpatient)
                       AND NOT EXISTS
                     (SELECT 1
                              FROM opinion o
                             WHERE o.id_episode_answer = ei.id_episode
                               AND o.flg_state NOT IN (pk_opinion.g_opinion_cancel,
                                                       pk_opinion.g_opinion_rejected,
                                                       pk_opinion.g_opinion_not_approved,
                                                       pk_opinion.g_opinion_over))
                       AND e.dt_cancel_tstz IS NULL
                       AND ei.dt_last_interaction_tstz <
                           pk_date_utils.add_to_ltstz(pk_date_utils.trunc_insttimezone(profissional(NULL,
                                                                                                    e.id_institution,
                                                                                                    NULL),
                                                                                       i_date) +
                                                      numtodsinterval(1, 'DAY') + numtodsinterval(-1, 'SECOND'),
                                                      '-' || (SELECT pk_sysconfig.get_config('DISCHARGE_NR_DAYS',
                                                                                             profissional(0,
                                                                                                          e.id_institution,
                                                                                                          ei.id_software))
                                                                FROM dual),
                                                      'DAY')) epis;
    
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'SET_END_DAY_DISCHARGES';
        l_prof profissional;
        l_lang language.id_language%TYPE;
    
        l_count NUMBER;
    
        l_rowids table_varchar;
    
        l_error t_error_out;
    
        l_flg_show        pk_translation.t_desc_translation;
        l_msg_title       pk_translation.t_desc_translation;
        l_msg_text        pk_translation.t_desc_translation;
        l_button          pk_translation.t_desc_translation;
        l_reports         reports.id_reports%TYPE;
        l_reports_pat     reports.id_reports%TYPE;
        l_id_episode      episode.id_episode%TYPE;
        l_id_discharge    discharge.id_discharge%TYPE;
        l_disch_reas_dest disch_reas_dest.id_disch_reas_dest%TYPE;
        l_prof_id         professional.id_professional%TYPE;
    
        l_id_schedule_ext sch_api_map_ids.id_schedule_ext%TYPE;
        l_debug           VARCHAR2(4000);
        l_err             VARCHAR2(4000);
    
        l_transaction_id VARCHAR2(4000);
    
        PROCEDURE process_error(i_text IN VARCHAR2) IS
        BEGIN
        
            pk_alertlog.log_error(text            => l_debug || '***' || i_text,
                                  object_name     => 'PK_DISCHARGE',
                                  sub_object_name => 'SET_END_DAY_DISCHARGES',
                                  owner           => 'ALERT');
            pk_utils.undo_changes;
        
        END process_error;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        <<lup_epis_discharge>>
        FOR i IN c_epis_discharge(i_date => g_sysdate_tstz)
        LOOP
        
            l_debug := 'STEP 00';
            <<process_cycle>>
            DECLARE
            BEGIN
            
                l_debug := 'STEP 10';
                IF (i.flg_ehr = pk_visit.g_flg_ehr_n)
                THEN
                
                    l_debug   := 'STEP 11';
                    l_prof_id := pk_sysconfig.get_config(i_code_cf   => 'ID_PROF_BACKGROUND',
                                                         i_prof_inst => i.id_institution,
                                                         i_prof_soft => i.id_software);
                
                    l_prof := profissional(l_prof_id, i.id_institution, i.id_software);
                    l_lang := pk_sysconfig.get_config('LANGUAGE', l_prof);
                
                    --TODO: use the discharge reason created by content team
                    l_disch_reas_dest := pk_sysconfig.get_config(i_code_cf => 'DEFAULT_DISCH_REAS_DEST',
                                                                 i_prof    => profissional(l_prof_id,
                                                                                           i.id_institution,
                                                                                           i.id_software));
                
                    IF (l_disch_reas_dest IS NOT NULL)
                    THEN
                        l_debug := 'STEP 12';
                        IF NOT pk_api_discharge.intf_set_epis_discharge(i_lang         => l_lang,
                                                                        i_prof         => l_prof,
                                                                        i_episode      => i.id_episode_e,
                                                                        i_flg_new_epis => NULL,
                                                                        i_reas_dest    => l_disch_reas_dest,
                                                                        i_notes        => NULL,
                                                                        i_transp       => NULL,
                                                                        i_flg_status   => 'A',
                                                                        i_dt_admin     => pk_date_utils.date_send_tsz(i_lang => l_lang,
                                                                                                                      i_date => current_timestamp,
                                                                                                                      i_inst => i.id_institution,
                                                                                                                      i_soft => i.id_software),
                                                                        o_flg_show     => l_flg_show,
                                                                        o_msg_title    => l_msg_title,
                                                                        o_msg_text     => l_msg_text,
                                                                        o_button       => l_button,
                                                                        o_reports      => l_reports,
                                                                        o_reports_pat  => l_reports_pat,
                                                                        o_id_episode   => l_id_episode,
                                                                        o_id_discharge => l_id_discharge,
                                                                        o_error        => l_error)
                        THEN
                        
                            l_err := 'ERROR ON pk_api_discharge.intf_set_epis_discharge - epis:';
                            l_err := l_err || i.id_episode_e || ' ' || l_error.ora_sqlcode || ' - ' ||
                                     l_error.ora_sqlerrm;
                            process_error(i_text => l_err);
                        
                            CONTINUE;
                        END IF;
                    ELSE
                        IF i.id_bed IS NOT NULL
                        THEN
                            -- dealocate bed
                            g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                            l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(l_transaction_id);
                        
                            IF NOT pk_bmng_pbl.set_episode_bed_status_vacant(i_lang                  => l_lang,
                                                                             i_prof                  => l_prof,
                                                                             i_id_episode            => i.id_episode_e,
                                                                             i_transaction_id        => l_transaction_id,
                                                                             i_dt_discharge_schedule => pk_date_utils.date_send_tsz(l_lang,
                                                                                                                                    current_timestamp,
                                                                                                                                    l_prof),
                                                                             o_error                 => l_error)
                            THEN
                                l_err := 'ERROR ON pk_api_discharge.intf_set_epis_discharge - epis:';
                                l_err := l_err || i.id_episode_e || ' ' || l_error.ora_sqlcode || ' - ' ||
                                         l_error.ora_sqlerrm;
                                process_error(i_text => l_err);
                            
                                CONTINUE;
                            END IF;
                        
                            IF NOT pk_bmng_pbl.set_bmng_discharge(i_lang           => l_lang,
                                                                  i_prof           => l_prof,
                                                                  i_epis           => i.id_episode_e,
                                                                  i_transaction_id => l_transaction_id,
                                                                  o_error          => l_error)
                            THEN
                                l_err := 'ERROR ON pk_api_discharge.intf_set_epis_discharge - epis:';
                                l_err := l_err || i.id_episode_e || ' ' || l_error.ora_sqlcode || ' - ' ||
                                         l_error.ora_sqlerrm;
                                process_error(i_text => l_err);
                            
                                CONTINUE;
                            END IF;
                        END IF;
                    END IF;
                END IF;
            
                --Actualiza flags
                l_debug  := 'UPDATE EPIS_INFO';
                l_rowids := table_varchar();
                ts_epis_info.upd(flg_status_in => g_disch_type_alert,
                                 where_in      => 'id_episode =' || i.id_episode_e || ' AND flg_status != ''' ||
                                                  g_disch_type_alert || '''',
                                 rows_out      => l_rowids);
            
                l_debug := 'STEP 01';
                t_data_gov_mnt.process_update(i_lang         => NULL,
                                              i_prof         => l_prof,
                                              i_table_name   => 'EPIS_INFO',
                                              i_rowids       => l_rowids,
                                              o_error        => l_error,
                                              i_list_columns => table_varchar('FLG_STATUS'));
            
                l_debug  := 'UPDATE EPISODE';
                l_rowids := table_varchar();
                ts_episode.upd(flg_status_in  => g_epis_inactive,
                               dt_end_tstz_in => i.dt_end_inactts_tz,
                               where_in       => 'id_episode = ' || i.id_episode_e || ' AND flg_status in ( ''' ||
                                                 g_epis_active || ''',''' || g_epis_pend || ''')',
                               rows_out       => l_rowids);
            
                IF i.flg_status = g_epis_active
                   AND i.flg_ehr = g_ehr_schedule
                   AND i.id_schedule IS NOT NULL
                   AND i.id_epis_type IN (pk_alert_constant.g_epis_type_dietitian,
                                          pk_alert_constant.g_epis_type_social,
                                          pk_alert_constant.g_epis_type_psychologist,
                                          pk_alert_constant.g_epis_type_resp_therapist)
                THEN
                
                    l_debug := 'STEP 02';
                    BEGIN
                        SELECT sami.id_schedule_ext
                          INTO l_id_schedule_ext
                          FROM sch_api_map_ids sami
                         WHERE sami.id_schedule_pfh = i.id_schedule;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_id_schedule_ext := NULL;
                            CONTINUE;
                    END;
                
                    l_debug := 'STEP 13';
                    IF l_id_schedule_ext IS NOT NULL
                    THEN
                        l_debug := 'STEP 03';
                        IF NOT pk_schedule_api_downstream.set_patient_no_show(i_lang             => l_lang,
                                                                              i_prof             => l_prof,
                                                                              i_id_sch_ext       => l_id_schedule_ext,
                                                                              i_id_patient       => i.id_patient,
                                                                              i_id_cancel_reason => NULL,
                                                                              i_notes            => NULL,
                                                                              o_error            => l_error)
                        THEN
                            l_debug := 'STEP 04';
                            l_err   := l_error.ora_sqlcode || '-' || l_error.ora_sqlerrm;
                            CONTINUE;
                        END IF;
                    END IF;
                END IF;
            
                l_debug := 'STEP 05';
                t_data_gov_mnt.process_update(i_lang         => NULL,
                                              i_prof         => l_prof,
                                              i_table_name   => 'EPISODE',
                                              i_rowids       => l_rowids,
                                              o_error        => l_error,
                                              i_list_columns => table_varchar('flg_status', 'dt_end_tstz'));
            
                l_debug := 'SELECT l_count';
                SELECT COUNT(*)
                  INTO l_count
                  FROM episode
                 WHERE id_visit = i.id_visit
                   AND flg_status IN (g_epis_active, g_epis_pend);
            
                IF l_count = 0
                THEN
                
                    l_debug  := 'UPDATE VISIT';
                    l_rowids := table_varchar();
                    ts_visit.upd(flg_status_in   => g_visit_inactive,
                                 flg_status_nin  => FALSE,
                                 dt_end_tstz_in  => i.dt_end_inactts_tz,
                                 dt_end_tstz_nin => FALSE,
                                 where_in        => 'id_visit = ' || i.id_visit || ' AND flg_status = ''' ||
                                                    g_visit_active || ''' ',
                                 rows_out        => l_rowids);
                
                    l_debug := 'STEP 06';
                    t_data_gov_mnt.process_update(i_lang         => NULL,
                                                  i_prof         => l_prof,
                                                  i_table_name   => 'VISIT',
                                                  i_rowids       => l_rowids,
                                                  o_error        => l_error,
                                                  i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
                
                END IF;
            
                l_debug := 'UPDATE GRID_TASK_LAB';
                UPDATE grid_task_lab
                   SET flg_status_epis = g_epis_inactive
                 WHERE id_episode = i.id_episode_e;
            
                l_debug := 'UPDATE GRID_TASK_IMG';
                UPDATE grid_task_img
                   SET flg_status_epis = g_epis_inactive
                 WHERE id_episode = i.id_episode_e;
            
                l_debug := 'UPDATE GRID_TASK_OTH_EXM';
                UPDATE grid_task_oth_exm
                   SET flg_status_epis = g_epis_inactive
                 WHERE id_episode = i.id_episode_e;
            
                -- ALERT-41412: AS (03-06-2011)
                l_debug := 'CALL PK_ADVANCED_DIRECTIVES.CANCEL_ADV_DIR_RECURR_PLANS';
                IF NOT pk_advanced_directives.cancel_adv_dir_recurr_plans(i_lang    => NULL,
                                                                          i_prof    => l_prof,
                                                                          i_patient => i.id_patient,
                                                                          i_episode => i.id_episode_e,
                                                                          o_error   => l_error)
                THEN
                    l_err := 'CALL PK_ADVANCED_DIRECTIVES.CANCEL_ADV_DIR_RECURR_PLANS:' || l_error.ora_sqlerrm;
                    process_error(l_err);
                    CONTINUE;
                END IF;
                -- END ALERT-41412
            
                l_debug := 'STEP 07';
                IF i.flg_ehr != pk_visit.g_flg_ehr_e
                THEN
                
                    IF NOT pk_adt.set_discharge_adt(i_lang          => l_lang,
                                                    i_prof          => l_prof,
                                                    i_id_discharge  => i.id_discharge,
                                                    i_id_episode    => i.id_episode_e,
                                                    i_id_visit      => i.id_visit,
                                                    i_dt_admin_tstz => i.dt_end_inactts_tz,
                                                    i_notes         => NULL,
                                                    o_error         => l_error)
                    THEN
                        process_error('ERROR ON pk_adt.set_discharge_adt:' || l_error.ora_sqlcode || '-' ||
                                      l_error.ora_sqlerrm);
                        CONTINUE;
                    END IF;
                
                END IF;
            
                COMMIT;
            EXCEPTION
                WHEN OTHERS THEN
                
                    l_err := 'id_episode: ' || i.id_episode_e || '==> sqlcode=' || SQLCODE || '; sqlerrm=' || SQLERRM;
                    process_error(l_err);
            END;
        
        END LOOP lup_epis_discharge;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            l_err := '==> sqlcode=' || SQLCODE || '; sqlerrm=' || SQLERRM;
            process_error(l_err);
        
            RAISE;
    END set_end_day_discharges;

    FUNCTION set_payment
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN episode.id_episode%TYPE,
        i_payment      IN VARCHAR2,
        i_price        IN discharge.price%TYPE,
        i_currency     IN discharge.currency%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        /**
        * Sets medical discharge info in enviroments where price is specified.
        *
        * @param   I_LANG language associated to the professional executing the request
        * @param   I_PROF  professional, institution and software ids
        * @param   I_ID_DISCHARGE the discharge id
        * @param   I_PAYMENT the new payment state, TRUE if payed, false otherwise
        * @param   O_ERROR OUT the error message in case of error
        *
        * @RETURN  TRUE if sucess, FALSE otherwise
        * @author  Luis Gaspar
        * @version 1.0
        * @since   30-Jan-2006
        */
        l_flg_payment discharge.flg_payment%TYPE;
    
    BEGIN
        g_error := 'calc flg_payment';
        IF (i_payment = g_disch_flg_pay_y)
        THEN
            l_flg_payment := g_disch_flg_pay_y;
        ELSE
            l_flg_payment := g_disch_flg_pay_n;
        END IF;
    
        --
        g_error := 'update discharge';
        UPDATE discharge
           SET flg_payment = i_payment, price = i_price, currency = i_currency
         WHERE id_discharge = i_id_discharge
           AND flg_status <> g_disch_flg_cancel;
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_PAYMENT',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_payment;
    --
    /********************************************************************************************
    * Validar se é possivél proceder à alta do paciente - Discharge do episódio
    *
    * @param i_lang                  language id
    * @param i_episode               episode id
    * @param i_prof                  professional, software and institution ids
    * @param i_patient               patient id   
    * @param i_reas_dest             Relação motivo e destino da alta
    * @param i_disch_type            Tipo de alta: F - Fim do episódio; D - Alta
    * @param i_flg_type              Tipo: D - Alta médica; M - Alta administrativa
    * @param o_epis_type_new_epis    Tipo do novo episódio        
    * @param o_flg_type_new_epis     Estado do novo episódio        
    * @param o_flg_new_epis          Criação de novo episódio: Y - Yes; N - No    
    * @param o_screen                Ecran a ser visualizado no caso da relação Motivo/Destino obrigar a criar um novo episódio
    * @param o_flg_show_msg          Flag: Y - existe msg para mostrar; N - ñ existe                    
    * @param o_msg                   Mensagem a mostrar
    * @param o_msg_title             Título da mensagem
    * @param o_button                Botões a mostrar: N - não, R - lido, C - confirmado 
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         12-02-2007
    ********************************************************************************************/
    FUNCTION check_epis_discharge
    (
        i_lang               IN NUMBER,
        i_episode            IN NUMBER,
        i_prof               IN profissional,
        i_patient            IN patient.id_patient%TYPE,
        i_reas_dest          IN NUMBER,
        i_disch_type         IN VARCHAR2,
        i_flg_type           IN VARCHAR2,
        o_epis_type_new_epis OUT episode.id_epis_type%TYPE,
        o_flg_type_new_epis  OUT episode.flg_type%TYPE,
        o_flg_new_epis       OUT VARCHAR2,
        o_screen             OUT VARCHAR2,
        o_flg_show_msg       OUT VARCHAR2,
        o_msg                OUT VARCHAR2,
        o_msg_title          OUT VARCHAR2,
        o_button             OUT VARCHAR2,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_disch      discharge.id_discharge%TYPE;
        l_dt_disch      discharge.dt_med_tstz%TYPE;
        l_flg_diag      disch_reas_dest.flg_diag%TYPE;
        l_epis_diag     epis_diagnosis.id_epis_diagnosis%TYPE;
        l_disch_reason  disch_reas_dest.id_discharge_reason%TYPE;
        l_epis_type     disch_reas_dest.id_epis_type%TYPE;
        l_type_screen   disch_reas_dest.type_screen%TYPE;
        l_disch_status  discharge.flg_status%TYPE;
        l_char          VARCHAR2(1);
        l_institution   disch_reas_dest.id_institution%TYPE;
        l_flg_mcdt      disch_reas_dest.flg_mcdt%TYPE;
        l_error_title   sys_message.desc_message%TYPE;
        l_error_message sys_message.desc_message%TYPE;
        l_common_error   EXCEPTION;
        l_internal_error EXCEPTION;
        l_cosign_count           NUMBER(6);
        l_flg_needs_overall_resp disch_reas_dest.flg_needs_overall_resp%TYPE;
        --
        l_force_doc_discharge sys_config.value%TYPE;
        l_opinion_count       NUMBER;
        --
        l_disch_diag_icd9 sys_config.value%TYPE;
        l_total_mand_diag PLS_INTEGER;
        l_code_msg_mand_diag CONSTANT sys_message.code_message%TYPE := 'DISCHARGE_M038';
        l_replace_str        CONSTANT VARCHAR2(2) := '@1';
        l_diagnosis_icd9 diagnosis.id_diagnosis%TYPE;
        --
        l_show_error_msg VARCHAR2(1);
        --
        err_no_final_diag EXCEPTION;
        --
        CURSOR c_epis_disch IS
            SELECT id_discharge,
                   decode(i_flg_type,
                          g_doctor,
                          dt_med_tstz,
                          g_adm,
                          pk_discharge_core.get_dt_admin(i_lang, i_prof, NULL, flg_status_adm, dt_admin_tstz),
                          NULL),
                   flg_status
              FROM discharge
             WHERE id_episode = i_episode
               AND flg_status = g_disch_flg_active; --lg 2007-02-28 episode reopening
    
        -- Relação motivo / destino - Obriga o episódio a ter diagnósticos
        CURSOR c_diag IS
            SELECT drd.flg_diag
              FROM disch_reas_dest drd
             WHERE id_disch_reas_dest = i_reas_dest;
    
        -- Verifica se o episódio tem diagnósticos finais
        CURSOR c_epis_diag IS
            SELECT ed.id_epis_diagnosis
              FROM epis_diagnosis ed, diagnosis d
             WHERE ed.id_episode = i_episode
               AND ed.id_diagnosis = d.id_diagnosis
                  -- CRS 2007/01/11 Exige somente diagnóstico de saída
               AND (ed.flg_type IN (g_epis_diag_def, g_epis_diag_base) AND
                   ed.flg_status NOT IN (g_epis_diag_canc, g_epis_diag_decl) AND
                   -- LO 2007/05/12 Um diagnóstico do tipo outro não é considerado para efeitos de obrigatoriedade de diagnóstico na alta
                   ((pk_sysconfig.get_config('DISCHARGE_ALLOW_DIAG_OTHERS', i_prof) = 'N' AND
                   nvl(d.flg_other, 'N') <> 'Y') OR
                   pk_sysconfig.get_config('DISCHARGE_ALLOW_DIAG_OTHERS', i_prof) = 'Y'));
    
        -- Qual o motivo da alta, tipo de episódio a ser criado, estado e respectivo ecran
        CURSOR c_disch_reason IS
            SELECT drd.id_discharge_reason,
                   drd.id_epis_type,
                   drd.type_screen,
                   drd.id_institution,
                   drd.flg_mcdt,
                   drd.flg_needs_overall_resp
              FROM disch_reas_dest drd
             WHERE drd.id_disch_reas_dest = i_reas_dest;
    
        CURSOR c_admin IS
            SELECT 'X'
              FROM epis_anamnesis
             WHERE id_episode = i_episode
               AND flg_type = g_anamnesis_type
               AND flg_class = g_admin_anamnesis;
    
        CURSOR c_opinion_approval_count IS
            SELECT COUNT(1)
              FROM opinion o, episode e, epis_info ei
             WHERE o.flg_state = pk_opinion.g_opinion_req
               AND o.id_opinion_type IS NOT NULL
               AND o.id_patient = i_patient
               AND o.id_episode = e.id_episode
               AND o.id_episode = ei.id_episode
               AND e.id_institution = i_prof.institution
               AND pk_opinion.check_approval_need(profissional(o.id_prof_questions, i_prof.institution, ei.id_software),
                                                  o.id_opinion_type) = 'Y';
    
    BEGIN
        g_error := 'GET CONFIGURATIONS';
        -- Se o motivo da alta obriga a criação de um episodio (Software/instituição)
        g_disch_reason := pk_sysconfig.get_config('ID_DISCHARGE_INTERNMENT', i_prof);
        -- Se o motivo da alta obriga a criação de um episodio (Software/instituição)
        g_disch_reason_oris := pk_sysconfig.get_config('ID_DISCHARGE_ORIS', i_prof);
        -- Se é possivél efectuar alta administrativa sem alta médica(Software/instituição)
        g_disch_admin := pk_sysconfig.get_config('DOCTOR_DISCH_MANDATORY', i_prof); --'DISCHARGE_ADMIN', I_PROF);
        -- Se é possivél realizar a alta sobre o episódio com episódios sociais activos(Software/instituição)
        g_disch_social := pk_sysconfig.get_config('DISCHARGE_SOCIAL', i_prof);
        -- Validar se existem MCDTs em atraso aquando alta médica
        g_discharge_mcdt := pk_sysconfig.get_config('DISCHARGE_MCDT', i_prof);
        --
        l_force_doc_discharge := pk_sysconfig.get_config(g_cfg_force_doc_discharge, i_prof);
    
        --
        o_flg_show_msg := 'N';
        --
        IF pk_sysconfig.get_config('ALLOW_DISPOSITION_WITHOUT_COSIGN', i_prof) = g_no
           AND i_flg_type <> g_adm
        THEN
            -- Check if there are tasks with pending co-sign
            SELECT COUNT(1)
              INTO l_cosign_count
              FROM TABLE(pk_co_sign_api.tf_pending_co_sign_tasks(i_lang    => i_lang,
                                                                 i_prof    => i_prof,
                                                                 i_episode => i_episode)) c;
        
            IF l_cosign_count > 0
            THEN
                l_error_title   := pk_message.get_message(i_lang, 'DISPOSITION_NOCOSIGN_T001');
                l_error_message := pk_message.get_message(i_lang, 'DISPOSITION_NOCOSIGN_M001');
                RAISE l_common_error;
            END IF;
        END IF;
        --
        -- Verificar se já EXISTE ALTA para este episódio
        g_error := 'OPEN CURSOR C_EPIS_DISCH';
        OPEN c_epis_disch;
        FETCH c_epis_disch
            INTO l_id_disch, l_dt_disch, l_disch_status;
        CLOSE c_epis_disch;
        --
        IF l_dt_disch IS NOT NULL
           AND l_disch_status = g_disch_act
        THEN
            -- Neste episódio já existe alta deste tipo
            l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M004'); -- MSG: "A alta já foi dada, não pode ser alterada."
            RAISE l_common_error;
        END IF;
        --
        -- Para as altas médicas é necessário verificar se é obrigatório exitir diagnósticos
        --
        IF i_flg_type = g_doctor
        THEN
            ---- ALTA MÉDICA ----
            --
            g_error := 'OPEN C_ADMIN';
            OPEN c_admin;
            FETCH c_admin
                INTO l_char;
            g_found := c_admin%NOTFOUND;
            CLOSE c_admin;
            --
            IF g_found
            THEN
                -- Se não foi registada queixa administrativa
                --
                --ET 2007/03/29
                g_error := 'OPEN C_DIAG';
                OPEN c_diag;
                FETCH c_diag
                    INTO l_flg_diag;
                CLOSE c_diag;
                --
                IF l_flg_diag = g_yes
                   AND pk_sysconfig.get_config('DISCHARGE_DIAG_MANDATORY', i_prof) = g_yes
                THEN
                    l_disch_diag_icd9 := pk_sysconfig.get_config(g_syscfg_disch_diag_icd9, i_prof);
                
                    IF l_disch_diag_icd9 = g_not_applicable
                    THEN
                        -- Obrigatório apresentar diagnósticos finais
                        --Verifica se existem diagnósticos finais no episódio
                        g_error := 'OPEN CURSOR C_EPIS_DIAG';
                        OPEN c_epis_diag;
                        FETCH c_epis_diag
                            INTO l_epis_diag;
                        g_found := c_epis_diag%NOTFOUND;
                        CLOSE c_epis_diag;
                        --
                        IF g_found
                        THEN
                            --  Não EXISTEM
                            l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M006');
                            RAISE err_no_final_diag;
                        END IF;
                    ELSE
                        g_error := 'GET DIAGNOSIS ID';
                        BEGIN
                            SELECT id_diagnosis,
                                   pk_diagnosis.std_diag_desc(i_lang         => i_lang,
                                                              i_prof         => i_prof,
                                                              i_id_diagnosis => id_diagnosis,
                                                              i_code         => code_icd,
                                                              i_flg_other    => flg_other,
                                                              i_flg_std_diag => pk_alert_constant.g_yes)
                              INTO l_diagnosis_icd9, l_error_message
                              FROM diagnosis_content
                             WHERE id_institution = i_prof.institution
                               AND id_software = i_prof.software
                               AND flg_type_dep_clin = pk_diagnosis.g_diag_pesq
                               AND code_icd = l_disch_diag_icd9
                               AND flg_type IN
                                   (SELECT /*+opt_estimate(table,tdgc,scale_rows=1))*/
                                     column_value flg_terminology
                                      FROM TABLE(pk_diagnosis_core.get_diag_terminologies(i_lang      => i_lang,
                                                                                          i_prof      => i_prof,
                                                                                          i_task_type => pk_alert_constant.g_task_diagnosis)) tdgc);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_error_message := REPLACE(pk_message.get_message(i_lang, i_prof, l_code_msg_mand_diag),
                                                           l_replace_str,
                                                           l_code_msg_mand_diag);
                        END;
                    
                        g_error := 'VALIDATE MANDATORY DIAG CATEGORY';
                        pk_alertlog.log_info(text => g_error);
                        SELECT COUNT(*)
                          INTO l_total_mand_diag
                          FROM epis_diagnosis ed
                          JOIN (SELECT d.id_diagnosis
                                  FROM (SELECT *
                                          FROM diagnosis_content
                                         WHERE id_institution = i_prof.institution
                                           AND id_software = i_prof.software
                                           AND flg_type_dep_clin = pk_diagnosis.g_diag_pesq
                                           AND flg_type IN
                                               (SELECT /*+opt_estimate(table,tdgc,scale_rows=1))*/
                                                 column_value flg_terminology
                                                  FROM TABLE(pk_diagnosis_core.get_diag_terminologies(i_lang      => i_lang,
                                                                                                      i_prof      => i_prof,
                                                                                                      i_task_type => pk_alert_constant.g_task_diagnosis)) tdgc)
                                           AND rownum > 0) d
                                 START WITH d.id_diagnosis = l_diagnosis_icd9
                                CONNECT BY PRIOR d.id_diagnosis = d.id_diagnosis_parent) dd
                            ON dd.id_diagnosis = ed.id_diagnosis
                         WHERE ed.id_episode = i_episode
                           AND ed.flg_type IN (g_epis_diag_def, g_epis_diag_base)
                           AND ed.flg_status NOT IN (g_epis_diag_canc, g_epis_diag_decl);
                    
                        IF l_total_mand_diag = 0
                        THEN
                            -- if this ID is null its a wrong configuration and the error message was built previously
                            IF l_diagnosis_icd9 IS NOT NULL
                            THEN
                                l_error_message := REPLACE(pk_message.get_message(i_lang, i_prof, l_code_msg_mand_diag),
                                                           l_replace_str,
                                                           l_error_message);
                            END IF;
                        
                            RAISE l_common_error;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END IF;
        --
        IF l_id_disch IS NULL
        THEN
            -- Episódio SEM ALTA
            IF i_flg_type = g_adm
            THEN
                -- Alta administrativa
                IF g_disch_admin <> g_yes
                THEN
                    -- Não permite Alta administrativa sem alta médica (ET 2007/02/07)
                    l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M007');
                    RAISE l_common_error;
                END IF;
            END IF;
        END IF;
        --
        -- Verificar se o MOTIVO da alta obriga a criação de um novo episódio
        --
        g_error := 'OPEN CURSOR C_DISCH_REASON';
        OPEN c_disch_reason;
        FETCH c_disch_reason
            INTO l_disch_reason, l_epis_type, l_type_screen, l_institution, l_flg_mcdt, l_flg_needs_overall_resp;
        CLOSE c_disch_reason;
        --
        -- Check if this discharge reason requires an overall responsible to be assigned to the patient
        IF nvl(l_flg_needs_overall_resp, pk_alert_constant.g_yes) = pk_alert_constant.g_yes
        THEN
            g_error := 'CHECK_OVERALL_RESP';
            alertlog.pk_alertlog.log_info(text => g_error);
            IF NOT pk_hand_off_api.check_overall_responsible(i_lang           => i_lang,
                                                             i_prof           => i_prof,
                                                             i_episode        => i_episode,
                                                             o_flg_show_error => l_show_error_msg,
                                                             o_error_title    => l_error_title,
                                                             o_error_message  => l_error_message,
                                                             o_error          => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            IF l_show_error_msg = pk_alert_constant.g_yes
            THEN
                RAISE l_common_error;
            END IF;
        END IF;
        --
        -- when discharge is administrative, check for ongoing social worker episodes
        IF i_flg_type = g_adm
           AND g_disch_social = g_adm
        THEN
            g_error := 'CALL check_sw_episode';
            check_sw_episode(i_lang      => i_lang,
                             i_prof      => i_prof,
                             i_visit     => pk_episode.get_id_visit(i_episode),
                             o_flg_show  => o_flg_show_msg,
                             o_msg_title => o_msg_title,
                             o_msg_text  => o_msg,
                             o_button    => o_button);
            IF o_flg_show_msg = pk_alert_constant.g_yes
            THEN
                l_error_message := o_msg;
                RAISE l_common_error;
            END IF;
        END IF;
        -------------------------------------------------
        IF l_force_doc_discharge = 'N'
           AND i_flg_type IN (g_doctor, g_adm)
        THEN
            g_error := 'OPEN CURSOR C_DISCH_REASON';
            OPEN c_opinion_approval_count;
            FETCH c_opinion_approval_count
                INTO l_opinion_count;
            CLOSE c_opinion_approval_count;
        
            IF l_opinion_count != 0
            THEN
                l_error_message := pk_message.get_message(i_lang, i_prof, g_opinion_approval_needed);
                RAISE l_common_error;
            END IF;
        END IF;
        -------------------------------------------------
        pk_utils.put_line('g_discharge_mcdt: ' || g_discharge_mcdt);
        IF g_discharge_mcdt = g_yes
        THEN
            IF l_flg_mcdt IS NOT NULL
            THEN
                pk_utils.put_line('l_flg_mcdt: ' || l_flg_mcdt);
                g_error := 'CALL pk_discharge.check_discharge';
                IF NOT pk_discharge.check_discharge(i_lang         => i_lang,
                                                    i_prof         => i_prof,
                                                    i_episode      => i_episode,
                                                    i_flg_mcdt     => l_flg_mcdt,
                                                    o_flg_show_msg => o_flg_show_msg,
                                                    o_msg          => o_msg,
                                                    o_msg_title    => o_msg_title,
                                                    o_button       => o_button,
                                                    o_error        => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            END IF;
        END IF;
        --
        IF l_disch_reason = g_disch_reason
        THEN
            -- Qual o tipo de episódio a ser gerado e o ecran a ser visualizado
            IF l_epis_type IS NOT NULL
               AND l_type_screen IS NOT NULL
               AND l_institution IS NULL
            THEN
                o_flg_new_epis       := g_yes;
                o_epis_type_new_epis := l_epis_type;
                o_flg_type_new_epis  := substr(l_type_screen, 1, instr(l_type_screen, '|') - 1);
                o_screen             := substr(l_type_screen, instr(l_type_screen, '|') + 1);
            ELSE
                o_flg_new_epis := g_no;
            END IF;
        ELSIF l_disch_reason = g_disch_reason_oris
        THEN
            -- Qual o tipo de episódio a ser gerado e o ecran a ser visualizado
            IF l_epis_type IS NOT NULL
               AND l_type_screen IS NOT NULL
               AND l_institution IS NULL
            THEN
                o_flg_new_epis       := g_yes;
                o_epis_type_new_epis := l_epis_type;
                o_flg_type_new_epis  := substr(l_type_screen, 1, instr(l_type_screen, '|') - 1);
                o_screen             := substr(l_type_screen, instr(l_type_screen, '|') + 1);
            ELSE
                o_flg_new_epis := g_no;
            END IF;
        ELSE
            o_flg_new_epis := g_no;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_common_error THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'CHECK_EPIS_DISCHARGE',
                                   NULL,
                                   'U',
                                   l_error_title);
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_alert_exceptions.reset_error_state();
                RETURN FALSE;
            END;
        WHEN err_no_final_diag THEN
            o_flg_show_msg := 'NO_DIAG';
            o_msg          := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_WARNING_002');
            o_msg_title    := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_WARNING_001');
            RETURN TRUE;
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CHECK_EPIS_DISCHARGE',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CHECK_EPIS_DISCHARGE',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END check_epis_discharge;
    --
    /********************************************************************************************
    * Criar registo de alta (DISCHARGE -  master and detail)
    *
    * @param i_lang                           language id
    * @param i_episode                        episode id
    * @param i_prof                           professional, software and institution ids
    * @param i_prof_cat_type                  Categoria do profissional
    * @param i_reas_dest                      Relação motivo e destino da alta
    * @param i_disch_type                     Tipo de alta: F - Fim do episódio; D - Alta
    * @param i_flg_type                       Tipo: D - Alta médica; M - Alta administrativa
    * @param i_notes                          Notas da alta
    * @param i_notes_det                      Notas do detalhe da alta
    * @param i_transp                         Transporte indicado pelo médico ou administrativo
    * @param i_notes_justify                  Notas de justificação
    * @param i_flg_pat_condition              Patient conditions: (i)mproved, (u)nchanged, (s)table, (w)orse, (o)ther
    * @param i_id_transport_type              Tipo de transporte
    * @param i_id_disch_rea_t_ent_inst 
    * @param i_flg_caretaker                  Caretaker Flag: (C)aretaker, (F)amily, (P)atient, (N)one, (O)ther
    * @param i_caretaker_notes                Notes for individual responsible for additional care and instructions
    * @param i_flg_follow_up_by               Type of Professional for performs the follow-up: (P)rimary care doctor, (N)one, (O)ther
    * @param i_follow_up_notes                Notes for follow-up
    * @param i_follow_up_date                 Date/Time of Follow-up
    * @param i_flg_written_notes              Flag indicates if there is additional WRITTEN instructions
    * @param i_flg_voluntary 
    * @param i_flg_pat_report 
    * @param i_flg_transfer_form
    * @param i_id_prof_admitting 
    * @param i_prof_admitting_desc 
    * @param i_id_dep_clin_serv_admit 
    * @param i_dep_clin_serv_ad_desc 
    * @param i_flg_summary_report 
    * @param i_flg_autopsy_consent 
    * @param i_autopsy_consent_desc 
    * @param i_flg_orgn_dntn_info 
    * @param i_orgn_dntn_info 
    * @param i_flg_examiner_notified 
    * @param i_examiner_notified_info 
    * @param i_flg_orgn_dntn_f_compl 
    * @param i_flg_ama_form_complete 
    * @param i_flg_lwbs_form_complete 
    * @param i_price                          Preço da consulta
    * @param i_currency                       Moeda
    * @param i_flg_payment                    Estado do pagamento:Pagou ou não pago
    * @param i_flg_status 
    * @param i_mse_type                       MSE (Medical screening evaluation)
    * @param o_flg_show
    * @param o_msg_title 
    * @param o_msg_text 
    * @param o_button 
    * @param o_error                          error message
    *
    * @return                                 TRUE if sucess, FALSE otherwise
    *
    * @author                                 Emília Taborda
    * @version                                1.0  
    * @since                                  06-02-2007
    ********************************************************************************************/

    FUNCTION set_epis_discharge
    (
        i_lang                       IN NUMBER,
        i_episode                    IN NUMBER,
        i_prof                       IN profissional,
        i_prof_cat_type              IN category.flg_type%TYPE,
        i_flg_new_epis               IN VARCHAR2, --5
        i_reas_dest                  IN NUMBER,
        i_disch_type                 IN VARCHAR2,
        i_flg_type                   IN VARCHAR2,
        i_notes                      IN discharge.notes_med%TYPE,
        i_notes_det                  IN discharge_detail.notes%TYPE, --10
        i_transp                     IN discharge.id_transp_ent_med%TYPE,
        i_notes_justify              IN discharge.notes_justify%TYPE,
        i_flg_pat_condition          IN discharge_detail.flg_pat_condition%TYPE,
        i_id_transport_type          IN discharge_detail.id_transport_type%TYPE,
        i_id_disch_rea_t_ent_inst    IN discharge_detail.id_disch_rea_transp_ent_inst%TYPE, --15
        i_flg_caretaker              IN discharge_detail.flg_caretaker%TYPE,
        i_caretaker_notes            IN discharge_detail.caretaker_notes%TYPE,
        i_flg_follow_up_by           IN discharge_detail.flg_follow_up_by%TYPE,
        i_follow_up_notes            IN discharge_detail.follow_up_notes%TYPE,
        i_follow_up_date_str         IN VARCHAR2, --SS --20
        i_flg_written_notes          IN discharge_detail.flg_written_notes%TYPE,
        i_flg_voluntary              IN discharge_detail.flg_voluntary%TYPE,
        i_flg_pat_report             IN discharge_detail.flg_pat_report%TYPE,
        i_flg_transfer_form          IN discharge_detail.flg_transfer_form%TYPE,
        i_id_prof_admitting          IN discharge_detail.id_prof_admitting%TYPE, --25
        i_prof_admitting_desc        IN discharge_detail.prof_admitting_desc%TYPE,
        i_id_dep_clin_serv_admit     IN discharge_detail.id_dep_clin_serv_admiting%TYPE,
        i_dep_clin_serv_ad_desc      IN discharge_detail.dep_clin_serv_admiting_desc%TYPE,
        i_flg_summary_report         IN discharge_detail.flg_summary_report%TYPE,
        i_flg_autopsy_consent        IN discharge_detail.flg_autopsy_consent%TYPE, --30
        i_autopsy_consent_desc       IN discharge_detail.autopsy_consent_desc%TYPE,
        i_flg_orgn_dntn_info         IN discharge_detail.flg_orgn_dntn_info%TYPE,
        i_orgn_dntn_info             IN discharge_detail.orgn_dntn_info%TYPE,
        i_flg_examiner_notified      IN discharge_detail.flg_examiner_notified%TYPE,
        i_examiner_notified_info     IN discharge_detail.examiner_notified_info%TYPE, --35
        i_flg_orgn_dntn_f_compl      IN discharge_detail.flg_orgn_dntn_form_complete%TYPE,
        i_flg_ama_form_complete      IN discharge_detail.flg_ama_form_complete%TYPE,
        i_flg_lwbs_form_complete     IN discharge_detail.flg_lwbs_form_complete%TYPE,
        i_price                      IN discharge.price%TYPE,
        i_currency                   IN discharge.currency%TYPE, --40
        i_flg_payment                IN discharge.flg_payment%TYPE,
        i_flg_status                 IN discharge.flg_status%TYPE,
        i_mse_type                   IN discharge_detail.mse_type%TYPE,
        i_flg_surgery                IN discharge_detail.flg_surgery%TYPE,
        i_date_surgery_str           IN VARCHAR2, --SS --45
        i_flg_print_report           IN VARCHAR2, -- José Brito 21/04/2008: Flag indicating if the professional wants to print the summary report 
        i_transfer_diagnosis         IN discharge_detail.id_transfer_diagnosis%TYPE,
        i_flg_inst_transfer          IN discharge_detail.flg_inst_transfer%TYPE,
        i_dt_admin                   IN VARCHAR2,
        i_flg_autopsy                IN discharge_detail.flg_autopsy%TYPE,
        i_dt_med                     IN VARCHAR2 DEFAULT NULL,
        i_death_process_registration IN discharge_detail.death_process_registration%TYPE DEFAULT NULL,
        o_flg_show                   OUT VARCHAR2,
        o_msg_title                  OUT VARCHAR2,
        o_msg_text                   OUT VARCHAR2,
        o_button                     OUT VARCHAR2,
        o_reports                    OUT reports.id_reports%TYPE, --odete monteiro 7/9/2007
        o_reports_pat                OUT reports.id_reports%TYPE, -- José Brito 21/04/2008: Returns the ID of the summary report to print (if any).
        o_id_episode                 OUT episode.id_episode%TYPE,
        o_id_discharge               OUT discharge.id_discharge%TYPE,
        o_shortcut                   OUT sys_shortcut.id_sys_shortcut%TYPE,
        o_error                      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_ret BOOLEAN;
        l_internal_error EXCEPTION;
        l_id_discharge discharge.id_discharge%TYPE;
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
        --l_id_print_list_jobs table_number := table_number();
        l_print_jobs   table_number := table_number();
        l_id_patient   patient.id_patient%TYPE;
        l_label        pk_translation.t_desc_translation;
        l_print_config sys_list_group_rel.flg_context%TYPE;
    
        -- Cursor com as configurações de envio automático de reports na alta
        CURSOR c_discharge_report_cfg(i_id_discharge discharge.id_discharge%TYPE) IS
            SELECT t.id_report, t.flg_send, t.flg_send_to_crm, t.generation_rank
              FROM TABLE(pk_discharge_crm.tf_discharge_report_cfg(i_lang => i_lang, i_prof => i_prof)) t
             WHERE NOT EXISTS (SELECT 1
                      FROM discharge_report dr
                     WHERE dr.id_report = t.id_report
                       AND dr.id_discharge = i_id_discharge)
             ORDER BY t.generation_rank;
    
        l_rec_disch_rep_cfg   pk_discharge_crm.t_rec_disch_rep_cfg;
        l_table_disch_rep_cfg pk_discharge_crm.t_table_disch_rep_cfg;
        l_disch_rep_rowids    table_varchar := table_varchar();
    
    BEGIN
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        pk_alertlog.log_debug(text        => 'SET_EPIS_DISCHARGE: i_death_process_registration:' ||
                                             i_death_process_registration || 'i_dt_med:' || i_dt_med ||
                                             ' i_flg_autopsy:' || i_flg_autopsy || ' i_autopsy_consent_desc:' ||
                                             i_autopsy_consent_desc,
                              object_name => g_package_name);
    
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(l_transaction_id);
    
        -- Turn off alerts for this episode
        IF NOT pk_alerts.delete_sys_alert_event_episode(i_lang, i_prof, i_episode, 'N', o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        l_id_patient := pk_episode.get_id_patient(i_episode => i_episode);
        l_ret        := set_epis_discharge_no_commit(i_lang,
                                                     i_episode,
                                                     i_prof,
                                                     i_prof_cat_type,
                                                     i_flg_new_epis,
                                                     i_reas_dest,
                                                     i_disch_type,
                                                     i_flg_type,
                                                     i_notes,
                                                     i_notes_det,
                                                     i_transp,
                                                     i_notes_justify,
                                                     i_flg_pat_condition,
                                                     i_id_transport_type,
                                                     i_id_disch_rea_t_ent_inst,
                                                     i_flg_caretaker,
                                                     i_caretaker_notes,
                                                     i_flg_follow_up_by,
                                                     i_follow_up_notes,
                                                     i_follow_up_date_str,
                                                     i_flg_written_notes,
                                                     i_flg_voluntary,
                                                     i_flg_pat_report,
                                                     i_flg_transfer_form,
                                                     i_id_prof_admitting,
                                                     i_prof_admitting_desc,
                                                     i_id_dep_clin_serv_admit,
                                                     i_dep_clin_serv_ad_desc,
                                                     i_flg_summary_report,
                                                     i_flg_autopsy_consent,
                                                     i_autopsy_consent_desc,
                                                     i_flg_orgn_dntn_info,
                                                     i_orgn_dntn_info,
                                                     i_flg_examiner_notified,
                                                     i_examiner_notified_info,
                                                     i_flg_orgn_dntn_f_compl,
                                                     i_flg_ama_form_complete,
                                                     i_flg_lwbs_form_complete,
                                                     i_price,
                                                     i_currency,
                                                     i_flg_payment,
                                                     i_flg_status,
                                                     i_mse_type,
                                                     i_flg_surgery,
                                                     i_date_surgery_str,
                                                     i_flg_print_report,
                                                     l_transaction_id,
                                                     i_transfer_diagnosis,
                                                     i_flg_inst_transfer,
                                                     i_dt_admin,
                                                     i_flg_autopsy,
                                                     i_dt_med,
                                                     i_death_process_registration,
                                                     o_flg_show,
                                                     o_msg_title,
                                                     o_msg_text,
                                                     o_button,
                                                     o_id_episode,
                                                     l_id_discharge,
                                                     o_error);
    
        IF l_ret = FALSE
        THEN
            RETURN FALSE; -- o_error can contain user error messages so function must end now
        END IF;
    
        --
        IF i_flg_type = g_doctor
        THEN
            --odete monteiro 12/9/2007 so é validado na alta medica
            BEGIN
                g_error := 'CHECK FLG_PRINT_REPORT';
                -- José Brito 21/04/2008 Return the ID of the report to print on discharge
                IF i_flg_print_report IN (pk_alert_constant.g_yes, g_disch_detail_fpr_s, g_disch_detail_fpr_x)
                THEN
                    o_reports_pat := pk_sysconfig.get_config(i_code_cf => 'PRINT_DISCHARGE_REPORT', i_prof => i_prof);
                ELSE
                    o_reports_pat := NULL;
                END IF;
            
                SELECT id_reports
                  INTO o_reports
                  FROM disch_reas_dest a
                 WHERE a.id_disch_reas_dest = i_reas_dest;
            
                g_error      := 'CALL PK_PRINT_LIST_DB.GET_PRINT_LIST_JOBS';
                l_print_jobs := pk_print_list_db.get_print_list_jobs(i_lang            => i_lang,
                                                                     i_prof            => i_prof,
                                                                     i_patient         => l_id_patient,
                                                                     i_episode         => i_episode,
                                                                     i_print_list_area => NULL);
            
                IF NOT pk_discharge.get_report_label(i_lang         => i_lang,
                                                     i_prof         => i_prof,
                                                     i_reas_dest    => i_reas_dest,
                                                     o_label        => l_label,
                                                     o_print_config => l_print_config,
                                                     o_error        => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                IF l_print_jobs.exists(1)
                   OR (i_flg_print_report = pk_alert_constant.g_yes AND i_flg_status = g_disch_flg_active)
                   OR (l_print_config = pk_discharge.g_sys_list_save_add_print_list AND o_reports IS NOT NULL)
                THEN
                    o_shortcut := pk_print_list_db.g_print_list_id_shortcut_pat;
                ELSE
                    o_shortcut := nvl(pk_sysconfig.get_config('DISPOSITION_SHORTCUT', i_prof), 38);
                END IF;
            EXCEPTION
                WHEN OTHERS THEN
                    o_reports     := NULL;
                    o_reports_pat := NULL;
            END;
        ELSE
            o_reports     := NULL;
            o_reports_pat := NULL;
        END IF;
    
        g_error := 'OPEN c_discharge_report_cfg';
        OPEN c_discharge_report_cfg(l_id_discharge);
        FETCH c_discharge_report_cfg BULK COLLECT
            INTO l_table_disch_rep_cfg;
        CLOSE c_discharge_report_cfg;
    
        IF i_flg_status = g_disch_flg_active
        THEN
            FOR i IN 1 .. l_table_disch_rep_cfg.count
            LOOP
                l_rec_disch_rep_cfg := l_table_disch_rep_cfg(i);
            
                -- check if it'is to send discharge letter
                IF (l_rec_disch_rep_cfg.flg_send = pk_alert_constant.g_yes OR
                   l_rec_disch_rep_cfg.flg_send_to_crm = pk_alert_constant.g_yes)
                   AND l_rec_disch_rep_cfg.id_report IS NOT NULL
                THEN
                    g_error := 'pk_print_tool.request_gen_report';
                    l_ret   := pk_print_tool.request_gen_report(i_id_episode         => i_episode,
                                                                i_id_patient         => l_id_patient,
                                                                i_id_institution     => i_prof.institution,
                                                                i_id_language        => i_lang,
                                                                i_id_report_type     => l_rec_disch_rep_cfg.id_report,
                                                                i_id_sections        => 'null',
                                                                i_id_professional    => i_prof.id,
                                                                i_id_software        => i_prof.software,
                                                                i_flag_report_origin => 'null');
                
                    g_error := 'ts_discharge_report.ins: id_discharge: ' || l_id_discharge || ', id_report: ' ||
                               l_rec_disch_rep_cfg.id_report;
                
                    ts_discharge_report.ins(id_discharge_in => l_id_discharge,
                                            id_report_in    => l_rec_disch_rep_cfg.id_report,
                                            flg_status_in   => pk_discharge_crm.g_flg_status_crm_req,
                                            rows_out        => l_disch_rep_rowids);
                END IF;
            END LOOP;
        END IF;
    
        --
        IF nvl(i_flg_new_epis, g_yes) = g_no
        THEN
            --refrescar esplicitamente mview de episódios
            pk_episode.update_mv_episodes();
        END IF;
    
        l_ret := pk_alerts.delete_sys_alert_event_episode(i_lang    => i_lang,
                                                          i_prof    => i_prof,
                                                          i_episode => i_episode,
                                                          i_delete  => 'Y',
                                                          o_error   => o_error);
    
        o_id_discharge := l_id_discharge;
        RETURN TRUE;
        --
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_EPIS_DISCHARGE',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_EPIS_DISCHARGE',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
    END set_epis_discharge;
    --
    /********************************************************************************************
    * Alterar nos MCDTs o ID_EPISODE e actualizar o ID_EPISODE_ORIGIN
    *
    * @param i_lang            language id
    * @param i_prof            professional, software and institution ids
    * @param i_prof_cat_type   Category professional
    * @param i_episode         episode id
    * @param i_new_episode     ID do novo episódio 
    * @param i_new_epis_type   Tipo do novo episódio
    * @param i_dep_clin_serv   Clinical service department id    
    * @param i_patient         patient id        
    * @param o_error           error message
    *
    * @return                  TRUE if sucess, FALSE otherwise
    *
    * @author                  Emília Taborda
    * @version                 1.0  
    * @since                   19-02-2007
    ********************************************************************************************/
    FUNCTION set_mcdt_episode_origin
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_episode       IN episode.id_episode%TYPE,
        i_new_episode   IN episode.id_episode%TYPE,
        i_new_epis_type IN epis_type.id_epis_type%TYPE,
        i_dep_clin_serv IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_patient       IN patient.id_patient%TYPE,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_internal_error EXCEPTION;
    
        l_new_epis_software epis_type_soft_inst.id_software%TYPE;
    BEGIN
        g_error := 'GET NEW EPISODE SOFTWARE';
        SELECT pk_episode.get_soft_by_epis_type(e.id_epis_type, e.id_institution)
          INTO l_new_epis_software
          FROM episode e
         WHERE e.id_episode = i_new_episode;
    
        g_error := 'CALL PK_API_PFH_CLINDOC_IN.SET_PRESC_NEW_EPISODE';
        pk_api_pfh_clindoc_in.set_presc_new_episode(i_lang        => i_lang,
                                                    i_prof        => i_prof,
                                                    i_id_episode  => i_episode,
                                                    i_new_episode => i_new_episode,
                                                    o_error       => o_error);
    
        g_error := 'CALL PK_API_PFH_CLINDOC_IN.PROCESS_EPIS_GRID_TASK';
        pk_api_pfh_clindoc_in.process_epis_grid_task(i_lang       => i_lang,
                                                     i_prof       => profissional(i_prof.id,
                                                                                  i_prof.institution,
                                                                                  l_new_epis_software),
                                                     i_id_episode => i_new_episode);
    
        --
        g_error := 'CALL PK_MONITORIZATION.UPDATE_MONITORIZATION';
        IF NOT pk_monitorization.update_monitorization(i_lang          => i_lang,
                                                       i_prof          => i_prof,
                                                       i_prof_cat_type => i_prof_cat_type,
                                                       i_episode       => i_episode,
                                                       i_new_episode   => i_new_episode,
                                                       o_error         => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        --
        g_error := 'CALL PK_EPISODE.UPDATE_ESTATE';
        IF NOT pk_episode.update_estate(i_lang          => i_lang,
                                        i_prof          => i_prof,
                                        i_prof_cat_type => i_prof_cat_type,
                                        i_episode       => i_episode,
                                        i_new_episode   => i_new_episode,
                                        o_error         => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        RETURN TRUE;
        --
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_MCDT_EPISODE_ORIGIN',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_MCDT_EPISODE_ORIGIN',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            RETURN FALSE;
    END;
    --
    FUNCTION get_default_admin_disch_values
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE,
        o_defaults   OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO: Obter os valores por defeito do motivo e destino da alta a utilizar quando não existe alta clínica.
           PARAMETROS:  ENTRADA: I_LANG - Língua registada como preferência do profissional
                                 I_PROF - ID do profissional
                     I_EPISODE - ID do episódio. Usado para obter a instituição e software. Não se usa a do I_PROF pq em EDIS o ADMIN trabalha com episódios EDIS e de INPATIENT.
        
                     SAÍDA: O_DEFAULTS - Valores por defeito
                               O_ERROR - Erro
        
          CRIAÇÃO: LG 2007/fev/22
          NOTAS:
        *********************************************************************************/
        l_id_software        software.id_software%TYPE;
        l_id_institution     institution.id_institution%TYPE;
        l_id_disch_reas_dest disch_reas_dest.id_disch_reas_dest%TYPE;
        l_id_transp_ent_inst transp_ent_inst.id_transp_ent_inst%TYPE;
        l_id_transp_entity   transp_entity.id_transp_entity%TYPE;
        l_desc_transp_entity pk_translation.t_desc_translation;
    BEGIN
        g_error := 'GET SOFTARE AND INSTITUTION';
        SELECT pk_episode.get_soft_by_epis_type(e.id_epis_type, e.id_institution), e.id_institution
          INTO l_id_software, l_id_institution
          FROM episode e
         WHERE e.id_episode = i_id_episode;
        --        
        g_error              := 'GET CONFIGURATIONS';
        g_error              := 'GET DISCHARGE REASON DESTINATION SYS_CONFIG';
        l_id_disch_reas_dest := pk_sysconfig.get_config(g_disch_reas_dest_default,
                                                        profissional(i_prof.id, l_id_institution, l_id_software));
        --
        g_error              := 'GET TRANSPORT SYS_CONFIG';
        l_id_transp_ent_inst := pk_sysconfig.get_config(g_disch_trans_entity_default,
                                                        profissional(i_prof.id, l_id_institution, l_id_software));
        --
        BEGIN
            g_error := 'GET TRANSPORT ENTITY';
            SELECT te.id_transp_entity, pk_translation.get_translation(i_lang, te.code_transp_entity)
              INTO l_id_transp_entity, l_desc_transp_entity
              FROM transp_ent_inst tei
              JOIN transp_entity te
                ON tei.id_transp_entity = te.id_transp_entity
             WHERE tei.id_transp_ent_inst = l_id_transp_ent_inst
               AND tei.id_institution = i_prof.institution
               AND nvl(tei.flg_type, g_transp_all) IN (g_transp_disch, g_transp_all);
            --
            g_error := 'GET DEFAULT valueS';
            IF (l_id_disch_reas_dest IS NOT NULL)
            THEN
                OPEN o_defaults FOR
                    SELECT drd.id_disch_reas_dest,
                           drd.id_discharge_reason,
                           pk_translation.get_translation(i_lang, dr.code_discharge_reason) desc_disch_reason,
                           drd.id_discharge_dest,
                           pk_translation.get_translation(i_lang, dd.code_discharge_dest) desc_disch_dest,
                           l_id_transp_ent_inst id_transp_ent_inst,
                           l_id_transp_entity id_transp_entity,
                           l_desc_transp_entity desc_transp
                      FROM disch_reas_dest drd
                      JOIN discharge_reason dr
                        ON dr.id_discharge_reason = drd.id_discharge_reason
                      JOIN discharge_dest dd
                        ON dd.id_discharge_dest = drd.id_discharge_dest
                     WHERE id_disch_reas_dest = l_id_disch_reas_dest
                       AND dd.flg_available = 'Y'
                       AND dr.flg_available = 'Y';
            ELSE
                pk_types.open_my_cursor(o_defaults);
            END IF;
        EXCEPTION
            WHEN no_data_found THEN
                pk_types.open_my_cursor(o_defaults);
        END;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DEFAULT_ADMIN_DISCH_valueS',
                                              o_error);
            pk_types.open_my_cursor(o_defaults);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
    END get_default_admin_disch_values;
    --
    /********************************************************************************************
    * Criar registo de alta (DISCHARGE -  master and detail). Alterar nos MCDTs o ID_EPISODE e actualizar o ID_PREV_EPISODE
    *
    * @param i_lang                           language id
    * @param i_episode                        episode id
    * @param i_prof                           professional, software and institution ids
    * @param i_prof_cat_type                  Categoria do profissional
    * @param i_flg_new_epis  
    * @param i_reas_dest                      Relação motivo e destino da alta
    * @param i_disch_type                     Tipo de alta: F - Fim do episódio; D - Alta
    * @param i_flg_type                       Tipo: D - Alta médica; M - Alta administrativa
    * @param i_notes                          Notas da alta
    * @param i_notes_det                      Notas do detalhe da alta
    * @param i_transp                         Transporte indicado pelo médico ou administrativo
    * @param i_notes_justify                  Notas de justificação
    * @param i_flg_pat_condition              Patient conditions: (i)mproved, (u)nchanged, (s)table, (w)orse, (o)ther
    * @param i_id_transport_type              Tipo de transporte
    * @param i_id_disch_rea_t_ent_inst 
    * @param i_flg_caretaker                  Caretaker Flag: (C)aretaker, (F)amily, (P)atient, (N)one, (O)ther
    * @param i_caretaker_notes                Notes for individual responsible for additional care and instructions
    * @param i_flg_follow_up_by               Type of Professional for performs the follow-up: (P)rimary care doctor, (N)one, (O)ther
    * @param i_follow_up_notes                Notes for follow-up
    * @param i_follow_up_date_str             Date/Time of Follow-up
    * @param i_flg_written_notes              Flag indicates if there is additional WRITTEN instructions
    * @param i_flg_voluntary 
    * @param i_flg_pat_report 
    * @param i_flg_transfer_form
    * @param i_id_prof_admitting 
    * @param i_prof_admitting_desc 
    * @param i_id_dep_clin_serv_admit 
    * @param i_dep_clin_serv_ad_desc 
    * @param i_flg_summary_report 
    * @param i_flg_autopsy_consent 
    * @param i_autopsy_consent_desc 
    * @param i_flg_orgn_dntn_info 
    * @param i_orgn_dntn_info 
    * @param i_flg_examiner_notified 
    * @param i_examiner_notified_info 
    * @param i_flg_orgn_dntn_f_compl 
    * @param i_flg_ama_form_complete 
    * @param i_flg_lwbs_form_complete 
    * @param i_price                          Preço da consulta
    * @param i_currency                       Moeda
    * @param i_flg_payment                    Estado do pagamento:Pagou ou não pago
    * @param i_flg_status 
    * @param i_new_episode                    ID do novo episódio
    * @param i_new_epis_type                  Tipo do novo episódio
    * @param i_flg_type_new_epis              Estado (flg_type) do novo episódio
    * @param i_id_clinical_service            Clinical service id
    * @param i_dep_clin_serv                  Clinical service department id
    * @param i_patient                        patient id
    * @param i_entry_notes                    Entry notes
    * @param i_date_prev_inp_str              Data prevista de internamento
    * @param i_date_prev_disch_str            Data prevista da alta
    * @param i_id_room                        room id
    * @param i_id_bed                         bed id
    * @param i_flg_surgery                    Flg surgery
    * @param i_dt_surgery_str                 surgery date
    * @param i_mse_type                       MSE (Medical screening evaluation)
    * @param i_transaction_id     Scheduler 3.0 transaction ID
    * @param o_flg_show 
    * @param o_msg_title 
    * @param o_msg_text 
    * @param o_button 
    * @param o_id_episode                     episode ID that was created after the discharge
    * @param o_error                          Error message
    *                        
    * @return                                 TRUE if sucess, FALSE otherwise
    *
    * @author                                 Emília Taborda
    * @version                                1.0  
    * @since                                  06-02-2007
    ********************************************************************************************/
    FUNCTION set_discharge_edis_to_inp
    (
        i_lang                    IN NUMBER,
        i_episode                 IN NUMBER,
        i_prof                    IN profissional,
        i_prof_cat_type           IN category.flg_type%TYPE,
        i_flg_new_epis            IN VARCHAR2,
        i_reas_dest               IN NUMBER,
        i_disch_type              IN VARCHAR2,
        i_flg_type                IN VARCHAR2,
        i_notes                   IN discharge.notes_med%TYPE,
        i_notes_det               IN discharge_detail.notes%TYPE,
        i_transp                  IN discharge.id_transp_ent_med%TYPE,
        i_notes_justify           IN discharge.notes_justify%TYPE,
        i_flg_pat_condition       IN discharge_detail.flg_pat_condition%TYPE,
        i_id_transport_type       IN discharge_detail.id_transport_type%TYPE,
        i_id_disch_rea_t_ent_inst IN discharge_detail.id_disch_rea_transp_ent_inst%TYPE,
        i_flg_caretaker           IN discharge_detail.flg_caretaker%TYPE,
        i_caretaker_notes         IN discharge_detail.caretaker_notes%TYPE,
        i_flg_follow_up_by        IN discharge_detail.flg_follow_up_by%TYPE,
        i_follow_up_notes         IN discharge_detail.follow_up_notes%TYPE,
        i_follow_up_date_str      IN VARCHAR2,
        i_flg_written_notes       IN discharge_detail.flg_written_notes%TYPE,
        i_flg_voluntary           IN discharge_detail.flg_voluntary%TYPE,
        i_flg_pat_report          IN discharge_detail.flg_pat_report%TYPE,
        i_flg_transfer_form       IN discharge_detail.flg_transfer_form%TYPE,
        i_id_prof_admitting       IN discharge_detail.id_prof_admitting%TYPE,
        i_prof_admitting_desc     IN discharge_detail.prof_admitting_desc%TYPE,
        i_id_dep_clin_serv_admit  IN discharge_detail.id_dep_clin_serv_admiting%TYPE,
        i_dep_clin_serv_ad_desc   IN discharge_detail.dep_clin_serv_admiting_desc%TYPE,
        i_flg_summary_report      IN discharge_detail.flg_summary_report%TYPE,
        i_flg_autopsy_consent     IN discharge_detail.flg_autopsy_consent%TYPE,
        i_autopsy_consent_desc    IN discharge_detail.autopsy_consent_desc%TYPE,
        i_flg_orgn_dntn_info      IN discharge_detail.flg_orgn_dntn_info%TYPE,
        i_orgn_dntn_info          IN discharge_detail.orgn_dntn_info%TYPE,
        i_flg_examiner_notified   IN discharge_detail.flg_examiner_notified%TYPE,
        i_examiner_notified_info  IN discharge_detail.examiner_notified_info%TYPE,
        i_flg_orgn_dntn_f_compl   IN discharge_detail.flg_orgn_dntn_form_complete%TYPE,
        i_flg_ama_form_complete   IN discharge_detail.flg_ama_form_complete%TYPE,
        i_flg_lwbs_form_complete  IN discharge_detail.flg_lwbs_form_complete%TYPE,
        i_price                   IN discharge.price%TYPE,
        i_currency                IN discharge.currency%TYPE,
        i_flg_payment             IN discharge.flg_payment%TYPE,
        i_flg_status              IN discharge.flg_status%TYPE,
        i_new_episode             IN episode.id_episode%TYPE,
        i_new_epis_type           IN epis_type.id_epis_type%TYPE,
        i_flg_type_new_epis       IN episode.flg_type%TYPE,
        i_id_clinical_service     IN clinical_service.id_clinical_service%TYPE,
        i_dep_clin_serv           IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_patient                 IN patient.id_patient%TYPE,
        i_entry_notes             IN VARCHAR,
        i_date_prev_inp_str       IN VARCHAR2,
        i_date_prev_disch_str     IN VARCHAR2,
        i_id_room                 IN room.id_room%TYPE,
        i_id_bed                  IN bed.id_bed%TYPE,
        i_flg_surgery             IN VARCHAR2,
        i_dt_surgery_str          IN VARCHAR2,
        i_mse_type                IN discharge_detail.mse_type%TYPE,
        i_flg_print_report        IN VARCHAR2, -- José Brito 21/04/2008: Flag indicating if the professional wants to print the summary report
        i_transaction_id          IN VARCHAR2,
        i_transfer_diagnosis      IN discharge_detail.id_transfer_diagnosis%TYPE,
        i_flg_inst_transfer       IN discharge_detail.flg_inst_transfer%TYPE,
        i_dt_admin                IN VARCHAR2,
        i_dt_med                  IN VARCHAR2 DEFAULT NULL,
        o_flg_show                OUT VARCHAR2,
        o_msg_title               OUT VARCHAR2,
        o_msg_text                OUT VARCHAR2,
        o_button                  OUT VARCHAR2,
        o_id_episode              OUT episode.id_episode%TYPE,
        o_id_discharge            OUT discharge.id_discharge%TYPE,
        o_reports                 OUT reports.id_reports%TYPE, --odete monteiro 7/9/2007
        o_reports_pat             OUT reports.id_reports%TYPE, -- José Brito 21/04/2008: Returns the ID of the summary report to print (if any).
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_can_refresh_mviews VARCHAR2(1) := g_no;
    
        l_internal_error EXCEPTION;
        --l_error_message VARCHAR2(4000);
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
    BEGIN
        g_sysdate_tstz := current_timestamp;
        --
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
    
        g_error := 'CALL PK_DISCHARGE.SET_EPIS_DISCHARGE';
        IF NOT pk_discharge.set_epis_discharge_no_commit(i_lang                    => i_lang,
                                                         i_episode                 => i_episode,
                                                         i_prof                    => i_prof,
                                                         i_prof_cat_type           => i_prof_cat_type,
                                                         i_flg_new_epis            => i_flg_new_epis,
                                                         i_reas_dest               => i_reas_dest,
                                                         i_disch_type              => i_disch_type,
                                                         i_flg_type                => i_flg_type,
                                                         i_notes                   => i_notes,
                                                         i_notes_det               => i_notes_det,
                                                         i_transp                  => i_transp,
                                                         i_notes_justify           => i_notes_justify,
                                                         i_flg_pat_condition       => i_flg_pat_condition,
                                                         i_id_transport_type       => i_id_transport_type,
                                                         i_id_disch_rea_t_ent_inst => i_id_disch_rea_t_ent_inst,
                                                         i_flg_caretaker           => i_flg_caretaker,
                                                         i_caretaker_notes         => i_caretaker_notes,
                                                         i_flg_follow_up_by        => i_flg_follow_up_by,
                                                         i_follow_up_notes         => i_follow_up_notes,
                                                         i_follow_up_date_str      => i_follow_up_date_str,
                                                         i_flg_written_notes       => i_flg_written_notes,
                                                         i_flg_voluntary           => i_flg_voluntary,
                                                         i_flg_pat_report          => i_flg_pat_report,
                                                         i_flg_transfer_form       => i_flg_transfer_form,
                                                         i_id_prof_admitting       => i_id_prof_admitting,
                                                         i_prof_admitting_desc     => i_prof_admitting_desc,
                                                         i_id_dep_clin_serv_admit  => i_id_dep_clin_serv_admit,
                                                         i_dep_clin_serv_ad_desc   => i_dep_clin_serv_ad_desc,
                                                         i_flg_summary_report      => i_flg_summary_report,
                                                         i_flg_autopsy_consent     => i_flg_autopsy_consent,
                                                         i_autopsy_consent_desc    => i_autopsy_consent_desc,
                                                         i_flg_orgn_dntn_info      => i_flg_orgn_dntn_info,
                                                         i_orgn_dntn_info          => i_orgn_dntn_info,
                                                         i_flg_examiner_notified   => i_flg_examiner_notified,
                                                         i_examiner_notified_info  => i_examiner_notified_info,
                                                         i_flg_orgn_dntn_f_compl   => i_flg_orgn_dntn_f_compl,
                                                         i_flg_ama_form_complete   => i_flg_ama_form_complete,
                                                         i_flg_lwbs_form_complete  => i_flg_lwbs_form_complete,
                                                         i_price                   => i_price,
                                                         i_currency                => i_currency,
                                                         i_flg_payment             => i_flg_payment,
                                                         i_flg_status              => i_flg_status,
                                                         i_mse_type                => i_mse_type,
                                                         i_flg_surgery             => i_flg_surgery,
                                                         i_date_surgery_str        => i_dt_surgery_str,
                                                         i_flg_print_report        => i_flg_print_report,
                                                         i_transaction_id          => l_transaction_id,
                                                         i_transfer_diagnosis      => i_transfer_diagnosis,
                                                         i_flg_inst_transfer       => i_flg_inst_transfer,
                                                         i_dt_admin                => i_dt_admin,
                                                         i_flg_autopsy             => NULL,
                                                         i_dt_med                  => i_dt_med,
                                                         o_flg_show                => o_flg_show,
                                                         o_msg_title               => o_msg_title,
                                                         o_msg_text                => o_msg_text,
                                                         o_button                  => o_button,
                                                         o_id_episode              => o_id_episode,
                                                         o_id_discharge            => o_id_discharge,
                                                         o_error                   => o_error)
        THEN
            RETURN FALSE; -- o_error can contain user error messages so function must end now
        END IF;
        --
        IF NOT set_inp_episode(i_lang               => i_lang,
                               i_prof               => i_prof,
                               i_patient            => i_patient,
                               i_episode            => i_episode,
                               i_prof_cat_type      => i_prof_cat_type,
                               i_flg_status         => i_flg_status,
                               i_flg_new_epis       => i_flg_new_epis,
                               i_new_epis_type      => i_new_epis_type,
                               i_id_prof_admitting  => i_id_prof_admitting,
                               i_dep_clin_serv      => i_dep_clin_serv,
                               i_transaction_id     => l_transaction_id,
                               o_can_refresh_mviews => l_can_refresh_mviews,
                               o_id_episode         => o_id_episode,
                               o_error              => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF i_flg_type = g_doctor
        THEN
            --odete monteiro 12/9/2007 so é validado na alta medica
            BEGIN
                -- José Brito 21/04/2008 Return the ID of the report to print on discharge
                IF i_flg_print_report IN (pk_alert_constant.g_yes, g_disch_detail_fpr_s, g_disch_detail_fpr_x)
                THEN
                    o_reports_pat := pk_sysconfig.get_config(i_code_cf => 'PRINT_DISCHARGE_REPORT', i_prof => i_prof);
                ELSE
                    o_reports_pat := NULL;
                END IF;
            
                SELECT id_reports
                  INTO o_reports
                  FROM disch_reas_dest a
                 WHERE a.id_disch_reas_dest = i_reas_dest;
            EXCEPTION
                WHEN OTHERS THEN
                    o_reports     := NULL;
                    o_reports_pat := NULL;
            END;
        ELSE
            o_reports     := NULL;
            o_reports_pat := NULL;
        END IF;
    
        FOR r_analysis IN (SELECT ard.id_analysis_req_det, ard.id_analysis_req, ar.id_patient
                             FROM analysis_req_det ard, analysis_req ar
                            WHERE ar.id_episode = i_episode
                              AND ard.id_analysis_req = ar.id_analysis_req)
        LOOP
            g_error := 'PK_LAB_TESTS_API_DB.SET_LAB_TEST_GRID_TASK';
            IF NOT pk_lab_tests_api_db.set_lab_test_grid_task(i_lang             => i_lang,
                                                              i_prof             => i_prof,
                                                              i_patient          => r_analysis.id_patient,
                                                              i_episode          => i_episode,
                                                              i_analysis_req     => r_analysis.id_analysis_req,
                                                              i_analysis_req_det => r_analysis.id_analysis_req_det,
                                                              o_error            => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END LOOP;
    
        FOR r_exam IN (SELECT erd.id_exam_req_det, erd.id_exam_req, er.id_patient
                         FROM exam_req_det erd, exam_req er
                        WHERE er.id_episode = i_episode
                          AND erd.id_exam_req = er.id_exam_req)
        LOOP
            g_error := 'PK_EXAMS_API_DB.SET_EXAM_GRID_TASK';
            IF NOT pk_exams_api_db.set_exam_grid_task(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_patient      => r_exam.id_patient,
                                                      i_episode      => i_episode,
                                                      i_exam_req     => r_exam.id_exam_req,
                                                      i_exam_req_det => r_exam.id_exam_req_det,
                                                      o_error        => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END LOOP;
    
        -- Valida necessidade de criação de alerta
        -- Válido para os alertas 30 e 31
        IF NOT set_disch_edis_to_inp_alert(i_lang, i_prof, i_episode, o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF l_can_refresh_mviews = g_yes
        THEN
            pk_episode.update_mv_episodes();
        END IF;
    
        IF i_transaction_id IS NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
    
        RETURN TRUE;
        --
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_EDIS_TO_INP',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_EDIS_TO_INP',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_discharge_edis_to_inp;
    --
    /********************************************************************************************
    * Criar registo de alta (DISCHARGE -  master and detail). Alterar nos MCDTs o ID_EPISODE e actualizar o ID_PREV_EPISODE
    *
    * @param i_lang                           language id
    * @param i_episode                        episode id
    * @param i_prof                           professional, software and institution ids
    * @param i_prof_cat_type                  Categoria do profissional
    * @param i_flg_new_epis                   Tipo do novo episódio
    * @param i_reas_dest                      Relação motivo e destino da alta
    * @param i_disch_type                     Tipo de alta: F - Fim do episódio; D - Alta
    * @param i_flg_type                       Tipo: D - Alta médica; M - Alta administrativa
    * @param i_notes                          Notas da alta
    * @param i_notes_det                      Notas do detalhe da alta
    * @param i_transp                         Transporte indicado pelo médico ou administrativo
    * @param i_notes_justify                  Notas de justificação
    * @param i_flg_pat_condition              Patient conditions: (i)mproved, (u)nchanged, (s)table, (w)orse, (o)ther
    * @param i_id_transport_type              Tipo de transporte
    * @param i_id_disch_rea_t_ent_inst 
    * @param i_flg_caretaker                  Caretaker Flag: (C)aretaker, (F)amily, (P)atient, (N)one, (O)ther
    * @param i_caretaker_notes                Notes for individual responsible for additional care and instructions
    * @param i_flg_follow_up_by               Type of Professional for performs the follow-up: (P)rimary care doctor, (N)one, (O)ther
    * @param i_follow_up_notes                Notes for follow-up
    * @param i_follow_up_date                 Date/Time of Follow-up
    * @param i_flg_written_notes              Flag indicates if there is additional WRITTEN instructions
    * @param i_flg_voluntary 
    * @param i_flg_pat_report 
    * @param i_flg_transfer_form
    * @param i_id_prof_admitting 
    * @param i_prof_admitting_desc 
    * @param i_id_dep_clin_serv_admit 
    * @param i_dep_clin_serv_ad_desc 
    * @param i_flg_summary_report 
    * @param i_flg_autopsy_consent 
    * @param i_autopsy_consent_desc 
    * @param i_flg_orgn_dntn_info 
    * @param i_orgn_dntn_info 
    * @param i_flg_examiner_notified 
    * @param i_examiner_notified_info 
    * @param i_flg_orgn_dntn_f_compl 
    * @param i_flg_ama_form_complete 
    * @param i_flg_lwbs_form_complete 
    * @param i_price                          Preço da consulta
    * @param i_currency                       Moeda
    * @param i_flg_payment                    Estado do pagamento:Pagou ou não pago
    * @param i_flg_status 
    * @param i_mse_type                       MSE (Medical screening evaluation)
    * @param i_flg_surgery                    Flg surgery
    * @param i_dt_surgery_str                 surgery date
    * @param i_transaction_id     Scheduler 3.0 transaction ID
    * @param o_flg_show 
    * @param o_msg_title 
    * @param o_msg_text 
    * @param o_button 
    * @param o_error                          error message
    *
    * @return                                 TRUE if sucess, FALSE otherwise
    *
    * @author                                 Emília Taborda
    * @version                                1.0  
    * @since                                  23-02-2007
    ********************************************************************************************/
    FUNCTION set_epis_discharge_no_commit
    (
        i_lang                       IN NUMBER,
        i_episode                    IN NUMBER,
        i_prof                       IN profissional,
        i_prof_cat_type              IN category.flg_type%TYPE,
        i_flg_new_epis               IN VARCHAR2,
        i_reas_dest                  IN NUMBER,
        i_disch_type                 IN VARCHAR2,
        i_flg_type                   IN VARCHAR2,
        i_notes                      IN discharge.notes_med%TYPE,
        i_notes_det                  IN discharge_detail.notes%TYPE,
        i_transp                     IN discharge.id_transp_ent_med%TYPE,
        i_notes_justify              IN discharge.notes_justify%TYPE,
        i_flg_pat_condition          IN discharge_detail.flg_pat_condition%TYPE,
        i_id_transport_type          IN discharge_detail.id_transport_type%TYPE,
        i_id_disch_rea_t_ent_inst    IN discharge_detail.id_disch_rea_transp_ent_inst%TYPE,
        i_flg_caretaker              IN discharge_detail.flg_caretaker%TYPE,
        i_caretaker_notes            IN discharge_detail.caretaker_notes%TYPE,
        i_flg_follow_up_by           IN discharge_detail.flg_follow_up_by%TYPE,
        i_follow_up_notes            IN discharge_detail.follow_up_notes%TYPE,
        i_follow_up_date_str         IN VARCHAR2, --ss
        i_flg_written_notes          IN discharge_detail.flg_written_notes%TYPE,
        i_flg_voluntary              IN discharge_detail.flg_voluntary%TYPE,
        i_flg_pat_report             IN discharge_detail.flg_pat_report%TYPE,
        i_flg_transfer_form          IN discharge_detail.flg_transfer_form%TYPE,
        i_id_prof_admitting          IN discharge_detail.id_prof_admitting%TYPE,
        i_prof_admitting_desc        IN discharge_detail.prof_admitting_desc%TYPE,
        i_id_dep_clin_serv_admit     IN discharge_detail.id_dep_clin_serv_admiting%TYPE,
        i_dep_clin_serv_ad_desc      IN discharge_detail.dep_clin_serv_admiting_desc%TYPE,
        i_flg_summary_report         IN discharge_detail.flg_summary_report%TYPE,
        i_flg_autopsy_consent        IN discharge_detail.flg_autopsy_consent%TYPE,
        i_autopsy_consent_desc       IN discharge_detail.autopsy_consent_desc%TYPE,
        i_flg_orgn_dntn_info         IN discharge_detail.flg_orgn_dntn_info%TYPE,
        i_orgn_dntn_info             IN discharge_detail.orgn_dntn_info%TYPE,
        i_flg_examiner_notified      IN discharge_detail.flg_examiner_notified%TYPE,
        i_examiner_notified_info     IN discharge_detail.examiner_notified_info%TYPE,
        i_flg_orgn_dntn_f_compl      IN discharge_detail.flg_orgn_dntn_form_complete%TYPE,
        i_flg_ama_form_complete      IN discharge_detail.flg_ama_form_complete%TYPE,
        i_flg_lwbs_form_complete     IN discharge_detail.flg_lwbs_form_complete%TYPE,
        i_price                      IN discharge.price%TYPE,
        i_currency                   IN discharge.currency%TYPE,
        i_flg_payment                IN discharge.flg_payment%TYPE,
        i_flg_status                 IN discharge.flg_status%TYPE,
        i_mse_type                   IN discharge_detail.mse_type%TYPE,
        i_flg_surgery                IN discharge_detail.flg_surgery%TYPE,
        i_date_surgery_str           IN VARCHAR2, --SS
        i_flg_print_report           IN VARCHAR2,
        i_transaction_id             IN VARCHAR2,
        i_transfer_diagnosis         IN discharge_detail.id_transfer_diagnosis%TYPE,
        i_flg_inst_transfer          IN discharge_detail.flg_inst_transfer%TYPE,
        i_dt_admin                   IN VARCHAR2,
        i_flg_autopsy                IN discharge_detail.flg_autopsy%TYPE,
        i_dt_med                     IN VARCHAR2 DEFAULT NULL,
        i_death_process_registration IN discharge_detail.death_process_registration%TYPE DEFAULT NULL,
        o_flg_show                   OUT VARCHAR2,
        o_msg_title                  OUT VARCHAR2,
        o_msg_text                   OUT VARCHAR2,
        o_button                     OUT VARCHAR2,
        o_id_episode                 OUT episode.id_episode%TYPE,
        o_id_discharge               OUT discharge.id_discharge%TYPE,
        o_error                      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_next_disch  discharge.id_discharge%TYPE;
        l_next_detail discharge_detail.id_discharge_detail%TYPE;
        --l_exist_temp  VARCHAR2(1);
        l_visit   visit.id_visit%TYPE;
        l_patient visit.id_patient%TYPE;
        --
        l_epis_type     episode.id_epis_type%TYPE;
        l_epis_dt_begin episode.dt_begin_tstz%TYPE;
        l_aux           VARCHAR2(2000);
        l_count         NUMBER;
        --
        l_disch_status discharge.flg_status%TYPE;
        l_id_disch     discharge.id_discharge%TYPE;
        l_flg_payment  sys_config.value%TYPE;
        l_episode_inp  episode.id_prev_episode%TYPE;
        l_prev_episode episode.id_prev_episode%TYPE;
        --
        l_new_epis_type disch_reas_dest.id_epis_type%TYPE;
        l_type_screen   disch_reas_dest.type_screen%TYPE;
        l_type_new_epis episode.flg_type%TYPE;
        l_institution   disch_reas_dest.id_institution%TYPE;
        ---
        l_flg_type       discharge.flg_type%TYPE;
        l_flg_show       VARCHAR2(0050);
        l_msg_title      VARCHAR2(4000);
        l_msg_text       VARCHAR2(4000);
        l_button         VARCHAR2(0050);
        l_flg_end_epis   VARCHAR2(1);
        l_flg_type_disch discharge.flg_type_disch%TYPE;
        --
        -- l_grid_task  grid_task%ROWTYPE;
        l_short_pend sys_shortcut.id_sys_shortcut%TYPE;
        --        
        CURSOR c_discharge IS
            SELECT id_discharge, flg_status, dt_med_tstz
              FROM discharge
             WHERE id_episode = i_episode
                  -- lg 2007-03-02
               AND flg_status IN (g_epis_disch_act, g_disch_flg_pend);
    
        -- Devolve o episódio destino deste episódio
        CURSOR c_episode_inp IS
            SELECT id_episode
              FROM episode
             WHERE id_prev_episode = i_episode
               AND flg_status = g_epis_active
               AND id_visit = l_visit;
    
        -- id_disch_reas_dest id_disch_reas_dest 
        -- Devolve o episódio origem deste episodio EX: Epis. actual: Inpatient  --epis.Origem Urgencia
        CURSOR c_prev_episode IS
            SELECT epis.id_prev_episode
              FROM episode epis, episode epis1, discharge d
             WHERE epis.id_episode = i_episode
               AND epis.id_prev_episode = epis1.id_episode
                  --               AND epis1.flg_status != g_epis_inactive;
               AND epis1.flg_status = g_epis_pend;
    
        -- Qual o motivo da alta, 
        CURSOR c_disch_reason IS
            SELECT drd.id_epis_type,
                   drd.type_screen,
                   substr(l_type_screen, 1, instr(l_type_screen, '|') - 1) flg_type_new_epis,
                   drd.id_institution
              FROM disch_reas_dest drd, discharge d
             WHERE drd.id_disch_reas_dest = d.id_disch_reas_dest
               AND d.id_episode = i_episode
               AND flg_status IN (g_epis_disch_act, g_disch_flg_pend);
    
        -- cursor para validar se é uma alta com instituições de transferência
        CURSOR c_transf_discharge IS
            SELECT dd.flg_inst_transfer,
                   decode((SELECT 1
                            FROM disch_transf_inst dti
                           WHERE id_discharge = l_id_disch
                             AND dti.flg_status = pk_discharge_inst.g_transf_status_concluded
                             AND rownum = 1),
                          NULL,
                          g_no,
                          g_yes) is_concluded
              FROM discharge_detail dd
             WHERE dd.id_discharge = l_id_disch;
    
        -- Cursor com as configurações de envio automático de reports na alta
        /*
        CURSOR c_discharge_report_cfg(i_id_discharge discharge.id_discharge%TYPE) IS
            SELECT t.id_report, t.flg_send, t.flg_send_to_crm, t.generation_rank
              FROM TABLE(pk_discharge_crm.tf_discharge_report_cfg(i_lang => i_lang, i_prof => i_prof)) t
             WHERE NOT EXISTS (SELECT 1
                      FROM discharge_report dr
                     WHERE dr.id_report = t.id_report
                       AND dr.id_discharge = i_id_discharge)
             ORDER BY t.generation_rank;
             */
    
        l_flg_inst_transfer discharge_detail.flg_inst_transfer%TYPE;
        l_dti_concluded     VARCHAR(1 CHAR);
    
        -- denormalization variables
        l_rowids              table_varchar;
        l_rowids_aux          table_varchar;
        l_dt_admin_tstz       discharge.dt_admin_tstz%TYPE;
        l_dt_med_tstz         discharge.dt_med_tstz%TYPE;
        l_dt_pend_active_tstz discharge.dt_pend_active_tstz%TYPE;
        l_flag_status         discharge.flg_status%TYPE;
        l_id_disch_reas       discharge.id_disch_reas_dest%TYPE;
    
        l_sysdate_tstz TIMESTAMP WITH LOCAL TIME ZONE;
        l_med_tstz     TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_internal_error EXCEPTION;
        l_err_date_begin EXCEPTION;
    
        l_id_episode   episode.id_episode%TYPE;
        l_id_discharge discharge.id_discharge%TYPE;
        l_id_hist      discharge_hist.id_discharge_hist%TYPE;
    
        l_flg_status       discharge.flg_status%TYPE;
        l_discharge_status discharge.id_discharge_status%TYPE;
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
        l_id_schedule    schedule_outp.id_schedule_outp%TYPE;
    
        l_err_msg           sys_message.desc_message%TYPE;
        l_error_title       sys_message.desc_message%TYPE;
        l_rowids2           table_varchar;
        l_sei_flg_status    table_varchar;
        l_id_sr_epis_interv table_number;
    
        l_id_print_list_jobs table_number := table_number();
        l_cancel_print_jobs_excpt EXCEPTION;
    
        --
        l_status_string VARCHAR2(200);
        l_status_str    VARCHAR2(200);
        l_dummy         VARCHAR2(200);
    
        l_dt_epis_begin         episode.dt_begin_tstz%TYPE;
        l_check_intake_time_cfg sys_config.desc_sys_config%TYPE;
        l_auto_presc_cancel     VARCHAR2(1 CHAR);
        l_prof_id               NUMBER;
        l_auto_cancel_msg       sys_message.desc_message%TYPE;
    
    BEGIN
        g_sysdate := SYSDATE;
        -- José Brito 14/11/2008 Variável L_SYSDATE_TSTZ usada apenas para SET_FIRST_OBS, 
        -- para garantir que a DT_FIRST_OBS não é superior à alta médica.
        l_sysdate_tstz := current_timestamp;
        g_sysdate_tstz := current_timestamp;
    
        pk_alertlog.log_debug(text        => 'SET_EPIS_DISCHARGE_NO_COMMIT: i_death_process_registration:' ||
                                             i_death_process_registration,
                              object_name => g_package_name);
        --
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
        --
        -- odete monteiro 14/11/2007 altas clinicas pendentes, actulizacao da epis_grid
        -- l_grid_task.id_episode := i_episode;
        l_check_intake_time_cfg := pk_sysconfig.get_config('USE_INTAKE_TIME_TO_CALCULATE_LOS', i_prof);
        l_auto_cancel_msg       := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_T033');
    
        g_error := 'GET VISIT AND PATIENT ID';
        SELECT e.id_visit, e.id_patient, e.id_epis_type, e.dt_begin_tstz
          INTO l_visit, l_patient, l_epis_type, l_epis_dt_begin
          FROM episode e
         WHERE e.id_episode = i_episode;
    
        g_error := 'GET SCHEDULE ID';
        BEGIN
            SELECT DISTINCT v.id_schedule
              INTO l_id_schedule
              FROM epis_info v
             WHERE v.id_episode = i_episode;
        EXCEPTION
            WHEN no_data_found THEN
                --l_id_schedule := NULL;
                NULL;
        END;
    
        IF l_check_intake_time_cfg = g_yes
        THEN
            BEGIN
                SELECT dt_intake_time
                  INTO l_dt_epis_begin
                  FROM (SELECT eit.dt_intake_time
                          FROM epis_intake_time eit
                         WHERE eit.id_episode = i_episode
                         ORDER BY eit.dt_register DESC)
                 WHERE rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_dt_epis_begin := l_epis_dt_begin;
            END;
        ELSE
            l_dt_epis_begin := l_epis_dt_begin;
        END IF;
    
        IF (i_dt_med = ' ' OR i_dt_med IS NULL)
        THEN
            l_med_tstz := g_sysdate_tstz;
        ELSIF (i_dt_med IS NOT NULL AND l_dt_epis_begin > pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_med, NULL))
        THEN
            l_err_msg := pk_message.get_message(i_lang, 'DISCHARGE_M020');
        
            RAISE l_err_date_begin;
        ELSE
            l_med_tstz := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_med, NULL);
        END IF;
    
        --
        SELECT COUNT(*)
          INTO l_count
          FROM episode
         WHERE id_visit = l_visit
           AND flg_status NOT IN (g_epis_inactive, g_epis_canc);
    
        g_error      := 'OPEN C_SHORT_IMAGE';
        l_short_pend := pk_disposition.get_discharge_shortcut(i_lang => i_lang, i_prof => i_prof);
    
        -- Delete all grid_task tasks to a specific episode
        /*        g_error := 'CALL TO PK_GRID.DELETE_EPIS_GRID_TASK';
        IF NOT pk_grid.update_grid_task(i_lang => i_lang, i_grid_task => l_grid_task, o_error => o_error)
        THEN
            RAISE l_internal_error;
        END IF;*/
    
        IF i_flg_status = g_disch_flg_pend
        THEN
            g_error := 'UPDATE DISCHARGE_PEND GRID TASK';
            pk_utils.build_status_string(i_display_type => pk_alert_constant.g_display_type_date,
                                         i_value_date   => pk_date_utils.to_char_insttimezone(i_prof,
                                                                                              g_sysdate_tstz,
                                                                                              pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                         i_shortcut     => l_short_pend,
                                         o_status_str   => l_status_str,
                                         o_status_msg   => l_dummy,
                                         o_status_icon  => l_dummy,
                                         o_status_flg   => l_dummy);
        
            l_status_string := REPLACE(l_status_str,
                                       pk_alert_constant.g_status_rpl_chr_dt_server,
                                       pk_date_utils.to_char_insttimezone(i_prof,
                                                                          g_sysdate_tstz,
                                                                          pk_alert_constant.g_dt_yyyymmddhh24miss_tzr)) || '|';
        
            IF NOT pk_grid.update_grid_task(i_lang             => i_lang,
                                            i_prof             => i_prof,
                                            i_episode          => i_episode,
                                            discharge_pend_in  => l_status_string,
                                            discharge_pend_nin => FALSE,
                                            o_error            => o_error)
            
            THEN
                RAISE l_internal_error;
            END IF;
        
            -- José Brito 30/07/2009 ALERT-25306 Set automatic status of patient tracking after disposition
            g_error := 'SET DISPOSITION AUTOMATIC PATIENT TRACKING STATUS';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_patient_tracking.set_auto_disposition_status(i_lang               => i_lang,
                                                                   i_prof               => i_prof,
                                                                   i_episode            => i_episode,
                                                                   i_id_disch_reas_dest => i_reas_dest,
                                                                   o_error              => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
        ELSE
            -- Remove from grid task
            IF NOT pk_grid.update_grid_task(i_lang             => i_lang,
                                            i_prof             => i_prof,
                                            i_episode          => i_episode,
                                            discharge_pend_in  => NULL,
                                            discharge_pend_nin => FALSE,
                                            o_error            => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            g_error := 'REMOVE EPIS REGISTER DISCHARGE_PEND GRID TASK';
            pk_alertlog.log_debug(g_error);
        
            IF NOT pk_grid.delete_epis_grid_task(i_lang => i_lang, i_episode => i_episode, o_error => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
        END IF;
    
        g_error := 'GET ID_DISCHARGE_STATUS';
        IF NOT pk_discharge.get_disch_flg_status(i_lang         => i_lang,
                                                 i_prof         => i_prof,
                                                 i_flg_status   => i_flg_status,
                                                 i_disch_status => NULL,
                                                 o_flg_status   => l_flg_status,
                                                 o_disch_status => l_discharge_status,
                                                 o_error        => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        --
        -- lg 2007-fev-07 no caso do Private Practice coloca a flg_payment com o valor Por pagar
        IF (i_flg_payment IS NULL)
        THEN
            l_flg_payment := pk_sysconfig.get_config(g_sys_config_default_flg_pay, i_prof);
        ELSE
            l_flg_payment := i_flg_payment;
        END IF;
        --
        -- Validar qual o estado da alta no caso de já existir uma alta para o episódio
        g_error := 'OPEN c_discharge';
        OPEN c_discharge;
        FETCH c_discharge
            INTO l_id_disch, l_disch_status, l_dt_med_tstz;
        CLOSE c_discharge;
        --
        -- Se o tipo de alta não vier preenchido, é deduzido através da categoria do profissional
        g_error := 'SET L_FLG_TYPE';
        IF i_flg_type IS NULL
        THEN
            IF i_prof_cat_type IN (g_doctor, g_nurse, g_manchester)
            THEN
                l_flg_type := g_doctor;
            ELSIF i_prof_cat_type = g_adm_cat
            THEN
                l_flg_type := g_adm;
            END IF;
        ELSE
            l_flg_type := i_flg_type;
        END IF;
    
        -- checks if the episode is about to end
        g_error := 'SET L_FLG_END_EPIS';
        IF l_flg_type = g_adm
           OR (nvl(pk_sysconfig.get_config(g_config_disch_triage, i_prof), g_no) = g_yes AND
           i_flg_status = g_disch_flg_active)
        THEN
            l_flg_end_epis := g_yes;
        ELSE
            l_flg_end_epis := g_no;
        END IF;
    
        -- checks the discharge type
        g_error := 'SET L_FLG_TYPE_DISCH';
        IF i_prof_cat_type = g_manchester
        THEN
            l_flg_type_disch := g_triage;
        ELSIF i_flg_type = g_disch_type_therapist_o
        THEN
            l_flg_type_disch := g_therapist;
        ELSIF i_flg_type IN (g_doctor, g_adm, g_disch_type_nurse)
        THEN
            l_flg_type_disch := i_flg_type;
        ELSE
            l_flg_type_disch := NULL;
        END IF;
    
        g_error         := 'GET DT_ADMIN';
        l_dt_admin_tstz := nvl(pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_admin, NULL), g_sysdate_tstz);
    
        g_error := 'CHECK DT_ADMIN';
        IF l_dt_admin_tstz IS NOT NULL
           AND l_dt_epis_begin > l_dt_admin_tstz
        THEN
            l_err_msg     := pk_message.get_message(i_lang, 'DISCHARGE_M020');
            l_error_title := pk_message.get_message(i_lang, 'COMMON_T013');
            RAISE l_err_date_begin;
        ELSIF nvl(l_dt_med_tstz, l_dt_admin_tstz) > l_dt_admin_tstz
        THEN
            l_err_msg     := pk_message.get_message(i_lang, 'DISCHARGE_M034');
            l_error_title := pk_message.get_message(i_lang, 'COMMON_T013');
            RAISE l_err_date_begin;
        END IF;
    
        g_error := 'CHECK_DISCHARGE (3)';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.check_discharge(i_lang               => i_lang,
                                            i_prof               => i_prof,
                                            i_episode            => i_episode,
                                            i_can_edt_inact_epis => g_can_edit_inact_epis,
                                            o_error              => o_error)
        THEN
            RAISE pk_discharge.e_check_discharge;
        END IF;
    
        -- lg 2007-03-02 
        IF l_id_disch IS NULL
        THEN
        
            g_error      := 'GET SEQ_DISCHARGE.NEXTVAL';
            l_next_disch := seq_discharge.nextval;
        
            --
            g_error := 'INSERT DISCHARGE';
            INSERT INTO discharge
                (id_discharge,
                 id_disch_reas_dest,
                 id_episode,
                 id_prof_med,
                 dt_med_tstz,
                 notes_med,
                 id_prof_admin,
                 dt_admin_tstz,
                 notes_admin,
                 flg_status,
                 id_discharge_status,
                 flg_type,
                 id_transp_ent_med,
                 id_transp_ent_adm,
                 notes_justify,
                 price,
                 currency,
                 flg_payment,
                 flg_type_disch,
                 flg_status_adm,
                 flg_market)
            
            VALUES
                (l_next_disch,
                 i_reas_dest,
                 i_episode,
                 decode(i_flg_type, g_doctor, i_prof.id, NULL),
                 decode(i_flg_type, g_doctor, l_med_tstz, NULL),
                 decode(i_flg_type, g_doctor, i_notes, NULL),
                 decode(l_flg_end_epis, g_yes, i_prof.id, NULL),
                 decode(l_flg_end_epis, g_yes, l_dt_admin_tstz, NULL),
                 decode(i_flg_type, g_adm, i_notes, NULL),
                 i_flg_status,
                 l_discharge_status,
                 i_disch_type,
                 decode(i_flg_type, g_doctor, i_transp, NULL),
                 decode(i_flg_type, g_adm, i_transp, NULL),
                 i_notes_justify,
                 i_price,
                 i_currency,
                 l_flg_payment,
                 l_flg_type_disch,
                 decode(l_flg_end_epis, g_yes, pk_alert_constant.g_active, NULL),
                 pk_discharge_core.g_disch_type_pt)
            RETURNING id_disch_reas_dest, dt_med_tstz, dt_admin_tstz, flg_status, dt_pend_active_tstz, id_prof_med INTO l_id_disch_reas, l_dt_med_tstz, l_dt_admin_tstz, l_flag_status, l_dt_pend_active_tstz, l_prof_id;
        
            o_id_discharge := l_next_disch;
        ELSE
        
            g_error := 'UPDATE DISCHARGE';
            UPDATE discharge d
               SET id_prof_med         = nvl(id_prof_med, decode(l_flg_type, g_doctor, i_prof.id, NULL)),
                   dt_med_tstz         = nvl(dt_med_tstz, decode(l_flg_type, g_doctor, l_med_tstz, NULL)),
                   notes_med           = nvl(notes_med, decode(l_flg_type, g_doctor, i_notes, NULL)),
                   dt_admin_tstz       = nvl(decode(l_flg_end_epis, g_yes, l_dt_admin_tstz, NULL), dt_admin_tstz),
                   notes_admin         = nvl(decode(l_flg_type, g_adm, i_notes, NULL), notes_admin),
                   id_prof_admin       = nvl(decode(l_flg_end_epis, g_yes, i_prof.id, NULL), id_prof_admin),
                   id_transp_ent_med   = decode(l_flg_type, g_adm, NULL, i_transp),
                   id_transp_ent_adm   = decode(l_flg_type, g_doctor, NULL, i_transp),
                   price               = i_price,
                   currency            = i_currency,
                   flg_payment         = l_flg_payment,
                   flg_status          = i_flg_status,
                   id_discharge_status = l_discharge_status,
                   -- se activa, actualizar campos de pendente
                   -- se pendente = dt_med, alta medica directa
                   -- José Brito 15/07/2008 O preenchimento destes campos deve ser feito com base no estado anterior da alta.
                   -- Se for pendente e se estiver a ser alterado para activa, actualiza os campos. Caso contrário, mantém o valor.
                   id_prof_pend_active = decode(l_disch_status,
                                                g_disch_flg_pend,
                                                decode(i_flg_status, g_disch_flg_active, i_prof.id, id_prof_pend_active),
                                                id_prof_pend_active),
                   dt_pend_active_tstz = decode(l_disch_status,
                                                g_disch_flg_pend,
                                                decode(i_flg_status,
                                                       g_disch_flg_active,
                                                       l_dt_admin_tstz,
                                                       dt_pend_active_tstz),
                                                dt_pend_active_tstz),
                   flg_status_adm      = decode(l_flg_end_epis, g_yes, pk_alert_constant.g_active, NULL)
            --
             WHERE id_discharge = l_id_disch
            RETURNING id_disch_reas_dest, dt_med_tstz, dt_admin_tstz, flg_status, dt_pend_active_tstz, id_prof_med INTO l_id_disch_reas, l_dt_med_tstz, l_dt_admin_tstz, l_flag_status, l_dt_pend_active_tstz, l_prof_id;
        
            ----------------------------------------------------------------------
            -- valida se é uma alta com instituições de transferência
            g_error := 'GET CURSOR DISCH';
            OPEN c_transf_discharge;
            FETCH c_transf_discharge
                INTO l_flg_inst_transfer, l_dti_concluded;
            g_found := c_transf_discharge %FOUND;
            CLOSE c_transf_discharge;
        
            -- se a alta for activa tem de se desactivar tudo o que tem a ver com a transferência
            IF g_found
               AND l_flg_inst_transfer = g_yes
               AND i_flg_status = g_disch_flg_active
               AND l_dti_concluded = g_no
            THEN
                g_error := 'PK_DISCHARGE_INST.CANCEL_TRANSF_DISCHARGE';
                IF NOT pk_discharge_inst.cancel_transf_discharge(i_lang, i_prof, l_id_disch, o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            END IF;
            ----------------------------------------------------------------------
        
            o_id_discharge := l_id_disch;
        END IF;
    
        -- ALERT-41412: AS (03-06-2011)
        g_error := 'CALL PK_ADVANCED_DIRECTIVES.CANCEL_ADV_DIR_RECURR_PLANS';
        pk_alertlog.log_debug(text => g_error);
        IF NOT pk_advanced_directives.cancel_adv_dir_recurr_plans(i_lang    => i_lang,
                                                                  i_prof    => i_prof,
                                                                  i_patient => l_patient,
                                                                  i_episode => i_episode,
                                                                  o_error   => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        -- END ALERT-41412
    
        g_error := 'SET DISCHARGE_HIST';
        pk_discharge_core.set_discharge_hist(i_prof       => i_prof,
                                             i_discharge  => nvl(l_id_disch, l_next_disch),
                                             i_outd_prev  => pk_alert_constant.g_no,
                                             o_disch_hist => l_id_hist);
    
        -- José Brito 11/02/2009 ALERT-9546
        -- Notes on discharge are currently available only for the registrar profile
        IF i_flg_type = g_adm
           AND i_notes IS NOT NULL
        THEN
            g_error := 'CALL TO CALL_CREATE_NEW_DISCHARGE_NOTES';
            pk_alertlog.log_debug(g_error);
            IF NOT call_create_new_disch_notes(i_lang         => i_lang,
                                               i_prof         => i_prof,
                                               i_id_episode   => i_episode,
                                               i_id_discharge => nvl(l_id_disch, l_next_disch),
                                               i_notes        => i_notes,
                                               i_flg_type     => CASE i_flg_type
                                                                     WHEN g_adm THEN
                                                                      'A'
                                                                     ELSE
                                                                      'D'
                                                                 END,
                                               i_date         => g_sysdate_tstz,
                                               o_error        => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        IF i_flg_status = g_disch_flg_active
        THEN
        
            g_error := 'GET auto_presc_cancel';
            SELECT drd.flg_auto_presc_cancel
              INTO l_auto_presc_cancel
              FROM disch_reas_dest drd
             WHERE drd.id_disch_reas_dest = l_id_disch_reas;
        
            -- if configuration for cancel prescription
            --is active.
            IF (l_auto_presc_cancel = pk_alert_constant.g_yes AND nvl(i_flg_type, l_flg_type) = g_doctor)
            THEN
                g_error := 'CALL pk_medication_api.set_interrupt_medication';
                IF NOT pk_api_pfh_in.set_cancel_presc(i_lang       => i_lang,
                                                      i_prof       => profissional(nvl(l_prof_id, i_prof.id),
                                                                                   i_prof.institution,
                                                                                   i_prof.software),
                                                      i_id_episode => i_episode,
                                                      i_notes      => l_auto_cancel_msg,
                                                      o_error      => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            END IF;
        END IF;
    
        g_error := 'UPDATE EPIS_INFO';
        ts_epis_info.upd(id_episode_in           => i_episode,
                         id_disch_reas_dest_in   => l_id_disch_reas,
                         id_disch_reas_dest_nin  => FALSE,
                         dt_med_tstz_in          => l_dt_med_tstz,
                         dt_med_tstz_nin         => FALSE,
                         dt_admin_tstz_in        => l_dt_admin_tstz,
                         dt_admin_tstz_nin       => FALSE,
                         dt_pend_active_tstz_in  => l_dt_pend_active_tstz,
                         dt_pend_active_tstz_nin => FALSE,
                         flg_dsch_status_in      => l_flag_status,
                         flg_dsch_status_nin     => FALSE,
                         rows_out                => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_INFO',
                                      i_rowids       => l_rowids,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('ID_DISCH_REAS_DEST',
                                                                      'DT_MED_TSTZ',
                                                                      'DT_ADMIN_TSTZ',
                                                                      'DT_PEND_ACTIVE_TSTZ',
                                                                      'FLG_DSCH_STATUS'));
        l_rowids := table_varchar();
    
        -- Actualiza flags
        IF l_flg_type IN (g_doctor, g_adm)
        THEN
            g_error := 'UPDATE EPIS_INFO';
            ts_epis_info.upd(flg_status_in => l_flg_type,
                             where_in      => 'id_episode =' || i_episode || ' AND flg_status != ''' || l_flg_type || '''',
                             rows_out      => l_rowids);
        
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_INFO',
                                          i_rowids       => l_rowids,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('FLG_STATUS'));
        
            l_rowids := table_varchar();
            --
            g_error := 'UPDATE SCHEDULE_OUTP';
            UPDATE schedule_outp
               SET flg_state = l_flg_type
             WHERE id_schedule_outp = (SELECT DISTINCT v.id_schedule_outp
                                         FROM epis_info v
                                        WHERE v.id_episode = i_episode)
               AND flg_state != l_flg_type;
        END IF;
    
        --
        -- Se for uma alta médica, verificar a existência de REGISTOS TEMPORÁRIOS
        --
        IF l_flg_type = g_doctor
        THEN
            --
            IF i_flg_status IN (g_disch_flg_active)
            THEN
                IF i_prof.software IN (g_soft_edis, g_soft_ubu, g_soft_manchester)
                THEN
                    -- Episódio de urgência fica PENDENTE (ET 2007/02/07)
                    g_error := 'UPDATE EPISODE - PENDENTE';
                    ts_episode.upd(id_episode_in  => i_episode,
                                   flg_status_in  => g_epis_pend,
                                   flg_status_nin => FALSE,
                                   rows_out       => l_rowids);
                
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'EPISODE',
                                                  i_rowids       => l_rowids,
                                                  o_error        => o_error,
                                                  i_list_columns => table_varchar('FLG_STATUS'));
                
                    l_rowids := table_varchar();
                
                    IF NOT pk_patient_tracking.set_care_stage_disposition(i_lang, i_prof, i_episode, o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                END IF;
                --
                -- Verifica se o episódio pertence ao bloco operatório (ORIS)
                IF l_epis_type = g_epis_type_oris
                THEN
                    -- Actualiza o estado do paciente.
                    g_error := 'CALL Pk_Sr_Grid.SET_PAT_STATUS';
                    IF NOT pk_sr_grid.call_set_pat_status(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          i_episode        => i_episode,
                                                          i_flg_status_new => 'O',
                                                          i_flg_status_old => NULL,
                                                          i_test           => 'N',
                                                          i_transaction_id => l_transaction_id,
                                                          o_flg_show       => l_aux,
                                                          o_msg_title      => l_aux,
                                                          o_msg_text       => l_aux,
                                                          o_button         => l_aux,
                                                          o_error          => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    -- all open surgical procedures are closed
                    g_error := 'get l_sei_flg_status';
                    BEGIN
                        SELECT sei.id_sr_epis_interv, sei.flg_status
                          BULK COLLECT
                          INTO l_id_sr_epis_interv, l_sei_flg_status
                          FROM sr_epis_interv sei
                         WHERE sei.id_episode_context = i_episode
                           AND sei.flg_status != pk_alert_constant.g_interv_status_cancel;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_sei_flg_status    := table_varchar();
                            l_id_sr_epis_interv := table_number();
                    END;
                
                    FOR i IN 1 .. l_id_sr_epis_interv.count
                    LOOP
                        IF l_sei_flg_status(i) IS NOT NULL
                        THEN
                            g_error := 'call ts_sr_epis_interv.upd';
                            ts_sr_epis_interv.upd(flg_status_in => CASE
                                                                       WHEN l_sei_flg_status(i) = pk_alert_constant.g_interv_status_requisition THEN
                                                                        pk_alert_constant.g_interv_status_finished
                                                                       WHEN l_sei_flg_status(i) = pk_alert_constant.g_interv_status_execution THEN
                                                                        pk_alert_constant.g_interv_status_finished
                                                                       ELSE
                                                                        l_sei_flg_status(i)
                                                                   END,
                                                  where_in      => 'id_sr_epis_interv = ' || l_id_sr_epis_interv(i),
                                                  rows_out      => l_rowids2);
                        
                            g_error := 'call t_data_gov_mnt.process_update';
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'SR_EPIS_INTERV',
                                                          i_rowids     => l_rowids2,
                                                          o_error      => o_error);
                        
                            g_error := 'call pk_sr_output.set_ia_event_prescription';
                            IF NOT pk_sr_output.set_ia_event_prescription(i_lang              => i_lang,
                                                                     i_prof              => i_prof,
                                                                     i_flg_action        => 'U',
                                                                     i_id_sr_epis_interv => l_id_sr_epis_interv(i),
                                                                     i_flg_status_new    => CASE
                                                                                                WHEN l_sei_flg_status(i) =
                                                                                                     pk_alert_constant.g_interv_status_requisition THEN
                                                                                                 pk_alert_constant.g_interv_status_finished
                                                                                                WHEN l_sei_flg_status(i) =
                                                                                                     pk_alert_constant.g_interv_status_execution THEN
                                                                                                 pk_alert_constant.g_interv_status_finished
                                                                                                ELSE
                                                                                                 l_sei_flg_status(i)
                                                                                            END,
                                                                     i_flg_status_old    => l_sei_flg_status(i),
                                                                     o_error             => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        END IF;
                    END LOOP;
                
                    -- change the status in sr_surgery_record to 'completed'
                    IF NOT pk_sr_surg_record.set_surg_process_status(i_lang    => i_lang,
                                                                     i_prof    => i_prof,
                                                                     i_episode => i_episode,
                                                                     i_status  => pk_sr_approval.g_completed_surgery,
                                                                     o_error   => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    SELECT COUNT(*)
                      INTO l_count
                      FROM episode
                     WHERE id_visit = l_visit
                       AND flg_status NOT IN (g_epis_inactive, g_epis_canc);
                
                    IF l_count <= 1
                    THEN
                        --
                        -- Marca a visita como terminada
                        g_error := 'CALL PK_VISIT.SET_VISIT_END';
                        IF NOT pk_visit.set_visit_end(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_prof_cat_type => i_prof_cat_type,
                                                      i_id_visit      => l_visit,
                                                      i_sysdate       => NULL,
                                                      i_sysdate_tstz  => l_dt_admin_tstz,
                                                      o_error         => o_error)
                        THEN
                            RAISE l_internal_error;
                        END IF;
                        -- Alta administrativa, tornar as dietas para o episodio inactivas
                        g_error := 'PK_DIET.SET_DIET_INTERRUPT';
                        IF NOT pk_diet.set_diet_interrupt(i_lang  => i_lang,
                                                          i_prof  => i_prof,
                                                          i_visit => l_visit,
                                                          o_error => o_error)
                        THEN
                            RAISE l_internal_error;
                        END IF;
                    ELSE
                        ts_episode.upd(id_episode_in   => i_episode,
                                       flg_status_in   => g_epis_inactive,
                                       flg_status_nin  => FALSE,
                                       dt_end_tstz_in  => l_dt_admin_tstz,
                                       dt_end_tstz_nin => FALSE,
                                       rows_out        => l_rowids);
                    
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPISODE',
                                                      i_rowids       => l_rowids,
                                                      o_error        => o_error,
                                                      i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
                        l_rowids := table_varchar();
                    
                    END IF;
                END IF;
                IF NOT pk_bmng_pbl.set_episode_bed_status_vacant(i_lang                  => i_lang,
                                                                 i_prof                  => i_prof,
                                                                 i_id_episode            => i_episode,
                                                                 i_transaction_id        => l_transaction_id,
                                                                 i_dt_discharge_schedule => pk_date_utils.date_send_tsz(i_lang,
                                                                                                                        l_dt_med_tstz,
                                                                                                                        i_prof),
                                                                 o_error                 => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                IF NOT pk_bmng_pbl.set_bmng_discharge(i_lang           => i_lang,
                                                      i_prof           => i_prof,
                                                      i_epis           => i_episode,
                                                      i_transaction_id => l_transaction_id,
                                                      o_error          => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
            END IF;
            --
            --jsilva 23-04-2007 o detalhe da alta é só inserido caso se trate de uma alta médica
            -- jsilva 18-05-2007 só insere o detalhe caso a alta ainda não exista
            -- INSERIR DETALHE - DISCHARGE_DETAIL
            --
            IF l_id_disch IS NULL
            THEN
                g_error := 'GET SEQ_DISCHARGE_DETAIL.NEXTVAL';
                SELECT seq_discharge_detail.nextval
                  INTO l_next_detail
                  FROM dual;
                --
                g_error := 'INSERT DISCHARGE_DETAIL';
                INSERT INTO discharge_detail
                    (id_discharge_detail,
                     id_discharge,
                     flg_pat_condition,
                     id_transport_type,
                     id_disch_rea_transp_ent_inst,
                     flg_caretaker,
                     caretaker_notes,
                     flg_follow_up_by,
                     follow_up_notes,
                     follow_up_date_tstz,
                     flg_written_notes,
                     flg_voluntary,
                     flg_pat_report,
                     flg_transfer_form,
                     id_prof_admitting,
                     prof_admitting_desc,
                     id_dep_clin_serv_admiting,
                     dep_clin_serv_admiting_desc,
                     flg_summary_report,
                     flg_autopsy_consent,
                     autopsy_consent_desc,
                     flg_orgn_dntn_info,
                     orgn_dntn_info,
                     flg_examiner_notified,
                     examiner_notified_info,
                     flg_orgn_dntn_form_complete,
                     flg_ama_form_complete,
                     flg_lwbs_form_complete,
                     notes,
                     mse_type,
                     flg_surgery,
                     date_surgery_tstz,
                     flg_print_report,
                     id_transfer_diagnosis,
                     flg_inst_transfer,
                     flg_autopsy,
                     death_process_registration)
                VALUES
                    (l_next_detail,
                     nvl(l_next_disch, l_id_disch),
                     i_flg_pat_condition,
                     i_id_transport_type,
                     i_id_disch_rea_t_ent_inst,
                     i_flg_caretaker,
                     i_caretaker_notes,
                     i_flg_follow_up_by,
                     i_follow_up_notes,
                     pk_date_utils.get_string_tstz(i_lang, i_prof, i_follow_up_date_str, NULL),
                     i_flg_written_notes,
                     i_flg_voluntary,
                     i_flg_pat_report,
                     i_flg_transfer_form,
                     i_id_prof_admitting,
                     i_prof_admitting_desc,
                     i_id_dep_clin_serv_admit,
                     i_dep_clin_serv_ad_desc,
                     i_flg_summary_report,
                     i_flg_autopsy_consent,
                     i_autopsy_consent_desc,
                     i_flg_orgn_dntn_info,
                     i_orgn_dntn_info,
                     i_flg_examiner_notified,
                     i_examiner_notified_info,
                     i_flg_orgn_dntn_f_compl,
                     i_flg_ama_form_complete,
                     i_flg_lwbs_form_complete,
                     i_notes_det,
                     i_mse_type,
                     i_flg_surgery,
                     pk_date_utils.get_string_tstz(i_lang, i_prof, i_date_surgery_str, NULL),
                     i_flg_print_report,
                     i_transfer_diagnosis,
                     i_flg_inst_transfer,
                     i_flg_autopsy,
                     i_death_process_registration);
            END IF;
        
            --Nuno Neves 24/12/2010 (ALERT-151966) 
        
            g_error := 'CHECK REQUEST PRINT REPORT';
            IF NOT pk_api_discharge.check_request_print_report(i_lang,
                                                               i_episode,
                                                               nvl(l_next_disch, l_id_disch),
                                                               i_prof,
                                                               i_currency,
                                                               o_error)
            
            THEN
                RAISE l_internal_error;
            END IF;
        
            --END (ALERT-151966)
        
            -- on medical discharge, set existing INAIL typed CIs to printed
            g_error := 'CALL pk_cit.print_inail';
            pk_cit.print_inail(i_lang => i_lang, i_prof => i_prof, i_patient => l_patient, i_episode => i_episode);
        END IF;
    
        IF l_flg_end_epis = g_yes
        THEN
            -- ALTA ADMINISTRATIVA
            -- ANTES DE ENCERRAR O EPISÓDIO DE URGENCIA EXISTEM ALGUMAS VALIDAÇÕES A TER EM CONTA - CRIAR OU NÃO UM NOVO EPISÓDIO
            -- SE FOR UMA ALTA ADMINISTRATIVA, SE O DESTINO NÃO FOR UM DEPARTAMENTO DA INSTITUIÇÃO, FECHA O EPISÓDIO E A VISITA.
            -- SENÃO, FECHA APENAS O EPISÓDIO
            IF nvl(i_flg_new_epis, g_no) = g_yes
            THEN
                -- NOVO episódio a ser criado: Não se encerra a visita, só se inactiva o episódio
                g_error := 'UPDATE EPISODE - INACTIVE';
                ts_episode.upd(id_episode_in   => i_episode,
                               flg_status_in   => g_epis_inactive,
                               flg_status_nin  => FALSE,
                               dt_end_tstz_in  => l_dt_admin_tstz,
                               dt_end_tstz_nin => FALSE,
                               rows_out        => l_rowids);
            
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPISODE',
                                              i_rowids       => l_rowids,
                                              o_error        => o_error,
                                              i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
            
                l_rowids := table_varchar();
            
            END IF;
        
            FOR r_analysis IN (SELECT ard.id_analysis_req_det, ard.id_analysis_req, ar.id_patient
                                 FROM analysis_req_det ard, analysis_req ar
                                WHERE ar.id_episode = i_episode
                                  AND ard.id_analysis_req = ar.id_analysis_req)
            LOOP
                g_error := 'PK_LAB_TESTS_API_DB.SET_LAB_TEST_GRID_TASK';
                IF NOT pk_lab_tests_api_db.set_lab_test_grid_task(i_lang             => i_lang,
                                                                  i_prof             => i_prof,
                                                                  i_patient          => r_analysis.id_patient,
                                                                  i_episode          => i_episode,
                                                                  i_analysis_req     => r_analysis.id_analysis_req,
                                                                  i_analysis_req_det => r_analysis.id_analysis_req_det,
                                                                  o_error            => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            END LOOP;
        
            FOR r_exam IN (SELECT erd.id_exam_req_det, erd.id_exam_req, erd.id_exam, er.id_episode
                             FROM exam_req_det erd, exam_req er
                            WHERE er.id_episode = i_episode
                              AND erd.id_exam_req = er.id_exam_req)
            LOOP
            
                g_error := 'PK_EXAMS_API_DB.SET_EXAM_GRID_TASK';
                IF NOT pk_exams_api_db.set_exam_grid_task(i_lang         => i_lang,
                                                          i_prof         => i_prof,
                                                          i_patient      => NULL,
                                                          i_episode      => i_episode,
                                                          i_exam_req     => r_exam.id_exam_req,
                                                          i_exam_req_det => r_exam.id_exam_req_det,
                                                          o_error        => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            END LOOP;
        
            --
            --Por exemplo : Alta administrativa sobre um episódio de urgência.
            --               Verificar se este episódio tem um episódio de destino de OBS,
            --               se sim, o episódio de OBS fica com a FLG_TYPE=D (Definitivo)
        
            g_error := 'OPEN C_EPISODE_INP';
            OPEN c_episode_inp;
            FETCH c_episode_inp
                INTO l_episode_inp;
            CLOSE c_episode_inp;
            --
            -- Verificar se o MOTIVO da alta obriga a criação de um novo episódio noutra instituição
            --
            g_error := 'OPEN CURSOR C_DISCH_REASON';
            OPEN c_disch_reason;
            FETCH c_disch_reason
                INTO l_new_epis_type, l_type_screen, l_type_new_epis, l_institution;
            CLOSE c_disch_reason;
            --
            IF l_episode_inp IS NOT NULL --TEM UM EPISODIO DESTINO
            THEN
                g_error  := 'UPDATE EPISODE - DEFINITIVO';
                l_rowids := table_varchar();
                ts_episode.upd(id_episode_in => l_episode_inp,
                               flg_type_in   => g_epis_flg_type_d,
                               flg_type_nin  => FALSE,
                               rows_out      => l_rowids_aux);
            
                l_rowids := l_rowids MULTISET UNION DISTINCT l_rowids_aux;
            
                g_error := 'UPDATE EPISODE URG- INACTIVO';
                ts_episode.upd(id_episode_in   => i_episode,
                               flg_status_in   => g_epis_inactive,
                               flg_status_nin  => FALSE,
                               dt_end_tstz_in  => l_dt_admin_tstz,
                               dt_end_tstz_nin => FALSE,
                               rows_out        => l_rowids_aux);
            
                l_rowids := l_rowids MULTISET UNION DISTINCT l_rowids_aux;
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPISODE',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            
                l_rowids := table_varchar();
            ELSE
                IF l_new_epis_type IS NOT NULL
                   AND l_institution IS NOT NULL
                THEN
                    g_error := 'discharge_to_new_institution';
                    IF NOT discharge_to_new_institution(i_lang,
                                                        i_prof,
                                                        i_episode,
                                                        l_patient,
                                                        l_institution,
                                                        l_new_epis_type,
                                                        g_sysdate,
                                                        g_sysdate_tstz,
                                                        i_prof_cat_type,
                                                        l_transaction_id,
                                                        o_id_episode,
                                                        o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                    NULL;
                END IF;
                --
                SELECT COUNT(*)
                  INTO l_count
                  FROM episode
                 WHERE id_visit = l_visit
                   AND flg_status NOT IN (g_epis_inactive, g_epis_canc);
            
                IF l_count <= 1
                   AND nvl(i_flg_new_epis, g_yes) = g_no
                   AND nvl(l_type_new_epis, g_no) NOT IN (g_flg_temp, g_flg_def)
                THEN
                    g_error := 'CALL Pk_Visit.SET_VISIT_END';
                    IF NOT pk_visit.set_visit_end(i_lang          => i_lang,
                                                  i_prof          => i_prof,
                                                  i_prof_cat_type => i_prof_cat_type,
                                                  i_id_visit      => l_visit,
                                                  i_sysdate       => NULL,
                                                  i_sysdate_tstz  => l_dt_admin_tstz,
                                                  o_error         => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                    -- Alta administrativa, tornar as dietas para o episodio inactivas
                    g_error := 'PK_DIET.SET_DIET_INTERRUPT';
                    IF NOT pk_diet.set_diet_interrupt(i_lang  => i_lang,
                                                      i_prof  => i_prof,
                                                      i_visit => l_visit,
                                                      o_error => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                ELSE
                    ts_episode.upd(id_episode_in   => i_episode,
                                   flg_status_in   => g_epis_inactive,
                                   flg_status_nin  => FALSE,
                                   dt_end_tstz_in  => l_dt_admin_tstz,
                                   dt_end_tstz_nin => FALSE,
                                   rows_out        => l_rowids);
                
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'EPISODE',
                                                  i_rowids       => l_rowids,
                                                  o_error        => o_error,
                                                  i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
                
                    l_rowids := table_varchar();
                END IF;
            
                g_error := 'DELETE EPIS WAITING ALERT';
                IF NOT pk_edis_triage.set_alert_triage(i_lang,
                                                       i_prof,
                                                       i_episode,
                                                       g_sysdate_tstz,
                                                       pk_edis_triage.g_alert_waiting,
                                                       pk_edis_triage.g_type_rem,
                                                       o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            END IF;
            --
            -- Alta administrativa de um episódio de OBS, por exemplo, verificar se existe alta adminstrativa do episódio prévio,
            -- No caso de não existir, será inactivado o episódio de origem, por exemplo urgência
            g_error := 'OPEN C_PREV_EPISODE';
            OPEN c_prev_episode;
            FETCH c_prev_episode
                INTO l_prev_episode;
            CLOSE c_prev_episode;
            --
            IF l_prev_episode IS NOT NULL
            THEN
                g_error := 'CALL set_epis_discharge';
                IF NOT set_epis_discharge_no_commit(i_lang                    => i_lang,
                                                    i_episode                 => l_prev_episode,
                                                    i_prof                    => i_prof,
                                                    i_prof_cat_type           => g_adm_cat,
                                                    i_flg_new_epis            => g_no,
                                                    i_reas_dest               => NULL,
                                                    i_disch_type              => g_disch_type_f,
                                                    i_flg_type                => g_adm,
                                                    i_notes                   => pk_message.get_message(i_lang,
                                                                                                        i_prof,
                                                                                                        'EDIS_ADM_AUTO_DISCH'),
                                                    i_notes_det               => NULL,
                                                    i_transp                  => NULL,
                                                    i_notes_justify           => NULL,
                                                    i_flg_pat_condition       => NULL,
                                                    i_id_transport_type       => NULL,
                                                    i_id_disch_rea_t_ent_inst => NULL,
                                                    i_flg_caretaker           => NULL,
                                                    i_caretaker_notes         => NULL,
                                                    i_flg_follow_up_by        => NULL,
                                                    i_follow_up_notes         => NULL,
                                                    i_follow_up_date_str      => NULL,
                                                    i_flg_written_notes       => NULL,
                                                    i_flg_voluntary           => NULL,
                                                    i_flg_pat_report          => NULL,
                                                    i_flg_transfer_form       => NULL,
                                                    i_id_prof_admitting       => NULL,
                                                    i_prof_admitting_desc     => NULL,
                                                    i_id_dep_clin_serv_admit  => NULL,
                                                    i_dep_clin_serv_ad_desc   => NULL,
                                                    i_flg_summary_report      => NULL,
                                                    i_flg_autopsy_consent     => NULL,
                                                    i_autopsy_consent_desc    => NULL,
                                                    i_flg_orgn_dntn_info      => NULL,
                                                    i_orgn_dntn_info          => NULL,
                                                    i_flg_examiner_notified   => NULL,
                                                    i_examiner_notified_info  => NULL,
                                                    i_flg_orgn_dntn_f_compl   => NULL,
                                                    i_flg_ama_form_complete   => NULL,
                                                    i_flg_lwbs_form_complete  => NULL,
                                                    i_price                   => NULL,
                                                    i_currency                => NULL,
                                                    i_flg_payment             => NULL,
                                                    i_flg_status              => g_disch_flg_active,
                                                    i_mse_type                => NULL,
                                                    i_flg_surgery             => NULL,
                                                    i_date_surgery_str        => NULL,
                                                    i_flg_print_report        => NULL,
                                                    i_transaction_id          => l_transaction_id,
                                                    i_transfer_diagnosis      => i_transfer_diagnosis,
                                                    i_flg_inst_transfer       => i_flg_inst_transfer,
                                                    i_dt_admin                => i_dt_admin,
                                                    i_flg_autopsy             => NULL,
                                                    o_flg_show                => l_flg_show,
                                                    o_msg_title               => l_msg_title,
                                                    o_msg_text                => l_msg_text,
                                                    o_button                  => l_button,
                                                    o_id_episode              => l_id_episode,
                                                    o_id_discharge            => l_id_discharge,
                                                    o_error                   => o_error)
                THEN
                    RETURN FALSE; -- o_error can contain user error messages so function must end now
                END IF;
                --
                g_error := 'UPDATE EPISODE - PREV_EPISODE';
                /* <DENORM Fábio> */
                l_rowids := table_varchar();
                ts_episode.upd(id_episode_in   => l_prev_episode,
                               dt_end_tstz_in  => l_dt_admin_tstz,
                               dt_end_tstz_nin => FALSE,
                               flg_status_in   => g_epis_inactive,
                               rows_out        => l_rowids);
            
                t_data_gov_mnt.process_update(i_lang,
                                              i_prof,
                                              'EPISODE',
                                              l_rowids,
                                              o_error,
                                              table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
            
                --l_rowids := table_varchar();
            END IF;
            --
            -- Enquanto não existir alta administrativa a cama não é disponibilizada. Esta função coloca a cama disponivel
            g_error := 'CALL pk_bmng_pbl.set_episode_bed_status_vacant';
            IF NOT pk_bmng_pbl.set_episode_bed_status_vacant(i_lang                  => i_lang,
                                                             i_prof                  => i_prof,
                                                             i_id_episode            => i_episode,
                                                             i_transaction_id        => l_transaction_id,
                                                             i_dt_discharge_schedule => pk_date_utils.date_send_tsz(i_lang,
                                                                                                                    l_dt_med_tstz,
                                                                                                                    i_prof),
                                                             o_error                 => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            g_error := 'CALL pk_bmng_pbl.set_bmng_discharge';
            IF NOT pk_bmng_pbl.set_bmng_discharge(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_epis           => i_episode,
                                                  i_transaction_id => l_transaction_id,
                                                  o_error          => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
        END IF;
    
        IF l_flg_type = g_adm
        THEN
        
            g_error := 'CALL pk_activity_therapist.set_discharge_adm with id_episode: ' || i_episode;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_activity_therapist.set_discharge_adm(i_lang       => i_lang,
                                                           i_prof       => i_prof,
                                                           i_id_episode => i_episode,
                                                           o_error      => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        -- physician discharge   
        IF ((l_flg_type = g_doctor) OR (l_flg_type IS NULL AND i_prof_cat_type = g_doctor))
        THEN
            ---- in inp episodes with an associated activity therapy episode
            -- if there is loaned suplies when discharging the patient an alert is sent to the activity therapist.
            g_error := 'CALL pk_activity_therapist.set_discharge_phy';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_activity_therapist.set_discharge_phy(i_lang       => i_lang,
                                                           i_prof       => i_prof,
                                                           i_id_episode => i_episode,
                                                           o_error      => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        --
        --Actualiza dados das observações
        -- José Brito 14/11/2008 ALERT-8235
        -- Chamada à SET_FIRST_OBS é feita no fim e com a data atribuída no início da função,
        -- para não haver o risco da DT_FIRST_OBS ser superior à data de alta médica.
        g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => l_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'CALL TO REMOVE ALL EXISTING PRINT JOBS IN THE PRINTING LIST';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.cancel_disch_print_jobs(i_lang               => i_lang,
                                                    i_prof               => i_prof,
                                                    i_patient            => l_patient,
                                                    i_episode            => i_episode,
                                                    o_id_print_list_jobs => l_id_print_list_jobs,
                                                    o_error              => o_error)
        THEN
            RAISE l_cancel_print_jobs_excpt;
        END IF;
        --
        IF i_transaction_id IS NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
    
        RETURN TRUE;
        --
    EXCEPTION
        WHEN pk_discharge.e_check_discharge THEN
            pk_alertlog.log_error(text            => 'pk_discharge.e_check_discharge',
                                  object_name     => 'PK_DISCHARGE',
                                  sub_object_name => 'set_epis_discharge_no_commit',
                                  owner           => 'ALERT');
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN l_cancel_print_jobs_excpt THEN
        
            pk_alertlog.log_error(text            => 'l_cancel_print_jobs_excpt',
                                  object_name     => 'PK_DISCHARGE',
                                  sub_object_name => 'set_epis_discharge_no_commit',
                                  owner           => 'ALERT');
        
            pk_alert_exceptions.reset_error_state();
            pk_utils.undo_changes; -- ROLLBACK
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
        WHEN l_err_date_begin THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   'DISCHARGE_M020',
                                   l_err_msg,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_EPIS_DISCHARGE_NO_COMMIT',
                                   NULL,
                                   'U',
                                   l_error_title);
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                pk_alert_exceptions.reset_error_state;
                RETURN FALSE;
            END;
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_EPIS_DISCHARGE_NO_COMMIT',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_EPIS_DISCHARGE_NO_COMMIT',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
    END set_epis_discharge_no_commit;
    --
    /********************************************************************************************
    * Verificar, antes de realizar a alta médica, se existem:Medicamentos
    *                                                        Procedimentos
    *                                                        Análisis
    *                                                        Exames
    * para concluir.
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param i_episode               episode id
    * @param i_flg_mcdt              Apresenta a concatenação de determinados valores: A - Analysis;D - Drugs; I - Intervention; 
                                                                                       E - Exam
                                                                   Ex: |A|D|I|E|                                                                                                                                         
    * @param o_flg_show_msg          Flag: Y - existe msg para mostrar; N - ñ existe  
    * @param o_msg                   Mensagem a mostrar
    * @param o_msg_title             Título da mensagem
    * @param o_button                Botões a mostrar: R - lido 
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         05-02-2007
    ********************************************************************************************/
    FUNCTION check_discharge
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_flg_mcdt     IN disch_reas_dest.flg_mcdt%TYPE,
        o_flg_show_msg OUT VARCHAR2,
        o_msg          OUT VARCHAR2,
        o_msg_title    OUT VARCHAR2,
        o_button       OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_check_analysis IS
            SELECT COUNT(*)
              FROM lab_tests_ea lte
             WHERE lte.id_episode = i_episode
               AND lte.flg_status_det NOT IN (pk_alert_constant.g_analysis_det_result,
                                              pk_alert_constant.g_analysis_det_read,
                                              pk_alert_constant.g_analysis_det_canc,
                                              pk_lab_tests_constant.g_analysis_draft);
    
        CURSOR c_check_exam(l_flg_type exams_ea.flg_type%TYPE) IS
            SELECT COUNT(*)
              FROM exams_ea eea
             WHERE eea.id_episode = i_episode
               AND eea.flg_type = l_flg_type
               AND eea.flg_status_det NOT IN (pk_alert_constant.g_exam_det_performed,
                                              pk_alert_constant.g_exam_det_result,
                                              pk_alert_constant.g_exam_det_read,
                                              pk_alert_constant.g_exam_det_canc,
                                              pk_exam_constant.g_exam_draft);
    
        CURSOR c_check_interv IS
            SELECT COUNT(*)
              FROM procedures_ea pea
             WHERE pea.id_episode = i_episode
               AND pea.flg_time NOT IN (pk_procedures_constant.g_flg_time_a, pk_procedures_constant.g_flg_time_h)
               AND pea.flg_status_det NOT IN (pk_alert_constant.g_interv_det_fin,
                                              pk_alert_constant.g_interv_det_inter,
                                              pk_alert_constant.g_interv_det_cancel,
                                              pk_procedures_constant.g_interv_draft,
                                              pk_procedures_constant.g_interv_expired);
    
        l_check_count NUMBER := 0;
    
        l_analysis    sys_message.desc_message%TYPE;
        l_exam        sys_message.desc_message%TYPE;
        l_drug_fluids sys_message.desc_message%TYPE;
        l_interv      sys_message.desc_message%TYPE;
    
        l_message VARCHAR2(4000) := NULL;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        o_flg_show_msg := 'N';
    
        -- obrigatoriedade de concluir as analises
        IF instr(i_flg_mcdt, g_analysis) > 0
        THEN
            OPEN c_check_analysis;
            FETCH c_check_analysis
                INTO l_check_count;
            CLOSE c_check_analysis;
        
            IF l_check_count > 0
            THEN
                l_analysis := REPLACE(pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M008'), '@1', l_check_count) || '; ';
                l_message  := l_message || l_analysis;
            END IF;
        
        END IF;
    
        -- obrigatoriedade de concluir exames de imagem
        IF instr(i_flg_mcdt, g_exam) > 0
        THEN
            OPEN c_check_exam('I');
            FETCH c_check_exam
                INTO l_check_count;
            CLOSE c_check_exam;
        
            IF l_check_count > 0
            THEN
                l_exam    := REPLACE(pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M009'), '@1', l_check_count) || '; ';
                l_message := l_message || l_exam;
            END IF;
        
            OPEN c_check_exam('E');
            FETCH c_check_exam
                INTO l_check_count;
            CLOSE c_check_exam;
        
            IF l_check_count > 0
            THEN
                l_exam    := REPLACE(pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M001'), '@1', l_check_count) || '; ';
                l_message := l_message || l_exam;
            END IF;
        END IF;
    
        -- obrigatoriedade de concluir a medicação / soros simples
        IF instr(i_flg_mcdt, g_drug) > 0
           OR instr(i_flg_mcdt, g_drug_continuous) > 0
        THEN
            -- José Brito 06/11/2009 ALERT-30828  Also check for requested continuous medication            
            l_check_count := pk_api_pfh_clindoc_in.get_drug_fluids_num(i_lang       => i_lang,
                                                                       i_prof       => i_prof,
                                                                       i_id_episode => i_episode);
        
            IF l_check_count > 0
            THEN
                l_drug_fluids := REPLACE(pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M010'), '@1', l_check_count) || '; ';
                l_message     := l_message || l_drug_fluids;
            END IF;
        END IF;
    
        -- obrigatoriedade de concluir os procedimentos
        IF instr(i_flg_mcdt, g_intervention) > 0
        THEN
            OPEN c_check_interv;
            FETCH c_check_interv
                INTO l_check_count;
            CLOSE c_check_interv;
        
            IF l_check_count > 0
            THEN
                l_interv  := REPLACE(pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M011'), '@1', l_check_count) || '; ';
                l_message := l_message || l_interv;
            END IF;
        END IF;
    
        IF l_message IS NOT NULL
        THEN
            o_flg_show_msg := 'Y';
            o_msg_title    := pk_message.get_message(i_lang, i_prof, 'COMMON_M080');
            o_msg          := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M012') || ' ' ||
                              substr(l_message, 1, length(l_message) - 2) || '.';
            o_button       := 'R';
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CHECK_DISCHARGE',
                                              o_error);
            RETURN FALSE;
    END check_discharge;

    /********************************************************************************************
    * Get the most recent discharge notes, and also all patient complaints and diagnosis.
    * This method is used specifically for the USA market.
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param i_epis                  episode id
    * @param o_complaint             string with all patient complaints
    * @param o_diagnosis             string with all patient diagnosis
    * @param o_disch                 discharge notes
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        José Brito (Based on GET_DISCHARGE_NOTES by Emília Taborda)
    * @version                       1.0  
    * @since                         06-03-2009
    ********************************************************************************************/
    FUNCTION get_discharge_notes
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_epis      IN episode.id_episode%TYPE,
        o_complaint OUT CLOB,
        o_diagnosis OUT VARCHAR2,
        o_disch     OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_flg_status       discharge_notes.flg_status%TYPE;
        l_epis_complaint   CLOB;
        l_epis_diagnosis   discharge_notes.epis_diagnosis%TYPE;
        l_id_disch_notes   discharge_notes.id_discharge_notes%TYPE;
        l_id_pending_issue pending_issue.id_pending_issue%TYPE;
        l_flg_issue_assign discharge_notes.flg_issue_assign%TYPE;
        l_issue_title      pending_issue.title%TYPE;
        l_issue_status     pending_issue.flg_status%TYPE;
        l_current_assignee VARCHAR2(4000);
    
        l_release_from      discharge_notes.release_from%TYPE;
        l_release_from_desc sys_domain.desc_val%TYPE;
    
        l_instr_disc      table_varchar;
        l_instr_disc_desc table_varchar;
    
        l_disch_instr_list table_number;
        l_disch_instr_desc table_varchar;
    
        l_internal_error EXCEPTION;
    BEGIN
        -- Check if exists active discharge notes. Return the most recent record ID.
        g_error := 'CHECK DISCHARGE_NOTES';
        pk_alertlog.log_debug(g_error);
        BEGIN
            SELECT dn.id_discharge_notes,
                   dn.epis_complaint,
                   REPLACE(dn.epis_diagnosis, '''', ''),
                   dn.flg_status,
                   dn.id_pending_issue,
                   dn.flg_issue_assign,
                   dn.release_from
              INTO l_id_disch_notes,
                   l_epis_complaint,
                   l_epis_diagnosis,
                   l_flg_status,
                   l_id_pending_issue,
                   l_flg_issue_assign,
                   l_release_from
              FROM (SELECT id_discharge_notes,
                           id_episode,
                           pk_translation.get_translation_trs(code_epis_complaint) epis_complaint,
                           epis_diagnosis,
                           flg_status,
                           id_pending_issue,
                           flg_issue_assign,
                           release_from,
                           row_number() over(PARTITION BY id_episode ORDER BY dt_creation_tstz DESC) row_number
                      FROM discharge_notes
                     WHERE id_episode = i_epis
                       AND flg_status != g_disch_notes_c
                       AND rownum > 0) dn
             WHERE dn.row_number = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_disch_notes := NULL;
        END;
    
        IF l_id_disch_notes IS NULL -- There are no discharge notes
        THEN
            -- Concatenate all patient's complaints in a string
            g_error     := 'GET COMPLAINT (1)';
            o_complaint := pk_edis_proc.get_epis_anamnesis(i_lang, i_prof, i_epis);
        
            -- Concatenate all patient's diagnosis in a string
            g_error := 'GET DIAGNOSIS (1)';
            pk_alertlog.log_debug(g_error);
            o_diagnosis := pk_edis_proc.get_epis_diag_concat(i_lang, i_epis, i_prof.institution, i_prof.software);
        
            -- There's no discharge notes, so we only open the cursor
            g_error := 'GET O_DISCH (1)';
            pk_alertlog.log_debug(g_error);
            pk_types.open_my_cursor(o_disch);
        
        ELSE
        
            -- GET PENDING ISSUE INFORMATION
            IF l_id_pending_issue IS NOT NULL
            THEN
                BEGIN
                    -- Get the issue title, if issue is not cancelled
                    g_error := 'GET ISSUE TITLE AND STATUS';
                    pk_alertlog.log_debug(g_error);
                    SELECT p.title, p.flg_status
                      INTO l_issue_title, l_issue_status
                      FROM pending_issue p
                     WHERE p.id_pending_issue = l_id_pending_issue
                       AND p.flg_status <> pk_pending_issues.g_issue_flg_status_cancelled;
                
                    -- Get string with the currrent assignee to the pending issue
                    g_error := 'GET ISSUE CURRENT ASSIGNEE';
                    pk_alertlog.log_debug(g_error);
                    l_current_assignee := get_issue_current_assignee(i_lang,
                                                                     i_prof,
                                                                     l_id_disch_notes,
                                                                     l_id_pending_issue,
                                                                     l_flg_issue_assign);
                EXCEPTION
                    WHEN OTHERS THEN
                        l_issue_title      := NULL;
                        l_issue_status     := NULL;
                        l_current_assignee := NULL;
                END;
            END IF;
        
            -- GET "RELEASE FROM" DESCRIPTION
            IF l_release_from IS NOT NULL
            THEN
                g_error := 'GET RELEASE FROM DESCRIPTION';
                pk_alertlog.log_debug(g_error);
                l_release_from_desc := pk_sysdomain.get_domain('DISCHARGE_NOTES.RELEASE_FROM', l_release_from, i_lang);
            END IF;
        
            -- GET "INSTRUCTIONS DISCUSSED WITH" DESCRIPTION           
            g_error := 'CALL PK_DISCHARGE.GET_DN_DISCUSSED_WITH i_discharge_notes: ' || l_id_disch_notes;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_discharge.get_dn_discussed_with(i_lang              => i_lang,
                                                      i_prof              => i_prof,
                                                      i_discharge_notes   => l_id_disch_notes,
                                                      o_dn_discussed      => l_instr_disc,
                                                      o_dn_discussed_desc => l_instr_disc_desc,
                                                      o_error             => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            -- GET "DISCHARGE INSTRUCTIONS LIST" DESCRIPTION           
            g_error := 'CALL PK_DISCHARGE.GET_DN_INSTR_LIST i_discharge_notes: ' || l_id_disch_notes;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_discharge.get_dn_instr_list(i_lang            => i_lang,
                                                  i_prof            => i_prof,
                                                  i_discharge_notes => l_id_disch_notes,
                                                  o_dn_instr        => l_disch_instr_list,
                                                  o_dn_instr_desc   => l_disch_instr_desc,
                                                  o_error           => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            -- Get the discharge notes, by ID
            g_error := 'GET O_DISCH (2)';
            pk_alertlog.log_debug(g_error);
            OPEN o_disch FOR
                SELECT dn.id_discharge_notes, --> Required to get follow-up entities
                       dn.discharge_instructions,
                       l_disch_instr_list disch_instr_list,
                       get_dn_instr_list(i_lang, i_prof, dn.id_discharge_notes) disch_instr_list_desc,
                       dn.release_from,
                       l_release_from_desc desc_release_from,
                       pk_date_utils.date_send_tsz(i_lang, dn.dt_from, i_prof) dt_from,
                       pk_date_utils.date_chr_short_read_tsz(i_lang, dn.dt_from, i_prof) dt_from_f,
                       pk_date_utils.date_send_tsz(i_lang, dn.dt_until, i_prof) dt_until,
                       pk_date_utils.date_chr_short_read_tsz(i_lang, dn.dt_until, i_prof) dt_until_f,
                       dn.notes_release,
                       l_instr_disc instruc_disc,
                       get_dn_discussed_with(i_lang, i_prof, dn.id_discharge_notes) desc_instrc_disc,
                       -- Pending issue information
                       dn.id_pending_issue,
                       dn.flg_issue_assign,
                       l_current_assignee  current_assignee,
                       l_issue_title       issue_title,
                       -- If issue is not cancelled (or doesn't exists), the pending issue fields must be blocked for edition
                       decode(l_issue_status,
                              pk_pending_issues.g_issue_flg_status_cancelled,
                              pk_alert_constant.g_no,
                              NULL,
                              pk_alert_constant.g_no,
                              pk_alert_constant.g_yes) flg_block_issue_create,
                       pk_date_utils.date_char_tsz(i_lang, dn.dt_creation_tstz, i_prof.institution, i_prof.software) dt_reg,
                       pk_prof_utils.get_name_signature(i_lang, i_prof, dn.id_professional) prof_reg,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        dn.id_professional,
                                                        dn.dt_creation_tstz,
                                                        dn.id_episode) spec_reg,
                       dn.flg_csg_patient,
                       pk_sysdomain.get_domain('DISCHARGE_NOTES.FLG_CSG_PATIENT', dn.flg_csg_patient, i_lang) flg_csg_patient_desc,
                       
                       pk_date_utils.date_char_tsz(i_lang, dn.dt_csg_patient, i_prof.institution, i_prof.software) dt_csg_patient_char,
                       pk_date_utils.date_send_tsz(i_lang, dn.dt_csg_patient, i_prof) dt_csg_patient_tsz
                
                  FROM discharge_notes dn
                 WHERE dn.id_discharge_notes = l_id_disch_notes;
        
            -- Set patient's complaint and diagnosis
            IF l_flg_status = g_disch_notes_np -- Notes not printed
            THEN
                g_error := 'GET COMPLAINT (2)';
                pk_alertlog.log_debug(g_error);
                o_complaint := nvl(l_epis_complaint, pk_edis_proc.get_epis_anamnesis(i_lang, i_prof, i_epis));
            
                g_error := 'GET DIAGNOSIS (2)';
                pk_alertlog.log_debug(g_error);
                o_diagnosis := nvl(l_epis_diagnosis,
                                   pk_edis_proc.get_epis_diag_concat(i_lang, i_epis, i_prof.institution, i_prof.software));
            
            ELSE
                -- Notes have been printed, so the information about complaint and diagnosis was already saved in DISCHARGE_NOTES
                o_complaint := to_clob(l_epis_complaint);
                o_diagnosis := l_epis_diagnosis;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_NOTES',
                                              o_error);
            pk_types.open_my_cursor(o_disch);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_discharge_notes;
    --
    /********************************************************************************************
    * Listar todas as notas da alta do episódio
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param i_epis                  episode id
    * @param o_disch                 array with info discharge
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         10-10-2006
    ********************************************************************************************/
    FUNCTION get_all_discharge_notes
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        i_epis  IN episode.id_episode%TYPE,
        o_disch OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_csg_pat_dom sys_domain.code_domain%TYPE := 'DISCHARGE_NOTES.FLG_CSG_PATIENT';
    BEGIN
        g_error := 'GET CURSOR O_DISCH';
        OPEN o_disch FOR
            SELECT dn.id_discharge_notes,
                   dn.id_professional,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, dn.id_professional) prof_name,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    dn.id_professional,
                                                    dn.dt_creation_tstz,
                                                    dn.id_episode) desc_spec,
                   dn.flg_status status_discharge,
                   decode(dn.flg_status,
                          g_disch_notes_np,
                          pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M001'),
                          g_disch_notes_p,
                          pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M002'),
                          g_disch_notes_c,
                          pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M003')) desc_status,
                   pk_date_utils.dt_chr_tsz(i_lang, dn.dt_creation_tstz, i_prof) date_target,
                   pk_date_utils.date_char_hour_tsz(i_lang, dn.dt_creation_tstz, i_prof.institution, i_prof.software) hour_target,
                   pk_date_utils.date_char_tsz(i_lang, dn.dt_creation_tstz, i_prof.institution, i_prof.software) dt_reg,
                   pk_date_utils.date_send_tsz(i_lang, dn.dt_creation_tstz, i_prof) dt_creation,
                   dn.epis_diagnosis,
                   pk_translation.get_translation(i_lang, et.code_epis_type) intern_name_epis_type,
                   pk_date_utils.date_char_tsz(i_lang, dn.dt_csg_patient, i_prof.institution, i_prof.software) dt_csg_patient_char,
                   pk_sysdomain.get_domain(i_code_dom => l_csg_pat_dom, i_val => dn.flg_csg_patient, i_lang => i_lang) flg_csg_patient_desc
              FROM discharge_notes dn, episode epis, epis_type et
             WHERE dn.id_episode = epis.id_episode
               AND dn.id_episode = i_epis
               AND epis.id_epis_type = et.id_epis_type
             ORDER BY pk_sysdomain.get_rank(i_lang, g_disch_n_status, dn.flg_status), dn.dt_creation_tstz DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_ALL_DISCHARGE_NOTES',
                                              o_error);
            pk_types.open_my_cursor(o_disch);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END;
    --
    /********************************************************************************************
    * List the details of discharge notes
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param i_epis                  episode id
    * @param i_id_disch              discharge id
    * @param o_disch                 array with info discharge detail
    * @param o_follow_up             follow-up info
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         10-10-2006
    *
    * @alter                         José Brito
    * @version                       1.1
    * @since                         06-03-2009
    *
    ********************************************************************************************/
    FUNCTION get_discharge_notes_det
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_epis      IN episode.id_episode%TYPE,
        i_id_disch  IN discharge_notes.id_discharge_notes%TYPE,
        o_disch     OUT pk_types.cursor_type,
        o_follow_up OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_count NUMBER(6);
        l_internal_error EXCEPTION;
    BEGIN
        g_error := 'GET CURSOR O_DISCH';
        pk_alertlog.log_debug(g_error);
        OPEN o_disch FOR
            SELECT -- JIRA EMR-78 dn.epis_complaint,
             pk_translation.get_translation_trs(dn.code_epis_complaint) epis_complaint,
             dn.epis_diagnosis,
             dn.release_from,
             pk_sysdomain.get_domain('DISCHARGE_NOTES.RELEASE_FROM', dn.release_from, i_lang) desc_release_from,
             pk_date_utils.date_send_tsz(i_lang, dn.dt_from, i_prof) dt_form,
             pk_date_utils.date_chr_short_read_tsz(i_lang, dn.dt_from, i_prof.institution, i_prof.software) dt_from_f,
             pk_date_utils.date_send_tsz(i_lang, dn.dt_until, i_prof) dt_until,
             pk_date_utils.date_chr_short_read_tsz(i_lang, dn.dt_until, i_prof.institution, i_prof.software) dt_until_f,
             dn.notes_release,
             NULL instructions_discussed,
             pk_discharge.get_dn_discussed_with(i_lang, i_prof, dn.id_discharge_notes) desc_instrc_disc,
             dn.discharge_instructions,
             dn.flg_status,
             get_issue_current_assignee(i_lang, i_prof, dn.id_discharge_notes, dn.id_pending_issue, dn.flg_issue_assign) current_assignee,
             pi.title issue_title,
             pk_sysdomain.get_domain('DISCHARGE_NOTES.FLG_CSG_PATIENT', dn.flg_csg_patient, i_lang) flg_csg_patient_desc,
             pk_date_utils.date_char_tsz(i_lang, dn.dt_csg_patient, i_prof.institution, i_prof.software) dt_csg_patient_tsz
              FROM discharge_notes dn, pending_issue pi
             WHERE dn.id_discharge_notes = i_id_disch
               AND pi.id_pending_issue(+) = dn.id_pending_issue
               AND dn.id_episode = i_epis;
    
        -- José Brito 06/03/2009 ALERT-10317
        -- Get follow-up entities
        g_error := 'GET FOLLOW-UP COUNT';
        pk_alertlog.log_debug(g_error);
        SELECT COUNT(*)
          INTO l_count
          FROM discharge_notes_follow_up d
         WHERE d.id_discharge_notes = i_id_disch;
    
        IF l_count > 0
        THEN
        
            g_error := 'OPEN FOLLOW-UP CURSOR (1)';
            pk_alertlog.log_debug(g_error);
            IF NOT get_follow_up_with_list(i_lang           => i_lang,
                                           i_prof           => i_prof,
                                           i_id_disch_notes => i_id_disch,
                                           o_follow_up_with => o_follow_up,
                                           o_error          => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
        ELSE
            g_error := 'OPEN FOLLOW-UP CURSOR (2)';
            pk_alertlog.log_debug(g_error);
            pk_types.open_my_cursor(o_follow_up);
        END IF;
    
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_NOTES_DET',
                                              o_error);
            pk_types.open_my_cursor(o_disch);
            pk_types.open_my_cursor(o_follow_up);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_NOTES_DET',
                                              o_error);
            pk_types.open_my_cursor(o_disch);
            pk_types.open_my_cursor(o_follow_up);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_discharge_notes_det;

    /********************************************************************************************
    * A mix of GET_ALL_DISCHARGE_NOTES with GET_DISCHARGE_NOTES_DET for CARE.
    * Adapted from those functions.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_epis                  episode identifier
    * @param o_notes                 detail of all discharge instructions
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         09/04/2009
    *
    ********************************************************************************************/
    FUNCTION get_all_dis_notes_care
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        i_epis  IN episode.id_episode%TYPE,
        o_notes OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_na    CONSTANT VARCHAR2(2 CHAR) := '--';
        l_colon CONSTANT VARCHAR2(1 CHAR) := ':';
        l_cs_desc               pk_translation.t_desc_translation;
        l_msg_m027              sys_message.desc_message%TYPE;
        l_msg_m028              sys_message.desc_message%TYPE;
        lbl_epis_complaint      sys_message.desc_message%TYPE;
        lbl_epis_diagnosis      sys_message.desc_message%TYPE;
        lbl_desc_release_from   sys_message.desc_message%TYPE;
        lbl_recommended         sys_message.desc_message%TYPE;
        lbl_desc_follow_up_with sys_message.desc_message%TYPE;
        lbl_follow_up_in        sys_message.desc_message%TYPE;
        lbl_desc_instrc_disc    sys_message.desc_message%TYPE;
    BEGIN
        g_error   := 'CALL pk_episode.get_cs_desc';
        l_cs_desc := pk_episode.get_cs_desc(i_lang => i_lang, i_prof => i_prof, i_episode => i_epis);
    
        g_error                 := 'sys_message retrieval';
        lbl_epis_complaint      := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M004');
        lbl_epis_diagnosis      := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M005');
        lbl_desc_release_from   := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M009');
        lbl_recommended         := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_T023');
        lbl_desc_follow_up_with := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M024');
        lbl_follow_up_in        := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M025');
        lbl_desc_instrc_disc    := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M022');
        l_msg_m027              := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M027') || ' ';
        l_msg_m028              := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_NOTES_M028') || ' ';
    
        g_error := 'OPEN o_notes';
        OPEN o_notes FOR
            SELECT l_cs_desc cons_type,
                   cont_type,
                   prof_name,
                   reg_date,
                   CASE
                        WHEN epis_complaint IS NOT NULL
                             OR epis_diagnosis IS NOT NULL
                             OR desc_release_from IS NOT NULL
                             OR desc_follow_up_with IS NOT NULL
                             OR follow_up_in IS NOT NULL
                             OR desc_instrc_disc IS NOT NULL THEN
                         table_varchar(lbl_epis_complaint,
                                       nvl(epis_complaint, l_na),
                                       lbl_epis_diagnosis,
                                       nvl(epis_diagnosis, l_na),
                                       lbl_desc_release_from || l_colon,
                                       nvl(desc_release_from || decode(dt, ' (', '', dt), l_na),
                                       lbl_recommended || l_colon,
                                       nvl(discharge_instructions, l_na),
                                       lbl_desc_follow_up_with,
                                       nvl(desc_follow_up_with, l_na),
                                       lbl_follow_up_in,
                                       nvl(follow_up_in, l_na),
                                       lbl_desc_instrc_disc,
                                       nvl(desc_instrc_disc, l_na))
                        ELSE
                         table_varchar(lbl_recommended || l_colon, discharge_instructions)
                    END notes,
                   lbl_epis_complaint label_epis_complaint,
                   epis_complaint,
                   lbl_epis_diagnosis label_epis_diagnosis,
                   epis_diagnosis,
                   lbl_desc_release_from label_desc_release_from,
                   decode(desc_release_from, NULL, '', desc_release_from || decode(dt, ' (', '', dt)) desc_release_from,
                   lbl_recommended label_recommended,
                   discharge_instructions,
                   lbl_desc_follow_up_with label_desc_follow_up_with,
                   desc_follow_up_with,
                   lbl_follow_up_in label_follow_up_in,
                   follow_up_in,
                   lbl_desc_instrc_disc label_desc_instrc_disc,
                   desc_instrc_disc
              FROM (SELECT pk_translation.get_translation(i_lang, et.code_epis_type) cont_type,
                           pk_tools.get_prof_description(i_lang, i_prof, dn.id_professional, dn.dt_creation_tstz, i_epis) prof_name,
                           pk_date_utils.date_char_tsz(i_lang, dn.dt_creation_tstz, i_prof.institution, i_prof.software) reg_date,
                           dn.epis_complaint,
                           dn.epis_diagnosis,
                           pk_sysdomain.get_domain('DISCHARGE_NOTES.RELEASE_FROM', dn.release_from, i_lang) desc_release_from,
                           ' (' ||
                           decode(dn.dt_from,
                                  NULL,
                                  NULL,
                                  l_msg_m027 || pk_date_utils.dt_chr_tsz(i_lang, dn.dt_from, i_prof) || ' ') ||
                           decode(dn.dt_until,
                                  NULL,
                                  NULL,
                                  l_msg_m028 || pk_date_utils.dt_chr_tsz(i_lang, dn.dt_until, i_prof) || ')') dt,
                           dn.discharge_instructions,
                           pk_prof_utils.get_name_signature(i_lang, i_prof, dn.follow_up_with) desc_follow_up_with,
                           decode(dn.id_follow_up_type,
                                  NULL,
                                  NULL,
                                  g_follow_up_date,
                                  nvl(pk_date_utils.date_char_tsz(i_lang,
                                                                  pk_date_utils.get_string_tstz(i_lang,
                                                                                                i_prof,
                                                                                                dn.follow_up_in,
                                                                                                NULL),
                                                                  i_prof.institution,
                                                                  i_prof.software),
                                      dn.follow_up_in),
                                  g_follow_up_days,
                                  pk_string_utils.concat_if_exists(dn.follow_up_in,
                                                                   pk_translation.get_translation(i_lang,
                                                                                                  'FOLLOW_UP_TYPE.CODE_UNITS.' ||
                                                                                                  dn.id_follow_up_type),
                                                                   ' '),
                                  g_follow_up_sos,
                                  dn.follow_up_in) follow_up_in,
                           pk_discharge.get_dn_discussed_with(i_lang, i_prof, dn.id_discharge_notes) desc_instrc_disc
                      FROM discharge_notes dn
                      JOIN episode e
                        ON dn.id_episode = e.id_episode
                      JOIN epis_type et
                        ON e.id_epis_type = et.id_epis_type
                     WHERE dn.id_episode = i_epis
                     ORDER BY dn.dt_creation_tstz DESC);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_ALL_DIS_NOTES_CARE',
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_notes);
            RETURN FALSE;
    END get_all_dis_notes_care;

    --

    /********************************************************************************************
    * Insert discharge notes, follow-up entities
    * and manages pending issues related to discharge instructions.
    *
    * @param i_lang                    language id
    * @param i_prof                    Professional, software and institution ids
    * @param i_prof_cat_type           Professional category
    * @param i_epis                    Episode id
    * @param i_patient                 Patient id
    * @param i_id_disch                Discharge notes id
    * @param i_epis_complaint          Patient complaint
    * @param i_epis_diagnosis          Patient diagnosis
    * @param i_recommended             Recommendations for patient 
    * @param i_discharge_instr_list    Discharge instructions DEFAULT NULL   
    * @param i_release_from            Release from work or school
    * @param i_dt_from                 Release from this date...
    * @param i_dt_until                ...until this date
    * @param i_notes_release           Release notes
    * @param i_instructions_discussed  Instructions discussed with...
    * @param i_follow_up_with          Follow-up entities ID (can be a physician, external physician or external institution)
    * @param i_follow_up_in            Array of dates or number of days from which the patient must be followed-up
    * @param i_id_follow_up_type       Array of type of follow-up: D - Date; DY - Days; S - SOS
    * @param i_flg_follow_up_with      Follow-up with: (OC) on-call physician (PH) external physician
                                                       (CL) clinic (OF) office (O) other (free text specified in 'i_follow_up_text')
    * @param i_follow_up_text          Specified follow-up entity, with free text, if 'i_flg_follow_up_with' is 'O'
    * @param i_follow_up_notes         Specific notes for follow-up
    * @param i_issue_assignee         Selected assignee(s) in the multichoice, in the format: P<id> or G<id>
                                       Examples:
                                                P142 (Professional with ID_PROFESSIONAL = 142)
                                                G27  (Group with ID_GROUP = 27)
    * @param i_issue_title             Title for the pending issue
    * @param i_flg_printer             Flag printer: P - Printed
    * @param i_commit_data             Commit date? (Y) Yes (N) No   
    * @param i_sysdate                 record date   
    * @param o_error                   Error message
    *
    * @return                          TRUE if sucess, FALSE otherwise
    *
    * @author                          José Brito
    * @version                         1.0  
    * @since                           2009/03/05
    *
    ********************************************************************************************/
    FUNCTION set_discharge_notes
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_epis          IN episode.id_episode%TYPE,
        i_patient       IN patient.id_patient%TYPE,
        --
        i_id_disch               IN discharge_notes.id_discharge_notes%TYPE,
        i_epis_complaint         IN CLOB,
        i_epis_diagnosis         IN discharge_notes.epis_diagnosis%TYPE,
        i_discharge_instructions IN discharge_notes.discharge_instructions%TYPE,
        i_discharge_instr_list   IN table_number DEFAULT NULL,
        i_release_from           IN discharge_notes.release_from%TYPE,
        i_dt_from                IN VARCHAR2,
        i_dt_until               IN VARCHAR2,
        i_notes_release          IN discharge_notes.notes_release%TYPE,
        i_instructions_discussed IN table_varchar,
        --
        i_follow_up_with     IN table_number,
        i_follow_up_in       IN table_varchar,
        i_id_follow_up_type  IN table_number,
        i_flg_follow_up_type IN follow_up_entity.flg_type%TYPE,
        i_follow_up_text     IN VARCHAR2,
        i_follow_up_notes    IN VARCHAR2,
        --
        i_issue_assignee IN table_varchar,
        i_issue_title    IN pending_issue.title%TYPE,
        --
        i_flg_printer       IN VARCHAR,
        i_commit_data       IN VARCHAR2,
        i_sysdate           IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_csg_patient   IN VARCHAR2,
        i_dt_csg_patient    IN VARCHAR2,
        o_id_discharge_note OUT discharge_notes.id_discharge_notes%TYPE,
        o_reports_pat       OUT reports.id_reports%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_next                discharge_notes.id_discharge_notes%TYPE;
        l_dt_from             TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_until            TIMESTAMP WITH LOCAL TIME ZONE;
        l_rowids              table_varchar;
        l_id_follow_up_entity follow_up_entity.id_follow_up_entity%TYPE;
    
        l_patient patient.id_patient%TYPE;
    
        l_assignee_id       NUMBER(24);
        l_assignee_table    table_number := table_number();
        l_assignee_type     VARCHAR2(1);
        l_assignee_type_aux VARCHAR2(1);
        l_assignee_type_p CONSTANT VARCHAR2(1) := pk_alert_constant.g_disch_issue_assign_p; -- 'P'
        l_assignee_type_g CONSTANT VARCHAR2(1) := pk_alert_constant.g_disch_issue_assign_g; -- 'G'
    
        l_id_pending_issue_old pending_issue.id_pending_issue%TYPE;
        l_flg_issue_assign_old discharge_notes.flg_issue_assign%TYPE;
        l_id_pending_issue_new pending_issue.id_pending_issue%TYPE := NULL;
        l_id_disch_notes       discharge_notes.id_discharge_notes%TYPE;
        l_issue_status         pending_issue.flg_status%TYPE;
    
        l_create_pending_issue BOOLEAN := FALSE;
    
        l_invalid_action      EXCEPTION;
        l_runtime_error       EXCEPTION;
        l_data_error          EXCEPTION;
        l_error_type_assignee EXCEPTION;
        l_wrong_type_assignee BOOLEAN := FALSE;
        l_commit_data         BOOLEAN;
        l_invalid_issue_creation EXCEPTION;
    
        l_id_print_list_jobs table_number := table_number();
        l_cancel_print_jobs_excpt EXCEPTION;
    
        l_dt_csg_patient TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_exist_tanslation_trs     BOOLEAN := FALSE;
        l_tbl_code_translation_trs table_varchar;
    
        l_disch_notes_discussed_tc ts_disch_notes_discussed.disch_notes_discussed_tc;
        l_disch_notes_instr_tc     ts_disch_notes_instr.disch_notes_instr_tc;
    
    BEGIN
        IF i_sysdate IS NULL
        THEN
            g_sysdate      := SYSDATE;
            g_sysdate_tstz := current_timestamp;
        ELSE
            g_sysdate      := i_sysdate;
            g_sysdate_tstz := i_sysdate;
        END IF;
        --
        IF (i_commit_data = pk_alert_constant.g_no)
        THEN
            l_commit_data := FALSE;
        ELSE
            l_commit_data := TRUE;
        END IF;
        --
        g_error := 'CONFIGURE DATES';
        pk_alertlog.log_debug(g_error);
        l_dt_from        := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_from, NULL);
        l_dt_until       := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_until, NULL);
        l_dt_csg_patient := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_csg_patient, NULL);
        --
        -- Check if type of follow-up is valid within the domain
        g_error := 'CHECK DOMAINS';
        pk_alertlog.log_debug(g_error);
        IF NOT
            pk_sysdomain.check_val_in_domain(i_code_domain => 'FOLLOW_UP_ENTITY.FLG_TYPE',
                                             i_val         => nvl(i_flg_follow_up_type, pk_alert_constant.g_followupwith_o))
        THEN
            RAISE l_invalid_action;
        END IF;
        --
    
        IF i_id_disch IS NULL
        THEN
        
            -- Get most recent discharge notes
            g_error := 'GET LAST DISCHARGE_NOTES';
            pk_alertlog.log_debug(g_error);
            BEGIN
                SELECT dn.id_discharge_notes, dn.id_pending_issue, dn.flg_issue_assign
                  INTO l_id_disch_notes, l_id_pending_issue_old, l_flg_issue_assign_old
                  FROM (SELECT id_discharge_notes,
                               id_episode,
                               id_pending_issue,
                               flg_issue_assign,
                               row_number() over(PARTITION BY id_episode ORDER BY dt_creation_tstz DESC) row_number
                          FROM discharge_notes
                         WHERE id_episode = i_epis
                           AND flg_status != g_disch_notes_c
                           AND rownum > 0) dn
                 WHERE row_number = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    --l_id_disch_notes := NULL;
                    NULL;
            END;
        
            ---------------------------------------------------------------------
            -- A) Process information destinated to the patient:
            --    -> Discharge Notes
            --    -> Follow up information
            ---------------------------------------------------------------------
        
            IF i_patient IS NULL
            THEN
                g_error := 'GET PATIENT ID';
                pk_alertlog.log_debug(g_error);
                SELECT e.id_patient
                  INTO l_patient
                  FROM episode e
                 WHERE e.id_episode = i_epis;
            ELSE
                l_patient := i_patient;
            END IF;
        
            g_error := 'GET SEQ_DISCHARGE_NOTES.NEXTVAL';
            pk_alertlog.log_debug(g_error);
            l_next := ts_discharge_notes.next_key();
        
            g_error := 'INSERT DISCHARGE_NOTES';
            pk_alertlog.log_debug(g_error);
            ts_discharge_notes.ins(id_discharge_notes_in     => l_next,
                                   id_episode_in             => i_epis,
                                   id_patient_in             => l_patient,
                                   id_professional_in        => i_prof.id,
                                   dt_creation_tstz_in       => g_sysdate_tstz,
                                   epis_diagnosis_in         => i_epis_diagnosis,
                                   discharge_instructions_in => i_discharge_instructions,
                                   flg_status_in             => g_disch_notes_np,
                                   release_from_in           => i_release_from,
                                   dt_from_in                => l_dt_from,
                                   dt_until_in               => l_dt_until,
                                   notes_release_in          => i_notes_release,
                                   adw_last_update_in        => g_sysdate,
                                   flg_csg_patient_in        => i_flg_csg_patient,
                                   dt_csg_patient_in         => l_dt_csg_patient,
                                   rows_out                  => l_rowids);
        
            --Delete the old records on translation_trs
            BEGIN
                SELECT t.code_translation
                  BULK COLLECT
                  INTO l_tbl_code_translation_trs
                  FROM translation_trs t
                 WHERE t.id_episode = i_epis
                   AND t.table_name = 'DISCHARGE_NOTES'
                   AND t.column_name = 'EPIS_COMPLAINT';
            
                --EMR-78, Removed per request. 
                --pk_translation.delete_code_translation_trs(i_code => l_tbl_code_translation_trs);
            
                l_exist_tanslation_trs := TRUE;
            EXCEPTION
                WHEN no_data_found THEN
                    --l_exist_tanslation_trs := FALSE;
                    NULL;
            END;
        
            --Insert the most recent record on translation_trs
            pk_translation.insert_translation_trs(i_lang         => i_lang,
                                                  i_code         => g_trs_complaint || l_next,
                                                  i_desc         => i_epis_complaint,
                                                  i_module       => 'PFH',
                                                  i_episode      => i_epis,
                                                  i_patient      => l_patient,
                                                  i_professional => i_prof.id,
                                                  i_dt_record    => g_sysdate_tstz,
                                                  i_task_type    => pk_alert_constant.g_task_discharge_instruction);
        
            --Process the events associated to an insert on discharge_notes
            g_error := 'PROCESS INSERT - DISCHARGE NOTES';
            pk_alertlog.log_debug(g_error);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'DISCHARGE_NOTES',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
            -- reset variable
            l_rowids := table_varchar();
        
            --Process discharge instruction list           
            IF i_discharge_instr_list.exists(1)
            THEN
                IF i_discharge_instr_list.count > 0
                THEN
                    g_error := 'GET ALL DISCH_NOTES_INSTR ROW';
                    pk_alertlog.log_debug(g_error);
                    SELECT l_next,
                           t.column_value /*+opt_estimate (table t rows=1)*/,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                      BULK COLLECT
                      INTO l_disch_notes_instr_tc
                      FROM TABLE(i_discharge_instr_list) t;
                
                    g_error := 'INSERT DISCH_NOTES_INSTR ROW';
                    pk_alertlog.log_debug(g_error);
                    ts_disch_notes_instr.ins(rows_in         => l_disch_notes_instr_tc,
                                             handle_error_in => TRUE,
                                             rows_out        => l_rowids);
                
                    g_error := 'PROCESS INSERT - DISCH_NOTES_INSTR';
                    pk_alertlog.log_debug(g_error);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'DISCH_NOTES_INSTR',
                                                  i_rowids     => l_rowids,
                                                  o_error      => o_error);
                END IF;
            END IF;
        
            -- reset variable
            l_rowids := table_varchar();
        
            --Process instructions discussed with            
            IF i_instructions_discussed.exists(1)
               AND i_instructions_discussed(1) IS NOT NULL
            THEN
                IF i_instructions_discussed.count > 0
                THEN
                    g_error := 'GET ALL DISCH_NOTES_DISCUSSED ROW';
                    pk_alertlog.log_debug(g_error);
                    SELECT l_next,
                           t.column_value /*+opt_estimate (table t rows=1)*/,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                      BULK COLLECT
                      INTO l_disch_notes_discussed_tc
                      FROM TABLE(i_instructions_discussed) t;
                
                    g_error := 'INSERT DISCH_NOTES_DISCUSSED ROW';
                    pk_alertlog.log_debug(g_error);
                    ts_disch_notes_discussed.ins(rows_in         => l_disch_notes_discussed_tc,
                                                 handle_error_in => TRUE,
                                                 rows_out        => l_rowids);
                
                    g_error := 'PROCESS INSERT - DISCH_NOTES_DISCUSSED';
                    pk_alertlog.log_debug(g_error);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'DISCH_NOTES_DISCUSSED',
                                                  i_rowids     => l_rowids,
                                                  o_error      => o_error);
                END IF;
            END IF;
        
            -- reset variable
            l_rowids := table_varchar();
        
            -- Get follow-up entity ID
            BEGIN
                g_error := 'GET FOLLOW-UP ENTITY ID (' || i_flg_follow_up_type || ')';
                pk_alertlog.log_debug(g_error);
                SELECT fue.id_follow_up_entity
                  INTO l_id_follow_up_entity
                  FROM follow_up_entity fue
                 WHERE fue.flg_type = nvl(i_flg_follow_up_type, pk_alert_constant.g_followupwith_o);
            EXCEPTION
                WHEN no_data_found THEN
                    RAISE l_data_error;
            END;
        
            -- Process DISCHARGE_NOTES_FOLLOW_UP
            IF i_flg_follow_up_type = pk_alert_constant.g_followupwith_o
            THEN
                g_error := 'INSERT DISCHARGE_NOTES_FOLLOW_UP (1)';
                pk_alertlog.log_debug(g_error);
                ts_discharge_notes_follow_up.ins(id_discharge_notes_in  => l_next,
                                                 id_follow_up_with_in   => -1,
                                                 id_follow_up_entity_in => l_id_follow_up_entity,
                                                 follow_up_with_text_in => i_follow_up_text,
                                                 id_prof_create_in      => i_prof.id,
                                                 dt_creation_in         => g_sysdate_tstz,
                                                 follow_up_in_in        => i_follow_up_in(1),
                                                 id_follow_up_type_in   => i_id_follow_up_type(1),
                                                 notes_in               => i_follow_up_notes, -- Notes applicable only to free-text follow-up
                                                 rows_out               => l_rowids);
            
                g_error := 'PROCESS INSERT - DISCHARGE_NOTES_FOLLOW_UP (1)';
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'DISCHARGE_NOTES_FOLLOW_UP',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            
                -- reset variable
                l_rowids := table_varchar();
            
            ELSIF i_follow_up_with.exists(1)
            THEN
                -- For other types of follow-up, a new record in DISCHARGE_NOTES_FOLLOW_UP
                -- is created for each follow-up entity
                FOR i IN i_follow_up_with.first .. i_follow_up_with.last
                LOOP
                    IF i_follow_up_with(i) IS NOT NULL
                    THEN
                        g_error := 'INSERT DISCHARGE_NOTES_FOLLOW_UP (2)';
                        pk_alertlog.log_debug(g_error);
                        ts_discharge_notes_follow_up.ins(id_discharge_notes_in  => l_next,
                                                         id_follow_up_with_in   => i_follow_up_with(i),
                                                         id_follow_up_entity_in => l_id_follow_up_entity,
                                                         follow_up_with_text_in => NULL,
                                                         id_prof_create_in      => i_prof.id,
                                                         dt_creation_in         => g_sysdate_tstz,
                                                         follow_up_in_in        => i_follow_up_in(i),
                                                         id_follow_up_type_in   => i_id_follow_up_type(i),
                                                         notes_in               => NULL, -- Notes NOT applicable to other types of follow-up, other then free-text
                                                         rows_out               => l_rowids);
                    END IF;
                END LOOP;
            
                g_error := 'PROCESS INSERT - DISCHARGE_NOTES_FOLLOW_UP (2)';
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'DISCHARGE_NOTES_FOLLOW_UP',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            
                -- reset variable
                l_rowids := table_varchar();
            
            END IF;
        
            ---------------------------------------------------------------------
            -- B) Process information destinated to the professionals
            --    -> Pending issues
            ---------------------------------------------------------------------
            IF i_issue_assignee.exists(1) -- Check if there's any elements in the array
            THEN
                IF l_id_pending_issue_old IS NOT NULL
                THEN
                    g_error := 'CHECK OLD PENDING ISSUE STATUS';
                    pk_alertlog.log_debug(g_error);
                    SELECT pi.flg_status
                      INTO l_issue_status
                      FROM pending_issue pi
                     WHERE pi.id_pending_issue = l_id_pending_issue_old;
                
                    IF l_issue_status = pk_pending_issues.g_issue_flg_status_cancelled
                    THEN
                        -- A new pending issue can be created, if the previous issue is cancelled
                        l_create_pending_issue := TRUE;
                    ELSIF i_issue_assignee(1) IS NULL -- In case Flash sends an array like [NULL]
                    THEN
                        l_create_pending_issue := FALSE;
                    ELSE
                        -- This should not happen, because new assignee(s) was/were selected, 
                        -- when the issue was still in progress.
                        -- Check for errors in GET_DISCHARGE_NOTES or in the Flash layer.
                        l_create_pending_issue := FALSE;
                        RAISE l_invalid_issue_creation;
                    END IF;
                ELSE
                    -- If does not exist a pending issue, then it can be created
                    l_create_pending_issue := TRUE;
                END IF;
            
                IF l_create_pending_issue
                THEN
                    -- OK to go: lets create a pending issue.
                    g_error := 'CREATE PENDING ISSUE';
                    pk_alertlog.log_debug(g_error);
                    l_assignee_table.extend(i_issue_assignee.count);
                
                    -- Each element in 'i_issue_assignee' has the format P<id> or G<id>, to be able to
                    -- distinguish between the ID's of professionals (P) or groups (G).
                    FOR i IN i_issue_assignee.first .. i_issue_assignee.last
                    LOOP
                    
                        g_error := 'PROCESS SELECTED ASSIGNEE(S) - ' || i_issue_assignee(i);
                        pk_alertlog.log_debug(g_error);
                    
                        l_assignee_type := substr(i_issue_assignee(i), 1, 1); -- (P) or (G)
                        l_assignee_id := to_number(substr(i_issue_assignee(i), 2)); -- Professional or Group ID
                        l_assignee_table(i) := l_assignee_id; -- List of assignee ID's
                    
                        -- Type of assignee must be the same for every element
                        IF i = 1
                        THEN
                            l_assignee_type_aux := l_assignee_type;
                        ELSIF l_assignee_type <> l_assignee_type_aux
                        THEN
                            -- If found a different type, an exception must be raised
                            l_wrong_type_assignee := TRUE;
                        END IF;
                    
                    END LOOP;
                
                    IF l_wrong_type_assignee
                    THEN
                        RAISE l_error_type_assignee;
                    END IF;
                
                    -- Create a new pending issue...
                    g_error := 'CREATE PENDING ISSUE';
                    pk_alertlog.log_debug(g_error);
                    IF NOT pk_pending_issues.set_issue_prof_group(i_lang    => i_lang,
                                                                  i_prof    => i_prof,
                                                                  i_issue   => l_id_pending_issue_new, -- IN/OUT parameter: returns the new ID
                                                                  i_title   => i_issue_title,
                                                                  i_patient => l_patient,
                                                                  i_episode => i_epis,
                                                                  i_group   => CASE l_assignee_type
                                                                                   WHEN l_assignee_type_g THEN
                                                                                    l_assignee_table
                                                                                   ELSE
                                                                                    NULL
                                                                               END,
                                                                  i_profs   => CASE l_assignee_type
                                                                                   WHEN l_assignee_type_p THEN
                                                                                    l_assignee_table
                                                                                   ELSE
                                                                                    NULL
                                                                               END,
                                                                  i_status  => pk_pending_issues.g_issue_flg_status_open,
                                                                  i_subject => i_issue_title,
                                                                  i_message => NULL,
                                                                  o_error   => o_error)
                    THEN
                        RAISE l_runtime_error;
                    END IF;
                END IF;
            END IF;
        
            IF l_create_pending_issue
            THEN
                -- Finally, update the new discharge notes with pending issue ID
                g_error := 'UPDATE DISCHARGE_NOTES (1A)';
                pk_alertlog.log_debug(g_error);
                ts_discharge_notes.upd(id_discharge_notes_in => l_next,
                                       id_pending_issue_in   => l_id_pending_issue_new,
                                       flg_issue_assign_in   => l_assignee_type,
                                       rows_out              => l_rowids);
            ELSE
                -- Or copy the previous information about pending issues to the new discharge notes
                g_error := 'UPDATE DISCHARGE_NOTES (1B)';
                pk_alertlog.log_debug(g_error);
                ts_discharge_notes.upd(id_discharge_notes_in => l_next,
                                       id_pending_issue_in   => l_id_pending_issue_old,
                                       flg_issue_assign_in   => l_flg_issue_assign_old,
                                       rows_out              => l_rowids);
            END IF;
        
            g_error := 'PROCESS UPDATE ON DISCHARGE_NOTES';
            pk_alertlog.log_debug(g_error);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'DISCHARGE_NOTES',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
        ELSIF i_flg_printer = g_disch_notes_p
        THEN
            g_error := 'UPDATE DISCHARGE_NOTES (2)';
            pk_alertlog.log_debug(g_error);
            ts_discharge_notes.upd(flg_status_in         => g_disch_notes_p,
                                   id_discharge_notes_in => i_id_disch,
                                   rows_out              => l_rowids);
        
            --Process the events associated to an update on discharge_notes
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'DISCHARGE_NOTES',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END IF;
    
        --
        g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_epis,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_runtime_error;
        END IF;
    
        g_error := 'CALL TO REMOVE ALL EXISTING PRINT JOBS IN THE PRINTING LIST';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.cancel_disch_instr_print_jobs(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_patient            => l_patient,
                                                          i_episode            => i_epis,
                                                          o_id_print_list_jobs => l_id_print_list_jobs,
                                                          o_error              => o_error)
        THEN
            RAISE l_cancel_print_jobs_excpt;
        END IF;
    
        IF l_commit_data
        THEN
            COMMIT;
        END IF;
    
        o_id_discharge_note := l_next;
        o_reports_pat       := pk_sysconfig.get_config(g_cfg_print_disch_instr, i_prof);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_invalid_issue_creation THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   'T_APPLICATION_ERROR',
                                   'INVALID_CREATION_PENDING_ISSUE',
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_DISCHARGE_NOTES',
                                   'INVALID_CREATION_PENDING_ISSUE',
                                   'S');
            
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes; -- ROLLBACK
                IF l_commit_data
                THEN
                    pk_alert_exceptions.reset_error_state();
                END IF;
                RETURN FALSE;
            END;
        
        WHEN l_invalid_action THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   'T_PARAM_ERROR',
                                   'INVALID_ACTION',
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_DISCHARGE_NOTES',
                                   'INVALID_ACTION',
                                   'S');
            
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes; -- ROLLBACK
                IF l_commit_data
                THEN
                    pk_alert_exceptions.reset_error_state();
                END IF;
                RETURN FALSE;
            END;
        
        WHEN l_error_type_assignee THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   'T_ISSUE_ERROR',
                                   'INVALID_ASSIGNEE_TYPE',
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_DISCHARGE_NOTES',
                                   'INVALID_ASSIGNEE_TYPE',
                                   'S');
            
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes; -- ROLLBACK
                IF l_commit_data
                THEN
                    pk_alert_exceptions.reset_error_state();
                END IF;
                RETURN FALSE;
            END;
        
        WHEN l_runtime_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_NOTES',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            IF l_commit_data
            THEN
                pk_alert_exceptions.reset_error_state();
            END IF;
            RETURN FALSE;
        WHEN l_cancel_print_jobs_excpt THEN
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_NOTES',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            IF l_commit_data
            THEN
                pk_alert_exceptions.reset_error_state();
            END IF;
            RETURN FALSE;
    END set_discharge_notes;

    --
    /********************************************************************************************
    * Insert discharge notes, follow-up entities
    * and manages pending issues related to discharge instructions.
    *
    * @param i_lang                    language id
    * @param i_prof                    Professional, software and institution ids
    * @param i_prof_cat_type           Professional category
    * @param i_epis                    Episode id
    * @param i_patient                 Patient id
    * @param i_id_disch                Discharge notes id
    * @param i_epis_complaint          Patient complaint
    * @param i_epis_diagnosis          Patient diagnosis
    * @param i_recommended             Recommendations for patient
    * @param i_discharge_instr_list    Discharge instructions DEFAULT NULL       
    * @param i_release_from            Release from work or school
    * @param i_dt_from                 Release from this date...
    * @param i_dt_until                ...until this date
    * @param i_notes_release           Release notes
    * @param i_instructions_discussed  Instructions discussed with...
    * @param i_follow_up_with          Follow-up entities ID (can be a physician, external physician or external institution)
    * @param i_follow_up_in            Array of dates or number of days from which the patient must be followed-up
    * @param i_id_follow_up_type       Array of type of follow-up: D - Date; DY - Days; S - SOS
    * @param i_flg_follow_up_with      Follow-up with: (OC) on-call physician (PH) external physician
                                                       (CL) clinic (OF) office (O) other (free text specified in 'i_follow_up_text')
    * @param i_follow_up_text          Specified follow-up entity, with free text, if 'i_flg_follow_up_with' is 'O'
    * @param i_follow_up_notes         Specific notes for follow-up
    * @param i_issue_assignee         Selected assignee(s) in the multichoice, in the format: P<id> or G<id>
                                       Examples:
                                                P142 (Professional with ID_PROFESSIONAL = 142)
                                                G27  (Group with ID_GROUP = 27)
    * @param i_issue_title             Title for the pending issue
    * @param i_flg_printer             Flag printer: P - Printed
    * @param i_commit_data             Commit date? (Y) Yes (N) No   
    * @param o_error                   Error message
    *
    * @return                          TRUE if sucess, FALSE otherwise
    *
    * @author                          José Brito
    * @version                         1.0  
    * @since                           2009/03/05
    *
    ********************************************************************************************/
    FUNCTION set_discharge_notes
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_prof_cat_type          IN category.flg_type%TYPE,
        i_epis                   IN episode.id_episode%TYPE,
        i_patient                IN patient.id_patient%TYPE,
        i_id_disch               IN discharge_notes.id_discharge_notes%TYPE,
        i_epis_complaint         IN CLOB,
        i_epis_diagnosis         IN discharge_notes.epis_diagnosis%TYPE,
        i_discharge_instructions IN discharge_notes.discharge_instructions%TYPE,
        i_discharge_instr_list   IN table_number DEFAULT NULL,
        i_release_from           IN discharge_notes.release_from%TYPE,
        i_dt_from                IN VARCHAR2,
        i_dt_until               IN VARCHAR2,
        i_notes_release          IN discharge_notes.notes_release%TYPE,
        i_instructions_discussed IN table_varchar,
        i_follow_up_with         IN table_number,
        i_follow_up_in           IN table_varchar,
        i_id_follow_up_type      IN table_number,
        i_flg_follow_up_type     IN follow_up_entity.flg_type%TYPE,
        i_follow_up_text         IN VARCHAR2,
        i_follow_up_notes        IN VARCHAR2,
        i_issue_assignee         IN table_varchar,
        i_issue_title            IN pending_issue.title%TYPE,
        i_flg_printer            IN VARCHAR,
        i_commit_data            IN VARCHAR2,
        i_flg_csg_patient        IN VARCHAR2,
        i_dt_csg_patient         IN VARCHAR2,
        o_id_discharge_note      OUT discharge_notes.id_discharge_notes%TYPE,
        o_reports_pat            OUT reports.id_reports%TYPE,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN pk_discharge.set_discharge_notes(i_lang                   => i_lang,
                                                i_prof                   => i_prof,
                                                i_prof_cat_type          => i_prof_cat_type,
                                                i_epis                   => i_epis,
                                                i_patient                => i_patient,
                                                i_id_disch               => i_id_disch,
                                                i_epis_complaint         => i_epis_complaint,
                                                i_epis_diagnosis         => i_epis_diagnosis,
                                                i_discharge_instructions => i_discharge_instructions,
                                                i_discharge_instr_list   => i_discharge_instr_list,
                                                i_release_from           => i_release_from,
                                                i_dt_from                => i_dt_from,
                                                i_dt_until               => i_dt_until,
                                                i_notes_release          => i_notes_release,
                                                i_instructions_discussed => i_instructions_discussed,
                                                i_follow_up_with         => i_follow_up_with,
                                                i_follow_up_in           => i_follow_up_in,
                                                i_id_follow_up_type      => i_id_follow_up_type,
                                                i_flg_follow_up_type     => i_flg_follow_up_type,
                                                i_follow_up_text         => i_follow_up_text,
                                                i_follow_up_notes        => i_follow_up_notes,
                                                i_issue_assignee         => i_issue_assignee,
                                                i_issue_title            => i_issue_title,
                                                i_flg_printer            => i_flg_printer,
                                                i_commit_data            => i_commit_data,
                                                i_sysdate                => NULL,
                                                i_flg_csg_patient        => i_flg_csg_patient,
                                                i_dt_csg_patient         => i_dt_csg_patient,
                                                o_id_discharge_note      => o_id_discharge_note,
                                                o_reports_pat            => o_reports_pat,
                                                o_error                  => o_error);
    END set_discharge_notes;
    --    
    /********************************************************************************************
    * Cancelar uma nota associada à alta do episódio
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param i_epis                  episode id
    * @param i_id_disch              discharge id
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         10-10-2006
    * Changes:
    *
    * @author                          Ariel Machado
    * @version                         2.4.3-Denormalized
    * @since                           2008/09/16
    * reason                           DB Denormalization - Updates to discharge_notes uses framework
    ********************************************************************************************/
    FUNCTION set_cancel_disch_notes
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_epis     IN episode.id_episode%TYPE,
        i_id_disch IN discharge_notes.id_discharge_notes%TYPE,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_char         VARCHAR2(1);
        l_flg_type_cat category.flg_type%TYPE;
        l_rowids       table_varchar;
    
        l_internal_error EXCEPTION;
        --
        CURSOR c_disch IS
            SELECT 'X'
              FROM discharge_notes
             WHERE id_discharge_notes = i_id_disch
               AND id_episode = i_epis
               AND flg_status = g_disch_notes_np;
        --
        CURSOR c_cat IS
            SELECT flg_type
              FROM prof_cat pc, category c
             WHERE pc.id_professional = i_prof.id
               AND pc.id_institution = i_prof.institution
               AND c.id_category = pc.id_category;
    BEGIN
        g_sysdate_tstz := current_timestamp;
        --
        -- Verificar se a nota da alta não foi imprimida
        g_error := 'GET CURSOR C_DISCH';
        OPEN c_disch;
        FETCH c_disch
            INTO l_char;
        g_found := c_disch%FOUND;
        CLOSE c_disch;
        --
        IF g_found
        THEN
            g_error := 'UPDATE DISCHARGE_NOTES';
            ts_discharge_notes.upd(id_prof_cancel_in     => i_prof.id,
                                   dt_cancel_tstz_in     => g_sysdate_tstz,
                                   flg_status_in         => g_disch_notes_c,
                                   id_discharge_notes_in => i_id_disch,
                                   rows_out              => l_rowids);
        
            --Process the events associated to an update on discharge_notes
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'DISCHARGE_NOTES',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END IF;
        --
        g_error := 'OPEN C_CAT';
        OPEN c_cat;
        FETCH c_cat
            INTO l_flg_type_cat;
        CLOSE c_cat;
        --
        g_error := 'CALL TO SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_epis,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => l_flg_type_cat,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        --
        COMMIT;
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_CANCEL_DISCH_NOTES',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_CANCEL_DISCH_NOTES',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END set_cancel_disch_notes;
    --
    /********************************************************************************************
    * Listar os tipos para o acompanhamento
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param o_follow_up_type        Lista com os tipos para o acompanhamento
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         2007/11/07
    ********************************************************************************************/
    FUNCTION get_follow_up_type_list
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        o_follow_up_type OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'OPEN o_follow_up_type';
        OPEN o_follow_up_type FOR
            SELECT fut.id_follow_up_type,
                   pk_translation.get_translation(i_lang, fut.code_follow_up_type) desc_follow_up_ty,
                   fut.flg_type,
                   pk_translation.get_translation(i_lang, fut.code_units) desc_units
              FROM follow_up_type fut
             WHERE fut.flg_available = g_yes
             ORDER BY desc_follow_up_ty ASC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_TYPE_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_follow_up_type);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END;

    FUNCTION tf_get_follow_up_type_list
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional
    ) RETURN t_tbl_core_domain IS
    
        l_ret   t_tbl_core_domain;
        l_error t_error_out;
    
    BEGIN
        g_error := 'OPEN l_ret';
        SELECT *
          BULK COLLECT
          INTO l_ret
          FROM (SELECT t_row_core_domain(internal_name => NULL,
                                         desc_domain   => desc_follow_up_ty,
                                         domain_value  => id_follow_up_type,
                                         order_rank    => NULL,
                                         img_name      => NULL)
                  FROM (SELECT fut.id_follow_up_type,
                               pk_translation.get_translation(i_lang, fut.code_follow_up_type) desc_follow_up_ty
                          FROM follow_up_type fut
                         WHERE fut.flg_available = g_yes
                         ORDER BY desc_follow_up_ty ASC));
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'TF_GET_FOLLOW_UP_TYPE_LIST',
                                              l_error);
            RETURN t_tbl_core_domain();
    END;
    --
    /********************************************************************************************
    * Get follow-up type description
    *
    * @param    i_lang                      preferred language ID
    * @param    i_prof                      object (id of professional, id of institution, id of software)
    * @param    i_follow_up_type            follow-up type ID
    * @param    o_follow_up_type_desc       follow-up type description
    * @param    o_follow_up_type_unit_mea   follow-up type unit measure description
    * @param    o_error                     error message   
    *
    * @return   boolean                     false in case of error and true otherwise
    *
    * @author   Tiago Silva
    * @since    2010/08/09
    ********************************************************************************************/
    FUNCTION get_follow_up_type_desc
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_follow_up_type          IN follow_up_type.id_follow_up_type%TYPE,
        o_follow_up_type_desc     OUT pk_translation.t_desc_translation,
        o_follow_up_type_unit_mea OUT pk_translation.t_desc_translation,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'GET FOLLOW-UP TYPE DESCRIPTION';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        SELECT pk_translation.get_translation(i_lang, fut.code_follow_up_type) desc_follow_up_ty,
               pk_translation.get_translation(i_lang, fut.code_units) desc_units
          INTO o_follow_up_type_desc, o_follow_up_type_unit_mea
          FROM follow_up_type fut
         WHERE fut.id_follow_up_type = i_follow_up_type;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_TYPE_DESC',
                                              o_error);
            RETURN FALSE;
    END get_follow_up_type_desc;
    --
    /********************************************************************************************
    * Listar as entidades a quem se destina a justificação
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param o_release_from          Listar as entidades a quem se destina a justificação
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         2007/11/07
    ********************************************************************************************/
    FUNCTION get_release_from_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        o_release_from OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_internal_error EXCEPTION;
    
    BEGIN
    
        g_error := 'OPEN O_RELEASE_FROM';
        IF NOT pk_sysdomain.get_values_domain('DISCHARGE_NOTES.RELEASE_FROM', i_lang, o_release_from)
        THEN
            RAISE l_internal_error;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_RELEASE_FROM_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_release_from);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END;
    --
    /********************************************************************************************
    * Listar as entidades a quem foi comunicado as instruções
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param o_instr_disc            Listar as entidades a quem foi comunicado as instruções
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         2007/11/07
    ********************************************************************************************/
    FUNCTION get_instruct_discussed_list
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        o_instr_disc OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'OPEN o_instr_disc';
        RETURN pk_sysdomain.get_values_domain('DISCHARGE_NOTES.INSTRUCTIONS_DISCUSSED', i_lang, o_instr_disc);
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_INSTRUCT_DISCUSSED_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_instr_disc);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END;
    --
    /********************************************************************************************
    * Listar os grupos e as intruções dos mesmos
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param o_disch_instr_grp       Listar os grupos de intruções
    * @param o_disch_instr           Listar as instruções associadas a cada grupo   
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         2007/11/08
    ********************************************************************************************/
    FUNCTION get_disch_instructions_list
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        o_disch_instr_grp OUT pk_types.cursor_type,
        o_disch_instr     OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'OPEN o_disch_instr_grp';
        OPEN o_disch_instr_grp FOR
            SELECT dig.id_disch_instructions_group,
                   pk_translation.get_translation(i_lang, dig.code_disch_instructions_group) desc_disch_inst_grp
              FROM disch_instructions_group dig
             WHERE dig.flg_available = g_yes
               AND EXISTS (SELECT 0
                      FROM disch_instr_relation dir
                     WHERE dir.id_disch_instructions_group = dig.id_disch_instructions_group
                       AND dir.id_institution IN (i_prof.institution, 0)
                       AND dir.id_software IN (i_prof.software, 0))
             ORDER BY desc_disch_inst_grp;
    
        g_error := 'OPEN o_disch_instr';
        OPEN o_disch_instr FOR
            SELECT di.id_disch_instructions,
                   dir.id_disch_instructions_group,
                   pk_translation.get_translation(i_lang, di.code_disch_instructions) desc_disch_instr,
                   pk_translation.get_translation(i_lang, di.code_disch_instructions_title) desc_title_disch_instr
              FROM disch_instructions di, disch_instr_relation dir
             WHERE di.flg_available = g_yes
               AND dir.id_disch_instructions = di.id_disch_instructions
               AND dir.id_institution IN (i_prof.institution, 0)
               AND dir.id_software IN (i_prof.software, 0)
             ORDER BY id_disch_instructions_group, desc_title_disch_instr;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCH_INSTRUCTIONS_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_disch_instr_grp);
            pk_types.open_my_cursor(o_disch_instr);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_disch_instructions_list;
    --
    /********************************************************************************************
    * Returns the list of professionals that follow the patient in the next intervention (without free text option)
    *
    * @param i_lang                  preferred language id for this professional
    * @param i_prof                  professional id structure
    * @param o_follow_up_with        list of professionals that follow the patient in the next intervention
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Tiago Silva
    * @since                         2010/10/28
    ********************************************************************************************/
    FUNCTION get_followup_with_wofreetext
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        o_follow_up_with OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'OPEN o_follow_up_with_wofreetext';
    
        OPEN o_follow_up_with FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.domain_value data, t.desc_domain label, t.desc_domain ordered
              FROM (pk_discharge.tf_get_followup_with_wofreetext(i_lang => i_lang, i_prof => i_prof)) t;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOWUP_WITH_WOFREETEXT',
                                              o_error);
            pk_types.open_my_cursor(o_follow_up_with);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_followup_with_wofreetext;

    FUNCTION tf_get_followup_with_wofreetext
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional
    ) RETURN t_tbl_core_domain IS
        l_ret   t_tbl_core_domain;
        l_error t_error_out;
    BEGIN
        g_error := 'OPEN o_follow_up_with_wofreetext';
    
        SELECT *
          BULK COLLECT
          INTO l_ret
          FROM (SELECT t_row_core_domain(internal_name => NULL,
                                         desc_domain   => label,
                                         domain_value  => data,
                                         order_rank    => NULL,
                                         img_name      => NULL)
                  FROM (SELECT p.id_professional data,
                               pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) label
                          FROM professional p, prof_cat pc, category c, prof_institution pi
                         WHERE p.id_professional = pc.id_professional
                           AND p.id_professional = pi.id_professional
                           AND pi.id_institution = i_prof.institution
                           AND pi.flg_state = pk_alert_constant.g_active
                           AND pi.dt_end_tstz IS NULL
                           AND pc.id_category = c.id_category
                           AND pc.id_institution = pi.id_institution
                           AND c.flg_type IN (g_doctor, g_nurse))
                 ORDER BY label);
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'TF_GET_FOLLOWUP_WITH_WOFREETEXT',
                                              l_error);
            pk_alert_exceptions.reset_error_state();
            RETURN t_tbl_core_domain();
    END tf_get_followup_with_wofreetext;
    --
    /********************************************************************************************
    * Listar os profissionais que acompanham o paciente numa proxima intervenção
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param o_follow_up_with        Listar os profissionais que acompanham o paciente numa proxima intervenção
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Emília Taborda
    * @version                       1.0  
    * @since                         2007/11/14
    ********************************************************************************************/
    FUNCTION get_follow_up_with_list
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        o_follow_up_with OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'OPEN o_follow_up_with';
        OPEN o_follow_up_with FOR
            SELECT p.id_professional data,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) label,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) ordered
              FROM professional p, prof_cat pc, category c, prof_institution pi
             WHERE p.id_professional = pc.id_professional
               AND p.id_professional = pi.id_professional
               AND pi.id_institution = i_prof.institution
               AND pi.flg_state = pk_alert_constant.g_active
               AND pi.dt_end_tstz IS NULL
               AND pc.id_category = c.id_category
               AND pc.id_institution = pi.id_institution
               AND c.flg_type IN (g_doctor, g_nurse)
            UNION ALL
            SELECT g_other_prof_id data, pk_message.get_message(i_lang, i_prof, 'COMMON_M041') label, '-1' ordered
              FROM dual
             ORDER BY 3 ASC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_WITH_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_follow_up_with);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END;
    --
    /********************************************************************************************
    * List follow-up entities in the discharge instructions screen.
    *
    * @param i_lang                  language id
    * @param i_prof                  Professional, software and institution ids
    * @param i_id_disch_notes        Discharge notes ID
    * @param o_follow_up_with        Follow-up entities list
    * @param o_error                 Error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        José Brito
    * @version                       1.0  
    * @since                         2009/03/06
    ********************************************************************************************/
    FUNCTION get_follow_up_with_list
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_disch_notes IN discharge_notes.id_discharge_notes%TYPE,
        o_follow_up_with OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_invalid_data   EXCEPTION;
        l_invalid_action EXCEPTION;
    
        l_flg_follow_up_type follow_up_entity.flg_type%TYPE;
    BEGIN
    
        IF i_id_disch_notes IS NOT NULL
        THEN
            -- Get type of follow-up
            g_error := 'GET FOLLOW-UP TYPE';
            pk_alertlog.log_debug(g_error);
            BEGIN
                SELECT fue.flg_type
                  INTO l_flg_follow_up_type
                  FROM discharge_notes_follow_up dnu, follow_up_entity fue
                 WHERE dnu.id_follow_up_entity = fue.id_follow_up_entity
                   AND dnu.id_discharge_notes = i_id_disch_notes
                 GROUP BY fue.flg_type;
            EXCEPTION
                WHEN no_data_found THEN
                    l_flg_follow_up_type := NULL;
                WHEN too_many_rows THEN
                    -- If we get more than one type of flag, there is a data quality issue,
                    -- because each discharge note only supports one type of follow-up.
                    RAISE l_invalid_data;
            END;
        
            IF l_flg_follow_up_type = pk_alert_constant.g_followupwith_oc
            THEN
                -- On-call physician data
                g_error := 'GET FOLLOW-UP CURSOR (OC)';
                pk_alertlog.log_debug(g_error);
                OPEN o_follow_up_with FOR
                    SELECT dnu.id_discharge_notes,
                           dnu.id_follow_up_with,
                           dnu.id_follow_up_entity,
                           l_flg_follow_up_type flg_type,
                           --
                           decode(fut.flg_type,
                                  NULL,
                                  '',
                                  'D',
                                  nvl(pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                         pk_date_utils.get_string_tstz(i_lang,
                                                                                                       i_prof,
                                                                                                       dnu.follow_up_in,
                                                                                                       NULL),
                                                                         i_prof.institution,
                                                                         i_prof.software),
                                      dnu.follow_up_in),
                                  'DY',
                                  dnu.follow_up_in ||
                                  (SELECT decode(pk_translation.get_translation(i_lang, fut.code_units),
                                                 NULL,
                                                 '',
                                                 ' ' || pk_translation.get_translation(i_lang, fut.code_units))
                                     FROM dual),
                                  'S',
                                  dnu.follow_up_in) follow_up_in_str, -- Date / No. of days / SOS
                           dnu.follow_up_in,
                           dnu.id_follow_up_type,
                           dnu.notes follow_up_notes,
                           fut.flg_type follow_up_in_type,
                           --
                           pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) label,
                           pk_prof_utils.get_spec_signature(i_lang, i_prof, p.id_professional, NULL, NULL) desc_spec,
                           --
                           p.address,
                           p.city,
                           p.district,
                           p.zip_code,
                           (SELECT pk_translation.get_translation(i_lang, c.code_country)
                              FROM country c
                             WHERE c.id_country = p.id_country) desc_country,
                           --
                           p.work_phone,
                           p.fax,
                           NULL         website,
                           p.email
                      FROM discharge_notes_follow_up dnu, professional p, follow_up_type fut
                     WHERE dnu.id_follow_up_with = p.id_professional
                       AND dnu.id_follow_up_type = fut.id_follow_up_type(+)
                       AND dnu.id_discharge_notes = i_id_disch_notes;
            
            ELSIF l_flg_follow_up_type = pk_alert_constant.g_followupwith_ph
            THEN
                -- External professional data
                g_error := 'GET FOLLOW-UP CURSOR (PH)';
                pk_alertlog.log_debug(g_error);
                OPEN o_follow_up_with FOR
                    SELECT dnu.id_discharge_notes,
                           dnu.id_follow_up_with,
                           dnu.id_follow_up_entity,
                           l_flg_follow_up_type flg_type,
                           --
                           decode(fut.flg_type,
                                  NULL,
                                  '',
                                  'D',
                                  nvl(pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                         pk_date_utils.get_string_tstz(1,
                                                                                                       i_prof,
                                                                                                       dnu.follow_up_in,
                                                                                                       NULL),
                                                                         i_prof.institution,
                                                                         i_prof.software),
                                      dnu.follow_up_in),
                                  'DY',
                                  dnu.follow_up_in ||
                                  (SELECT decode(pk_translation.get_translation(i_lang, fut.code_units),
                                                 NULL,
                                                 '',
                                                 ' ' || pk_translation.get_translation(i_lang, fut.code_units))
                                     FROM dual),
                                  'S',
                                  dnu.follow_up_in) follow_up_in_str, -- Date / No. of days / SOS
                           dnu.follow_up_in,
                           dnu.id_follow_up_type,
                           dnu.notes follow_up_notes,
                           fut.flg_type follow_up_in_type,
                           --
                           nvl2(p.last_name, p.last_name || ', ', '') || p.first_name || ', ' || p.title label,
                           (SELECT pk_translation.get_translation(i_lang, s.code_speciality)
                              FROM speciality s
                             WHERE s.id_speciality = p.id_speciality) desc_spec,
                           --
                           p.address,
                           p.city,
                           p.district,
                           p.zip_code,
                           (SELECT pk_translation.get_translation(i_lang, c.code_country)
                              FROM country c
                             WHERE c.id_country = p.id_country) desc_country,
                           --
                           p.work_phone,
                           p.fax,
                           NULL         website,
                           p.email
                      FROM discharge_notes_follow_up dnu, professional p, follow_up_type fut
                     WHERE dnu.id_follow_up_with = p.id_professional
                       AND dnu.id_follow_up_type = fut.id_follow_up_type(+)
                       AND dnu.id_discharge_notes = i_id_disch_notes;
            
            ELSIF l_flg_follow_up_type IN (pk_alert_constant.g_followupwith_cl)
            THEN
                -- External institution data
                g_error := 'GET FOLLOW-UP CURSOR (CL/OF)';
                pk_alertlog.log_debug(g_error);
                OPEN o_follow_up_with FOR
                    SELECT dnu.id_discharge_notes,
                           dnu.id_follow_up_with,
                           dnu.id_follow_up_entity,
                           l_flg_follow_up_type flg_type,
                           --
                           decode(fut.flg_type,
                                  NULL,
                                  '',
                                  'D',
                                  nvl(pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                         pk_date_utils.get_string_tstz(1,
                                                                                                       i_prof,
                                                                                                       dnu.follow_up_in,
                                                                                                       NULL),
                                                                         i_prof.institution,
                                                                         i_prof.software),
                                      dnu.follow_up_in),
                                  'DY',
                                  dnu.follow_up_in ||
                                  (SELECT decode(pk_translation.get_translation(i_lang, fut.code_units),
                                                 NULL,
                                                 '',
                                                 ' ' || pk_translation.get_translation(i_lang, fut.code_units))
                                     FROM dual),
                                  'S',
                                  dnu.follow_up_in) follow_up_in_str, -- Date / No. of days / SOS
                           dnu.follow_up_in,
                           dnu.id_follow_up_type,
                           dnu.notes follow_up_notes,
                           fut.flg_type follow_up_in_type,
                           --
                           pk_translation.get_translation(i_lang => i_lang, i_code_mess => i.code_institution) label,
                           pk_utils.concatenate_list(CURSOR
                                                     (SELECT pk_translation.get_translation(i_lang, column_value)
                                                        FROM TABLE(pk_tools.get_inst_clin_serv_codes(i_lang        => i_lang,
                                                                                                     i_prof        => i_prof,
                                                                                                     i_institution => i.id_institution))),
                                                     '; ') desc_spec,
                           --
                           i.address,
                           i.location city,
                           i.district,
                           i.zip_code,
                           (SELECT pk_translation.get_translation(i_lang, c.code_country)
                              FROM country c
                             WHERE c.id_country = ia.id_country) desc_country,
                           --
                           i.phone_number work_phone,
                           i.fax_number   fax,
                           NULL           website,
                           ia.email
                      FROM discharge_notes_follow_up dnu, institution i, inst_attributes ia, follow_up_type fut
                     WHERE dnu.id_follow_up_with = i.id_institution
                       AND dnu.id_follow_up_type = fut.id_follow_up_type(+)
                       AND i.id_institution = ia.id_institution
                       AND dnu.id_discharge_notes = i_id_disch_notes;
            
            ELSIF l_flg_follow_up_type = pk_alert_constant.g_followupwith_o
            THEN
                -- Get free text data
                g_error := 'GET FOLLOW-UP CURSOR (O)';
                pk_alertlog.log_debug(g_error);
                OPEN o_follow_up_with FOR
                    SELECT dnu.id_discharge_notes,
                           dnu.id_follow_up_with,
                           dnu.id_follow_up_entity,
                           l_flg_follow_up_type flg_type,
                           --
                           decode(fut.flg_type,
                                  NULL,
                                  '',
                                  'D',
                                  nvl(pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                         pk_date_utils.get_string_tstz(1,
                                                                                                       i_prof,
                                                                                                       dnu.follow_up_in,
                                                                                                       NULL),
                                                                         i_prof.institution,
                                                                         i_prof.software),
                                      dnu.follow_up_in),
                                  'DY',
                                  dnu.follow_up_in ||
                                  (SELECT decode(pk_translation.get_translation(i_lang, fut.code_units),
                                                 NULL,
                                                 '',
                                                 ' ' || pk_translation.get_translation(i_lang, fut.code_units))
                                     FROM dual),
                                  'S',
                                  dnu.follow_up_in) follow_up_in_str, -- Date / No. of days / SOS
                           dnu.follow_up_in,
                           dnu.id_follow_up_type,
                           dnu.notes follow_up_notes,
                           fut.flg_type follow_up_in_type,
                           dnu.follow_up_with_text label,
                           -- José Brito 01/03/2010 ALERT-77809 Avoid error in report generation
                           NULL desc_spec,
                           NULL address,
                           NULL city,
                           NULL district,
                           NULL zip_code,
                           NULL desc_country,
                           NULL work_phone,
                           NULL fax,
                           NULL website,
                           NULL email
                      FROM discharge_notes_follow_up dnu, follow_up_type fut
                     WHERE dnu.id_discharge_notes = i_id_disch_notes
                       AND dnu.id_follow_up_type = fut.id_follow_up_type(+);
            ELSE
                g_error := 'OPEN CURSOR (2)';
                pk_alertlog.log_debug(g_error);
                pk_types.open_my_cursor(o_follow_up_with);
            END IF;
        
        ELSE
            g_error := 'OPEN CURSOR (2)';
            pk_alertlog.log_debug(g_error);
            pk_types.open_my_cursor(o_follow_up_with);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_invalid_action THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'T_PARAM_ERROR',
                                              'INVALID ACTION',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_WITH_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_follow_up_with);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN l_invalid_data THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'T_DATA_ERROR',
                                              'INVALID DATA',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_WITH_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_follow_up_with);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_WITH_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_follow_up_with);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_follow_up_with_list;
    --
    /********************************************************************************************
    * List follow-up entities in the EHR Discharge Instructions History.
    *
    * @param i_lang                  language id
    * @param i_prof                  Professional, software and institution ids
    * @param i_id_disch_notes        Discharge notes ID
    * @param i_id_episode            Episode ID
    *
    * @return                        Text with follow-up entities and follow-up dates
    *
    * @author                        José Brito
    * @version                       1.0  
    * @since                         2009/04/07
    ********************************************************************************************/
    FUNCTION get_follow_up_with_list
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_disch_notes IN discharge_notes.id_discharge_notes%TYPE,
        i_id_episode     IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
        l_invalid_action EXCEPTION;
        l_invalid_data   EXCEPTION;
        l_flg_follow_up_type follow_up_entity.flg_type%TYPE;
        l_follow_up_desc     VARCHAR2(4000);
        l_sep                VARCHAR2(2) := '; ';
    BEGIN
    
        IF i_id_disch_notes IS NOT NULL
        THEN
            -- Get type of follow-up
            g_error := 'GET FOLLOW-UP TYPE';
            pk_alertlog.log_debug(g_error);
            BEGIN
                SELECT fue.flg_type
                  INTO l_flg_follow_up_type
                  FROM discharge_notes_follow_up dnu, follow_up_entity fue
                 WHERE dnu.id_follow_up_entity = fue.id_follow_up_entity
                   AND dnu.id_discharge_notes = i_id_disch_notes
                 GROUP BY fue.flg_type;
            EXCEPTION
                WHEN too_many_rows THEN
                    -- If we get more than one type of flag, there is a data quality issue,
                    -- because each discharge note only supports one type of follow-up.
                    RAISE l_invalid_data;
            END;
        
            IF l_flg_follow_up_type = pk_alert_constant.g_followupwith_oc
            THEN
                -- On-call physician data
                g_error := 'GET FOLLOW-UP CURSOR (OC)';
                pk_alertlog.log_debug(g_error);
                SELECT pk_utils.concatenate_list(CURSOR (SELECT pk_prof_utils.get_name_signature(i_lang,
                                                                                          i_prof,
                                                                                          p.id_professional) || ' (' ||
                                                         decode(fut.flg_type,
                                                                NULL,
                                                                '',
                                                                'D',
                                                                nvl(pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                                                       pk_date_utils.get_string_tstz(1,
                                                                                                                                     i_prof,
                                                                                                                                     dnu.follow_up_in,
                                                                                                                                     NULL),
                                                                                                       i_prof.institution,
                                                                                                       i_prof.software),
                                                                    dnu.follow_up_in),
                                                                'DY',
                                                                pk_string_utils.concat_if_exists(dnu.follow_up_in,
                                                                                                 pk_translation.get_translation(i_lang,
                                                                                                                                fut.code_units),
                                                                                                 ' '),
                                                                'S',
                                                                dnu.follow_up_in) || ')'
                                                    FROM discharge_notes_follow_up dnu,
                                                         professional              p,
                                                         follow_up_type            fut
                                                   WHERE dnu.id_follow_up_with = p.id_professional
                                                     AND dnu.id_follow_up_type = fut.id_follow_up_type(+)
                                                     AND dnu.id_discharge_notes = i_id_disch_notes),
                                                 l_sep)
                  INTO l_follow_up_desc
                  FROM dual;
            
            ELSIF l_flg_follow_up_type = pk_alert_constant.g_followupwith_ph
            THEN
                -- External professional data
                g_error := 'GET FOLLOW-UP CURSOR (PH)';
                pk_alertlog.log_debug(g_error);
                SELECT pk_utils.concatenate_list(CURSOR
                                                 (SELECT p.name || ' (' || decode(fut.flg_type,
                                                                                  NULL,
                                                                                  '',
                                                                                  'D',
                                                                                  nvl(pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                                                                         pk_date_utils.get_string_tstz(1,
                                                                                                                                                       i_prof,
                                                                                                                                                       dnu.follow_up_in,
                                                                                                                                                       NULL),
                                                                                                                         i_prof.institution,
                                                                                                                         i_prof.software),
                                                                                      dnu.follow_up_in),
                                                                                  'DY',
                                                                                  pk_string_utils.concat_if_exists(dnu.follow_up_in,
                                                                                                                   pk_translation.get_translation(i_lang,
                                                                                                                                                  fut.code_units),
                                                                                                                   ' '),
                                                                                  'S',
                                                                                  dnu.follow_up_in) || ')'
                                                    FROM discharge_notes_follow_up dnu,
                                                         professional              p,
                                                         follow_up_type            fut
                                                   WHERE dnu.id_follow_up_with = p.id_professional
                                                     AND dnu.id_follow_up_type = fut.id_follow_up_type(+)
                                                     AND dnu.id_discharge_notes = i_id_disch_notes),
                                                 l_sep)
                  INTO l_follow_up_desc
                  FROM dual;
            
            ELSIF l_flg_follow_up_type IN (pk_alert_constant.g_followupwith_cl)
            THEN
                -- External institution data
                g_error := 'GET FOLLOW-UP CURSOR (CL/OF)';
                pk_alertlog.log_debug(g_error);
                SELECT pk_utils.concatenate_list(CURSOR (SELECT pk_translation.get_translation(i_lang      => i_lang,
                                                                                        i_code_mess => i.code_institution) || ' (' ||
                                                         decode(fut.flg_type,
                                                                NULL,
                                                                '',
                                                                'D',
                                                                nvl(pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                                                       pk_date_utils.get_string_tstz(1,
                                                                                                                                     i_prof,
                                                                                                                                     dnu.follow_up_in,
                                                                                                                                     NULL),
                                                                                                       i_prof.institution,
                                                                                                       i_prof.software),
                                                                    dnu.follow_up_in),
                                                                'DY',
                                                                pk_string_utils.concat_if_exists(dnu.follow_up_in,
                                                                                                 pk_translation.get_translation(i_lang,
                                                                                                                                fut.code_units),
                                                                                                 ' '),
                                                                'S',
                                                                dnu.follow_up_in) || ')'
                                                    FROM discharge_notes_follow_up dnu,
                                                         institution               i,
                                                         follow_up_type            fut
                                                   WHERE dnu.id_follow_up_with = i.id_institution
                                                     AND dnu.id_follow_up_type = fut.id_follow_up_type(+)
                                                     AND dnu.id_discharge_notes = i_id_disch_notes),
                                                 l_sep)
                  INTO l_follow_up_desc
                  FROM dual;
            
            ELSIF l_flg_follow_up_type = pk_alert_constant.g_followupwith_o
            THEN
                -- Get free text data
                g_error := 'GET FOLLOW-UP CURSOR (O)';
                pk_alertlog.log_debug(g_error);
                SELECT pk_utils.concatenate_list(CURSOR (SELECT dnu.follow_up_with_text || ' (' ||
                                                         decode(fut.flg_type,
                                                                NULL,
                                                                '',
                                                                'D',
                                                                nvl(pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                                                       pk_date_utils.get_string_tstz(1,
                                                                                                                                     i_prof,
                                                                                                                                     dnu.follow_up_in,
                                                                                                                                     NULL),
                                                                                                       i_prof.institution,
                                                                                                       i_prof.software),
                                                                    dnu.follow_up_in),
                                                                'DY',
                                                                pk_string_utils.concat_if_exists(dnu.follow_up_in,
                                                                                                 pk_translation.get_translation(i_lang,
                                                                                                                                fut.code_units),
                                                                                                 ' '),
                                                                'S',
                                                                dnu.follow_up_in) || ')'
                                                    FROM discharge_notes_follow_up dnu, follow_up_type fut
                                                   WHERE dnu.id_discharge_notes = i_id_disch_notes
                                                     AND dnu.id_follow_up_type = fut.id_follow_up_type(+)),
                                                 l_sep)
                  INTO l_follow_up_desc
                  FROM dual;
            ELSE
                RAISE l_invalid_action;
            END IF;
        
        ELSE
            RETURN NULL;
        END IF;
    
        RETURN l_follow_up_desc;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
        WHEN OTHERS THEN
            RETURN NULL;
    END get_follow_up_with_list;
    --
    /********************************************************************************************
    * Get follow-up with entity description
    *
    * @param    i_lang                preferred language ID
    * @param    i_prof                object (id of professional, id of institution, id of software)
    * @param    i_opinion_prof        entity professional ID
    *
    * @return   varchar2              entity description
    *
    * @author                         Tiago Silva
    * @since                          2010/08/06
    ********************************************************************************************/
    FUNCTION get_follow_up_with_entity_desc
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_entity_prof IN professional.id_professional%TYPE
    ) RETURN professional.name%TYPE IS
        l_entity_desc professional.name%TYPE;
    BEGIN
        g_error := 'GET FOLLOW-UP WITH ENTITY DESCRIPTION';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        SELECT label
          INTO l_entity_desc
          FROM (SELECT p.id_professional data, pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) label
                  FROM professional p
                 WHERE i_entity_prof != g_other_prof_id
                UNION ALL
                SELECT g_other_prof_id data, pk_message.get_message(i_lang, i_prof, 'COMMON_M041') label
                  FROM dual)
         WHERE data = i_entity_prof;
    
        RETURN l_entity_desc;
    
    END get_follow_up_with_entity_desc;
    --  
    FUNCTION get_discharge_options
    (
        i_lang  IN language.id_language%TYPE,
        o_type  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        /******************************************************************************
           OBJECTIVO:   Obter lista de opções disponíveis para tipo de alta
           PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                        Saida:   O_TYPE - tipos de alta
                                 O_ERROR - erro
        
          CRIAÇÃO: JSILVA 17/05/2007                                    
          NOTAS:
        *********************************************************************************/
    BEGIN
    
        g_error := 'OPEN CURSOR O_TYPE';
        RETURN pk_sysdomain.get_values_domain('DISCHARGE.FLG_STATUS',
                                              i_lang,
                                              o_type,
                                              table_varchar(g_disch_flg_active, g_disch_flg_pend));
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_OPTIONS',
                                              o_error);
            pk_types.open_my_cursor(o_type);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_discharge_options;
    --
    /***********************************************************************************************
    * Gets the discharge type list
    *
    * @param i_lang      the id language
    * @param i_prof      professional, software and institution ids
    * @param o_type      list of available discharge types    
    *                        
    * @return            Description of MSE_TYPE
    *
    * @author            José Silva
    * @version           1.0  
    * @since             2008/02/11
    **********************************************************************************************/
    FUNCTION get_discharge_options
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_type  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_disch_domain sys_domain.code_domain%TYPE;
    
    BEGIN
    
        g_error        := 'GET DISCHARGE OPTIONS DOMAIN';
        l_disch_domain := pk_sysconfig.get_config('DISCHARGE_OPTIONS', i_prof);
    
        g_error := 'OPEN CURSOR O_TYPE';
        RETURN pk_sysdomain.get_values_domain(l_disch_domain,
                                              i_lang,
                                              o_type,
                                              table_varchar(g_disch_flg_active, g_disch_flg_pend));
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_OPTIONS',
                                              o_error);
            pk_types.open_my_cursor(o_type);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_discharge_options;
    --
    FUNCTION set_alert_edis_to_inp
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_episode     IN episode.id_episode%TYPE,
        i_new_episode IN episode.id_episode%TYPE,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_department_dest department.id_department%TYPE;
        --
        l_desc_orig           VARCHAR2(0100);
        l_desc_dest           VARCHAR2(0100);
        l_id_sys_alert        NUMBER;
        l_id_profile_template profile_template.id_profile_template%TYPE;
    
        l_next_sys_alert_det  sys_alert_det.id_sys_alert_det%TYPE;
        l_next_epis_prof_resp sys_alert_det.id_reg_det%TYPE;
        l_rowids_1            table_varchar;
    
        CURSOR c_ppt
        (
            i_sys_alert        IN NUMBER,
            i_profile_template IN NUMBER,
            i_dept_dest        IN NUMBER
        ) IS
            SELECT *
              FROM sys_alert_prof
             WHERE id_sys_alert = i_sys_alert
               AND id_institution = i_prof.institution
               AND id_profile_template = i_profile_template
               AND id_software = pk_sysconfig.get_config('SOFTWARE_ID_INP', i_prof)
               AND id_professional IN (SELECT DISTINCT pdcs.id_professional
                                         FROM dep_clin_serv dcs, prof_dep_clin_serv pdcs, prof_profile_template ppt
                                        WHERE dcs.id_dep_clin_serv = pdcs.id_dep_clin_serv
                                          AND ppt.id_professional = pdcs.id_professional
                                          AND ppt.id_profile_template = i_profile_template
                                          AND pdcs.flg_status = 'S'
                                          AND pdcs.id_institution = i_prof.institution
                                          AND dcs.id_department = i_dept_dest);
    BEGIN
        g_sysdate_tstz := current_timestamp;
        --
        g_error := 'INIT VAR';
        IF i_new_episode IS NOT NULL
        THEN
            g_error               := 'INIT CONFIG VAR';
            l_id_profile_template := pk_sysconfig.get_config('ALERT_INP_TRANSFER_PROFILE', i_prof);
            l_id_sys_alert        := pk_sysconfig.get_config('ALERT_INP_TRANSFER', i_prof);
            --
            g_error := 'GET DESC_ORIG';
            SELECT pk_translation.get_translation(i_lang, et.code_epis_type) x
              INTO l_desc_orig
              FROM epis_type et
             WHERE et.id_epis_type = pk_sysconfig.get_config('ID_EPIS_TYPE_EDIS', i_prof);
        
            g_error := 'GET DESC_DEST';
            SELECT dpt.id_department, pk_translation.get_translation(i_lang, dpt.code_department) x
              INTO l_id_department_dest, l_desc_dest
              FROM department dpt, episode e
             WHERE e.id_episode = i_new_episode
               AND e.id_department = dpt.id_department;
        
            g_error := 'DO LOOP ALERT_PROFILE';
            FOR c IN c_ppt(l_id_sys_alert, l_id_profile_template, l_id_department_dest)
            LOOP
            
                g_error := 'INSERT ALERT_DET FOR PROF:' || c.id_professional;
                -- USO DA SEQUENCIA PARA EVITAR PROBLEMAS DE UK
                -- *********************************
                -- PT 15/01/2009 2.4.3.d
                SELECT seq_sys_alert_det.nextval, seq_epis_prof_resp.nextval
                  INTO l_next_sys_alert_det, l_next_epis_prof_resp
                  FROM dual;
            
                ts_sys_alert_det.ins(id_sys_alert_det_in => l_next_sys_alert_det,
                                     id_reg_in           => i_new_episode,
                                     id_episode_in       => i_new_episode,
                                     id_institution_in   => i_prof.institution,
                                     id_prof_in          => c.id_professional,
                                     dt_req_tstz_in      => g_sysdate_tstz,
                                     replace1_in         => l_desc_orig,
                                     replace2_in         => l_desc_dest,
                                     id_schedule_in      => NULL,
                                     id_sys_alert_in     => l_id_sys_alert,
                                     id_reg_det_in       => l_next_epis_prof_resp,
                                     rows_out            => l_rowids_1);
            
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'SYS_ALERT_DET',
                                              i_rowids     => l_rowids_1,
                                              o_error      => o_error);
                -- *********************************
            
            END LOOP;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_ALERT_EDIS_TO_INP',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_alert_edis_to_inp;
    --
    /***********************************************************************************************
    * Concatenar os diferentes valores MSE_TYPE inseridos no detalhe da alta
    *
    * @param i_lang      the id language
    * @param i_mse_type  mse - medical screening evaluation ids
    *                        
    * @return            Description of MSE_TYPE
    *
    * @author            Emilia Taborda
    * @version           1.0  
    * @since             2007/06/18
    **********************************************************************************************/
    FUNCTION get_disch_det_mse_type_desc
    (
        i_lang     IN language.id_language%TYPE,
        i_mse_type IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_desc_mse_type VARCHAR2(4000);
    
    BEGIN
        g_error := 'GET DESC_MSE_TYPE';
        SELECT pk_utils.concatenate_list(CURSOR
                                         (SELECT desc_val
                                            FROM sys_domain s
                                           WHERE s.code_domain = 'DISCHARGE_DETAIL.MSE_TYPE'
                                             AND s.id_language = i_lang
                                             AND s.domain_owner = pk_sysdomain.k_default_schema
                                             AND s.flg_available = g_flg_available
                                             AND s.val IN (SELECT *
                                                             FROM TABLE(pk_utils.str_split(i_mse_type, ',')))
                                           ORDER BY rank),
                                         '; ')
          INTO l_desc_mse_type
          FROM dual;
    
        IF l_desc_mse_type IS NOT NULL
        THEN
            l_desc_mse_type := l_desc_mse_type || ';';
        END IF;
    
        RETURN l_desc_mse_type;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END;
    --

    /***********************************************************************************************
    * Set id_epis_report for a discharge_note record
    *
    * @param i_lang      the id language
    * @param i_prof      professional, software and institution ids
    * @param i_id_episode          id of episode    
    * @param i_id_epis_report      id of epis_report to save    
    * @param o_error     Error message
    *                        
    * @return            TRUE if sucess, FALSE otherwise
    *
    * @author            Carlos Ferreira
    * @version           1.0  
    * @since             2008/03/26
    * Changes:
    *
    * @author                          Ariel Machado
    * @version                         2.4.3-Denormalized
    * @since                           2008/09/16
    * reason                           DB Denormalization - Table discharge_notes includes field id_patient
    **********************************************************************************************/
    FUNCTION set_epis_report
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_episode     IN episode.id_episode%TYPE,
        i_id_epis_report IN epis_report.id_epis_report%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_notes IS
            SELECT id_discharge_notes
              FROM discharge_notes
             WHERE id_episode = i_id_episode
             ORDER BY dt_creation_tstz DESC;
        l_id_discharge_notes discharge_notes.id_discharge_notes%TYPE;
        l_rowids             table_varchar;
    BEGIN
    
        g_error := 'OPEN C_SHORT_IMAGE';
        OPEN c_notes;
        FETCH c_notes
            INTO l_id_discharge_notes;
        CLOSE c_notes;
    
        ts_discharge_notes.upd(id_epis_report_in     => i_id_epis_report,
                               flg_status_in         => 'P',
                               id_discharge_notes_in => l_id_discharge_notes,
                               rows_out              => l_rowids);
    
        --Process the events associated to an update on epis_recomend
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'DISCHARGE_NOTES',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_EPIS_REPORT',
                                              o_error);
            pk_utils.undo_changes; -- ROLLBACK
            RETURN FALSE;
    END set_epis_report;
    --

    /***********************************************************************************************
    * Updates to the destination institution the original data of the patient.
    *
    * @param i_lang             language ID
    * @param i_prof             Professional, software and institution IDs
    * @param i_episode          Episode ID    
    * @param i_patient          Patient ID
    * @param i_institution      Destination institution ID        
    * @param o_error            Error message
    *                        
    * @return            TRUE if sucess, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2008/11/17
    **********************************************************************************************/
    FUNCTION update_patient_data
    (
        i_lang          IN NUMBER,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_patient       IN patient.id_patient%TYPE,
        i_institution   IN institution.id_institution%TYPE,
        i_software      IN software.id_software%TYPE,
        i_prof_cat_type IN category.flg_type%TYPE,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_health_plan           table_number;
        l_num_health_plan          table_varchar;
        l_dt_health_plan           table_date;
        l_flg_default              table_varchar;
        l_flg_default_epis         table_varchar;
        l_barcode                  table_varchar;
        l_desc_health_plan         table_varchar;
        l_id_necessity_tbl         table_number;
        l_necessity_flg_status_tbl table_varchar;
        --
        --l_next_key       clin_record.id_clin_record%TYPE;
        --l_rowids         table_varchar;
        --l_id_clin_record clin_record.id_clin_record%TYPE;
    
        l_internal_error EXCEPTION;
    
        CURSOR c_pat_hplan IS
            SELECT php.id_health_plan,
                   php.num_health_plan,
                   php.dt_health_plan,
                   php.flg_default,
                   decode(ehp.id_episode, NULL, 'N', 'Y') flg_default_epis,
                   php.barcode,
                   php.desc_health_plan
              FROM pat_health_plan php, epis_health_plan ehp
             WHERE php.id_patient = i_patient
               AND ehp.id_episode(+) = i_episode
               AND php.id_pat_health_plan = ehp.id_pat_health_plan(+)
               AND php.id_institution = i_prof.institution;
    
    BEGIN
    
        -- clin_record must be inserted by the ADT code
    
        SELECT pn.id_necessity, pn.flg_status
          BULK COLLECT
          INTO l_id_necessity_tbl, l_necessity_flg_status_tbl
          FROM pat_necessity pn
         WHERE pn.id_patient = i_patient
           AND pn.id_episode = i_episode
           AND pn.id_institution = i_prof.institution;
    
        g_error := 'CALL PK_PATIENT.SET_PAT_NECESS_INTERNAL';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_patient.set_pat_necess(i_lang             => i_lang,
                                         i_prof             => i_prof,
                                         i_id_patient       => i_patient,
                                         i_id_episode       => i_episode,
                                         i_tbl_flg_status   => l_necessity_flg_status_tbl,
                                         i_tbl_id_necessity => l_id_necessity_tbl,
                                         i_id_institution   => i_institution,
                                         o_error            => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        /*
        g_error := 'MERGE PAT_NECESSITY';
        MERGE INTO pat_necessity p
        USING (SELECT *
                 FROM pat_necessity
                WHERE id_patient = i_patient
                  AND id_institution = i_prof.institution) p2
        ON (p.id_patient = i_patient AND p.id_institution = i_institution AND p.id_necessity = p2.id_necessity)
        WHEN MATCHED THEN
        -- Actualizar o estado das necessidades existentes na instituição de destino...
            UPDATE
               SET p.flg_status = p2.flg_status, p.id_episode = p2.id_episode
        WHEN NOT MATCHED THEN
        -- ...ou registar as necessidades que não existem, com o estado correspondente da instituição de origem.
            INSERT
                (id_pat_necessity, id_patient, id_necessity, flg_status, id_institution, id_episode)
            VALUES
                (seq_pat_necessity.nextval, i_patient, p2.id_necessity, p2.flg_status, i_institution, i_episode);
        */
        -- Actualizar atributos do paciente.
        -- Prevalecem os atributos registados na instituição de origem, já que são os mais recentes.
    
        /* Merged in Java layer (ADT logic) ADT-2861
        
        g_error := 'MERGE PAT_SOC_ATTRIBUTES';
        MERGE INTO pat_soc_attributes psa
        USING (SELECT psa2.*
                 FROM pat_soc_attributes psa2
                WHERE psa2.id_patient = i_patient
                  AND psa2.id_institution = i_prof.institution) psa2
        ON (psa.id_patient = i_patient AND psa.id_institution = i_institution)
        WHEN MATCHED THEN
            UPDATE
               SET psa.marital_status        = nvl(psa2.marital_status, psa.marital_status),
                   psa.address               = nvl(psa2.address, psa.address),
                   psa.location              = nvl(psa2.location, psa.location),
                   psa.district              = nvl(psa2.district, psa.district),
                   psa.zip_code              = nvl(psa2.zip_code, psa.zip_code),
                   psa.num_main_contact      = nvl(psa2.num_main_contact, psa.num_main_contact),
                   psa.num_contact           = nvl(psa2.num_contact, psa.num_contact),
                   psa.flg_job_status        = nvl(psa2.flg_job_status, psa.flg_job_status),
                   psa.id_country_nation     = nvl(psa2.id_country_nation, psa.id_country_nation),
                   psa.id_country_address    = nvl(psa2.id_country_address, psa.id_country_address),
                   psa.id_scholarship        = nvl(psa2.id_scholarship, psa.id_scholarship),
                   psa.id_religion           = nvl(psa2.id_religion, psa.id_religion),
                   psa.mother_name           = nvl(psa2.mother_name, psa.mother_name),
                   psa.father_name           = nvl(psa2.father_name, psa.father_name),
                   psa.id_isencao            = nvl(psa2.id_isencao, psa.id_isencao),
                   psa.dt_isencao            = nvl(psa2.dt_isencao, psa.dt_isencao),
                   psa.ine_location          = nvl(psa2.ine_location, psa.ine_location),
                   psa.id_language           = nvl(psa2.id_language, psa.id_language),
                   psa.notes                 = nvl(psa2.notes, psa.notes),
                   psa.contact_number_3      = nvl(psa2.contact_number_3, psa.contact_number_3),
                   psa.contact_number_4      = nvl(psa2.contact_number_4, psa.contact_number_4),
                   psa.birth_place           = nvl(psa2.birth_place, psa.birth_place),
                   psa.pension               = nvl(psa2.pension, psa.pension),
                   psa.net_wage              = nvl(psa2.net_wage, psa.net_wage),
                   psa.unemployment_subsidy  = nvl(psa2.unemployment_subsidy, psa.unemployment_subsidy),
                   psa.id_geo_state          = nvl(psa2.id_geo_state, psa.id_geo_state),
                   psa.num_contrib           = nvl(psa2.num_contrib, psa.num_contrib),
                   psa.id_currency_pension   = nvl(psa2.id_currency_pension, psa.id_currency_pension),
                   psa.id_currency_net_wage  = nvl(psa2.id_currency_net_wage, psa.id_currency_net_wage),
                   psa.id_currency_unemp_sub = nvl(psa2.id_currency_unemp_sub, psa.id_currency_unemp_sub),
                   psa.flg_migrator          = nvl(psa2.flg_migrator, psa.flg_migrator),
                   psa.desc_geo_state        = nvl(psa2.desc_geo_state, psa.desc_geo_state),
                   psa.id_episode            = i_episode
        WHEN NOT MATCHED THEN
            INSERT
                (id_pat_soc_attributes,
                 id_patient,
                 marital_status,
                 address,
                 location,
                 district,
                 zip_code,
                 num_main_contact,
                 num_contact,
                 flg_job_status,
                 id_country_nation,
                 id_country_address,
                 id_scholarship,
                 id_religion,
                 mother_name,
                 father_name,
                 id_isencao,
                 id_institution,
                 dt_isencao,
                 ine_location,
                 id_language,
                 notes,
                 contact_number_3,
                 contact_number_4,
                 birth_place,
                 pension,
                 net_wage,
                 unemployment_subsidy,
                 id_geo_state,
                 num_contrib,
                 id_currency_pension,
                 id_currency_net_wage,
                 id_currency_unemp_sub,
                 flg_migrator,
                 desc_geo_state,
                 id_episode)
            valueS
                (seq_pat_soc_attributes.NEXTVAL,
                 i_patient,
                 psa2.marital_status,
                 psa2.address,
                 psa2.location,
                 psa2.district,
                 psa2.zip_code,
                 psa2.num_main_contact,
                 psa2.num_contact,
                 psa2.flg_job_status,
                 psa2.id_country_nation,
                 psa2.id_country_address,
                 psa2.id_scholarship,
                 psa2.id_religion,
                 psa2.mother_name,
                 psa2.father_name,
                 psa2.id_isencao,
                 i_institution,
                 psa2.dt_isencao,
                 psa2.ine_location,
                 psa2.id_language,
                 psa2.notes,
                 psa2.contact_number_3,
                 psa2.contact_number_4,
                 psa2.birth_place,
                 psa2.pension,
                 psa2.net_wage,
                 psa2.unemployment_subsidy,
                 psa2.id_geo_state,
                 psa2.num_contrib,
                 psa2.id_currency_pension,
                 psa2.id_currency_net_wage,
                 psa2.id_currency_unemp_sub,
                 psa2.flg_migrator,
                 psa2.desc_geo_state,
                 i_episode);
        
        */
    
        -- Actualizar planos de saúde
        g_error := 'GET INSTITUTION HEALTH PLAN';
        OPEN c_pat_hplan;
        FETCH c_pat_hplan BULK COLLECT
            INTO l_id_health_plan,
                 l_num_health_plan,
                 l_dt_health_plan,
                 l_flg_default,
                 l_flg_default_epis,
                 l_barcode,
                 l_desc_health_plan;
        CLOSE c_pat_hplan;
    
        IF l_id_health_plan IS NOT NULL
           AND l_id_health_plan.count > 0
        THEN
            g_error := 'SET INSTITUTION HEALTH PLAN';
            IF NOT pk_patient.set_pat_hplan_internal(i_lang,
                                                     i_patient,
                                                     i_episode,
                                                     l_id_health_plan,
                                                     l_num_health_plan,
                                                     l_dt_health_plan,
                                                     l_flg_default,
                                                     l_flg_default_epis,
                                                     l_barcode,
                                                     profissional(0, i_institution, i_software),
                                                     i_prof_cat_type,
                                                     l_desc_health_plan,
                                                     o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'UPDATE_PATIENT_DATA',
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'UPDATE_PATIENT_DATA',
                                              o_error);
            RETURN FALSE;
    END update_patient_data;
    --

    /**********************************************************************************************
    * Devolve os valores possiveis para o compo que indica se é necessário criar cirurgia na alta para internamento o para o bloco
    *
    * @param i_lang      the id language
    * @param l_patient   identificador do pacient 
    * @i_institution     identificador da instituição destino 
    * @i_new_epis_type   identificador do tipo de episódio a gerar. 
    * @param o_error     Error message
    *                        
    * @return            TRUE if sucess, FALSE otherwise
    *
    * @author            Teresa Coutinho
    * @version           1.0  
    * @since             2008/04/28
    **********************************************************************************************/
    FUNCTION discharge_to_new_institution
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_patient        IN patient.id_patient%TYPE,
        i_institution    IN institution.id_institution%TYPE,
        i_new_epis_type  IN epis_type.id_epis_type%TYPE,
        i_sysdate        IN DATE,
        i_sysdate_tstz   IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_prof_cat_type  IN category.flg_type%TYPE,
        i_transaction_id IN VARCHAR2 DEFAULT NULL,
        o_id_episode     OUT episode.id_episode%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_next_visit         NUMBER;
        l_next_epis_inst     NUMBER;
        l_next_epis_ext_sys  NUMBER;
        l_barcode            VARCHAR2(30);
        l_admin_default_room sys_config.value%TYPE;
        l_check_adt          sys_config.value%TYPE;
        l_software           software.id_software%TYPE;
        l_episode            episode.id_episode%TYPE;
        l_new_patient        patient.id_patient%TYPE;
        l_epis_type          episode.id_epis_type%TYPE;
        l_flg_unknown        epis_info.flg_unknown%TYPE;
        -- 
        l_flg_show   VARCHAR2(10);
        l_button     VARCHAR2(10);
        l_msg_title  VARCHAR2(4000);
        l_msg        VARCHAR2(4000);
        l_can_create VARCHAR2(10);
        --    
        -- denormalization variables
        l_rowid_ei table_varchar;
    
        l_rowids_1 table_varchar;
        l_process_event EXCEPTION;
    
        l_no_triage_color triage_color.id_triage_color%TYPE;
    
        l_error_exception EXCEPTION;
        l_data_exception  EXCEPTION;
        -- SCH 3.0 variable
        l_transaction_id VARCHAR2(4000);
    
    BEGIN
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
    
        -- g_sysdate      := nvl(i_sysdate, SYSDATE);
        g_sysdate_tstz := nvl(i_sysdate_tstz, current_timestamp);
        --
        -- novo software
        -- <DENORM RicardoNunoAlmeida> Removido cursor para obter software, substituido por função. 
        g_error    := 'GET l_software';
        l_software := pk_episode.get_soft_by_epis_type(i_new_epis_type, i_institution);
    
        --
        g_error := 'GET_CONFIGURATIONS';
        -- No caso de ser o administrativo a criar um episódio temporário, qual a sala por defieto
        l_admin_default_room := pk_sysconfig.get_config('DEFAULT_ROOM_ORIGIN_UBU', i_institution, l_software); ---alterado por Sílvia Freitas    
        l_check_adt          := pk_sysconfig.get_config('CHECK_ALERT_ADT', i_institution, l_software);
        --
        g_error := 'GET PREV EPISODE TYPE';
        SELECT id_epis_type
          INTO l_epis_type
          FROM episode
         WHERE id_episode = i_episode;
    
        g_error := 'GET FLG_UNKNOWN';
        IF NOT pk_episode.get_flg_unknown(i_lang        => i_lang,
                                          i_prof        => i_prof,
                                          i_id_episode  => i_episode,
                                          o_flg_unknown => l_flg_unknown,
                                          o_error       => o_error)
        THEN
            RAISE l_error_exception;
        END IF;
    
        IF nvl(l_check_adt, g_no) = g_no
           OR l_flg_unknown = g_yes
        THEN
            --
            g_error := 'GET SEQ_VISIT.NEXTVAL';
            SELECT seq_visit.nextval
              INTO l_next_visit
              FROM dual;
            --
            g_error := 'GET SEQ_EPIS_INSTITUTION.NEXTVAL ';
            SELECT seq_epis_institution.nextval
              INTO l_next_epis_inst
              FROM dual;
            --  
            g_error := 'GET SEQ_EPIS_EXT_SYS.NEXTVAL';
            SELECT seq_epis_ext_sys.nextval
              INTO l_next_epis_ext_sys
              FROM dual;
            --
            g_error := 'INSERT INTO VISIT';
            INSERT INTO visit
                (id_visit, dt_begin_tstz, flg_status, id_patient, id_institution, dt_creation)
            VALUES
                (l_next_visit, g_sysdate_tstz, g_visit_active, i_patient, i_institution, g_sysdate_tstz);
            --
            g_error := 'CALL TO PK_BARCODE.GENERATE_BARCODE';
            IF NOT pk_barcode.generate_barcode(i_lang         => i_lang,
                                               i_barcode_type => 'P',
                                               i_institution  => i_institution,
                                               i_software     => l_software,
                                               o_barcode      => l_barcode,
                                               o_error        => o_error)
            THEN
                RAISE l_error_exception;
            END IF;
            --
        
            -- *********************************
            g_error := 'INSERT EPISODE';
            ts_episode.ins(id_patient_in              => i_patient,
                           id_visit_in                => l_next_visit,
                           id_clinical_service_in     => -1,
                           id_department_in           => -1,
                           id_dept_in                 => -1,
                           dt_begin_tstz_in           => g_sysdate_tstz,
                           id_epis_type_in            => i_new_epis_type,
                           flg_status_in              => g_epis_active,
                           barcode_in                 => l_barcode,
                           id_prev_episode_in         => i_episode,
                           dt_creation_in             => g_sysdate_tstz,
                           id_institution_in          => i_institution,
                           id_prev_epis_type_in       => l_epis_type,
                           id_cs_requested_in         => -1,
                           id_department_requested_in => -1,
                           id_dept_requested_in       => -1,
                           id_episode_out             => l_episode,
                           rows_out                   => l_rowids_1);
        
            g_error := 'PROCESS INSERT EPISODE';
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => profissional(0, i_institution, l_software),
                                          i_table_name => 'EPISODE',
                                          i_rowids     => l_rowids_1,
                                          o_error      => o_error);
            -- *********************************
        
            -- José Brito 03/11/2008 Preencher o ID_TRIAGE_COLOR com a côr genérica do 
            -- tipo de triagem usado na instituição de DESTINO
            g_error := 'GET NO TRIAGE COLOR';
            BEGIN
                SELECT tco.id_triage_color
                  INTO l_no_triage_color
                  FROM triage_color tco, triage_type tt
                 WHERE tco.id_triage_type = tt.id_triage_type
                   AND tt.id_triage_type =
                       pk_edis_triage.get_triage_type(i_lang, profissional(0, i_institution, l_software), l_episode)
                   AND tco.flg_type = 'S'
                   AND rownum < 2;
            EXCEPTION
                WHEN no_data_found THEN
                    RAISE l_data_exception;
            END;
            --
            g_error := 'INSERT EPIS_INFO';
            ts_epis_info.ins(id_episode_in               => l_episode,
                             id_schedule_in              => -1,
                             id_room_in                  => l_admin_default_room,
                             flg_unknown_in              => g_unknown,
                             flg_status_in               => g_epis_info_efectiv,
                             dt_last_interaction_tstz_in => g_sysdate_tstz,
                             id_patient_in               => i_patient,
                             id_software_in              => l_software,
                             triage_acuity_in            => pk_alert_constant.g_color_gray,
                             triage_color_text_in        => pk_alert_constant.g_color_white,
                             triage_rank_acuity_in       => pk_alert_constant.g_rank_acuity,
                             id_triage_color_in          => l_no_triage_color,
                             rows_out                    => l_rowid_ei);
        
            g_error := 'PROCESS INSERT EPIS_INFO';
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => profissional(0, i_institution, l_software),
                                          i_table_name => 'EPIS_INFO',
                                          i_rowids     => l_rowid_ei,
                                          o_error      => o_error);
            --
            g_error := 'INSERT DOC TRIAGE ALERT';
            IF NOT pk_edis_triage.set_alert_triage(i_lang,
                                                   profissional(0, i_institution, l_software),
                                                   l_episode,
                                                   g_sysdate_tstz,
                                                   g_alert_nurse,
                                                   g_type_add,
                                                   o_error)
            THEN
                RAISE l_error_exception;
            END IF;
            --   
            g_error := 'INSERT EPIS_INSTITUTION';
            INSERT INTO epis_institution
                (id_epis_institution, id_institution, id_episode)
            VALUES
                (l_next_epis_inst, i_institution, l_episode);
            -- ALERT-41412: AS (03-06-2011)
            g_error := 'CALL PK_ADVANCED_DIRECTIVES.SET_RECURR_PLAN';
            pk_alertlog.log_debug(text => g_error);
            IF NOT pk_advanced_directives.set_recurr_plan(i_lang        => i_lang,
                                                          i_prof        => i_prof,
                                                          i_patient     => i_patient,
                                                          i_new_episode => l_episode,
                                                          o_error       => o_error)
            THEN
                RAISE l_error_exception;
            END IF;
            -- END ALERT-41412
        ELSIF l_check_adt = g_yes
        THEN
            g_error := 'CALL TO CREATE_QUICK_EPISODE';
            IF NOT pk_visit.create_quick_episode(i_lang           => i_lang,
                                                 i_prof           => profissional(i_prof.id, i_institution, l_software),
                                                 i_patient        => i_patient,
                                                 i_test           => g_no,
                                                 i_keys           => NULL,
                                                 i_values         => NULL,
                                                 i_transaction_id => l_transaction_id,
                                                 o_flg_show       => l_flg_show,
                                                 o_button         => l_button,
                                                 o_msg_title      => l_msg_title,
                                                 o_msg            => l_msg,
                                                 o_can_create     => l_can_create,
                                                 o_new_episode    => l_episode,
                                                 o_new_patient    => l_new_patient,
                                                 o_error          => o_error)
            THEN
                RAISE l_error_exception;
            END IF;
        
            l_rowids_1 := table_varchar();
            g_error    := 'UPDATE EPISODE';
            ts_episode.upd(id_episode_in         => l_episode,
                           id_prev_episode_in    => i_episode,
                           id_prev_episode_nin   => FALSE,
                           id_prev_epis_type_in  => l_epis_type,
                           id_prev_epis_type_nin => FALSE,
                           rows_out              => l_rowids_1);
        
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPISODE',
                                          i_rowids       => l_rowids_1,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('ID_PREV_EPISODE', 'ID_PREV_EPIS_TYPE'));
        
            g_error    := 'UPDATE EPIS_INFO';
            l_rowids_1 := table_varchar();
            ts_epis_info.upd(id_episode_in => l_episode,
                             id_room_in    => l_admin_default_room,
                             id_room_nin   => FALSE,
                             rows_out      => l_rowids_1);
        
            t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_INFO', l_rowids_1, o_error, table_varchar('ID_ROOM'));
        
        END IF;
        --
    
        -- José Brito 17/11/2008 ALERT-9759
        IF NOT update_patient_data(i_lang          => i_lang,
                                   i_prof          => i_prof,
                                   i_episode       => l_episode,
                                   i_patient       => i_patient,
                                   i_institution   => i_institution,
                                   i_software      => l_software,
                                   i_prof_cat_type => i_prof_cat_type,
                                   o_error         => o_error)
        THEN
            RAISE l_error_exception;
        END IF;
        --
        --ALERT-70086, ASantos 27-01-2009
        IF NOT pk_diagnosis_core.set_visit_diagnosis(i_lang               => i_lang,
                                                     i_prof               => i_prof,
                                                     i_episode            => l_episode,
                                                     i_tbl_epis_diagnosis => NULL,
                                                     o_error              => o_error)
        THEN
            g_error := 'SET_VISIT_DIAGNOSIS ERROR - ID_EPISODE: ' || l_episode || '; LOG_ID: ' || o_error.log_id;
            pk_alertlog.log_error(text            => g_error,
                                  object_name     => g_package_name,
                                  sub_object_name => 'DISCHARGE_TO_NEW_INSTITUTION');
            RAISE l_error_exception;
        END IF;
    
        --remote scheduler commit. Doesn't affect PFH.
        IF i_transaction_id IS NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
    
        o_id_episode := l_episode;
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_data_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'T_DATA_ERROR',
                                              'TRIAGE COLOR ERROR',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'DISCHARGE_TO_NEW_INSTITUTION',
                                              o_error);
            --remote scheduler rollback. Doesn't affect PFH.
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
        
        WHEN l_error_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'DISCHARGE_TO_NEW_INSTITUTION',
                                              o_error);
            --remote scheduler rollback. Doesn't affect PFH.
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'DISCHARGE_TO_NEW_INSTITUTION',
                                              o_error);
            --remote scheduler rollback. Doesn't affect PFH.
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
        
            RETURN FALSE;
        
    END discharge_to_new_institution;
    --

    /**********************************************************************************************
    * Returns the list of follow-up entities to fill the multichoice displayed
    * after pressing the field "Follow-up with" in the "Discharge Instructions" screen.
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param o_list               List of entities
    * @param o_error              Error message
    *                        
    * @return            TRUE if successful, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/03/13
    **********************************************************************************************/
    FUNCTION get_follow_up_entities
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_list  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        -- Return the list of options to display in the multichoice
        g_error := 'GET FOLLOW-UP LIST';
        pk_alertlog.log_debug(g_error);
        OPEN o_list FOR
            SELECT t.data, t.label
              FROM (SELECT DISTINCT fue.flg_type data,
                                    pk_translation.get_translation(i_lang, fue.code_follow_up_entity) label,
                                    fusi.rank
                      FROM follow_up_entity fue, follow_up_entity_soft_inst fusi
                     WHERE fue.id_follow_up_entity = fusi.id_follow_up_entity
                       AND fusi.flg_available = pk_alert_constant.g_yes
                       AND fusi.id_institution IN (0, i_prof.institution)
                       AND fusi.id_software IN (0, i_prof.software)) t
             ORDER BY t.rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FOLLOW_UP_ENTITIES',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_follow_up_entities;

    /**********************************************************************************************
    * Returns the list of options to fill the multichoice "Create a pending issue..." on the 
    * "Discharge Instructions" screen.
    * Cursor includes the follow-up care groups and the current professional.
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param o_assignees          List of assignees
    * @param o_error              Error message
    *                        
    * @return            TRUE if successful, FALSE otherwise
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/03/19
    **********************************************************************************************/
    FUNCTION get_issue_assignees
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        o_assignees OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'GET ASSIGNEE LIST';
        pk_alertlog.log_debug(g_error);
        OPEN o_assignees FOR
            SELECT data, label, flg_type
              FROM -- Follow-up care groups (FLG_TYPE = 'G')
                   (SELECT DISTINCT 'G' || gd.id_group data, g.name label, 'G' flg_type, 2 rank
                      FROM groups_dept gd, dept d, software_dept sd, groups g
                     WHERE gd.id_dept = d.id_dept
                       AND d.id_dept = sd.id_dept
                       AND d.id_institution = i_prof.institution
                       AND sd.id_software = i_prof.software
                       AND g.id_group = gd.id_group
                       AND g.flg_available = pk_alert_constant.g_yes
                    UNION ALL
                    -- Current professional (FLG_TYPE = 'P')
                    SELECT 'P' || p.id_professional data,
                           pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) label,
                           'P' flg_type,
                           1 rank -- Show this at the top of the list
                      FROM professional p
                     WHERE p.id_professional = i_prof.id
                     ORDER BY rank);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_ISSUE_ASSIGNEES',
                                              o_error);
            pk_types.open_my_cursor(o_assignees);
            pk_alert_exceptions.reset_error_state();
    END get_issue_assignees;
    --

    /**********************************************************************************************
    * Database internal function.
    * Returns the current assignee(s) of the pending issue related to discharge instructions.
    *
    * @param i_lang               language ID
    * @param i_prof               Professional info
    * @param i_id_disch_notes     Discharge Notes ID
    * @param i_id_pending_issue   Pending Issue ID
    * @param i_flg_issue_assign   Issue is assigned to: (P) professional (G) groups
    *                        
    * @return            Text with the current assignees
    *
    * @author            José Brito
    * @version           1.0  
    * @since             2009/03/19
    **********************************************************************************************/
    FUNCTION get_issue_current_assignee
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_disch_notes   IN discharge_notes.id_discharge_notes%TYPE,
        i_id_pending_issue IN pending_issue.id_pending_issue%TYPE,
        i_flg_issue_assign IN discharge_notes.flg_issue_assign%TYPE
    ) RETURN VARCHAR2 IS
        l_assignee VARCHAR2(4000) := NULL;
    BEGIN
    
        IF i_id_disch_notes IS NULL
        THEN
            RETURN NULL;
        ELSIF i_id_pending_issue IS NOT NULL
        THEN
        
            IF i_flg_issue_assign = pk_alert_constant.g_disch_issue_assign_p
            THEN
                -- (P) Professionals
                g_error := 'GET_ISSUE_CURRENT_ASSIGNEE - GET PROFESSIONALS';
                pk_alertlog.log_debug(g_error);
                SELECT pk_utils.concatenate_list(CURSOR
                                                 (SELECT pk_prof_utils.get_name_signature(i_lang,
                                                                                          i_prof,
                                                                                          p.id_professional)
                                                    FROM (SELECT piv.id_involved id_professional
                                                            FROM pending_issue_involved piv, pending_issue p
                                                           WHERE p.id_pending_issue = i_id_pending_issue
                                                             AND piv.id_pending_issue = p.id_pending_issue
                                                             AND piv.flg_involved =
                                                                 pk_alert_constant.g_disch_issue_assign_p
                                                             AND p.flg_status <>
                                                                 pk_pending_issues.g_issue_flg_status_cancelled) p),
                                                 '; ')
                  INTO l_assignee
                  FROM dual;
            
            ELSIF i_flg_issue_assign = pk_alert_constant.g_disch_issue_assign_g
            THEN
                -- (G) Groups
                g_error := 'GET_ISSUE_CURRENT_ASSIGNEE - GET GROUPS';
                pk_alertlog.log_debug(g_error);
                SELECT pk_utils.concatenate_list(CURSOR
                                                 (SELECT g.name
                                                    FROM pending_issue_involved piv, pending_issue p, groups g
                                                   WHERE p.id_pending_issue = i_id_pending_issue
                                                     AND piv.id_pending_issue = p.id_pending_issue
                                                     AND piv.id_involved = g.id_group
                                                     AND piv.flg_involved = pk_alert_constant.g_disch_issue_assign_g
                                                     AND p.flg_status <> pk_pending_issues.g_issue_flg_status_cancelled),
                                                 '; ')
                  INTO l_assignee
                  FROM dual;
            
            ELSE
                RETURN NULL; -- This should not happen
            END IF;
        
        END IF;
    
        RETURN l_assignee;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_issue_current_assignee;
    --
    --#################################################################################################################### --                  
    --
    /**********************************************************************************************
    * Returns the flg_hour_origin corresponding to the expected discharge of a given episode.
    *
    * @param i_lang                ID language
    * @param i_episode             ID of episode
    * @param i_prof                Object with user info
    *
    * @param o_error               Error message
    *
    * @return                      flg_hour_origin ('D'-date;'DH'-date and hour)
    *                        
    * @author                      Sofia Mendes
    * @version                     2.6.0
    * @since                       2009/12/16
    **********************************************************************************************/
    FUNCTION get_dch_sch_flg_hour
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN epis_anamnesis.id_episode%TYPE
    ) RETURN discharge_schedule.flg_hour_origin%TYPE IS
        l_flg_hour_origin discharge_schedule.flg_hour_origin%TYPE := NULL;
        l_error           t_error_out;
    BEGIN
        g_error := 'GET DISCHARGE_SCHEDULE';
        SELECT ds.flg_hour_origin
          INTO l_flg_hour_origin
          FROM discharge_schedule ds
         WHERE ds.id_episode = i_id_episode
           AND ds.flg_status = pk_alert_constant.g_yes
           AND rownum = 1;
    
        RETURN l_flg_hour_origin;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN l_flg_hour_origin;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_DCH_SCH_FLG_HOUR',
                                              o_error    => l_error);
        
            RETURN l_flg_hour_origin;
    END get_dch_sch_flg_hour;

    /**********************************************************************************************
    * Retorna a lista com as datas previstas de alta para um dado episódio
    *
    * @param i_lang                ID language
    * @param i_episode             ID of episode
    * @param i_prof                Object with user info
    *
    * @param o_error               Error message
    *
    * @return                      True on success, false otherwise
    *                        
    * @author                      Alexandre Santos
    * @version                     2.5.
    * @since                       2009/03/30
    **********************************************************************************************/
    FUNCTION get_discharge_schedule_date
    (
        i_lang     IN language.id_language%TYPE,
        i_episode  IN epis_anamnesis.id_episode%TYPE,
        i_prof     IN profissional,
        o_disch_sh OUT pk_types.cursor_type,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'GET DISCHARGE_SCHEDULE';
        OPEN o_disch_sh FOR
            SELECT id_discharge_schedule,
                   id_episode,
                   id_patient,
                   pk_date_utils.date_send_tsz(i_lang, ds.dt_discharge_schedule, i_prof) dt_discharge_schedule_send,
                   --Sofia Mendes (11-12-2009)                   
                   get_formatted_disch_sch_date(i_lang, i_prof, i_episode, ds.dt_discharge_schedule, ds.flg_hour_origin) dt_discharge_schedule,
                   ds.flg_hour_origin,
                   --
                   flg_status,
                   pk_date_utils.date_send_tsz(i_lang, ds.dt_req, i_prof) create_time_send,
                   pk_date_utils.date_char_tsz(i_lang, ds.dt_req, i_prof.institution, i_prof.software) create_time,
                   id_prof_req create_user,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, ds.id_prof_req) nickname,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, ds.id_prof_req, ds.dt_req, i_episode) desc_speciality
              FROM discharge_schedule ds
             WHERE ds.id_episode = i_episode
             ORDER BY ds.flg_status DESC, ds.dt_discharge_schedule DESC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_DISCHARGE_SCHEDULE_DATE',
                                              o_error    => o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_disch_sh);
            RETURN FALSE;
    END get_discharge_schedule_date;

    /**********************************************************************************************
    * Returns the disposition date and label.
    *
    * @param i_lang                          ID language
    * @param i_prof                          Logged professional
    * @param i_row_ei                        EPIS_INFO row_type
    * 
    * @param o_disp_date                     Disposition date
    * @param o_disp_date_tstz                Disposition date (timestamp with local time zone)
    * @param o_disp_label                    Disposition label
    * @param o_error                         Error message
    *
    * @return                                True on success, false otherwise
    *                        
    * @author                                Luís Maia
    * @version                               2.6.0.3.2
    * @since                                 2010-Ago-31
    * 
    **********************************************************************************************/
    FUNCTION get_inp_disposition_date
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_row_ei         IN epis_info%ROWTYPE,
        o_disp_date      OUT VARCHAR2,
        o_disp_date_tstz OUT epis_info.dt_med_tstz%TYPE,
        o_disp_label     OUT VARCHAR2,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_dt_discharge_tstz     epis_info.dt_med_tstz%TYPE;
        l_dt_adm_discharge_tstz epis_info.dt_admin_tstz%TYPE;
        l_flg_disch_shec        epis_info.flg_dsch_status%TYPE;
        l_error                 t_error_out;
    BEGIN
        l_dt_discharge_tstz := i_row_ei.dt_med_tstz;
    
        l_flg_disch_shec        := i_row_ei.flg_dsch_status;
        l_dt_adm_discharge_tstz := i_row_ei.dt_admin_tstz;
    
        IF l_flg_disch_shec = 'A'
        THEN
            IF (l_dt_adm_discharge_tstz IS NULL)
            THEN
                o_disp_label := pk_message.get_message(i_lang, i_prof, 'INP_ID_T006');
            ELSE
                o_disp_label := pk_message.get_message(i_lang, i_prof, 'INP_MAIN_GRID_DISCHARGE_T005');
            END IF;
        ELSIF l_flg_disch_shec = 'P'
        THEN
            o_disp_label := pk_message.get_message(i_lang, i_prof, 'INP_MAIN_GRID_DISCHARGE_T002');
            --Sofia Mendes (7-12-2009): in cases of pending discharge that the epis_info.dt_med_tstz is not filled
            IF l_dt_discharge_tstz IS NULL
            THEN
                IF NOT pk_discharge.get_discharge_date(i_lang                 => i_lang,
                                                       i_prof                 => i_prof,
                                                       i_id_episode           => i_row_ei.id_episode,
                                                       o_discharge_date       => l_dt_discharge_tstz,
                                                       o_flg_discharge_status => l_flg_disch_shec,
                                                       o_error                => l_error)
                THEN
                    NULL;
                END IF;
            END IF;
            --
        ELSE
            o_disp_label := pk_message.get_message(i_lang, i_prof, 'INP_ID_T007');
        
            l_dt_discharge_tstz     := NULL;
            l_dt_adm_discharge_tstz := NULL;
        
            IF (i_prof.software IN (pk_alert_constant.g_soft_inpatient, pk_alert_constant.g_soft_act_therapist))
            THEN
                IF (l_dt_discharge_tstz IS NULL AND l_dt_adm_discharge_tstz IS NULL AND
                   (l_flg_disch_shec IS NULL OR l_flg_disch_shec NOT IN ('A', 'P')) OR l_flg_disch_shec = 'C' OR
                   l_flg_disch_shec = 'R')
                THEN
                    BEGIN
                        SELECT ds.dt_discharge_schedule
                          INTO l_dt_discharge_tstz
                          FROM discharge_schedule ds
                         WHERE ds.id_episode = i_row_ei.id_episode
                           AND ds.flg_status = 'Y'
                           AND rownum = 1;
                    EXCEPTION
                        WHEN no_data_found THEN
                            IF l_flg_disch_shec = 'C'
                            THEN
                                l_dt_discharge_tstz := NULL;
                            END IF;
                    END;
                
                    --l_flg_disch_shec := 'S';
                END IF;
            END IF;
        END IF;
    
        IF l_dt_discharge_tstz IS NULL
           AND l_dt_adm_discharge_tstz IS NULL
        THEN
            o_disp_date      := '---';
            o_disp_date_tstz := NULL;
        ELSE
            IF (l_dt_adm_discharge_tstz IS NOT NULL)
            THEN
                l_dt_discharge_tstz := l_dt_adm_discharge_tstz;
            END IF;
        
            o_disp_date      := pk_date_utils.dt_chr_tsz(i_lang, l_dt_discharge_tstz, i_prof);
            o_disp_date_tstz := l_dt_discharge_tstz;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_INP_DISPOSITION_DATE',
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_inp_disposition_date;

    /**********************************************************************************************
    * Define a data de alta prevista para um dado episódio
    *
    * @param i_lang                          ID language
    * @param i_episode                       ID of episode
    * @param i_prof                          Object with user info
    * @param i_dt_discharge_schedule         New discharge schedule date
    * @param i_flg_hour_origin               flg hour origin
    * @param  i_transaction_id               remote transaction identifier
    * @param i_allocation_commit             Indicates if bed allocation should sent information to scheduler 3.0 ('Y' - Yes; 'N' - No)
    *
    * @param o_id_discharge_schedule         New ID record
    * @param o_error                         Error message
    *
    * @return                                True on success, false otherwise
    *                        
    * @author                                Alexandre Santos
    * @version                               2.5.
    * @since                                 2009/03/30
    * 
    * Sofia Mendes (27-05-2009): - New funtion set_discharge_sch_dt:
    *                               (contains the same code as previously the function set_discharge_schedule_date).
    *                               It was created to avoid recursive calls because with the incorporation of the 
    *                               Admissions scheduler, when an admission schedule is created it is necessary to 
    *                               change the discharge date and when the discharge date is changed it is necessary to 
    *                               change the schedule end date.
    *                            - Remove commit on function set_discharge_schedule_date
    **********************************************************************************************/
    FUNCTION set_discharge_sch_dt_int
    (
        i_lang                  IN language.id_language%TYPE,
        i_episode               IN discharge_schedule.id_episode%TYPE,
        i_patient               IN discharge_schedule.id_patient%TYPE,
        i_prof                  IN profissional,
        i_dt_discharge_schedule IN VARCHAR2,
        i_flg_hour_origin       IN VARCHAR2 DEFAULT 'DH',
        i_transaction_id        IN VARCHAR2,
        i_allocation_commit     IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        o_id_discharge_schedule OUT discharge_schedule.id_discharge_schedule%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rows                      table_varchar;
        l_new_id_discharge_schedule discharge_schedule.id_discharge_schedule%TYPE;
        l_bed_flg_type              bed.flg_type%TYPE;
        l_id_bed                    epis_info.id_bed%TYPE;
        l_transaction_id            VARCHAR2(4000);
        l_old_dt_discharge_sched    discharge_schedule.dt_discharge_schedule%TYPE;
        l_new_dt_discharge_sched    discharge_schedule.dt_discharge_schedule%TYPE;
        l_bmng_action_start_date    bmng_action.dt_begin_action%TYPE;
        l_bmng_action_end_date      bmng_action.dt_end_action%TYPE;
        l_id_resource_ext           bmng_scheduler_map.id_resource_ext%TYPE;
        l_id_bmng                   bmng_allocation_bed.id_bmng_allocation_bed%TYPE;
        --
        err_set_first_obs EXCEPTION;
        l_err             EXCEPTION;
    BEGIN
        g_sysdate_tstz           := current_timestamp;
        l_new_dt_discharge_sched := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_discharge_schedule, NULL);
    
        BEGIN
            SELECT ds.dt_discharge_schedule
              INTO l_old_dt_discharge_sched
              FROM discharge_schedule ds
             WHERE ds.id_episode = i_episode
               AND ds.flg_status = pk_alert_constant.g_yes
               AND rownum = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_old_dt_discharge_sched := NULL;
        END;
    
        g_error := 'UPDATE FLG_STATUS';
        pk_alertlog.log_debug(g_error);
        ts_discharge_schedule.upd(flg_status_in => pk_alert_constant.g_no,
                                  where_in      => 'id_episode = ' || i_episode,
                                  rows_out      => l_rows);
        --
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'DISCHARGE_SCHEDULE',
                                      i_list_columns => table_varchar('flg_status'),
                                      i_rowids       => l_rows,
                                      o_error        => o_error);
        --
        g_error := 'GET DISCHARGE SCHEDULE NEXT KEY';
        pk_alertlog.log_debug(g_error);
        l_new_id_discharge_schedule := ts_discharge_schedule.next_key;
    
        g_error := 'INSERT NEW DISCHARGE SCHEDULE';
        pk_alertlog.log_debug(g_error);
        l_rows := table_varchar();
        ts_discharge_schedule.ins(id_discharge_schedule_in => l_new_id_discharge_schedule,
                                  id_episode_in            => i_episode,
                                  id_patient_in            => i_patient,
                                  dt_discharge_schedule_in => l_new_dt_discharge_sched,
                                  flg_hour_origin_in       => i_flg_hour_origin,
                                  flg_status_in            => pk_alert_constant.g_yes,
                                  dt_req_in                => g_sysdate_tstz,
                                  id_prof_req_in           => i_prof.id,
                                  rows_out                 => l_rows);
        --                          
        t_data_gov_mnt.process_insert(i_lang, i_prof, 'DISCHARGE_SCHEDULE', l_rows, o_error);
    
        BEGIN
            SELECT ei.id_bed, b.flg_type
              INTO l_id_bed, l_bed_flg_type
              FROM epis_info ei
             INNER JOIN bed b
                ON (b.id_bed = ei.id_bed)
             WHERE ei.id_episode = i_episode;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_bed       := NULL;
                l_bed_flg_type := NULL;
        END;
    
        pk_alertlog.log_debug('***Condition: l_id_bed = ' || l_id_bed || ' l_bed_flg_type = ' || l_bed_flg_type ||
                              ' i_allocation_commit = ' || i_allocation_commit || ' i_dt_discharge_schedule: ' ||
                              i_dt_discharge_schedule);
        IF l_id_bed IS NOT NULL
           AND l_bed_flg_type = pk_bmng_constant.g_bmng_bed_flg_type_p
           AND i_allocation_commit = pk_alert_constant.g_yes
        THEN
            --get the blocking begin and end date to send to the new scheduler in edition action
            g_error := 'CALL TO pk_bmng_core.get_bmng_action_dt';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_bmng_core.get_bmng_action_dt(i_lang                   => i_lang,
                                                   i_prof                   => i_prof,
                                                   i_id_bed                 => l_id_bed,
                                                   o_bmng_action_start_date => l_bmng_action_start_date,
                                                   o_bmng_action_end_date   => l_bmng_action_end_date,
                                                   o_error                  => o_error)
            THEN
                RETURN FALSE;
            END IF;
        
            IF l_bmng_action_start_date IS NOT NULL
            THEN
                --
                g_error := 'GET SCHEDULER RESOURCE ID';
                pk_alertlog.log_debug(g_error);
                BEGIN
                    SELECT bsm.id_resource_pfh, bsm.id_resource_ext
                      INTO l_id_bmng, l_id_resource_ext
                      FROM bmng_allocation_bed bab
                      JOIN bmng_scheduler_map bsm
                        ON bsm.id_resource_pfh = bab.id_bmng_allocation_bed
                     WHERE bab.flg_outdated = g_no
                       AND bab.id_bed = l_id_bed;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_id_resource_ext := NULL;
                END;
            
                -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
                g_error := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                pk_alertlog.log_debug(g_error);
                l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
            
                g_error := 'CALL TO PK_SCHEDULE_API_UPSTREAM.UPDATE_ALLOCATED_BED';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_schedule_api_upstream.update_allocated_bed(i_lang           => i_lang,
                                                                     i_prof           => i_prof,
                                                                     i_transaction_id => l_transaction_id,
                                                                     i_id_patient     => i_patient,
                                                                     i_id_bed         => l_id_bed,
                                                                     i_start_date     => l_bmng_action_start_date,
                                                                     i_end_date       => l_old_dt_discharge_sched,
                                                                     i_new_end_date   => l_new_dt_discharge_sched,
                                                                     i_id_resource    => l_id_resource_ext,
                                                                     i_id_bmng        => l_id_bmng,
                                                                     o_error          => o_error)
                THEN
                    pk_alertlog.log_error('ERROR: Function pk_schedule_api_upstream.update_allocated_bed. ID_BED=' ||
                                          l_id_bed || ' START_DATE=' || CAST(l_bmng_action_start_date AS VARCHAR2) ||
                                          ' END_DATE=' || CAST(l_old_dt_discharge_sched AS VARCHAR2) || ' ID_PATIENT=' ||
                                          i_patient || ' NEW_END_DATE=' || CAST(l_new_dt_discharge_sched AS VARCHAR2));
                    pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                    RAISE l_err;
                END IF;
                pk_alertlog.log_debug('DEBUG: CALLED Function pk_schedule_api_upstream.update_allocated_bed. ID_BED=' ||
                                      l_id_bed || ' START_DATE=' || CAST(l_bmng_action_start_date AS VARCHAR2) ||
                                      ' END_DATE=' || CAST(l_old_dt_discharge_sched AS VARCHAR2) || ' ID_PATIENT=' ||
                                      i_patient || ' NEW_END_DATE=' || CAST(l_new_dt_discharge_sched AS VARCHAR2));
            
                IF (i_transaction_id IS NULL)
                THEN
                    pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
                END IF;
            
            END IF;
        END IF;
    
        --
        o_id_discharge_schedule := l_new_id_discharge_schedule;
    
        g_error := 'CALL TO pk_visit.set_first_obs';
        pk_alertlog.log_debug(g_error);
        IF NOT
            pk_visit.set_first_obs(i_lang                => i_lang,
                                   i_id_episode          => i_episode,
                                   i_pat                 => i_patient,
                                   i_prof                => i_prof,
                                   i_prof_cat_type       => pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof),
                                   i_dt_last_interaction => g_sysdate_tstz,
                                   i_dt_first_obs        => g_sysdate_tstz,
                                   o_error               => o_error)
        THEN
            RAISE err_set_first_obs;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_err THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_SCH_DT_INT',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'SET_DISCHARGE_SCH_DT_INT',
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_discharge_sch_dt_int;

    /**********************************************************************************************
    * Define a data de alta prevista para um dado episódio
    *
    * @param i_lang                          ID language
    * @param i_episode                       ID of episode
    * @param i_prof                          Object with user info
    * @param i_dt_discharge_schedule         New discharge schedule date
    *
    * @param o_id_discharge_schedule         New ID record
    * @param o_error                         Error message
    *
    * @return                                True on success, false otherwise
    *                        
    * @author                                Alexandre Santos
    * @version                               2.5.
    * @since                                 2009/03/30
    * 
    * Sofia Mendes (27-05-2009): - New funtion set_discharge_sch_dt:
    *                               (contains the same code as previously the function set_discharge_schedule_date).
    *                               It was created to avoid recursive calls because with the incorporation of the 
    *                               Admissions scheduler, when an admission schedule is created it is necessary to 
    *                               change the discharge date and when the discharge date is changed it is necessary to 
    *                               change the schedule end date.
    *                            - Remove commit on function set_discharge_schedule_date
    **********************************************************************************************/
    FUNCTION set_discharge_sch_dt
    (
        i_lang                  IN language.id_language%TYPE,
        i_episode               IN discharge_schedule.id_episode%TYPE,
        i_patient               IN discharge_schedule.id_patient%TYPE,
        i_prof                  IN profissional,
        i_dt_discharge_schedule IN VARCHAR2,
        i_flg_hour_origin       IN VARCHAR2 DEFAULT 'DH',
        o_id_discharge_schedule OUT discharge_schedule.id_discharge_schedule%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'CALL PK_DISCHARGE.SET_DISCHARGE_SCH_DT_INT WITH ID_EPISODE ' || i_episode;
        pk_alertlog.log_debug(g_error);
        IF NOT set_discharge_sch_dt_int(i_lang                  => i_lang,
                                        i_episode               => i_episode,
                                        i_patient               => i_patient,
                                        i_prof                  => i_prof,
                                        i_dt_discharge_schedule => i_dt_discharge_schedule,
                                        i_transaction_id        => NULL,
                                        i_flg_hour_origin       => i_flg_hour_origin,
                                        o_id_discharge_schedule => o_id_discharge_schedule,
                                        o_error                 => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'SET_DISCHARGE_SCH_DT',
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_discharge_sch_dt;

    FUNCTION set_discharge_schedule_date
    (
        i_lang                  IN language.id_language%TYPE,
        i_episode               IN discharge_schedule.id_episode%TYPE,
        i_patient               IN discharge_schedule.id_patient%TYPE,
        i_prof                  IN profissional,
        i_dt_discharge_schedule IN VARCHAR2,
        i_flg_hour_origin       IN VARCHAR2 DEFAULT 'DH',
        o_id_discharge_schedule OUT discharge_schedule.id_discharge_schedule%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'CALL set_discharge_sch_dt';
        pk_alertlog.log_debug(g_error);
        IF NOT (set_discharge_sch_dt(i_lang                  => i_lang,
                                     i_episode               => i_episode,
                                     i_patient               => i_patient,
                                     i_prof                  => i_prof,
                                     i_dt_discharge_schedule => i_dt_discharge_schedule,
                                     i_flg_hour_origin       => i_flg_hour_origin,
                                     o_id_discharge_schedule => o_id_discharge_schedule,
                                     o_error                 => o_error))
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => 'SET_DISCHARGE_SCHEDULE_DATE',
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_discharge_schedule_date;

    /**********************************************************************************************
    * SET_NEW_MATCH_EPIS_DS                  This function make "match" of discharge schedule registries between episodes
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_episode_temp                  Temporary episode
    * @param i_episode                       Episode identifier 
    * @param o_error                         Error object
    *
    * @return                                Success / fail
    *
    * @author                                Luís Maia
    * @version                               2.5.2
    * @since                                 2012/03/05
    **********************************************************************************************/
    FUNCTION set_new_match_epis_ds
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode_temp IN episode.id_episode%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rowids             table_varchar := table_varchar();
        l_num_epis_active_ds PLS_INTEGER := 0;
    BEGIN
        SELECT COUNT(1)
          INTO l_num_epis_active_ds
          FROM discharge_schedule ds
         WHERE ds.id_episode = i_episode
           AND ds.flg_status = pk_alert_constant.g_yes;
    
        g_error  := 'UPDATE DISCHARGE_SCHEDULE';
        l_rowids := table_varchar();
        IF l_num_epis_active_ds = 0
        THEN
            ts_discharge_schedule.upd(id_episode_in => i_episode,
                                      where_in      => 'id_episode = ' || i_episode_temp,
                                      rows_out      => l_rowids);
        ELSE
            ts_discharge_schedule.upd(id_episode_in => i_episode,
                                      flg_status_in => pk_alert_constant.g_no,
                                      where_in      => 'id_episode = ' || i_episode_temp,
                                      rows_out      => l_rowids);
        END IF;
    
        --
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'DISCHARGE_SCHEDULE',
                                      i_list_columns => table_varchar('id_episode', 'flg_status'),
                                      i_rowids       => l_rowids,
                                      o_error        => o_error);
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => 'ALERT',
                                              i_package  => 'PK_DISCHARGE',
                                              i_function => 'SET_NEW_MATCH_EPIS',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_new_match_epis_ds;

    /********************************************************************************************
    * Register discharge history. For ambulatory products.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_disch                 discharge identifier
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         28/05/2009
    ********************************************************************************************/
    FUNCTION set_disch_hist_amb
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        i_disch IN discharge.id_discharge%TYPE,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_prof_templ profile_template.id_profile_template%TYPE;
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        g_error      := 'CALL pk_tools.get_prof_profile_template';
        l_prof_templ := pk_tools.get_prof_profile_template(i_prof);
    
        g_error := 'INSERT INTO discharge_hist';
        INSERT INTO discharge_hist
            (id_discharge_hist,
             id_discharge,
             id_disch_reas_dest,
             id_episode,
             id_prof_cancel,
             notes_cancel,
             id_prof_med,
             notes_med,
             flg_status,
             id_discharge_status,
             flg_type,
             dt_med_tstz,
             dt_cancel_tstz,
             id_profile_template,
             id_prof_created_hist,
             dt_created_hist)
            SELECT seq_discharge_hist.nextval id_discharge_hist,
                   d.id_discharge,
                   d.id_disch_reas_dest,
                   d.id_episode,
                   d.id_prof_cancel,
                   d.notes_cancel,
                   d.id_prof_med,
                   d.notes_med,
                   d.flg_status,
                   d.id_discharge_status,
                   d.flg_type,
                   d.dt_med_tstz,
                   d.dt_cancel_tstz,
                   l_prof_templ,
                   i_prof.id                  id_prof_created_hist,
                   g_sysdate_tstz             dt_created_hist
              FROM discharge d
             WHERE d.id_discharge = i_disch;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     g_owner,
                                                     g_package_name,
                                                     'SET_DISCH_HIST_AMB',
                                                     o_error);
    END set_disch_hist_amb;

    /********************************************************************************************
    * Used in ambulatory products. Adapted from GET_DISCHARGE.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_disch                 discharge identifier
    * @param i_episode               episode identifier
    * @param o_disch                 cursor
    * @param o_min_dt                contact end date left bound
    * @param o_max_dt                contact end date right bound
    * @param o_flg_warn              show no contact start date warning (Y/N)
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         28/05/2009
    ********************************************************************************************/
    FUNCTION get_discharge_amb
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_disch    IN discharge.id_discharge%TYPE,
        i_episode  IN episode.id_episode%TYPE,
        o_disch    OUT pk_types.cursor_type,
        o_min_dt   OUT VARCHAR2,
        o_max_dt   OUT VARCHAR2,
        o_flg_warn OUT VARCHAR2,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_dt_begin      episode.dt_begin_tstz%TYPE;
        l_dt_send       VARCHAR2(100);
        l_def_disch_rea discharge_reason.id_discharge_reason%TYPE;
    
        CURSOR c_dt_begin IS
            SELECT ei.dt_init
              FROM epis_info ei
             WHERE ei.id_episode = i_episode;
    
    BEGIN
        g_sysdate_tstz  := current_timestamp;
        l_def_disch_rea := pk_sysconfig.get_config('CARE_DISCHARGE_REASON', i_prof);
    
        g_error := 'OPEN c_dt_begin';
        OPEN c_dt_begin;
        FETCH c_dt_begin
            INTO l_dt_begin;
    
        CLOSE c_dt_begin;
    
        IF l_dt_begin IS NOT NULL
        THEN
            -- episode has begin date: set it as end date left bound
            o_min_dt   := pk_date_utils.date_send_tsz(i_lang, l_dt_begin, i_prof);
            o_flg_warn := pk_alert_constant.g_no;
        ELSE
            -- episode has no begin date, prompt for warning
            o_min_dt   := NULL;
            o_flg_warn := pk_alert_constant.g_yes;
        END IF;
    
        -- end date right bound is current date
        l_dt_send := pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof);
        o_max_dt  := l_dt_send;
    
        IF i_disch IS NULL
        THEN
            g_error := 'OPEN o_disch (no ID)';
            OPEN o_disch FOR
                SELECT l_dt_send end_date,
                       id_discharge_dest,
                       pk_translation.get_translation(i_lang, code_discharge_dest) desc_discharge_dest,
                       NULL notes
                  FROM (SELECT drd.id_disch_reas_dest id_discharge_dest, dd.code_discharge_dest
                          FROM disch_reas_dest drd
                          LEFT JOIN discharge_dest dd
                         USING (id_discharge_dest)
                         WHERE drd.id_discharge_reason = l_def_disch_rea
                           AND drd.id_instit_param = i_prof.institution
                           AND drd.id_software_param = i_prof.software
                           AND drd.flg_active = g_disch_flg_active
                           AND dd.flg_available = g_yes
                         ORDER BY drd.rank)
                 WHERE rownum < 2;
        ELSE
            g_error := 'OPEN o_disch';
            OPEN o_disch FOR
                SELECT pk_date_utils.date_send_tsz(i_lang, d.dt_med_tstz, i_prof) end_date,
                       id_disch_reas_dest id_discharge_dest,
                       pk_translation.get_translation(i_lang, dd.code_discharge_dest) desc_discharge_dest,
                       d.notes_med notes
                  FROM discharge d
                  LEFT JOIN disch_reas_dest drd
                 USING (id_disch_reas_dest)
                  LEFT JOIN discharge_dest dd
                 USING (id_discharge_dest)
                 WHERE d.id_discharge = i_disch;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_AMB',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_disch);
            RETURN FALSE;
    END get_discharge_amb;

    /********************************************************************************************
    * Retrieve discharges, in ambulatory products. Adapted from GET_DISCHARGE.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_episode               episode identifier
    * @param o_disch                 cursor
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         28/05/2009
    ********************************************************************************************/
    FUNCTION get_discharges_amb
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        o_disch   OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        RETURN pk_discharge_core.get_discharges_amb(i_lang    => i_lang,
                                                    i_prof    => i_prof,
                                                    i_episode => i_episode,
                                                    o_disch   => o_disch,
                                                    o_error   => o_error);
    END get_discharges_amb;

    /********************************************************************************************
    * Cancels a discharge, in ambulatory products.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_disch                 discharge identifier
    * @param i_canc_reas             cancel reason identifier
    * @param i_canc_notes            cancel notes
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         28/05/2009
    ********************************************************************************************/
    FUNCTION cancel_discharge_amb
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_disch      IN discharge.id_discharge%TYPE,
        i_canc_reas  IN cancel_reason.id_cancel_reason%TYPE,
        i_canc_notes IN discharge.notes_cancel%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF i_disch IS NOT NULL
        THEN
            g_error := 'UPDATE ' || i_disch;
            IF cancel_discharge(i_lang             => i_lang,
                                i_id_discharge     => i_disch,
                                i_prof             => i_prof,
                                i_id_cancel_reason => i_canc_reas,
                                i_notes_cancel     => i_canc_notes,
                                o_error            => o_error)
            THEN
                g_error := 'CALL set_disch_hist_amb';
                IF NOT set_disch_hist_amb(i_lang, i_prof, i_disch, o_error)
                THEN
                    RAISE g_exception;
                END IF;
            ELSE
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN g_exception THEN
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_DISCHARGE_AMB',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END cancel_discharge_amb;

    /********************************************************************************************
    * Sets a discharge, in ambulatory products.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_prof_cat              logged professional category
    * @param i_disch                 discharge identifier
    * @param i_episode               episode identifier
    * @param i_dt_end                discharge date
    * @param i_disch_dest            discharge reason destiny identifier
    * @param i_notes                 discharge notes_med
    * @param o_flg_show              warm
    * @param o_msg_title             warn
    * @param o_msg_text              warn
    * @param o_button                warn
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         28/05/2009
    ********************************************************************************************/
    FUNCTION set_discharge_amb
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_prof_cat   IN category.flg_type%TYPE,
        i_disch      IN discharge.id_discharge%TYPE,
        i_episode    IN episode.id_episode%TYPE,
        i_dt_end     IN VARCHAR2,
        i_disch_dest IN disch_reas_dest.id_disch_reas_dest%TYPE,
        i_notes      IN discharge.notes_med%TYPE,
        o_flg_show   OUT VARCHAR2,
        o_msg_title  OUT VARCHAR2,
        o_msg_text   OUT VARCHAR2,
        o_button     OUT VARCHAR2,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        IF NOT set_discharge_amb(i_lang           => i_lang,
                                 i_prof           => i_prof,
                                 i_prof_cat       => i_prof_cat,
                                 i_disch          => i_disch,
                                 i_episode        => i_episode,
                                 i_dt_end         => i_dt_end,
                                 i_disch_dest     => i_disch_dest,
                                 i_notes          => i_notes,
                                 i_transaction_id => NULL,
                                 o_flg_show       => o_flg_show,
                                 o_msg_title      => o_msg_title,
                                 o_msg_text       => o_msg_text,
                                 o_button         => o_button,
                                 o_error          => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_AMB',
                                              o_error);
            RETURN FALSE;
    END set_discharge_amb;

    /********************************************************************************************
    * Sets a discharge, in ambulatory products.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_prof_cat              logged professional category
    * @param i_disch                 discharge identifier
    * @param i_episode               episode identifier
    * @param i_dt_end                discharge date
    * @param i_disch_dest            discharge reason destiny identifier
    * @param i_notes                 discharge notes_med
    * @param o_flg_show              warm
    * @param o_msg_title             warn
    * @param o_msg_text              warn
    * @param o_button                warn
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         28/05/2009
    ********************************************************************************************/
    FUNCTION set_discharge_amb
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_prof_cat       IN category.flg_type%TYPE,
        i_disch          IN discharge.id_discharge%TYPE,
        i_episode        IN episode.id_episode%TYPE,
        i_dt_end         IN VARCHAR2,
        i_disch_dest     IN disch_reas_dest.id_disch_reas_dest%TYPE,
        i_notes          IN discharge.notes_med%TYPE,
        i_transaction_id IN VARCHAR2,
        o_flg_show       OUT VARCHAR2,
        o_msg_title      OUT VARCHAR2,
        o_msg_text       OUT VARCHAR2,
        o_button         OUT VARCHAR2,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_dt_end  discharge.dt_med_tstz%TYPE;
        l_disch   discharge.id_discharge%TYPE;
        l_episode episode.id_episode%TYPE;
        --l_message      sys_message.desc_message%TYPE;
        --l_temp         VARCHAR2(16);
        l_reports_pat  reports.id_reports%TYPE;
        l_id_shortcut  sys_shortcut.id_sys_shortcut%TYPE;
        l_discharge    discharge.id_discharge%TYPE;
        l_disch_detail discharge_detail.id_discharge_detail%TYPE;
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
    
    BEGIN
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
    
        l_disch  := i_disch;
        l_dt_end := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                  i_prof      => i_prof,
                                                  i_timestamp => i_dt_end,
                                                  i_timezone  => NULL);
    
        IF l_disch IS NULL
        THEN
        
            g_error := 'CALL set_discharge_no_commit';
            IF NOT set_discharge_no_commit(i_lang             => i_lang,
                                           i_episode          => i_episode,
                                           i_prof             => i_prof,
                                           i_reas_dest        => i_disch_dest,
                                           i_disch_type       => g_disch_type_f,
                                           i_flg_type         => g_doctor,
                                           i_notes            => i_notes,
                                           i_transp           => NULL,
                                           i_justify          => NULL,
                                           i_prof_cat_type    => i_prof_cat,
                                           i_price            => NULL,
                                           i_currency         => NULL,
                                           i_flg_payment      => NULL,
                                           i_flg_surgery      => NULL,
                                           i_dt_surgery       => NULL,
                                           i_clin_serv        => NULL,
                                           i_department       => NULL,
                                           i_flg_bill_type    => NULL,
                                           i_flg_letter       => NULL,
                                           i_flg_task         => NULL,
                                           i_transaction_id   => l_transaction_id,
                                           i_flg_hist         => pk_alert_constant.g_no,
                                           o_reports_pat      => l_reports_pat,
                                           o_flg_show         => o_flg_show,
                                           o_msg_title        => o_msg_title,
                                           o_msg_text         => o_msg_text,
                                           o_button           => o_button,
                                           o_id_episode       => l_episode,
                                           o_id_shortcut      => l_id_shortcut,
                                           o_discharge        => l_discharge,
                                           o_discharge_detail => l_disch_detail,
                                           o_error            => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'SELECT l_disch';
            SELECT d.id_discharge
              INTO l_disch
              FROM discharge d
             WHERE d.id_episode = i_episode
               AND d.id_prof_med = i_prof.id
               AND d.flg_status != g_disch_flg_cancel;
        
            g_error := 'UPDATE A ' || l_disch;
            UPDATE discharge d
               SET d.dt_med_tstz = l_dt_end
             WHERE d.id_discharge = l_disch;
        
        ELSE
            g_error := 'UPDATE B ' || l_disch;
            UPDATE discharge d
               SET d.id_disch_reas_dest = i_disch_dest, d.dt_med_tstz = l_dt_end, d.notes_med = i_notes
             WHERE d.id_discharge = l_disch;
        END IF;
    
        g_error := 'CALL set_disch_hist_amb';
        IF NOT set_disch_hist_amb(i_lang => i_lang, i_prof => i_prof, i_disch => l_disch, o_error => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF i_transaction_id IS NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
            COMMIT;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN g_exception THEN
            pk_utils.undo_changes;
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_AMB',
                                              o_error);
            pk_utils.undo_changes;
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_discharge_amb;

    /********************************************************************************************
    * Retrieves discharge destinations, in ambulatory products.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param o_dests                 cursor
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         28/05/2009
    ********************************************************************************************/
    FUNCTION get_disch_dest_amb
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_dests OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_def_disch_rea discharge_reason.id_discharge_reason%TYPE;
    BEGIN
        l_def_disch_rea := pk_sysconfig.get_config('CARE_DISCHARGE_REASON', i_prof);
    
        g_error := 'OPEN o_dests';
        OPEN o_dests FOR
            SELECT drd.id_disch_reas_dest id_discharge_dest,
                   pk_translation.get_translation(i_lang, dd.code_discharge_dest) desc_discharge_dest
              FROM disch_reas_dest drd
              JOIN discharge_dest dd
             USING (id_discharge_dest)
             WHERE drd.id_discharge_reason = l_def_disch_rea
               AND drd.id_instit_param = i_prof.institution
               AND drd.id_software_param = i_prof.software
               AND drd.flg_active = g_disch_flg_active
               AND dd.flg_available = g_yes
             ORDER BY dd.rank;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCH_DEST_AMB',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_dests);
            RETURN FALSE;
    END get_disch_dest_amb;

    /********************************************************************************************
    * Retrieves a discharge record history of operations, in ambulatory products.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_disch                 discharge identifier
    * @param o_hist                  cursor
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         28/05/2009
    ********************************************************************************************/
    FUNCTION get_disch_hist_amb
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        i_disch IN discharge.id_discharge%TYPE,
        o_hist  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        RETURN pk_discharge_core.get_disch_hist_amb(i_lang  => i_lang,
                                                    i_prof  => i_prof,
                                                    i_disch => i_disch,
                                                    o_hist  => o_hist,
                                                    o_error => o_error);
    END get_disch_hist_amb;

    /********************************************************************************************
    * Similar to GET_ALL_DIS_NOTES_CARE, but only sends out printed instructions.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_epis                  episode identifier
    * @param o_notes                 detail of all discharge instructions
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Pedro Carneiro
    * @version                       1.0  
    * @since                         08/06/2009
    *
    ********************************************************************************************/
    FUNCTION get_printed_dis_notes
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        i_epis  IN episode.id_episode%TYPE,
        o_notes OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'OPEN o_notes';
        OPEN o_notes FOR
            SELECT dn.recommended
              FROM discharge_notes dn
             WHERE dn.id_episode = i_epis
               AND dn.flg_status = g_disch_notes_p
             ORDER BY dn.dt_creation_tstz DESC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_PRINTED_DIS_NOTES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_notes);
            RETURN FALSE;
    END get_printed_dis_notes;

    /********************************************************************************************
    * Retrieves a physician discharge record notes from phy_discharge_notes table
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_patient               patient identifier
    * @param i_episode               episode identifier
    * @param o_notes                 cursor returned
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Filipe Machado
    * @version                       1.0  
    * @since                         01/07/2009
    ********************************************************************************************/

    FUNCTION get_phy_discharge_notes
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_patient IN patient.id_patient%TYPE,
        i_episode IN episode.id_episode%TYPE,
        o_notes   OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'OPEN o_notes';
        OPEN o_notes FOR
            SELECT phdn.id_phy_discharge_notes,
                   phdn.id_patient,
                   phdn.id_professional,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, phdn.id_professional) prof,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, phdn.id_professional, phdn.dt_creation, i_episode) prof_speciality,
                   phdn.flg_status,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, phdn.dt_creation, i_prof) dt_creation,
                   phdn.notes,
                   phdn.id_cancel_reason,
                   pk_message.get_message(i_lang, 'DISCHARGE_NOTES_T033') cancel_reason_label,
                   pk_translation.get_translation(i_lang, cr.code_cancel_reason) cancel_reason,
                   pk_message.get_message(i_lang, 'DISCHARGE_NOTES_T034') cancel_notes_label,
                   phdn.cancel_notes
              FROM phy_discharge_notes phdn, cancel_reason cr
             WHERE phdn.id_patient = i_patient
               AND phdn.id_episode = i_episode
               AND phdn.id_cancel_reason = cr.id_cancel_reason(+)
             ORDER BY phdn.id_phy_discharge_notes DESC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_PHY_DISCHARGE_NOTES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_notes);
            RETURN FALSE;
    END get_phy_discharge_notes;

    /********************************************************************************************
    * Cancel a physician discharge record notes from phy_discharge_notes table
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_patient               patient identifier
    * @param i_episode               episode identifier
    * @param i_cancel_reason         cancel reason identifier
    * @param i_phy_discharge_notes   physician discharge notes
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Filipe Machado
    * @version                       1.0  
    * @since                         01/07/2009
    ********************************************************************************************/

    FUNCTION cancel_phy_discharge_notes
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_patient             IN patient.id_patient%TYPE,
        i_episode             IN episode.id_episode%TYPE,
        i_phy_discharge_notes IN phy_discharge_notes.id_phy_discharge_notes%TYPE,
        i_cancel_reason       IN cancel_reason.id_cancel_reason%TYPE,
        i_notes               IN VARCHAR2,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error        := 'CANCEL_PHY_DISCHARGE_NOTES';
        g_sysdate_tstz := current_timestamp;
    
        --
        UPDATE phy_discharge_notes phdn
           SET phdn.dt_cancel              = g_sysdate_tstz,
               phdn.id_professional_cancel = i_prof.id,
               phdn.flg_status             = g_phy_disch_notes_cancelled,
               phdn.id_cancel_reason       = i_cancel_reason,
               phdn.cancel_notes           = i_notes
         WHERE phdn.id_patient = i_patient
           AND phdn.id_episode = i_episode
           AND phdn.id_phy_discharge_notes = i_phy_discharge_notes;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CANCEL_PHY_DISCHARGE_NOTES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END cancel_phy_discharge_notes;

    /********************************************************************************************
    * Sets a physician discharge record notes
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_patient               patient identifier
    * @param i_episode               episode identifier
    * @param i_notes                 physician discharge notes
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Filipe Machado
    * @version                       1.0  
    * @since                         01/07/2009
    ********************************************************************************************/
    FUNCTION set_phy_discharge_notes
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_patient IN patient.id_patient%TYPE,
        i_episode IN episode.id_episode%TYPE,
        i_notes   IN phy_discharge_notes.notes%TYPE,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error        := 'SET_PHY_DISCHARGE_NOTES';
        g_sysdate_tstz := current_timestamp;
        --
        MERGE INTO phy_discharge_notes phdn
        USING (SELECT i_patient id_patient, i_episode id_episode
                 FROM dual) args
        ON (phdn.id_patient = args.id_patient AND phdn.id_episode = args.id_episode AND phdn.dt_creation = g_sysdate_tstz)
        WHEN MATCHED THEN
        
            UPDATE
               SET phdn.notes = i_notes
        WHEN NOT MATCHED THEN
            INSERT
                (id_phy_discharge_notes, id_patient, id_professional, id_episode, flg_status, dt_creation, notes)
            VALUES
                (seq_phy_discharge_notes.nextval,
                 i_patient,
                 i_prof.id,
                 i_episode,
                 g_phy_disch_notes_activated,
                 g_sysdate_tstz,
                 i_notes);
    
        RETURN TRUE;
    
    EXCEPTION
    
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_PHY_DISCHARGE_NOTES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
        
            RETURN FALSE;
    END set_phy_discharge_notes;

    /********************************************************************************************
    * Criação de episódio no internamento
    *
    * @param i_lang                  language id
    * @param i_prof                  professional, software and institution ids
    * @param i_patient               patient id
    * @param i_episode               episode id
    * @param i_prof_cat_type         professional category
    * @param i_flg_status            discharge status
    * @param i_flg_new_epis          discharge with new episode: Y - yes, N - no
    * @param i_new_epis_type         episode type
    * @param i_id_prof_admitting     professional who admitted the patient
    * @param i_dep_clin_serv         clinical service that admits the patient
    * @param i_transaction_id        remote transaction identifier
    * @param o_can_refresh_mviews    materialized view refresh: Y - yes, N - no
    * @param o_id_episode            episode ID that was created after the discharge
    * @param o_error                 error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        José Silva
    * @version                       1.0  
    * @since                         10-09-2009
    ********************************************************************************************/
    FUNCTION set_inp_episode
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN patient.id_patient%TYPE,
        i_episode              IN episode.id_episode%TYPE,
        i_prof_cat_type        IN category.flg_type%TYPE,
        i_flg_status           IN discharge.flg_status%TYPE,
        i_flg_new_epis         IN VARCHAR2,
        i_new_epis_type        IN epis_type.id_epis_type%TYPE,
        i_id_prof_admitting    IN discharge_detail.id_prof_admitting%TYPE,
        i_dep_clin_serv        IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_transaction_id       IN VARCHAR2,
        i_flg_compulsory       IN episode.flg_compulsory%TYPE DEFAULT NULL,
        i_id_compulsory_reason IN episode.id_compulsory_reason%TYPE DEFAULT NULL,
        i_compulsory_reason    IN episode.compulsory_reason%TYPE DEFAULT NULL,
        o_can_refresh_mviews   OUT VARCHAR2,
        o_id_episode           OUT episode.id_episode%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_discharge discharge.id_discharge%TYPE;
        l_visit        visit.id_visit%TYPE;
        --
        l_id_dep_clin_serv_admit discharge_detail.id_dep_clin_serv_admiting%TYPE;
        l_type_screen            disch_reas_dest.type_screen%TYPE;
        l_flg_surgery            discharge_detail.flg_surgery%TYPE;
        l_date_surgery           discharge_detail.date_surgery_tstz%TYPE;
        l_type_new_epis          episode.flg_type%TYPE;
        l_id_room                NUMBER;
        l_value                  epis_ext_sys.value%TYPE;
        l_new_episode            episode.id_episode%TYPE;
        l_movement               VARCHAR2(1);
        l_id_epis_type_inp       NUMBER;
        l_cat_type               VARCHAR2(0050);
        l_id_mov                 NUMBER;
        l_msg                    VARCHAR2(4000);
        l_flg_show               VARCHAR2(4000);
        l_msg_title              VARCHAR2(4000);
        l_button                 VARCHAR2(4000);
        l_epis_type              episode.id_epis_type%TYPE;
        l_flg_new_epis           VARCHAR2(1);
        --l_id_clinical_service      dep_clin_serv.id_clinical_service%TYPE;
        --l_speciality_id            speciality.id_speciality%TYPE;
        l_id_discharge_status discharge.id_discharge_status%TYPE;
        l_exists_inp_episode  BOOLEAN;
        --l_exists_surg_episode      BOOLEAN;
        l_pend_discharge_with_epis BOOLEAN;
        l_id_external_sys          NUMBER;
        l_inp_episode              episode.id_episode%TYPE;
        l_inp_episode_pat          episode.id_episode%TYPE;
        l_surg_episode             episode.id_episode%TYPE;
        l_schedule                 schedule.id_schedule%TYPE;
        l_id_patient               patient.id_patient%TYPE;
        l_id_prof_admitting        discharge_detail.id_prof_admitting%TYPE;
        l_old_id_prof_admitting    discharge_detail.id_prof_admitting%TYPE;
        --l_handoff_type             sys_config.value%TYPE;
        --l_epis_prof_resp           epis_prof_resp.id_epis_prof_resp%TYPE;
        --l_software                 software.id_software%TYPE;
        --
        --l_is_prof_responsible VARCHAR2(1 CHAR);
        l_rank NUMBER;
        --l_rows                table_varchar;
        l_rowids table_varchar;
        l_internal_error   EXCEPTION;
        l_error_inp_exists EXCEPTION;
        l_error_message VARCHAR2(4000);
        l_common_error EXCEPTION;
        l_transaction_id VARCHAR2(4000);
        --l_refresh_mview  VARCHAR2(200);
        --
        l_surgery_type           VARCHAR2(1 CHAR) := g_surgery_type_c;
        l_check_adm              VARCHAR2(1 CHAR);
        l_allow_multiple_episode VARCHAR2(1 CHAR);
        --
    
        CURSOR c_new_epis_disch(i_id_discharge IN discharge.id_discharge%TYPE) IS
            SELECT nvl(dd.id_dep_clin_serv_admiting, drd.id_dep_clin_serv) id_dep_clin_serv_admiting,
                   drd.id_epis_type,
                   drd.type_screen,
                   nvl(dd.flg_surgery, g_no) flg_surgery,
                   dd.date_surgery_tstz,
                   d.id_discharge_status,
                   dd.id_prof_admitting
              FROM discharge d
              JOIN disch_reas_dest drd
                ON d.id_disch_reas_dest = drd.id_disch_reas_dest
              JOIN discharge_detail dd
                ON dd.id_discharge = d.id_discharge
             WHERE d.id_discharge = i_id_discharge;
    
        CURSOR c_epis_room
        (
            l_id_epis_type  IN epis_type.id_epis_type%TYPE,
            l_dep_clin_serv IN dep_clin_serv.id_dep_clin_serv%TYPE
        ) IS
            SELECT er.id_room, 0 rank
              FROM epis_type et, epis_type_room er
             WHERE et.id_epis_type = l_id_epis_type
               AND er.id_epis_type = et.id_epis_type
               AND er.id_institution = i_prof.institution
               AND nvl(er.id_dep_clin_serv, 0) = 0
            UNION
            SELECT er.id_room, 1 rank
              FROM epis_type et, epis_type_room er
             WHERE et.id_epis_type = l_id_epis_type
               AND er.id_epis_type = et.id_epis_type
               AND er.id_institution = i_prof.institution
               AND er.id_dep_clin_serv = l_dep_clin_serv
             ORDER BY rank DESC;
    
        -- ********************************************************************************
        PROCEDURE get_new_epis_disch(i_id_discharge IN NUMBER) IS
            TYPE new_epis_disc_typ IS TABLE OF c_new_epis_disch%ROWTYPE;
            tbl_discharge new_epis_disc_typ;
            k_1st_row CONSTANT NUMBER := 1;
        BEGIN
        
            g_error := 'OPEN C_NEW_EPIS_DISCH';
            OPEN c_new_epis_disch(i_id_discharge);
            FETCH c_new_epis_disch BULK COLLECT
                INTO tbl_discharge;
            CLOSE c_new_epis_disch;
        
            IF tbl_discharge.count > 0
            THEN
                l_id_dep_clin_serv_admit := tbl_discharge(k_1st_row).id_dep_clin_serv_admiting;
                l_epis_type              := tbl_discharge(k_1st_row).id_epis_type;
                l_type_screen            := tbl_discharge(k_1st_row).type_screen;
                l_flg_surgery            := tbl_discharge(k_1st_row).flg_surgery;
                l_date_surgery           := tbl_discharge(k_1st_row).date_surgery_tstz;
                l_id_discharge_status    := tbl_discharge(k_1st_row).id_discharge_status;
                l_id_prof_admitting      := tbl_discharge(k_1st_row).id_prof_admitting;
            END IF;
        
        END get_new_epis_disch;
        -- ################################################################################
    
        -- ********************************************************************************
        FUNCTION get_id_visit_by_episode(i_id_episode IN NUMBER) RETURN NUMBER IS
            l_return   NUMBER;
            tbl_return table_number;
        BEGIN
        
            SELECT id_visit
              BULK COLLECT
              INTO tbl_return
              FROM episode
             WHERE id_episode = i_id_episode;
        
            IF tbl_return.count > 0
            THEN
                l_return := tbl_return(1);
            END IF;
        
            RETURN l_return;
        
        END get_id_visit_by_episode;
        -- ##############################################################################
    
        -- ********************************************************************************
        FUNCTION get_id_discharge_by_episode(i_id_episode IN NUMBER) RETURN NUMBER IS
            tbl_return table_number;
            l_return   NUMBER;
        BEGIN
        
            SELECT d.id_discharge
              BULK COLLECT
              INTO tbl_return
              FROM discharge d
             WHERE d.id_episode = i_id_episode
               AND d.flg_status IN (g_disch_flg_pend, g_disch_flg_active);
        
            IF tbl_return.count > 0
            THEN
                l_return := tbl_return(1);
            END IF;
        
            RETURN l_return;
        
        END get_id_discharge_by_episode;
        -- ##############################################################################
    
        -- ********************************************************************************
        FUNCTION get_inp_created_episode(i_id_episode IN NUMBER) RETURN NUMBER IS
            l_return   NUMBER;
            tbl_return table_number;
        BEGIN
        
            g_error := 'CHECK CREATED EPISODE';
            SELECT e.id_episode
              BULK COLLECT
              INTO tbl_return
              FROM episode e
              JOIN episode e_prev
                ON e.id_prev_episode = e_prev.id_episode
             WHERE e.id_prev_episode = i_id_episode
               AND e.flg_status != pk_visit.g_flg_status_c
               AND e.flg_ehr != g_ehr_schedule
               AND e.id_epis_type = l_id_epis_type_inp
               AND e.id_visit = e_prev.id_visit
               AND e.id_institution = i_prof.institution;
        
            IF tbl_return.count > 0
            THEN
                l_return := tbl_return(1);
            END IF;
        
            RETURN l_return;
        
        END get_inp_created_episode;
    
        FUNCTION get_inp_created_patient
        (
            i_id_patient IN NUMBER,
            i_id_episode IN NUMBER
        ) RETURN NUMBER IS
            l_return   NUMBER;
            tbl_return table_number;
        BEGIN
        
            g_error := 'CHECK CREATED EPISODE';
            SELECT id_episode
              BULK COLLECT
              INTO tbl_return
              FROM episode e
             WHERE e.id_patient = i_id_patient
               AND e.id_episode != i_id_episode
               AND e.flg_status = pk_visit.g_flg_status_a
               AND e.flg_ehr NOT IN (g_ehr_schedule, pk_alert_constant.g_epis_ehr_ehr)
               AND e.id_epis_type = l_id_epis_type_inp
               AND e.id_institution = i_prof.institution;
        
            IF tbl_return.count > 0
            THEN
                l_return := tbl_return(1);
            END IF;
        
            RETURN l_return;
        
        END get_inp_created_patient;
        -- ##############################################################################
    
        -- ********************************************************************************
        FUNCTION get_surg_episode
        (
            i_inp_episode IN NUMBER,
            i_visit       IN NUMBER
        ) RETURN NUMBER IS
            tbl_return table_number;
            l_return   NUMBER;
        BEGIN
        
            -- Check if SURGERY episode was already created
            SELECT e.id_episode
              BULK COLLECT
              INTO tbl_return
              FROM episode e
             WHERE e.id_prev_episode = i_inp_episode
               AND e.id_visit = i_visit
               AND e.id_epis_type = g_epis_type_oris;
        
            IF tbl_return.count > 0
            THEN
                l_return := tbl_return(1);
            END IF;
        
            RETURN l_return;
        
        END get_surg_episode;
        -- ##############################################################################
    
        -- ********************************************************************************
        FUNCTION get_id_room_of_episode(i_id_episode IN NUMBER) RETURN NUMBER IS
            tbl_return table_number;
            l_return   NUMBER;
        BEGIN
        
            SELECT id_room
              BULK COLLECT
              INTO tbl_return
              FROM epis_info
             WHERE id_episode = i_id_episode;
        
            IF tbl_return.count > 0
            THEN
                l_return := tbl_return(1);
            END IF;
        
            RETURN l_return;
        
        END get_id_room_of_episode;
        -- ##############################################################################
    
        -- ********************************************************************************
        FUNCTION get_value_epis_ext_sys
        (
            i_prof            IN profissional,
            i_id_episode      IN NUMBER,
            i_id_external_sys IN NUMBER
        ) RETURN VARCHAR2 IS
            tbl_return table_varchar;
            l_return   epis_ext_sys.value%TYPE;
        BEGIN
        
            SELECT VALUE
              BULK COLLECT
              INTO tbl_return
              FROM epis_ext_sys
             WHERE id_episode = i_episode
               AND id_external_sys = i_id_external_sys
               AND id_institution = i_prof.institution;
        
            IF tbl_return.count > 0
            THEN
                l_return := tbl_return(1);
            END IF;
        
            RETURN l_return;
        
        END get_value_epis_ext_sys;
        -- ##############################################################################
    
        -- ********************************************************************************
        PROCEDURE process_surgery_episodes
        (
            i_inp_episode IN NUMBER,
            i_visit       IN NUMBER,
            i_dt_surg     IN discharge_detail.date_surgery_tstz%TYPE,
            i_schedule    IN NUMBER,
            i_flg_surgery IN VARCHAR2
        ) IS
            l_surg_episode episode.id_episode%TYPE;
            l_id_patient   NUMBER;
            l_flg_surgery  discharge_detail.flg_surgery%TYPE;
        BEGIN
        
            IF i_inp_episode IS NOT NULL
            THEN
            
                l_surg_episode := get_surg_episode(i_inp_episode => i_inp_episode, i_visit => i_visit);
            
                IF i_flg_surgery = pk_alert_constant.g_yes
                THEN
                    BEGIN
                        SELECT DISTINCT flg_surgery
                          INTO l_flg_surgery
                          FROM discharge_detail dd
                          JOIN discharge d
                            ON d.id_discharge = dd.id_discharge
                         WHERE d.id_episode IN (SELECT id_prev_episode
                                                  FROM episode
                                                 WHERE id_episode = i_inp_episode);
                    EXCEPTION
                        WHEN OTHERS THEN
                            l_flg_surgery := pk_alert_constant.g_yes;
                    END;
                END IF;
                -- Create surgical episode, if it doesn't exist. 
                -- We can ignore the type of discharge (active/pending) since the inpatient episode
                -- was already created without a surgical episode.
                IF i_flg_surgery = pk_alert_constant.g_yes
                   AND l_surg_episode IS NULL
                THEN
                    g_error      := 'INSERT SURGERY EPISODE';
                    l_id_patient := i_patient;
                    IF NOT pk_sr_visit.create_all_surgery(i_lang         => i_lang,
                                                          i_patient      => l_id_patient,
                                                          i_prof         => i_prof,
                                                          i_prev_episode => i_inp_episode,
                                                          i_type         => l_surgery_type,
                                                          i_dt_surg      => i_dt_surg,
                                                          i_room         => NULL,
                                                          i_duration     => NULL,
                                                          i_flg_ehr      => pk_alert_constant.g_epis_ehr_normal,
                                                          o_episode_new  => l_surg_episode,
                                                          o_schedule     => l_schedule,
                                                          o_error        => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                ELSIF nvl(i_flg_surgery, pk_alert_constant.g_no) = pk_alert_constant.g_no
                      AND l_surg_episode IS NOT NULL
                      AND i_flg_status = g_disch_flg_active
                      AND l_flg_surgery = pk_alert_constant.g_yes
                THEN
                    -- If surgery was already created, and surgery status (flag) is changed to "NO", raise error if it's final discharge.
                    l_error_message := 'ERROR: SURGERY ALREADY CREATED.';
                    RAISE l_common_error;
                END IF;
            
            END IF;
        
        END process_surgery_episodes;
        -- ##############################################################################
    
        FUNCTION check_disch_admission(i_id_episode IN NUMBER) RETURN VARCHAR2 IS
            l_count     NUMBER;
            l_admission VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        BEGIN
            SELECT COUNT(1)
              INTO l_count
              FROM discharge_hist dh
              JOIN discharge_flash_files dff
                ON dh.id_discharge_flash_files = dff.id_discharge_flash_files
             WHERE dh.id_episode = i_id_episode
               AND dh.flg_status <> pk_discharge.g_disch_flg_cancel
               AND dff.flg_type = pk_disposition.g_disp_adms;
        
            IF l_count > 0
            THEN
                l_admission := pk_alert_constant.g_yes;
            END IF;
            RETURN l_admission;
        END check_disch_admission;
    
    BEGIN
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
    
        g_error                  := 'GET configurations';
        l_movement               := pk_sysconfig.get_config('DISCH_EDIS_TO_INP_MOVEMENT', i_prof);
        l_id_epis_type_inp       := pk_sysconfig.get_config('ID_EPIS_TYPE_INPATIENT', i_prof);
        l_allow_multiple_episode := pk_sysconfig.get_config('ADT_ALLOW_MULTIPLE_ACTIVE_EDIS_INP', i_prof);
    
        o_can_refresh_mviews := g_no;
        g_sysdate_tstz       := current_timestamp;
    
        --        
        g_error        := 'OPEN C_EPIS_DISCHARGE';
        l_id_discharge := get_id_discharge_by_episode(i_id_episode => i_episode);
    
        l_id_external_sys := pk_sysconfig.get_config('ID_EXTERNAL_SYS', i_prof.institution, i_prof.software);
    
        g_error := 'OPEN C_NEW_EPIS_DISCH';
        get_new_epis_disch(i_id_discharge => l_id_discharge);
    
        l_type_new_epis := substr(l_type_screen, 1, instr(l_type_screen, '|') - 1);
    
        IF nvl(i_flg_new_epis, g_no) = g_yes
           OR l_epis_type = l_id_epis_type_inp
        THEN
            l_flg_new_epis := g_yes;
        ELSE
            l_flg_new_epis := g_no;
        END IF;
    
        --------------------------------------------------------------------------------------------------------------
        -- A) CHECK EXISTENCE OF INPATIENT AND/OR SURGERY EPISODES
        --------------------------------------------------------------------------------------------------------------
    
        -- Get current visit
        g_error := 'OPEN C_VISIT';
        l_visit := get_id_visit_by_episode(i_id_episode => i_episode);
    
        -- Check if INPATIENT episode was already created
        l_id_patient      := i_patient;
        l_inp_episode     := get_inp_created_episode(i_id_episode => i_episode);
        l_inp_episode_pat := get_inp_created_patient(i_id_patient => l_id_patient, i_id_episode => i_episode);
        g_error           := 'l_inp_episode:' || l_inp_episode || 'l_inp_episode_pat: ' || l_inp_episode_pat;
        pk_alertlog.log_debug(g_error);
        IF l_inp_episode IS NULL
           AND l_inp_episode_pat IS NOT NULL
           AND l_allow_multiple_episode = pk_alert_constant.g_no
           AND l_flg_new_epis = g_yes
        THEN
            o_id_episode := -1000;
            RETURN TRUE;
            --RAISE l_error_inp_exists;
        END IF;
    
        -- Check if it's a pending discharge with episode creation
        l_pend_discharge_with_epis := i_flg_status = g_disch_flg_pend AND
                                      l_id_discharge_status = pk_alert_constant.g_disch_pend_episode;
    
        l_exists_inp_episode := l_inp_episode IS NOT NULL;
    
        IF l_flg_new_epis = g_yes
           OR l_epis_type = l_id_epis_type_inp
           AND l_exists_inp_episode
        THEN
            g_error := 'process_surgery_episodes';
            pk_alertlog.log_debug(g_error);
        
            process_surgery_episodes(i_inp_episode => l_inp_episode,
                                     i_visit       => l_visit,
                                     i_dt_surg     => l_date_surgery,
                                     i_schedule    => l_schedule,
                                     i_flg_surgery => l_flg_surgery);
        END IF;
        --------------------------------------------------------------------------------------------------------------
        -- B) CREATE EPISODES WHEN APPLICABLE (CHECK CONDITIONS IN 'IF' CLAUSE)
        --------------------------------------------------------------------------------------------------------------
    
        IF (i_flg_status = g_disch_flg_active OR l_pend_discharge_with_epis)
           AND l_flg_new_epis = g_yes
           AND l_type_new_epis IN (g_flg_temp, g_flg_def)
           AND l_id_dep_clin_serv_admit IS NOT NULL
           AND NOT l_exists_inp_episode -- Only if INP episode doesn't exist!!
        THEN
            l_id_room := get_id_room_of_episode(i_id_episode => i_episode);
        
            g_error := 'GET EPIS_EXT_SYS.value';
            l_value := get_value_epis_ext_sys(i_prof            => i_prof,
                                              i_id_episode      => i_episode,
                                              i_id_external_sys => l_id_external_sys);
        
            g_error := 'CALL PK_INP_EPISODE.CALL_INS_EPISODE_DISCH';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_inp_episode.call_ins_episode_disch(i_lang                 => i_lang,
                                                         i_id_visit             => l_visit,
                                                         i_id_professional      => i_prof,
                                                         i_epis_type            => l_id_epis_type_inp,
                                                         i_id_dep_clin_serv     => l_id_dep_clin_serv_admit,
                                                         i_id_room              => l_id_room,
                                                         i_dt_begin             => g_sysdate_tstz,
                                                         i_id_episode_ext       => l_value,
                                                         i_flg_type             => l_type_new_epis,
                                                         i_type                 => l_surgery_type,
                                                         i_dt_surgery           => pk_date_utils.date_send_tsz(i_lang,
                                                                                                               l_date_surgery,
                                                                                                               i_prof),
                                                         i_flg_surgery          => l_flg_surgery,
                                                         i_id_prev_episode      => i_episode,
                                                         i_transaction_id       => l_transaction_id,
                                                         i_flg_compulsory       => i_flg_compulsory,
                                                         i_id_compulsory_reason => i_id_compulsory_reason,
                                                         i_compulsory_reason    => i_compulsory_reason,
                                                         o_id_episode           => l_new_episode,
                                                         o_error                => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            g_error := 'CALL pk_discharge.set_mcdt_episode_origin';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_discharge.set_mcdt_episode_origin(i_lang          => i_lang,
                                                        i_prof          => i_prof,
                                                        i_prof_cat_type => i_prof_cat_type,
                                                        i_episode       => i_episode,
                                                        i_new_episode   => l_new_episode,
                                                        i_new_epis_type => i_new_epis_type,
                                                        i_dep_clin_serv => i_dep_clin_serv,
                                                        i_patient       => i_patient,
                                                        o_error         => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            --jsilva 21-05-2007 verificar se existe requisição automática de transporte na criação de novo processo de internamento
            IF l_movement = pk_alert_constant.g_yes
               AND i_flg_status = g_disch_flg_active -- Move patient ONLY on final discharge
            THEN
                l_id_room := NULL;
                IF l_id_dep_clin_serv_admit IS NOT NULL
                THEN
                    -- Sala por defeito 
                    g_error := 'OPEN c_epis_room';
                    OPEN c_epis_room(l_id_epis_type_inp, l_id_dep_clin_serv_admit);
                    FETCH c_epis_room
                        INTO l_id_room, l_rank;
                    CLOSE c_epis_room;
                ELSE
                    l_error_message := pk_message.get_message(i_lang, i_prof, 'CREATE_EPISODE_TEMP_M001');
                    RAISE l_common_error;
                END IF;
            
                g_error    := 'GET PROF CAT';
                l_cat_type := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
            
                g_error := 'CALL pk_movement.create_movement';
                IF NOT pk_movement.create_movement_no_commit(i_lang,
                                                             l_new_episode,
                                                             i_prof,
                                                             l_id_room,
                                                             NULL,
                                                             pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof),
                                                             l_cat_type,
                                                             l_id_mov,
                                                             l_flg_show,
                                                             l_msg,
                                                             l_msg_title,
                                                             l_button,
                                                             o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                g_error := 'CALL pk_movement.insert_movement_task';
                IF NOT pk_movement.insert_movement_task(i_lang, l_new_episode, i_prof, l_cat_type, o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            END IF;
        
            -- Assign new INPATIENT episode ID
            l_inp_episode := l_new_episode;
        
        END IF;
    
        -- If user changes the admiting dcs ( one that created an episode for one that dont ), 
        -- cancel the inp episode created previously
        -- CMF
        -- l_exists_inp_episode :: inp episode exists
        -- l_type_new_epis      :: new dcs has no flag assign so we assume that it wont generate episode.
        l_check_adm := check_disch_admission(i_episode);
        IF (i_flg_status = g_disch_flg_active OR l_pend_discharge_with_epis)
           AND l_exists_inp_episode
           AND l_type_new_epis IS NULL
           AND l_check_adm = pk_alert_constant.g_yes
        THEN
        
            -- CANCEL_TYPE EQUAL TO "A" for alert cancellations
            g_error := 'CALL pk_visit.call_cancel_episode';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_visit.call_cancel_episode(i_lang           => i_lang,
                                                i_id_episode     => l_inp_episode,
                                                i_prof           => i_prof,
                                                i_cancel_reason  => NULL,
                                                i_cancel_type    => 'A',
                                                i_transaction_id => l_transaction_id,
                                                o_error          => o_error)
            
            THEN
            
                RETURN FALSE;
            END IF;
        
        END IF;
    
        --------------------------------------------------------------------------------------------------------------
        -- C) MANAGE EPISODE RESPONSABILITY
        --------------------------------------------------------------------------------------------------------------
    
        IF NOT l_exists_inp_episode
           AND i_id_prof_admitting IS NOT NULL
           AND l_inp_episode IS NOT NULL
        THEN
        
            -- C.1) A new episode was created, so there is no responsible. Create a new responsability.
        
            g_error := 'CALL TO SET_OVERALL_RESPONSABILITY';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_hand_off_api.set_overall_responsability(i_lang              => i_lang,
                                                              i_prof              => i_prof,
                                                              i_id_prof_admitting => profissional(i_id_prof_admitting,
                                                                                                  i_prof.institution,
                                                                                                  pk_alert_constant.g_soft_inpatient),
                                                              i_id_dep_clin_serv  => i_dep_clin_serv,
                                                              i_id_episode        => l_inp_episode,
                                                              i_dt_reg            => g_sysdate_tstz,
                                                              o_error             => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
        ELSIF i_id_prof_admitting IS NOT NULL
              AND l_exists_inp_episode
        THEN
        
            -- C.2) Replace responsability, if responsible was changed.
        
            -- 1) Check if previously assigned responsible has changed.
            BEGIN
                g_error := 'CHECK PREVIOUS RESPONSIBLE';
                pk_alertlog.log_debug(g_error);
                SELECT id_prof_admitting
                  INTO l_old_id_prof_admitting
                  FROM (SELECT ddh.id_prof_admitting,
                               row_number() over(PARTITION BY d.id_episode ORDER BY ddh.dt_created_hist DESC) row_number
                          FROM discharge_detail_hist ddh
                          JOIN discharge d
                            ON d.id_discharge = ddh.id_discharge
                         WHERE ddh.id_discharge = l_id_discharge) t
                 WHERE row_number = 2; -- Row number 1 is the current discharge. Row number 2 is the previously assigned responsible, if exists.
            EXCEPTION
                WHEN no_data_found THEN
                    l_old_id_prof_admitting := NULL;
            END;
        
            IF i_id_prof_admitting <> nvl(l_old_id_prof_admitting, 0)
            THEN
                -- 2) Set new responsible. Calling this method will also terminate previous responsability.
                g_error := 'CALL TO SET_OVERALL_RESPONSABILITY (2)';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_hand_off_api.set_overall_responsability(i_lang              => i_lang,
                                                                  i_prof              => i_prof,
                                                                  i_id_prof_admitting => profissional(i_id_prof_admitting,
                                                                                                      i_prof.institution,
                                                                                                      pk_alert_constant.g_soft_inpatient),
                                                                  i_id_dep_clin_serv  => i_dep_clin_serv,
                                                                  i_id_episode        => l_inp_episode,
                                                                  i_dt_reg            => g_sysdate_tstz,
                                                                  o_error             => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
            END IF;
        ELSIF l_inp_episode IS NOT NULL
              AND l_exists_inp_episode
        THEN
            g_error := 'EPISODE UPDATE';
            ts_episode.upd(id_episode_in            => l_inp_episode,
                           flg_compulsory_in        => i_flg_compulsory,
                           flg_compulsory_nin       => FALSE,
                           id_compulsory_reason_in  => i_id_compulsory_reason,
                           id_compulsory_reason_nin => FALSE,
                           compulsory_reason_in     => i_compulsory_reason,
                           compulsory_reason_nin    => FALSE,
                           rows_out                 => l_rowids);
        
            g_error := 'PROCESS UPDATE';
            pk_alertlog.log_debug(g_error);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPISODE',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
        END IF;
    
        o_id_episode := l_inp_episode;
    
        o_can_refresh_mviews := g_yes;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_common_error THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_INP_EPISODE',
                                   NULL,
                                   'U');
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_alert_exceptions.reset_error_state();
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_INP_EPISODE',
                                              o_error);
            RETURN FALSE;
    END set_inp_episode;

    /********************************************************************************************
    * Returns the discharge dates: administrative discharge, medical active discharge and medical pending discharge.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_episode               episode identifier
    * @param o_discharge_adm         Administrative discharge
    * @param o_discharge_med         Medical active discharge
    * @param o_discharge_date        Medical pending discharge
    * @param o_flg_discharge_status  Discharge status flag
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Sofia Mendes
    * @version                       2.5.0.7
    * @since                         03/12/2009
    ********************************************************************************************/
    FUNCTION get_discharge_dates
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_episode           IN episode.id_episode%TYPE,
        o_discharge_adm        OUT discharge.dt_admin_tstz%TYPE,
        o_discharge_med        OUT discharge.dt_med_tstz%TYPE,
        o_discharge_pend       OUT discharge.dt_pend_tstz%TYPE,
        o_flg_discharge_status OUT epis_info.flg_dsch_status%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'SELECT DISCHARGE_DATE WITH EPISODE: ' || i_id_episode;
        pk_alertlog.log_debug(g_error);
        SELECT dch.flg_status,
               pk_discharge_core.get_dt_admin(i_lang, i_prof, NULL, dch.flg_status_adm, dch.dt_admin_tstz),
               dch.dt_med_tstz,
               dch.dt_pend_tstz
          INTO o_flg_discharge_status, o_discharge_adm, o_discharge_med, o_discharge_pend
          FROM discharge dch
         WHERE dch.id_episode = i_id_episode
           AND dch.flg_status <> g_disch_flg_status_reopen
           AND dch.flg_status <> g_disch_flg_status_cancel;
    
        RETURN TRUE;
    EXCEPTION
        WHEN no_data_found THEN
            o_flg_discharge_status := NULL;
            o_discharge_adm        := NULL;
            o_discharge_med        := NULL;
            o_discharge_pend       := NULL;
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_DATES',
                                              o_error);
            RETURN FALSE;
    END get_discharge_dates;

    /********************************************************************************************
    * Returns the discharge date.
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_patient               patient identifier
    * @param i_episode               episode identifier
    * @param o_discharge_date        Discharge date
    * @param o_flg_discharge_status  Discharge status flag
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Sofia Mendes
    * @version                       2.5.0.7
    * @since                         03/12/2009
    ********************************************************************************************/
    FUNCTION get_discharge_date
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_episode           IN episode.id_episode%TYPE,
        o_discharge_date       OUT discharge.dt_med_tstz%TYPE,
        o_flg_discharge_status OUT epis_info.flg_dsch_status%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_discharge_adm  discharge.dt_admin_tstz%TYPE;
        l_discharge_med  discharge.dt_med_tstz%TYPE;
        l_discharge_pend discharge.dt_pend_tstz%TYPE;
    BEGIN
        g_error := 'CALL get_discharge_dates. i_id_episode' || i_id_episode;
        pk_alertlog.log_debug(g_error);
        IF NOT get_discharge_dates(i_lang                 => i_lang,
                                   i_prof                 => i_prof,
                                   i_id_episode           => i_id_episode,
                                   o_discharge_adm        => l_discharge_adm,
                                   o_discharge_med        => l_discharge_med,
                                   o_discharge_pend       => l_discharge_pend,
                                   o_flg_discharge_status => o_flg_discharge_status,
                                   o_error                => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        o_discharge_date := nvl(nvl(l_discharge_adm, l_discharge_med), l_discharge_pend);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_DATE',
                                              o_error);
            RETURN FALSE;
    END get_discharge_date;

    /********************************************************************************************
    * Returns the expected discharge date.    
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure    
    * @param i_episode               episode identifier
    * @param o_discharge_date        Expected discharge date
    * @param o_flg_hour_origin       Flg_hour_origin ('D' -date; 'DH' - date and hour)
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Sofia Mendes
    * @version                       2.5.0.7
    * @since                         03/12/2009
    ********************************************************************************************/
    FUNCTION get_discharge_schedule_date
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_episode      IN episode.id_episode%TYPE,
        o_discharge_date  OUT discharge_schedule.dt_discharge_schedule%TYPE,
        o_flg_hour_origin OUT discharge_schedule.flg_hour_origin%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'SELECT DISCHARGE SCHEDULE with id_episode: ' || i_id_episode;
        pk_alertlog.log_debug(g_error);
        SELECT ds.dt_discharge_schedule, ds.flg_hour_origin
          INTO o_discharge_date, o_flg_hour_origin
          FROM discharge_schedule ds
         WHERE ds.id_episode = i_id_episode
           AND ds.flg_status = pk_alert_constant.g_yes
           AND rownum = 1;
    
        RETURN TRUE;
    EXCEPTION
        WHEN no_data_found THEN
            o_discharge_date  := NULL;
            o_flg_hour_origin := NULL;
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_SCHEDULE_DATE',
                                              o_error);
            RETURN FALSE;
    END get_discharge_schedule_date;

    /********************************************************************************************
    * Returns the discharge date.
    * Priority order:
    * -administrative discharge
    * -physician active discharge
    * -physician pending discharge
    * -expected discharge
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure    
    * @param i_episode               episode identifier    
    *
    * @return                        discharge date
    *
    * @author                        Sofia Mendes
    * @version                       2.5.0.7
    * @since                         03/12/2009
    ********************************************************************************************/
    FUNCTION get_discharge_date
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_episode         IN episode.id_episode%TYPE,
        i_show_date_expected IN VARCHAR2 DEFAULT 'Y'
    ) RETURN discharge.dt_med_tstz%TYPE IS
        l_discharge_date  TIMESTAMP WITH LOCAL TIME ZONE;
        l_flg_dsch_status epis_info.flg_dsch_status%TYPE;
        l_flg_hour_origin discharge_schedule.flg_hour_origin%TYPE;
        l_internal_error EXCEPTION;
        l_error t_error_out;
    BEGIN
        g_error := 'CALL PK_DISCHARGE.GET_DISCHARGE_DATE with id_episode: ' || i_id_episode;
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.get_discharge_date(i_lang                 => i_lang,
                                               i_prof                 => i_prof,
                                               i_id_episode           => i_id_episode,
                                               o_discharge_date       => l_discharge_date,
                                               o_flg_discharge_status => l_flg_dsch_status,
                                               o_error                => l_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF (l_discharge_date IS NULL)
           AND i_show_date_expected = 'Y'
        THEN
            g_error := 'CALL GET_DISCHARGE_SCHEDULE_DATE WITH ID_EPISODE=' || i_id_episode;
            pk_alertlog.log_debug(g_error);
            IF NOT get_discharge_schedule_date(i_lang            => i_lang,
                                               i_prof            => i_prof,
                                               i_id_episode      => i_id_episode,
                                               o_discharge_date  => l_discharge_date,
                                               o_flg_hour_origin => l_flg_hour_origin,
                                               o_error           => l_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
        END IF;
    
        RETURN l_discharge_date;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_DATE',
                                              l_error);
            RETURN NULL;
    END get_discharge_date;

    /********************************************************************************************
    * Returns the discharge date. This function does not consider the expected discharge.
    * Priority order:
    * -administrative discharge
    * -physician active discharge
    * -physician pending discharge    
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure    
    * @param i_episode               episode identifier    
    *
    * @return                        discharge date
    *
    * @author                        Sofia Mendes
    * @version                       2.6.0.3.3
    * @since                         28-Sep-2010
    ********************************************************************************************/
    FUNCTION get_disch_phy_adm_date
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE
    ) RETURN discharge.dt_med_tstz%TYPE IS
        l_discharge_date  TIMESTAMP WITH LOCAL TIME ZONE;
        l_flg_dsch_status epis_info.flg_dsch_status%TYPE;
        --l_flg_hour_origin discharge_schedule.flg_hour_origin%TYPE;
        l_internal_error EXCEPTION;
        l_error t_error_out;
    BEGIN
        g_error := 'CALL PK_DISCHARGE.GET_DISCHARGE_DATE with id_episode: ' || i_id_episode;
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.get_discharge_date(i_lang                 => i_lang,
                                               i_prof                 => i_prof,
                                               i_id_episode           => i_id_episode,
                                               o_discharge_date       => l_discharge_date,
                                               o_flg_discharge_status => l_flg_dsch_status,
                                               o_error                => l_error)
        THEN
            RAISE l_internal_error;
        END IF;
        RETURN l_discharge_date;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCH_PHY_ADM_DATE',
                                              l_error);
            RETURN NULL;
    END get_disch_phy_adm_date;

    /**
    * Checks if "Tipo de consulta" should be shown
    *
    * @param   I_LANG language associated to the professional executing the request
    * @param   I_PROF  professional, institution and software ids
    * @param   O_IS_AVAILABLE Y - show "tipo de consula", N - otherwise
    * @param   O_ERROR error message
    *
    * @RETURN  TRUE if sucess, FALSE otherwise
    * @author  Pedro Teixeira
    * @since   05-01-2009
    */
    FUNCTION check_bill_type_avail
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        o_is_available OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        IF i_prof.software IN (g_soft_outpatient, g_soft_pp)
        THEN
            o_is_available := g_yes;
        ELSE
            o_is_available := g_no;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CHECK_BILL_TYPE_AVAIL',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END check_bill_type_avail;

    /**
    * Get bill types
    *
    * @param   I_LANG                language associated to the professional executing the request
    * @param   I_PROF                profissional
    * @param   I_EPISODE             episode ID    
    * @param   O_TYPE                cursor with bill types
    * @param   O_FILLED_DEFAULT      this field is automatically filled with the first option of the multichoice: (Y)es or (N)o
    *
    * @param   O_ERROR               error message
    *
    * @RETURN  TRUE if sucess, FALSE otherwise
    * @author  Pedro Teixeira
    * @since   05-01-2009
    */
    FUNCTION get_discharge_bill_type
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        o_type           OUT pk_types.cursor_type,
        o_filled_default OUT VARCHAR2,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dep_clin_serv dep_clin_serv.id_dep_clin_serv%TYPE;
        l_config_bill_type CONSTANT sys_config.value%TYPE := 'DISCHARGE_BILL_TYPE_DEFAULT';
    
    BEGIN
    
        g_error         := 'GET EPIS DEP_CLIN_SERV';
        l_dep_clin_serv := pk_episode.get_dep_clin_serv(i_lang, i_prof, i_episode);
    
        g_error := 'GET CURSOR';
        OPEN o_type FOR
            SELECT *
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang,
                                                                  i_prof,
                                                                  pk_discharge_core.g_domain_bill_type,
                                                                  l_dep_clin_serv));
    
        o_filled_default := pk_sysconfig.get_config(i_code_cf => l_config_bill_type, i_prof => i_prof);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCHARGE_BILL_TYPE',
                                              o_error);
            pk_types.open_my_cursor(o_type);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_discharge_bill_type;

    /********************************************************************************************
    * Returns the disposition report label
    *
    * @param i_lang                  Language identifier
    * @param i_prof                  Logged professional structure
    * @param i_reas_dest             Discharge destination Identifier
    * @param o_label                 Report label
    * @param o_reports               Discharge destination report (if it is configured)
    * @param o_reports_pat           Complete emergency reports identifier
    * @param o_print_config          Print configuration (P- Save and Print, PL- Save and add
    *                                to the printing list).
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Alexandre Santos
    * @updated by                    Gisela Couto
    * @version                       2.5.0.7
    * @since                         11/12/2009
    ********************************************************************************************/
    FUNCTION get_report_label
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_reas_dest    IN disch_reas_dest.id_disch_reas_dest%TYPE DEFAULT NULL,
        o_label        OUT pk_translation.t_desc_translation,
        o_print_config OUT sys_list_group_rel.flg_context%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_report        reports.id_reports%TYPE;
        l_print_config  sys_list_group_rel.flg_context%TYPE;
        l_can_add       VARCHAR2(1 CHAR);
        l_internal_name sys_list.internal_name%TYPE;
        l_exception EXCEPTION;
    BEGIN
    
        g_error  := 'GET REPORT ID';
        l_report := pk_sysconfig.get_config(i_code_cf => g_cfg_print_disp_report, i_prof => i_prof);
    
        g_error := 'GET REPORT LABEL';
        SELECT nvl(pk_translation.get_translation(i_lang, r.code_reports_title),
                   pk_translation.get_translation(i_lang, r.code_reports))
          INTO o_label
          FROM reports r
         WHERE r.id_reports = l_report;
    
        g_error := 'VERIFY IF PATIENT HAVE PERMISSIONS TO ADD TO THE PRINTING LIST';
        IF NOT pk_print_list_db.check_func_can_add(i_lang        => i_lang,
                                                   i_prof        => i_prof,
                                                   o_flg_can_add => l_can_add,
                                                   o_error       => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error         := 'GET DEFAULT OPTION';
        l_internal_name := get_default_opt_print_list(i_lang => i_lang,
                                                      i_prof => i_prof,
                                                      i_area => pk_print_list_db.g_print_list_area_disch);
    
        g_error := 'GET PRINT CONFIG - P - PRINT/ADD TO THE PRINTING LIST';
        BEGIN
            SELECT tc.flg_context
              INTO l_print_config
              FROM TABLE(pk_sys_list.tf_sys_list_values(i_lang          => i_lang,
                                                        i_prof          => i_prof,
                                                        i_internal_name => pk_discharge.g_slg_disch_options)) tc
             WHERE ((tc.sys_list_internal_name = l_internal_name AND l_can_add = pk_alert_constant.g_yes) OR
                   (tc.sys_list_internal_name != l_internal_name AND l_can_add = pk_alert_constant.g_no))
               AND rownum = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_print_config := NULL;
        END;
    
        o_print_config := l_print_config;
    
        RETURN TRUE;
    EXCEPTION
        WHEN no_data_found THEN
            o_label        := NULL;
            o_print_config := NULL;
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_REPORT_LABEL',
                                              o_error);
            RETURN FALSE;
    END get_report_label;

    /********************************************************************************************
    * Returns discharge detail
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_id_discharge           discharge id
    * @param o_sql                    cursor with detail of discharge
    * @param o_error                  Error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        Alexandre Santos
    * @version                       2.5.0.7.1
    * @since                         27/01/2009
    ********************************************************************************************/
    FUNCTION get_disch_detail
    (
        i_lang         IN NUMBER,
        i_prof         IN profissional,
        i_id_discharge IN NUMBER,
        o_sql          OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        RETURN pk_discharge_core.get_disch_detail(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_id_discharge => i_id_discharge,
                                                  o_sql          => o_sql,
                                                  o_error        => o_error);
    END get_disch_detail;

    /********************************************************************************************
    * Returns the FLG_STATUS from ID_DISCHARGE_STATUS or vice-versa
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_flg_status            input discharge status (A - active, P - pending)
    * @param i_disch_status          input discharge type
    * @param o_flg_status            output discharge status (A - active, P - pending)
    * @param o_disch_status          output discharge type
    * @param o_error                 error message
    *
    * @return                        false if errors occur, true otherwise
    *
    * @author                        José Silva
    * @version                       2.6
    * @since                         19/02/2010
    ********************************************************************************************/
    FUNCTION get_disch_flg_status
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_flg_status   IN discharge.flg_status%TYPE,
        i_disch_status IN discharge_status.id_discharge_status%TYPE,
        o_flg_status   OUT discharge.flg_status%TYPE,
        o_disch_status OUT discharge_status.id_discharge_status%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_market market.id_market%TYPE;
    
    BEGIN
    
        IF i_flg_status IS NOT NULL
        THEN
        
            l_id_market := pk_utils.get_institution_market(i_lang, i_prof.institution);
        
            g_error := 'GET ID_DISCHARGE_STATUS';
            SELECT ds.id_discharge_status
              INTO o_disch_status
              FROM disch_status_soft_inst dsi
              JOIN discharge_status ds
                ON dsi.id_discharge_status = ds.id_discharge_status
             WHERE ds.flg_available = pk_alert_constant.g_yes
               AND dsi.id_institution IN (0, i_prof.institution)
               AND dsi.id_software IN (0, i_prof.software)
               AND dsi.id_market IN (0, l_id_market)
               AND ds.flg_status = i_flg_status
               AND rownum = 1
             ORDER BY dsi.id_institution DESC, dsi.id_market DESC, dsi.id_software DESC;
        ELSIF i_disch_status IS NOT NULL
        THEN
            g_error := 'GET FLG_STATUS';
            SELECT ds.flg_status
              INTO o_flg_status
              FROM discharge_status ds
             WHERE ds.id_discharge_status = i_disch_status;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCH_FLG_STATUS',
                                              o_error);
            RETURN FALSE;
    END get_disch_flg_status;

    /********************************************************************************************
     * Get list of actions available in the discharge screen
     *
     * @param i_lang                   Preferred language ID for this professional
     * @param i_prof                   Object (professional ID, institution ID, software ID)
     * @param i_subject                Subject
     * @param i_disch_reas_dest        Discharge reason and destination ID
     * @param i_patient                Patient ID
     * @param o_actions                List of actions
     * @param o_error                  Error
     *
     * @return                         true or false on success or error
     *
     * @author                          José Silva
     * @version                         2.6
     * @since                           2010/02/22
    **********************************************************************************************/
    FUNCTION get_actions
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_subject         IN action.subject%TYPE,
        i_disch_reas_dest IN disch_reas_dest.id_disch_reas_dest%TYPE,
        i_patient         IN patient.id_patient%TYPE,
        o_actions         OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_internal_error EXCEPTION;
        l_id_report     sys_config.value%TYPE;
        l_actions       pk_action.p_action_cur;
        l_actions_rec   pk_action.p_action_rec;
        l_t_id_action   table_number;
        l_t_from_state  table_varchar;
        l_t_desc_action table_varchar;
        l_t_icon        table_varchar;
        l_count         NUMBER := 0;
        l_flg_rep       disch_reas_dest.flg_rep_notes%TYPE;
    
        -- send gp letter
        l_flg_rep_s CONSTANT action.from_state%TYPE := 'S';
        l_add    BOOLEAN;
        l_po_box VARCHAR2(200);
    
    BEGIN
    
        IF i_disch_reas_dest IS NOT NULL
        THEN
        
            g_error := 'GET ACTION CONFIGURATION';
            SELECT flg_rep_notes
              INTO l_flg_rep
              FROM disch_reas_dest drd
             WHERE drd.id_disch_reas_dest = i_disch_reas_dest;
        
            g_error     := 'GET SYS_CONFIG REPORT';
            l_id_report := pk_sysconfig.get_config('REPORT_DISCHARGE_NOTES', i_prof);
        
            IF l_flg_rep = pk_alert_constant.g_yes
               AND l_id_report IS NOT NULL
            THEN
                g_error         := 'INIT TABLES';
                l_t_id_action   := table_number();
                l_t_from_state  := table_varchar();
                l_t_desc_action := table_varchar();
                l_t_icon        := table_varchar();
            
                g_error := 'GET CURSOR o_actions';
                IF NOT pk_action.get_actions(i_lang       => i_lang,
                                             i_prof       => i_prof,
                                             i_subject    => i_subject,
                                             i_from_state => NULL,
                                             o_actions    => l_actions,
                                             o_error      => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                g_error := 'FETCH o_actions';
                LOOP
                    l_add := TRUE;
                
                    FETCH l_actions
                        INTO l_actions_rec;
                    EXIT WHEN l_actions%NOTFOUND;
                
                    IF l_actions_rec.from_state = l_flg_rep_s
                    THEN
                        g_error := 'CHECK EDIFACT INFO';
                        IF NOT pk_adt.get_life_line_post_office_box(i_lang    => i_lang,
                                                                    i_prof    => i_prof,
                                                                    i_patient => i_patient,
                                                                    o_po_box  => l_po_box,
                                                                    o_error   => o_error)
                        THEN
                            RAISE l_internal_error;
                        END IF;
                    
                        IF l_po_box IS NULL
                        THEN
                            l_add := FALSE;
                        END IF;
                    
                    END IF;
                
                    IF l_add
                    THEN
                        l_count := l_count + 1;
                        l_t_id_action.extend;
                        l_t_from_state.extend;
                        l_t_desc_action.extend;
                        l_t_icon.extend;
                    
                        l_t_id_action(l_count) := l_actions_rec.id_action;
                        l_t_from_state(l_count) := l_actions_rec.from_state;
                        l_t_desc_action(l_count) := l_actions_rec.desc_action;
                        l_t_icon(l_count) := l_actions_rec.icon;
                    END IF;
                
                END LOOP;
            
                OPEN o_actions FOR
                    SELECT a.column_value id_action,
                           b.column_value from_state,
                           c.column_value desc_action,
                           d.column_value icon
                      FROM (SELECT column_value, rownum num
                              FROM TABLE(l_t_id_action)) a,
                           (SELECT column_value, rownum num
                              FROM TABLE(l_t_from_state)) b,
                           (SELECT column_value, rownum num
                              FROM TABLE(l_t_desc_action)) c,
                           (SELECT column_value, rownum num
                              FROM TABLE(l_t_icon)) d
                     WHERE a.num = b.num
                       AND b.num = c.num
                       AND c.num = d.num;
            ELSE
                pk_types.open_my_cursor(o_actions);
            END IF;
        
        ELSE
            pk_types.open_my_cursor(o_actions);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_ACTIONS',
                                              o_error);
            pk_types.open_my_cursor(o_actions);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_actions;

    /********************************************************************************************
     * Gets the list of available sections in the discharge notes report
     *
     * @param i_lang                   Preferred language ID for this professional
     * @param i_prof                   Object (professional ID, institution ID, software ID)
     * @param i_flg_type               Type of discharge letter: P - print discharge letter; S - send discharge letter message
     * 
     * @param o_sections               List of sections
     * @param o_report                 Report ID
     * @param o_error                  Error
     *
     * @return                         true or false on success or error
     *
     * @author                          José Silva
     * @version                         2.6
     * @since                           2010/02/22
    **********************************************************************************************/
    FUNCTION get_rep_notes_sections
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_flg_type IN discharge_rep_notes.flg_type%TYPE,
        o_sections OUT pk_print_tool.p_rep_section_cur,
        o_report   OUT reports.id_reports%TYPE,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_internal_error EXCEPTION;
        l_id_report sys_config.value%TYPE;
    
        -- print gp letter
        --l_flg_rep_p CONSTANT action.from_state%TYPE := 'P';
    
    BEGIN
    
        g_error     := 'GET SYS_CONFIG REPORT';
        l_id_report := pk_sysconfig.get_config('REPORT_DISCHARGE_NOTES', i_prof);
    
        g_error := 'GET REPORT SECTIONS';
        IF NOT pk_print_tool.get_section_list(i_lang    => i_lang,
                                              i_prof    => i_prof,
                                              i_reports => l_id_report,
                                              o_section => o_sections,
                                              o_error   => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error  := 'GET REPORT ID';
        o_report := l_id_report;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_REP_NOTES_SECTIONS',
                                              o_error);
            pk_types.open_my_cursor(o_sections);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_rep_notes_sections;

    /********************************************************************************************
     * Sets the information to be sent in the discharge notes area
     *
     * @param i_lang                   Preferred language ID for this professional
     * @param i_prof                   Object (professional ID, institution ID, software ID)
     * @param i_episode                Episode ID
     * @param i_patient                Patient ID
     * @param i_discharge              Discharge ID
     * @param i_flg_type               type of discharge notes: P - print discharge notes; S - send digital message
     * @param i_flg_task               List of tasks to be sent in the GP Letter
     * @param o_error                  Error
     *
     * @return                         true or false on success or error
     *
     * @author                          José Silva
     * @version                         2.6
     * @since                           2010/02/22
    **********************************************************************************************/
    FUNCTION set_discharge_rep_notes
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_episode   IN episode.id_episode%TYPE,
        i_patient   IN patient.id_patient%TYPE,
        i_discharge IN discharge.id_discharge%TYPE,
        i_flg_type  IN discharge_rep_notes.flg_type%TYPE,
        i_flg_task  IN discharge_rep_notes.flg_task%TYPE,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- send gp letter
        l_flg_rep_s CONSTANT action.from_state%TYPE := 'S';
        l_error_message sys_message.desc_message%TYPE;
        l_error_action  sys_message.desc_message%TYPE;
    
        l_common_error EXCEPTION;
        l_exception    EXCEPTION;
    
        l_po_box VARCHAR2(200);
    
    BEGIN
    
        g_error := 'SET DISCHARGE LETTER EVENT';
        IF i_flg_type = l_flg_rep_s
        THEN
            g_error := 'CHECK EDIFACT INFO';
            IF NOT pk_adt.get_life_line_post_office_box(i_lang    => i_lang,
                                                        i_prof    => i_prof,
                                                        i_patient => i_patient,
                                                        o_po_box  => l_po_box,
                                                        o_error   => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            IF l_po_box IS NULL
            THEN
                l_error_message := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M031');
                l_error_action  := pk_message.get_message(i_lang, i_prof, 'DISCHARGE_M032');
            
                RAISE l_common_error;
            END IF;
        
        END IF;
    
        g_error := 'SET DISCHARGE_REP_NOTES';
        IF i_flg_type IS NOT NULL
        THEN
            INSERT INTO discharge_rep_notes
                (id_discharge_rep_notes, id_discharge, id_episode, flg_task, flg_type, dt_reg)
            VALUES
                (seq_discharge_rep_notes.nextval, i_discharge, i_episode, i_flg_task, i_flg_type, current_timestamp);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_common_error THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   'SET_DISCHARGE_REP_NOTES',
                                   l_error_action,
                                   'U');
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_alert_exceptions.reset_error_state();
                RETURN FALSE;
            END;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_DISCHARGE_REP_NOTES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_discharge_rep_notes;

    /**********************************************************************************************
    * Retorna o numero da ordem do profissional
    * 
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_prof_id                profissional para o qual pretendemos que seja retornado o numero da ordem                
    * @param o_num_order              numero da ordem do profissional pretendido
    * @param o_error                  Error message
    *
    * @author                         Rui Duarte
    * @version                        1.0 
    * @since                          2009/11/06
    **********************************************************************************************/

    FUNCTION get_num_order
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_prof_id   IN professional.id_professional%TYPE,
        o_num_order OUT professional.num_order%TYPE,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        CURSOR c_num_order IS
            SELECT p.num_order
              FROM professional p
             WHERE p.id_professional = i_prof_id;
    BEGIN
        g_error := 'OPEN C_BARCODE';
        OPEN c_num_order;
        FETCH c_num_order
            INTO o_num_order;
        CLOSE c_num_order;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     'ALERT',
                                                     'PK_BARCODE',
                                                     'GET_GRID_BARCODE',
                                                     o_error);
    END;

    /********************************************************************************************
    * Clears all records from discharge and related (FK's) tables for the given id_episode's
    *
    * @param i_lang                    Language id
    * @param i_table_id_episodes       table with id episodes
    * @param o_error                   Error message
    *
    * @return                          TRUE if sucess, FALSE otherwise
    *
    * @author                          Alexandre Santos
    * @version                         2.6.0.4
    * @since                           2010-09-08
    *
    ********************************************************************************************/
    FUNCTION clear_discharge_reset
    (
        i_lang              IN language.id_language%TYPE,
        i_table_id_episodes IN table_number,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30) := 'CLEAR_DISCHARGE_RESET';
        --
        l_tbl_disch table_number;
        e_adt_exception EXCEPTION;
        l_result NUMBER;
    BEGIN
        g_error := 'CHECK ENVIRONMENT';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        EXECUTE IMMEDIATE 'SELECT alert_reset.check_environment FROM dual'
            INTO l_result;
    
        IF l_result = 1
        THEN
            g_error := 'GET ALL DISCHARGES FOR THE FOLLOWING EPISODES: ' || pk_utils.concat_table(i_table_id_episodes);
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            SELECT d.id_discharge
              BULK COLLECT
              INTO l_tbl_disch
              FROM discharge d
             WHERE d.id_episode IN (SELECT column_value id_episode
                                      FROM TABLE(i_table_id_episodes));
        
            IF l_tbl_disch.count > 0
            THEN
                --PK_ADT.DELETE_DISCHARGES
                g_error := 'DELETE ADT RECORDS FOR THE FOLLOWING ID_DISCH''s: ' || pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                IF NOT pk_adt.delete_discharges(i_lang          => i_lang,
                                                i_prof          => profissional(0, 0, 0),
                                                i_discharge_ids => l_tbl_disch,
                                                o_error         => o_error)
                THEN
                    RAISE e_adt_exception;
                END IF;
            
                --DISCHARGE_DETAIL_HIST
                g_error := 'DELETE DISCHARGE_DETAIL_HIST FOR THE FOLLOWING ID_DISCH''s: ' ||
                           pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                DELETE FROM discharge_detail_hist d
                 WHERE d.id_discharge IN (SELECT column_value id_discharge
                                            FROM TABLE(l_tbl_disch));
            
                --DISCHARGE_HIST
                g_error := 'DELETE DISCHARGE_HIST FOR THE FOLLOWING ID_DISCH''s: ' ||
                           pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                DELETE FROM discharge_hist d
                 WHERE d.id_discharge IN (SELECT column_value id_discharge
                                            FROM TABLE(l_tbl_disch));
            
                --DISCHARGE_DETAIL
                g_error := 'DELETE DISCHARGE_DETAIL FOR THE FOLLOWING ID_DISCH''s: ' ||
                           pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                DELETE FROM discharge_detail d
                 WHERE d.id_discharge IN (SELECT column_value id_discharge
                                            FROM TABLE(l_tbl_disch));
            
                --DISCH_PREP_MESG
                g_error := 'DELETE DISCH_PREP_MESG FOR THE FOLLOWING ID_DISCH''s: ' ||
                           pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                DELETE FROM disch_prep_mesg d
                 WHERE d.id_discharge IN (SELECT column_value id_discharge
                                            FROM TABLE(l_tbl_disch));
            
                --DISCH_PROF_NOTES
                g_error := 'DELETE DISCH_PROF_NOTES FOR THE FOLLOWING ID_DISCH''s: ' ||
                           pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_disch_prof_notes.del_by(where_clause_in => 'id_discharge in (' ||
                                                              pk_utils.concat_table(i_tab   => l_tbl_disch,
                                                                                    i_delim => ',') || ')');
            
                --DISCH_TRANSF_INST
                g_error := 'DELETE DISCH_TRANSF_INST FOR THE FOLLOWING ID_DISCH''s: ' ||
                           pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_disch_transf_inst.del_by(where_clause_in => 'id_discharge in (' ||
                                                               pk_utils.concat_table(i_tab   => l_tbl_disch,
                                                                                     i_delim => ',') || ')');
            
                --DISCHARGE_REP_NOTES
                g_error := 'DELETE DISCHARGE_REP_NOTES FOR THE FOLLOWING ID_DISCH''s: ' ||
                           pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                DELETE FROM discharge_rep_notes d
                 WHERE d.id_discharge IN (SELECT column_value id_discharge
                                            FROM TABLE(l_tbl_disch));
            
                --DISCHARGE_SCHEDULE
                g_error := 'DELETE DISCHARGE_SCHEDULE FOR THE FOLLOWING EPISODE''s: ' ||
                           pk_utils.concat_table(i_table_id_episodes);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_discharge_schedule.del_by(where_clause_in => 'id_episode in (' ||
                                                                pk_utils.concat_table(i_tab   => i_table_id_episodes,
                                                                                      i_delim => ',') || ')');
            
                --DISCH_NOTES_INSTR
                g_error := 'DELETE DISCHARGE_NOTES_INSTR FOR THE FOLLOWING EPISODE''s: ' ||
                           pk_utils.concat_table(i_table_id_episodes);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_disch_notes_instr.del_by(where_clause_in => 'id_discharge_notes in (select id_discharge_notes from discharge_notes where id_episode in (' ||
                                                               pk_utils.concat_table(i_tab   => i_table_id_episodes,
                                                                                     i_delim => ',') || '))');
            
                --DISCHARGE_NOTES_FOLLOW_UP
                g_error := 'DELETE DISCHARGE_NOTES_FOLLOW_UP FOR THE FOLLOWING EPISODE''s: ' ||
                           pk_utils.concat_table(i_table_id_episodes);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_discharge_notes_follow_up.del_by(where_clause_in => 'id_discharge_notes in (select id_discharge_notes from discharge_notes where id_episode in (' ||
                                                                       pk_utils.concat_table(i_tab   => i_table_id_episodes,
                                                                                             i_delim => ',') || '))');
            
                --DISCH_NOTES_DISCUSSED
                g_error := 'DELETE DISCHARGE_DETAIL FOR THE FOLLOWING EPISODE''s: ' ||
                           pk_utils.concat_table(i_table_id_episodes);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_disch_notes_discussed.del_by(where_clause_in => 'id_discharge_notes in (select id_discharge_notes from discharge_notes where id_episode in (' ||
                                                                   pk_utils.concat_table(i_tab   => i_table_id_episodes,
                                                                                         i_delim => ',') || '))');
            
                --DISCHARGE_NOTES
                g_error := 'DELETE DISCHARGE_DETAIL FOR THE FOLLOWING EPISODE''s: ' ||
                           pk_utils.concat_table(i_table_id_episodes);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_discharge_notes.del_by(where_clause_in => 'id_episode in (' ||
                                                             pk_utils.concat_table(i_tab   => i_table_id_episodes,
                                                                                   i_delim => ',') || ')');
            
                --DISCHARGE_NEWBORN
                g_error := 'DELETE DISCHARGE_NEWBORN FOR THE FOLLOWING EPISODE''s: ' ||
                           pk_utils.concat_table(i_table_id_episodes);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_discharge_newborn.del_by(where_clause_in => 'id_discharge in (select id_discharge from discharge where id_episode in (' ||
                                                               pk_utils.concat_table(i_tab   => i_table_id_episodes,
                                                                                     i_delim => ',') || '))');
            
                ts_discharge_report.del_by(where_clause_in => 'id_discharge in (select id_discharge from discharge where id_episode in (' ||
                                                              pk_utils.concat_table(i_tab   => i_table_id_episodes,
                                                                                    i_delim => ',') || '))');
                --DISCHARGE
                g_error := 'DELETE DISCHARGE FOR THE FOLLOWING ID_DISCH''s: ' || pk_utils.concat_table(l_tbl_disch);
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                DELETE FROM discharge d
                 WHERE d.id_discharge IN (SELECT column_value id_discharge
                                            FROM TABLE(l_tbl_disch));
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END clear_discharge_reset;

    /********************************************************************************************
    * Checks if there exist nursing notes for an episode
    *
    * @param i_lang            language id
    * @param i_prof            professional, software and institution ids
    * @param i_episode         episode id 
    * @param o_flg_data        Y if there exist data, N when no data found
    * @param o_error           Error message
    *
    * @return                  true or false on success or error
    *
    * @author                  Ariel Machado 
    * @version                 2.5.1.2                    
    * @since                   29-10-2010
    **********************************************************************************************/
    FUNCTION get_nursing_notes_exists
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_episode  IN episode.id_episode%TYPE,
        o_flg_data OUT VARCHAR2,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_function_name CONSTANT VARCHAR2(30) := 'get_nursing_notes_exists';
    BEGIN
    
        g_error := 'CHECK DATA EXISTS';
        BEGIN
            SELECT pk_alert_constant.g_yes
              INTO o_flg_data
              FROM dual
             WHERE EXISTS (SELECT 1
                      FROM epis_documentation ed
                     WHERE ed.id_episode = i_episode
                       AND ed.id_doc_area = pk_summary_page.g_doc_area_nursing_notes)
                OR EXISTS (SELECT 1
                      FROM epis_recomend er
                     WHERE er.id_episode = i_episode
                       AND er.flg_type = g_type_n);
        EXCEPTION
            WHEN no_data_found THEN
                o_flg_data := pk_alert_constant.g_no;
        END;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
            BEGIN
                l_error_in.set_all(i_lang, SQLCODE, SQLERRM, g_error, g_owner, g_package_name, l_function_name);
                RETURN pk_alert_exceptions.process_error(l_error_in, o_error);
            END;
    END get_nursing_notes_exists;

    /********************************************************************************************
    * Checks the following conditions:
    *  - A new discharge cannot be given if already exists an active or pending one
    *  - It's not possible to change a discharge of an inactive episode unless input var i_can_edt_inact_epis = 'Y'
    * ATTENTION: The call to this function must be made at the end of the discharge/disposition logic
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_episode               Episode id
    * @param i_can_edt_inact_epis    Can edit inactive episodes?
    * @param o_error                 error message
    *
    * @return                        True if all validations are ok, otherwise returns false
    *
    * @author                        Alexandre Santos
    * @version                       2.5.1
    * @since                         27/12/2010
    ********************************************************************************************/
    FUNCTION check_discharge
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_episode            IN episode.id_episode%TYPE,
        i_can_edt_inact_epis IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_DISCHARGE';
        --
        l_code_error_msg CONSTANT sys_message.code_message%TYPE := 'DISCHARGE_M004';
        l_error_msg sys_message.desc_message%TYPE;
        l_error EXCEPTION;
        l_error_title VARCHAR2(4000);
        --
        l_count_disch      PLS_INTEGER;
        l_count_inact_epis PLS_INTEGER;
    BEGIN
    
        l_error_title := pk_message.get_message(i_lang, 'COMMON_T013');
    
        g_error := 'GET TOTAL EPISODE DISCHARGES - ID_EPISODE: ' || i_episode;
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        SELECT COUNT(*)
          INTO l_count_disch
          FROM discharge d
         WHERE d.id_episode = i_episode
           AND d.flg_status IN (pk_discharge.g_disch_flg_active, pk_discharge.g_disch_flg_pend);
    
        --A new discharge cannot be given if already exists an active or pending one
        g_error := 'TOTAL DISCHARGES: ' || l_count_disch;
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF l_count_disch > 1
        THEN
            g_error := 'MORE THEN ONE DISCHARGE';
            pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            RAISE l_error;
        END IF;
    
        g_error := 'CAN EDT INACT EPIS: ' || i_can_edt_inact_epis;
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF i_can_edt_inact_epis = pk_alert_constant.g_no
        THEN
            g_error := 'VERIFY IF CURRENT EPISODE IS INACTIVE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            SELECT COUNT(*)
              INTO l_count_inact_epis
              FROM episode epis
             WHERE epis.id_episode = i_episode
               AND epis.flg_status = pk_alert_constant.g_inactive;
        
            g_error := 'TOTAL INACT EPIS: ' || l_count_inact_epis;
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            IF l_count_inact_epis > 0
            THEN
                g_error := 'INACTIVE EPISODE';
                pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                RAISE l_error;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_error THEN
            l_error_msg := pk_message.get_message(i_lang, i_prof, i_code_mess => l_code_error_msg);
        
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   'DISCHARGE_M099',
                                   l_error_msg,
                                   g_error,
                                   g_owner,
                                   g_package_name,
                                   l_func_name,
                                   NULL,
                                   'U',
                                   l_error_title);
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes;
                RETURN FALSE;
            
            END;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END check_discharge;
    --
    /********************************************************************************************
    * Gets flag patient problem configuration variables (id_disch_reas_status, code_domain)
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_discharge_reason      Discharge reason id 
    * @param i_screen_name           Screen name. 
    * @param o_disch_reas_status     Configurated Dich_reas_status id. 
    * @param o_code_domain           Configurated code domain. 
    * @param o_error                 error message
    *
    * @return                        True if all validations are ok, otherwise returns false
    *
    * @author                        Alexandre Santos
    * @version                       2.6.0.3.4
    * @since                         18/01/2010
    ********************************************************************************************/
    FUNCTION get_flg_pat_cond_cfg_vars
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_discharge_reason  IN discharge_reason.id_discharge_reason%TYPE,
        i_screen_name       IN disch_reas_status.screen_name%TYPE,
        o_disch_reas_status OUT disch_reas_status.id_disch_reas_status%TYPE,
        o_code_domain       OUT sys_domain.code_domain%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_CFG_VARS';
        --
        l_first_ln CONSTANT PLS_INTEGER := 1;
        l_first    CONSTANT PLS_INTEGER := 1;
        l_second   CONSTANT PLS_INTEGER := 2;
        --
        l_missing_values EXCEPTION;
    BEGIN
        --Get disch_reas_status and code_domain
        --Configuration priorities are:
        --     - If exists a discharge reason specific configuration use it first
        --     - Then use the logged professional institution
        --     - Then use the logged professional software
        --And get the first record
        BEGIN
            g_error := 'GET DISCH_REAS_STATUS AND CODE_DOMAIN';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            SELECT t.id_disch_reas_status, t.code_domain
              INTO o_disch_reas_status, o_code_domain
              FROM (SELECT drs.id_disch_reas_status,
                           drs.code_domain,
                           row_number() over(ORDER BY decode(drs.id_discharge_reason, NULL, l_second, l_first), --
                           decode(drs.id_institution, i_prof.institution, l_first, l_second), --
                           decode(drs.id_software, i_prof.software, l_first, l_second)) line_number
                      FROM disch_reas_status drs
                     WHERE drs.flg_available = pk_alert_constant.g_yes
                       AND (drs.id_discharge_reason = i_discharge_reason OR i_discharge_reason IS NULL OR
                           drs.id_discharge_reason IS NULL)
                       AND (drs.screen_name = i_screen_name OR i_screen_name IS NULL OR drs.screen_name IS NULL)
                       AND drs.id_institution IN (pk_alert_constant.g_inst_all, i_prof.institution)
                       AND drs.id_software IN (pk_alert_constant.g_soft_all, i_prof.software)) t
             WHERE t.line_number = l_first_ln;
        EXCEPTION
            WHEN no_data_found THEN
                --A configuration is missing so show the following error
                g_error := 'INVALID CONFIGURATION - NO_DATA_FOUND -  SCREEN: ' || i_screen_name ||
                           '; DISCHARGE_REASON: ' || i_discharge_reason || ';';
                pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                RAISE;
        END;
    
        IF o_disch_reas_status IS NULL
           OR o_code_domain IS NULL
        THEN
            --There are missing values in the configuration so show the following error
            g_error := 'INVALID CONFIGURATION - MISSING VALUES - DISCH_REAS_STATUS: ' || o_disch_reas_status ||
                       '; CODE_DOMAIN: ' || o_code_domain || ';';
            pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            RAISE l_missing_values;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_flg_pat_cond_cfg_vars;

    --
    /********************************************************************************************
    * Gets the multichoice options of patient condition field
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_discharge_reason      Discharge reason id 
    * @param i_screen_name           Screen name. 
    * @param o_items                 Options list
    * @param o_error                 error message
    *
    * @return                        True if all validations are ok, otherwise returns false
    *
    * @author                        Alexandre Santos
    * @version                       2.6.0.3.4
    * @since                         18/01/2010
    ********************************************************************************************/
    FUNCTION get_patient_conditions
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_discharge_reason IN discharge_reason.id_discharge_reason%TYPE,
        i_screen_name      IN disch_reas_status.screen_name%TYPE,
        o_items            OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PATIENT_CONDITIONS';
        --
        l_disch_reas_status disch_reas_status.id_disch_reas_status%TYPE;
        l_code_domain       sys_domain.code_domain%TYPE;
        --
        l_missing_confs EXCEPTION;
    BEGIN
        g_error := 'GET CFG VALUES TO BE USED';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF NOT get_flg_pat_cond_cfg_vars(i_lang              => i_lang,
                                         i_prof              => i_prof,
                                         i_discharge_reason  => i_discharge_reason,
                                         i_screen_name       => i_screen_name,
                                         o_disch_reas_status => l_disch_reas_status,
                                         o_code_domain       => l_code_domain,
                                         o_error             => o_error)
        THEN
            RAISE l_missing_confs;
        END IF;
    
        --Get the multichoice patient conditions items ordered by rank and then by description of code_domain
        g_error := 'GET ITEMS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        OPEN o_items FOR
            SELECT drsv.val data, t.desc_val label, drsv.flg_default
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang, i_prof, l_code_domain, NULL)) t
              JOIN disch_reas_status_val drsv
                ON t.val = drsv.val
             WHERE drsv.flg_available = pk_alert_constant.g_yes
               AND drsv.id_disch_reas_status = l_disch_reas_status
             ORDER BY drsv.rank, label;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_missing_confs THEN
            pk_types.open_my_cursor(o_items);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_items);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_patient_conditions;
    --

    /********************************************************************************************
    * Get patient condition description
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_discharge             Discharge id 
    * @param i_discharge_reason      Discharge reason id 
    * @param i_screen_name           Screen name. 
    * @param i_flg_pat_condition     Patient condition flag 
    *
    * @return                        Patient condition description
    *
    * @author                        Alexandre Santos
    * @version                       2.6.0.3.4
    * @since                         18/01/2010
    ********************************************************************************************/
    FUNCTION get_patient_condition
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_discharge         IN discharge.id_discharge%TYPE,
        i_discharge_reason  IN discharge_reason.id_discharge_reason%TYPE,
        i_flg_pat_condition IN discharge_detail.flg_pat_condition%TYPE
    ) RETURN sys_domain.desc_val%TYPE IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PATIENT_CONDITION';
        --      
        l_desc sys_domain.desc_val%TYPE;
        --
        l_disch_reas_status disch_reas_status.id_disch_reas_status%TYPE;
        l_code_domain       sys_domain.code_domain%TYPE;
        --
        l_missing_confs EXCEPTION;
        l_error t_error_out;
    BEGIN
        g_error := 'GET CFG VALUES TO BE USED';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF NOT get_flg_pat_cond_cfg_vars(i_lang              => i_lang,
                                         i_prof              => i_prof,
                                         i_discharge_reason  => i_discharge_reason,
                                         i_screen_name       => pk_discharge_core.get_disch_screen_name(i_lang      => i_lang,
                                                                                                        i_prof      => i_prof,
                                                                                                        i_discharge => i_discharge),
                                         o_disch_reas_status => l_disch_reas_status,
                                         o_code_domain       => l_code_domain,
                                         o_error             => l_error)
        THEN
            RAISE l_missing_confs;
        END IF;
    
        g_error := 'GET PAT_CONDITION DESCRIPTION';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        SELECT pk_sysdomain.get_domain(l_code_domain, drsv.val, i_lang) descr
          INTO l_desc
          FROM disch_reas_status_val drsv
         WHERE drsv.id_disch_reas_status = l_disch_reas_status
           AND drsv.val = i_flg_pat_condition;
    
        RETURN l_desc;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_patient_condition;

    /**********************************************************************************************
    * Verifies if patient (in a specific episode) has already been discharged 
    *
    * @param          i_lang              language id    
    * @param          i_prof              professional type
    * @param          i_episode           episode id
    * @param          o_discharge         Discharge state: 
    *                                     Y if the discharge is set for the given episode and N otherwise
    * @param          o_error             error message
    *
    * @return         boolean             true on success, otherwise false
    *
    * @author                             Orlando Antunes
    * @version                            2.5.1.2
    * @since                              2010/10/20       
    ********************************************************************************************/
    FUNCTION get_epis_discharge_state
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_episode   IN episode.id_episode%TYPE,
        o_discharge OUT VARCHAR2,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_count_discharge PLS_INTEGER := 0;
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DISCHARGE_STATE';
    BEGIN
    
        SELECT COUNT(*)
          INTO l_count_discharge
          FROM discharge d
         WHERE d.id_episode = i_episode
           AND d.flg_status IN (g_disch_flg_active, g_disch_flg_pend);
    
        IF l_count_discharge > 0
        THEN
            o_discharge := pk_alert_constant.g_yes;
        ELSE
            o_discharge := pk_alert_constant.g_no;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_epis_discharge_state;

    /********************************************************************************************
    * Gets the discharge reason and discharge destination descriptions for the episode
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure
    * @param i_episode               Episode id 
    * @param o_reason                Discharge reason
    * @param o_destination           Discharge destination
    * @param o_error                 error message
    *
    * @return                        true or false on success or error
    *
    * @author                        Nuno Alves
    * @version                       2.6.3.8.2
    * @since                         29/04/2015
    ********************************************************************************************/
    FUNCTION get_epis_disch_rea_dest_desc
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_episode     IN episode.id_episode%TYPE,
        o_reason      OUT translation.desc_lang_2%TYPE,
        o_destination OUT translation.desc_lang_2%TYPE,
        o_signature   OUT VARCHAR2,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DISCH_REA_DEST_DESC';
    
        l_reason      translation.desc_lang_2%TYPE;
        l_destination translation.desc_lang_2%TYPE;
        l_signature   VARCHAR2(4000);
    BEGIN
        g_error := 'GET DISCHARGE DESTINATION AND REASON';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        BEGIN
            SELECT t.discharge_dest, t.discharge_reason, t.signature
              INTO l_destination, l_reason, l_signature
              FROM (SELECT pk_discharge.get_disch_destination(i_lang              => i_lang,
                                                              i_id_dep_clin_serv  => drd.id_dep_clin_serv,
                                                              i_id_department     => drd.id_department,
                                                              i_id_institution    => drd.id_institution,
                                                              i_id_discharge_dest => drd.id_discharge_dest) discharge_dest,
                           pk_translation.get_translation(i_lang, dr.code_discharge_reason) discharge_reason,
                           pk_prof_utils.get_detail_signature(i_lang, i_prof, d.id_episode, d.dt_med_tstz, d.id_prof_med) signature,
                           row_number() over(ORDER BY nvl(nvl(nvl(nvl(d.dt_pend_tstz, d.dt_med_tstz), d.dt_nurse), d.dt_nutritionist), d.dt_therapist) DESC) rn
                      FROM discharge d
                      LEFT JOIN disch_reas_dest drd
                        ON drd.id_disch_reas_dest = d.id_disch_reas_dest
                      LEFT JOIN discharge_reason dr
                        ON dr.id_discharge_reason = drd.id_discharge_reason
                     WHERE d.id_episode = i_episode
                       AND d.flg_status <> pk_discharge.g_disch_flg_status_cancel) t
             WHERE t.rn = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_reason      := NULL;
                l_destination := NULL;
                l_signature   := NULL;
        END;
    
        o_reason      := l_reason;
        o_destination := l_destination;
        o_signature   := l_signature;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_epis_disch_rea_dest_desc;
    /********************************************************************************************
    * Returns the expected discharge date.    
    *
    * @param i_lang                  language identifier
    * @param i_prof                  logged professional structure    
    * @param i_episode               episode identifier
    * @param i_discharge_date        Discharge schedule date 
    * @param i_flg_hour_origin       Flg_hour_origin ('D' -date; 'DH' - date and hour)
    *
    * @return                        Discharge schedule date formatted string
    *
    * @author                        Sofia Mendes
    * @version                       2.6.1.2
    * @since                         23-Ago-2011
    ********************************************************************************************/
    FUNCTION get_formatted_disch_sch_date
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_episode      IN episode.id_episode%TYPE,
        i_discharge_date  IN discharge_schedule.dt_discharge_schedule%TYPE DEFAULT NULL,
        i_flg_hour_origin IN discharge_schedule.flg_hour_origin%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_dt_discharge_sch discharge_schedule.dt_discharge_schedule%TYPE;
        l_flg_hour_origin  discharge_schedule.flg_hour_origin%TYPE;
        l_disch_date       VARCHAR2(4000);
        l_error            t_error_out;
    BEGIN
        IF (i_discharge_date IS NULL OR i_flg_hour_origin IS NULL)
        THEN
            g_error := 'CALL pk_discharge.get_discharge_schedule_date. i_id_episode: ' || i_id_episode;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_discharge.get_discharge_schedule_date(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_id_episode      => i_id_episode,
                                                            o_discharge_date  => l_dt_discharge_sch,
                                                            o_flg_hour_origin => l_flg_hour_origin,
                                                            o_error           => l_error)
            THEN
                RAISE g_exception;
            END IF;
        ELSE
            l_dt_discharge_sch := i_discharge_date;
            l_flg_hour_origin  := i_flg_hour_origin;
        END IF;
    
        IF l_flg_hour_origin = pk_discharge.g_disch_flg_hour_d
        THEN
            g_error := 'CALL pk_date_utils.dt_chr_tsz';
            pk_alertlog.log_debug(g_error);
            l_disch_date := pk_date_utils.dt_chr_tsz(i_lang => i_lang, i_date => l_dt_discharge_sch, i_prof => i_prof);
        ELSE
            g_error := 'CALL pk_date_utils.dt_chr_tsz';
            pk_alertlog.log_debug(g_error);
            l_disch_date := pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                        i_date => l_dt_discharge_sch,
                                                        i_inst => i_prof.institution,
                                                        i_soft => i_prof.software);
        END IF;
    
        RETURN l_disch_date;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_FORMATTED_DISCH_SCH_DATE',
                                              l_error);
            RETURN NULL;
    END get_formatted_disch_sch_date;

    /**************************************************************************
    * Get the discharge schedule flg_hour_origin. 
    *                                                                         
    * @param i_lang                   Language ID                             
    * @param i_prof                   Profissional ID                         
    * @param i_id_discharge_schedule  Discharge schedule Id    
    * 
    * Return                          Flg_hour_origin ('D' -date; 'DH' - date and hour) 
    *                                                                       
    * @author                         Sofia Mendes                       
    * @version                        2.6.1                                
    * @since                          24-Aug-2011                                
    **************************************************************************/
    FUNCTION get_dich_sch_flg_hour_origin
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_discharge_schedule IN discharge_schedule.id_discharge_schedule%TYPE
    ) RETURN discharge_schedule.flg_hour_origin%TYPE IS
        l_flg_hour_origin discharge_schedule.flg_hour_origin%TYPE;
        l_error           t_error_out;
    BEGIN
        g_error := 'GET discharge schedule flg_hour_origin. i_id_discharge_schedule: ' || i_id_discharge_schedule;
        pk_alertlog.log_debug(g_error);
        SELECT ds.flg_hour_origin
          INTO l_flg_hour_origin
          FROM discharge_schedule ds
         WHERE ds.id_discharge_schedule = i_id_discharge_schedule;
    
        RETURN l_flg_hour_origin;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DICH_SCH_FLG_HOUR_ORIGIN',
                                              l_error);
            RETURN NULL;
    END get_dich_sch_flg_hour_origin;
    --    

    /********************************************************************************************
    * Get medication reconciliation info
    *
    * @param i_lang                    Language ID
    * @param i_prof                    Professional info
    * @param i_id_patient              Patient ID
    * @param i_id_episode              Episode ID
    * @param o_info                    Medication reconciliation data
    * @param o_error                   Error message
    * 
    * @return                          TRUE if sucess, FALSE otherwise
    *
    * @author                          José Brito
    * @version                         2.6
    * @since                           29-Sep-2011
    *
    **********************************************************************************************/
    FUNCTION get_reconciliation_status
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN patient.id_patient%TYPE,
        i_id_episode IN episode.id_episode%TYPE,
        o_info       OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'GET_RECONCILIATION_STATUS';
    BEGIN
    
        RETURN pk_api_pfh_clindoc_in.get_reconciliation_status(i_lang       => i_lang,
                                                               i_prof       => i_prof,
                                                               i_id_patient => i_id_patient,
                                                               i_id_episode => i_id_episode,
                                                               o_info       => o_info,
                                                               o_error      => o_error);
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_info);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_reconciliation_status;
    /***
    * Checks if new disposition screen should be opened
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info   
    * @param i_id_DISCH_REAS_DEST     id_DISCH_REAS_DEST to check
    *
    * @param o_check_disposition_fe   'Y' or 'N' 
    * @param o_error                   Error message
    *
    * @return                          TRUE if sucess, FALSE otherwise
    *
    * @author   Paulo Teixeira
    * @version  2.6.1.2
    * @since    2012/03/23
    */
    FUNCTION check_disposition_fe
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_disch_reas_dest   IN disch_reas_dest.id_disch_reas_dest%TYPE,
        o_check_disposition_fe OUT VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'CHECK_DISPOSITION_FE';
    BEGIN
        g_error := 'check_DISPOSITION_FE';
    
        o_check_disposition_fe := check_disposition_fe_aux(i_lang               => i_lang,
                                                           i_prof               => i_prof,
                                                           i_id_disch_reas_dest => i_id_disch_reas_dest);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            o_check_disposition_fe := pk_alert_constant.g_no;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END check_disposition_fe;
    /***
    * Checks if new disposition screen should be opened
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info   
    * @param i_id_DISCH_REAS_DEST     id_DISCH_REAS_DEST to check
    *
    * @return                          Y / N
    *
    * @author   Paulo Teixeira
    * @version  2.6.1.2
    * @since    2012/03/23
    */
    FUNCTION check_disposition_fe_aux
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_disch_reas_dest IN disch_reas_dest.id_disch_reas_dest%TYPE
    ) RETURN VARCHAR2 IS
        l_return            VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_values            sys_config.value%TYPE := pk_sysconfig.get_config('ID_DISCHARGE_DEST_DISPOSITION_FE', i_prof);
        l_pipe              VARCHAR2(1 CHAR) := '|';
        l_id_discharge_dest discharge_dest.id_discharge_dest%TYPE;
        l_is_disch_hhc      VARCHAR2(1 CHAR);
    BEGIN
    
        SELECT nvl(dr.flg_hhc_disch, pk_alert_constant.g_no)
          INTO l_is_disch_hhc
          FROM discharge_reason dr
          JOIN disch_reas_dest drd
            ON drd.id_discharge_reason = dr.id_discharge_reason
         WHERE drd.id_disch_reas_dest = i_id_disch_reas_dest;
        IF l_is_disch_hhc = pk_alert_constant.g_yes
        THEN
            l_return := 'H';
        ELSE
            g_error := 'check_DISPOSITION_FE';
            IF substr(l_values, 1, 1) != l_pipe
            THEN
                l_values := l_pipe || l_values;
            END IF;
        
            IF substr(l_values, length(l_values), 1) != l_pipe
            THEN
                l_values := l_values || l_pipe;
            END IF;
        
            g_error := 'get id_discharge_dest';
            SELECT drd.id_discharge_dest
              INTO l_id_discharge_dest
              FROM disch_reas_dest drd
             WHERE drd.id_disch_reas_dest = i_id_disch_reas_dest;
        
            IF instr(l_values, l_pipe || l_id_discharge_dest || l_pipe) > 0
            THEN
                l_return := pk_alert_constant.g_yes;
            END IF;
        END IF;
        RETURN l_return;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN l_return;
    END check_disposition_fe_aux;

    /*
    * Get the description of a discharge instruction to use on single pages import mechanism
    *
    * @param i_lang           language identifier
    * @param i_prof           logged professional structure
    * @param i_disch_note     discharge note identifier
    * @param i_flg_short      Short descritpion or long descritpion (Y - short description)
    *
    * @return                 Discharge instrution description
    *
    * @author                 Sérgio Santos
    * @version                2.6.2
    * @since                  2012/08/22
    */
    FUNCTION get_sp_disch_instr_desc
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_disch_notes        IN discharge_notes.id_discharge_notes%TYPE,
        i_flg_short             IN VARCHAR2 DEFAULT 'N',
        i_desc_type             IN VARCHAR2 DEFAULT NULL,
        i_description_condition IN VARCHAR2 DEFAULT NULL
    ) RETURN CLOB IS
        l_description CLOB;
    
        l_disc_instr_by_msg sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                    i_prof      => i_prof,
                                                                                    i_code_mess => 'DISCHARGE_NOTES_T002');
        l_rel_from_msg      sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                    i_prof      => i_prof,
                                                                                    i_code_mess => 'DISCHARGE_NOTES_M009');
        l_from_msg          sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                    i_prof      => i_prof,
                                                                                    i_code_mess => 'DISCHARGE_NOTES_M020');
        l_to_msg            sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                    i_prof      => i_prof,
                                                                                    i_code_mess => 'DISCHARGE_NOTES_M011');
        l_restr_activ_msg   sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                    i_prof      => i_prof,
                                                                                    i_code_mess => 'DISCHARGE_NOTES_M023');
        l_followup_by_msg   sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                    i_prof      => i_prof,
                                                                                    i_code_mess => 'DISCHARGE_NOTES_M024');
        /*
        l_followup_on_msg   sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                    i_prof      => i_prof,
                                                                                    i_code_mess => 'DISCHARGE_NOTES_M025');
        */
        l_followup_with NUMBER(24);
    BEGIN
    
        /*Data block Discharge instructions
        Attributes: Discharge notes by, Date and Time, Discharge instructions text, Release from description (From - date, To - date) and Restrict activity for text
        Import mechanism: 
          Attributes in 2nd level: Discharge notes by and date and time
          More information level: Discharge instructions text, Release from description (From - date, To - date) and Restrict activity for text
          Sorted by: Date and Time
          Information imported to the page: 
            Discharge instructions text, Release from description (From - date, To - date) and Restrict activity for text
         */
        IF i_desc_type = pk_prog_notes_constants.g_desc_type_s
        THEN
        
            l_description := get_dn_instr_list(i_lang, i_prof, i_id_disch_notes);
        ELSIF i_desc_type = pk_prog_notes_constants.g_desc_type_c
        THEN
            IF i_description_condition = 'LABEL'
            THEN
            
                l_description := pk_message.get_message(i_lang, 'DISCH_INSTR_LABEL');
            END IF;
        
        ELSE
            IF i_flg_short = pk_alert_constant.g_yes
            THEN
                SELECT l_disc_instr_by_msg || ' ' ||
                       pk_prof_utils.get_name_signature(i_lang, i_prof, dn.id_professional) || ', ' ||
                       pk_date_utils.date_char_tsz(i_lang, dn.dt_creation_tstz, i_prof.institution, i_prof.software)
                  INTO l_description
                  FROM discharge_notes dn
                 WHERE dn.id_discharge_notes = i_id_disch_notes;
            ELSE
                BEGIN
                    SELECT dnf.id_follow_up_with
                      INTO l_followup_with
                      FROM discharge_notes_follow_up dnf
                     WHERE dnf.id_discharge_notes = i_id_disch_notes;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_followup_with := NULL;
                END;
            
                -- Release from description (From - date, To - date) and Restrict activity for text
                SELECT
                -- Discharge instructions text
                 dn.discharge_instructions || chr(10) ||
                 -- Release from description (From - date, To - date)           
                  decode(dn.release_from,
                         NULL,
                         NULL,
                         l_rel_from_msg || ' ' ||
                         lower(pk_sysdomain.get_domain('DISCHARGE_NOTES.RELEASE_FROM', dn.release_from, i_lang)) || ', ') ||
                  decode(dn.dt_from,
                         NULL,
                         NULL,
                         lower(l_from_msg) || ' ' || pk_date_utils.date_chr_short_read_tsz(i_lang, dn.dt_from, i_prof) || ' ') ||
                  decode(dn.dt_until,
                         NULL,
                         NULL,
                         lower(l_to_msg) || ': ' || pk_date_utils.date_chr_short_read_tsz(i_lang, dn.dt_until, i_prof)) ||
                 --Restrict activity for text
                  decode(dn.notes_release, NULL, NULL, chr(10) || l_restr_activ_msg || ' ' || dn.notes_release) ||
                 --Followup info
                  decode(l_followup_with,
                         NULL,
                         NULL,
                         chr(10) || l_followup_by_msg || ' ' ||
                         get_follow_up_with_list(i_lang           => i_lang,
                                                 i_prof           => i_prof,
                                                 i_id_disch_notes => i_id_disch_notes,
                                                 i_id_episode     => dn.id_episode))
                  INTO l_description
                  FROM discharge_notes dn
                 WHERE dn.id_discharge_notes = i_id_disch_notes;
            END IF;
        END IF;
    
        RETURN l_description;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_sp_disch_instr_desc;

    FUNCTION send_discharge_letter_to_crm
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_episode     IN episode.id_episode%TYPE,
        i_id_epis_report IN epis_report.id_epis_report%TYPE,
        o_ws_response    OUT CLOB,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rec_disch_message pk_edis_types.rec_disch_message;
        l_ret               BOOLEAN;
        l_id_patient        patient.id_patient%TYPE;
        l_dt_begin_tstz     episode.dt_begin_tstz%TYPE;
        l_dummy             VARCHAR2(4000);
        l_hp_id_hp          pat_health_plan.id_health_plan%TYPE;
        l_prof_resp         professional.id_professional%TYPE;
        --l_file              CLOB;
        -- WEBSERVICES
        g_ws_execution_request CONSTANT VARCHAR2(500 CHAR) := 'execution_request';
        l_internal_error EXCEPTION;
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'SEND_DISCHARGE_LETTER';
        --l_id_report    NUMBER;
        l_epis_report epis_report.id_epis_report%TYPE;
        --l_dt_discharge discharge.dt_med_tstz%TYPE;
        CURSOR c_gp_info IS
            SELECT p.id_professional,
                   (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional)
                      FROM dual) physician_name,
                   p.email
              FROM pat_professional_inst pp
              JOIN professional p
                ON pp.id_professional = p.id_professional
             WHERE id_patient = l_id_patient
               AND pp.flg_family_physician = pk_alert_constant.g_yes;
    
        CURSOR c_institution IS
            SELECT pk_translation.get_translation(i_lang, i.code_institution),
                   i.address,
                   i.location,
                   i.zip_code,
                   i.phone_number
              FROM institution i
             WHERE i.id_institution = i_prof.institution;
    
        CURSOR c_professional IS
            SELECT (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional)
                      FROM dual),
                   email
              FROM professional p
             WHERE p.id_professional = l_prof_resp;
    
        CURSOR c_report IS
            SELECT er.rep_binary_file,
                   er.id_epis_report,
                   REPLACE(pk_translation.get_translation(i_lang, r.code_reports_title), ' ', '') || '.pdf' report_name
              FROM epis_report er
              JOIN reports r
                ON er.id_reports = r.id_reports
             WHERE er.id_epis_report = i_id_epis_report;
    
        /*
        CURSOR c_discharge IS
            SELECT d.dt_med_tstz
              FROM discharge d
             WHERE d.id_episode = i_id_episode
               AND d.flg_status = 'A';
        */
    BEGIN
        l_id_patient := pk_episode.get_epis_patient(i_lang => i_lang, i_prof => i_prof, i_episode => i_id_episode);
    
        OPEN c_report;
        FETCH c_report
            INTO l_rec_disch_message.attachfile, l_epis_report, l_rec_disch_message.attach_name;
        CLOSE c_report;
    
        l_rec_disch_message.gp_name := pk_patient.get_designated_provider(i_lang, i_prof, l_id_patient, i_id_episode);
    
        IF NOT pk_episode.get_epis_dt_begin_tstz(i_lang          => i_lang,
                                                 i_prof          => i_prof,
                                                 i_id_episode    => i_id_episode,
                                                 o_dt_begin_tstz => l_dt_begin_tstz,
                                                 o_error         => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        l_rec_disch_message.episode_date := pk_date_utils.date_chr_short_read_tsz(i_lang => i_lang,
                                                                                  i_date => l_dt_begin_tstz,
                                                                                  i_prof => i_prof);
    
        l_rec_disch_message.episode_time := pk_date_utils.date_char_hour_tsz(i_lang => i_lang,
                                                                             i_date => l_dt_begin_tstz,
                                                                             i_inst => i_prof.institution,
                                                                             i_soft => i_prof.software);
    
        OPEN c_gp_info;
        FETCH c_gp_info
            INTO l_rec_disch_message.gp_id, l_rec_disch_message.gp_name, l_rec_disch_message.gp_email;
        CLOSE c_gp_info;
    
        OPEN c_institution;
        FETCH c_institution
            INTO l_rec_disch_message.address_1,
                 l_rec_disch_message.address_2,
                 l_rec_disch_message.address_3,
                 l_rec_disch_message.address_4,
                 l_rec_disch_message.address_5;
        CLOSE c_institution;
    
        l_rec_disch_message.patient_name := pk_adt.get_patient_name(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_patient      => l_id_patient,
                                                                    i_is_prof_resp => 1);
    
        IF NOT pk_adt.get_national_health_number(i_lang            => i_lang,
                                                 i_prof            => i_prof,
                                                 i_id_patient      => l_id_patient,
                                                 o_hp_id_hp        => l_hp_id_hp,
                                                 o_num_health_plan => l_rec_disch_message.patient_nhs,
                                                 o_hp_entity       => l_dummy,
                                                 o_hp_desc         => l_dummy,
                                                 o_error           => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        l_prof_resp := pk_hand_off.get_episode_responsible(i_lang       => i_lang,
                                                           i_prof       => i_prof,
                                                           i_id_episode => i_id_episode,
                                                           o_error      => o_error);
    
        OPEN c_professional;
        FETCH c_professional
            INTO l_rec_disch_message.episode_prof_name, l_rec_disch_message.professional_email;
        CLOSE c_professional;
    
        l_rec_disch_message.episode_final_diagnoses := pk_diagnosis.get_final_diagnosis(i_lang       => i_lang,
                                                                                        i_prof       => i_prof,
                                                                                        i_id_episode => i_id_episode,
                                                                                        o_error      => o_error);
    
        pk_alertlog.log_debug(text => ' pk_discharge_crm.send_message_to_crmr id_episode:' || i_id_episode);
    
        IF NOT pk_discharge_crm.send_message_to_crm(i_lang          => i_lang,
                                                    i_prof          => i_prof,
                                                    i_ws_name       => g_ws_execution_request,
                                                    i_discharge_msg => l_rec_disch_message,
                                                    o_ws_response   => o_ws_response,
                                                    o_error         => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
    
        WHEN l_internal_error THEN
            pk_alertlog.log_warn(g_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        
    END send_discharge_letter_to_crm;

    /**********************************************************************************************
    * Send discharge letter to GP
    *
    * @param i_lang                  Language ID
    * @param i_prof                  Professional's details
    * @param i_id_patient            Patient name
    * @param i_id_episode            Episode
    * @param o_error                 Error message
    *
    * @return                        True on success, false otherwise
    *                        
    * @author                        Elisabete Bugalho
    * @version                       2.6.3
    * @since                         2013/09/18 
    ***********************************************************************************************/
    FUNCTION send_discharge_letter
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE,
        i_id_report  IN reports.id_reports%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        --l_ret           BOOLEAN;
        --l_id_patient    patient.id_patient%TYPE;
        l_dt_begin_tstz episode.dt_begin_tstz%TYPE;
        l_internal_error EXCEPTION;
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'SEND_DISCHARGE_LETTER';
        l_epis_report  epis_report.id_epis_report%TYPE;
        l_id_discharge discharge.id_discharge%TYPE;
        l_dt_discharge discharge.dt_med_tstz%TYPE;
        l_send_to_crm  VARCHAR2(1);
        l_response     CLOB;
        CURSOR c_report(i_dt_discharge discharge.dt_med_tstz%TYPE) IS
            SELECT id_epis_report
              FROM (SELECT er.id_epis_report
                      FROM epis_report er
                      JOIN reports r
                        ON er.id_reports = r.id_reports
                     WHERE er.id_episode = i_id_episode
                       AND er.id_reports = i_id_report
                       AND er.dt_creation_tstz > i_dt_discharge
                     ORDER BY er.adw_last_update DESC)
             WHERE rownum = 1;
    
        CURSOR c_discharge IS
            SELECT d.id_discharge, d.dt_med_tstz
              FROM discharge d
             WHERE d.id_episode = i_id_episode
               AND d.flg_status = pk_discharge_core.g_disch_status_active;
    BEGIN
        OPEN c_discharge;
        FETCH c_discharge
            INTO l_id_discharge, l_dt_discharge;
        CLOSE c_discharge;
    
        IF i_id_report IS NOT NULL
        THEN
            OPEN c_report(l_dt_discharge);
            FETCH c_report
                INTO l_epis_report;
            CLOSE c_report;
        END IF;
    
        IF l_epis_report IS NULL
        THEN
            RETURN FALSE;
        END IF;
        pk_alertlog.log_debug(text => ' pk_ia_event_common.discharge_report_new id_episode:' || i_id_episode);
        pk_ia_event_common.discharge_report_new(i_id_institution  => i_prof.institution,
                                                i_id_professional => i_prof.id,
                                                i_id_software     => i_prof.software,
                                                i_id_language     => i_lang,
                                                i_id_discharge    => l_id_discharge,
                                                i_id_epis_report  => l_epis_report);
    
        pk_alertlog.log_debug(text => ' pk_discharge_crm.send_message_to_crm id_episode:' || i_id_episode);
        l_send_to_crm := pk_discharge_crm.check_send_to_crm(i_lang      => i_lang,
                                                            i_prof      => i_prof,
                                                            i_id_report => i_id_report);
        IF l_send_to_crm = pk_alert_constant.g_yes
        THEN
            IF NOT send_discharge_letter_to_crm(i_lang           => i_lang,
                                                i_prof           => i_prof,
                                                i_id_episode     => i_id_episode,
                                                i_id_epis_report => l_epis_report,
                                                o_ws_response    => l_response,
                                                o_error          => o_error)
            THEN
                pk_alertlog.log_error(text            => 'ERROR SENDING DISCHARGE LETTER to CRM ID_EPISODE:' ||
                                                         i_id_episode,
                                      object_name     => g_package_name,
                                      sub_object_name => 'SEND_CRM_MESSAGES');
                RAISE l_internal_error;
            END IF;
        END IF;
        RETURN TRUE;
    EXCEPTION
    
        WHEN l_internal_error THEN
            pk_alertlog.log_warn(g_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        
    END send_discharge_letter;
    /**********************************************************************************************
    * Send messages to interalert
    *                        
    * @author                        Elisabete Bugalho
    * @version                       2.6.3
    * @since                         2013/09/18 
    *
    * @changed                       Elisabete Bugalho
    * @version                       2.6.4.3
    * @since                         2014/12/18
    ***********************************************************************************************/

    PROCEDURE send_gp_discharge_letter IS
        CURSOR c_discharge_messages IS
            SELECT t.id_discharge_report,
                   t.id_discharge,
                   t.id_episode,
                   t.id_report,
                   t.id_prof_med,
                   t.id_institution,
                   t.id_software,
                   t.id_language,
                   t.rep_rank
              FROM (SELECT dr.id_discharge_report,
                           dr.id_discharge,
                           d.id_episode,
                           dr.id_report,
                           d.id_prof_med,
                           e.id_institution,
                           ei.id_software,
                           nvl(pp.id_language, pk_utils.get_institution_language(e.id_institution, ei.id_software)) id_language,
                           pk_discharge_crm.get_report_rank(i_lang      => NULL,
                                                            i_prof      => profissional(d.id_prof_med,
                                                                                        e.id_institution,
                                                                                        ei.id_software),
                                                            i_id_report => dr.id_report) rep_rank
                      FROM discharge_report dr
                      JOIN discharge d
                        ON d.id_discharge = dr.id_discharge
                      JOIN episode e
                        ON d.id_episode = e.id_episode
                      JOIN epis_info ei
                        ON e.id_episode = ei.id_episode
                      LEFT JOIN prof_soft_inst psi
                        ON psi.id_professional = d.id_prof_med
                       AND psi.id_institution = e.id_institution
                       AND psi.id_software = ei.id_software
                      LEFT JOIN prof_preferences pp
                        ON pp.id_professional = psi.id_professional
                       AND pp.id_institution = psi.id_institution
                       AND pp.id_software = psi.id_software
                     WHERE dr.flg_status = pk_discharge_crm.g_flg_status_crm_req
                       AND d.flg_status = pk_discharge_core.g_disch_status_active) t
             ORDER BY t.id_discharge ASC, t.rep_rank ASC;
    
        --l_response  CLOB;
        l_error_out t_error_out;
        --l_lang      language.id_language%TYPE;
        l_prof profissional;
    BEGIN
    
        FOR m IN c_discharge_messages
        LOOP
            pk_alertlog.log_debug(text => 'send_discharge_letter id_episode:' || m.id_episode);
            l_prof := profissional(m.id_prof_med, m.id_institution, m.id_software);
            IF NOT send_discharge_letter(i_lang       => m.id_language,
                                         i_prof       => l_prof,
                                         i_id_episode => m.id_episode,
                                         i_id_report  => m.id_report,
                                         o_error      => l_error_out)
            THEN
                pk_alertlog.log_error(text            => 'ERROR SENDING DISCHARGE LETTER ID_EPISODE:' || m.id_episode,
                                      object_name     => g_package_name,
                                      sub_object_name => 'SEND_CRM_MESSAGES');
                -- RETURN;
            ELSE
                ts_discharge_report.upd(id_discharge_report_in => m.id_discharge_report,
                                        flg_status_in          => pk_discharge_crm.g_flg_status_crm_sent);
            END IF;
        END LOOP;
    
    END;
    --------------------------------
    PROCEDURE set_oris_discharge IS
        /******************************************************************************
           OBJECTIVO:  Fechar todos os episódios pendentes ao final do dia (DISCHARGE).
           PARAMETROS:
        
          CRIAÇÃO: ASM 2006/12/18
          NOTAS:
        *********************************************************************************/
        --        l_id_visit     visit.id_visit%TYPE;
        --        l_id_patient   visit.id_patient%TYPE;
        --        l_id_epis_type episode.id_epis_type%TYPE;
        l_count          NUMBER;
        l_error          t_error_out;
        l_transaction_id VARCHAR2(4000);
        l_aux            VARCHAR2(2000);
        --
        CURSOR c_epis_discharge
        (
            i_date IN schedule.dt_begin_tstz%TYPE,
            i_inst IN institution.id_institution%TYPE
        ) IS
            SELECT id_episode_e,
                   id_institution,
                   id_epis_type,
                   id_software,
                   id_visit,
                   id_patient,
                   nvl(dt_discharge, epis.dt_filter) dt_end_inactts_tz
              FROM (SELECT e.id_episode id_episode_e,
                           e.id_institution,
                           e.id_epis_type,
                           ei.id_software,
                           e.id_visit,
                           e.id_patient,
                           (SELECT MAX(d.dt_med_tstz) dt_discharge
                              FROM discharge d
                             WHERE d.id_episode = e.id_episode
                               AND d.flg_status = g_disch_flg_active) dt_discharge,
                           pk_date_utils.add_to_ltstz(pk_date_utils.trunc_insttimezone(profissional(NULL,
                                                                                                    e.id_institution,
                                                                                                    NULL),
                                                                                       i_date),
                                                      '-' || pk_sysconfig.get_config('DISCHARGE_NR_DAYS',
                                                                                     profissional(0,
                                                                                                  e.id_institution,
                                                                                                  ei.id_software))) dt_filter,
                           sr.dt_target_tstz
                      FROM episode e
                      JOIN epis_info ei
                        ON e.id_episode = ei.id_episode
                      JOIN schedule_sr sr
                        ON sr.id_episode = ei.id_episode
                     WHERE e.id_epis_type IN (pk_alert_constant.g_epis_type_operating)
                       AND e.flg_status IN
                           (pk_alert_constant.g_epis_status_active, pk_alert_constant.g_epis_status_pendent)
                       AND e.flg_ehr = pk_visit.g_flg_ehr_n
                       AND e.dt_cancel_tstz IS NULL
                       AND sr.dt_target_tstz IS NOT NULL
                       AND e.id_institution = i_inst) epis
             WHERE epis.dt_target_tstz < epis.dt_filter;
    
        l_can_refresh_mviews BOOLEAN := FALSE;
    
        l_rowids table_varchar;
        l_prof   profissional;
        l_lang   language.id_language%TYPE := 2;
        o_error  t_error_out;
        l_internal_error EXCEPTION;
        l_rowids2           table_varchar;
        l_sei_flg_status    table_varchar;
        l_id_sr_epis_interv table_number;
        l_table_inst        table_number;
    BEGIN
        BEGIN
            SELECT DISTINCT id_institution
              BULK COLLECT
              INTO l_table_inst
              FROM sys_config sc
             WHERE sc.id_sys_config = 'INACTIVE_ORIS_ENDED_EPISODES'
               AND sc.value = pk_alert_constant.g_yes
               AND sc.id_software = pk_alert_constant.g_soft_oris
               AND sc.id_institution <> 0;
        EXCEPTION
            WHEN no_data_found THEN
                l_table_inst := table_number();
        END;
    
        g_sysdate_tstz := current_timestamp;
        --
        FOR k IN 1 .. l_table_inst.count
        LOOP
            FOR i IN c_epis_discharge(i_date => g_sysdate_tstz, i_inst => l_table_inst(k))
            LOOP
                BEGIN
                    l_prof           := profissional(0, i.id_institution, i.id_software);
                    l_lang           := pk_sysconfig.get_config('LANGUAGE', l_prof);
                    l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(NULL, l_prof);
                
                    -- Actualiza o estado do paciente.
                    g_error := 'CALL Pk_Sr_Grid.SET_PAT_STATUS';
                    IF NOT pk_sr_grid.call_set_pat_status(i_lang           => l_lang,
                                                          i_prof           => l_prof,
                                                          i_episode        => i.id_episode_e,
                                                          i_flg_status_new => 'O',
                                                          i_flg_status_old => NULL,
                                                          i_test           => 'N',
                                                          i_transaction_id => l_transaction_id,
                                                          o_flg_show       => l_aux,
                                                          o_msg_title      => l_aux,
                                                          o_msg_text       => l_aux,
                                                          o_button         => l_aux,
                                                          o_error          => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    -- all open surgical procedures are closed
                    g_error := 'get l_sei_flg_status';
                    BEGIN
                        SELECT sei.id_sr_epis_interv, sei.flg_status
                          BULK COLLECT
                          INTO l_id_sr_epis_interv, l_sei_flg_status
                          FROM sr_epis_interv sei
                         WHERE sei.id_episode_context = i.id_episode_e
                           AND sei.flg_status != pk_alert_constant.g_interv_status_cancel;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_sei_flg_status    := table_varchar();
                            l_id_sr_epis_interv := table_number();
                    END;
                
                    FOR j IN 1 .. l_id_sr_epis_interv.count
                    LOOP
                        IF l_sei_flg_status(j) IS NOT NULL
                        THEN
                            g_error := 'call ts_sr_epis_interv.upd';
                            ts_sr_epis_interv.upd(flg_status_in => CASE
                                                                       WHEN l_sei_flg_status(j) = pk_alert_constant.g_interv_status_requisition THEN
                                                                        pk_alert_constant.g_interv_status_finished
                                                                       WHEN l_sei_flg_status(j) = pk_alert_constant.g_interv_status_execution THEN
                                                                        pk_alert_constant.g_interv_status_finished
                                                                       ELSE
                                                                        l_sei_flg_status(j)
                                                                   END,
                                                  where_in      => 'id_sr_epis_interv = ' || l_id_sr_epis_interv(j),
                                                  rows_out      => l_rowids2);
                        
                            g_error := 'call t_data_gov_mnt.process_update';
                            t_data_gov_mnt.process_update(i_lang       => l_lang,
                                                          i_prof       => l_prof,
                                                          i_table_name => 'SR_EPIS_INTERV',
                                                          i_rowids     => l_rowids2,
                                                          o_error      => o_error);
                        
                            g_error := 'call pk_sr_output.set_ia_event_prescription';
                            IF NOT pk_sr_output.set_ia_event_prescription(i_lang              => l_lang,
                                                                     i_prof              => l_prof,
                                                                     i_flg_action        => 'U',
                                                                     i_id_sr_epis_interv => l_id_sr_epis_interv(j),
                                                                     i_flg_status_new    => CASE
                                                                                                WHEN l_sei_flg_status(j) =
                                                                                                     pk_alert_constant.g_interv_status_requisition THEN
                                                                                                 pk_alert_constant.g_interv_status_finished
                                                                                                WHEN l_sei_flg_status(j) =
                                                                                                     pk_alert_constant.g_interv_status_execution THEN
                                                                                                 pk_alert_constant.g_interv_status_finished
                                                                                                ELSE
                                                                                                 l_sei_flg_status(j)
                                                                                            END,
                                                                     i_flg_status_old    => l_sei_flg_status(j),
                                                                     o_error             => o_error)
                            THEN
                                RAISE l_internal_error;
                            END IF;
                        END IF;
                    
                        --Commit per episode
                        COMMIT;
                    END LOOP;
                
                    --Actualiza flags
                    g_error := 'UPDATE EPIS_INFO';
                    ts_epis_info.upd(flg_status_in => g_disch_type_alert,
                                     where_in      => 'id_episode =' || i.id_episode_e || ' AND flg_status != ''' ||
                                                      g_disch_type_alert || '''',
                                     rows_out      => l_rowids);
                
                    t_data_gov_mnt.process_update(i_lang         => NULL,
                                                  i_prof         => profissional(0, 0, 0),
                                                  i_table_name   => 'EPIS_INFO',
                                                  i_rowids       => l_rowids,
                                                  o_error        => l_error,
                                                  i_list_columns => table_varchar('FLG_STATUS'));
                    l_rowids := table_varchar();
                
                    g_error := 'UPDATE EPISODE';
                    ts_episode.upd(flg_status_in  => g_epis_inactive,
                                   dt_end_tstz_in => i.dt_end_inactts_tz,
                                   where_in       => 'id_episode = ' || i.id_episode_e || ' AND flg_status in ( ''' ||
                                                     g_epis_active || ''',''' || g_epis_pend || ''')',
                                   rows_out       => l_rowids);
                
                    t_data_gov_mnt.process_update(i_lang         => NULL,
                                                  i_prof         => profissional(0, 0, 0),
                                                  i_table_name   => 'EPISODE',
                                                  i_rowids       => l_rowids,
                                                  o_error        => l_error,
                                                  i_list_columns => table_varchar('flg_status', 'dt_end_tstz'));
                
                    g_error := 'SELECT l_count';
                    SELECT COUNT(*)
                      INTO l_count
                      FROM episode
                     WHERE id_visit = i.id_visit
                       AND flg_status IN (g_epis_active, g_epis_pend);
                
                    --
                    IF l_count = 0
                    THEN
                        --
                        -- Marca a visita como terminada
                        g_error := 'UPDATE VISIT';
                        UPDATE visit
                           SET dt_end_tstz = i.dt_end_inactts_tz, flg_status = g_visit_inactive
                         WHERE id_visit = i.id_visit
                           AND flg_status = g_visit_active;
                        -- Alta administrativa, tornar as dietas para o episodio inactivas
                        g_error := 'PK_DIET.SET_DIET_INTERRUPT';
                        IF NOT pk_diet.set_diet_interrupt(i_lang  => l_lang,
                                                          i_prof  => l_prof,
                                                          i_visit => i.id_visit,
                                                          o_error => o_error)
                        THEN
                            RAISE l_internal_error;
                        END IF;
                    
                    END IF;
                
                    g_error := 'UPDATE GRID_TASK_LAB';
                    UPDATE grid_task_lab
                       SET flg_status_epis = g_epis_inactive
                     WHERE id_episode = i.id_episode_e;
                
                    g_error := 'UPDATE GRID_TASK_IMG';
                    UPDATE grid_task_img
                       SET flg_status_epis = g_epis_inactive
                     WHERE id_episode = i.id_episode_e;
                
                    g_error := 'UPDATE GRID_TASK_OTH_EXM';
                    UPDATE grid_task_oth_exm
                       SET flg_status_epis = g_epis_inactive
                     WHERE id_episode = i.id_episode_e;
                
                    g_error := 'CALL PK_ADVANCED_DIRECTIVES.CANCEL_ADV_DIR_RECURR_PLANS';
                    pk_alertlog.log_debug(text => g_error);
                    IF NOT pk_advanced_directives.cancel_adv_dir_recurr_plans(i_lang    => NULL,
                                                                              i_prof    => profissional(0, 0, 0),
                                                                              i_patient => i.id_patient,
                                                                              i_episode => i.id_episode_e,
                                                                              o_error   => l_error)
                    THEN
                        g_error := 'CALL PK_ADVANCED_DIRECTIVES.CANCEL_ADV_DIR_RECURR_PLANS';
                        pk_alertlog.log_fatal(text => g_error);
                        RAISE l_internal_error;
                    END IF;
                
                    g_error := 'CALL pk_bmng_pbl.set_episode_bed_status_vacant';
                    IF NOT pk_bmng_pbl.set_episode_bed_status_vacant(i_lang                  => l_lang,
                                                                     i_prof                  => l_prof,
                                                                     i_id_episode            => i.id_episode_e,
                                                                     i_transaction_id        => l_transaction_id,
                                                                     i_dt_discharge_schedule => pk_date_utils.date_send_tsz(l_lang,
                                                                                                                            i.dt_end_inactts_tz,
                                                                                                                            l_prof),
                                                                     o_error                 => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    g_error := 'CALL pk_bmng_pbl.set_bmng_discharge';
                    IF NOT pk_bmng_pbl.set_bmng_discharge(i_lang           => l_lang,
                                                          i_prof           => l_prof,
                                                          i_epis           => i.id_episode_e,
                                                          i_transaction_id => l_transaction_id,
                                                          o_error          => o_error)
                    THEN
                        RAISE l_internal_error;
                    END IF;
                
                    l_can_refresh_mviews := TRUE;
                
                    --Commit per hospital
                    COMMIT;
                EXCEPTION
                    WHEN OTHERS THEN
                        ROLLBACK;
                        CONTINUE;
                END;
            END LOOP;
        END LOOP;
    
        IF l_can_refresh_mviews
        THEN
            pk_episode.update_mv_episodes();
        END IF;
    
        COMMIT;
    
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('ERROR');
            dbms_output.put_line(g_error);
            pk_alert_exceptions.process_error(l_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'SET_ORIS_DISCHARGE',
                                              o_error);
            pk_utils.undo_changes;
    END set_oris_discharge;

    /**********************************************************************************************
    * Get discharge notes for CDA section: Discharge instructions
    *
    * @param i_lang                  Language ID
    * @param i_prof                  Professional ID
    * @param i_scope                 ID for scope type
    * @param i_scope_type            Scope type (E)pisode/(V)isit/(P)atient
    * @param o_discharge_notes       Cursor with all discharge notes for the given scope
    * @param o_error                 Error message
    *
    * @return                        True on success, false otherwise
    *                        
    * @author                        Vanessa Barsottelli
    * @version                       2.6.3
    * @since                         2013/12/20 
    ***********************************************************************************************/
    FUNCTION get_disch_instructions_cda
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_scope           IN NUMBER,
        i_scope_type      IN VARCHAR2,
        o_discharge_instr OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_patient patient.id_patient%TYPE;
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_function_name CONSTANT VARCHAR2(32 CHAR) := 'GET_DISCH_INSTRUCTIONS_CDA';
    BEGIN
        IF i_scope IS NULL
           OR i_scope_type IS NULL
        THEN
            g_error := 'SCOPE ID OR TYPE IS NULL';
            RAISE g_exception;
        END IF;
    
        g_error := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_scope_type,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        OPEN o_discharge_instr FOR
            SELECT d.id_discharge_notes id_discharge_instructions, d.discharge_instructions
              FROM discharge_notes d
             INNER JOIN (SELECT e.id_episode
                           FROM episode e
                          WHERE e.id_episode = l_id_episode
                            AND e.id_patient = l_id_patient
                            AND i_scope_type = pk_alert_constant.g_scope_type_episode
                         UNION ALL
                         SELECT e.id_episode
                           FROM episode e
                          WHERE e.id_patient = l_id_patient
                            AND i_scope_type = pk_alert_constant.g_scope_type_patient
                         UNION ALL
                         SELECT e.id_episode
                           FROM episode e
                          WHERE e.id_visit = l_id_visit
                            AND e.id_patient = l_id_patient
                            AND i_scope_type = pk_alert_constant.g_scope_type_visit) epi
                ON epi.id_episode = d.id_episode
             WHERE d.flg_status <> pk_alert_constant.g_cancelled
               AND dbms_lob.compare(d.discharge_instructions, empty_clob()) > 0;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_function_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_discharge_instr);
            RETURN FALSE;
    END get_disch_instructions_cda;

    /*Printing list developments*/

    /********************************************************************************************
    * Gets information about print list job using print list job identifier 
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_id_print_list_job     Print list job identifier (discharge areas)
    *
    * @return                        Print list job information
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         07/10/2014
    ********************************************************************************************/
    FUNCTION tf_get_print_job_info
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_print_list_job IN print_list_job.id_print_list_job%TYPE
    ) RETURN t_rec_print_list_job IS
        l_result       t_rec_print_list_job := t_rec_print_list_job();
        l_context_data print_list_job.context_data%TYPE;
        --l_id_context      NUMBER(24);
        l_curr_area       print_list_job.id_print_list_area%TYPE;
        l_id_report       reports.id_reports%TYPE;
        l_id_discharge    discharge.id_discharge%TYPE;
        l_disch_instr_mgs translation.desc_lang_1%TYPE;
        l_disch_msg       translation.desc_lang_1%TYPE;
    
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'TF_GET_PRINT_JOB_INFO';
        l_error t_error_out;
    BEGIN
        g_error := 'GETTING CONTEXT DATA AND AREA OF THIS PRINT LIST JOB';
        BEGIN
            SELECT v.context_data, v.id_print_list_area
              INTO l_context_data, l_curr_area
              FROM v_print_list_context_data v
             WHERE v.id_print_list_job = i_id_print_list_job;
        
        EXCEPTION
            WHEN no_data_found THEN
                l_context_data := '-1';
        END;
    
        g_error := 'VERIFY IF ID CONTEXT IS VALID';
        IF l_context_data <> '-1'
        THEN
            g_error := 'CREATION OF THE T_REC_PRINT_LIST_JOB TYPE';
            IF l_curr_area = pk_print_list_db.g_print_list_area_disch
            THEN
                IF NOT decode_disch_print_job_context(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_context      => l_context_data,
                                                      o_id_report    => l_id_report,
                                                      o_id_discharge => l_id_discharge)
                THEN
                    l_id_report := -1;
                END IF;
                IF l_id_report <> -1
                THEN
                    g_error := 'GETTING REPORT TRANSLATION';
                    SELECT pk_translation.get_translation(i_lang => i_lang, i_code_mess => rep.code_reports)
                      INTO l_disch_msg
                      FROM reports rep
                     WHERE rep.id_reports =
                           pk_sysconfig.get_config(i_code_cf => g_cfg_print_disp_report, i_prof => i_prof);
                
                    l_result.title_desc := l_disch_msg;
                
                ELSE
                    l_result.title_desc := NULL;
                END IF;
            
            ELSIF l_curr_area = pk_print_list_db.g_print_list_area_disch_i
            THEN
                g_error := 'GETTING REPORT TRANSLATION';
                SELECT pk_translation.get_translation(i_lang => i_lang, i_code_mess => rep.code_reports)
                  INTO l_disch_instr_mgs
                  FROM reports rep
                 WHERE rep.id_reports = pk_sysconfig.get_config(i_code_cf => g_cfg_print_disch_instr, i_prof => i_prof);
            
                l_result.title_desc := l_disch_instr_mgs;
            END IF;
        
            l_result.id_print_list_job := i_id_print_list_job;
            l_result.subtitle_desc     := NULL;
        END IF;
    
        RETURN l_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END tf_get_print_job_info;

    /********************************************************************************************
    * Compares if a print list job is similar to the array of print list jobs
    *
    * @param i_lang                   Language associated to the professional executing the request
    * @param i_prof                   Professional, institution and software identification
    * @param i_print_job_context_data Print list job context
    * @param i_tbl_print_list_jobs    Array of print list job identifiers
    *
    * @return                        Array of print list jobs that are similar
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION tf_compare_print_jobs
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_print_job_context_data IN print_list_job.context_data%TYPE,
        i_tbl_print_list_jobs    IN table_number
    ) RETURN table_number IS
        l_result table_number := table_number();
        --
        l_func_name CONSTANT VARCHAR2(200) := 'TF_COMPARE_PRINT_JOBS';
        l_error t_error_out;
    BEGIN
    
        g_error := 'GETTING SIMMILAR PRINTING LIST JOBS | PRINT_JOB_CONTEXT_DATA - ' || i_print_job_context_data;
        SELECT t.id_print_list_job
          BULK COLLECT
          INTO l_result
          FROM (SELECT /*+opt_estimate (table t rows=1)*/
                 v2.id_print_list_job
                  FROM v_print_list_context_data v2
                  JOIN TABLE(CAST(i_tbl_print_list_jobs AS table_number)) t
                    ON t.column_value = v2.id_print_list_job
                 WHERE dbms_lob.compare(v2.context_data, i_print_job_context_data) = 0) t;
    
        RETURN l_result;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END tf_compare_print_jobs;

    /********************************************************************************************
    * Gets discharge instruction completion options
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param o_options               Referrals completion options
    * @param o_error                 An error message, set when return=false
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION get_completion_options
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        o_options OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_config        VARCHAR(1 CHAR);
        l_internal_name sys_list.internal_name%TYPE;
        l_can_add       VARCHAR2(1 CHAR);
        --
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'GET_COMPLETION_OPTIONS';
        l_exception EXCEPTION;
    BEGIN
        g_error := 'GET CONFIGURATION VALUE - DISCH_GET_DEFAULT_OPT_FROM_PL CONFIG';
    
        l_config := pk_sysconfig.get_config(i_code_cf => g_disch_print_tool_default_opt, i_prof => i_prof);
    
        g_error := 'VERIFY IF PATIENT HAVE PERMISSIONS TO ADD TO THE PRINTING LIST';
        IF NOT pk_print_list_db.check_func_can_add(i_lang        => i_lang,
                                                   i_prof        => i_prof,
                                                   o_flg_can_add => l_can_add,
                                                   o_error       => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        --gets printing list configurations
        IF l_config = pk_alert_constant.g_no
        THEN
            g_error         := 'GET PRINTING LIST OPTIONS CONFIGURATION - CONFIG - ' || l_config;
            l_internal_name := get_default_opt_print_list(i_lang => i_lang,
                                                          i_prof => i_prof,
                                                          i_area => pk_print_list_db.g_print_list_area_disch_i);
        
            IF l_can_add = pk_alert_constant.g_no
            THEN
                SELECT tc.sys_list_internal_name
                  INTO l_internal_name
                  FROM TABLE(pk_sys_list.tf_sys_list_values(i_lang          => i_lang,
                                                            i_prof          => i_prof,
                                                            i_internal_name => pk_discharge.g_slg_disch_options)) tc
                 WHERE ((tc.sys_list_internal_name = l_internal_name AND l_can_add = pk_alert_constant.g_yes) OR
                       (tc.sys_list_internal_name != l_internal_name AND l_can_add = pk_alert_constant.g_no))
                   AND rownum = 1;
            
            END IF;
        
        ELSIF l_config = pk_alert_constant.g_yes
        THEN
            --set default option from sys_list
            g_error         := 'GET DEFAULT OPTION FROM SYS_LIST - CONFIG - ' || l_config;
            l_internal_name := g_sys_list_inst_name_s;
        ELSE
            RETURN FALSE;
        END IF;
    
        g_error := 'GET COMPLETION OPTIONS - DEFAULT FIELD - ' || g_sys_list_inst_name_s;
        OPEN o_options FOR
            SELECT tbl_opt.flg_context val_option,
                   tbl_opt.desc_list desc_option,
                   decode(tbl_opt.sys_list_internal_name,
                          l_internal_name,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_default,
                   tbl_opt.rank rank,
                   decode(tbl_opt.sys_list_internal_name,
                          g_sys_list_int_name_pl,
                          decode(l_can_add, pk_alert_constant.g_yes, pk_alert_constant.g_yes, pk_alert_constant.g_no),
                          pk_alert_constant.g_yes) flg_available
              FROM TABLE(pk_sys_list.tf_sys_list_values(i_lang          => i_lang,
                                                        i_prof          => i_prof,
                                                        i_internal_name => g_slg_disch_instr_options)) tbl_opt;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_completion_options;

    /********************************************************************************************
    * Gets default option from printing list configuration 
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_area                  Functional area (discharge - 8, discharge_instructions - 7)
    *
    * @return                        Sys_list internal name - SAVE_PRINT_LIST | SAVE_LIST
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION get_default_opt_print_list
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional,
        i_area IN print_list_area.id_print_list_area%TYPE
    ) RETURN VARCHAR2 IS
        l_option_internal_name VARCHAR2(200 CHAR);
        --
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'GET_DEFAULT_OPT_PRINT_LIST';
        l_exception EXCEPTION;
        l_error t_error_out;
    BEGIN
        g_error := 'CALL PK_PRINT_LIST_DB.GET_PRINT_DEF_OPTION - GET CONFIGURED PRINT OPTION';
        IF NOT pk_print_list_db.get_print_list_def_option(i_lang            => i_lang,
                                                          i_prof            => i_prof,
                                                          i_print_list_area => i_area,
                                                          o_default_option  => l_option_internal_name,
                                                          o_error           => l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN l_option_internal_name;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_default_opt_print_list;

    /********************************************************************************************
    * Creates discharge context structure using report id and associated discharge identifier.
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_id_reports            Report identifier
    * @param i_id_discharge          Discharge identifier
    *
    * @return                        Context string created
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         07/10/2014
    ********************************************************************************************/
    FUNCTION encode_disch_print_job_context
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_reports   IN reports.id_reports%TYPE,
        i_id_discharge IN discharge.id_discharge%TYPE
    ) RETURN VARCHAR2 IS
        --l_func_name CONSTANT VARCHAR2(200 CHAR) := 'ENCODE_DISCH_PRINT_JOB_CONTEXT';
        --l_error t_error_out;
    BEGIN
        RETURN g_id_report_label || i_id_reports || g_separator || g_id_transctional_label || i_id_discharge;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END encode_disch_print_job_context;

    /********************************************************************************************
    * Decodes discharge context string to get report id and associated discharge identifier.
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_context               Printing list context
    * @param o_id_report             Report identifier
    * @param o_id_discharge          Discharge identifier 
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         07/10/2014
    ********************************************************************************************/
    FUNCTION decode_disch_print_job_context
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_context      IN print_list_job.context_data%TYPE,
        o_id_report    OUT reports.id_reports%TYPE,
        o_id_discharge OUT discharge.id_discharge%TYPE
    ) RETURN BOOLEAN IS
        l_id_report_clob    print_list_job.context_data%TYPE;
        l_id_discharge_clob print_list_job.context_data%TYPE;
        l_id_report         reports.id_reports%TYPE;
        l_id_discharge      discharge.id_discharge%TYPE;
        --
        --l_func_name CONSTANT VARCHAR2(200 CHAR) := 'DECODE_DISCH_PRINT_JOB_CONTEXT';
        --l_error t_error_out;
    BEGIN
        g_error := 'GET IDENTIFIERS FROM STRING CONTEXT AND CAST TO NUMBER';
        BEGIN
            SELECT regexp_replace(i_context, '(.*)(' || g_id_report_label || ')([^' || g_separator || ']+);?(.*)', '\3'),
                   regexp_replace(regexp_replace(i_context,
                                                 '(.*)(' || g_id_transctional_label || ')([^' || g_separator ||
                                                 ']+);?(.*)',
                                                 '\3'),
                                  '''',
                                  '')
              INTO l_id_report_clob, l_id_discharge_clob
              FROM dual;
        
            l_id_report    := to_number(l_id_report_clob);
            l_id_discharge := to_number(l_id_discharge_clob);
        
        EXCEPTION
            WHEN OTHERS THEN
                l_id_report    := NULL;
                l_id_discharge := NULL;
        END;
    
        o_id_report    := l_id_report;
        o_id_discharge := l_id_discharge;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END decode_disch_print_job_context;

    /********************************************************************************************
    * Adds the print list job to the printing list
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_patient               Patient identifier
    * @param i_episode               Episode identifier
    * @param i_tbl_context_data      List tha contains all print list jobs context
    * @param i_tbl_print_list_areas  Printing list areas
    * @param i_tbl_print_arguments   Arguments necessary to print the jobs
    * @param o_print_list_jobs       Array of print list job identifiers added
    * @param o_error                 Error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION set_print_list_jobs
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN patient.id_patient%TYPE,
        i_episode              IN episode.id_episode%TYPE,
        i_tbl_context_data     IN table_clob,
        i_tbl_print_list_areas IN table_number,
        i_tbl_print_arguments  IN table_varchar,
        o_print_list_jobs      OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        --l_func_name CONSTANT VARCHAR2(200 CHAR) := 'SET_PRINT_LIST_JOBS';
    BEGIN
        g_error := 'CALL PK_PRINT_LIST.ADD_PRINT_JOBS (ID_PATIENT: ' || i_patient || ', ID_EPISODE: ' || i_episode || ')';
        RETURN pk_print_list_db.add_print_jobs(i_lang             => i_lang,
                                               i_prof             => i_prof,
                                               i_patient          => i_patient,
                                               i_episode          => i_episode,
                                               i_print_list_areas => i_tbl_print_list_areas,
                                               i_context_data     => i_tbl_context_data,
                                               i_print_arguments  => i_tbl_print_arguments,
                                               o_print_list_jobs  => o_print_list_jobs,
                                               o_error            => o_error);
    
    END set_print_list_jobs;

    /********************************************************************************************
    * Adds the discharge instruction record to the print list.
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_patient               Patient identifier
    * @param i_episode               Episode identifier
    * @param i_print_arguments       Arguments necessary to print the discharge instructions job
    * @param i_id_reports            Report identifier   
    * @param o_print_list_jobs       Array of print list job identifiers added
    * @param o_error                 Error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION add_print_list_jobs
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_patient         IN patient.id_patient%TYPE,
        i_episode         IN episode.id_episode%TYPE,
        i_print_arguments IN table_varchar,
        o_print_list_job  OUT table_number,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_context_data    print_list_job.context_data%TYPE;
        l_print_list_jobs table_number;
        --
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'SET_DISCH_INSTR_PRINT_LIST_JOB';
        l_exception EXCEPTION;
    BEGIN
        g_error        := 'GET DISCHARGE INSTRUCTION CONTEXT DATA - ID_PRINT_LIST_AREA:' ||
                          pk_print_list_db.g_print_list_area_disch_i;
        l_context_data := to_clob(pk_print_list_db.g_print_list_area_disch_i);
    
        IF l_context_data IS NOT NULL
        THEN
            g_error := 'ADD PRINT LIST JOBS CREATED TO THE PRINTING LIST';
            IF NOT set_print_list_jobs(i_lang                 => i_lang,
                                       i_prof                 => i_prof,
                                       i_patient              => i_patient,
                                       i_episode              => i_episode,
                                       i_tbl_context_data     => table_clob(l_context_data),
                                       i_tbl_print_list_areas => table_number(pk_print_list_db.g_print_list_area_disch_i),
                                       i_tbl_print_arguments  => i_print_arguments,
                                       o_print_list_jobs      => l_print_list_jobs,
                                       o_error                => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        
            o_print_list_job := l_print_list_jobs;
        ELSE
            o_print_list_job := NULL;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END add_print_list_jobs;

    /********************************************************************************************
    * Sets discharge print jobs in the printing list.
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_patient               Patient identifier
    * @param i_episode               Episode identifier
    * @param i_tbl_id_report         List that contains report identifiers 
    * @param i_id_discharge          Discharge identifier
    * @param i_tbl_print_arguments   Arguments necessary to print the discharge job
    * @param o_id_print_list_jobs    Print list job identifiers added to the printing list
    * @param o_error                 Error message
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION add_print_list_jobs
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_patient             IN patient.id_patient%TYPE,
        i_episode             IN episode.id_episode%TYPE,
        i_tbl_id_report       IN table_number,
        i_id_discharge        IN discharge.id_discharge%TYPE,
        i_tbl_print_arguments IN table_varchar,
        o_id_print_list_jobs  OUT table_number,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_report        reports.id_reports%TYPE;
        l_id_discharge     discharge.id_discharge%TYPE;
        l_context_data     print_list_job.context_data%TYPE;
        l_tbl_context_data table_clob := table_clob();
        l_tbl_areas        table_number := table_number();
        --
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'SET_DISCH_PRINT_LIST_JOBS';
        l_exception EXCEPTION;
    BEGIN
    
        g_error := 'VERIFY IF IDENTIFIERS EXISTS - ID_REPORTS, ID_DISCHARGE';
        IF i_tbl_id_report.exists(1)
           AND i_id_discharge IS NOT NULL
        THEN
            FOR i IN i_tbl_id_report.first .. i_tbl_id_report.last
            LOOP
            
                l_id_report    := i_tbl_id_report(i);
                l_id_discharge := i_id_discharge;
            
                g_error        := 'CREATE DISCHARGE PRINT LIST JOB CONTEXT - ID_REPORT:' || l_id_report ||
                                  ', ID_DISCHARGE:' || l_id_discharge;
                l_context_data := encode_disch_print_job_context(i_lang         => i_lang,
                                                                 i_prof         => i_prof,
                                                                 i_id_reports   => l_id_report,
                                                                 i_id_discharge => l_id_discharge);
                g_error        := 'ADD CONTEXT TO TABLE_CLOB';
                l_tbl_context_data.extend();
                l_tbl_context_data(l_tbl_context_data.count) := l_context_data;
            
                l_tbl_areas.extend();
                l_tbl_areas(l_tbl_areas.count) := pk_print_list_db.g_print_list_area_disch;
            END LOOP;
        
            g_error := 'ADD PRINT LIST JOBS CREATED TO THE PRINTING LIST - SET_PRINT_LIST_JOBS';
            IF NOT set_print_list_jobs(i_lang                 => i_lang,
                                       i_prof                 => i_prof,
                                       i_patient              => i_patient,
                                       i_episode              => i_episode,
                                       i_tbl_context_data     => l_tbl_context_data,
                                       i_tbl_print_list_areas => l_tbl_areas,
                                       i_tbl_print_arguments  => i_tbl_print_arguments,
                                       o_print_list_jobs      => o_id_print_list_jobs,
                                       o_error                => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSE
            o_id_print_list_jobs := table_number();
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END add_print_list_jobs;

    /********************************************************************************************
    * Generic function to delete more than one print jobs, by area/patient/episode
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_patient               Patient identifier
    * @param i_episode               Episode identifier
    * @param i_print_list_area       Discharge instructions - 7, Discharge - 8
    * @param o_id_print_list_jobs    Print list job identifiers deleted
    * @param o_error                 An error message, set when return=false
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION cancel_print_jobs
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN patient.id_patient%TYPE,
        i_episode            IN episode.id_episode%TYPE,
        i_print_list_area    IN print_list_area.id_print_list_area%TYPE,
        o_id_print_list_jobs OUT table_number,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_print_jobs_to_remove table_number := table_number();
        --
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'CANCEL_PRINT_JOBS';
        l_exception EXCEPTION;
    BEGIN
    
        g_error                := 'CALL PK_PRINT_LIST_DB.GET_PRINT_LIST_JOBS TO GET ALL PRINT LIST JOBS BY AREA';
        l_print_jobs_to_remove := pk_print_list_db.get_print_list_jobs(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_patient         => i_patient,
                                                                       i_episode         => i_episode,
                                                                       i_print_list_area => i_print_list_area);
    
        g_error := 'VERIFY IF EXISTS JOBS TO REMOVE FROM PRINT LIST';
        IF l_print_jobs_to_remove.exists(1)
        THEN
            g_error := 'CALL PK_PRINT_LIST_DB.SET_PRINT_JOBS_CANCEL';
            IF NOT pk_print_list_db.set_print_jobs_cancel(i_lang              => i_lang,
                                                          i_prof              => i_prof,
                                                          i_id_print_list_job => l_print_jobs_to_remove,
                                                          o_id_print_list_job => o_id_print_list_jobs,
                                                          o_error             => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END cancel_print_jobs;

    /********************************************************************************************
    * Removes all discharge print jobs from printing list
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_patient               Patient identifier
    * @param i_episode               Episode identifier
    * @param o_id_print_list_jobs    Print list job identifiers deleted
    * @param o_error                 An error message, set when return=false
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION cancel_disch_print_jobs
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN patient.id_patient%TYPE,
        i_episode            IN episode.id_episode%TYPE,
        o_id_print_list_jobs OUT table_number,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'CANCEL_DISCH_PRINT_JOBS';
    BEGIN
    
        IF NOT cancel_print_jobs(i_lang               => i_lang,
                                 i_prof               => i_prof,
                                 i_patient            => i_patient,
                                 i_episode            => i_episode,
                                 i_print_list_area    => pk_print_list_db.g_print_list_area_disch,
                                 o_id_print_list_jobs => o_id_print_list_jobs,
                                 o_error              => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END cancel_disch_print_jobs;

    /********************************************************************************************
    * Removes all discharge instruction print jobs from printing list.
    *
    * @param i_lang                  Language associated to the professional executing the request
    * @param i_prof                  Professional, institution and software identification
    * @param i_patient               Patient identifier
    * @param i_episode               Episode identifier
    * @param o_id_print_list_jobs    Print list job identifiers deleted
    * @param o_error                 An error message, set when return=false
    *
    * @return                        TRUE if sucess, FALSE otherwise
    *
    * @author                        Gisela Couto
    * @version                       2.6.4.2.1
    * @since                         08/10/2014
    ********************************************************************************************/
    FUNCTION cancel_disch_instr_print_jobs
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN patient.id_patient%TYPE,
        i_episode            IN episode.id_episode%TYPE,
        o_id_print_list_jobs OUT table_number,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'CANCEL_DISCH_INSTR_PRINT_JOBS';
    BEGIN
    
        IF NOT cancel_print_jobs(i_lang               => i_lang,
                                 i_prof               => i_prof,
                                 i_patient            => i_patient,
                                 i_episode            => i_episode,
                                 i_print_list_area    => pk_print_list_db.g_print_list_area_disch_i,
                                 o_id_print_list_jobs => o_id_print_list_jobs,
                                 o_error              => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END cancel_disch_instr_print_jobs;

    FUNCTION get_level_of_service_desc
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_id_task_type            IN task_type.id_task_type%TYPE,
        i_id_concept_term         IN concept_term.id_concept_term%TYPE,
        i_id_cncpt_trm_inst_owner IN concept_term.id_inst_owner%TYPE,
        i_id_terminology_version  IN terminology_version.id_terminology_version%TYPE
        
    ) RETURN VARCHAR2 IS
        l_exception EXCEPTION;
        l_ret VARCHAR2(32000);
    
        l_concept_term_desc       VARCHAR2(4000);
        l_code                    VARCHAR2(4000);
        l_terminology_abreviation VARCHAR2(4000);
        l_concept_vrs_by_trm      pk_api_termin_server_func.t_concept_version_record;
    
    BEGIN
        IF i_id_concept_term IS NOT NULL
        THEN
            l_concept_term_desc       := pk_api_termin_server_func.get_concept_term_desc(i_lang                    => i_lang,
                                                                                         i_id_task_type            => i_id_task_type,
                                                                                         i_id_concept_term         => i_id_concept_term,
                                                                                         i_id_cncpt_trm_inst_owner => i_id_cncpt_trm_inst_owner);
            l_concept_vrs_by_trm      := pk_api_termin_server_func.get_concept_vrs_by_trm(i_concept_term => i_id_concept_term,
                                                                                          i_inst_owner   => i_id_cncpt_trm_inst_owner);
            l_terminology_abreviation := pk_translation.get_translation(i_lang      => i_lang,
                                                                        i_code_mess => pk_api_termin_server_func.get_terminology_abbreviation(i_concept_version      => l_concept_vrs_by_trm.id_concept_version,
                                                                                                                                              i_cncpt_vrs_inst_owner => i_id_cncpt_trm_inst_owner));
        
            l_code := pk_api_termin_server_func.get_concept_code_by_trm(i_concept_term => i_id_concept_term,
                                                                        i_inst_owner   => i_id_cncpt_trm_inst_owner);
        
            l_ret := l_concept_term_desc || ' (' || l_code || ')' || ' (' || l_terminology_abreviation || ')';
        END IF;
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'ERROR - GET_LEVEL_OF_SERVICE_DESC';
    END get_level_of_service_desc;

    FUNCTION get_level_of_service
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_data  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'GET_TERMINOLOGY_SERVER';
        -- CONCEPT TYPE ID
        l_id_concept_type NUMBER(24) := 62;
    BEGIN
    
        OPEN o_data FOR
        
            SELECT id_concept_term,
                   id_cpt_trm_inst_owner id_cncpt_trm_inst_owner,
                   id_terminology_version,
                   get_level_of_service_desc(i_lang,
                                             i_prof,
                                             id_task_type,
                                             id_concept_term,
                                             id_cpt_trm_inst_owner,
                                             id_terminology_version) description
            
              FROM TABLE(pk_api_termin_server_func.tf_concept_list(i_lang              => i_lang,
                                                                   i_prof              => i_prof,
                                                                   i_institution       => i_prof.institution,
                                                                   i_software          => i_prof.software,
                                                                   i_task_type_list    => table_number(pk_alert_constant.g_task_discharge_los),
                                                                   i_concept_type_list => table_number(l_id_concept_type)))
            
             ORDER BY rank, description;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_level_of_service;

    FUNCTION tf_discharge_notes
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN table_number
    ) RETURN t_coll_disch_notes
        PIPELINED IS
        l_exception EXCEPTION;
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'TF_DISCHARGE_NOTES';
        l_error               t_error_out;
        l_rec_discharge_notes t_rec_disch_notes;
    
    BEGIN
        FOR l_rec_discharge_notes IN (SELECT id_discharge_notes,
                                             id_episode,
                                             id_professional,
                                             pk_date_utils.date_char_tsz(i_lang,
                                                                         dt_creation_tstz,
                                                                         i_prof.institution,
                                                                         i_prof.software),
                                             epis_complaint,
                                             epis_diagnosis,
                                             recommended,
                                             discharge_instructions,
                                             notes_release,
                                             pk_prof_utils.get_detail_signature(i_lang,
                                                                                i_prof,
                                                                                dn.id_episode,
                                                                                dn.dt_creation_tstz,
                                                                                dn.id_professional) signature
                                        FROM (SELECT id_discharge_notes,
                                                     
                                                     id_episode,
                                                     id_professional,
                                                     dt_creation_tstz,
                                                     epis_complaint,
                                                     epis_diagnosis,
                                                     recommended,
                                                     release_from,
                                                     notes_release,
                                                     discharge_instructions,
                                                     row_number() over(PARTITION BY id_episode ORDER BY dt_creation_tstz DESC) row_number
                                                FROM discharge_notes
                                               WHERE id_episode IN (SELECT /*+ opt_estimate(table t rows=1) */
                                                                     t.column_value
                                                                      FROM TABLE(i_episode) t)
                                                 AND flg_status != g_disch_notes_c
                                                 AND rownum > 0) dn
                                       WHERE row_number = 1)
        LOOP
            PIPE ROW(l_rec_discharge_notes);
        END LOOP;
    
        RETURN;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN;
        
    END tf_discharge_notes;

    FUNCTION get_list_discharge_notes
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_episode     IN table_number,
        o_disch_notes OUT t_cur_discharge_notes,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'GET_LIST_DISCHARGE_NOTES';
    BEGIN
    
        OPEN o_disch_notes FOR
            SELECT id_discharge_notes,
                   id_episode,
                   id_professional,
                   dt_creation,
                   epis_complaint,
                   epis_diagnosis,
                   recommended,
                   discharge_instructions,
                   notes_release,
                   signature
              FROM TABLE(pk_discharge.tf_discharge_notes(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode));
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_disch_notes);
            RETURN FALSE;
        
    END;

    /**
    * Returns the actions to be displayed when a SOAP note is selected.
    *
    * @param i_lang                       language identifier
    * @param i_prof                       logged professional structure
    * @param i_id_epis_recomend           Epis recomment id    
    * @param o_actions                    actions data
    * @param o_error                      error
    *
    * @return                             false if errors occur, true otherwise
    *
    * @author                             Vanessa Barsottelli
    * @version                            2.6.4
    * @since                              10-Dez-2014
    */
    FUNCTION get_actions_soap_notes
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_epis_recomend IN epis_recomend.id_epis_recomend%TYPE,
        i_id_task_type     IN tl_task.id_tl_task%TYPE,
        o_actions          OUT NOCOPY pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(25 CHAR) := 'GET_ACTIONS_SOAP_NOTES';
        l_id_professional epis_recomend.id_professional%TYPE;
    BEGIN
        g_error := 'GET epis_recommend id_professional i_id_epis_recomend: ' || i_id_epis_recomend;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT er.id_professional
          INTO l_id_professional
          FROM epis_recomend er
         WHERE er.id_epis_recomend = i_id_epis_recomend;
    
        g_error := 'GET CURSOR o_actions';
        pk_alertlog.log_debug(g_error);
        OPEN o_actions FOR
            SELECT /*+opt_estimate(table,t,scale_rows=3)*/
             id_action,
             id_parent,
             level_nr,
             from_state,
             to_state,
             desc_action,
             icon,
             flg_default,
             CASE
                  WHEN l_id_professional <> i_prof.id THEN
                   'I'
                  ELSE
                   flg_active
              END flg_active,
             action
              FROM TABLE(pk_action.tf_get_actions(i_lang,
                                                   i_prof,
                                                   CASE
                                                       WHEN i_id_task_type = pk_prog_notes_constants.g_task_plan_notes THEN
                                                        'PLAN_NOTES'
                                                       WHEN i_id_task_type = pk_prog_notes_constants.g_task_subjective THEN
                                                        'SUBJECTIVE_NOTES'
                                                       WHEN i_id_task_type = pk_prog_notes_constants.g_task_objective THEN
                                                        'OBJECTIVE_NOTES'
                                                       WHEN i_id_task_type = pk_prog_notes_constants.g_task_assessment THEN
                                                        'ASSESSMENT_NOTES'
                                                   END,
                                                   NULL)) t;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_actions);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_actions_soap_notes;

    FUNCTION set_match_episode_discharge
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode_temp IN episode.id_episode%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'SET_MATCH_EPISODE_DISCHARGE';
        l_cancel_dt         TIMESTAMP WITH LOCAL TIME ZONE;
        l_id_discharge      discharge.id_discharge%TYPE;
        l_type_discharge    discharge.flg_market%TYPE;
        l_id_discharge_hist discharge_hist.id_discharge_hist%TYPE;
    BEGIN
    
        g_error := 'UPDATE DISCHARGE_HIST';
        UPDATE discharge_hist
           SET id_episode = i_episode
         WHERE id_episode = i_episode_temp;
    
        g_error := 'UPDATE DISCHARGE';
        UPDATE discharge
           SET id_episode = i_episode
         WHERE id_episode = i_episode_temp;
    
        --Actualiza as altas do episódio de forma a apenas a última ficar activa
        l_cancel_dt := current_timestamp;
    
        g_error := 'UPDATE DISCHARGE';
        UPDATE discharge d
           SET flg_status      = g_disch_cancel,
               dt_cancel_tstz  = l_cancel_dt,
               id_prof_cancel  = i_prof.id,
               flg_cancel_type = pk_alert_constant.g_disch_flgcanceltype_n
         WHERE id_episode = i_episode
           AND d.flg_status = g_disch_active
           AND d.dt_med_tstz < (SELECT MAX(d1.dt_med_tstz)
                                  FROM discharge d1
                                 WHERE d1.id_episode = d.id_episode
                                   AND d1.flg_status = g_disch_active
                                   AND d1.flg_type = d.flg_type)
        RETURNING id_discharge, flg_market INTO l_id_discharge, l_type_discharge;
    
        IF l_type_discharge = 'US'
        THEN
            SELECT id_discharge_hist
              INTO l_id_discharge_hist
              FROM (SELECT id_discharge_hist,
                           id_discharge,
                           id_episode,
                           row_number() over(PARTITION BY dh.id_episode ORDER BY dh.dt_created_hist DESC) row_number
                      FROM discharge_hist dh
                     WHERE dh.id_episode = i_episode
                       AND dh.flg_status_hist = g_disch_active
                       AND id_discharge = l_id_discharge) t
             WHERE row_number = 1;
        
            UPDATE discharge_hist dh
               SET flg_status      = g_disch_cancel,
                   dt_cancel_tstz  = l_cancel_dt,
                   id_prof_cancel  = i_prof.id,
                   flg_cancel_type = pk_alert_constant.g_disch_flgcanceltype_n,
                   flg_status_hist = g_disch_cancel,
                   flg_status_adm  = decode(flg_status_adm, g_disch_active, 'C', flg_status_adm)
             WHERE dh.id_discharge_hist = l_id_discharge_hist;
        
            UPDATE discharge_hist
               SET flg_status_hist = 'O'
             WHERE id_discharge_hist <> l_id_discharge_hist
               AND id_discharge = l_id_discharge
               AND flg_status_hist = g_disch_active;
        
        END IF;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        
    END set_match_episode_discharge;

    /**
    * Returns the concat string with list of dicharge instructions selected in dicharge note.
    *
    * @param i_lang                       language identifier
    * @param i_prof                       logged professional structure
    * @param i_discharge_notes            Discharge note id    
    *
    * @return                             string with description
    *
    * @author                             Anna Kurowska
    * @version                            2.7
    * @since                              29-Jun-2017
    */
    FUNCTION get_dn_instr_list
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_discharge_notes IN discharge_notes.id_discharge_notes%TYPE
    ) RETURN VARCHAR2 IS
        l_error t_error_out;
        l_exception EXCEPTION;
    
        l_instr_t      table_number;
        l_instr_desc_t table_varchar;
        l_instr_desc   VARCHAR2(4000 CHAR);
    BEGIN
        g_error := 'GET DISCH_NOTES_INSTR i_discharge_notes: ' || i_discharge_notes;
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.get_dn_instr_list(i_lang            => i_lang,
                                              i_prof            => i_prof,
                                              i_discharge_notes => i_discharge_notes,
                                              o_dn_instr        => l_instr_t,
                                              o_dn_instr_desc   => l_instr_desc_t,
                                              o_error           => l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_instr_desc := pk_utils.concat_table(i_tab => l_instr_desc_t, i_delim => '; ');
    
        RETURN l_instr_desc;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'get_dn_instr_list',
                                              l_error);
            RETURN NULL;
    END get_dn_instr_list;
    /**
    * Returns the list of dicharge instructions selected in dicharge note.
    *
    * @param i_lang                       language identifier
    * @param i_prof                       logged professional structure
    * @param i_discharge_notes            Discharge note id    
    * @param o_dn_instr                   Array of discharge instruction IDs
    * @param o_dn_instr_desc              Array of discharge instruction description
    * @param o_error                      Error message
    *
    * @return                             TRUE if sucess, FALSE otherwise
    *
    * @author                             Anna Kurowska
    * @version                            2.7
    * @since                              29-Jun-2017
    */
    FUNCTION get_dn_instr_list
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_discharge_notes IN discharge_notes.id_discharge_notes%TYPE,
        o_dn_instr        OUT table_number,
        o_dn_instr_desc   OUT table_varchar,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'GET DISCH_NOTES_INSTR i_discharge_notes: ' || i_discharge_notes;
        SELECT pk_translation.get_translation(i_lang, di.code_disch_instructions_title), dni.id_disch_instructions
          BULK COLLECT
          INTO o_dn_instr_desc, o_dn_instr
          FROM disch_notes_instr dni
          JOIN disch_instructions di
            ON dni.id_disch_instructions = di.id_disch_instructions
         WHERE dni.id_discharge_notes = i_discharge_notes;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'get_dn_instr_list',
                                              o_error);
            RETURN FALSE;
    END get_dn_instr_list;

    FUNCTION get_dn_discussed_with
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_discharge_notes IN discharge_notes.id_discharge_notes%TYPE
    ) RETURN VARCHAR2 IS
        l_error t_error_out;
        l_exception EXCEPTION;
    
        l_discussed      table_varchar;
        l_discussed_desc table_varchar;
        l_discussed_with VARCHAR2(4000 CHAR);
    BEGIN
        g_error := 'GET DISCHARGE_NOTES DISCUSSED WITH i_discharge_notes: ' || i_discharge_notes;
        pk_alertlog.log_debug(g_error);
        IF NOT pk_discharge.get_dn_discussed_with(i_lang              => i_lang,
                                                  i_prof              => i_prof,
                                                  i_discharge_notes   => i_discharge_notes,
                                                  o_dn_discussed      => l_discussed,
                                                  o_dn_discussed_desc => l_discussed_desc,
                                                  o_error             => l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_discussed_with := pk_utils.concat_table(i_tab => l_discussed_desc, i_delim => '; ');
    
        RETURN l_discussed_with;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DN_DISCUSSED_WITH',
                                              l_error);
            RETURN NULL;
    END get_dn_discussed_with;

    FUNCTION get_dn_discussed_with
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_discharge_notes   IN discharge_notes.id_discharge_notes%TYPE,
        o_dn_discussed      OUT table_varchar,
        o_dn_discussed_desc OUT table_varchar,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'GET DISCHARGE_NOTES DISCUSSED WITH i_discharge_notes: ' || i_discharge_notes;
        SELECT pk_sysdomain.get_domain('DISCHARGE_NOTES.INSTRUCTIONS_DISCUSSED', d.instructions_discussed, i_lang),
               instructions_discussed
          BULK COLLECT
          INTO o_dn_discussed_desc, o_dn_discussed
          FROM disch_notes_discussed d
         WHERE d.id_discharge_notes = i_discharge_notes;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DN_DISCUSSED_WITH',
                                              o_error);
            RETURN FALSE;
    END get_dn_discussed_with;
    --#################################################################################################################### --
    /* *******************************************************************************************
    *  Get current state of dischrge instructions for viewer checklist 
    *             
    * @param    i_lang           Language ID
    * @param    i_prof           Logged professional structure
    * @param    i_scope_type     Scope flag | 'P' - Patient, 'E' - Episode, 'V' - Visit 
    * @param    i_id_episode     Episode ID
    * @param    i_id_patient     Patient ID
    *
    * @return VARCHAR2  Viewer checklist status | 'N' - Not started , 'C' - Complete, 'O' - On going
    * 
    * @author                     
    * @version                    
    * @since                              
    **********************************************************************************************/
    FUNCTION get_vwr_disch_notes
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_scope_type IN VARCHAR2,
        i_id_episode IN episode.id_episode%TYPE,
        i_id_patient IN patient.id_patient%TYPE
    ) RETURN VARCHAR2 IS
        l_status   VARCHAR2(1 CHAR) := pk_viewer_checklist.g_checklist_not_started;
        l_episodes table_number;
        l_count    NUMBER;
    BEGIN
    
        SELECT /*+ OPT_ESTIMATE(TABLE tblx ROWS=1) */
         id_episode
          BULK COLLECT
          INTO l_episodes
          FROM (SELECT column_value id_episode
                  FROM TABLE(pk_episode.get_scope(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_patient    => i_id_patient,
                                                  i_episode    => i_id_episode,
                                                  i_flg_filter => i_scope_type))) tblx;
    
        SELECT COUNT(*)
          INTO l_count
          FROM discharge_notes dn
         WHERE dn.flg_status != pk_discharge.g_phy_disch_notes_cancelled
           AND dn.id_episode IN (SELECT column_value
                                   FROM TABLE(l_episodes));
    
        IF l_count > 0
        THEN
            l_status := pk_viewer_checklist.g_checklist_completed;
        END IF;
    
        RETURN l_status;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN l_status;
    END get_vwr_disch_notes;

    /* *******************************************************************************************
    *  Get current state of dischrge  for viewer checklist 
    *             
    * @param    i_lang           Language ID
    * @param    i_prof           Logged professional structure
    * @param    i_scope_type     Scope flag | 'P' - Patient, 'E' - Episode, 'V' - Visit 
    * @param    i_id_episode     Episode ID
    * @param    i_id_patient     Patient ID
    *
    * @return VARCHAR2  Viewer checklist status | 'N' - Not started , 'C' - Complete, 'O' - On going
    * 
    * @author     Elisabete Bugalho                
    * @version                    
    * @since                              
    **********************************************************************************************/
    FUNCTION get_vwr_discharge
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_scope_type IN VARCHAR2,
        i_id_episode IN episode.id_episode%TYPE,
        i_id_patient IN patient.id_patient%TYPE
    ) RETURN VARCHAR2 IS
        l_status   VARCHAR2(1 CHAR) := pk_viewer_checklist.g_checklist_not_started;
        l_episodes table_number;
        l_count    NUMBER;
    BEGIN
    
        SELECT /*+ OPT_ESTIMATE(TABLE tblx ROWS=1) */
         id_episode
          BULK COLLECT
          INTO l_episodes
          FROM (SELECT column_value id_episode
                  FROM TABLE(pk_episode.get_scope(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_patient    => i_id_patient,
                                                  i_episode    => i_id_episode,
                                                  i_flg_filter => i_scope_type))) tblx;
    
        SELECT COUNT(*)
          INTO l_count
          FROM discharge d
         WHERE d.flg_status = pk_discharge.g_disch_flg_status_pend
           AND d.id_episode IN (SELECT /*+opt_estimate(table,e,scale_rows=1))*/
                                 column_value
                                  FROM TABLE(l_episodes) e);
    
        IF l_count > 0
        THEN
            l_status := pk_viewer_checklist.g_checklist_ongoing;
        ELSE
            SELECT COUNT(*)
              INTO l_count
              FROM discharge d
             WHERE d.flg_status = pk_discharge.g_disch_flg_status_active
               AND d.id_episode IN (SELECT /*+opt_estimate(table,e,scale_rows=1))*/
                                     column_value
                                      FROM TABLE(l_episodes) e);
            IF l_count > 0
            THEN
                l_status := pk_viewer_checklist.g_checklist_completed;
            END IF;
        END IF;
    
        RETURN l_status;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN l_status;
    END get_vwr_discharge;

    /********************************************************************************************
    * Get Admission information
    *             
    * @param i_lang       language idenfier
    * @param i_prof       profissional identifier
    * @param i_id_episode episode idenfier
    *
    * @return             Type with the admission information
    *
    * @author                         Elisabete Bugalho
    * @version                        2.7.2.3
    * @since                          2018-01-18
    **********************************************************************************************/

    FUNCTION tf_get_episode_discharge
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE
    ) RETURN t_table_epis_transf IS
        l_discharge          sys_message.desc_message%TYPE := pk_message.get_message(i_lang, 'PREV_EPISODE_T342');
        l_tbl_epis_discharge t_table_epis_transf;
        l_function_name      VARCHAR2(030 CHAR) := 'TF_GET_EPISODE_DISCHARGE';
        l_error              t_error_out;
        l_dt_end             episode.dt_end_tstz%TYPE;
        l_location           VARCHAR2(2000 CHAR);
        l_resp               VARCHAR2(2000 CHAR);
        l_id_type_discharge CONSTANT NUMBER(24) := 5;
    BEGIN
    
        SELECT e.dt_end_tstz
          INTO l_dt_end
          FROM episode e
         WHERE e.id_episode = i_id_episode;
        -- get patient location on discharge
        l_location := pk_bmng.get_pat_location_by_date(i_lang, i_prof, i_id_episode, l_dt_end);
    
        -- get resposability on discharge                                              
        l_resp := pk_hand_off.get_prof_resp_list_by_date(i_lang, i_prof, i_id_episode, l_dt_end);
    
        SELECT t_rec_epis_transf(i_id_episode, l_id_type_discharge, l_dt_end, l_discharge, l_location || ', ' || l_resp)
          BULK COLLECT
          INTO l_tbl_epis_discharge
          FROM dual;
    
        RETURN l_tbl_epis_discharge;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_function_name,
                                              o_error    => l_error);
            RETURN l_tbl_epis_discharge;
    END tf_get_episode_discharge;

    FUNCTION check_created_epis_on_disch
    (
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_prev_episode IN episode.id_prev_episode%TYPE
    ) RETURN VARCHAR2 IS
        l_created VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    BEGIN
        SELECT pk_alert_constant.g_yes
          INTO l_created
          FROM episode e
          JOIN episode pe
            ON pe.id_episode = e.id_prev_episode
         WHERE e.id_episode = i_id_episode
           AND e.id_prev_episode = i_id_prev_episode
           AND e.id_visit = pe.id_visit;
        RETURN l_created;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_constant.g_no;
    END check_created_epis_on_disch;

    FUNCTION check_exists_disch_type
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_episode     IN discharge.id_episode%TYPE,
        i_flg_type    IN VARCHAR2,
        o_exist_disch OUT VARCHAR2,
        o_type        OUT VARCHAR2,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id                 discharge.id_discharge%TYPE;
        l_exist              VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_type               discharge_flash_files.flg_type%TYPE;
        l_file_discharge_inp discharge_reason.file_to_execute%TYPE;
    
        --
        CURSOR c_exist IS
            SELECT id_discharge,
                   decode(d.flg_market,
                          'US',
                          nvl(dff.flg_type, pk_disposition.g_disp_other),
                          decode(dr.file_to_execute, l_file_discharge_inp, 'A', 'O'))
              FROM discharge d
            --A left join is made with discharge_flash_files to show all records even wrong ones
              LEFT JOIN discharge_flash_files dff
                ON dff.id_discharge_flash_files = d.id_discharge_flash_files
              JOIN disch_reas_dest drd
                ON d.id_disch_reas_dest = drd.id_disch_reas_dest
              JOIN discharge_reason dr
                ON drd.id_discharge_reason = dr.id_discharge_reason
             WHERE d.id_episode = i_episode
               AND d.dt_cancel_tstz IS NULL
               AND d.flg_status IN (pk_discharge.g_disch_flg_active, pk_discharge.g_disch_flg_pend);
    BEGIN
    
        l_file_discharge_inp := pk_sysconfig.get_config('FILE_DISCHARGE_INP', i_prof);
    
        --Verifica se já existe alta para este tipo, neste episódio
        g_error := 'OPEN CURSOR C_EXIST';
        OPEN c_exist;
        FETCH c_exist
            INTO l_id, l_type;
        CLOSE c_exist;
        IF l_id IS NOT NULL
        THEN
            -- Já existe alta deste tipo, neste episódio
            l_exist := pk_alert_constant.g_yes;
        END IF;
    
        o_exist_disch := l_exist;
        o_type        := l_type;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'CHECK_DISCHARGE_TYPE',
                                              o_error);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END check_exists_disch_type;

    /******************************************************************************
    * Used to return the names of all professionals
    * 
    * @param i_lang            Professional prefered language
    * @param i_prof            Professional information
    * @param o_prof             List of all professionals
    * 
    *
    ******************************************************************************/
    FUNCTION get_admitting_professionals
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_prof  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_show_all VARCHAR2(1 CHAR) := pk_sysconfig.get_config('DISCHARGE_ADMISSION_DOCTOR_ONLY_SPECIALIST', i_prof);
    
    BEGIN
    
        g_error := 'GET CURSOR';
        OPEN o_prof FOR
            SELECT DISTINCT prf.id_professional data,
                            to_char(prf.id_professional) val,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, prf.id_professional) desc_val,
                            0 rank
              FROM prof_institution pi
             INNER JOIN prof_cat prc
                ON (prc.id_professional = pi.id_professional)
             INNER JOIN category cat
                ON (cat.id_category = prc.id_category)
             INNER JOIN professional prf
                ON (prf.id_professional = pi.id_professional)
             INNER JOIN prof_profile_template ppt
                ON prc.id_institution = ppt.id_institution
               AND prc.id_professional = ppt.id_professional
              JOIN profile_template pt
                ON ppt.id_profile_template = pt.id_profile_template
             WHERE cat.flg_type = 'D'
               AND prf.flg_state = 'A'
               AND pi.id_institution = i_prof.institution
               AND pi.flg_state = pk_alert_constant.g_active
               AND pi.dt_end_tstz IS NULL
               AND prc.id_institution = i_prof.institution
               AND pi.flg_external = pk_alert_constant.g_no
               AND ppt.id_software = i_prof.software
               AND nvl(prf.flg_prof_test, pk_alert_constant.g_no) = pk_alert_constant.g_no
               AND pt.flg_profile = 'S'
             ORDER BY rank, desc_val;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'get_admitting_professionals',
                                              o_error);
            pk_types.open_my_cursor(o_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_admitting_professionals;

    /***********************************************************
    * used to get Print discharge report auto? (Y/N)
    ************************************************************/
    FUNCTION get_disch_print_report
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        o_type             OUT pk_types.cursor_type,
        o_flg_print_report OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_sys_config_value sys_config.value%TYPE;
    BEGIN
        OPEN o_type FOR
            SELECT *
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang,
                                                                  i_prof,
                                                                  pk_discharge_core.g_flg_print_report_domain,
                                                                  NULL));
    
        l_sys_config_value := pk_sysconfig.get_config(g_disch_print_report_auto, i_prof);
        o_flg_print_report := l_sys_config_value;
    
        IF l_sys_config_value = pk_alert_constant.g_no
        THEN
            SELECT nvl(flg_print_report, pk_alert_constant.g_no)
              INTO o_flg_print_report
              FROM epis_info ei
              JOIN dep_clin_serv dcs
                ON ei.id_dep_clin_serv = dcs.id_dep_clin_serv
             WHERE ei.id_episode = i_episode;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'GET_DISCH_PRINT_REPORT',
                                              o_error);
            pk_types.open_my_cursor(o_type);
            pk_alert_exceptions.reset_error_state();
            o_flg_print_report := pk_alert_constant.g_no;
        
            RETURN FALSE;
    END get_disch_print_report;

    /******************************************************************************
    * Used to return the names of all professionals
    * 
    * @param i_lang            Professional prefered language
    * @param i_prof            Professional information
    * @param o_prof             List of all professionals
    * 
    *
    ******************************************************************************/
    FUNCTION get_written_by_professionals
    (
        i_lang  IN NUMBER,
        i_prof  IN profissional,
        o_prof  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'GET CURSOR';
        OPEN o_prof FOR
            SELECT DISTINCT prf.id_professional data,
                            to_char(prf.id_professional) val,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, prf.id_professional) desc_val,
                            0 rank,
                            pk_alert_constant.g_yes flg_default
              FROM professional prf
             WHERE prf.id_professional = i_prof.id
             ORDER BY rank, desc_val;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              'get_written_by_professionals',
                                              o_error);
            pk_types.open_my_cursor(o_prof);
            pk_alert_exceptions.reset_error_state();
            RETURN FALSE;
    END get_written_by_professionals;

    FUNCTION get_admission_description
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_co_sign_hist IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN CLOB IS
        l_ret CLOB;
    BEGIN
    
        l_ret := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_ADMIT_T012');
        -- L_RET :='XXXX';
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END get_admission_description;

    FUNCTION get_admission_instructions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_co_sign_hist IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN CLOB IS
        l_ret              CLOB;
        l_clinical_service VARCHAR2(4000);
        l_physician        VARCHAR2(2000);
    BEGIN
    
        SELECT pk_translation.get_translation(i_lang,
                                              'CLINICAL_SERVICE.CODE_CLINICAL_SERVICE.' || dcs.id_clinical_service),
               (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, dd.id_prof_admitting)
                  FROM dual)
          INTO l_clinical_service, l_physician
          FROM discharge d
          JOIN discharge_detail dd
            ON d.id_discharge = dd.id_discharge
          JOIN dep_clin_serv dcs
            ON dd.id_dep_clin_serv_admiting = dcs.id_dep_clin_serv
         WHERE d.id_discharge = i_id_discharge;
        --   l_ret := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_ADMIT_T012');
        l_ret := l_clinical_service;
        IF l_physician IS NOT NULL
        THEN
            l_ret := l_ret || ' - ' || l_physician;
        END IF;
        --   DISCHARGE_ADMIT_T003
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_admission_instructions;

    FUNCTION get_admission_action_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_action       IN co_sign.id_action%TYPE,
        i_co_sign_hist IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret sys_message.desc_message%TYPE;
    BEGIN
        l_ret := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_M146');
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END get_admission_action_desc;

    FUNCTION get_admission_date
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_co_sign_hist IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
        l_ret TIMESTAMP WITH LOCAL TIME ZONE;
    BEGIN
    
        SELECT d.dt_med_tstz
          INTO l_ret
          FROM discharge d
         WHERE d.id_discharge = i_id_discharge;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END get_admission_date;

    FUNCTION get_discharge_description
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_co_sign_hist IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN CLOB IS
        l_ret CLOB;
    BEGIN
    
        SELECT pk_translation.get_translation(i_lang, dr.code_discharge_reason)
          INTO l_ret
          FROM discharge d
          JOIN disch_reas_dest drd
            ON d.id_disch_reas_dest = drd.id_disch_reas_dest
          JOIN discharge_reason dr
            ON drd.id_discharge_reason = dr.id_discharge_reason
         WHERE d.id_discharge = i_id_discharge;
        --        l_ret := pk_message.get_message(i_lang => i_lang, i_code_mess => 'DISCHARGE_ADMIT_T012');
        -- L_RET :='XXXX';
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END get_discharge_description;

    FUNCTION get_discharge_instructions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_co_sign_hist IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN CLOB IS
        l_ret CLOB;
    BEGIN
    
        SELECT pk_disposition.get_disch_dest_label(i_lang               => i_lang,
                                                   i_prof               => i_prof,
                                                   i_id_disch_reas_dest => d.id_disch_reas_dest)
          INTO l_ret
          FROM discharge d
         WHERE d.id_discharge = i_id_discharge;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_discharge_instructions;

    FUNCTION get_discharge_action_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_action       IN co_sign.id_action%TYPE,
        i_co_sign_hist IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret sys_message.desc_message%TYPE;
    BEGIN
        l_ret := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_M146');
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END get_discharge_action_desc;

    FUNCTION get_discharge_date
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_discharge IN discharge.id_discharge%TYPE,
        i_co_sign_hist IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
        l_ret TIMESTAMP WITH LOCAL TIME ZONE;
    BEGIN
    
        SELECT d.dt_med_tstz
          INTO l_ret
          FROM discharge d
         WHERE d.id_discharge = i_id_discharge;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END get_discharge_date;

    FUNCTION get_patient_condition
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
    
        l_patient_condition VARCHAR2(200 CHAR);
    BEGIN
        SELECT pk_discharge.get_patient_condition(i_lang,
                                                  i_prof,
                                                  d.id_discharge,
                                                  drd.id_discharge_reason,
                                                  dd.flg_pat_condition)
          INTO l_patient_condition
          FROM discharge d
        
          JOIN disch_reas_dest drd
            ON drd.id_disch_reas_dest = d.id_disch_reas_dest
          JOIN discharge_detail dd
            ON dd.id_discharge = d.id_discharge
         WHERE d.id_episode = i_id_episode
           AND d.flg_status NOT IN (pk_discharge.g_disch_flg_status_cancel, pk_discharge.g_disch_flg_reopen);
        RETURN l_patient_condition;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_patient_condition;

    FUNCTION get_discharge_schedule_date
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
        l_discharge_date  discharge_schedule.dt_discharge_schedule%TYPE;
        l_flg_hour_origin discharge_schedule.flg_hour_origin%TYPE;
        l_error           t_error_out;
        e_discharge_date EXCEPTION;
    BEGIN
    
        IF NOT get_discharge_schedule_date(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_id_episode      => i_id_episode,
                                           o_discharge_date  => l_discharge_date,
                                           o_flg_hour_origin => l_flg_hour_origin,
                                           o_error           => l_error)
        THEN
            RAISE e_discharge_date;
        END IF;
        RETURN get_formatted_disch_sch_date(i_lang, i_prof, i_id_episode, l_discharge_date, l_flg_hour_origin);
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_discharge_schedule_date;
    -- ##################################################################################
-- GLOBALS
-- ##################################################################################   
BEGIN

    g_owner        := 'ALERT';
    g_package_name := pk_alertlog.who_am_i;

    pk_alertlog.who_am_i(g_owner, g_package_name);
    pk_alertlog.log_init(g_package_name);

    g_found_true  := 'Y';
    g_found_false := 'N';
    --
    g_yes        := 'Y';
    g_no         := 'N';
    g_document_n := 'N';
    g_document_d := 'D';
    --
    g_cat_avail := 'Y';
    --
    g_disch_cancel := 'C';
    g_disch_active := 'A';
    --
    g_diagn_actv  := 'A'; --diagnóstico activo
    g_diagn_canc  := 'C';
    g_diagn_decl  := 'R';
    g_diagn_def   := 'D'; --diagnóstico definitivo
    g_diagn_base  := 'B'; --diagnóstico base
    g_flag_diag   := 'Y';
    g_diagn_final := 'F';
    --
    g_epis_diag_act  := 'A';
    g_epis_diag_canc := 'C';
    g_epis_diag_decl := 'R';
    g_epis_diag_def  := 'D'; -- Diagnóstico definitivo
    g_epis_diag_base := 'B';
    --
    g_disch_type_alert := 'A';
    --g_disch_type_nurse    := 'N';--SF
    g_disch_flg_active    := 'A';
    g_disch_flg_reopen    := 'R';
    g_disch_flg_cancel    := 'C';
    g_disch_flg_pend      := 'P';
    g_disch_flg_available := 'Y';
    g_disch_flg_pay_n     := 'N';
    g_disch_flg_pay_y     := 'Y';
    --
    g_domain_disch := 'DISCHARGE.FLG_TYPE';
    --
    g_disch_notes_np := 'NP';
    g_disch_notes_p  := 'P';
    g_disch_notes_c  := 'C';
    g_disch_n_status := 'DISCHARGE_NOTES.FLG_STATUS';
    --
    g_disch_type_f               := 'F';
    g_disch_act                  := 'A';
    g_disch_reopen               := 'R';
    g_disch_reas_dest_default    := 'DEFAULT_DISCH_REAS_DEST';
    g_disch_trans_entity_default := 'DEFAULT_TRANSP_ENT_INST';
    g_disch_reas_dest_default    := 'DEFAULT_DISCH_REAS_DEST';
    g_disch_trans_entity_default := 'DEFAULT_TRANSP_ENT_INST';
    --
    g_disch_print_report_auto := 'PRINT_DISCHARGE_REPORT_AUTO';
    --
    g_epis_disch_act := 'A';
    --
    g_epis_status_active := 'A';
    g_epis_status_cons   := 'T';
    g_epis_status_atend  := 'N';
    --
    g_visit_active   := 'A';
    g_epis_active    := 'A';
    g_visit_inactive := 'I';
    g_epis_inactive  := 'I';
    g_epis_canc      := 'C';
    g_epis_pend      := 'P';
    g_epis_act       := 'A';
    --
    g_without_patient_epis_type := 10;
    g_care_nurse_epis_type      := 14;
    g_outp_nurse_epis_type      := 16;
    g_epis_type_oris            := 4;
    g_epis_flg_type_d           := 'D';
    --
    g_isencao       := 1;
    g_complaint_act := 'A';
    g_complaint     := 'C';
    --
    g_flash_mask                 := 'YYYYMMDDHH24MI';
    g_message_none               := 'COMMON_M002';
    g_sys_config_default_flg_pay := 'DISCHARGE_FLG_PAYMENT_DEFAULT';
    --
    g_flg_hist := 'H';
    g_flg_temp := 'T';
    g_flg_def  := 'D';
    --
    g_type_p := 'P';
    g_type_d := 'D';
    g_type_n := 'N';
    g_type_m := 'M';
    g_type_a := 'A';
    g_type_l := 'L';
    --
    g_anamnesis_type  := 'C';
    g_admin_anamnesis := 'A';
    --
    --Analysis
    g_analysis_det_req    := 'R';
    g_analysis_det_result := 'F';
    g_analysis_det_canc   := 'C';
    g_analysis_det_read   := 'L';
    g_analysis_det_exec   := 'E';
    g_analysis_det_pend   := 'D';
    --
    g_analisys_status_final := 'F';
    g_analisys_status_red   := 'L';
    --
    --Exames
    g_exam_det_canc     := 'C';
    g_exam_det_result   := 'F';
    g_exam_status_final := 'F';
    g_exam_status_red   := 'L';
    --
    --Procedimentos
    g_interv_det_canc  := 'C';
    g_interv_det_fin   := 'F';
    g_interv_det_inter := 'I';
    --

    --
    g_admin_category := 'A';
    g_disch_cancel   := 'C';

    g_flg_available := 'Y';

    g_surgery_type_c := 'C';

    g_unknown           := 'Y';
    g_epis_info_efectiv := 'E';

    g_disch_type_nurse := 'P';

    g_flg_other := 'O';

    g_disch_type_therapist_f := 'F';
    g_disch_type_therapist_o := 'O';

END pk_discharge;
/
