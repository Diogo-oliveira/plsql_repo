/*-- Last Change Revision: $Rev: 2048103 $*/
/*-- Last Change by: $Author: elisabete.bugalho $*/
/*-- Date of last change: $Date: 2022-10-20 17:35:23 +0100 (qui, 20 out 2022) $*/

CREATE OR REPLACE PACKAGE BODY pk_backoffice_default IS
    -- Package info
    g_package_owner VARCHAR2(30) := 'ALERT';
    g_package_name  VARCHAR2(30) := 'PK_BACKOFFICE_DEFAULT';
    /********************************************************************************************
    * check_translation: check if translation exists
    *
    * @param i_lang                Prefered language ID
    * @param i_code                code translation    
    *
    *
    * @return                      0 id no tranlsation available, 1 if tranlsation exists
    *
    * @author                      CMF
    * @version                     1
    * @since                       2010/09/28
    ********************************************************************************************/
    FUNCTION check_translation
    (
        i_lang IN language.id_language%TYPE,
        i_code IN translation.code_translation%TYPE
    ) RETURN NUMBER IS
        l_count NUMBER(24);
    BEGIN
    
        l_count := 0;
        IF pk_translation.get_translation(i_lang, i_code) IS NOT NULL
        THEN
            l_count := 1;
        END IF;
    
        RETURN l_count;
    
    END check_translation;
    /********************************************************************************************
    * Get relation of interventions and drugs for the specified markets and versions.
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_id_intervention     Cursor of default data
    * @param o_id_drug             Cursor of default data
    * @param o_flg_type            Cursor of default data
    * @param o_vers                Cursor of default data
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      Ana Coelho
    * @version                     0.1
    * @since                       07-JUN-2011
    ********************************************************************************************/
    FUNCTION get_inst_interv_drug
    (
        i_lang            IN language.id_language%TYPE,
        i_market          IN table_number,
        i_version         IN table_varchar,
        i_id_institution  IN institution.id_institution%TYPE,
        o_id_intervention OUT pk_types.cursor_type,
        o_id_drug         OUT pk_types.cursor_type,
        o_flg_type        OUT pk_types.cursor_type,
        o_vers            OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_intervention alert_default.interv_drug.id_intervention%TYPE;
        l_id_drug         alert_default.interv_drug.id_drug%TYPE;
        l_flg_type        alert_default.interv_drug.flg_type%TYPE;
        l_vers            alert_default.interv_drug.vers%TYPE;
    
        l_id_intervention_array table_number := table_number();
        l_id_drug_array         table_varchar := table_varchar();
        l_flg_type_array        table_varchar := table_varchar();
        l_vers_array            table_varchar := table_varchar();
    
        l_count              NUMBER := 0;
        l_index              NUMBER := 1;
        l_intervention_exist NUMBER := 0;
        l_drug_exist         NUMBER := 0;
    
        CURSOR c_interv_drug_inst
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT id.id_intervention, id.id_drug, id.flg_type, id.vers
              FROM alert_default.interv_drug id
             WHERE id.id_market = c_market
               AND id.version = c_version;
    BEGIN
    
        g_func_name := 'GET_INST_INTERV_DRUG';
    
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_EVENT_SOFT_INST';
                OPEN c_interv_drug_inst(i_version(i), i_market(j));
                LOOP
                    g_error := 'FETCH C_INTERV_DRUG_INST';
                    FETCH c_interv_drug_inst
                        INTO l_id_intervention, l_id_drug, l_flg_type, l_vers;
                    EXIT WHEN c_interv_drug_inst%NOTFOUND;
                
                    g_error := 'SELECT ID_INTERVENTION';
                    SELECT nvl((SELECT i.id_intervention
                                 FROM alert_default.intervention ai
                                 JOIN intervention i
                                   ON (ai.id_content = i.id_content)
                                WHERE ai.id_intervention = l_id_intervention),
                               0)
                      INTO l_intervention_exist
                      FROM dual;
                
                    g_error := 'SELECT ID_DRUG';
                    SELECT nvl((SELECT d.id_drug
                                 FROM drug d
                                WHERE d.id_drug = l_id_drug),
                               '0')
                      INTO l_drug_exist
                      FROM dual;
                
                    IF l_intervention_exist != 0
                       AND l_drug_exist != '0'
                    THEN
                        g_error := 'SELECT COUNT ID_INTERV_DRUG';
                        SELECT COUNT(id.id_interv_drug)
                          INTO l_count
                          FROM interv_drug id
                         WHERE id.id_institution = i_id_institution
                           AND id.id_intervention = l_intervention_exist
                           AND id.id_drug = l_id_drug;
                    
                        IF l_count = 0
                        THEN
                            l_id_intervention_array.extend;
                            l_id_drug_array.extend;
                            l_flg_type_array.extend;
                            l_vers_array.extend;
                        
                            l_id_intervention_array(l_index) := l_intervention_exist;
                            l_id_drug_array(l_index) := l_id_drug;
                            l_flg_type_array(l_index) := l_flg_type;
                            l_vers_array(l_index) := l_vers;
                        
                            l_index := l_index + 1;
                        END IF;
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_INTERV_DRUG_INST';
                CLOSE c_interv_drug_inst;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_INTERVENTION';
        OPEN o_id_intervention FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_intervention_array AS table_number));
    
        g_error := 'CLOSE O_ID_DRUG';
        OPEN o_id_drug FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_drug_array AS table_varchar));
    
        g_error := 'CLOSE O_FLG_TYPE';
        OPEN o_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_type_array AS table_varchar));
    
        g_error := 'CLOSE O_VERS';
        OPEN o_vers FOR
            SELECT column_value
              FROM TABLE(CAST(l_vers_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              'PK_DEFAULT_CONTENT',
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_intervention);
            pk_types.open_my_cursor(o_id_drug);
            pk_types.open_my_cursor(o_flg_type);
            pk_types.open_my_cursor(o_vers);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_interv_drug;

    /********************************************************************************************
    * Set relation of interventions and drugs for the specified institution.
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_inst_interv_drug    Cursor of default data
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      Ana Coelho
    * @version                     0.1
    * @since                       07-JUN-2011
    ********************************************************************************************/
    FUNCTION set_inst_interv_drug
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_inst_interv    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_intervention pk_types.cursor_type;
        l_c_id_drug         pk_types.cursor_type;
        l_c_flg_type        pk_types.cursor_type;
        l_c_vers            pk_types.cursor_type;
    
        l_data_id_intervention table_number := table_number();
        l_data_id_drug         table_varchar := table_varchar();
        l_data_flg_type        table_varchar := table_varchar();
        l_data_vers            table_varchar := table_varchar();
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    BEGIN
    
        g_func_name := 'SET_INST_INTERV_DRUG';
    
        g_error := 'CALL GET_INST_INTERV_DRUG';
        IF NOT get_inst_interv_drug(i_lang            => i_lang,
                                    i_market          => i_market,
                                    i_version         => i_version,
                                    i_id_institution  => i_id_institution,
                                    o_id_intervention => l_c_id_intervention,
                                    o_id_drug         => l_c_id_drug,
                                    o_flg_type        => l_c_flg_type,
                                    o_vers            => l_c_vers,
                                    o_error           => o_error)
        THEN
            RAISE l_exception;
        ELSE
        
            g_error       := 'O_INST_INTERV := L_C_ID_INTERVENTION';
            o_inst_interv := l_c_id_intervention;
        
            LOOP
            
                FETCH l_c_id_intervention BULK COLLECT
                    INTO l_data_id_intervention LIMIT g_array_size;
            
                FETCH l_c_id_drug BULK COLLECT
                    INTO l_data_id_drug LIMIT g_array_size;
            
                FETCH l_c_flg_type BULK COLLECT
                    INTO l_data_flg_type LIMIT g_array_size;
            
                FETCH l_c_vers BULK COLLECT
                    INTO l_data_vers LIMIT g_array_size;
            
                FORALL j IN 1 .. l_data_id_intervention.count SAVE EXCEPTIONS
                    INSERT INTO interv_drug
                        (id_interv_drug, id_intervention, id_drug, flg_type, id_institution, vers)
                    VALUES
                        (seq_interv_drug.nextval,
                         l_data_id_intervention(j),
                         l_data_id_drug(j),
                         l_data_flg_type(j),
                         i_id_institution,
                         l_data_vers(j));
                EXIT WHEN l_c_id_intervention%NOTFOUND;
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_INTERVENTION';
            CLOSE l_c_id_intervention;
            g_error := 'CLOSE L_C_ID_DRUG';
            CLOSE l_c_id_drug;
            g_error := 'CLOSE L_C_FLG_TYPE';
            CLOSE l_c_flg_type;
            g_error := 'CLOSE L_C_VERS';
            CLOSE l_c_vers;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  'PK_DEFAULT_CONTENT',
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              'PK_DEFAULT_CONTENT',
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              'PK_DEFAULT_CONTENT',
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_interv_drug;

    /********************************************************************************************
    * Set a Default Parameterization for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/25
    ********************************************************************************************/
    FUNCTION set_inst_default_param
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        i_id_content     IN table_varchar DEFAULT table_varchar(),
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_health_plans               pk_types.cursor_type;
        l_c_inst_unit_measures         pk_types.cursor_type;
        l_c_inst_analysis              pk_types.cursor_type;
        l_c_inst_analysis_group        pk_types.cursor_type;
        l_c_inst_exams                 pk_types.cursor_type;
        l_c_inst_interv                pk_types.cursor_type;
        l_c_inst_st                    pk_types.cursor_type;
        l_c_inst_supplies              pk_types.cursor_type;
        l_c_inst_hidrics               pk_types.cursor_type;
        l_c_inst_transp                pk_types.cursor_type;
        l_c_inst_disch_instr           pk_types.cursor_type;
        l_c_inst_disch_instr_group     pk_types.cursor_type;
        l_c_inst_disch_reason          pk_types.cursor_type;
        l_c_inst_disch_dest            pk_types.cursor_type;
        l_c_inst_icnp_compo            pk_types.cursor_type;
        l_c_inst_icnp_axis_cs          pk_types.cursor_type;
        l_c_inst_alert_diagnosis       pk_types.cursor_type;
        l_c_inst_vacc                  pk_types.cursor_type;
        l_c_inst_vital_signs           pk_types.cursor_type;
        l_c_inst_exam_type_vs          pk_types.cursor_type;
        l_c_inst_events                pk_types.cursor_type;
        l_c_inst_lens                  pk_types.cursor_type;
        l_c_inst_calc                  pk_types.cursor_type;
        l_c_inst_templates             pk_types.cursor_type;
        l_c_inst_pop                   pk_types.cursor_type;
        l_c_inst_pod                   pk_types.cursor_type;
        l_c_inst_int_med               pk_types.cursor_type;
        l_c_inst_ext_med               pk_types.cursor_type;
        l_c_inst_health_program        pk_types.cursor_type;
        l_c_inst_health_program_event  pk_types.cursor_type;
        l_c_inst_cancel_reason         pk_types.cursor_type;
        l_c_inst_diet                  pk_types.cursor_type;
        l_c_inst_codification          pk_types.cursor_type;
        l_c_inst_advanced_input        pk_types.cursor_type;
        l_c_inst_notes_profile         pk_types.cursor_type;
        l_c_sr_interv_duration         pk_types.cursor_type;
        l_c_sr_posit                   pk_types.cursor_type;
        l_c_inst_wtl                   pk_types.cursor_type;
        l_c_origin                     pk_types.cursor_type;
        l_c_inst_origin                pk_types.cursor_type;
        l_c_inst_order_set             pk_types.cursor_type;
        l_c_order_set_link             pk_types.cursor_type;
        l_c_order_set_task             pk_types.cursor_type;
        l_c_inst_order_set_frequent    pk_types.cursor_type;
        l_c_graphic                    pk_types.cursor_type;
        l_c_follow                     pk_types.cursor_type;
        l_c_body_diagram               pk_types.cursor_type;
        l_c_p1                         pk_types.cursor_type;
        l_c_sys_config                 pk_types.cursor_type;
        l_c_disch_rea_transp_ei        pk_types.cursor_type;
        l_c_profile_disch_reason       pk_types.cursor_type;
        l_c_protocol                   pk_types.cursor_type;
        l_c_guideline                  pk_types.cursor_type;
        l_c_comp_config                pk_types.cursor_type;
        l_c_comp_axe_detail            pk_types.cursor_type;
        l_c_checklist                  pk_types.cursor_type;
        l_c_rehab_area_interv          pk_types.cursor_type;
        l_c_rehab_inst_soft            pk_types.cursor_type;
        l_c_exam_body_structure        pk_types.cursor_type;
        l_c_body_structure_freq        pk_types.cursor_type;
        l_c_external_causes            table_number;
        l_c_appointments               pk_types.cursor_type;
        l_c_quest_response             pk_types.cursor_type;
        l_c_exam_quest                 pk_types.cursor_type;
        l_c_inst_habits                pk_types.cursor_type;
        l_c_inst_tl_vertical_axis      pk_types.cursor_type;
        l_c_inst_tl_horizontal_axis    pk_types.cursor_type;
        l_c_inst_hidrics_device_rel    pk_types.cursor_type;
        l_c_inst_hidrics_occurs_tp_rel pk_types.cursor_type;
        l_c_inst_interv_drug           pk_types.cursor_type;
        -- new
        l_c_hc_habit_char table_number := table_number();
        l_c_hc_habit      table_number := table_number();
        /*v2.6.1.5: ALERT-203542*/
        l_c_supply        pk_types.cursor_type;
        l_c_supply_sa     pk_types.cursor_type;
        l_c_supply_loc    pk_types.cursor_type;
        l_c_supply_ctx    pk_types.cursor_type;
        l_c_supply_reason pk_types.cursor_type;
        l_c_supply_rel    pk_types.cursor_type;
        /*v2.6.1.6: ALERT-199895*/
        l_c_analysis_collection pk_types.cursor_type;
        l_c_lab_collection_int  pk_types.cursor_type;
        /*v2.6.1.8: ALERT-219338*/
        l_c_result_notes_is pk_types.cursor_type;
        /*v2.6.1.8: ALERT-161435*/
        l_c_occupation                 pk_types.cursor_type;
        l_c_inst_order_set_task_detail pk_types.cursor_type;
    
        --common result
        l_result NUMBER;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'SET INSTITUTION HEALTH PLANS';
        IF NOT set_inst_health_plans(i_lang, i_market, i_version, i_id_institution, l_c_health_plans, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION POSITIONINGS';
        IF NOT set_def_positioning(i_lang, i_market, i_version, l_result, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION UNIT MEASURES';
        IF NOT set_inst_unit_measures(i_lang,
                                      i_market,
                                      i_version,
                                      i_id_institution,
                                      i_software,
                                      l_c_inst_unit_measures,
                                      l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION ANALYSIS';
        IF NOT set_inst_analysis(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_analysis, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION ANALYSIS GROUPS';
        IF NOT set_inst_analysis_group(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software,
                                       l_c_inst_analysis_group,
                                       l_error)
        THEN
            RAISE l_exception;
        END IF;
        g_error := 'SET INSTITUTION ANALYSIS COLLECTION';
        IF NOT set_inst_analysis_collection(i_lang,
                                            i_market,
                                            i_version,
                                            i_id_institution,
                                            i_software,
                                            l_c_analysis_collection,
                                            l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION ANALYSIS COLLECTION INTERNAL';
        IF NOT set_inst_lab_collection_int(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software,
                                           l_c_lab_collection_int,
                                           l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION EXAMS';
        IF NOT set_inst_exams(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_exams, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION INTERV INT CAT';
        IF NOT pk_backoffice_default.set_inst_interv_cat(i_lang,
                                                         i_market,
                                                         i_version,
                                                         i_id_institution,
                                                         i_software,
                                                         l_result,
                                                         o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION INTERVENTIONS';
        IF NOT set_inst_interv(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_interv, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION DIAGNOSIS';
        IF NOT set_inst_diagnosis(i_lang, i_market, i_version, i_id_institution, i_software, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION SAMPLE TEXTS';
        IF NOT set_inst_sample_text(i_lang, i_market, i_version, i_id_institution, l_c_inst_st, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION HIDRICS';
        IF NOT set_inst_hidrics(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_hidrics, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION TRANSPORTS';
        IF NOT set_inst_transp(i_lang, i_market, i_version, i_id_institution, l_c_inst_transp, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION DISCHARGES';
    
        IF NOT set_inst_discharges(i_lang,
                                   i_market,
                                   i_version,
                                   i_id_institution,
                                   i_software,
                                   l_c_inst_disch_instr,
                                   l_c_inst_disch_instr_group,
                                   l_c_inst_disch_reason,
                                   l_c_inst_disch_dest,
                                   l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION DISCH_REA_TRANSP_ENT_INST';
    
        IF NOT
            set_inst_disch_rea_transp_ei(i_lang, i_market, i_version, i_id_institution, l_c_disch_rea_transp_ei, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION PROFILE_DISCH_REASON';
    
        IF NOT set_inst_profile_disch_reason(i_lang,
                                             i_market,
                                             i_version,
                                             i_id_institution,
                                             l_c_profile_disch_reason,
                                             l_error)
        THEN
            RAISE l_exception;
        END IF;
        /*Added V2.6.3.2*/
        g_error := 'SET INSTITUTION ICNP COMPOSITIONS';
        IF NOT set_inst_icnp_composition(i_lang, i_market, i_version, i_id_institution, i_software, l_result, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION ICNP COMPOSITIONS HISTORY';
        IF NOT
            set_inst_icnp_composition_hist(i_lang, i_market, i_version, i_id_institution, i_software, l_result, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION ICNP COMPOSITIONS TERMS';
        IF NOT
            set_inst_icnp_composition_term(i_lang, i_market, i_version, i_id_institution, i_software, l_result, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION ICNP PREDEFINED AREAS';
        IF NOT
            set_inst_icnp_compo(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_icnp_compo, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET DEFAULT ICNP TASK COMPOSITION';
        IF NOT pk_icnp_prm.load_icnp_task_comp_def(i_lang,
                                                   i_id_institution,
                                                   i_market,
                                                   i_version,
                                                   i_software,
                                                   l_result,
                                                   l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET DEFAULT ICNP TASK COMPOSITION BY SOFTWARE AND INSTITUTION';
        IF NOT set_inst_task_comp_search(i_lang, i_market, i_version, i_id_institution, i_software, l_result, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION VACINES';
        IF NOT set_inst_vacc(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_vacc, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION VITAL SIGNS';
        IF NOT set_inst_vital_signs(i_lang,
                                    i_market,
                                    i_version,
                                    i_id_institution,
                                    i_software,
                                    l_c_inst_vital_signs,
                                    l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION VITAL SIGNS SCALES';
        IF NOT pk_vitalsign_prm.set_vital_sign_sa_search(i_lang,
                                                         i_id_institution,
                                                         i_market,
                                                         i_version,
                                                         i_software,
                                                         i_id_content,
                                                         l_result,
                                                         l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION VITAL SIGNS EXAM TYPE';
        IF NOT set_inst_vs_exam_type(i_lang,
                                     i_market,
                                     i_version,
                                     i_id_institution,
                                     i_software,
                                     l_c_inst_exam_type_vs,
                                     l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION LENS';
        IF NOT set_inst_lens(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_lens, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION CALCULATORS';
        IF NOT set_inst_calc(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_calc, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION TEMPLATES';
        IF NOT
            set_inst_templates(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_templates, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION SOFTWARE TEMPLATES';
        IF NOT set_inst_doc_template_si(i_lang, i_market, i_version, i_id_institution, i_software, l_result, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION INTERNAL MEDICATION';
        IF NOT set_inst_int_med(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_int_med, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION EXTERNAL MEDICATION';
        IF NOT set_inst_ext_med(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_ext_med, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION HEALTH PROGRAM';
        IF NOT set_inst_health_program(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software,
                                       l_c_inst_health_program,
                                       l_c_inst_health_program_event,
                                       l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION CANCEL_REASON';
        IF NOT set_inst_cancel_reason(i_lang,
                                      i_market,
                                      i_version,
                                      i_id_institution,
                                      i_software,
                                      l_c_inst_cancel_reason,
                                      l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION DIET';
        IF NOT set_inst_diet(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_diet, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET CODIFICATION INSTITUTION';
        IF NOT set_inst_codification(i_lang,
                                     i_market,
                                     i_version,
                                     i_id_institution,
                                     i_software,
                                     l_c_inst_codification,
                                     l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET ADVANCED_INPUT INSTITUTION';
        IF NOT set_inst_advanced_input(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software,
                                       l_c_inst_advanced_input,
                                       l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_notes_profile_inst INSTITUTION';
        IF NOT set_inst_notes_profile_inst(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software,
                                           l_c_inst_notes_profile,
                                           l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_SR_INTERV_DURATION_INST INSTITUTION';
        IF NOT set_sr_interv_duration_inst(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software,
                                           l_c_sr_interv_duration,
                                           l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_sr_posi INSTITUTION';
        IF NOT set_inst_sr_posit(i_lang, i_market, i_version, i_id_institution, i_software, l_c_sr_posit, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_wtl_urg_level INSTITUTION';
        IF NOT set_inst_wtl_urg_level(i_lang, i_id_institution, l_c_inst_wtl, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_def_origin INSTITUTION';
        IF NOT set_inst_origin(i_lang, l_c_origin, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_origin_soft_inst INSTITUTION';
        IF NOT set_inst_origin_soft_inst(i_lang,
                                         i_market,
                                         i_version,
                                         i_id_institution,
                                         i_software,
                                         l_c_inst_origin,
                                         o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_order_set INSTITUTION';
        IF NOT
            set_inst_order_set(i_lang, i_market, i_version, i_id_institution, i_software, l_c_inst_order_set, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_order_set_link INSTITUTION';
        IF NOT set_inst_order_set_link(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software,
                                       l_c_order_set_link,
                                       o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_order_set_task INSTITUTION';
        IF NOT set_inst_order_set_task(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software,
                                       l_c_order_set_task,
                                       o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_order_set_task_detail INSTITUTION';
        IF NOT set_inst_order_set_task_detail(i_lang,
                                              i_market,
                                              i_version,
                                              i_id_institution,
                                              i_software,
                                              l_c_inst_order_set_task_detail,
                                              o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_order_set_frequent INSTITUTION';
        IF NOT set_inst_order_set_frequent(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software,
                                           l_c_inst_order_set_frequent,
                                           o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_graphic_soft_inst INSTITUTION';
        IF NOT
            set_inst_graphic_soft_inst(i_lang, i_market, i_version, i_id_institution, i_software, l_c_graphic, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET set_inst_follow_up_entity_si INSTITUTION';
        IF NOT
            set_inst_follow_up_entity_si(i_lang, i_market, i_version, i_id_institution, i_software, l_c_follow, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_BODY_DIAGRAM INSTITUTION';
        IF NOT
            set_inst_body_diagram(i_lang, i_market, i_version, i_id_institution, i_software, l_c_body_diagram, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_P1 INSTITUTION';
        IF NOT set_inst_p1(i_lang, i_id_institution, l_c_p1, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_SYS_CONFIG INSTITUTION';
        IF NOT set_inst_sys_config(i_lang, i_market, i_id_institution, i_software, l_c_sys_config, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_PROTOCOL';
        IF NOT set_inst_protocol(i_lang, i_market, i_version, i_id_institution, i_software, l_c_protocol, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_GUIDELINES INSTITUTION';
        IF NOT set_inst_guideline(i_lang, i_market, i_version, i_id_institution, i_software, l_c_guideline, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_COMP_CONFIG';
        IF NOT set_inst_comp_config(i_lang, i_market, i_version, i_id_institution, i_software, l_c_comp_config, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_COMP_AXE_DETAIL';
        IF NOT set_inst_comp_axe_detail(i_lang, i_market, i_version, l_c_comp_axe_detail, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_CHECKLISTS';
        IF NOT set_inst_checklist_inst(i_lang, i_market, i_version, i_id_institution, l_c_checklist, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_REHAB_AREA_INTERV';
        IF NOT set_inst_rehab_area_interv(i_lang, i_market, i_version, i_id_institution, l_c_rehab_area_interv, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_REHAB_INST_SOFT';
        IF NOT set_inst_rehab_inst_soft(i_lang,
                                        i_market,
                                        i_version,
                                        i_id_institution,
                                        i_software,
                                        l_c_rehab_inst_soft,
                                        o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET DEFAULT EXTERNAL CAUSE BY MRK/VRS';
        IF NOT set_def_external_cause(i_lang, i_market, i_version, l_c_external_causes, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET DEFAULT QUESTIONNAIRE_RESPONSE BY MRK/VRS';
        IF NOT set_inst_quest_response(i_lang, i_market, i_version, l_c_quest_response, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET DEFAULT EXAM_QUESTIONNAIRE BY MRK/VRS';
        IF NOT set_inst_exam_questionnaire(i_lang, i_market, i_version, l_c_exam_quest, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION HABITS';
        IF NOT pk_backoffice_default.set_inst_habits(i_lang,
                                                     i_market,
                                                     i_version,
                                                     i_id_institution,
                                                     l_c_inst_habits,
                                                     o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_TL_VERTICAL_AXIS INSTITUTION';
        IF NOT set_inst_tl_vertical_axis(i_lang,
                                         i_market,
                                         i_version,
                                         i_id_institution,
                                         i_software,
                                         l_c_inst_tl_vertical_axis,
                                         o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_TL_HORIZONTAL_AXIS INSTITUTION';
        IF NOT set_inst_tl_horizontal_axis(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software,
                                           l_c_inst_tl_horizontal_axis,
                                           o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_HIDRICS_DEVICE_REL INSTITUTION';
        IF NOT set_inst_hidrics_device_rel(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           l_c_inst_hidrics_device_rel,
                                           o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_HIDRICS_OCCURS_TYPE_REL INSTITUTION';
        IF NOT set_inst_hidrics_occurs_tp_rel(i_lang,
                                              i_market,
                                              i_version,
                                              i_id_institution,
                                              l_c_inst_hidrics_occurs_tp_rel,
                                              o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION INTERVENTION DRUG';
        IF NOT set_inst_interv_drug(i_lang           => i_lang,
                                    i_market         => i_market,
                                    i_version        => i_version,
                                    i_id_institution => i_id_institution,
                                    o_inst_interv    => l_c_inst_interv_drug,
                                    o_error          => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION RESULT NOTES CONFIGURATION ';
        IF NOT set_inst_result_notes(i_lang,
                                     i_market,
                                     i_version,
                                     i_id_institution,
                                     i_software,
                                     l_c_result_notes_is,
                                     o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET INSTITUTION OCCUPATION CONFIGURATION ';
        IF NOT set_def_occupation(i_lang, i_market, i_version, l_c_occupation, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET SET_INST_EXAM_BODY_STRUCTURE';
        IF NOT set_inst_exam_body_structure(i_lang, i_market, i_version, l_c_exam_body_structure, o_error)
        THEN
            RAISE l_exception;
        END IF;
        g_error := 'SET SET_INST_EXAM_BODY_STRUCTURE';
        IF NOT set_dash_da_mkt_search(i_lang, i_id_institution, i_market, i_version, i_software, l_result, o_error)
        THEN
            RAISE l_exception;
        END IF;
        g_error := 'SET SET_INST_EXAM_BODY_STRUCTURE';
        IF NOT set_dash_da_inst_search(i_lang, i_id_institution, i_market, i_version, i_software, l_result, o_error)
        THEN
            RAISE l_exception;
        END IF;
        /*v2.6.3.5: ALERT-188051*/
        g_error := 'SET INSTITUTION TASK_GOAL CONFIGURATION';
        IF NOT set_taskgoaltask_search(i_lang, i_id_institution, i_market, i_version, i_software, l_result, o_error)
        THEN
            RAISE l_exception;
        END IF;
        g_error := 'SET INSTITUTION INTERV_PLAN CCONFIGURATION';
        IF NOT set_intervplan_search(i_lang, i_id_institution, i_market, i_version, i_software, l_result, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'SET INSTITUTION HABIT CHAR RELATION';
                IF NOT
                    set_inst_habit_char_rel(i_lang, i_market(j), i_version(i), l_c_hc_habit_char, l_c_hc_habit, o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                /*v2.6.1.5: ALERT-203542*/
                g_error := 'SET INSTITUTION SUPPLY';
                IF NOT set_supply_soft_inst(i_lang,
                                            i_market(j),
                                            i_version(i),
                                            i_id_institution,
                                            i_software,
                                            l_c_supply,
                                            o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET SUPPLY_RELATION';
                IF NOT set_supply_relation(i_lang, i_market(j), i_version(i), l_c_supply_rel, o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET INSTITUTION SUPPLY AREA';
                IF NOT set_supply_sup_area(i_lang,
                                           i_market(j),
                                           i_version(i),
                                           i_id_institution,
                                           i_software,
                                           l_c_supply_sa,
                                           o_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET INSTITUTION LOCATION DEFAULT';
                IF NOT set_supply_loc_default(i_lang,
                                              i_market(j),
                                              i_version(i),
                                              i_id_institution,
                                              i_software,
                                              l_c_supply_loc,
                                              o_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET INSTITUTION SUPPLY CONTEXT';
                IF NOT set_supply_context(i_lang,
                                          i_market(j),
                                          i_version(i),
                                          i_id_institution,
                                          i_software,
                                          l_c_supply_ctx,
                                          o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET INSTITUTION SUPPLY rEASON';
                IF NOT set_supply_reason(i_lang, i_market(j), i_version(i), l_c_supply_reason, o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END LOOP;
        
        END LOOP;
    
        /*v2.6.3.7.1 ALERT-264073*/
        g_error := 'SET SEARCHEABLE PO PARAM HEALTH PROGRAMS';
        IF NOT pk_periodicobservation_prm.set_pop_hpg_search(i_lang,
                                                             i_id_institution,
                                                             i_market,
                                                             i_version,
                                                             i_software,
                                                             l_result,
                                                             o_error)
        THEN
            RAISE l_exception;
        END IF;
        g_error := 'SET SEARCHEABLE PO PARAM UNIT MEASURES';
        IF NOT pk_periodicobservation_prm.set_pop_um_search(i_lang,
                                                            i_id_institution,
                                                            i_market,
                                                            i_version,
                                                            i_software,
                                                            l_result,
                                                            o_error)
        THEN
            RAISE l_exception;
        END IF;
        g_error := 'SET SEARCHEABLE PO PARAM RANKS';
        IF NOT pk_periodicobservation_prm.set_pop_rk_search(i_lang,
                                                            i_id_institution,
                                                            i_market,
                                                            i_version,
                                                            i_software,
                                                            l_result,
                                                            o_error)
        THEN
            RAISE l_exception;
        END IF;
        g_error := 'SET SEARCHEABLE PO PARAM WH';
        IF NOT pk_periodicobservation_prm.set_poparamwh_search(i_lang,
                                                               i_id_institution,
                                                               i_market,
                                                               i_version,
                                                               i_software,
                                                               NULL,
                                                               l_result,
                                                               o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'SET BODY STRUCTURE RELATION + SYS_CONFIG';
        IF NOT pk_exam_utils.create_body_struct_rel(i_lang               => i_lang,
                                                    i_prof               => profissional(0, i_id_institution, 0),
                                                    i_mcs_concept        => NULL,
                                                    i_mcs_concept_parent => NULL,
                                                    o_error              => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'REMOVE ORDERS WITHOUT TASKS';
        orders_double_check(i_lang, i_id_institution, o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DEFAULT_PARAM',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DEFAULT_PARAM',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_default_param;
    /********************************************************************************************
    * Get Health Plans for a set of markets and versions
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_health_plans        Cursor of Health Plans
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/19
    ********************************************************************************************/
    FUNCTION get_inst_health_plans
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_health_plans   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_content  VARCHAR2(200);
        l_health_plan health_plan.id_health_plan%TYPE := NULL;
    
        l_health_plan_array table_number := table_number();
        l_count             NUMBER := 0;
        l_index             NUMBER := 1;
    
        CURSOR c_hp_id_content
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT hp.id_content
              FROM alert_default.health_plan hp, alert_default.health_plan_mrk_vrs hpmv
             WHERE hpmv.id_market = c_market
               AND hpmv.version = c_version
               AND hpmv.id_health_plan = hp.id_health_plan
               AND hp.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                OPEN c_hp_id_content(i_version(i), i_market(j));
                LOOP
                    FETCH c_hp_id_content
                        INTO l_id_content;
                    EXIT WHEN c_hp_id_content%NOTFOUND;
                
                    --HEALTH_PLAN
                    SELECT nvl((SELECT hp.id_health_plan
                                 FROM health_plan hp
                                WHERE hp.id_content = l_id_content
                                  AND hp.id_content IS NOT NULL
                                  AND hp.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_health_plan
                      FROM dual;
                
                    IF l_health_plan != 0
                    THEN
                    
                        SELECT COUNT(hpi.id_health_plan_instit)
                          INTO l_count
                          FROM health_plan_instit hpi
                         WHERE hpi.id_institution = i_id_institution
                           AND hpi.id_health_plan = l_health_plan;
                    
                        IF l_count = 0
                        THEN
                        
                            l_health_plan_array.extend;
                        
                            l_health_plan_array(l_index) := l_health_plan;
                        
                            l_index := l_index + 1;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                CLOSE c_hp_id_content;
            
            END LOOP;
        
        END LOOP;
    
        OPEN o_health_plans FOR
            SELECT column_value
              FROM TABLE(CAST(l_health_plan_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_HEALTH_PLANS',
                                              o_error);
            pk_types.open_my_cursor(o_health_plans);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_health_plans;

    /********************************************************************************************
    * Set Health Plans for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_inst_health_plans   Cursor of Instituition Health Plans
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/19
    ********************************************************************************************/
    FUNCTION set_inst_health_plans
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        o_inst_health_plans OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data table_number;
    
        l_c_health_plans pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        IF NOT get_inst_health_plans(i_lang, i_market, i_version, i_id_institution, l_c_health_plans, l_error)
        THEN
            RAISE l_exception;
        ELSE
        
            o_inst_health_plans := l_c_health_plans;
        
            --HEALTH_PLAN_INST
            LOOP
                FETCH l_c_health_plans BULK COLLECT
                    INTO l_data LIMIT g_array_size;
            
                FORALL i IN 1 .. l_data.count
                    INSERT INTO health_plan_instit
                        (id_health_plan_instit, id_institution, id_health_plan)
                    VALUES
                        (seq_health_plan_instit.nextval, i_id_institution, l_data(i));
            
                EXIT WHEN l_c_health_plans%NOTFOUND;
            
            END LOOP;
        
            CLOSE l_c_health_plans;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HEALTH_PLANS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HEALTH_PLANS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_health_plans;

    /********************************************************************************************
    * Get Unit Measures for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_unit_measures       Cursor of Unit measures
    * @param o_unit_measures       Cursor of Unit measures prescription flags
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/26
    ********************************************************************************************/
    FUNCTION get_inst_unit_measures
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_unit_measures  OUT pk_types.cursor_type,
        o_umsi_flg_presc OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --UNIT_MEASURE
        l_id_unit_measure_def unit_measure.id_unit_measure%TYPE;
    
        --UNIT_MEA_SOFT_INST
        l_umsi_flg_prescription unit_mea_soft_inst.flg_prescription%TYPE;
    
        l_unit_measures_array  table_number := table_number();
        l_umsi_flg_presc_array table_varchar := table_varchar();
        l_count                NUMBER := 0;
        l_index                NUMBER := 1;
    
        CURSOR c_unit_soft
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT umsi.id_unit_measure, umsi.flg_prescription
              FROM alert_default.unit_mea_soft_inst umsi
             WHERE umsi.id_market = c_market
               AND umsi.version = c_version
               AND umsi.id_software = c_id_software
               AND umsi.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_UNIT_SOFT CURSOR';
                OPEN c_unit_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_unit_soft
                        INTO l_id_unit_measure_def, l_umsi_flg_prescription;
                    EXIT WHEN c_unit_soft%NOTFOUND;
                
                    --UNIT_MEA_SOFT_INST
                    SELECT COUNT(umsi.id_unit_mea_soft_inst)
                      INTO l_count
                      FROM unit_mea_soft_inst umsi
                     WHERE umsi.id_unit_measure = l_id_unit_measure_def
                       AND umsi.id_institution = i_id_institution
                       AND umsi.id_software = i_id_software;
                
                    IF l_count = 0
                    THEN
                    
                        l_unit_measures_array.extend;
                        l_umsi_flg_presc_array.extend;
                    
                        l_unit_measures_array(l_index) := l_id_unit_measure_def;
                        l_umsi_flg_presc_array(l_index) := l_umsi_flg_prescription;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_UNIT_SOFT CURSOR';
                CLOSE c_unit_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_UNIT_MEASURES CURSOR';
        OPEN o_unit_measures FOR
            SELECT column_value
              FROM TABLE(CAST(l_unit_measures_array AS table_number));
    
        g_error := 'CLOSE O_UMSI_FLG_PRESC CURSOR';
        OPEN o_umsi_flg_presc FOR
            SELECT column_value
              FROM TABLE(CAST(l_umsi_flg_presc_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_UNIT_MEASURES',
                                              o_error);
            pk_types.open_my_cursor(o_unit_measures);
            pk_types.open_my_cursor(o_umsi_flg_presc);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_unit_measures;

    /********************************************************************************************
    * Set Unir Measures for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_unit_measures  Cursor of Instituition Unit_MEasures
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/19
    ********************************************************************************************/
    FUNCTION set_inst_unit_measures
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_software           IN table_number,
        o_inst_unit_measures OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_unit_measure table_number;
        l_data_flg_presc    table_varchar;
    
        l_c_unit_measures  pk_types.cursor_type;
        l_c_umsi_flg_presc pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            IF NOT get_inst_unit_measures(i_lang,
                                          i_market,
                                          i_version,
                                          i_id_institution,
                                          i_software(i),
                                          l_c_unit_measures,
                                          l_c_umsi_flg_presc,
                                          l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_unit_measures := l_c_unit_measures;
            
                LOOP
                    FETCH l_c_unit_measures BULK COLLECT
                        INTO l_data_unit_measure LIMIT g_array_size;
                
                    FETCH l_c_umsi_flg_presc BULK COLLECT
                        INTO l_data_flg_presc LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_unit_measure.count
                        INSERT INTO unit_mea_soft_inst
                            (id_unit_mea_soft_inst,
                             id_unit_measure,
                             id_institution,
                             id_software,
                             flg_available,
                             adw_last_update,
                             flg_prescription)
                        VALUES
                            (seq_unit_mea_soft_inst.nextval,
                             l_data_unit_measure(j),
                             i_id_institution,
                             i_software(i),
                             g_flg_available,
                             SYSDATE,
                             l_data_flg_presc(j));
                
                    EXIT WHEN l_c_unit_measures%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_unit_measures;
            
                CLOSE l_c_umsi_flg_presc;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_UNIT_MEASURES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_UNIT_MEASURES',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_unit_measures;

    /********************************************************************************************
    * Get Analysis loinc codes for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_analysis            Cursor of analysis
    * @param o_al_loinc            Cursor of loinc codes
    * @param o_al_flg_default      Cursor of analysis loinc codes default flags
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.2
    * @since                       2012/12/18
    ********************************************************************************************/
    FUNCTION get_inst_analysis_loinc
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_analysis       OUT pk_types.cursor_type,
        o_al_loinc       OUT pk_types.cursor_type,
        o_al_flg_default OUT pk_types.cursor_type,
        o_al_sptype      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_analysis_array       table_number := table_number();
        l_al_loinc_array       table_varchar := table_varchar();
        l_al_flg_default_array table_varchar := table_varchar();
        l_sptype_array         table_number := table_number();
    
    BEGIN
    
        SELECT def_data.id_analysis, def_data.id_sample_type, def_data.loinc_code, def_data.flg_default
          BULK COLLECT
          INTO l_analysis_array, l_sptype_array, l_al_loinc_array, l_al_flg_default_array
          FROM (SELECT temp_data.id_analysis,
                       temp_data.id_sample_type,
                       temp_data.flg_default,
                       temp_data.loinc_code,
                       row_number() over(PARTITION BY temp_data.id_analysis, temp_data.id_sample_type, temp_data.flg_default, temp_data.loinc_code ORDER BY temp_data.l_row) records_count
                  FROM (SELECT nvl((SELECT a.id_analysis
                                     FROM analysis a
                                    WHERE a.id_content = (SELECT a2.id_content
                                                            FROM alert_default.analysis a2
                                                           WHERE a2.id_analysis = def_al.id_analysis)
                                      AND a.id_content IS NOT NULL
                                      AND a.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_analysis,
                               nvl((SELECT sp.id_sample_type
                                     FROM sample_type sp
                                    WHERE sp.id_content =
                                          (SELECT sp2.id_content
                                             FROM alert_default.sample_type sp2
                                            WHERE sp2.id_sample_type = def_al.id_sample_type)
                                      AND sp.id_content IS NOT NULL
                                      AND sp.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_sample_type,
                               def_al.loinc_code,
                               def_al.flg_default,
                               def_al.rowid l_row
                          FROM alert_default.analysis_loinc def_al
                         WHERE def_al.id_software = i_id_software
                           AND EXISTS (SELECT 0
                                  FROM alert_default.analysis_sample_type def_ast
                                 INNER JOIN alert_default.ast_mkt_vrs astmv
                                    ON (astmv.id_content = def_ast.id_content)
                                 WHERE def_ast.id_analysis = def_al.id_analysis
                                   AND def_ast.id_sample_type = def_al.id_sample_type
                                   AND astmv.id_market IN
                                       (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                         column_value
                                          FROM TABLE(CAST(i_market AS table_number)) p)
                                   AND astmv.version IN
                                       (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                         column_value
                                          FROM TABLE(CAST(i_version AS table_varchar)) p))
                           AND rownum > 0) temp_data
                 WHERE temp_data.id_analysis != 0
                   AND temp_data.id_sample_type != 0) def_data
         WHERE def_data.records_count = 1
           AND NOT EXISTS (SELECT 0
                  FROM analysis_loinc al
                 WHERE al.id_analysis = def_data.id_analysis
                   AND al.loinc_code = def_data.loinc_code
                   AND al.id_institution = i_id_institution
                   AND al.id_software = i_id_software
                   AND al.id_sample_type = def_data.id_sample_type
                   AND al.flg_default = def_data.flg_default)
           AND EXISTS (SELECT 0
                  FROM analysis_sample_type ast
                 WHERE ast.id_analysis = def_data.id_analysis
                   AND ast.id_sample_type = def_data.id_sample_type);
    
        g_error := 'CLOSE O_UNIT_MEASURES CURSOR';
        OPEN o_analysis FOR
            SELECT column_value
              FROM TABLE(CAST(l_analysis_array AS table_number));
    
        g_error := 'CLOSE O_UMSI_FLG_PRESC CURSOR';
        OPEN o_al_loinc FOR
            SELECT column_value
              FROM TABLE(CAST(l_al_loinc_array AS table_varchar));
    
        g_error := 'CLOSE O_UMSI_FLG_PRESC CURSOR';
        OPEN o_al_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_al_flg_default_array AS table_varchar));
    
        g_error := 'CLOSE o_al_sptype CURSOR';
        OPEN o_al_sptype FOR
            SELECT column_value
              FROM TABLE(CAST(l_sptype_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ANALYSIS_LOINC',
                                              o_error);
            pk_types.open_my_cursor(o_analysis);
            pk_types.open_my_cursor(o_al_loinc);
            pk_types.open_my_cursor(o_al_flg_default);
            pk_types.open_my_cursor(o_al_sptype);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_analysis_loinc;

    /********************************************************************************************
    * Get Analysis set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_analysis            Cursor of analysis
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.2
    * @since                       2012/12/18
    ********************************************************************************************/
    FUNCTION get_inst_analysis
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_id_institution        IN institution.id_institution%TYPE,
        i_id_software           IN software.id_software%TYPE,
        o_analysis              OUT pk_types.cursor_type,
        o_ais_flg_type          OUT pk_types.cursor_type,
        o_ais_flg_mov_pat       OUT pk_types.cursor_type,
        o_ais_flg_first_result  OUT pk_types.cursor_type,
        o_ais_flg_mov_recipient OUT pk_types.cursor_type,
        o_ais_flg_harvest       OUT pk_types.cursor_type,
        o_ais_flg_fill_type     OUT pk_types.cursor_type,
        o_exam_cat              OUT pk_types.cursor_type,
        o_ais_sample_type       OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_analysis_array              table_number := table_number();
        l_ais_flg_type_array          table_varchar := table_varchar();
        l_ais_flg_mov_pat_array       table_varchar := table_varchar();
        l_ais_flg_first_result_array  table_varchar := table_varchar();
        l_ais_flg_mov_recipient_array table_varchar := table_varchar();
        l_ais_flg_harvest_array       table_varchar := table_varchar();
        l_ais_flg_fill_type_array     table_varchar := table_varchar();
        l_id_exam_cat_array           table_number := table_number();
        l_id_sptype_array             table_number := table_number();
    
        l_count NUMBER := 0;
    
    BEGIN
        SELECT def_data.id_analysis,
               def_data.id_exam_cat,
               def_data.id_sample_type,
               def_data.flg_type,
               def_data.flg_mov_pat,
               def_data.flg_first_result,
               def_data.flg_mov_recipient,
               def_data.flg_harvest
          BULK COLLECT
          INTO l_analysis_array,
               l_id_exam_cat_array,
               l_id_sptype_array,
               l_ais_flg_type_array,
               l_ais_flg_mov_pat_array,
               l_ais_flg_first_result_array,
               l_ais_flg_mov_recipient_array,
               l_ais_flg_harvest_array
        
          FROM (SELECT temp_data.id_analysis,
                       temp_data.id_exam_cat,
                       temp_data.id_sample_type,
                       temp_data.flg_type,
                       temp_data.flg_mov_pat,
                       temp_data.flg_first_result,
                       temp_data.flg_mov_recipient,
                       temp_data.flg_harvest,
                       row_number() over(PARTITION BY temp_data.id_analysis, temp_data.id_sample_type ORDER BY temp_data.l_row) records_count
                  FROM (SELECT nvl((SELECT a.id_analysis
                                     FROM analysis a
                                    WHERE a.id_content = (SELECT a2.id_content
                                                            FROM alert_default.analysis a2
                                                           WHERE a2.id_analysis = def_ais.id_analysis)
                                      AND a.id_content IS NOT NULL
                                      AND a.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_analysis,
                               nvl((SELECT ec.id_exam_cat
                                     FROM exam_cat ec
                                    WHERE ec.id_content = (SELECT ec2.id_content
                                                             FROM alert_default.exam_cat ec2
                                                            WHERE ec2.id_exam_cat = def_ais.id_exam_cat)
                                      AND ec.id_content IS NOT NULL
                                      AND ec.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_exam_cat,
                               nvl((SELECT sp.id_sample_type
                                     FROM sample_type sp
                                    WHERE sp.id_content =
                                          (SELECT sp2.id_content
                                             FROM alert_default.sample_type sp2
                                            WHERE sp2.id_sample_type = def_ais.id_sample_type)
                                      AND sp.id_content IS NOT NULL
                                      AND sp.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_sample_type,
                               flg_type,
                               def_ais.flg_mov_pat,
                               def_ais.flg_first_result,
                               def_ais.flg_mov_recipient,
                               def_ais.flg_harvest,
                               def_ais.rowid l_row
                          FROM alert_default.analysis_instit_soft def_ais
                         WHERE def_ais.id_software = i_id_software
                           AND def_ais.flg_available = g_flg_available
                           AND EXISTS (SELECT 0
                                  FROM alert_default.analysis_sample_type def_ast
                                 INNER JOIN alert_default.ast_mkt_vrs astmv
                                    ON (astmv.id_content = def_ast.id_content)
                                 WHERE def_ast.id_analysis = def_ais.id_analysis
                                   AND def_ast.id_sample_type = def_ais.id_sample_type
                                   AND astmv.id_market IN
                                       (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                         column_value
                                          FROM TABLE(CAST(i_market AS table_number)) p)
                                   AND astmv.version IN
                                       (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                         column_value
                                          FROM TABLE(CAST(i_version AS table_varchar)) p))
                           AND rownum > 0) temp_data
                 WHERE temp_data.id_analysis != 0
                   AND temp_data.id_exam_cat != 0
                   AND temp_data.id_sample_type != 0) def_data
         WHERE def_data.records_count = 1
           AND NOT EXISTS (SELECT 0
                  FROM analysis_instit_soft ais
                 WHERE ais.id_analysis = def_data.id_analysis
                   AND ais.id_institution = i_id_institution
                   AND ais.id_software = i_id_software
                   AND ais.id_sample_type = def_data.id_sample_type)
           AND EXISTS (SELECT 0
                  FROM analysis_sample_type ast
                 WHERE ast.id_analysis = def_data.id_analysis
                   AND ast.id_sample_type = def_data.id_sample_type);
    
        g_error := 'CLOSE O_ANALYSIS CURSOR';
        OPEN o_analysis FOR
            SELECT column_value
              FROM TABLE(CAST(l_analysis_array AS table_number));
    
        g_error := 'CLOSE O_AIS_FLG_TYPE CURSOR';
        OPEN o_ais_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_ais_flg_type_array AS table_varchar));
    
        g_error := 'CLOSE O_AIS_FLG_MOV CURSOR';
        OPEN o_ais_flg_mov_pat FOR
            SELECT column_value
              FROM TABLE(CAST(l_ais_flg_mov_pat_array AS table_varchar));
    
        g_error := 'CLOSE O_AIS_FLG_FIRST_RESULT CURSOR';
        OPEN o_ais_flg_first_result FOR
            SELECT column_value
              FROM TABLE(CAST(l_ais_flg_first_result_array AS table_varchar));
    
        g_error := 'CLOSE O_AIS_FLG_MOV_RECIPIENT CURSOR';
        OPEN o_ais_flg_mov_recipient FOR
            SELECT column_value
              FROM TABLE(CAST(l_ais_flg_mov_recipient_array AS table_varchar));
    
        g_error := 'CLOSE O_AIS_FLG_HARVEST CURSOR';
        OPEN o_ais_flg_harvest FOR
            SELECT column_value
              FROM TABLE(CAST(l_ais_flg_harvest_array AS table_varchar));
    
        g_error := 'CLOSE O_AIS_FLG_FILL_TYPE CURSOR';
        OPEN o_ais_flg_fill_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_ais_flg_fill_type_array AS table_varchar));
    
        g_error := 'CLOSE O_EXAM_CAT CURSOR';
        OPEN o_exam_cat FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_exam_cat_array AS table_number));
    
        g_error := 'CLOSE O_EXAM_CAT CURSOR';
        OPEN o_ais_sample_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_sptype_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ANALYSIS_LOINC',
                                              o_error);
            pk_types.open_my_cursor(o_analysis);
            pk_types.open_my_cursor(o_ais_flg_type);
            pk_types.open_my_cursor(o_ais_flg_mov_pat);
            pk_types.open_my_cursor(o_ais_flg_first_result);
            pk_types.open_my_cursor(o_ais_flg_mov_recipient);
            pk_types.open_my_cursor(o_ais_flg_harvest);
            pk_types.open_my_cursor(o_ais_flg_fill_type);
            pk_types.open_my_cursor(o_exam_cat);
            pk_types.open_my_cursor(o_ais_sample_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_analysis;

    /********************************************************************************************
    * Get Analysis Recipients for a set of markets, versions and softwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_analysis_instit_soft  Cursor of analysis
    * @param o_air_sample_recipient  Cursor of sample_recipients
    * @param o_air_flg_default       Cursor of analysis recipients default flags
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/27
    ********************************************************************************************/
    FUNCTION get_inst_analysis_recipients
    (
        i_lang                 IN language.id_language%TYPE,
        i_market               IN table_number,
        i_version              IN table_varchar,
        i_id_institution       IN institution.id_institution%TYPE,
        i_id_software          IN software.id_software%TYPE,
        o_analysis_instit_soft OUT pk_types.cursor_type,
        o_air_sample_recipient OUT pk_types.cursor_type,
        o_air_flg_default      OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_ais_array                  table_number := table_number();
        l_air_sample_recipient_array table_number := table_number();
        l_air_flg_default_array      table_varchar := table_varchar();
    
    BEGIN
        SELECT def_data.id_analysis_instit_soft, def_data.id_sample_recipient, def_data.flg_default
          BULK COLLECT
          INTO l_ais_array, l_air_sample_recipient_array, l_air_flg_default_array
          FROM (SELECT temp_data.id_analysis_instit_soft,
                       temp_data.id_sample_recipient,
                       temp_data.flg_default,
                       row_number() over(PARTITION BY temp_data.id_analysis_instit_soft, temp_data.id_sample_recipient ORDER BY temp_data.l_row) records_count
                  FROM (SELECT norm_data.id_analysis,
                               nvl((SELECT ais1.id_analysis_instit_soft
                                     FROM analysis_instit_soft ais1
                                    WHERE ais1.id_analysis = norm_data.id_analysis
                                      AND ais1.id_sample_type = norm_data.id_sample_type
                                      AND ais1.id_software = i_id_software
                                      AND ais1.id_institution = i_id_institution
                                      AND ais1.flg_available = g_flg_available),
                                   0) id_analysis_instit_soft,
                               norm_data.id_sample_type,
                               norm_data.id_sample_recipient,
                               norm_data.flg_default,
                               norm_data.l_row
                          FROM (SELECT nvl((SELECT a.id_analysis
                                             FROM analysis a
                                            WHERE a.id_content =
                                                  (SELECT a2.id_content
                                                     FROM alert_default.analysis a2
                                                    WHERE a2.id_analysis = def_ais.id_analysis)
                                              AND a.id_content IS NOT NULL
                                              AND a.flg_available = g_flg_available
                                              AND rownum = 1),
                                           0) id_analysis,
                                       nvl((SELECT sp.id_sample_type
                                             FROM sample_type sp
                                            WHERE sp.id_content =
                                                  (SELECT sp2.id_content
                                                     FROM alert_default.sample_type sp2
                                                    WHERE sp2.id_sample_type = def_ais.id_sample_type)
                                              AND sp.id_content IS NOT NULL
                                              AND sp.flg_available = g_flg_available
                                              AND rownum = 1),
                                           0) id_sample_type,
                                       
                                       nvl((SELECT sr.id_sample_recipient
                                             FROM sample_recipient sr
                                            INNER JOIN alert_default.sample_recipient def_sr
                                               ON (def_sr.id_content = sr.id_content AND
                                                  def_sr.flg_available = g_flg_available)
                                            WHERE sr.flg_available = g_flg_available
                                              AND def_sr.id_sample_recipient = def_air.id_sample_recipient),
                                           0) id_sample_recipient,
                                       def_air.flg_default,
                                       def_air.rowid l_row
                                  FROM alert_default.analysis_instit_soft def_ais
                                 INNER JOIN alert_default.analysis_instit_recipient def_air
                                    ON (def_air.id_analysis_instit_soft = def_ais.id_analysis_instit_soft)
                                 WHERE def_ais.id_software = i_id_software
                                   AND def_ais.flg_available = g_flg_available
                                   AND EXISTS (SELECT 0
                                          FROM alert_default.analysis_sample_type def_ast
                                         INNER JOIN alert_default.ast_mkt_vrs astmv
                                            ON (astmv.id_content = def_ast.id_content)
                                         WHERE def_ast.id_analysis = def_ais.id_analysis
                                           AND def_ast.id_sample_type = def_ais.id_sample_type
                                           AND astmv.id_market IN
                                               (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                 column_value
                                                  FROM TABLE(CAST(i_market AS table_number)) p)
                                           AND astmv.version IN
                                               (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                 column_value
                                                  FROM TABLE(CAST(i_version AS table_varchar)) p))
                                   AND rownum > 0) norm_data
                         WHERE norm_data.id_analysis != 0
                           AND norm_data.id_sample_type != 0
                           AND norm_data.id_sample_recipient != 0) temp_data
                 WHERE temp_data.id_analysis_instit_soft != 0) def_data
         WHERE def_data.records_count = 1
           AND NOT EXISTS (SELECT 0
                  FROM analysis_instit_recipient air
                 WHERE air.id_analysis_instit_soft = def_data.id_analysis_instit_soft
                   AND air.id_sample_recipient = def_data.id_sample_recipient
                   AND air.flg_default = def_data.flg_default);
    
        g_error := 'CLOSE O_ANALYSIS_INSTIT_SOFT CURSOR';
        OPEN o_analysis_instit_soft FOR
            SELECT column_value
              FROM TABLE(CAST(l_ais_array AS table_number));
    
        g_error := 'CLOSE O_AIR_SAMPLE_RECIPIENT CURSOR';
        OPEN o_air_sample_recipient FOR
            SELECT column_value
              FROM TABLE(CAST(l_air_sample_recipient_array AS table_number));
    
        g_error := 'CLOSE O_AIR_FLG_DEFAULT CURSOR';
        OPEN o_air_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_air_flg_default_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ANALYSIS_RECIPIENTS',
                                              o_error);
            pk_types.open_my_cursor(o_analysis_instit_soft);
            pk_types.open_my_cursor(o_air_sample_recipient);
            pk_types.open_my_cursor(o_air_flg_default);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_analysis_recipients;

    /********************************************************************************************
    * Get Analysis Parameters for a set of markets, versions and softwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_ap_analysis           Cursor of analysis
    * @param o_ap_parameter          Cursor of analysis parameters
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/27
    ********************************************************************************************/
    FUNCTION get_inst_analysis_param
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_ap_analysis    OUT pk_types.cursor_type,
        o_ap_parameter   OUT pk_types.cursor_type,
        o_ap_rank        OUT pk_types.cursor_type,
        o_ap_colors      OUT pk_types.cursor_type,
        o_ap_fill        OUT pk_types.cursor_type,
        o_ap_sptype      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_ap_analysis_array    table_number := table_number();
        l_ap_parameter_array   table_number := table_number();
        l_ap_color_array       table_varchar := table_varchar();
        l_ap_fill_type_array   table_varchar := table_varchar();
        l_ap_rank_array        table_number := table_number();
        l_ap_sample_type_array table_number := table_number();
    
    BEGIN
    
        SELECT def_data.id_analysis,
               def_data.id_sample_type,
               def_data.id_analysis_parameter,
               def_data.color_graph,
               def_data.flg_fill_type,
               def_data.rank
          BULK COLLECT
          INTO l_ap_analysis_array,
               l_ap_sample_type_array,
               l_ap_parameter_array,
               l_ap_color_array,
               l_ap_fill_type_array,
               l_ap_rank_array
          FROM (SELECT temp_data.id_analysis,
                       temp_data.id_sample_type,
                       temp_data.id_analysis_parameter,
                       temp_data.color_graph,
                       temp_data.flg_fill_type,
                       temp_data.rank,
                       row_number() over(PARTITION BY temp_data.id_analysis, temp_data.id_sample_type, temp_data.id_analysis_parameter ORDER BY temp_data.l_row) records_count
                  FROM (SELECT nvl((SELECT a.id_analysis
                                     FROM analysis a
                                    WHERE a.id_content = (SELECT a2.id_content
                                                            FROM alert_default.analysis a2
                                                           WHERE a2.id_analysis = def_ap.id_analysis)
                                      AND a.id_content IS NOT NULL
                                      AND a.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_analysis,
                               nvl((SELECT sp.id_sample_type
                                     FROM sample_type sp
                                    WHERE sp.id_content =
                                          (SELECT sp2.id_content
                                             FROM alert_default.sample_type sp2
                                            WHERE sp2.id_sample_type = def_ap.id_sample_type)
                                      AND sp.id_content IS NOT NULL
                                      AND sp.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_sample_type,
                               nvl((SELECT ap.id_analysis_parameter
                                     FROM analysis_parameter ap
                                    INNER JOIN alert_default.analysis_parameter def_apar
                                       ON (def_apar.id_content = ap.id_content AND
                                          def_apar.flg_available = g_flg_available)
                                    WHERE ap.flg_available = g_flg_available
                                      AND def_apar.id_analysis_parameter = def_ap.id_analysis_parameter),
                                   0) id_analysis_parameter,
                               def_ap.color_graph,
                               def_ap.flg_fill_type,
                               def_ap.rank,
                               def_ap.rowid l_row
                          FROM alert_default.analysis_param def_ap
                         WHERE def_ap.id_software = i_id_software
                           AND def_ap.flg_available = g_flg_available
                           AND EXISTS (SELECT 0
                                  FROM alert_default.analysis_sample_type def_ast
                                 INNER JOIN alert_default.ast_mkt_vrs astmv
                                    ON (astmv.id_content = def_ast.id_content)
                                 WHERE def_ast.id_analysis = def_ap.id_analysis
                                   AND def_ast.id_sample_type = def_ap.id_sample_type
                                   AND astmv.id_market IN
                                       (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                         column_value
                                          FROM TABLE(CAST(i_market AS table_number)) p)
                                   AND astmv.version IN
                                       (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                         column_value
                                          FROM TABLE(CAST(i_version AS table_varchar)) p))
                           AND rownum > 0) temp_data
                 WHERE temp_data.id_analysis != 0
                   AND temp_data.id_sample_type != 0
                   AND temp_data.id_analysis_parameter != 0) def_data
         WHERE def_data.records_count = 1
           AND NOT EXISTS (SELECT 0
                  FROM analysis_param apr
                 WHERE apr.id_analysis = def_data.id_analysis
                   AND apr.id_analysis_parameter = def_data.id_analysis_parameter
                   AND apr.id_institution = i_id_institution
                   AND apr.id_software = i_id_software
                   AND apr.id_sample_type = def_data.id_sample_type)
           AND EXISTS (SELECT 0
                  FROM analysis_sample_type ast
                 WHERE ast.id_analysis = def_data.id_analysis
                   AND ast.id_sample_type = def_data.id_sample_type);
    
        g_error := 'CLOSE O_AP_ANALYSIS CURSOR';
        OPEN o_ap_analysis FOR
            SELECT column_value
              FROM TABLE(CAST(l_ap_analysis_array AS table_number));
    
        g_error := 'CLOSE O_AP_PARAMETER CURSOR';
        OPEN o_ap_parameter FOR
            SELECT column_value
              FROM TABLE(CAST(l_ap_parameter_array AS table_number));
    
        g_error := 'CLOSE O_AP_COLOR CURSOR';
        OPEN o_ap_colors FOR
            SELECT column_value
              FROM TABLE(CAST(l_ap_color_array AS table_varchar));
    
        g_error := 'CLOSE O_AP_FILL_TYPE CURSOR';
        OPEN o_ap_fill FOR
            SELECT column_value
              FROM TABLE(CAST(l_ap_fill_type_array AS table_varchar));
    
        g_error := 'CLOSE O_AP_RANK CURSOR';
        OPEN o_ap_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_ap_rank_array AS table_number));
        g_error := 'CLOSE O_AP_SPTYPE CURSOR';
        OPEN o_ap_sptype FOR
            SELECT column_value
              FROM TABLE(CAST(l_ap_sample_type_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ANALYSIS_PARAM',
                                              o_error);
            pk_types.open_my_cursor(o_ap_analysis);
            pk_types.open_my_cursor(o_ap_parameter);
            pk_types.open_my_cursor(o_ap_fill);
            pk_types.open_my_cursor(o_ap_colors);
            pk_types.open_my_cursor(o_ap_rank);
            pk_types.open_my_cursor(o_ap_sptype);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_analysis_param;

    /********************************************************************************************
    * Get Analysis Parameters Functionalities for a set of markets, versions and softwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_apf_analysis_param    Cursor of analysis param
    * @param o_apf_flg_type          Cursor of analysis param types
    * @param o_apf_fill_type         Cursor of analysis param fill types
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/27
    ********************************************************************************************/
    FUNCTION get_inst_analysis_param_func
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_id_software        IN software.id_software%TYPE,
        o_apf_analysis_param OUT pk_types.cursor_type,
        o_apf_flg_type       OUT pk_types.cursor_type,
        o_apf_fill_type      OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_apf_analysis_param_array table_number := table_number();
        l_apf_flg_type_array       table_varchar := table_varchar();
        l_apf_fill_type_array      table_varchar := table_varchar();
    
    BEGIN
    
        SELECT def_data.id_analysis_param, def_data.flg_type, def_data.flg_fill_type
          BULK COLLECT
          INTO l_apf_analysis_param_array, l_apf_flg_type_array, l_apf_fill_type_array
          FROM (SELECT temp_data.id_analysis_param,
                       temp_data.flg_type,
                       temp_data.flg_fill_type,
                       row_number() over(PARTITION BY temp_data.id_analysis_param, temp_data.flg_type ORDER BY temp_data.l_row) records_count
                  FROM (SELECT norm_data.id_analysis,
                               nvl((SELECT ap1.id_analysis_param
                                     FROM analysis_param ap1
                                    WHERE ap1.id_analysis = norm_data.id_analysis
                                      AND ap1.id_sample_type = norm_data.id_sample_type
                                      AND ap1.id_analysis_parameter = norm_data.id_analysis_parameter
                                      AND ap1.id_software = i_id_software
                                      AND ap1.id_institution = i_id_institution
                                      AND ap1.flg_available = g_flg_available),
                                   0) id_analysis_param,
                               norm_data.flg_fill_type,
                               norm_data.flg_type,
                               norm_data.l_row
                          FROM (SELECT nvl((SELECT a.id_analysis
                                             FROM analysis a
                                            WHERE a.id_content =
                                                  (SELECT a2.id_content
                                                     FROM alert_default.analysis a2
                                                    WHERE a2.id_analysis = def_ap.id_analysis)
                                              AND a.id_content IS NOT NULL
                                              AND a.flg_available = g_flg_available
                                              AND rownum = 1),
                                           0) id_analysis,
                                       nvl((SELECT sp.id_sample_type
                                             FROM sample_type sp
                                            WHERE sp.id_content =
                                                  (SELECT sp2.id_content
                                                     FROM alert_default.sample_type sp2
                                                    WHERE sp2.id_sample_type = def_ap.id_sample_type)
                                              AND sp.id_content IS NOT NULL
                                              AND sp.flg_available = g_flg_available
                                              AND rownum = 1),
                                           0) id_sample_type,
                                       nvl((SELECT ap.id_analysis_parameter
                                             FROM analysis_parameter ap
                                            INNER JOIN alert_default.analysis_parameter def_apar
                                               ON (def_apar.id_content = ap.id_content AND
                                                  def_apar.flg_available = g_flg_available)
                                            WHERE ap.flg_available = g_flg_available
                                              AND def_apar.id_analysis_parameter = def_ap.id_analysis_parameter),
                                           0) id_analysis_parameter,
                                       def_apf.flg_type,
                                       def_apf.flg_fill_type,
                                       def_apf.rowid l_row
                                  FROM alert_default.analysis_param_funcionality def_apf
                                 INNER JOIN alert_default.analysis_param def_ap
                                    ON (def_ap.id_analysis_param = def_apf.id_analysis_param)
                                 WHERE def_ap.id_software = i_id_software
                                   AND def_ap.flg_available = g_flg_available
                                   AND EXISTS (SELECT 0
                                          FROM alert_default.analysis_sample_type def_ast
                                         INNER JOIN alert_default.ast_mkt_vrs astmv
                                            ON (astmv.id_content = def_ast.id_content)
                                         WHERE def_ast.id_analysis = def_ap.id_analysis
                                           AND def_ast.id_sample_type = def_ap.id_sample_type
                                           AND astmv.id_market IN
                                               (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                 column_value
                                                  FROM TABLE(CAST(i_market AS table_number)) p)
                                           AND astmv.version IN
                                               (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                 column_value
                                                  FROM TABLE(CAST(i_version AS table_varchar)) p))
                                   AND rownum > 0) norm_data
                         WHERE norm_data.id_analysis != 0
                           AND norm_data.id_sample_type != 0
                           AND norm_data.id_analysis_parameter != 0) temp_data
                 WHERE temp_data.id_analysis_param != 0) def_data
         WHERE def_data.records_count = 1
           AND NOT EXISTS (SELECT 0
                  FROM analysis_param_funcionality apf
                 WHERE apf.flg_type = def_data.flg_type
                   AND apf.id_analysis_param = def_data.id_analysis_param);
    
        g_error := 'CLOSE O_AP_ANALYSIS CURSOR';
        OPEN o_apf_analysis_param FOR
            SELECT column_value
              FROM TABLE(CAST(l_apf_analysis_param_array AS table_number));
    
        g_error := 'CLOSE O_AP_PARAMETER CURSOR';
        OPEN o_apf_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_apf_flg_type_array AS table_varchar));
    
        g_error := 'CLOSE O_AP_PARAMETER CURSOR';
        OPEN o_apf_fill_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_apf_fill_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ANALYSIS_PARAM_FUNC',
                                              o_error);
            pk_types.open_my_cursor(o_apf_analysis_param);
            pk_types.open_my_cursor(o_apf_flg_type);
            pk_types.open_my_cursor(o_apf_fill_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_analysis_param_func;

    /********************************************************************************************
    * Get Analysis Unit Measures for a set of markets, versions and softwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_aum_analysis          Cursor of analysis
    * @param o_aum_unit_measures     Cursor of analysis unit measures
    * @param o_aum_val_min           Cursor of analysis min values
    * @param o_aum_val_max           Cursor of analysis max values
    * @param o_aum_format_num        Cursor of analysis num format
    * @param o_aum_decimals          Cursor of analysis decimals
    * @param o_aum_flg_default       Cursor of analysis default flags
    * @param o_aum_analysis_param    Cursor of analysis parameters
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/27
    ********************************************************************************************/
    FUNCTION get_inst_analysis_unit_mea
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_id_software        IN software.id_software%TYPE,
        o_aum_analysis       OUT pk_types.cursor_type,
        o_aum_unit_measures  OUT pk_types.cursor_type,
        o_aum_val_min        OUT pk_types.cursor_type,
        o_aum_val_max        OUT pk_types.cursor_type,
        o_aum_format_num     OUT pk_types.cursor_type,
        o_aum_decimals       OUT pk_types.cursor_type,
        o_aum_flg_default    OUT pk_types.cursor_type,
        o_aum_analysis_param OUT pk_types.cursor_type,
        o_aum_sample_type    OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_analysis_array           table_number := table_number();
        l_aum_unit_measure_array   table_number := table_number();
        l_aum_val_min_array        table_number := table_number();
        l_aum_val_max_array        table_number := table_number();
        l_aum_format_num_array     table_varchar := table_varchar();
        l_aum_decimals_array       table_number := table_number();
        l_aum_flg_default_array    table_varchar := table_varchar();
        l_analysis_parameter_array table_number := table_number();
        l_sample_type_array        table_number := table_number();
    
    BEGIN
    
        SELECT def_data.id_analysis,
               def_data.id_sample_type,
               def_data.id_analysis_parameter,
               def_data.id_unit_measure,
               def_data.val_min,
               def_data.val_max,
               def_data.format_num,
               def_data.decimals,
               def_data.flg_default
          BULK COLLECT
          INTO l_analysis_array,
               l_sample_type_array,
               l_analysis_parameter_array,
               l_aum_unit_measure_array,
               l_aum_val_min_array,
               l_aum_val_max_array,
               l_aum_format_num_array,
               l_aum_decimals_array,
               l_aum_flg_default_array
          FROM (SELECT temp_data.id_analysis,
                       temp_data.id_sample_type,
                       temp_data.id_analysis_parameter,
                       temp_data.id_unit_measure,
                       temp_data.val_min,
                       temp_data.val_max,
                       temp_data.format_num,
                       temp_data.decimals,
                       temp_data.flg_default,
                       row_number() over(PARTITION BY temp_data.id_analysis, temp_data.id_sample_type, temp_data.id_analysis_parameter, temp_data.id_unit_measure ORDER BY temp_data.l_row) records_count
                  FROM (SELECT nvl((SELECT a.id_analysis
                                     FROM analysis a
                                    WHERE a.id_content = (SELECT a2.id_content
                                                            FROM alert_default.analysis a2
                                                           WHERE a2.id_analysis = def_aum.id_analysis)
                                      AND a.id_content IS NOT NULL
                                      AND a.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_analysis,
                               nvl((SELECT sp.id_sample_type
                                     FROM sample_type sp
                                    WHERE sp.id_content =
                                          (SELECT sp2.id_content
                                             FROM alert_default.sample_type sp2
                                            WHERE sp2.id_sample_type = def_aum.id_sample_type)
                                      AND sp.id_content IS NOT NULL
                                      AND sp.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_sample_type,
                               nvl((SELECT ap.id_analysis_parameter
                                     FROM analysis_parameter ap
                                    WHERE ap.id_content =
                                          (SELECT ap2.id_content
                                             FROM alert_default.analysis_parameter ap2
                                            WHERE ap2.id_analysis_parameter = def_aum.id_analysis_parameter)
                                      AND ap.id_content IS NOT NULL
                                      AND ap.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0) id_analysis_parameter,
                               def_aum.id_unit_measure,
                               def_aum.val_min,
                               def_aum.val_max,
                               def_aum.format_num,
                               def_aum.decimals,
                               def_aum.flg_default,
                               def_aum.rowid l_row
                          FROM alert_default.analysis_unit_measure def_aum
                         WHERE def_aum.id_software = i_id_software
                           AND EXISTS (SELECT 0
                                  FROM alert_default.analysis_sample_type def_ast
                                 INNER JOIN alert_default.ast_mkt_vrs astmv
                                    ON (astmv.id_content = def_ast.id_content)
                                 WHERE def_ast.id_analysis = def_aum.id_analysis
                                   AND def_ast.id_sample_type = def_aum.id_sample_type
                                   AND astmv.id_market IN
                                       (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                         column_value
                                          FROM TABLE(CAST(i_market AS table_number)) p)
                                   AND astmv.version IN
                                       (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                         column_value
                                          FROM TABLE(CAST(i_version AS table_varchar)) p))
                           AND rownum > 0) temp_data
                 WHERE temp_data.id_analysis != 0
                   AND temp_data.id_sample_type != 0
                   AND temp_data.id_analysis_parameter != 0) def_data
         WHERE def_data.records_count = 1
           AND NOT EXISTS (SELECT 0
                  FROM analysis_unit_measure aum
                 WHERE aum.id_analysis = def_data.id_analysis
                   AND aum.id_analysis_parameter = def_data.id_analysis_parameter
                   AND aum.id_unit_measure = def_data.id_unit_measure
                   AND aum.id_institution = i_id_institution
                   AND aum.id_software = i_id_software
                   AND aum.id_sample_type = def_data.id_sample_type)
           AND EXISTS (SELECT 0
                  FROM unit_measure um
                 WHERE um.id_unit_measure = def_data.id_unit_measure)
           AND EXISTS (SELECT 0
                  FROM analysis_sample_type ast
                 WHERE ast.id_analysis = def_data.id_analysis
                   AND ast.id_sample_type = def_data.id_sample_type);
    
        g_error := 'CLOSE O_AUM_ANALYSIS CURSOR';
        OPEN o_aum_analysis FOR
            SELECT column_value
              FROM TABLE(CAST(l_analysis_array AS table_number));
    
        g_error := 'CLOSE O_AUM_UNIT_MEASURES CURSOR';
        OPEN o_aum_unit_measures FOR
            SELECT column_value
              FROM TABLE(CAST(l_aum_unit_measure_array AS table_number));
    
        g_error := 'CLOSE O_AUM_VAL_MIN CURSOR';
        OPEN o_aum_val_min FOR
            SELECT column_value
              FROM TABLE(CAST(l_aum_val_min_array AS table_number));
    
        g_error := 'CLOSE O_AUM_VAL_MAX CURSOR';
        OPEN o_aum_val_max FOR
            SELECT column_value
              FROM TABLE(CAST(l_aum_val_max_array AS table_number));
    
        g_error := 'CLOSE O_AUM_FORMAT_NUM CURSOR';
        OPEN o_aum_format_num FOR
            SELECT column_value
              FROM TABLE(CAST(l_aum_format_num_array AS table_varchar));
    
        g_error := 'CLOSE O_AUM_DECIMALS CURSOR';
        OPEN o_aum_decimals FOR
            SELECT column_value
              FROM TABLE(CAST(l_aum_decimals_array AS table_number));
    
        g_error := 'CLOSE O_AUM_FORMAT_NUM CURSOR';
        OPEN o_aum_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_aum_flg_default_array AS table_varchar));
    
        g_error := 'CLOSE O_AP_ANALYSIS CURSOR';
        OPEN o_aum_analysis_param FOR
            SELECT column_value
              FROM TABLE(CAST(l_analysis_parameter_array AS table_number));
        g_error := 'CLOSE O_AUM_SAMPLE_TYPE CURSOR';
        OPEN o_aum_sample_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_sample_type_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ANALYSIS_UNIT_MEA',
                                              o_error);
            pk_types.open_my_cursor(o_aum_analysis);
            pk_types.open_my_cursor(o_aum_unit_measures);
            pk_types.open_my_cursor(o_aum_val_min);
            pk_types.open_my_cursor(o_aum_val_max);
            pk_types.open_my_cursor(o_aum_format_num);
            pk_types.open_my_cursor(o_aum_decimals);
            pk_types.open_my_cursor(o_aum_flg_default);
            pk_types.open_my_cursor(o_aum_analysis_param);
            pk_types.open_my_cursor(o_aum_sample_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_analysis_unit_mea;

    /********************************************************************************************
    * Set Analysis for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_analysis       Cursor of Instituition Analysis
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/19
    ********************************************************************************************/
    FUNCTION set_inst_analysis
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_analysis  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data           table_number;
        l_data_loinc     table_varchar;
        l_data_flg       table_varchar;
        l_data_al_sptype table_number;
    
        l_data_analysis   table_number;
        l_data_flg_type   table_varchar;
        l_data_flg_mp     table_varchar;
        l_data_flg_fr     table_varchar;
        l_data_flg_mr     table_varchar;
        l_data_flg_hr     table_varchar;
        l_data_flg_ft     table_varchar;
        l_data_exam       table_varchar;
        l_data_ais_sptype table_number;
    
        l_data_air_ais table_number;
        l_data_air_sr  table_varchar;
        l_data_air_flg table_varchar;
    
        l_data_ap_analysis   table_number;
        l_data_ap_parameters table_number;
        l_data_ap_colors     table_varchar;
        l_data_ap_fill       table_varchar;
        l_data_ap_rank       table_number;
        l_data_ap_sptype     table_number;
    
        l_data_apf_analysis_param table_number;
        l_data_apf_flg_type       table_varchar;
        l_data_apf_fill_type      table_varchar;
    
        l_data_aum_analysis       table_number;
        l_data_aum_unit_mea       table_number;
        l_data_aum_val_min        table_number;
        l_data_aum_val_max        table_number;
        l_data_aum_format_num     table_varchar;
        l_data_aum_decimals       table_number;
        l_data_aum_flg_default    table_varchar;
        l_data_aum_analysis_param table_number;
        l_data_aum_sample_type    table_number;
    
        l_c_analysis       pk_types.cursor_type;
        l_c_al_loinc       pk_types.cursor_type;
        l_c_al_flg_default pk_types.cursor_type;
        l_c_al_sptype      pk_types.cursor_type;
    
        l_c_ais_analysis          pk_types.cursor_type;
        l_c_ais_flg_type          pk_types.cursor_type;
        l_c_ais_flg_mov_pat       pk_types.cursor_type;
        l_c_ais_flg_first_result  pk_types.cursor_type;
        l_c_ais_flg_mov_recipient pk_types.cursor_type;
        l_c_ais_flg_harvest       pk_types.cursor_type;
        l_c_ais_flg_fill_type     pk_types.cursor_type;
        l_c_exam_cat              pk_types.cursor_type;
        l_c_sptype                pk_types.cursor_type;
    
        l_c_air_ais         pk_types.cursor_type;
        l_c_air_sr          pk_types.cursor_type;
        l_c_air_flg_default pk_types.cursor_type;
    
        l_c_ap_analysis   pk_types.cursor_type;
        l_c_ap_parameters pk_types.cursor_type;
        l_c_ap_fill       pk_types.cursor_type;
        l_c_ap_colors     pk_types.cursor_type;
        l_c_ap_rank       pk_types.cursor_type;
        l_c_ap_sptype     pk_types.cursor_type;
    
        l_c_apf_analysis_param pk_types.cursor_type;
        l_c_apf_flg_type       pk_types.cursor_type;
        l_c_apf_fill_type      pk_types.cursor_type;
    
        l_c_aum_analysis       pk_types.cursor_type;
        l_c_aum_unit_mea       pk_types.cursor_type;
        l_c_aum_val_min        pk_types.cursor_type;
        l_c_aum_val_max        pk_types.cursor_type;
        l_c_aum_format_num     pk_types.cursor_type;
        l_c_aum_decimals       pk_types.cursor_type;
        l_c_aum_flg_default    pk_types.cursor_type;
        l_c_aum_analysis_param pk_types.cursor_type;
        l_c_aum_sample_type    pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --ANALYSIS_INSTIT_SOFT
            IF NOT get_inst_analysis(i_lang,
                                     i_market,
                                     i_version,
                                     i_id_institution,
                                     i_software(i),
                                     l_c_ais_analysis,
                                     l_c_ais_flg_type,
                                     l_c_ais_flg_mov_pat,
                                     l_c_ais_flg_first_result,
                                     l_c_ais_flg_mov_recipient,
                                     l_c_ais_flg_harvest,
                                     l_c_ais_flg_fill_type,
                                     l_c_exam_cat,
                                     l_c_sptype,
                                     l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_analysis := l_c_ais_analysis;
            
                LOOP
                    FETCH l_c_ais_analysis BULK COLLECT
                        INTO l_data_analysis LIMIT g_array_size;
                
                    FETCH l_c_ais_flg_type BULK COLLECT
                        INTO l_data_flg_type LIMIT g_array_size;
                
                    FETCH l_c_ais_flg_mov_pat BULK COLLECT
                        INTO l_data_flg_mp LIMIT g_array_size;
                
                    FETCH l_c_ais_flg_first_result BULK COLLECT
                        INTO l_data_flg_fr LIMIT g_array_size;
                
                    FETCH l_c_ais_flg_mov_recipient BULK COLLECT
                        INTO l_data_flg_mr LIMIT g_array_size;
                
                    FETCH l_c_ais_flg_harvest BULK COLLECT
                        INTO l_data_flg_hr LIMIT g_array_size;
                
                    FETCH l_c_ais_flg_fill_type BULK COLLECT
                        INTO l_data_flg_ft LIMIT g_array_size;
                
                    FETCH l_c_exam_cat BULK COLLECT
                        INTO l_data_exam LIMIT g_array_size;
                    FETCH l_c_sptype BULK COLLECT
                        INTO l_data_ais_sptype LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_analysis.count
                        INSERT INTO analysis_instit_soft
                            (id_analysis_instit_soft,
                             id_analysis,
                             flg_type,
                             id_institution,
                             id_software,
                             flg_mov_pat,
                             flg_first_result,
                             flg_mov_recipient,
                             flg_harvest,
                             id_exam_cat,
                             rank,
                             flg_available,
                             id_sample_type)
                        VALUES
                            (seq_analysis_instit_soft.nextval,
                             l_data_analysis(j),
                             l_data_flg_type(j),
                             i_id_institution,
                             i_software(i),
                             l_data_flg_mp(j),
                             l_data_flg_fr(j),
                             l_data_flg_mr(j),
                             l_data_flg_hr(j),
                             l_data_exam(j),
                             0,
                             g_flg_available,
                             l_data_ais_sptype(j));
                
                    EXIT WHEN l_c_ais_analysis%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_ais_analysis;
                CLOSE l_c_ais_flg_type;
                CLOSE l_c_ais_flg_mov_pat;
                CLOSE l_c_ais_flg_first_result;
                CLOSE l_c_ais_flg_mov_recipient;
                CLOSE l_c_ais_flg_harvest;
                CLOSE l_c_ais_flg_fill_type;
                CLOSE l_c_exam_cat;
                CLOSE l_c_sptype;
            
            END IF;
        
            --ANALYSIS_LOINC
            IF NOT get_inst_analysis_loinc(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software(i),
                                           l_c_analysis,
                                           l_c_al_loinc,
                                           l_c_al_flg_default,
                                           l_c_al_sptype,
                                           l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                LOOP
                    FETCH l_c_analysis BULK COLLECT
                        INTO l_data LIMIT g_array_size;
                
                    FETCH l_c_al_loinc BULK COLLECT
                        INTO l_data_loinc LIMIT g_array_size;
                
                    FETCH l_c_al_flg_default BULK COLLECT
                        INTO l_data_flg LIMIT g_array_size;
                
                    FETCH l_c_al_sptype BULK COLLECT
                        INTO l_data_al_sptype LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data.count
                        INSERT INTO analysis_loinc
                            (id_analysis_loinc,
                             id_analysis,
                             loinc_code,
                             id_institution,
                             id_software,
                             flg_default,
                             id_sample_type)
                        VALUES
                            (seq_analysis_loinc.nextval,
                             l_data(j),
                             l_data_loinc(j),
                             i_id_institution,
                             i_software(i),
                             l_data_flg(j),
                             l_data_al_sptype(j));
                
                    EXIT WHEN l_c_analysis%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_analysis;
                CLOSE l_c_al_loinc;
                CLOSE l_c_al_flg_default;
                CLOSE l_c_al_sptype;
            
            END IF;
        
            --ANALYSIS_INSTIT_RECIPIENT
            IF NOT get_inst_analysis_recipients(i_lang,
                                                i_market,
                                                i_version,
                                                i_id_institution,
                                                i_software(i),
                                                l_c_air_ais,
                                                l_c_air_sr,
                                                l_c_air_flg_default,
                                                l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                LOOP
                    FETCH l_c_air_ais BULK COLLECT
                        INTO l_data_air_ais LIMIT g_array_size;
                
                    FETCH l_c_air_sr BULK COLLECT
                        INTO l_data_air_sr LIMIT g_array_size;
                
                    FETCH l_c_air_flg_default BULK COLLECT
                        INTO l_data_air_flg LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_air_ais.count
                        INSERT INTO analysis_instit_recipient
                            (id_analysis_instit_recipient, id_analysis_instit_soft, id_sample_recipient, flg_default)
                        VALUES
                            (seq_analysis_instit_recipient.nextval,
                             l_data_air_ais(j),
                             l_data_air_sr(j),
                             l_data_air_flg(j));
                
                    EXIT WHEN l_c_air_ais%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_air_ais;
                CLOSE l_c_air_sr;
                CLOSE l_c_air_flg_default;
            
            END IF;
        
            --ANALYSIS_PARAM
            IF NOT get_inst_analysis_param(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software(i),
                                           l_c_ap_analysis,
                                           l_c_ap_parameters,
                                           l_c_ap_rank,
                                           l_c_ap_colors,
                                           l_c_ap_fill,
                                           l_c_ap_sptype,
                                           l_error)
            THEN
                RAISE l_exception;
            ELSE
                --l_c_ap_fill,l_c_ap_colors, l_c_ap_rank
                --l_data_ap_colors ,l_data_ap_fill ,l_data_ap_rank 
                LOOP
                    FETCH l_c_ap_analysis BULK COLLECT
                        INTO l_data_ap_analysis LIMIT g_array_size;
                
                    FETCH l_c_ap_parameters BULK COLLECT
                        INTO l_data_ap_parameters LIMIT g_array_size;
                
                    FETCH l_c_ap_rank BULK COLLECT
                        INTO l_data_ap_rank LIMIT g_array_size;
                
                    FETCH l_c_ap_colors BULK COLLECT
                        INTO l_data_ap_colors LIMIT g_array_size;
                    FETCH l_c_ap_fill BULK COLLECT
                        INTO l_data_ap_fill LIMIT g_array_size;
                    FETCH l_c_ap_sptype BULK COLLECT
                        INTO l_data_ap_sptype LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_ap_analysis.count
                        INSERT INTO analysis_param
                            (id_analysis_param,
                             id_analysis,
                             flg_available,
                             adw_last_update,
                             id_institution,
                             id_software,
                             id_analysis_parameter,
                             rank,
                             color_graph,
                             flg_fill_type,
                             id_sample_type)
                        VALUES
                            (seq_analysis_param.nextval,
                             l_data_ap_analysis(j),
                             g_flg_available,
                             SYSDATE,
                             i_id_institution,
                             i_software(i),
                             l_data_ap_parameters(j),
                             l_data_ap_rank(j),
                             l_data_ap_colors(j),
                             l_data_ap_fill(j),
                             l_data_ap_sptype(j));
                
                    EXIT WHEN l_c_ap_analysis%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_ap_analysis;
                CLOSE l_c_ap_parameters;
                CLOSE l_c_ap_fill;
                CLOSE l_c_ap_colors;
                CLOSE l_c_ap_rank;
                CLOSE l_c_ap_sptype;
            
            END IF;
        
            --ANALYSIS_PARAM_FUNC
            IF NOT get_inst_analysis_param_func(i_lang,
                                                i_market,
                                                i_version,
                                                i_id_institution,
                                                i_software(i),
                                                l_c_apf_analysis_param,
                                                l_c_apf_flg_type,
                                                l_c_apf_fill_type,
                                                l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                LOOP
                    FETCH l_c_apf_analysis_param BULK COLLECT
                        INTO l_data_apf_analysis_param LIMIT g_array_size;
                
                    FETCH l_c_apf_flg_type BULK COLLECT
                        INTO l_data_apf_flg_type LIMIT g_array_size;
                
                    FETCH l_c_apf_fill_type BULK COLLECT
                        INTO l_data_apf_fill_type LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_apf_analysis_param.count
                        INSERT INTO analysis_param_funcionality
                            (id_analysis_param_funcionality,
                             flg_type,
                             adw_last_update,
                             id_analysis_param,
                             flg_fill_type,
                             rank)
                        VALUES
                            (seq_analysis_param_func.nextval,
                             l_data_apf_flg_type(j),
                             SYSDATE,
                             l_data_apf_analysis_param(j),
                             l_data_apf_fill_type(j),
                             0);
                
                    EXIT WHEN l_c_apf_analysis_param%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_apf_analysis_param;
                CLOSE l_c_apf_flg_type;
                CLOSE l_c_apf_fill_type;
            
            END IF;
        
            --ANALYSIS_UNIT_MEASURE
            IF NOT get_inst_analysis_unit_mea(i_lang,
                                              i_market,
                                              i_version,
                                              i_id_institution,
                                              i_software(i),
                                              l_c_aum_analysis,
                                              l_c_aum_unit_mea,
                                              l_c_aum_val_min,
                                              l_c_aum_val_max,
                                              l_c_aum_format_num,
                                              l_c_aum_decimals,
                                              l_c_aum_flg_default,
                                              l_c_aum_analysis_param,
                                              l_c_aum_sample_type,
                                              l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                LOOP
                    FETCH l_c_aum_analysis BULK COLLECT
                        INTO l_data_aum_analysis LIMIT g_array_size;
                
                    FETCH l_c_aum_unit_mea BULK COLLECT
                        INTO l_data_aum_unit_mea LIMIT g_array_size;
                
                    FETCH l_c_aum_val_min BULK COLLECT
                        INTO l_data_aum_val_min LIMIT g_array_size;
                
                    FETCH l_c_aum_val_max BULK COLLECT
                        INTO l_data_aum_val_max LIMIT g_array_size;
                
                    FETCH l_c_aum_format_num BULK COLLECT
                        INTO l_data_aum_format_num LIMIT g_array_size;
                
                    FETCH l_c_aum_decimals BULK COLLECT
                        INTO l_data_aum_decimals LIMIT g_array_size;
                
                    FETCH l_c_aum_flg_default BULK COLLECT
                        INTO l_data_aum_flg_default LIMIT g_array_size;
                
                    FETCH l_c_aum_analysis_param BULK COLLECT
                        INTO l_data_aum_analysis_param LIMIT g_array_size;
                
                    FETCH l_c_aum_sample_type BULK COLLECT
                        INTO l_data_aum_sample_type LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_aum_analysis.count
                        INSERT INTO analysis_unit_measure
                            (id_analysis_unit_measure,
                             id_analysis,
                             id_unit_measure,
                             val_min,
                             val_max,
                             format_num,
                             decimals,
                             id_institution,
                             id_software,
                             flg_default,
                             id_analysis_parameter,
                             id_sample_type)
                        VALUES
                            (seq_analysis_unit_measure.nextval,
                             l_data_aum_analysis(j),
                             l_data_aum_unit_mea(j),
                             l_data_aum_val_min(j),
                             l_data_aum_val_max(j),
                             l_data_aum_format_num(j),
                             l_data_aum_decimals(j),
                             i_id_institution,
                             i_software(i),
                             l_data_aum_flg_default(j),
                             l_data_aum_analysis_param(j),
                             l_data_aum_sample_type(j));
                
                    EXIT WHEN l_c_aum_analysis%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_aum_analysis;
                CLOSE l_c_aum_unit_mea;
                CLOSE l_c_aum_val_min;
                CLOSE l_c_aum_val_max;
                CLOSE l_c_aum_format_num;
                CLOSE l_c_aum_decimals;
                CLOSE l_c_aum_flg_default;
                CLOSE l_c_aum_analysis_param;
                CLOSE l_c_aum_sample_type;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_ANALYSIS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_ANALYSIS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_analysis;

    /********************************************************************************************
    * Get Analysis Groups set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_analysis_group      Cursor of analysis groups
    * @param o_ais_flg_type        Cursor of analysis groups types
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/30
    ********************************************************************************************/
    FUNCTION get_inst_analysis_group
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_analysis_group OUT pk_types.cursor_type,
        o_ais_flg_type   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --ANALYSIS_GROUP
        l_id_analysis_group_def analysis_group.id_analysis_group%TYPE := NULL;
        l_id_analysis_group     analysis_group.id_analysis_group%TYPE := NULL;
    
        --ANALYSIS_INSTIT_SOFT
        l_ais_flg_type analysis_instit_soft.flg_type%TYPE := NULL;
    
        l_analysis_group_array table_number := table_number();
        l_ais_flg_type_array   table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_ag_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT ais.id_analysis_group, ais.flg_type
              FROM alert_default.analysis_instit_soft ais, alert_default.analysis_group_mrk_vrs agmv
             WHERE ais.id_software = c_id_software
               AND ais.flg_available = g_flg_available
               AND ais.id_analysis_group = agmv.id_analysis_group
               AND agmv.id_market = c_market
               AND agmv.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_AG_INST_SOFT CURSOR';
                OPEN c_ag_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_ag_inst_soft
                        INTO l_id_analysis_group_def, l_ais_flg_type;
                    EXIT WHEN c_ag_inst_soft%NOTFOUND;
                
                    --ANALYSIS_GROUP
                    SELECT nvl((SELECT ag.id_analysis_group
                                 FROM analysis_group ag
                                WHERE ag.id_content =
                                      (SELECT ag2.id_content
                                         FROM alert_default.analysis_group ag2
                                        WHERE ag2.id_analysis_group = l_id_analysis_group_def)
                                  AND ag.id_content IS NOT NULL
                                  AND rownum = 1),
                               0)
                      INTO l_id_analysis_group
                      FROM dual;
                
                    IF l_id_analysis_group != 0
                    THEN
                    
                        g_error := 'COUNT';
                        SELECT COUNT(ais.id_analysis_instit_soft)
                          INTO l_count
                          FROM analysis_instit_soft ais
                         WHERE ais.id_analysis_group = l_id_analysis_group
                           AND ais.id_institution = i_id_institution
                           AND ais.id_software = i_id_software;
                    
                        IF l_count = 0
                        THEN
                            l_analysis_group_array.extend;
                            l_ais_flg_type_array.extend;
                        
                            l_analysis_group_array(l_index) := l_id_analysis_group;
                            l_ais_flg_type_array(l_index) := l_ais_flg_type;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_ANALYSIS_INST_SOFT CURSOR';
                CLOSE c_ag_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_ANALYSIS CURSOR';
        OPEN o_analysis_group FOR
            SELECT column_value
              FROM TABLE(CAST(l_analysis_group_array AS table_number));
    
        g_error := 'CLOSE O_AIS_FLG_TYPE CURSOR';
        OPEN o_ais_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_ais_flg_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ANALYSIS_GROUP',
                                              o_error);
            pk_types.open_my_cursor(o_analysis_group);
            pk_types.open_my_cursor(o_ais_flg_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_analysis_group;

    /********************************************************************************************
    * Set Analysis Groups for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_analysis_group Cursor of Instituition Analysis Groups
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/19
    ********************************************************************************************/
    FUNCTION set_inst_analysis_group
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN table_number,
        i_version             IN table_varchar,
        i_id_institution      IN institution.id_institution%TYPE,
        i_software            IN table_number,
        o_inst_analysis_group OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_ais_analysis_group pk_types.cursor_type;
        l_c_ais_flg_type       pk_types.cursor_type;
    
        l_data_analysis_group table_number;
        l_data_flg_type       table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --ANALYSIS_INSTIT_SOFT
            IF NOT get_inst_analysis_group(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software(i),
                                           l_c_ais_analysis_group,
                                           l_c_ais_flg_type,
                                           l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_analysis_group := l_c_ais_analysis_group;
            
                LOOP
                    FETCH l_c_ais_analysis_group BULK COLLECT
                        INTO l_data_analysis_group LIMIT g_array_size;
                
                    FETCH l_c_ais_flg_type BULK COLLECT
                        INTO l_data_flg_type LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_analysis_group.count
                        INSERT INTO analysis_instit_soft
                            (id_analysis_instit_soft,
                             id_analysis,
                             flg_type,
                             id_institution,
                             id_software,
                             rank,
                             id_analysis_group,
                             flg_available)
                        VALUES
                            (seq_analysis_instit_soft.nextval,
                             NULL,
                             l_data_flg_type(j),
                             i_id_institution,
                             i_software(i),
                             0,
                             l_data_analysis_group(j),
                             g_flg_available);
                
                    EXIT WHEN l_c_ais_analysis_group%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_ais_analysis_group;
                CLOSE l_c_ais_flg_type;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_ANALYSIS_GROUP',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_ANALYSIS_GROUP',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_analysis_group;

    /********************************************************************************************
    * Get Exams set of markets, versions and sotwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_exams                 Cursor of exams
    * @param o_ecs_flg_first_result  Cursor of exams first result flags
    * @param o_ecs_flg_mov_pat       Cursor of exams mov. patient flags
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/30
    ********************************************************************************************/
    FUNCTION get_inst_exams
    (
        i_lang                 IN language.id_language%TYPE,
        i_market               IN table_number,
        i_version              IN table_varchar,
        i_id_institution       IN institution.id_institution%TYPE,
        i_id_software          IN software.id_software%TYPE,
        o_exams                OUT pk_types.cursor_type,
        o_ecs_flg_first_result OUT pk_types.cursor_type,
        o_ecs_flg_mov_pat      OUT pk_types.cursor_type,
        o_ecs_flg_type         OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --EXAM
        l_id_exam_def exam.id_exam%TYPE := NULL;
        l_id_exam     exam.id_exam%TYPE := NULL;
    
        --EXAM__DEP_CLIN_SERV
        l_ecs_flg_first_result exam_dep_clin_serv.flg_first_result%TYPE := NULL;
        l_ecs_flg_mov_pat      exam_dep_clin_serv.flg_mov_pat%TYPE := NULL;
        l_ecs_flg_type         exam_dep_clin_serv.flg_mov_pat%TYPE := NULL;
    
        l_exams_array                table_number := table_number();
        l_ecs_flg_first_result_array table_varchar := table_varchar();
        l_ecs_flg_mov_pat_array      table_varchar := table_varchar();
        l_ecs_flg_type_array         table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_exams_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT ecs.id_exam, ecs.flg_first_result, ecs.flg_mov_pat, ecs.flg_type
              FROM alert_default.exam_mrk_vrs emv, alert_default.exam e, alert_default.exam_clin_serv ecs
             WHERE emv.id_market = c_market
               AND emv.version = c_version
               AND emv.id_exam = e.id_exam
               AND e.flg_available = g_flg_available
               AND e.id_exam = ecs.id_exam
               AND ecs.id_clinical_service IS NULL
               AND ecs.id_software = c_id_software;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_EXAMS_INST_SOFT CURSOR';
                OPEN c_exams_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_exams_inst_soft
                        INTO l_id_exam_def, l_ecs_flg_first_result, l_ecs_flg_mov_pat, l_ecs_flg_type;
                    EXIT WHEN c_exams_inst_soft%NOTFOUND;
                
                    --EXAM
                    g_error := 'EXAMS';
                    SELECT nvl((SELECT e.id_exam
                                 FROM exam e
                                WHERE e.id_content = (SELECT e2.id_content
                                                        FROM alert_default.exam e2
                                                       WHERE e2.id_exam = l_id_exam_def)
                                  AND e.id_content IS NOT NULL
                                  AND e.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_exam
                      FROM dual;
                
                    IF l_id_exam != 0
                    THEN
                    
                        SELECT COUNT(edcs.id_exam_dep_clin_serv)
                          INTO l_count
                          FROM exam_dep_clin_serv edcs
                         WHERE edcs.id_exam = l_id_exam
                           AND edcs.id_dep_clin_serv IS NULL
                           AND edcs.flg_type = l_ecs_flg_type
                           AND edcs.id_institution = i_id_institution
                           AND edcs.id_software = i_id_software;
                    
                        IF l_count = 0
                        THEN
                            l_exams_array.extend;
                            l_ecs_flg_first_result_array.extend;
                            l_ecs_flg_mov_pat_array.extend;
                            l_ecs_flg_type_array.extend;
                        
                            l_exams_array(l_index) := l_id_exam;
                            l_ecs_flg_first_result_array(l_index) := l_ecs_flg_first_result;
                            l_ecs_flg_mov_pat_array(l_index) := l_ecs_flg_mov_pat;
                            l_ecs_flg_type_array(l_index) := l_ecs_flg_type;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_EXAMS_INST_SOFT CURSOR';
                CLOSE c_exams_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_EXAMS CURSOR';
        OPEN o_exams FOR
            SELECT column_value
              FROM TABLE(CAST(l_exams_array AS table_number));
    
        g_error := 'CLOSE O_ECS_FLG_FIRST_RESULT CURSOR';
        OPEN o_ecs_flg_first_result FOR
            SELECT column_value
              FROM TABLE(CAST(l_ecs_flg_first_result_array AS table_varchar));
    
        g_error := 'CLOSE O_ECS_FLG_MOV_PAT CURSOR';
        OPEN o_ecs_flg_mov_pat FOR
            SELECT column_value
              FROM TABLE(CAST(l_ecs_flg_mov_pat_array AS table_varchar));
    
        g_error := 'CLOSE O_ECS_FLG_TYPE CURSOR';
        OPEN o_ecs_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_ecs_flg_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_EXAMS',
                                              o_error);
            pk_types.open_my_cursor(o_exams);
            pk_types.open_my_cursor(o_ecs_flg_first_result);
            pk_types.open_my_cursor(o_ecs_flg_mov_pat);
            pk_types.open_my_cursor(o_ecs_flg_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_exams;

    /********************************************************************************************
    * Get Exams set of markets, versions and sotwares
    *
    * @param i_lang                       Prefered language ID
    * @param i_market                     Market ID's
    * @param i_version                    ALERT version's
    * @param i_id_institution             Institution ID
    * @param i_id_software                Software ID
    * @param o_exams                      Cursor of exams
    * @param o_exams_type                 Cursor of exams first result flags
    * @param o_ecs_flg_bypass_validation  Cursor of exams mov. patient flags
    * @param o_error                      Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/30
    ********************************************************************************************/
    FUNCTION get_inst_exam_types
    (
        i_lang                      IN language.id_language%TYPE,
        i_market                    IN table_number,
        i_version                   IN table_varchar,
        i_id_institution            IN institution.id_institution%TYPE,
        i_id_software               IN software.id_software%TYPE,
        o_exams                     OUT pk_types.cursor_type,
        o_exams_type                OUT pk_types.cursor_type,
        o_ecs_flg_bypass_validation OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --EXAM
        l_id_exam_def exam.id_exam%TYPE := NULL;
        l_id_exam     exam.id_exam%TYPE := NULL;
    
        --EXAM_TYPE_GROUP
        l_etg_id_exam_type          exam_type_group.id_exam_type%TYPE;
        l_etg_flg_bypass_validation exam_type_group.flg_bypass_validation%TYPE;
    
        l_exams_array              table_number := table_number();
        l_exams_types_array        table_number := table_number();
        l_etg_flg_bypass_val_array table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_exams_types
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT etg.id_exam_type, etg.id_exam, etg.flg_bypass_validation
              FROM alert_default.exam_mrk_vrs emv, alert_default.exam e, alert_default.exam_type_group etg
             WHERE emv.id_market = c_market
               AND emv.version = c_version
               AND emv.id_exam = e.id_exam
               AND e.flg_available = g_flg_available
               AND e.id_exam = etg.id_exam
               AND etg.id_software = c_id_software;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_EXAMS_INST_SOFT CURSOR';
                OPEN c_exams_types(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_exams_types
                        INTO l_etg_id_exam_type, l_id_exam_def, l_etg_flg_bypass_validation;
                    EXIT WHEN c_exams_types%NOTFOUND;
                
                    --EXAM
                    g_error := 'EXAMS';
                    SELECT nvl((SELECT e.id_exam
                                 FROM exam e
                                WHERE e.id_content = (SELECT e2.id_content
                                                        FROM alert_default.exam e2
                                                       WHERE e2.id_exam = l_id_exam_def)
                                  AND e.id_content IS NOT NULL
                                  AND e.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_exam
                      FROM dual;
                
                    IF l_id_exam != 0
                    THEN
                    
                        SELECT COUNT(etg.id_exam_type_group)
                          INTO l_count
                          FROM exam_type_group etg
                         WHERE etg.id_exam_type = l_etg_id_exam_type
                           AND etg.flg_bypass_validation = l_etg_flg_bypass_validation
                           AND etg.id_exam = l_id_exam
                           AND etg.id_software = i_id_software
                           AND etg.id_institution = i_id_institution;
                    
                        IF l_count = 0
                        THEN
                            l_exams_array.extend;
                            l_exams_types_array.extend;
                            l_etg_flg_bypass_val_array.extend;
                        
                            l_exams_array(l_index) := l_id_exam;
                            l_exams_types_array(l_index) := l_etg_id_exam_type;
                            l_etg_flg_bypass_val_array(l_index) := l_etg_flg_bypass_validation;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_EXAMS_INST_SOFT CURSOR';
                CLOSE c_exams_types;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_EXAMS CURSOR';
        OPEN o_exams FOR
            SELECT column_value
              FROM TABLE(CAST(l_exams_array AS table_number));
    
        g_error := 'CLOSE O_EXAMS CURSOR';
        OPEN o_exams_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_exams_types_array AS table_number));
    
        g_error := 'CLOSE O_ECS_FLG_MOV_PAT CURSOR';
        OPEN o_ecs_flg_bypass_validation FOR
            SELECT column_value
              FROM TABLE(CAST(l_etg_flg_bypass_val_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_EXAM_TYPES',
                                              o_error);
            pk_types.open_my_cursor(o_exams);
            pk_types.open_my_cursor(o_exams_type);
            pk_types.open_my_cursor(o_ecs_flg_bypass_validation);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_exam_types;

    /********************************************************************************************
    * Set Exams for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_exams          Cursor of Instituition Exams
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/30
    ********************************************************************************************/
    FUNCTION set_inst_exams
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_exams     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_ecs_exams            pk_types.cursor_type;
        l_c_ecs_flg_first_result pk_types.cursor_type;
        l_c_ecs_flg_mov_pat      pk_types.cursor_type;
        l_c_ecs_flg_type         pk_types.cursor_type;
    
        l_c_etg_exams                 pk_types.cursor_type;
        l_c_etg_exams_types           pk_types.cursor_type;
        l_c_etg_flg_bypass_validation pk_types.cursor_type;
    
        l_data_exams        table_number;
        l_data_first_result table_varchar;
        l_data_flg_mov_pat  table_varchar;
        l_data_flg_type     table_varchar;
    
        l_data_etg_exams          table_number;
        l_data_etg_exams_types    table_number;
        l_data_etg_flg_bypass_val table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --EXAMS_DEP_CLIN_SERV
            IF NOT get_inst_exams(i_lang,
                                  i_market,
                                  i_version,
                                  i_id_institution,
                                  i_software(i),
                                  l_c_ecs_exams,
                                  l_c_ecs_flg_first_result,
                                  l_c_ecs_flg_mov_pat,
                                  l_c_ecs_flg_type,
                                  l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_exams := l_c_ecs_exams;
            
                LOOP
                    FETCH l_c_ecs_exams BULK COLLECT
                        INTO l_data_exams LIMIT g_array_size;
                
                    FETCH l_c_ecs_flg_first_result BULK COLLECT
                        INTO l_data_first_result LIMIT g_array_size;
                
                    FETCH l_c_ecs_flg_mov_pat BULK COLLECT
                        INTO l_data_flg_mov_pat LIMIT g_array_size;
                
                    FETCH l_c_ecs_flg_type BULK COLLECT
                        INTO l_data_flg_type LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_exams.count
                        INSERT INTO exam_dep_clin_serv
                            (id_exam_dep_clin_serv,
                             id_exam,
                             flg_type,
                             rank,
                             id_institution,
                             id_software,
                             flg_first_result,
                             flg_mov_pat,
                             id_external_sys)
                        VALUES
                            (seq_exam_dep_clin_serv.nextval,
                             l_data_exams(j),
                             l_data_flg_type(j),
                             0,
                             i_id_institution,
                             i_software(i),
                             l_data_first_result(j),
                             l_data_flg_mov_pat(j),
                             NULL);
                
                    EXIT WHEN l_c_ecs_exams%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_ecs_exams;
                CLOSE l_c_ecs_flg_first_result;
                CLOSE l_c_ecs_flg_mov_pat;
            
            END IF;
        
            --EXAMS_TYPE_GROUP
            IF NOT get_inst_exam_types(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software(i),
                                       l_c_etg_exams,
                                       l_c_etg_exams_types,
                                       l_c_etg_flg_bypass_validation,
                                       l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                LOOP
                    FETCH l_c_etg_exams BULK COLLECT
                        INTO l_data_etg_exams LIMIT g_array_size;
                
                    FETCH l_c_etg_exams_types BULK COLLECT
                        INTO l_data_etg_exams_types LIMIT g_array_size;
                
                    FETCH l_c_etg_flg_bypass_validation BULK COLLECT
                        INTO l_data_etg_flg_bypass_val LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_etg_exams.count
                        INSERT INTO exam_type_group
                            (id_exam_type_group,
                             id_exam_type,
                             id_exam,
                             flg_bypass_validation,
                             id_software,
                             id_institution)
                        VALUES
                            (seq_exam_type_group.nextval,
                             l_data_etg_exams_types(j),
                             l_data_etg_exams(j),
                             l_data_etg_flg_bypass_val(j),
                             i_software(i),
                             i_id_institution);
                
                    EXIT WHEN l_c_etg_exams%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_etg_exams;
                CLOSE l_c_etg_exams_types;
                CLOSE l_c_etg_flg_bypass_validation;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_ANALYSIS_GROUP',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_EXAMS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_exams;

    /********************************************************************************************
    * Get Interventions set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_interv              Cursor of interventions
    * @param o_ics_flg_bandaid     Cursor of interv bandaid flags
    * @param o_ics_flg_chargeable  Cursor of interv chargeable flags
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/30
    ********************************************************************************************/
    FUNCTION get_inst_interv
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_id_software        IN software.id_software%TYPE,
        o_interv             OUT pk_types.cursor_type,
        o_ics_flg_bandaid    OUT pk_types.cursor_type,
        o_ics_flg_chargeable OUT pk_types.cursor_type,
        o_ics_flg_type       OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --INTERVENTION
        l_id_interv_def intervention.id_intervention%TYPE := NULL;
        l_id_interv     intervention.id_intervention%TYPE := NULL;
    
        --INTERV_DEP_CLIN_SERV
        l_ics_flg_bandaid    interv_dep_clin_serv.flg_bandaid%TYPE := NULL;
        l_ics_flg_chargeable interv_dep_clin_serv.flg_chargeable%TYPE := NULL;
        l_ics_flg_type       interv_dep_clin_serv.flg_type%TYPE := NULL;
    
        l_interv_array             table_number := table_number();
        l_ics_flg_bandaid_array    table_varchar := table_varchar();
        l_ics_flg_chargeable_array table_varchar := table_varchar();
        l_ics_flg_type_array       table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_interv_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT ics.id_intervention, ics.flg_bandaid, ics.flg_chargeable, ics.flg_type
              FROM alert_default.interv_clin_serv ics, alert_default.intervention i, alert_default.interv_mrk_vrs imv
             WHERE ics.id_software = c_id_software
               AND ics.id_clinical_service IS NULL
               AND ics.id_intervention = i.id_intervention
               AND i.flg_status = pk_alert_constant.g_active
               AND i.id_intervention = imv.id_intervention
               AND imv.id_market = c_market
               AND imv.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_INTERV_INST_SOFT CURSOR';
                OPEN c_interv_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_interv_inst_soft
                        INTO l_id_interv_def, l_ics_flg_bandaid, l_ics_flg_chargeable, l_ics_flg_type;
                    EXIT WHEN c_interv_inst_soft%NOTFOUND;
                
                    --INTERVENTION
                    SELECT nvl((SELECT i.id_intervention
                                 FROM intervention i
                                WHERE i.id_content = (SELECT i2.id_content
                                                        FROM alert_default.intervention i2
                                                       WHERE i2.id_intervention = l_id_interv_def)
                                  AND i.id_content IS NOT NULL
                                  AND i.flg_status = pk_alert_constant.g_active
                                  AND rownum = 1),
                               0)
                      INTO l_id_interv
                      FROM dual;
                
                    IF l_id_interv != 0
                    THEN
                    
                        SELECT COUNT(idcs.id_interv_dep_clin_serv)
                          INTO l_count
                          FROM interv_dep_clin_serv idcs
                         WHERE idcs.id_intervention = l_id_interv
                           AND idcs.id_dep_clin_serv IS NULL
                           AND idcs.flg_type = l_ics_flg_type
                           AND idcs.id_institution = i_id_institution
                           AND idcs.id_software = i_id_software;
                    
                        IF l_count = 0
                        THEN
                            l_interv_array.extend;
                            l_ics_flg_bandaid_array.extend;
                            l_ics_flg_chargeable_array.extend;
                            l_ics_flg_type_array.extend;
                        
                            l_interv_array(l_index) := l_id_interv;
                            l_ics_flg_bandaid_array(l_index) := l_ics_flg_bandaid;
                            l_ics_flg_chargeable_array(l_index) := l_ics_flg_chargeable;
                            l_ics_flg_type_array(l_index) := l_ics_flg_type;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_INTERV_INST_SOFT CURSOR';
                CLOSE c_interv_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_INTERV CURSOR';
        OPEN o_interv FOR
            SELECT column_value
              FROM TABLE(CAST(l_interv_array AS table_number));
    
        g_error := 'CLOSE O_ICS_FLG_BANDAID CURSOR';
        OPEN o_ics_flg_bandaid FOR
            SELECT column_value
              FROM TABLE(CAST(l_ics_flg_bandaid_array AS table_varchar));
    
        g_error := 'CLOSE O_ICS_FLG_CHARGEABLE CURSOR';
        OPEN o_ics_flg_chargeable FOR
            SELECT column_value
              FROM TABLE(CAST(l_ics_flg_chargeable_array AS table_varchar));
    
        g_error := 'CLOSE O_ICS_FLG_TYPE CURSOR';
        OPEN o_ics_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_ics_flg_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_INTERV',
                                              o_error);
            pk_types.open_my_cursor(o_interv);
            pk_types.open_my_cursor(o_ics_flg_bandaid);
            pk_types.open_my_cursor(o_ics_flg_chargeable);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_interv;

    /********************************************************************************************
    * Set Interventions for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_interv         Cursor of Instituition Interventions
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/31
    ********************************************************************************************/
    FUNCTION set_inst_interv
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_interv    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_ics_interv         pk_types.cursor_type;
        l_c_ics_flg_bandaid    pk_types.cursor_type;
        l_c_ics_flg_chargeable pk_types.cursor_type;
        l_c_ics_flg_type       pk_types.cursor_type;
    
        l_data_interv         table_number;
        l_data_bandaid        table_varchar;
        l_data_flg_chargeable table_varchar;
        l_data_flg_type       table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --INTERV_DEP_CLIN_SERV
            IF NOT get_inst_interv(i_lang,
                                   i_market,
                                   i_version,
                                   i_id_institution,
                                   i_software(i),
                                   l_c_ics_interv,
                                   l_c_ics_flg_bandaid,
                                   l_c_ics_flg_chargeable,
                                   l_c_ics_flg_type,
                                   l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_interv := l_c_ics_interv;
            
                LOOP
                    FETCH l_c_ics_interv BULK COLLECT
                        INTO l_data_interv LIMIT g_array_size;
                
                    FETCH l_c_ics_flg_bandaid BULK COLLECT
                        INTO l_data_bandaid LIMIT g_array_size;
                
                    FETCH l_c_ics_flg_chargeable BULK COLLECT
                        INTO l_data_flg_chargeable LIMIT g_array_size;
                
                    FETCH l_c_ics_flg_type BULK COLLECT
                        INTO l_data_flg_type LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_interv.count
                        INSERT INTO interv_dep_clin_serv
                            (id_interv_dep_clin_serv,
                             id_intervention,
                             flg_type,
                             rank,
                             id_institution,
                             id_software,
                             flg_bandaid,
                             flg_chargeable)
                        
                        VALUES
                            (seq_interv_dep_clin_serv.nextval,
                             l_data_interv(j),
                             l_data_flg_type(j),
                             0,
                             i_id_institution,
                             i_software(i),
                             l_data_bandaid(j),
                             l_data_flg_chargeable(j));
                
                    EXIT WHEN l_c_ics_interv%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_ics_interv;
                CLOSE l_c_ics_flg_bandaid;
                CLOSE l_c_ics_flg_chargeable;
                CLOSE l_c_ics_flg_type;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_INTERV',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_INTERV',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_interv;

    /********************************************************************************************
    * Set Diagnosis for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/02
    ********************************************************************************************/
    FUNCTION set_inst_diagnosis
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        k_function_name CONSTANT VARCHAR2(30 CHAR) := 'set_inst_diagnosis';
    BEGIN
        g_error := 'Invoking PK_DIAGNOSIS_DEF.SET_INST_DIAGNOSIS to insert diagnoses';
        alertlog.pk_alertlog.log_debug(text            => g_error,
                                       object_name     => g_package_name,
                                       sub_object_name => k_function_name);
    
        pk_diagnosis_def.set_inst_diagnosis(i_lang         => i_lang,
                                            i_lst_market   => i_market,
                                            i_lst_version  => i_version,
                                            i_institution  => i_id_institution,
                                            i_lst_software => i_software);
    
        RETURN TRUE;
    EXCEPTION
        WHEN pk_diagnosis_def.e_missing_cfg_term_version THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'e_missing_cfg_term_version',
                                              'Verify the setup required in order be able to run the default process for Diagnosis functionality.',
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DIAGNOSIS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_diagnosis;

    /********************************************************************************************
    * Get Sample Text Types and relation with professional categories for a set of markets, versions
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_st_types            Cursor of sample text types
    * @param o_st_categories       Cursor of categories
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/02
    ********************************************************************************************/
    FUNCTION get_inst_sample_text
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_st_types       OUT pk_types.cursor_type,
        o_st_categories  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --SAMPLE_TEXT_TYPE
        l_id_stt_def sample_text_type.id_sample_text_type%TYPE;
    
        --SAMPLE_TEXT_TYPE_CAT
        l_sttc_id_category sample_text_type_cat.id_category%TYPE;
    
        l_st_type_array table_number := table_number();
        l_st_cat_array  table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_stt_cat
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT sttc.id_category, sttc.id_sample_text_type
              FROM alert_default.sample_text_type_cat sttc
              JOIN sample_text_type stt
                ON stt.id_sample_text_type = sttc.id_sample_text_type
             WHERE sttc.id_market = c_market
               AND sttc.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_DIAG_INST_SOFT CURSOR';
                OPEN c_stt_cat(i_version(i), i_market(j));
                LOOP
                    FETCH c_stt_cat
                        INTO l_sttc_id_category, l_id_stt_def;
                    EXIT WHEN c_stt_cat%NOTFOUND;
                
                    SELECT COUNT(1)
                      INTO l_count
                      FROM sample_text_type_cat sttc
                     WHERE sttc.id_sample_text_type = l_id_stt_def
                       AND sttc.id_category = l_sttc_id_category
                       AND sttc.id_institution = i_id_institution;
                
                    IF l_count = 0
                       AND l_id_stt_def != 0
                    THEN
                        l_st_type_array.extend;
                        l_st_cat_array.extend;
                    
                        l_st_type_array(l_index) := l_id_stt_def;
                        l_st_cat_array(l_index) := l_sttc_id_category;
                    
                        l_index := l_index + 1;
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_INTERV_INST_SOFT CURSOR';
                CLOSE c_stt_cat;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_INTERV CURSOR';
        OPEN o_st_types FOR
            SELECT column_value
              FROM TABLE(CAST(l_st_type_array AS table_number));
    
        g_error := 'CLOSE O_INTERV CURSOR';
        OPEN o_st_categories FOR
            SELECT column_value
              FROM TABLE(CAST(l_st_cat_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_SAMPLE_TEXT',
                                              o_error);
            pk_types.open_my_cursor(o_st_types);
            pk_types.open_my_cursor(o_st_categories);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_sample_text;

    /********************************************************************************************
    * Set Sample texts for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_diag           Cursor of Instituition Diagnosis
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/02
    ********************************************************************************************/
    FUNCTION set_inst_sample_text
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_inst_sttc      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_st_type pk_types.cursor_type;
        l_c_st_cat  pk_types.cursor_type;
    
        l_data_stt   table_number;
        l_data_stcat table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        --SAMPLE_TEXT_TYPE_CAT
        IF NOT get_inst_sample_text(i_lang, i_market, i_version, i_id_institution, l_c_st_type, l_c_st_cat, l_error)
        THEN
            RAISE l_exception;
        ELSE
        
            o_inst_sttc := l_c_st_type;
        
            LOOP
                FETCH l_c_st_type BULK COLLECT
                    INTO l_data_stt LIMIT g_array_size;
            
                FETCH l_c_st_cat BULK COLLECT
                    INTO l_data_stcat LIMIT g_array_size;
            
                FORALL j IN 1 .. l_data_stt.count
                    INSERT INTO sample_text_type_cat
                        ( id_sample_text_type, id_category, id_institution)
                    VALUES
                        ( l_data_stt(j), l_data_stcat(j), i_id_institution);
            
                EXIT WHEN l_c_st_type%NOTFOUND;
            
            END LOOP;
        
            CLOSE l_c_st_type;
        
            CLOSE l_c_st_cat;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_SAMPLE_TEXT',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_SAMPLE_TEXT',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_sample_text;

    /********************************************************************************************
    * Get Hidrics set of markets, versions and sotwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_hidrics               Cursor of hidrics
    * @param o_hidrics_types         Cursor of hidrics types
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/03
    ********************************************************************************************/
    FUNCTION get_inst_hidrics
    (
        i_lang           IN language.id_language%TYPE,
        i_id_market      IN market.id_market%TYPE,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_hidrics        OUT pk_types.cursor_type,
        o_hidrics_types  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --HIDRICS
        l_id_hidrics_def hidrics.id_hidrics%TYPE;
        l_id_hidrics     hidrics.id_hidrics%TYPE;
    
        --HIDRICS_TYPE
        l_id_hidrics_type_def hidrics_type.id_hidrics_type%TYPE;
        l_id_hidrics_type     hidrics_type.id_hidrics_type%TYPE;
    
        l_hidrics_array       table_number := table_number();
        l_hidrics_types_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_hidrics_inst_soft
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT hr.id_hidrics, hr.id_hidrics_type
              FROM alert_default.hidrics_relation hr
              JOIN alert_default.hidrics_relation_mrk_vrs htmv
                ON htmv.id_hidrics_relation = hr.id_hidrics_relation
               AND htmv.id_market = c_market
               AND htmv.version = c_version
             WHERE hr.id_software = c_id_software
               AND hr.flg_state = pk_alert_constant.g_active
               AND hr.flg_available = g_flg_available
               AND hr.id_market = htmv.id_market;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
            g_error := 'OPEN C_HIDRICS_INST_SOFT CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS ' || g_error);
            OPEN c_hidrics_inst_soft(i_id_software, i_version(i), i_id_market);
            LOOP
                FETCH c_hidrics_inst_soft
                    INTO l_id_hidrics_def, l_id_hidrics_type_def;
                EXIT WHEN c_hidrics_inst_soft%NOTFOUND;
            
                --HIDRICS_TYPE
                SELECT nvl((SELECT ht.id_hidrics_type
                             FROM hidrics_type ht
                            WHERE ht.id_content = (SELECT ht2.id_content
                                                     FROM alert_default.hidrics_type ht2
                                                    WHERE ht2.id_hidrics_type = l_id_hidrics_type_def
                                                      AND ht2.flg_available = g_flg_available)
                              AND ht.id_content IS NOT NULL
                              AND ht.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_hidrics_type
                  FROM dual;
            
                --HIDRICS
                SELECT nvl((SELECT h.id_hidrics
                             FROM hidrics h
                            WHERE h.id_content = (SELECT h2.id_content
                                                    FROM alert_default.hidrics h2
                                                   WHERE h2.id_hidrics = l_id_hidrics_def
                                                     AND h2.flg_available = g_flg_available)
                              AND h.id_content IS NOT NULL
                              AND h.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_hidrics
                  FROM dual;
            
                IF l_id_hidrics != 0
                   AND l_id_hidrics_type != 0
                THEN
                    --HIDRICS_RELATION
                    SELECT COUNT(hr.id_hidrics_relation)
                      INTO l_count
                      FROM hidrics_relation hr
                     WHERE hr.id_hidrics_type = l_id_hidrics_type
                       AND hr.id_hidrics = l_id_hidrics
                       AND hr.id_institution = i_id_institution
                       AND hr.id_software = i_id_software
                       AND hr.id_department = 0
                       AND hr.id_dept = 0
                       AND hr.id_market = i_id_market;
                
                    IF l_count = 0
                    THEN
                        l_hidrics_array.extend;
                        l_hidrics_types_array.extend;
                    
                        l_hidrics_array(l_index) := l_id_hidrics;
                        l_hidrics_types_array(l_index) := l_id_hidrics_type;
                    
                        l_index := l_index + 1;
                    END IF;
                
                END IF;
            
            END LOOP;
        
            g_error := 'CLOSE C_HIDRICS_INST_SOFT CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS ' || g_error);
            CLOSE c_hidrics_inst_soft;
        
        END LOOP;
    
        g_error := 'CLOSE O_HIDRICS CURSOR';
        OPEN o_hidrics FOR
            SELECT column_value
              FROM TABLE(CAST(l_hidrics_array AS table_number));
    
        g_error := 'CLOSE O_HIDRICS_TYPES CURSOR';
        OPEN o_hidrics_types FOR
            SELECT column_value
              FROM TABLE(CAST(l_hidrics_types_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_HIDRICS',
                                              o_error);
            pk_types.open_my_cursor(o_hidrics);
            pk_types.open_my_cursor(o_hidrics_types);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_hidrics;

    /********************************************************************************************
    * Set Hidrics for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_hidrics        Cursor of Instituition Hidrics
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/03
    ********************************************************************************************/
    FUNCTION set_inst_hidrics
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_hidrics   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_hr_hidrics       pk_types.cursor_type;
        l_c_hr_hidrics_types pk_types.cursor_type;
    
        l_data_hidrics       table_number;
        l_data_hidrics_types table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
        --Execute all the Checklist relations
        l_c_hdrcs_charact table_number := table_number();
        l_c_hdrcs_way     table_number := table_number();
        l_c_hdrcs_confs   table_number := table_number();
    
    BEGIN
    
        FOR j IN 1 .. i_market.count
        LOOP
            FOR i IN 1 .. i_software.count
            LOOP
                --HIDRICS_REALTION
                IF NOT get_inst_hidrics(i_lang,
                                        i_market(j),
                                        i_version,
                                        i_id_institution,
                                        i_software(i),
                                        l_c_hr_hidrics,
                                        l_c_hr_hidrics_types,
                                        l_error)
                THEN
                    RAISE l_exception;
                ELSE
                
                    o_inst_hidrics := l_c_hr_hidrics;
                
                    LOOP
                        FETCH l_c_hr_hidrics BULK COLLECT
                            INTO l_data_hidrics LIMIT g_array_size;
                    
                        FETCH l_c_hr_hidrics_types BULK COLLECT
                            INTO l_data_hidrics_types LIMIT g_array_size;
                    
                        FORALL k IN 1 .. l_data_hidrics.count
                            INSERT INTO hidrics_relation
                                (id_hidrics_relation,
                                 id_hidrics_type,
                                 id_hidrics,
                                 flg_state,
                                 flg_available,
                                 id_software,
                                 id_institution,
                                 id_department,
                                 id_dept,
                                 id_market)
                            VALUES
                                (seq_hidrics_relation.nextval,
                                 l_data_hidrics_types(k),
                                 l_data_hidrics(k),
                                 pk_alert_constant.g_active,
                                 g_flg_available,
                                 i_software(i),
                                 i_id_institution,
                                 0,
                                 0,
                                 i_market(j));
                    
                        EXIT WHEN l_c_hr_hidrics%NOTFOUND;
                    
                    END LOOP;
                
                    CLOSE l_c_hr_hidrics;
                    CLOSE l_c_hr_hidrics_types;
                
                END IF;
            
            END LOOP;
        
            -->Insere as Hidrics_Way         
            g_error := 'SET_INST_HIDRICS_WAY';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS ' || g_error);
            IF NOT set_def_hidrics_way(i_lang, i_market(j), i_id_institution, l_c_hdrcs_way, l_error)
            THEN
                RAISE l_exception;
            END IF;
        
            -->Insere as Hidrics_Charact         
            g_error := 'SET_INST_HIDRICS_CHARACT';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS ' || g_error);
            IF NOT set_def_hidrics_charact(i_lang, i_market(j), i_id_institution, l_c_hdrcs_charact, l_error)
            THEN
                RAISE l_exception;
            END IF;
        
            -->Insere as Hidrics_Configurations      
            g_error := 'SET_INST_HIDRICS_CONFIGURATION';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS ' || g_error);
            IF NOT set_inst_hidrics_configuration(i_lang, i_market(j), i_id_institution, l_c_hdrcs_confs, l_error)
            THEN
                RAISE l_exception;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_hidrics;
    /********************************************************************************************
    * Get Transports entities set of markets, versions and sotwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_hidrics               Cursor of hidrics
    * @param o_hidrics_types         Cursor of hidrics types
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/03
    ********************************************************************************************/
    FUNCTION get_inst_transp_entity
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_transp_entity  OUT pk_types.cursor_type,
        o_tei_flg_type   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --TRANSP_ENTITY
        l_id_transp_entity_def transp_entity.id_transp_entity%TYPE;
        l_id_transp_entity     transp_entity.id_transp_entity%TYPE;
    
        --TRANSP_ENT_INST
        l_tei_flg_type VARCHAR2(1);
    
        l_te_array          table_number := table_number();
        l_te_flg_type_array table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_transp_entity_inst
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT temv.id_transp_entity, pk_alert_constant.g_active
              FROM alert_default.transp_entity_mrk_vrs temv
             WHERE temv.id_market = c_market
               AND temv.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_TRANSP_ENTITY_INST CURSOR';
                OPEN c_transp_entity_inst(i_version(i), i_market(j));
                LOOP
                    FETCH c_transp_entity_inst
                        INTO l_id_transp_entity_def, l_tei_flg_type;
                    EXIT WHEN c_transp_entity_inst%NOTFOUND;
                
                    --TRANSP_ENTITY
                    SELECT nvl((SELECT te.id_transp_entity
                                 FROM transp_entity te
                                WHERE te.id_content =
                                      (SELECT te2.id_content
                                         FROM alert_default.transp_entity te2
                                        WHERE te2.id_transp_entity = l_id_transp_entity_def)
                                  AND te.id_content IS NOT NULL
                                  AND te.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_transp_entity
                      FROM dual;
                
                    IF l_id_transp_entity != 0
                    THEN
                        --TRANSP_ENT_INST
                        SELECT COUNT(tei.id_transp_ent_inst)
                          INTO l_count
                          FROM transp_ent_inst tei
                         WHERE tei.id_institution = i_id_institution
                           AND tei.id_transp_entity = l_id_transp_entity
                           AND tei.flg_type = l_tei_flg_type
                           AND tei.flg_available = pk_alert_constant.get_yes;
                    
                        IF l_count = 0
                        THEN
                            l_te_array.extend;
                            l_te_flg_type_array.extend;
                        
                            l_te_array(l_index) := l_id_transp_entity;
                            l_te_flg_type_array(l_index) := l_tei_flg_type;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_TRANSP_ENTITY_INST CURSOR';
                CLOSE c_transp_entity_inst;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_TRANSP_ENTITY CURSOR';
        OPEN o_transp_entity FOR
            SELECT column_value
              FROM TABLE(CAST(l_te_array AS table_number));
    
        g_error := 'CLOSE O_TEI_FLG_TYPE CURSOR';
        OPEN o_tei_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_te_flg_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_TRANSP_ENTITY',
                                              o_error);
            pk_types.open_my_cursor(o_transp_entity);
            pk_types.open_my_cursor(o_tei_flg_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_transp_entity;

    /********************************************************************************************
    * Set Transports for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_inst_transp         Cursor of Instituition Transports
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/03
    ********************************************************************************************/
    FUNCTION set_inst_transp
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_inst_transp    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_te           pk_types.cursor_type;
        l_c_tei_flg_type pk_types.cursor_type;
    
        l_data_te           table_number;
        l_data_tei_flg_type table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        --TRANSP_ENTITY
        IF NOT get_inst_transp_entity(i_lang, i_market, i_version, i_id_institution, l_c_te, l_c_tei_flg_type, l_error)
        THEN
            RAISE l_exception;
        ELSE
        
            o_inst_transp := l_c_te;
        
            LOOP
                FETCH l_c_te BULK COLLECT
                    INTO l_data_te LIMIT g_array_size;
            
                FETCH l_c_tei_flg_type BULK COLLECT
                    INTO l_data_tei_flg_type LIMIT g_array_size;
            
                FORALL j IN 1 .. l_data_te.count
                    INSERT INTO transp_ent_inst
                        (id_institution, id_transp_ent_inst, id_transp_entity, flg_available, flg_type)
                    VALUES
                        (i_id_institution,
                         seq_transp_ent_inst.nextval,
                         l_data_te(j),
                         g_flg_available,
                         l_data_tei_flg_type(j));
            
                EXIT WHEN l_c_te%NOTFOUND;
            
            END LOOP;
        
            CLOSE l_c_te;
            CLOSE l_c_tei_flg_type;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_TRANSP',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_TRANSP',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_transp;

    /********************************************************************************************
    * Get Discharge instructions for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_disch_instr         Cursor of discharge instructions
    * @param o_disch_instr_group   Cursor of discharge instructions groups
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/06
    ********************************************************************************************/
    FUNCTION get_inst_disch_instr
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_id_software       IN software.id_software%TYPE,
        o_disch_instr       OUT pk_types.cursor_type,
        o_disch_instr_group OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --DISCH_INSTR_RELATION
        l_id_disch_instr_def       disch_instr_relation.id_disch_instructions%TYPE;
        l_id_disch_instr           disch_instr_relation.id_disch_instructions%TYPE;
        l_id_disch_instr_group_def disch_instr_relation.id_disch_instructions_group%TYPE;
        l_id_disch_instr_group     disch_instr_relation.id_disch_instructions_group%TYPE;
    
        l_disch_instr_array       table_number := table_number();
        l_disch_instr_group_array table_number := table_number();
        l_count                   NUMBER := 0;
        l_index                   NUMBER := 1;
    
        CURSOR c_disch_instr_relation
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT dir.id_disch_instructions, dir.id_disch_instructions_group
              FROM alert_default.disch_instr_relation dir
             WHERE dir.id_software = c_id_software
               AND dir.id_market = c_market
               AND dir.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_DISCH_INSTR_RELATION CURSOR';
                OPEN c_disch_instr_relation(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_disch_instr_relation
                        INTO l_id_disch_instr_def, l_id_disch_instr_group_def;
                    EXIT WHEN c_disch_instr_relation%NOTFOUND;
                
                    --DISCH_INSTRUCTIONS
                    SELECT nvl((SELECT di.id_disch_instructions
                                 FROM disch_instructions di
                                WHERE di.id_content =
                                      (SELECT di2.id_content
                                         FROM alert_default.disch_instructions di2
                                        WHERE di2.id_disch_instructions = l_id_disch_instr_def)
                                  AND di.id_content IS NOT NULL
                                  AND di.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_disch_instr
                      FROM dual;
                
                    --DISCH_INSTRUCTIONS_GROUP            
                    SELECT nvl((SELECT dig.id_disch_instructions_group
                                 FROM disch_instructions_group dig
                                WHERE dig.id_content =
                                      (SELECT dig2.id_content
                                         FROM alert_default.disch_instructions_group dig2
                                        WHERE dig2.id_disch_instructions_group = l_id_disch_instr_group_def)
                                  AND dig.id_content IS NOT NULL
                                  AND dig.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_disch_instr_group
                      FROM dual;
                
                    IF l_id_disch_instr != 0
                       AND l_id_disch_instr_group != 0
                    THEN
                    
                        --DISCH_INSTR_RELATION
                        SELECT COUNT(dir.id_disch_instr_relation)
                          INTO l_count
                          FROM disch_instr_relation dir
                         WHERE dir.id_disch_instructions = l_id_disch_instr
                           AND dir.id_disch_instructions_group = l_id_disch_instr_group
                           AND dir.id_institution = i_id_institution
                           AND dir.id_software = i_id_software;
                    
                        IF l_count = 0
                        THEN
                        
                            l_disch_instr_array.extend;
                            l_disch_instr_group_array.extend;
                        
                            l_disch_instr_array(l_index) := l_id_disch_instr;
                            l_disch_instr_group_array(l_index) := l_id_disch_instr_group;
                        
                            l_index := l_index + 1;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_DISCH_INSTR_RELATION CURSOR';
                CLOSE c_disch_instr_relation;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_DISCH_INSTR CURSOR';
        OPEN o_disch_instr FOR
            SELECT column_value
              FROM TABLE(CAST(l_disch_instr_array AS table_number));
    
        g_error := 'CLOSE O_DISCH_INSTR_GROUP CURSOR';
        OPEN o_disch_instr_group FOR
            SELECT column_value
              FROM TABLE(CAST(l_disch_instr_group_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_DISCH_INSTR',
                                              o_error);
            pk_types.open_my_cursor(o_disch_instr);
            pk_types.open_my_cursor(o_disch_instr_group);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_disch_instr;

    /********************************************************************************************
    * Get Discharge instructions for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_disch_reason        Cursor of discharge reason
    * @param o_disch_dest          Cursor of discharge destinations
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/06
    ********************************************************************************************/
    FUNCTION get_inst_disch_reas_dest
    (
        i_lang                   IN language.id_language%TYPE,
        i_market                 IN table_number,
        i_version                IN table_varchar,
        i_id_institution         IN institution.id_institution%TYPE,
        i_id_software            IN software.id_software%TYPE,
        o_disch_reason           OUT pk_types.cursor_type,
        o_disch_dest             OUT pk_types.cursor_type,
        o_drd_flg_diag           OUT pk_types.cursor_type,
        o_drd_report_name        OUT pk_types.cursor_type,
        o_drd_id_epis_type       OUT pk_types.cursor_type,
        o_drd_type_screen        OUT pk_types.cursor_type,
        o_drd_id_reports         OUT pk_types.cursor_type,
        o_drd_flg_mcdt           OUT pk_types.cursor_type,
        o_drd_flg_care_stage     OUT pk_types.cursor_type,
        o_drd_flg_default        OUT pk_types.cursor_type,
        o_rank                   OUT pk_types.cursor_type,
        o_flg_specify_dest       OUT pk_types.cursor_type,
        o_flg_rep_notes          OUT pk_types.cursor_type,
        o_flg_def_disch_status   OUT pk_types.cursor_type,
        o_id_def_disch_status    OUT pk_types.cursor_type,
        o_flg_needs_overall_resp OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --DISCH_REAS_DEST
        l_drd_id_disch_reason_def    disch_reas_dest.id_discharge_reason%TYPE;
        l_drd_id_disch_reason        disch_reas_dest.id_discharge_reason%TYPE;
        l_drd_id_disch_dest_def      disch_reas_dest.id_discharge_dest%TYPE;
        l_drd_id_disch_dest          disch_reas_dest.id_discharge_dest%TYPE;
        l_drd_flg_diag               disch_reas_dest.flg_diag%TYPE;
        l_drd_report_name            disch_reas_dest.report_name%TYPE;
        l_drd_id_epis_type           disch_reas_dest.id_epis_type%TYPE;
        l_drd_type_screen            disch_reas_dest.type_screen%TYPE;
        l_drd_id_reports             disch_reas_dest.id_reports%TYPE;
        l_drd_flg_mcdt               disch_reas_dest.flg_mcdt%TYPE;
        l_drd_flg_care_stage         disch_reas_dest.flg_care_stage%TYPE;
        l_drd_flg_default            disch_reas_dest.flg_default%TYPE;
        l_drd_rank                   disch_reas_dest.rank%TYPE;
        l_drd_flg_specify_dest       disch_reas_dest.flg_specify_dest%TYPE;
        l_drd_flg_rep_notes          disch_reas_dest.flg_rep_notes%TYPE;
        l_drd_flg_def_disch_status   disch_reas_dest.flg_def_disch_status%TYPE;
        l_drd_id_def_disch_status    disch_reas_dest.id_def_disch_status%TYPE;
        l_drd_flg_needs_overall_resp disch_reas_dest.flg_needs_overall_resp%TYPE;
    
        l_disch_reason_array        table_number := table_number();
        l_disch_dest_array          table_number := table_number();
        l_drd_flg_diag_array        table_varchar := table_varchar();
        l_drd_report_name_array     table_varchar := table_varchar();
        l_drd_id_epis_type_array    table_number := table_number();
        l_drd_type_screen_array     table_varchar := table_varchar();
        l_drd_id_reports_array      table_number := table_number();
        l_drd_flg_mcdt_array        table_varchar := table_varchar();
        l_drd_flg_care_stage_array  table_varchar := table_varchar();
        l_drd_flg_default_array     table_varchar := table_varchar();
        l_drd_rank_array            table_number := table_number();
        l_drd_specify_dest          table_varchar := table_varchar();
        l_drd_rep_notes             table_varchar := table_varchar();
        l_drd_def_disch_status      table_varchar := table_varchar();
        l_drd_id_def_disch_status_a table_number := table_number();
        l_drd_flg_overall_resp      table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_disch_reas_dest
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT drs.id_discharge_reason,
                            drs.id_discharge_dest,
                            drs.flg_diag,
                            drs.report_name,
                            drs.id_epis_type,
                            drs.type_screen,
                            drs.id_reports,
                            drs.flg_mcdt,
                            drs.flg_care_stage,
                            drs.flg_default,
                            drs.rank,
                            drs.flg_specify_dest,
                            drs.flg_rep_notes,
                            drs.flg_def_disch_status,
                            drs.id_def_disch_status,
                            drs.flg_needs_overall_resp
              FROM alert_default.disch_reas_dest drs
             INNER JOIN alert_default.discharge_reason_mrk_vrs drmk
                ON (drmk.id_discharge_reason = drs.id_discharge_reason AND drmk.version = drs.version AND
                   drmk.id_market = drs.id_market)
             INNER JOIN alert_default.discharge_dest_mrk_vrs ddmv
                ON (ddmv.id_discharge_dest = drs.id_discharge_dest AND ddmv.id_market = drs.id_market AND
                   ddmv.version = drs.version)
             WHERE drs.id_clinical_service IS NULL
               AND drs.id_software_param = c_id_software
               AND drs.id_market = c_market
               AND drs.version = c_version
               AND drs.flg_active = pk_alert_constant.g_active;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN c_disch_reas_dest CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
            
                OPEN c_disch_reas_dest(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_disch_reas_dest
                        INTO l_drd_id_disch_reason_def,
                             l_drd_id_disch_dest_def,
                             l_drd_flg_diag,
                             l_drd_report_name,
                             l_drd_id_epis_type,
                             l_drd_type_screen,
                             l_drd_id_reports,
                             l_drd_flg_mcdt,
                             l_drd_flg_care_stage,
                             l_drd_flg_default,
                             l_drd_rank,
                             l_drd_flg_specify_dest,
                             l_drd_flg_rep_notes,
                             l_drd_flg_def_disch_status,
                             l_drd_id_def_disch_status,
                             l_drd_flg_needs_overall_resp;
                    EXIT WHEN c_disch_reas_dest%NOTFOUND;
                
                    g_error := 'l_drd_id_disch_reason';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
                
                    --DISCHARGE_REASON
                    SELECT nvl((SELECT dr.id_discharge_reason
                                 FROM discharge_reason dr
                                WHERE dr.id_content =
                                      (SELECT dr2.id_content
                                         FROM alert_default.discharge_reason dr2
                                        WHERE dr2.id_discharge_reason = l_drd_id_disch_reason_def)
                                  AND dr.id_content IS NOT NULL
                                  AND dr.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_drd_id_disch_reason
                      FROM dual;
                
                    g_error := 'l_drd_id_disch_dest';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
                
                    --DISCHARGE_DEST
                    SELECT nvl((SELECT dd.id_discharge_dest
                                 FROM discharge_dest dd
                                WHERE dd.id_content =
                                      (SELECT dd2.id_content
                                         FROM alert_default.discharge_dest dd2
                                        WHERE dd2.id_discharge_dest = l_drd_id_disch_dest_def)
                                  AND dd.id_content IS NOT NULL
                                  AND dd.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_drd_id_disch_dest
                      FROM dual;
                
                    IF l_drd_id_disch_reason != 0
                       AND l_drd_id_disch_dest != 0
                    THEN
                    
                        g_error := 'l_count';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
                    
                        --DISCH_REAS_DEST
                        SELECT COUNT(drs.id_disch_reas_dest)
                          INTO l_count
                          FROM disch_reas_dest drs
                         WHERE drs.id_discharge_reason = l_drd_id_disch_reason
                           AND drs.id_discharge_dest = l_drd_id_disch_dest
                           AND drs.id_instit_param = i_id_institution
                           AND drs.id_software_param = i_id_software
                           AND drs.flg_active = pk_alert_constant.g_active;
                    
                        g_error := 'IF l_count = 0 then';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
                    
                        IF l_count = 0
                        THEN
                        
                            l_disch_reason_array.extend;
                            l_disch_dest_array.extend;
                            l_drd_flg_diag_array.extend;
                            l_drd_report_name_array.extend;
                            l_drd_id_epis_type_array.extend;
                            l_drd_type_screen_array.extend;
                            l_drd_id_reports_array.extend;
                            l_drd_flg_mcdt_array.extend;
                            l_drd_flg_care_stage_array.extend;
                            l_drd_flg_default_array.extend;
                            l_drd_rank_array.extend;
                            l_drd_specify_dest.extend;
                            l_drd_rep_notes.extend;
                            l_drd_def_disch_status.extend;
                            l_drd_id_def_disch_status_a.extend;
                            l_drd_flg_overall_resp.extend;
                        
                            l_disch_reason_array(l_index) := l_drd_id_disch_reason;
                            l_disch_dest_array(l_index) := l_drd_id_disch_dest;
                            l_drd_flg_diag_array(l_index) := l_drd_flg_diag;
                            l_drd_report_name_array(l_index) := l_drd_report_name;
                            l_drd_id_epis_type_array(l_index) := l_drd_id_epis_type;
                            l_drd_type_screen_array(l_index) := l_drd_type_screen;
                            l_drd_id_reports_array(l_index) := l_drd_id_reports;
                            l_drd_flg_mcdt_array(l_index) := l_drd_flg_mcdt;
                            l_drd_flg_care_stage_array(l_index) := l_drd_flg_care_stage;
                            l_drd_flg_default_array(l_index) := l_drd_flg_default;
                            l_drd_rank_array(l_index) := l_drd_rank;
                            l_drd_specify_dest(l_index) := l_drd_flg_specify_dest;
                            l_drd_rep_notes(l_index) := l_drd_flg_rep_notes;
                            l_drd_def_disch_status(l_index) := l_drd_flg_def_disch_status;
                            l_drd_id_def_disch_status_a(l_index) := l_drd_id_def_disch_status;
                            l_drd_flg_overall_resp(l_index) := l_drd_flg_needs_overall_resp;
                        
                            l_index := l_index + 1;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE c_disch_reas_dest CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
            
                CLOSE c_disch_reas_dest;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_DISCH_REASON CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_disch_reason FOR
            SELECT column_value
              FROM TABLE(CAST(l_disch_reason_array AS table_number));
    
        g_error := 'CLOSE O_DISCH_DEST CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_disch_dest FOR
            SELECT column_value
              FROM TABLE(CAST(l_disch_dest_array AS table_number));
    
        g_error := 'CLOSE O_DRD_FLG_DIAG CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_drd_flg_diag FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_flg_diag_array AS table_varchar));
    
        g_error := 'CLOSE O_DRD_REPORT_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_drd_report_name FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_report_name_array AS table_varchar));
    
        g_error := 'CLOSE O_DRD_ID_EPIS_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_drd_id_epis_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_id_epis_type_array AS table_number));
    
        g_error := 'CLOSE O_DRD_TYPE_SCREEN CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_drd_type_screen FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_type_screen_array AS table_varchar));
    
        g_error := 'CLOSE O_DRD_ID_REPORTS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_drd_id_reports FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_id_reports_array AS table_number));
    
        g_error := 'CLOSE O_DRD_FLG_MCDT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_drd_flg_mcdt FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_flg_mcdt_array AS table_varchar));
    
        g_error := 'CLOSE o_drd_flg_care_stage CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_drd_flg_care_stage FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_flg_care_stage_array AS table_varchar));
    
        g_error := 'CLOSE o_drd_flg_default CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_disch_reas_dest ' || g_error);
    
        OPEN o_drd_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_flg_default_array AS table_varchar));
    
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_rank_array AS table_number));
        OPEN o_flg_specify_dest FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_specify_dest AS table_varchar));
        OPEN o_flg_rep_notes FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_rep_notes AS table_varchar));
        OPEN o_flg_def_disch_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_def_disch_status AS table_varchar));
        OPEN o_id_def_disch_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_id_def_disch_status_a AS table_number));
        OPEN o_flg_needs_overall_resp FOR
            SELECT column_value
              FROM TABLE(CAST(l_drd_flg_overall_resp AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_DISCH_REAS_DEST',
                                              o_error);
            pk_types.open_my_cursor(o_disch_reason);
            pk_types.open_my_cursor(o_disch_dest);
            pk_types.open_my_cursor(o_drd_flg_diag);
            pk_types.open_my_cursor(o_drd_report_name);
            pk_types.open_my_cursor(o_drd_id_epis_type);
            pk_types.open_my_cursor(o_drd_type_screen);
            pk_types.open_my_cursor(o_drd_id_reports);
            pk_types.open_my_cursor(o_drd_flg_mcdt);
            pk_types.open_my_cursor(o_drd_flg_care_stage);
            pk_types.open_my_cursor(o_drd_flg_default);
            pk_types.open_my_cursor(o_rank);
            pk_types.open_my_cursor(o_flg_specify_dest);
            pk_types.open_my_cursor(o_flg_rep_notes);
            pk_types.open_my_cursor(o_flg_def_disch_status);
            pk_types.open_my_cursor(o_id_def_disch_status);
            pk_types.open_my_cursor(o_flg_needs_overall_resp);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_disch_reas_dest;

    /********************************************************************************************
    * Set Discharges for a specific institution
    *
    * @param i_lang                   Prefered language ID
    * @param i_market                 Market ID's
    * @param i_version                ALERT version's
    * @param i_id_institution         Institution ID
    * @param i_software               Software ID's
    * @param o_inst_disch_instr       Cursor of Instituition Discharges Intructions
    * @param o_inst_disch_instr_group Cursor of Instituition Discharges Intructions Groups
    * @param o_inst_disch_reason      Cursor of Instituition Discharges Reasons
    * @param o_inst_disch_dest        Cursor of Instituition Discharges Destines
    * @param o_error                  Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/06
    ********************************************************************************************/
    FUNCTION set_inst_discharges
    (
        i_lang                   IN language.id_language%TYPE,
        i_market                 IN table_number,
        i_version                IN table_varchar,
        i_id_institution         IN institution.id_institution%TYPE,
        i_software               IN table_number,
        o_inst_disch_instr       OUT pk_types.cursor_type,
        o_inst_disch_instr_group OUT pk_types.cursor_type,
        o_inst_disch_reason      OUT pk_types.cursor_type,
        o_inst_disch_dest        OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_disch_instr       table_number;
        l_data_disch_instr_group table_number;
    
        l_data_disch_reason        table_number;
        l_data_disch_dest          table_number;
        l_data_drd_flg_diag        table_varchar;
        l_data_drd_report_name     table_varchar;
        l_data_drd_id_epis_type    table_number;
        l_data_drd_type_screen     table_varchar;
        l_data_drd_id_reports      table_number;
        l_data_drd_flg_mcdt        table_varchar;
        l_data_drd_flg_care_stage  table_varchar;
        l_data_drd_flg_default     table_varchar;
        l_data_rank_array          table_number;
        l_data_specify_dest        table_varchar;
        l_data_rep_notes           table_varchar;
        l_data_def_disch_status    table_varchar;
        l_data_id_def_disch_status table_number;
        l_data_flg_overall_resp    table_varchar;
    
        l_c_disch_instr       pk_types.cursor_type;
        l_c_disch_instr_group pk_types.cursor_type;
    
        l_c_disch_reason            pk_types.cursor_type;
        l_c_disch_dest              pk_types.cursor_type;
        l_c_drd_flg_diag            pk_types.cursor_type;
        l_c_drd_report_name         pk_types.cursor_type;
        l_c_drd_id_epis_type        pk_types.cursor_type;
        l_c_drd_type_screen         pk_types.cursor_type;
        l_c_drd_id_reports          pk_types.cursor_type;
        l_c_drd_flg_mcdt            pk_types.cursor_type;
        l_c_drd_flg_care_stage      pk_types.cursor_type;
        l_c_drd_flg_default         pk_types.cursor_type;
        l_c_drd_rank                pk_types.cursor_type;
        l_c_drd_specify_dest        pk_types.cursor_type;
        l_c_drd_rep_notes           pk_types.cursor_type;
        l_c_drd_def_disch_status    pk_types.cursor_type;
        l_c_drd_id_def_disch_status pk_types.cursor_type;
        l_c_drd_flg_overall_resp    pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT get_inst_disch_instr';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_discharges ' || g_error);
        
            IF NOT get_inst_disch_instr(i_lang,
                                        i_market,
                                        i_version,
                                        i_id_institution,
                                        i_software(i),
                                        l_c_disch_instr,
                                        l_c_disch_instr_group,
                                        l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_disch_instr       := l_c_disch_instr;
                o_inst_disch_instr_group := l_c_disch_instr_group;
            
                LOOP
                    FETCH l_c_disch_instr BULK COLLECT
                        INTO l_data_disch_instr LIMIT g_array_size;
                
                    FETCH l_c_disch_instr_group BULK COLLECT
                        INTO l_data_disch_instr_group LIMIT g_array_size;
                
                    g_error := 'INSERT INTO disch_instr_relation';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_discharges ' || g_error);
                
                    FORALL j IN 1 .. l_data_disch_instr.count
                        INSERT INTO disch_instr_relation
                            (id_disch_instr_relation,
                             id_disch_instructions,
                             id_disch_instructions_group,
                             id_institution,
                             id_software)
                        VALUES
                            (seq_disch_instr_relation.nextval,
                             l_data_disch_instr(j),
                             l_data_disch_instr_group(j),
                             i_id_institution,
                             i_software(i));
                
                    EXIT WHEN l_c_disch_instr%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_disch_instr;
            
                CLOSE l_c_disch_instr_group;
            
            END IF;
        
            g_error := 'IF NOT get_inst_disch_reas_dest';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_discharges ' || g_error);
        
            IF NOT get_inst_disch_reas_dest(i_lang,
                                            i_market,
                                            i_version,
                                            i_id_institution,
                                            i_software(i),
                                            l_c_disch_reason,
                                            l_c_disch_dest,
                                            l_c_drd_flg_diag,
                                            l_c_drd_report_name,
                                            l_c_drd_id_epis_type,
                                            l_c_drd_type_screen,
                                            l_c_drd_id_reports,
                                            l_c_drd_flg_mcdt,
                                            l_c_drd_flg_care_stage,
                                            l_c_drd_flg_default,
                                            l_c_drd_rank,
                                            l_c_drd_specify_dest,
                                            l_c_drd_rep_notes,
                                            l_c_drd_def_disch_status,
                                            l_c_drd_id_def_disch_status,
                                            l_c_drd_flg_overall_resp,
                                            l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_disch_reason := l_c_disch_reason;
                o_inst_disch_dest   := l_c_disch_dest;
            
                LOOP
                    FETCH l_c_disch_reason BULK COLLECT
                        INTO l_data_disch_reason LIMIT g_array_size;
                
                    FETCH l_c_disch_dest BULK COLLECT
                        INTO l_data_disch_dest LIMIT g_array_size;
                
                    FETCH l_c_drd_flg_diag BULK COLLECT
                        INTO l_data_drd_flg_diag LIMIT g_array_size;
                
                    FETCH l_c_drd_report_name BULK COLLECT
                        INTO l_data_drd_report_name LIMIT g_array_size;
                
                    FETCH l_c_drd_id_epis_type BULK COLLECT
                        INTO l_data_drd_id_epis_type LIMIT g_array_size;
                
                    FETCH l_c_drd_type_screen BULK COLLECT
                        INTO l_data_drd_type_screen LIMIT g_array_size;
                
                    FETCH l_c_drd_id_reports BULK COLLECT
                        INTO l_data_drd_id_reports LIMIT g_array_size;
                
                    FETCH l_c_drd_flg_mcdt BULK COLLECT
                        INTO l_data_drd_flg_mcdt LIMIT g_array_size;
                
                    FETCH l_c_drd_flg_care_stage BULK COLLECT
                        INTO l_data_drd_flg_care_stage LIMIT g_array_size;
                
                    FETCH l_c_drd_flg_default BULK COLLECT
                        INTO l_data_drd_flg_default LIMIT g_array_size;
                
                    FETCH l_c_drd_rank BULK COLLECT
                        INTO l_data_rank_array LIMIT g_array_size;
                    FETCH l_c_drd_specify_dest BULK COLLECT
                        INTO l_data_specify_dest LIMIT g_array_size;
                    FETCH l_c_drd_rep_notes BULK COLLECT
                        INTO l_data_rep_notes LIMIT g_array_size;
                    FETCH l_c_drd_def_disch_status BULK COLLECT
                        INTO l_data_def_disch_status LIMIT g_array_size;
                    FETCH l_c_drd_id_def_disch_status BULK COLLECT
                        INTO l_data_id_def_disch_status LIMIT g_array_size;
                    FETCH l_c_drd_flg_overall_resp BULK COLLECT
                        INTO l_data_flg_overall_resp LIMIT g_array_size;
                
                    g_error := 'INSERT INTO disch_reas_dest';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_discharges ' || g_error);
                
                    FORALL j IN 1 .. l_data_disch_reason.count
                        INSERT INTO disch_reas_dest
                            (id_disch_reas_dest,
                             id_discharge_reason,
                             id_discharge_dest,
                             id_dep_clin_serv,
                             flg_active,
                             flg_diag,
                             id_institution,
                             id_instit_param,
                             id_software_param,
                             report_name,
                             id_epis_type,
                             type_screen,
                             id_department,
                             id_reports,
                             flg_mcdt,
                             flg_care_stage,
                             flg_default,
                             rank,
                             flg_specify_dest,
                             flg_rep_notes,
                             flg_def_disch_status,
                             id_def_disch_status,
                             flg_needs_overall_resp)
                        VALUES
                            (seq_disch_reas_dest.nextval,
                             l_data_disch_reason(j),
                             l_data_disch_dest(j),
                             NULL,
                             'A',
                             l_data_drd_flg_diag(j),
                             NULL,
                             i_id_institution,
                             i_software(i),
                             l_data_drd_report_name(j),
                             l_data_drd_id_epis_type(j),
                             l_data_drd_type_screen(j),
                             NULL,
                             l_data_drd_id_reports(j),
                             l_data_drd_flg_mcdt(j),
                             l_data_drd_flg_care_stage(j),
                             l_data_drd_flg_default(j),
                             l_data_rank_array(j),
                             l_data_specify_dest(j),
                             l_data_rep_notes(j),
                             l_data_def_disch_status(j),
                             l_data_id_def_disch_status(j),
                             l_data_flg_overall_resp(j));
                
                    EXIT WHEN l_c_disch_reason%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_disch_reason;
            
                CLOSE l_c_disch_dest;
            
                CLOSE l_c_drd_flg_diag;
            
                CLOSE l_c_drd_report_name;
            
                CLOSE l_c_drd_id_epis_type;
            
                CLOSE l_c_drd_type_screen;
            
                CLOSE l_c_drd_id_reports;
            
                CLOSE l_c_drd_flg_mcdt;
            
                CLOSE l_c_drd_flg_care_stage;
            
                CLOSE l_c_drd_flg_default;
            
                CLOSE l_c_drd_rank;
                CLOSE l_c_drd_specify_dest;
                CLOSE l_c_drd_rep_notes;
                CLOSE l_c_drd_def_disch_status;
                CLOSE l_c_drd_id_def_disch_status;
                CLOSE l_c_drd_flg_overall_resp;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DISCHARGES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DISCHARGES',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_discharges;

    /********************************************************************************************
    * Get ICNP Compositions set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_icnp_compo_parent   Cursor of icnp composition parents
    * @param o_icnp_compo          Cursor of icnp compositions
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/07
    ********************************************************************************************/
    FUNCTION get_inst_icnp_compo
    (
        i_lang                 IN language.id_language%TYPE,
        i_market               IN table_number,
        i_version              IN table_varchar,
        i_id_institution       IN institution.id_institution%TYPE,
        i_id_software          IN software.id_software%TYPE,
        o_icnp_compo_parent    OUT pk_types.cursor_type,
        o_icnp_compo           OUT pk_types.cursor_type,
        o_icnp_predifined_act1 OUT pk_types.cursor_type,
        o_icnp_predifined_hist OUT pk_types.cursor_type,
        o_icnp_predifined_act2 OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --ICNP_PREDIFINED_ACTION
        l_ipa_id_comp_parent_def  icnp_predefined_action.id_composition_parent%TYPE;
        l_ipa_id_comp_parent      icnp_predefined_action.id_composition_parent%TYPE;
        l_ipa_id_composition_def  icnp_predefined_action.id_composition%TYPE;
        l_ipa_id_composition      icnp_predefined_action.id_composition%TYPE;
        l_id_icnp_predifined_hist icnp_predefined_action_hist.id_predefined_action_hist%TYPE;
        l_id_icnp_predifined_act  icnp_predefined_action.id_predefined_action%TYPE;
    
        l_icnp_compo_parent_array    table_number := table_number();
        l_icnp_compo_array           table_number := table_number();
        l_icnp_predifined_hist_array table_number := table_number();
        l_icnp_predifined_act1_array table_number := table_number();
        l_icnp_predifined_act2_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_icnp_pa_inst_soft
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT ipa.id_composition_parent, ipa.id_composition
              FROM alert_default.icnp_predefined_action ipa
             WHERE ipa.id_market = c_market
               AND ipa.version = c_version
               AND ipa.id_software = c_id_software
               AND ipa.flg_available = pk_alert_constant.g_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_ICNP_PA_INST_SOFT CURSOR';
                OPEN c_icnp_pa_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_icnp_pa_inst_soft
                        INTO l_ipa_id_comp_parent_def, l_ipa_id_composition_def;
                    EXIT WHEN c_icnp_pa_inst_soft%NOTFOUND;
                
                    --ICNP_COMPOSSITION_PARENT
                    g_error := 'GET ALERT ICNP_COMPOSITION_PARENT ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_ICNP_COMPO ' || g_error);
                    SELECT nvl((SELECT ic.id_composition
                                 FROM icnp_composition ic
                                WHERE ic.id_content = (SELECT ic2.id_content
                                                         FROM alert_default.icnp_composition ic2
                                                        WHERE ic2.id_composition = l_ipa_id_comp_parent_def
                                                          AND ic2.id_software = i_id_software)
                                  AND ic.id_content IS NOT NULL
                                  AND ic.flg_available = pk_alert_constant.g_available
                                  AND ic.id_software = i_id_software
                                  AND ic.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_ipa_id_comp_parent
                      FROM dual;
                
                    --ICNP_COMPOSITION
                    g_error := 'GET ALERT ICNP_COMPOSITION ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_ICNP_COMPO ' || g_error);
                    SELECT nvl((SELECT ic.id_composition
                                 FROM icnp_composition ic
                                WHERE ic.id_content = (SELECT ic2.id_content
                                                         FROM alert_default.icnp_composition ic2
                                                        WHERE ic2.id_composition = l_ipa_id_composition_def
                                                          AND ic2.id_software = i_id_software)
                                  AND ic.id_content IS NOT NULL
                                  AND ic.flg_available = pk_alert_constant.g_available
                                  AND ic.id_software = i_id_software
                                  AND ic.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_ipa_id_composition
                      FROM dual;
                
                    IF l_ipa_id_composition != 0
                       AND l_ipa_id_comp_parent != 0
                    THEN
                        --ICNP_PREDIFINED_ACTION
                        g_error := 'COUNT EXISTING RESULTS';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_ICNP_COMPO ' || g_error);
                        SELECT COUNT(ipa.id_predefined_action)
                          INTO l_count
                          FROM icnp_predefined_action ipa
                         WHERE ipa.id_institution = i_id_institution
                           AND ipa.id_composition = l_ipa_id_composition
                           AND ipa.id_composition_parent = l_ipa_id_comp_parent
                           AND ipa.id_software = i_id_software;
                    
                        IF l_count = 0
                        THEN
                            g_error := 'GET SEQ_ICNP_PREDIFINED_ACTION.NEXTVAL';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_ICNP_COMPO ' || g_error);
                            SELECT seq_icnp_predefined_action.nextval
                              INTO l_id_icnp_predifined_act
                              FROM dual;
                        
                            g_error := 'GET ICNP_PREDIFINED_ACTION NEXTVAL';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_ICNP_COMPO ' || g_error);
                            SELECT nvl(MAX(ich.id_predefined_action_hist), 0) + 1
                              INTO l_id_icnp_predifined_hist
                              FROM icnp_predefined_action_hist ich;
                        
                            g_error := 'ASSIGN VARIABLES';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_ICNP_COMPO ' || g_error);
                            l_icnp_compo_parent_array.extend;
                            l_icnp_compo_array.extend;
                            l_icnp_predifined_hist_array.extend;
                            l_icnp_predifined_act1_array.extend;
                            l_icnp_predifined_act2_array.extend;
                        
                            g_error := 'ASSIGN VARIABLES';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_ICNP_COMPO ' || g_error);
                            l_icnp_compo_parent_array(l_index) := l_ipa_id_comp_parent;
                            l_icnp_compo_array(l_index) := l_ipa_id_composition;
                            l_icnp_predifined_hist_array(l_index) := l_id_icnp_predifined_hist;
                            l_icnp_predifined_act1_array(l_index) := l_id_icnp_predifined_act;
                            l_icnp_predifined_act2_array(l_index) := l_id_icnp_predifined_act;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_ICNP_PA_INST_SOFT CURSOR';
                CLOSE c_icnp_pa_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_ICNP_COMPO_PARENT CURSOR';
        OPEN o_icnp_compo_parent FOR
            SELECT column_value
              FROM TABLE(CAST(l_icnp_compo_parent_array AS table_number));
    
        g_error := 'CLOSE O_ICNP_COMPO CURSOR';
        OPEN o_icnp_compo FOR
            SELECT column_value
              FROM TABLE(CAST(l_icnp_compo_array AS table_number));
    
        g_error := 'CLOSE O_ICNP_PREDIFINED_ACTION1 CURSOR';
        OPEN o_icnp_predifined_act1 FOR
            SELECT column_value
              FROM TABLE(CAST(l_icnp_predifined_act1_array AS table_number));
    
        g_error := 'CLOSE O_ICNP_PREDIFINED_HIST CURSOR';
        OPEN o_icnp_predifined_hist FOR
            SELECT column_value
              FROM TABLE(CAST(l_icnp_predifined_hist_array AS table_number));
    
        g_error := 'CLOSE O_ICNP_PREDIFINED_ACTION2 CURSOR';
        OPEN o_icnp_predifined_act2 FOR
            SELECT column_value
              FROM TABLE(CAST(l_icnp_predifined_act2_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ICNP_COMPO',
                                              o_error);
            pk_types.open_my_cursor(o_icnp_compo_parent);
            pk_types.open_my_cursor(o_icnp_compo);
            pk_types.open_my_cursor(o_icnp_predifined_act1);
            pk_types.open_my_cursor(o_icnp_predifined_hist);
            pk_types.open_my_cursor(o_icnp_predifined_act2);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_icnp_compo;

    /********************************************************************************************
    * Set ICNP Compostions for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_icnp_compo     Cursor of Instituition ICNP Compostions
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/07
    ********************************************************************************************/
    FUNCTION set_inst_icnp_compo
    (
        i_lang            IN language.id_language%TYPE,
        i_market          IN table_number,
        i_version         IN table_varchar,
        i_id_institution  IN institution.id_institution%TYPE,
        i_software        IN table_number,
        o_inst_icnp_compo OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_icnp_compo_parent    pk_types.cursor_type;
        l_c_icnp_compo           pk_types.cursor_type;
        l_c_icnp_predifined_act1 pk_types.cursor_type;
        l_c_icnp_predifined_hist pk_types.cursor_type;
        l_c_icnp_predifined_act2 pk_types.cursor_type;
    
        l_data_icnp_compo_parent    table_number;
        l_data_icnp_compo           table_number;
        l_data_icnp_predifined_act1 table_number;
        l_data_icnp_predifined_hist table_number;
        l_data_icnp_predifined_act2 table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT GET_INST_ICNP_COMPO';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ICNP_COMPO ' || g_error);
            IF NOT get_inst_icnp_compo(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software(i),
                                       l_c_icnp_compo_parent,
                                       l_c_icnp_compo,
                                       l_c_icnp_predifined_act1,
                                       l_c_icnp_predifined_hist,
                                       l_c_icnp_predifined_act2,
                                       l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_icnp_compo := l_c_icnp_compo;
            
                LOOP
                    FETCH l_c_icnp_compo_parent BULK COLLECT
                        INTO l_data_icnp_compo_parent LIMIT g_array_size;
                    FETCH l_c_icnp_compo BULK COLLECT
                        INTO l_data_icnp_compo LIMIT g_array_size;
                    FETCH l_c_icnp_predifined_act1 BULK COLLECT
                        INTO l_data_icnp_predifined_act1 LIMIT g_array_size;
                
                    g_error := 'INSERT in ICNP_PREDIFINED_ACTION WITH FORALL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ICNP_COMPO ' || g_error);
                    FORALL j IN 1 .. l_data_icnp_compo.count
                        INSERT INTO icnp_predefined_action
                            (id_predefined_action,
                             id_institution,
                             id_composition_parent,
                             id_composition,
                             flg_available,
                             adw_last_update,
                             id_software)
                        VALUES
                            (l_data_icnp_predifined_act1(j),
                             i_id_institution,
                             l_data_icnp_compo_parent(j),
                             l_data_icnp_compo(j),
                             g_flg_available,
                             SYSDATE,
                             i_software(i));
                
                    --> ...HIST
                    FETCH l_c_icnp_predifined_hist BULK COLLECT
                        INTO l_data_icnp_predifined_hist LIMIT g_array_size;
                    FETCH l_c_icnp_predifined_act2 BULK COLLECT
                        INTO l_data_icnp_predifined_act2 LIMIT g_array_size;
                
                    g_error := 'INSERT in ICNP_PREDIFINED_ACTION_HIST WITH FORALL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ICNP_COMPO ' || g_error);
                    FORALL k IN 1 .. l_data_icnp_predifined_hist.count
                        INSERT INTO icnp_predefined_action_hist
                            (id_predefined_action_hist,
                             id_predefined_action,
                             flg_most_recent,
                             dt_predefined_action_hist,
                             id_professional,
                             id_cancel_reason,
                             reason_notes,
                             dt_cancel,
                             id_prof_cancel,
                             hist_notes,
                             flg_cancel)
                        VALUES
                            (l_data_icnp_predifined_hist(k),
                             l_data_icnp_predifined_act2(k),
                             'Y',
                             current_timestamp,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             'N');
                
                    EXIT WHEN l_c_icnp_predifined_hist%NOTFOUND;
                    EXIT WHEN l_c_icnp_compo%NOTFOUND;
                
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_ICNP_COMPO_PARENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ICNP_COMPO ' || g_error);
                CLOSE l_c_icnp_compo_parent;
            
                g_error := 'CLOSE L_C_ID_ICNP_COMPO CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ICNP_COMPO ' || g_error);
                CLOSE l_c_icnp_compo;
            
                g_error := 'CLOSE L_C_ID_ICNP_PREDIFINED_ACT1 CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ICNP_COMPO ' || g_error);
                CLOSE l_c_icnp_predifined_act1;
            
                g_error := 'CLOSE L_C_ID_ICNP_PREDIFINED_HIST CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ICNP_COMPO ' || g_error);
                CLOSE l_c_icnp_predifined_hist;
            
                g_error := 'CLOSE L_C_ID_ICNP_PREDIFINED_ACT2 CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ICNP_COMPO ' || g_error);
                CLOSE l_c_icnp_predifined_act2;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_ICNP_COMPO',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_ICNP_COMPO',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_icnp_compo;
    /********************************************************************************************
    * Get Vaccines set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_vacc_group          Cursor of vaccines
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/07
    ********************************************************************************************/
    FUNCTION get_inst_vacc
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_vacc_group     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --VACC_GROUP_SOFT_INST
        l_id_vacc_group vacc_group.id_vacc_group%TYPE;
    
        l_vacc_group_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_vacc_group_inst_soft
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT vgsi.id_vacc_group
              FROM alert_default.vacc_group_soft_inst vgsi
             WHERE vgsi.id_software = c_id_software
               AND vgsi.id_market = c_market
               AND vgsi.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_VACC_GROUP_INST_SOFT CURSOR';
                OPEN c_vacc_group_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_vacc_group_inst_soft
                        INTO l_id_vacc_group;
                    EXIT WHEN c_vacc_group_inst_soft%NOTFOUND;
                
                    IF l_id_vacc_group != 0
                    THEN
                    
                        --VACC_GROUP_SOFT_INST
                        SELECT COUNT(vgsi.id_vacc_group_soft_inst)
                          INTO l_count
                          FROM vacc_group_soft_inst vgsi
                         WHERE vgsi.id_vacc_group = l_id_vacc_group
                           AND vgsi.id_institution = i_id_institution
                           AND vgsi.id_software = i_id_software;
                    
                        IF l_count = 0
                        THEN
                            l_vacc_group_array.extend;
                        
                            l_vacc_group_array(l_index) := l_id_vacc_group;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_ICNP_PA_INST_SOFT CURSOR';
                CLOSE c_vacc_group_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_VACC_GROUP CURSOR';
        OPEN o_vacc_group FOR
            SELECT column_value
              FROM TABLE(CAST(l_vacc_group_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_VACC',
                                              o_error);
            pk_types.open_my_cursor(o_vacc_group);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_vacc;

    /********************************************************************************************
    * Set Vaccines for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_vacc_group     Cursor of Instituition Vaccines
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/07
    ********************************************************************************************/
    FUNCTION set_inst_vacc
    (
        i_lang            IN language.id_language%TYPE,
        i_market          IN table_number,
        i_version         IN table_varchar,
        i_id_institution  IN institution.id_institution%TYPE,
        i_software        IN table_number,
        o_inst_vacc_group OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_vacc_group pk_types.cursor_type;
    
        l_data_vacc_group table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --VACC_GROUP_SOFT_INST
            IF NOT get_inst_vacc(i_lang, i_market, i_version, i_id_institution, i_software(i), l_c_vacc_group, l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_vacc_group := l_c_vacc_group;
            
                LOOP
                    FETCH l_c_vacc_group BULK COLLECT
                        INTO l_data_vacc_group LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_vacc_group.count
                        INSERT INTO vacc_group_soft_inst
                            (id_vacc_group_soft_inst, id_vacc_group, id_institution, id_software, adw_last_update)
                        VALUES
                            (seq_vacc_group_soft_inst.nextval,
                             l_data_vacc_group(j),
                             i_id_institution,
                             i_software(i),
                             SYSDATE);
                
                    EXIT WHEN l_c_vacc_group%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_vacc_group;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_VACC',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_VACC',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_vacc;

    /********************************************************************************************
    * Get Vital sign unit measures set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_vital_sign          Cursor of Vital signs
    * @param o_unit_measure        Cursor of Unit measures
    * @param o_val_min             Cursor of Minimum values
    * @param o_val_max             Cursor of Maximum values
    * @param o_format_num          Cursor of values format
    * @param o_decimals            Cursor of decimals
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/07
    ********************************************************************************************/
    FUNCTION get_inst_vs_unit_mea
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_vital_sign     OUT pk_types.cursor_type,
        o_unit_measure   OUT pk_types.cursor_type,
        o_val_min        OUT pk_types.cursor_type,
        o_val_max        OUT pk_types.cursor_type,
        o_format_num     OUT pk_types.cursor_type,
        o_decimals       OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --VITAL_SIGN_UNIT_MEASURE
        l_vsum_id_vsum         vital_sign_unit_measure.id_vital_sign_unit_measure%TYPE;
        l_vsum_id_vital_sign   vital_sign_unit_measure.id_vital_sign%TYPE;
        l_vsum_id_unit_measure vital_sign_unit_measure.id_unit_measure%TYPE;
        l_vsum_val_min         vital_sign_unit_measure.val_min%TYPE;
        l_vsum_val_max         vital_sign_unit_measure.val_max%TYPE;
        l_vsum_format_num      vital_sign_unit_measure.format_num%TYPE;
        l_vsum_decimals        vital_sign_unit_measure.decimals%TYPE;
    
        l_vital_sign_array   table_number := table_number();
        l_unit_measure_array table_number := table_number();
        l_val_min_array      table_number := table_number();
        l_val_max_array      table_number := table_number();
        l_format_num_array   table_varchar := table_varchar();
        l_decimals_array     table_number := table_number();
    
        l_index NUMBER := 1;
    
        CURSOR c_vs_unit_measure
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT vsum.id_vital_sign,
                            vsum.id_unit_measure,
                            vsum.val_min,
                            vsum.val_max,
                            vsum.format_num,
                            vsum.decimals
              FROM alert_default.vital_sign_unit_measure vsum
             WHERE vsum.id_software = c_id_software
               AND vsum.id_market = c_market
               AND vsum.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_VACC_GROUP_INST_SOFT CURSOR';
                OPEN c_vs_unit_measure(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_vs_unit_measure
                        INTO l_vsum_id_vital_sign,
                             l_vsum_id_unit_measure,
                             l_vsum_val_min,
                             l_vsum_val_max,
                             l_vsum_format_num,
                             l_vsum_decimals;
                    EXIT WHEN c_vs_unit_measure%NOTFOUND;
                
                    --VITAL_SIGN_UNIT_MEASURE
                    IF l_vsum_id_unit_measure IS NULL
                    THEN
                        SELECT nvl((SELECT vsum.id_vital_sign_unit_measure
                                     FROM vital_sign_unit_measure vsum
                                    WHERE vsum.id_vital_sign = l_vsum_id_vital_sign
                                      AND vsum.id_unit_measure IS NULL
                                      AND vsum.id_institution = i_id_institution
                                      AND vsum.id_software = i_id_software),
                                   0)
                          INTO l_vsum_id_vsum
                          FROM dual;
                    ELSE
                        SELECT nvl((SELECT vsum.id_vital_sign_unit_measure
                                     FROM vital_sign_unit_measure vsum
                                    WHERE vsum.id_vital_sign = l_vsum_id_vital_sign
                                      AND vsum.id_unit_measure = l_vsum_id_unit_measure
                                      AND vsum.id_institution = i_id_institution
                                      AND vsum.id_software = i_id_software),
                                   0)
                          INTO l_vsum_id_vsum
                          FROM dual;
                    END IF;
                
                    IF l_vsum_id_vsum = 0
                    THEN
                    
                        l_vital_sign_array.extend;
                        l_unit_measure_array.extend;
                        l_val_min_array.extend;
                        l_val_max_array.extend;
                        l_format_num_array.extend;
                        l_decimals_array.extend;
                    
                        l_vital_sign_array(l_index) := l_vsum_id_vital_sign;
                        l_unit_measure_array(l_index) := l_vsum_id_unit_measure;
                        l_val_min_array(l_index) := l_vsum_val_min;
                        l_val_max_array(l_index) := l_vsum_val_max;
                        l_format_num_array(l_index) := l_vsum_format_num;
                        l_decimals_array(l_index) := l_vsum_decimals;
                    
                        l_index := l_index + 1;
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_VS_UNIT_MEASURE CURSOR';
                CLOSE c_vs_unit_measure;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_VITAL_SIGN CURSOR';
        OPEN o_vital_sign FOR
            SELECT column_value
              FROM TABLE(CAST(l_vital_sign_array AS table_number));
    
        g_error := 'CLOSE O_UNIT_MEASURE CURSOR';
        OPEN o_unit_measure FOR
            SELECT column_value
              FROM TABLE(CAST(l_unit_measure_array AS table_number));
    
        g_error := 'CLOSE O_VAL_MIN CURSOR';
        OPEN o_val_min FOR
            SELECT column_value
              FROM TABLE(CAST(l_val_min_array AS table_number));
    
        g_error := 'CLOSE O_VAL_MAX CURSOR';
        OPEN o_val_max FOR
            SELECT column_value
              FROM TABLE(CAST(l_val_max_array AS table_number));
    
        g_error := 'CLOSE O_FORMAT_NUM CURSOR';
        OPEN o_format_num FOR
            SELECT column_value
              FROM TABLE(CAST(l_format_num_array AS table_varchar));
    
        g_error := 'CLOSE O_DECIMALS CURSOR';
        OPEN o_decimals FOR
            SELECT column_value
              FROM TABLE(CAST(l_decimals_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_VS_UNIT_MEA',
                                              o_error);
            pk_types.open_my_cursor(o_vital_sign);
            pk_types.open_my_cursor(o_unit_measure);
            pk_types.open_my_cursor(o_val_min);
            pk_types.open_my_cursor(o_val_max);
            pk_types.open_my_cursor(o_format_num);
            pk_types.open_my_cursor(o_decimals);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_vs_unit_mea;

    /********************************************************************************************
    * Get Vital signs for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_vital_sign          Cursor of Vital signs
    * @param o_unit_measure        Cursor of Unit measures
    * @param o_vssi_flg_view       Cursor of view flags
    * @param o_vssi_color_grafh    Cursor of grafh colors
    * @param o_vssi_color_text     Cursor of text colors
    * @param o_vssi_box_type       Cursor of box types
    * @param o_vssi_rank           Cursor of ranks
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/14
    ********************************************************************************************/
    FUNCTION get_inst_vs_soft_inst
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN table_number,
        i_version          IN table_varchar,
        i_id_institution   IN institution.id_institution%TYPE,
        i_id_software      IN software.id_software%TYPE,
        o_vital_sign       OUT pk_types.cursor_type,
        o_unit_measure     OUT pk_types.cursor_type,
        o_vssi_flg_view    OUT pk_types.cursor_type,
        o_vssi_color_grafh OUT pk_types.cursor_type,
        o_vssi_color_text  OUT pk_types.cursor_type,
        o_vssi_box_type    OUT pk_types.cursor_type,
        o_vssi_rank        OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --VS_SOFT_INST
        l_vssi_id_vssi         vs_soft_inst.id_vs_soft_inst%TYPE;
        l_vssi_id_vital_sign   vs_soft_inst.id_vital_sign%TYPE;
        l_vssi_id_unit_measure vs_soft_inst.id_unit_measure%TYPE;
        l_vssi_flg_view        vs_soft_inst.flg_view%TYPE;
        l_vssi_color_grafh     vs_soft_inst.color_grafh%TYPE;
        l_vssi_color_text      vs_soft_inst.color_text%TYPE;
        l_vssi_box_type        vs_soft_inst.box_type%TYPE;
        l_vssi_rank            vs_soft_inst.rank%TYPE;
    
        l_vital_sign_array       table_number := table_number();
        l_unit_measure_array     table_number := table_number();
        l_vssi_flg_view_array    table_varchar := table_varchar();
        l_vssi_color_grafh_array table_varchar := table_varchar();
        l_vssi_color_text_array  table_varchar := table_varchar();
        l_vssi_box_type_array    table_varchar := table_varchar();
        l_vssi_rank_array        table_number := table_number();
    
        l_index NUMBER := 1;
    
        CURSOR c_vs_soft_inst
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT vssi.id_vital_sign,
                            vssi.id_unit_measure,
                            vssi.flg_view,
                            vssi.color_grafh,
                            vssi.color_text,
                            vssi.box_type,
                            vssi.rank
              FROM alert_default.vs_soft_inst vssi
             WHERE vssi.id_software = c_id_software
               AND vssi.id_market = c_market
               AND vssi.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_VS_SOFT_INST CURSOR';
                OPEN c_vs_soft_inst(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_vs_soft_inst
                        INTO l_vssi_id_vital_sign,
                             l_vssi_id_unit_measure,
                             l_vssi_flg_view,
                             l_vssi_color_grafh,
                             l_vssi_color_text,
                             l_vssi_box_type,
                             l_vssi_rank;
                    EXIT WHEN c_vs_soft_inst%NOTFOUND;
                
                    --VS_SOFT_INST
                    IF l_vssi_id_unit_measure IS NULL
                    THEN
                        SELECT nvl((SELECT vsi.id_vs_soft_inst
                                     FROM vs_soft_inst vsi
                                    WHERE vsi.id_vital_sign = l_vssi_id_vital_sign
                                      AND vsi.id_unit_measure IS NULL
                                      AND vsi.id_institution = i_id_institution
                                      AND vsi.id_software = i_id_software
                                      AND vsi.flg_view = l_vssi_flg_view),
                                   0)
                          INTO l_vssi_id_vssi
                          FROM dual;
                    ELSE
                        SELECT nvl((SELECT vsi.id_vs_soft_inst
                                     FROM vs_soft_inst vsi
                                    WHERE vsi.id_vital_sign = l_vssi_id_vital_sign
                                      AND vsi.id_unit_measure = l_vssi_id_unit_measure
                                      AND vsi.id_institution = i_id_institution
                                      AND vsi.id_software = i_id_software
                                      AND vsi.flg_view = l_vssi_flg_view),
                                   0)
                          INTO l_vssi_id_vssi
                          FROM dual;
                    END IF;
                
                    IF l_vssi_id_vssi = 0
                    THEN
                    
                        l_vital_sign_array.extend;
                        l_unit_measure_array.extend;
                        l_vssi_flg_view_array.extend;
                        l_vssi_color_grafh_array.extend;
                        l_vssi_color_text_array.extend;
                        l_vssi_box_type_array.extend;
                        l_vssi_rank_array.extend;
                    
                        l_vital_sign_array(l_index) := l_vssi_id_vital_sign;
                        l_unit_measure_array(l_index) := l_vssi_id_unit_measure;
                        l_vssi_flg_view_array(l_index) := l_vssi_flg_view;
                        l_vssi_color_grafh_array(l_index) := l_vssi_color_grafh;
                        l_vssi_color_text_array(l_index) := l_vssi_color_text;
                        l_vssi_box_type_array(l_index) := l_vssi_box_type;
                        l_vssi_rank_array(l_index) := l_vssi_rank;
                    
                        l_index := l_index + 1;
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_VS_UNIT_MEASURE CURSOR';
                CLOSE c_vs_soft_inst;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_VITAL_SIGN CURSOR';
        OPEN o_vital_sign FOR
            SELECT column_value
              FROM TABLE(CAST(l_vital_sign_array AS table_number));
    
        g_error := 'CLOSE O_UNIT_MEASURE CURSOR';
        OPEN o_unit_measure FOR
            SELECT column_value
              FROM TABLE(CAST(l_unit_measure_array AS table_number));
    
        g_error := 'CLOSE O_VSSI_FLG_VIEW CURSOR';
        OPEN o_vssi_flg_view FOR
            SELECT column_value
              FROM TABLE(CAST(l_vssi_flg_view_array AS table_varchar));
    
        g_error := 'CLOSE O_VSSI_COLOR_TEXT CURSOR';
        OPEN o_vssi_color_grafh FOR
            SELECT column_value
              FROM TABLE(CAST(l_vssi_color_grafh_array AS table_varchar));
    
        g_error := 'CLOSE O_VSSI_COLOR_TEXT CURSOR';
        OPEN o_vssi_color_text FOR
            SELECT column_value
              FROM TABLE(CAST(l_vssi_color_text_array AS table_varchar));
    
        g_error := 'CLOSE O_VSSI_BOX_TYPE CURSOR';
        OPEN o_vssi_box_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_vssi_box_type_array AS table_varchar));
    
        g_error := 'CLOSE O_VSSI_RANK CURSOR';
        OPEN o_vssi_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_vssi_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_VS_SOFT_INST',
                                              o_error);
            pk_types.open_my_cursor(o_vital_sign);
            pk_types.open_my_cursor(o_unit_measure);
            pk_types.open_my_cursor(o_vssi_flg_view);
            pk_types.open_my_cursor(o_vssi_color_grafh);
            pk_types.open_my_cursor(o_vssi_color_text);
            pk_types.open_my_cursor(o_vssi_box_type);
            pk_types.open_my_cursor(o_vssi_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_vs_soft_inst;

    /********************************************************************************************
    * Set Vital signs for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_vacc_group     Cursor of Instituition Vaccines
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/07
    ********************************************************************************************/
    FUNCTION set_inst_vital_signs
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN table_number,
        i_version          IN table_varchar,
        i_id_institution   IN institution.id_institution%TYPE,
        i_software         IN table_number,
        o_inst_vital_signs OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_vsum_vital_sign   pk_types.cursor_type;
        l_c_vsum_unit_measure pk_types.cursor_type;
        l_c_vsum_val_min      pk_types.cursor_type;
        l_c_vsum_val_max      pk_types.cursor_type;
        l_c_vsum_format_num   pk_types.cursor_type;
        l_c_vsum_decimals     pk_types.cursor_type;
    
        l_c_vssi_vital_sign   pk_types.cursor_type;
        l_c_vssi_unit_measure pk_types.cursor_type;
        l_c_vssi_flg_view     pk_types.cursor_type;
        l_c_vssi_color_grafh  pk_types.cursor_type;
        l_c_vssi_color_text   pk_types.cursor_type;
        l_c_vssi_box_type     pk_types.cursor_type;
        l_c_vssi_rank         pk_types.cursor_type;
    
        l_c_vssa_vital_sign_scales pk_types.cursor_type;
        l_c_vssa_clinical_service  pk_types.cursor_type;
    
        l_data_vsum_vital_sign   table_number;
        l_data_vsum_unit_measure table_number;
        l_data_vsum_val_min      table_number;
        l_data_vsum_val_max      table_number;
        l_data_vsum_format_num   table_varchar;
        l_data_vsum_decimals     table_number;
    
        l_data_vssi_vital_sign   table_number;
        l_data_vssi_unit_measure table_number;
        l_data_vssi_flg_view     table_varchar;
        l_data_vssi_color_grafh  table_varchar;
        l_data_vssi_color_text   table_varchar;
        l_data_vssi_box_type     table_varchar;
        l_data_vssi_rank         table_number;
    
        l_data_vssa_vital_sign_scales table_number;
        l_data_vssa_clinical_service  table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --VITAL_SIGN_UNIT_MEASURE
            IF NOT get_inst_vs_unit_mea(i_lang,
                                        i_market,
                                        i_version,
                                        i_id_institution,
                                        i_software(i),
                                        l_c_vsum_vital_sign,
                                        l_c_vsum_unit_measure,
                                        l_c_vsum_val_min,
                                        l_c_vsum_val_max,
                                        l_c_vsum_format_num,
                                        l_c_vsum_decimals,
                                        l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_vital_signs := l_c_vsum_vital_sign;
            
                LOOP
                    FETCH l_c_vsum_vital_sign BULK COLLECT
                        INTO l_data_vsum_vital_sign LIMIT g_array_size;
                
                    FETCH l_c_vsum_unit_measure BULK COLLECT
                        INTO l_data_vsum_unit_measure LIMIT g_array_size;
                
                    FETCH l_c_vsum_val_min BULK COLLECT
                        INTO l_data_vsum_val_min LIMIT g_array_size;
                
                    FETCH l_c_vsum_val_max BULK COLLECT
                        INTO l_data_vsum_val_max LIMIT g_array_size;
                
                    FETCH l_c_vsum_format_num BULK COLLECT
                        INTO l_data_vsum_format_num LIMIT g_array_size;
                
                    FETCH l_c_vsum_decimals BULK COLLECT
                        INTO l_data_vsum_decimals LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_vsum_vital_sign.count
                        INSERT INTO vital_sign_unit_measure
                            (id_vital_sign_unit_measure,
                             id_vital_sign,
                             id_unit_measure,
                             id_institution,
                             id_software,
                             val_min,
                             val_max,
                             format_num,
                             decimals,
                             adw_last_update)
                        VALUES
                            (seq_vital_sign_unit_measure.nextval,
                             l_data_vsum_vital_sign(j),
                             l_data_vsum_unit_measure(j),
                             i_id_institution,
                             i_software(i),
                             l_data_vsum_val_min(j),
                             l_data_vsum_val_max(j),
                             l_data_vsum_format_num(j),
                             l_data_vsum_decimals(j),
                             SYSDATE);
                
                    EXIT WHEN l_c_vsum_vital_sign%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_vsum_vital_sign;
                CLOSE l_c_vsum_unit_measure;
                CLOSE l_c_vsum_val_min;
                CLOSE l_c_vsum_val_max;
                CLOSE l_c_vsum_format_num;
                CLOSE l_c_vsum_decimals;
            
            END IF;
        
            --VS_SOFT_INST
            IF NOT get_inst_vs_soft_inst(i_lang,
                                         i_market,
                                         i_version,
                                         i_id_institution,
                                         i_software(i),
                                         l_c_vssi_vital_sign,
                                         l_c_vssi_unit_measure,
                                         l_c_vssi_flg_view,
                                         l_c_vssi_color_grafh,
                                         l_c_vssi_color_text,
                                         l_c_vssi_box_type,
                                         l_c_vssi_rank,
                                         l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                LOOP
                    FETCH l_c_vssi_vital_sign BULK COLLECT
                        INTO l_data_vssi_vital_sign LIMIT g_array_size;
                
                    FETCH l_c_vssi_unit_measure BULK COLLECT
                        INTO l_data_vssi_unit_measure LIMIT g_array_size;
                
                    FETCH l_c_vssi_flg_view BULK COLLECT
                        INTO l_data_vssi_flg_view LIMIT g_array_size;
                
                    FETCH l_c_vssi_color_grafh BULK COLLECT
                        INTO l_data_vssi_color_grafh LIMIT g_array_size;
                
                    FETCH l_c_vssi_color_text BULK COLLECT
                        INTO l_data_vssi_color_text LIMIT g_array_size;
                
                    FETCH l_c_vssi_box_type BULK COLLECT
                        INTO l_data_vssi_box_type LIMIT g_array_size;
                
                    FETCH l_c_vssi_rank BULK COLLECT
                        INTO l_data_vssi_rank LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_vssi_vital_sign.count
                        INSERT INTO vs_soft_inst
                            (id_vs_soft_inst,
                             id_vital_sign,
                             id_unit_measure,
                             id_software,
                             id_institution,
                             rank,
                             flg_view,
                             color_grafh,
                             adw_last_update,
                             color_text,
                             box_type)
                        VALUES
                            (seq_vs_soft_inst.nextval,
                             l_data_vssi_vital_sign(j),
                             l_data_vssi_unit_measure(j),
                             i_software(i),
                             i_id_institution,
                             nvl(l_data_vssi_rank(j), 0),
                             l_data_vssi_flg_view(j),
                             l_data_vssi_color_grafh(j),
                             SYSDATE,
                             l_data_vssi_color_text(j),
                             l_data_vssi_box_type(j));
                
                    EXIT WHEN l_c_vssi_vital_sign%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_vssi_vital_sign;
                CLOSE l_c_vssi_unit_measure;
                CLOSE l_c_vssi_flg_view;
                CLOSE l_c_vssi_color_grafh;
                CLOSE l_c_vssi_color_text;
                CLOSE l_c_vssi_box_type;
                CLOSE l_c_vssi_rank;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_VITAL_SIGNS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_VITAL_SIGNS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_vital_signs;

    /********************************************************************************************
    * Get Vital sign unit measures set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_vs_unit_mea         Cursor of Vital signs unit measures
    * @param o_id_exam_type        Cursor of Exam types
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/07
    ********************************************************************************************/
    FUNCTION get_inst_vs_exam_type
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_vs_unit_mea    OUT pk_types.cursor_type,
        o_id_exam_type   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --VITAL_SIGN_UNIT_MEASURE
        l_vsum_id_vsum         vital_sign_unit_measure.id_vital_sign_unit_measure%TYPE;
        l_vsum_id_vital_sign   vital_sign_unit_measure.id_vital_sign%TYPE;
        l_vsum_id_unit_measure vital_sign_unit_measure.id_unit_measure%TYPE;
    
        --EXAM_TYPE_VS
        l_etvs_exam_type exam_type_vs.id_exam_type%TYPE;
    
        l_vs_unit_mea_array  table_number := table_number();
        l_id_exam_type_array table_number := table_number();
    
        l_index NUMBER := 1;
        l_count NUMBER := 0;
    
        CURSOR c_exam_type_vs
        (
            c_id_software IN NUMBER,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT vsum.id_vital_sign, vsum.id_unit_measure, etv.id_exam_type
              FROM alert_default.vital_sign_unit_measure vsum, alert_default.exam_type_vs etv
             WHERE vsum.id_software = c_id_software
               AND vsum.id_market = c_market
               AND vsum.version = c_version
               AND etv.id_vital_sign_unit_measure = vsum.id_vital_sign_unit_measure
               AND etv.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_EXAM_TYPE_VS CURSOR';
                OPEN c_exam_type_vs(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_exam_type_vs
                        INTO l_vsum_id_vital_sign, l_vsum_id_unit_measure, l_etvs_exam_type;
                    EXIT WHEN c_exam_type_vs%NOTFOUND;
                
                    --VITAL_SIGN_UNIT_MEASURE
                    IF l_vsum_id_unit_measure IS NULL
                    THEN
                        SELECT nvl((SELECT vsum.id_vital_sign_unit_measure
                                     FROM vital_sign_unit_measure vsum
                                    WHERE vsum.id_vital_sign = l_vsum_id_vital_sign
                                      AND vsum.id_unit_measure IS NULL
                                      AND vsum.id_institution = i_id_institution
                                      AND vsum.id_software = i_id_software),
                                   0)
                          INTO l_vsum_id_vsum
                          FROM dual;
                    ELSE
                        SELECT nvl((SELECT vsum.id_vital_sign_unit_measure
                                     FROM vital_sign_unit_measure vsum
                                    WHERE vsum.id_vital_sign = l_vsum_id_vital_sign
                                      AND vsum.id_unit_measure = l_vsum_id_unit_measure
                                      AND vsum.id_institution = i_id_institution
                                      AND vsum.id_software = i_id_software),
                                   0)
                          INTO l_vsum_id_vsum
                          FROM dual;
                    END IF;
                
                    IF l_vsum_id_vsum != 0
                    THEN
                    
                        --EXAM_TYPE_VS
                        SELECT COUNT(etvs.id_exam_type_vs)
                          INTO l_count
                          FROM exam_type_vs etvs
                         WHERE etvs.id_exam_type = l_etvs_exam_type
                           AND etvs.id_vital_sign_unit_measure = l_vsum_id_vsum;
                    
                        IF l_count = 0
                        THEN
                        
                            l_vs_unit_mea_array.extend;
                            l_id_exam_type_array.extend;
                        
                            l_vs_unit_mea_array(l_index) := l_vsum_id_vsum;
                            l_id_exam_type_array(l_index) := l_etvs_exam_type;
                        
                            l_index := l_index + 1;
                        
                        END IF;
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_VS_UNIT_MEASURE CURSOR';
                CLOSE c_exam_type_vs;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_VITAL_SIGN CURSOR';
        OPEN o_vs_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_vs_unit_mea_array AS table_number));
    
        g_error := 'CLOSE O_ID_EXAM_TYPE CURSOR';
        OPEN o_id_exam_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_exam_type_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_VS_EXAM_TYPE',
                                              o_error);
            pk_types.open_my_cursor(o_vs_unit_mea);
            pk_types.open_my_cursor(o_id_exam_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_vs_exam_type;

    /********************************************************************************************
    * Set  Vital Signs exam types for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_exam_type_vs   Cursor of Instituition Vital Signs exam types
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/07
    ********************************************************************************************/
    FUNCTION set_inst_vs_exam_type
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_software          IN table_number,
        o_inst_exam_type_vs OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_vsum_vs_unit_mea pk_types.cursor_type;
        l_c_etvs_exam_type   pk_types.cursor_type;
    
        l_data_vsum_vs_unit_mea table_number;
        l_data_etvs_exam_type   table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --EXAM_TYPE_VS
            IF NOT get_inst_vs_exam_type(i_lang,
                                         i_market,
                                         i_version,
                                         i_id_institution,
                                         i_software(i),
                                         l_c_vsum_vs_unit_mea,
                                         l_c_etvs_exam_type,
                                         l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_exam_type_vs := l_c_etvs_exam_type;
            
                LOOP
                    FETCH l_c_vsum_vs_unit_mea BULK COLLECT
                        INTO l_data_vsum_vs_unit_mea LIMIT g_array_size;
                
                    FETCH l_c_etvs_exam_type BULK COLLECT
                        INTO l_data_etvs_exam_type LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_vsum_vs_unit_mea.count
                        INSERT INTO exam_type_vs
                            (id_exam_type_vs, id_exam_type, flg_available, id_vital_sign_unit_measure)
                        VALUES
                            (seq_exam_type_vs.nextval, l_data_etvs_exam_type(j), 'Y', l_data_vsum_vs_unit_mea(j));
                
                    EXIT WHEN l_c_vsum_vs_unit_mea%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_vsum_vs_unit_mea;
                CLOSE l_c_etvs_exam_type;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_VS_EXAM_TYPE',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_VS_EXAM_TYPE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_vs_exam_type;

    /********************************************************************************************
    * Get Events set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_event_group         Cursor of events
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/14
    ********************************************************************************************/
    FUNCTION get_inst_events
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_event_group    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --EVENT_GROUP_SFOT_INST
        l_egsi_id_event_group event_group_soft_inst.id_event_group%TYPE;
    
        l_event_group_array table_number := table_number();
    
        l_count       NUMBER := 0;
        l_index       NUMBER := 1;
        l_group_exist NUMBER := 0;
    
        CURSOR c_event_soft_inst
        (
            c_software IN NUMBER,
            c_version  IN VARCHAR2,
            c_market   IN NUMBER
        ) IS
            SELECT DISTINCT egsi.id_event_group
              FROM alert_default.event_group_soft_inst egsi
             WHERE egsi.id_software = c_software
               AND egsi.id_market = c_market
               AND egsi.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_EVENT_SOFT_INST CURSOR';
                OPEN c_event_soft_inst(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_event_soft_inst
                        INTO l_egsi_id_event_group;
                    EXIT WHEN c_event_soft_inst%NOTFOUND;
                
                    SELECT nvl((SELECT eg.id_event_group
                                 FROM event_group eg
                                WHERE eg.id_event_group = l_egsi_id_event_group),
                               0)
                      INTO l_group_exist
                      FROM dual;
                
                    IF l_group_exist != 0
                    THEN
                    
                        --EVENT_GROUP_SOFT_INST
                        SELECT COUNT(egsi.id_event_group_soft_inst)
                          INTO l_count
                          FROM event_group_soft_inst egsi
                         WHERE egsi.id_institution = i_id_institution
                           AND egsi.id_software = i_id_software
                           AND egsi.id_event_group = l_egsi_id_event_group;
                    
                        IF l_count = 0
                        THEN
                            l_event_group_array.extend;
                        
                            l_event_group_array(l_index) := l_egsi_id_event_group;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_EVENT_SOFT_INST CURSOR';
                CLOSE c_event_soft_inst;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_EVENT_GROUP CURSOR';
        OPEN o_event_group FOR
            SELECT column_value
              FROM TABLE(CAST(l_event_group_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_EVENTS',
                                              o_error);
            pk_types.open_my_cursor(o_event_group);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_events;

    /********************************************************************************************
    * Set Events for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_events         Cursor of Instituition Events
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/14
    ********************************************************************************************/
    FUNCTION set_inst_events
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_events    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_event_group pk_types.cursor_type;
    
        l_data_event_group table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --EVENT_GROUP_SOFT_INST
            IF NOT
                get_inst_events(i_lang, i_market, i_version, i_id_institution, i_software(i), l_c_event_group, l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_events := l_c_event_group;
            
                LOOP
                    FETCH l_c_event_group BULK COLLECT
                        INTO l_data_event_group LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_event_group.count
                        INSERT INTO event_group_soft_inst
                            (id_event_group_soft_inst, id_institution, id_software, id_event_group)
                        VALUES
                            (seq_event_group_soft_inst.nextval, i_id_institution, i_software(i), l_data_event_group(j));
                
                    EXIT WHEN l_c_event_group%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_event_group;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_EVENTS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_EVENTS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_events;

    /********************************************************************************************
    * Get Lens set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_lens                Cursor of lens
    * @param o_lens_rank           Cursor of lens ranks
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/16
    ********************************************************************************************/
    FUNCTION get_inst_lens
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_lens           OUT pk_types.cursor_type,
        o_lens_rank      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --LENS
        l_id_lens_def lens.id_lens%TYPE := NULL;
        l_id_lens     lens.id_lens%TYPE := NULL;
        l_lens_rank   lens_soft_inst.rank%TYPE := NULL;
    
        l_lens_array      table_number := table_number();
        l_lens_rank_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_lens_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT lsi.id_lens, lsi.rank
              FROM alert_default.lens_soft_inst lsi, alert_default.lens_mrk_vrs lmv
             WHERE lsi.id_software = c_id_software
               AND lsi.flg_available = g_flg_available
               AND lsi.id_lens = lmv.id_lens
               AND lmv.id_market = c_market
               AND lmv.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_LENS_INST_SOFT CURSOR';
                OPEN c_lens_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_lens_inst_soft
                        INTO l_id_lens_def, l_lens_rank;
                    EXIT WHEN c_lens_inst_soft%NOTFOUND;
                
                    --DIAGNOSIS
                    SELECT nvl((SELECT l.id_lens
                                 FROM lens l
                                WHERE l.id_content = (SELECT l2.id_content
                                                        FROM alert_default.lens l2
                                                       WHERE l2.id_lens = l_id_lens_def)
                                  AND l.id_content IS NOT NULL
                                  AND rownum = 1),
                               0)
                      INTO l_id_lens
                      FROM dual;
                
                    IF l_id_lens != 0
                    THEN
                        SELECT COUNT(lsi.id_lens)
                          INTO l_count
                          FROM lens_soft_inst lsi
                         WHERE lsi.id_software = i_id_software
                           AND lsi.id_institution = i_id_institution
                           AND lsi.id_lens = l_id_lens;
                    
                        IF l_count = 0
                        THEN
                            l_lens_array.extend;
                            l_lens_rank_array.extend;
                        
                            l_lens_array(l_index) := l_id_lens;
                            l_lens_rank_array(l_index) := l_lens_rank;
                            l_index := l_index + 1;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_LENS_INST_SOFT CURSOR';
                CLOSE c_lens_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_LENS CURSOR';
        OPEN o_lens FOR
            SELECT column_value
              FROM TABLE(CAST(l_lens_array AS table_number));
    
        g_error := 'CLOSE O_LENS CURSOR';
        OPEN o_lens_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_lens_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_LENS',
                                              o_error);
            pk_types.open_my_cursor(o_lens);
            pk_types.open_my_cursor(o_lens_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_lens;

    /********************************************************************************************
    * Set Lens for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_lens           Cursor of Instituition Lens
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/16
    ********************************************************************************************/
    FUNCTION set_inst_lens
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_lens      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_lens pk_types.cursor_type;
        l_c_rank pk_types.cursor_type;
    
        l_data_lens      table_number;
        l_data_lens_rank table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --LENS_SOFT_INST
            IF NOT
                get_inst_lens(i_lang, i_market, i_version, i_id_institution, i_software(i), l_c_lens, l_c_rank, l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_lens := l_c_lens;
            
                LOOP
                    FETCH l_c_lens BULK COLLECT
                        INTO l_data_lens LIMIT g_array_size;
                
                    FETCH l_c_rank BULK COLLECT
                        INTO l_data_lens_rank LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_lens.count
                        INSERT INTO lens_soft_inst
                            (id_lens, id_software, id_institution, flg_available, rank)
                        VALUES
                            (l_data_lens(j), i_software(i), i_id_institution, 'Y', l_data_lens_rank(j));
                
                    EXIT WHEN l_c_lens%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_lens;
                CLOSE l_c_rank;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_LENS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_LENS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_lens;

    /********************************************************************************************
    * Get Calculators set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_calc                Cursor of calculators
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/16
    ********************************************************************************************/
    FUNCTION get_inst_calc
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_calc           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --CALC_SOFT_INST
        l_id_calculator calc_soft_inst.id_calculator%TYPE := NULL;
    
        l_calc_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_calc_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT csi.id_calculator
              FROM alert_default.calc_soft_inst csi, alert_default.calc_mrk_vrs cmv
             WHERE csi.id_software = c_id_software
               AND csi.flg_available = g_flg_available
               AND csi.id_calculator = cmv.id_calculator
               AND cmv.id_market = c_market
               AND cmv.version = c_version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_LENS_INST_SOFT CURSOR';
                OPEN c_calc_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_calc_inst_soft
                        INTO l_id_calculator;
                    EXIT WHEN c_calc_inst_soft%NOTFOUND;
                
                    --CALC_SOFT_INST                
                    IF l_id_calculator IS NOT NULL
                    THEN
                        SELECT COUNT(csi.id_calculator)
                          INTO l_count
                          FROM calc_soft_inst csi
                         WHERE csi.id_software = i_id_software
                           AND csi.id_institution = i_id_institution
                           AND csi.id_calculator = l_id_calculator;
                    
                        IF l_count = 0
                        THEN
                            l_calc_array.extend;
                        
                            l_calc_array(l_index) := l_id_calculator;
                            l_index := l_index + 1;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_CALC_INST_SOFT CURSOR';
                CLOSE c_calc_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_CALC CURSOR';
        OPEN o_calc FOR
            SELECT column_value
              FROM TABLE(CAST(l_calc_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_CALC',
                                              o_error);
            pk_types.open_my_cursor(o_calc);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_calc;

    /********************************************************************************************
    * Get Calculators fields set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_calc                Cursor of calculators
    * @param o_calc_field          Cursor of calculators fields
    * @param o_cf_unit_mea         Cursor of calculators fields unit measures
    * @param o_cf_format           Cursor of calculators fields formats
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/16
    ********************************************************************************************/
    FUNCTION get_inst_calc_field
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_calc           OUT pk_types.cursor_type,
        o_calc_field     OUT pk_types.cursor_type,
        o_cf_unit_mea    OUT pk_types.cursor_type,
        o_cf_format      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --CALC_FIELD_SOFT_INST
        l_id_calculator  calc_field_soft_inst.id_calculator%TYPE := NULL;
        l_id_calc_field  calc_field_soft_inst.id_calc_field%TYPE := NULL;
        l_cf_id_unit_mea calc_field_soft_inst.id_unit_measure%TYPE := NULL;
        l_cf_format      calc_field_soft_inst.format%TYPE := NULL;
    
        l_calc_array        table_number := table_number();
        l_calc_field_array  table_number := table_number();
        l_cf_unit_mea_array table_number := table_number();
        l_cf_format_array   table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_calc_field_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT cfsi.id_calculator, cfsi.id_calc_field, cfsi.id_unit_measure, cfsi.format
              FROM alert_default.calc_field_soft_inst cfsi
             INNER JOIN alert_default.calc_field_mrk_vrs cfmv
                ON (cfmv.id_calc_field = cfsi.id_calc_field AND cfmv.id_market = cfsi.id_market AND
                   cfmv.version = cfsi.version)
             WHERE cfsi.id_market = c_market
               AND cfsi.version = c_version
               AND cfsi.id_software = c_id_software;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_LENS_INST_SOFT CURSOR';
                OPEN c_calc_field_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_calc_field_inst_soft
                        INTO l_id_calculator, l_id_calc_field, l_cf_id_unit_mea, l_cf_format;
                    EXIT WHEN c_calc_field_inst_soft%NOTFOUND;
                
                    --CALC_FIELD_SOFT_INST                
                    IF l_id_calc_field IS NOT NULL
                    THEN
                        SELECT nvl(COUNT(*), 0)
                          INTO l_count
                          FROM calc_field_soft_inst cfsi
                         WHERE cfsi.id_software = i_id_software
                           AND cfsi.id_institution = i_id_institution
                           AND cfsi.id_calculator = l_id_calculator
                           AND cfsi.id_calc_field = l_id_calc_field;
                    
                        IF l_count = 0
                        THEN
                            l_calc_array.extend;
                            l_calc_field_array.extend;
                            l_cf_unit_mea_array.extend;
                            l_cf_format_array.extend;
                        
                            l_calc_array(l_index) := l_id_calculator;
                            l_calc_field_array(l_index) := l_id_calc_field;
                            l_cf_unit_mea_array(l_index) := l_cf_id_unit_mea;
                            l_cf_format_array(l_index) := l_cf_format;
                            l_index := l_index + 1;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_CALC_INST_SOFT CURSOR';
                CLOSE c_calc_field_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_CALC CURSOR';
        OPEN o_calc FOR
            SELECT column_value
              FROM TABLE(CAST(l_calc_array AS table_number));
    
        g_error := 'CLOSE O_CALC_FIELD CURSOR';
        OPEN o_calc_field FOR
            SELECT column_value
              FROM TABLE(CAST(l_calc_field_array AS table_number));
    
        g_error := 'CLOSE O_CF_UNIT_MEA CURSOR';
        OPEN o_cf_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_cf_unit_mea_array AS table_number));
    
        g_error := 'CLOSE O_CF_FORMAT CURSOR';
        OPEN o_cf_format FOR
            SELECT column_value
              FROM TABLE(CAST(l_cf_format_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_CALC_FIELD',
                                              o_error);
            pk_types.open_my_cursor(o_calc);
            pk_types.open_my_cursor(o_calc_field);
            pk_types.open_my_cursor(o_cf_unit_mea);
            pk_types.open_my_cursor(o_cf_format);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_calc_field;

    /********************************************************************************************
    * Set Calculators for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_calc           Cursor of Instituition Calculators
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/16
    ********************************************************************************************/
    FUNCTION set_inst_calc
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_calc      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_calc          pk_types.cursor_type;
        l_c_cf_calc       pk_types.cursor_type;
        l_c_cf_calc_field pk_types.cursor_type;
        l_c_cf_unit_mea   pk_types.cursor_type;
        l_c_cf_format     pk_types.cursor_type;
    
        l_data_calc          table_number;
        l_data_cf_calc       table_number;
        l_data_cf_calc_field table_number;
        l_data_cf_unit_mea   table_number;
        l_data_cf_format     table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --CALC_SOFT_INST
            IF NOT get_inst_calc(i_lang, i_market, i_version, i_id_institution, i_software(i), l_c_calc, l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_calc := l_c_calc;
            
                LOOP
                    FETCH l_c_calc BULK COLLECT
                        INTO l_data_calc LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_calc.count
                        INSERT INTO calc_soft_inst
                            (id_calculator, id_software, id_institution, flg_available)
                        VALUES
                            (l_data_calc(j), i_software(i), i_id_institution, 'Y');
                
                    EXIT WHEN l_c_calc%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_calc;
            
            END IF;
        
            --CALC_FIELD_SOFT_INST
            IF NOT get_inst_calc_field(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software(i),
                                       l_c_cf_calc,
                                       l_c_cf_calc_field,
                                       l_c_cf_unit_mea,
                                       l_c_cf_format,
                                       l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                LOOP
                
                    FETCH l_c_cf_calc BULK COLLECT
                        INTO l_data_cf_calc LIMIT g_array_size;
                
                    FETCH l_c_cf_calc_field BULK COLLECT
                        INTO l_data_cf_calc_field LIMIT g_array_size;
                
                    FETCH l_c_cf_unit_mea BULK COLLECT
                        INTO l_data_cf_unit_mea LIMIT g_array_size;
                
                    FETCH l_c_cf_format BULK COLLECT
                        INTO l_data_cf_format LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_cf_calc_field.count
                        INSERT INTO calc_field_soft_inst
                            (id_calculator, id_calc_field, id_institution, id_software, id_unit_measure, format)
                        VALUES
                            (l_data_cf_calc(j),
                             l_data_cf_calc_field(j),
                             i_id_institution,
                             i_software(i),
                             l_data_cf_unit_mea(j),
                             l_data_cf_format(j));
                
                    EXIT WHEN l_c_cf_calc_field%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_cf_calc;
                CLOSE l_c_cf_calc_field;
                CLOSE l_c_cf_unit_mea;
                CLOSE l_c_cf_format;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_CALC',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_CALC',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_calc;

    /********************************************************************************************
    * Get Templates set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_templates           Cursor of templates
    * @param o_profiles            Cursor of profiles
    * @param o_context             Cursor of contexts
    * @param o_flg_types           Cursor of templates flag types
    * @param o_id_sch_event        Cursor of scheduler events
    * @param o_context_2           Cursor of additional contexts  
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/17
    ********************************************************************************************/
    FUNCTION get_inst_templates
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_templates      OUT pk_types.cursor_type,
        o_profiles       OUT pk_types.cursor_type,
        o_context        OUT pk_types.cursor_type,
        o_flg_types      OUT pk_types.cursor_type,
        o_id_sch_event   OUT pk_types.cursor_type,
        o_context_2      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --DOC_TEMPLATE
        l_id_doc_template_def doc_template.id_doc_template%TYPE;
    
        --DOC_TEMPLATE_CONTEXT
        l_dtc_id_profile_template doc_template_context.id_profile_template%TYPE;
        l_dtc_id_context_def      doc_template_context.id_context%TYPE;
        l_dtc_id_context          doc_template_context.id_context%TYPE;
        l_dtc_flg_type            doc_template_context.flg_type%TYPE;
        l_dtc_id_sch_event        doc_template_context.id_sch_event%TYPE;
        l_dtc_id_context_2_def    doc_template_context.id_context_2%TYPE;
        l_dtc_id_context_2        doc_template_context.id_context_2%TYPE;
    
        l_templates_array    table_number := table_number();
        l_profiles_array     table_number := table_number();
        l_context_array      table_number := table_number();
        l_context_2_array    table_number := table_number();
        l_flg_type_array     table_varchar := table_varchar();
        l_id_sch_event_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_templates
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT dtc.id_doc_template,
                            dtc.id_profile_template,
                            dtc.id_context,
                            dtc.flg_type,
                            dtc.id_sch_event,
                            dtc.id_context_2
              FROM alert_default.doc_template_context dtc
             WHERE dtc.id_software = c_id_software
               AND dtc.id_market = c_market
               AND dtc.version = c_version
               AND dtc.id_clinical_service IS NULL
               AND EXISTS (SELECT 0
                      FROM doc_template dt
                     WHERE dt.id_doc_template = dtc.id_doc_template);
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_TEMPLATES CURSOR';
                OPEN c_templates(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_templates
                        INTO l_id_doc_template_def,
                             l_dtc_id_profile_template,
                             l_dtc_id_context_def,
                             l_dtc_flg_type,
                             l_dtc_id_sch_event,
                             l_dtc_id_context_2_def;
                    EXIT WHEN c_templates%NOTFOUND;
                    -- Procedures
                    IF l_dtc_flg_type = 'I'
                    THEN
                        SELECT nvl((SELECT ext_interv.id_intervention
                                     FROM intervention ext_interv
                                    INNER JOIN alert_default.intervention def_interv
                                       ON (def_interv.id_content = ext_interv.id_content AND
                                          def_interv.flg_status = g_active)
                                    WHERE ext_interv.flg_status = g_active
                                      AND def_interv.id_intervention = l_dtc_id_context_def),
                                   0)
                          INTO l_dtc_id_context
                          FROM dual;
                        l_dtc_id_context_2 := NULL;
                        -- Other Exams      
                    ELSIF l_dtc_flg_type = 'E'
                    THEN
                        SELECT nvl((SELECT ext_e.id_exam
                                     FROM exam ext_e
                                    INNER JOIN alert_default.exam def_e
                                       ON (def_e.id_content = ext_e.id_content AND
                                          def_e.flg_available = g_flg_available AND def_e.flg_type = 'E')
                                    WHERE ext_e.flg_available = g_flg_available
                                      AND ext_e.flg_type = 'E'
                                      AND def_e.id_exam = l_dtc_id_context_def),
                                   0)
                          INTO l_dtc_id_context
                          FROM dual;
                        l_dtc_id_context_2 := NULL;
                        -- Rehabilitation areas
                    ELSIF l_dtc_flg_type = 'R'
                    THEN
                        SELECT nvl((SELECT ext_ra.id_rehab_area
                                     FROM rehab_area ext_ra
                                    INNER JOIN alert_default.rehab_area def_ra
                                       ON (def_ra.id_content = ext_ra.id_content)
                                    WHERE def_ra.id_rehab_area = l_dtc_id_context_def),
                                   0)
                          INTO l_dtc_id_context
                          FROM dual;
                        l_dtc_id_context_2 := NULL;
                        -- ICNP
                    ELSIF l_dtc_flg_type = 'P'
                          AND l_dtc_id_context_def <> -1
                    THEN
                        SELECT nvl((SELECT ext_ic.id_composition
                                     FROM icnp_composition ext_ic
                                    INNER JOIN alert_default.icnp_composition def_ic
                                       ON (def_ic.id_content = ext_ic.id_content AND
                                          def_ic.flg_available = g_flg_available AND
                                          def_ic.id_software = i_id_software)
                                    WHERE ext_ic.flg_available = g_flg_available
                                      AND def_ic.id_composition = l_dtc_id_context_def
                                      AND ext_ic.id_software = i_id_software
                                      AND ext_ic.id_institution = i_id_institution),
                                   0)
                          INTO l_dtc_id_context
                          FROM dual;
                        l_dtc_id_context_2 := NULL;
                    ELSE
                        l_dtc_id_context   := l_dtc_id_context_def;
                        l_dtc_id_context_2 := l_dtc_id_context_2_def;
                    END IF;
                
                    IF l_dtc_id_context != 0
                    THEN
                        --DOC_TEMPLATE_CONTEXT
                        SELECT COUNT(dtc.id_doc_template_context)
                          INTO l_count
                          FROM doc_template_context dtc
                         WHERE dtc.id_doc_template = l_id_doc_template_def
                           AND dtc.id_institution = i_id_institution
                           AND dtc.id_software = i_id_software
                           AND dtc.id_context = l_dtc_id_context
                           AND ((dtc.id_context_2 = l_dtc_id_context_2) OR
                               (dtc.id_context_2 IS NULL AND l_dtc_id_context_2 IS NULL))
                           AND dtc.flg_type = l_dtc_flg_type
                           AND (dtc.id_profile_template = l_dtc_id_profile_template OR
                               (dtc.id_profile_template IS NULL AND l_dtc_id_profile_template IS NULL))
                           AND dtc.id_dep_clin_serv IS NULL
                           AND ((dtc.id_sch_event = l_dtc_id_sch_event) OR
                               (dtc.id_sch_event IS NULL AND l_dtc_id_sch_event IS NULL));
                    
                        IF l_count = 0
                        THEN
                            l_templates_array.extend;
                            l_profiles_array.extend;
                            l_context_array.extend;
                            l_context_2_array.extend;
                            l_flg_type_array.extend;
                            l_id_sch_event_array.extend;
                        
                            l_templates_array(l_index) := l_id_doc_template_def;
                            l_profiles_array(l_index) := l_dtc_id_profile_template;
                            l_context_array(l_index) := l_dtc_id_context;
                            l_context_2_array(l_index) := l_dtc_id_context_2;
                            l_flg_type_array(l_index) := l_dtc_flg_type;
                            l_id_sch_event_array(l_index) := l_dtc_id_sch_event;
                        
                            l_index := l_index + 1;
                        END IF;
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_CALC_INST_SOFT CURSOR';
                CLOSE c_templates;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'OPEN O_TEMPLATES CURSOR';
        OPEN o_templates FOR
            SELECT column_value
              FROM TABLE(CAST(l_templates_array AS table_number));
    
        g_error := 'OPEN O_PROFILES CURSOR';
        OPEN o_profiles FOR
            SELECT column_value
              FROM TABLE(CAST(l_profiles_array AS table_number));
    
        g_error := 'OPEN O_CONTEXT CURSOR';
        OPEN o_context FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_array AS table_number));
    
        g_error := 'OPEN O_CONTEXT_2 CURSOR';
        OPEN o_context_2 FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_2_array AS table_number));
    
        g_error := 'OPEN O_FLG_TYPES CURSOR';
        OPEN o_flg_types FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_type_array AS table_varchar));
    
        g_error := 'OPEN O_ID_SCH_EVENT CURSOR';
        OPEN o_id_sch_event FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_sch_event_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_TEMPLATES',
                                              o_error);
            pk_types.open_my_cursor(o_templates);
            pk_types.open_my_cursor(o_profiles);
            pk_types.open_my_cursor(o_context);
            pk_types.open_my_cursor(o_context_2);
            pk_types.open_my_cursor(o_flg_types);
            pk_types.open_my_cursor(o_id_sch_event);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_templates;

    /********************************************************************************************
    * Set Templates for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_templates      Cursor of Instituition Templates
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/16
    * @modified                    MESS 2010/04/12
    ********************************************************************************************/
    FUNCTION set_inst_templates
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_templates OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_templates pk_types.cursor_type;
        l_c_profiles  pk_types.cursor_type;
        l_c_context   pk_types.cursor_type;
        l_c_context_2 pk_types.cursor_type;
        l_c_flg_type  pk_types.cursor_type;
        l_c_sch_event pk_types.cursor_type;
    
        l_c_dais_doc_area        pk_types.cursor_type;
        l_c_dais_flg_mode        pk_types.cursor_type;
        l_c_dais_flg_type        pk_types.cursor_type;
        l_c_dais_flg_switch_mode pk_types.cursor_type;
        l_c_dais_flg_multiple    pk_types.cursor_type;
        l_c_dais_shortcut_error  pk_types.cursor_type;
    
        l_data_templates table_number;
        l_data_profiles  table_number;
        l_data_context   table_number;
        l_data_context_2 table_number;
        l_data_flg_type  table_varchar;
        l_data_sch_event table_number;
    
        l_data_doc_area        table_number;
        l_data_flg_mode        table_varchar;
        l_data_dais_flg_type   table_varchar;
        l_data_flg_switch_mode table_varchar;
        l_data_flg_multiple    table_varchar;
        l_data_shortcut_error  table_number;
    
        l_next                  doc_area_inst_soft.id_doc_area_inst_soft%TYPE;
        l_id_doc_area_inst_soft table_number := table_number();
        l_count                 NUMBER := 1;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        o_result    NUMBER;
    
    BEGIN
    
        IF NOT set_inst_doc_area(i_lang, i_market, i_version, i_id_institution, i_software, o_result, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            --DOC_TEMPLATE_CONTEXT
            IF NOT get_inst_templates(i_lang,
                                      i_market,
                                      i_version,
                                      i_id_institution,
                                      i_software(i),
                                      l_c_templates,
                                      l_c_profiles,
                                      l_c_context,
                                      l_c_flg_type,
                                      l_c_sch_event,
                                      l_c_context_2,
                                      l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_templates := l_c_templates;
            
                LOOP
                    FETCH l_c_templates BULK COLLECT
                        INTO l_data_templates LIMIT g_array_size;
                
                    FETCH l_c_profiles BULK COLLECT
                        INTO l_data_profiles LIMIT g_array_size;
                
                    FETCH l_c_context BULK COLLECT
                        INTO l_data_context LIMIT g_array_size;
                
                    FETCH l_c_flg_type BULK COLLECT
                        INTO l_data_flg_type LIMIT g_array_size;
                
                    FETCH l_c_sch_event BULK COLLECT
                        INTO l_data_sch_event LIMIT g_array_size;
                
                    FETCH l_c_context_2 BULK COLLECT
                        INTO l_data_context_2 LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_templates.count
                        INSERT INTO doc_template_context
                            (id_doc_template_context,
                             id_doc_template,
                             id_institution,
                             id_software,
                             id_profile_template,
                             id_dep_clin_serv,
                             adw_last_update,
                             id_context,
                             flg_type,
                             id_sch_event,
                             id_context_2)
                        VALUES
                            (seq_doc_template_context.nextval,
                             l_data_templates(j),
                             i_id_institution,
                             i_software(i),
                             l_data_profiles(j),
                             NULL,
                             SYSDATE,
                             l_data_context(j),
                             l_data_flg_type(j),
                             l_data_sch_event(j),
                             l_data_context_2(j));
                
                    EXIT WHEN l_c_templates%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_templates;
                CLOSE l_c_profiles;
                CLOSE l_c_context;
                CLOSE l_c_context_2;
                CLOSE l_c_flg_type;
                CLOSE l_c_sch_event;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_TEMPLATES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_TEMPLATES',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_templates;
    /********************************************************************************************
    * Get Periodic observation param for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_pop_id_content      Cursor of periodic observation param Content identifier
    * @param o_pop_id_event        Cursor of events
    * @param o_pop_po_type         Cursor of periodic observation param types
    * @param o_pop_id_cs           Cursor of clinical services
    * @param o_pop_id_teg          Cursor of time event groups
    * @param o_pop_fill_type       Cursor of periodic observation param fill types
    * @param o_pop_format_num      Cursor of periodic observation param num formats
    * @param o_pop_id_unit_mea     Cursor of periodic observation param unit measures
    * @param o_pop_id_context      Cursor of periodic observation param context
    * @param o_pop_flg_type        Cursor of periodic observation param flag types
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/16
    ********************************************************************************************/
    FUNCTION get_inst_periodic_obs_param
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_pop_config     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- error handling external methods
        l_exception EXCEPTION;
    BEGIN
        g_func_name := upper('get_inst_periodic_obs_param');
        g_error     := 'OPEN CONFIGURATION CURSOR';
        OPEN o_pop_config FOR
            SELECT def_data.id_software,
                   def_data.id_content,
                   def_data.id_event,
                   def_data.periodic_observation_type,
                   def_data.id_time_event_group,
                   def_data.flg_fill_type,
                   def_data.format_num,
                   def_data.id_unit_measure,
                   def_data.id_context,
                   def_data.flg_type
              FROM (SELECT temp_data.id_software,
                           temp_data.id_content,
                           temp_data.id_event,
                           temp_data.periodic_observation_type,
                           temp_data.id_time_event_group,
                           temp_data.flg_fill_type,
                           temp_data.format_num,
                           temp_data.id_unit_measure,
                           temp_data.id_context,
                           temp_data.flg_type,
                           rank() over(PARTITION BY temp_data.id_software, temp_data.id_content, temp_data.id_event ORDER BY temp_data.l_row) records_count
                      FROM (SELECT pop.rowid l_row,
                                   pop.id_content,
                                   decode(pop.id_event,
                                          NULL,
                                          NULL,
                                          pk_default_content.get_alert_event_id(i_lang, pop.id_event)) id_event,
                                   pop.periodic_observation_type,
                                   NULL id_clinical_service,
                                   pop.id_time_event_group,
                                   pop.flg_fill_type,
                                   pop.format_num,
                                   pop.id_unit_measure,
                                   pop.id_context,
                                   pop.flg_type,
                                   pop.id_software
                              FROM alert_default.periodic_observation_param pop
                             WHERE pop.id_software IN
                                   (SELECT /*+ dynamic_sampling(p 2) */
                                     column_value
                                      FROM TABLE(CAST(i_id_software AS table_number)) p)
                               AND pop.id_market IN (SELECT /*+ dynamic_sampling(p 2) */
                                                      column_value
                                                       FROM TABLE(CAST(i_market AS table_number)) p)
                               AND pop.version IN (SELECT /*+ dynamic_sampling(p 2) */
                                                    column_value
                                                     FROM TABLE(CAST(i_version AS table_varchar)) p)
                               AND pop.flg_available = g_flg_available
                               AND pop.id_clinical_service IS NULL) temp_data
                     WHERE (temp_data.id_event != 0 OR temp_data.id_event IS NULL)) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS
             (SELECT pop.id_periodic_observation_param
                      FROM periodic_observation_param pop
                     WHERE pop.id_content = def_data.id_content
                       AND pop.id_clinical_service IS NULL
                       AND (pop.id_event = def_data.id_event OR (pop.id_event IS NULL AND def_data.id_event IS NULL))
                       AND pop.id_institution = i_id_institution
                       AND pop.id_software = def_data.id_software
                       AND pop.flg_available = g_flg_available);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_pop_config);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_periodic_obs_param;

    /********************************************************************************************
    * Get Periodic observation param desc for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_pod_id_pop          Cursor of periodic observation param desc identifiers
    * @param o_pod_value           Cursor of eriodic observation param desc values
    * @param o_pod_icon            Cursor of periodic observation param desc icons
    * @param o_pod_id_content      Cursor of periodic observation param desc Content identifier
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/16
    ********************************************************************************************/
    FUNCTION get_inst_periodic_obs_desc
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_cursor_config  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- error handling external methods
        l_exception EXCEPTION;
    BEGIN
        g_func_name := upper('get_inst_periodic_obs_desc');
        g_error     := 'OPEN CONFIGURATION CURSOR';
        OPEN o_cursor_config FOR
            SELECT def_data.id_periodic_observation_param, def_data.pod_id_content, def_data.value, def_data.icon
              FROM (SELECT norm_data.id_periodic_observation_param,
                           norm_data.value,
                           norm_data.icon,
                           norm_data.pod_id_content,
                           rank() over(PARTITION BY norm_data.id_periodic_observation_param, norm_data.pod_id_content ORDER BY norm_data.l_row) records_count
                      FROM (SELECT temp_data.l_row,
                                   pk_default_content.get_alert_periodic_obs_id(i_lang,
                                                                                temp_data.pop_id_content,
                                                                                temp_data.id_clinical_service,
                                                                                temp_data.id_software,
                                                                                temp_data.id_event,
                                                                                temp_data.id_market) id_periodic_observation_param,
                                   temp_data.pod_id_content,
                                   temp_data.value,
                                   temp_data.icon
                              FROM (SELECT def_pod.rowid               l_row,
                                           def_pop.id_clinical_service,
                                           def_pop.id_event,
                                           def_pop.id_software,
                                           def_pop.id_content          pop_id_content,
                                           def_pod.id_content          pod_id_content,
                                           def_pod.value,
                                           def_pod.icon,
                                           def_pod.id_market
                                      FROM alert_default.periodic_observation_desc def_pod
                                     INNER JOIN alert_default.periodic_observation_param def_pop
                                        ON (def_pop.id_periodic_observation_param = def_pod.id_periodic_observation_param AND
                                           def_pop.flg_available = g_flg_available AND
                                           def_pop.id_market = def_pod.id_market AND def_pop.version = def_pod.version)
                                     WHERE def_pod.flg_available = g_flg_available
                                       AND def_pop.id_clinical_service IS NULL
                                       AND def_pod.id_market IN
                                           (SELECT /*+ dynamic_sampling(p 2) */
                                             column_value
                                              FROM TABLE(CAST(i_market AS table_number)) p)
                                       AND def_pod.version IN
                                           (SELECT /*+ dynamic_sampling(p 2) */
                                             column_value
                                              FROM TABLE(CAST(i_version AS table_varchar)) p)) temp_data
                             WHERE (temp_data.id_clinical_service IS NULL OR temp_data.id_clinical_service != 0)
                               AND (temp_data.id_event IS NULL OR temp_data.id_event != 0)) norm_data
                     WHERE norm_data.id_periodic_observation_param != 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS
             (SELECT 0
                      FROM periodic_observation_desc alert_pod
                     WHERE alert_pod.id_periodic_observation_param = def_data.id_periodic_observation_param
                       AND alert_pod.flg_available = g_flg_available
                       AND alert_pod.id_content = def_data.pod_id_content);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_cursor_config);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_periodic_obs_desc;

    /********************************************************************************************
    * Set Periodic observations for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_inst_periodic_obs_param  Cursor of Instituition Periodic Observations
    * @param o_error                    Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/17
    ********************************************************************************************/
    FUNCTION set_inst_periodic_obs_param
    (
        i_lang                    IN language.id_language%TYPE,
        i_market                  IN table_number,
        i_version                 IN table_varchar,
        i_id_institution          IN institution.id_institution%TYPE,
        i_software                IN table_number,
        o_inst_periodic_obs_param OUT pk_types.cursor_type,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- detail arrays   
        l_data_pop_id_software table_number;
        l_data_pop_id_content  table_varchar;
        l_data_pop_id_event    table_number;
        l_data_pop_po_type     table_varchar;
        ---l_data_pop_id_cs       table_number;
        l_data_pop_id_teg      table_number;
        l_data_pop_fill_type   table_varchar;
        l_data_pop_format_num  table_varchar;
        l_data_pop_id_unit_mea table_number;
        l_data_pop_id_context  table_number;
        l_data_pop_flg_type    table_varchar;
    
        --TRANSLATION
        dml_errors   EXCEPTION;
        l_table_name user_tables.table_name%TYPE;
    
        -- auxiliar outputs
        c_input_internal  pk_types.cursor_type;
        c_input_internal2 pk_types.cursor_type;
        l_aux1            table_number := table_number();
        l_auxf            table_number := table_number();
    
        --error handling
        l_exception EXCEPTION;
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    
        l_error t_error_out;
        -- temporary translation
        o_trl_table t_tab_translation;
        o_trl_rec   t_rec_translation;
    
    BEGIN
    
        --PERIODIC_OBSERVATION_PARAM
        IF NOT get_inst_periodic_obs_param(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software,
                                           c_input_internal,
                                           l_error)
        THEN
            RAISE l_exception;
        ELSE
            g_func_name := upper('set_inst_periodic_obs_param');
            LOOP
            
                g_error := 'FETCH CONFIGURATION CURSOR';
                FETCH c_input_internal BULK COLLECT
                    INTO l_data_pop_id_software,
                         l_data_pop_id_content,
                         l_data_pop_id_event,
                         l_data_pop_po_type,
                         l_data_pop_id_teg,
                         l_data_pop_fill_type,
                         l_data_pop_format_num,
                         l_data_pop_id_unit_mea,
                         l_data_pop_id_context,
                         l_data_pop_flg_type LIMIT g_array_size;
                g_error := 'LOAD CONFIGURATIONS';
                FORALL j IN 1 .. l_data_pop_id_content.count SAVE EXCEPTIONS
                    INSERT INTO periodic_observation_param
                        (id_periodic_observation_param,
                         code_periodic_observation,
                         id_event,
                         periodic_observation_type,
                         id_clinical_service,
                         id_time_event_group,
                         flg_available,
                         flg_fill_type,
                         rank,
                         format_num,
                         id_unit_measure,
                         id_institution,
                         id_software,
                         id_context,
                         flg_type,
                         id_content)
                    VALUES
                        (seq_periodic_observation_param.nextval,
                         'PERIODIC_OBSERVATION_PARAM.CODE_PERIODIC_OBSERVATION.' ||
                         seq_periodic_observation_param.currval,
                         l_data_pop_id_event(j),
                         l_data_pop_po_type(j),
                         NULL,
                         l_data_pop_id_teg(j),
                         g_flg_available,
                         l_data_pop_fill_type(j),
                         0,
                         l_data_pop_format_num(j),
                         l_data_pop_id_unit_mea(j),
                         i_id_institution,
                         l_data_pop_id_software(j),
                         l_data_pop_id_context(j),
                         l_data_pop_flg_type(j),
                         l_data_pop_id_content(j))
                    RETURNING id_periodic_observation_param BULK COLLECT INTO l_aux1;
                l_auxf := l_auxf MULTISET UNION l_aux1;
                EXIT WHEN c_input_internal%NOTFOUND;
            END LOOP;
        
            CLOSE c_input_internal;
        
        END IF;
    
        SELECT t_rec_translation(def_data.code_translation,
                                 'ALERT',
                                 'ALERT.' || def_data.code_translation,
                                 'PERIODIC_OBSERVATION_PARAM',
                                 'PFH',
                                 def_data.desc_lang_1,
                                 def_data.desc_lang_2,
                                 def_data.desc_lang_3,
                                 def_data.desc_lang_4,
                                 def_data.desc_lang_5,
                                 def_data.desc_lang_6,
                                 def_data.desc_lang_7,
                                 def_data.desc_lang_8,
                                 def_data.desc_lang_9,
                                 def_data.desc_lang_10,
                                 def_data.desc_lang_11,
                                 def_data.desc_lang_12,
                                 def_data.desc_lang_13,
                                 def_data.desc_lang_14,
                                 def_data.desc_lang_15,
                                 def_data.desc_lang_16,
                                 def_data.desc_lang_17,
                                 def_data.desc_lang_18,
                                 def_data.desc_lang_19,
                                 def_data.desc_lang_20,
                                 def_data.desc_lang_21,
                                 def_data.desc_lang_22,
                                 NULL)
          BULK COLLECT
          INTO o_trl_table
          FROM (SELECT temp_data.code_translation,
                       def_t.desc_lang_1,
                       def_t.desc_lang_2,
                       def_t.desc_lang_3,
                       def_t.desc_lang_4,
                       def_t.desc_lang_5,
                       def_t.desc_lang_6,
                       def_t.desc_lang_7,
                       def_t.desc_lang_8,
                       def_t.desc_lang_9,
                       def_t.desc_lang_10,
                       def_t.desc_lang_11,
                       def_t.desc_lang_12,
                       def_t.desc_lang_13,
                       def_t.desc_lang_14,
                       def_t.desc_lang_15,
                       def_t.desc_lang_16,
                       def_t.desc_lang_17,
                       def_t.desc_lang_18,
                       def_t.desc_lang_19,
                       def_t.desc_lang_20,
                       def_t.desc_lang_21,
                       def_t.desc_lang_22
                  FROM (SELECT r_data.code_translation,
                               (SELECT def_pop.code_periodic_observation
                                  FROM alert_default.periodic_observation_param def_pop
                                 WHERE def_pop.id_periodic_observation_param = r_data.def_pop) def_code
                          FROM (SELECT pk_default_content.get_def_periodic_obs_id(1,
                                                                                  ext_pop.id_content,
                                                                                  ext_pop.id_clinical_service,
                                                                                  ext_pop.id_software,
                                                                                  ext_pop.id_event,
                                                                                  ext_pop.id_institution) def_pop,
                                       ext_pop.code_periodic_observation code_translation
                                  FROM periodic_observation_param ext_pop
                                 WHERE ext_pop.id_periodic_observation_param IN
                                       (SELECT /*+ dynamic_sampling(p 2) */
                                         column_value
                                          FROM TABLE(CAST(l_auxf AS table_number)) p)
                                   AND ext_pop.flg_available = 'Y') r_data
                         WHERE r_data.def_pop != 0) temp_data
                 INNER JOIN alert_default.translation def_t
                    ON (def_t.code_translation = temp_data.def_code)) def_data
         WHERE NOT EXISTS (SELECT 0
                  FROM TABLE(pk_translation.get_table_code_translation(1, 'PERIODIC_OBSERVATION_PARAM')) trl
                 WHERE trl.code_translation = def_data.code_translation);
    
        pk_translation.ins_bulk_translation(o_trl_table, g_flg_available);
        pk_alertlog.log_info('Translations: ' || SQL%ROWCOUNT || ' Inserted');
    
        pk_alertlog.log_info(l_auxf.count || ' rows inserted');
        g_error := 'RETURN DEFAULT IDS CONFIGURED';
        OPEN o_inst_periodic_obs_param FOR
            SELECT column_value
              FROM TABLE(CAST(l_auxf AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQLERRM(-SQL%BULK_EXCEPTIONS(idx).error_code);
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  SQL%BULK_EXCEPTIONS(idx).error_code,
                                                  error_msg,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_periodic_obs_param;

    /********************************************************************************************
    * Set Periodic observations desc. for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_inst_periodic_obs_desc   Cursor of Instituition Periodic Observations Desc.
    * @param o_error                    Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/17
    ********************************************************************************************/
    FUNCTION set_inst_periodic_obs_desc
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_pod       OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- detail arrays   
        l_data_pop_id         table_number;
        l_data_pod_id_content table_varchar;
        l_data_pod_value      table_varchar;
        l_data_pod_icon       table_varchar;
    
        --TRANSLATION
        dml_errors   EXCEPTION;
        l_table_name user_tables.table_name%TYPE;
    
        -- auxiliar outputs
        c_input_internal  pk_types.cursor_type;
        c_input_internal2 pk_types.cursor_type;
        l_aux1            table_number := table_number();
        l_auxf            table_number := table_number();
    
        --error handling
        l_exception EXCEPTION;
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    
        l_error t_error_out;
        -- temporary translation
        o_trl_table t_tab_translation;
        o_trl_rec   t_rec_translation;
    
    BEGIN
        IF NOT get_inst_periodic_obs_desc(i_lang,
                                          i_market,
                                          i_version,
                                          i_id_institution,
                                          i_software,
                                          c_input_internal,
                                          l_error)
        THEN
            RAISE l_exception;
        ELSE
            g_func_name := upper('set_inst_periodic_obs_desc');
            LOOP
            
                g_error := 'FETCH CONFIGURATION CURSOR';
                FETCH c_input_internal BULK COLLECT
                    INTO l_data_pop_id, l_data_pod_id_content, l_data_pod_value, l_data_pod_icon LIMIT g_array_size;
                g_error := 'LOAD CONFIGURATIONS';
                FORALL j IN 1 .. l_data_pod_id_content.count SAVE EXCEPTIONS
                    INSERT INTO periodic_observation_desc
                        (id_periodic_observation_desc,
                         code_periodic_observation_desc,
                         id_periodic_observation_param,
                         flg_available,
                         rank,
                         VALUE,
                         adw_last_update,
                         icon,
                         id_content)
                    VALUES
                        (seq_periodic_observation_desc.nextval,
                         'PERIODIC_OBSERVATION_DESC.CODE_PERIODIC_OBSERVATION_DESC.' ||
                         seq_periodic_observation_desc.currval,
                         l_data_pop_id(j),
                         g_flg_available,
                         0,
                         l_data_pod_value(j),
                         SYSDATE,
                         l_data_pod_icon(j),
                         l_data_pod_id_content(j))
                    RETURNING id_periodic_observation_desc BULK COLLECT INTO l_aux1;
                l_auxf := l_auxf MULTISET UNION l_aux1;
                EXIT WHEN c_input_internal%NOTFOUND;
            END LOOP;
        
            CLOSE c_input_internal;
        
        END IF;
        pk_alertlog.log_info(l_auxf.count || ' rows inserted');
        g_error := 'RETURN DEFAULT IDS CONFIGURED';
        OPEN o_inst_pod FOR
            SELECT column_value
              FROM TABLE(CAST(l_auxf AS table_number));
    
        SELECT t_rec_translation(def_data.code_translation,
                                 'ALERT',
                                 'ALERT.' || def_data.code_translation,
                                 'PERIODIC_OBSERVATION_DESC',
                                 'PFH',
                                 def_data.desc_lang_1,
                                 def_data.desc_lang_2,
                                 def_data.desc_lang_3,
                                 def_data.desc_lang_4,
                                 def_data.desc_lang_5,
                                 def_data.desc_lang_6,
                                 def_data.desc_lang_7,
                                 def_data.desc_lang_8,
                                 def_data.desc_lang_9,
                                 def_data.desc_lang_10,
                                 def_data.desc_lang_11,
                                 def_data.desc_lang_12,
                                 def_data.desc_lang_13,
                                 def_data.desc_lang_14,
                                 def_data.desc_lang_15,
                                 def_data.desc_lang_16,
                                 def_data.desc_lang_17,
                                 def_data.desc_lang_18,
                                 def_data.desc_lang_19,
                                 def_data.desc_lang_20,
                                 def_data.desc_lang_21,
                                 def_data.desc_lang_22,
                                 NULL)
          BULK COLLECT
          INTO o_trl_table
          FROM (SELECT temp_data.code_translation,
                       def_t.desc_lang_1,
                       def_t.desc_lang_2,
                       def_t.desc_lang_3,
                       def_t.desc_lang_4,
                       def_t.desc_lang_5,
                       def_t.desc_lang_6,
                       def_t.desc_lang_7,
                       def_t.desc_lang_8,
                       def_t.desc_lang_9,
                       def_t.desc_lang_10,
                       def_t.desc_lang_11,
                       def_t.desc_lang_12,
                       def_t.desc_lang_13,
                       def_t.desc_lang_14,
                       def_t.desc_lang_15,
                       def_t.desc_lang_16,
                       def_t.desc_lang_17,
                       def_t.desc_lang_18,
                       def_t.desc_lang_19,
                       def_t.desc_lang_20,
                       def_t.desc_lang_21,
                       def_t.desc_lang_22
                  FROM (SELECT r_data.code_translation,
                               nvl((SELECT def_pod.code_periodic_observation_desc
                                     FROM alert_default.periodic_observation_desc def_pod
                                    WHERE def_pod.id_content = r_data.id_content
                                      AND def_pod.id_periodic_observation_param = r_data.id_pop
                                      AND def_pod.flg_available = 'Y'),
                                   NULL) code_translation_def
                          FROM (SELECT pod.code_periodic_observation_desc code_translation,
                                       pk_default_content.get_def_periodic_obs_id(i_lang,
                                                                                  pop.id_content,
                                                                                  pop.id_clinical_service,
                                                                                  pop.id_software,
                                                                                  pop.id_event,
                                                                                  pop.id_institution) id_pop,
                                       pod.id_content
                                  FROM periodic_observation_desc pod
                                 INNER JOIN periodic_observation_param pop
                                    ON (pop.id_periodic_observation_param = pod.id_periodic_observation_param)
                                 WHERE pod.flg_available = 'Y'
                                   AND pod.id_periodic_observation_desc IN
                                       (SELECT /*+ dynamic_sampling(p 2) */
                                         column_value
                                          FROM TABLE(CAST(l_auxf AS table_number)) p)
                                   AND rownum > 0) r_data
                         WHERE r_data.id_pop != 0) temp_data
                 INNER JOIN alert_default.translation def_t
                    ON (def_t.code_translation = temp_data.code_translation_def)
                 WHERE temp_data.code_translation_def IS NOT NULL) def_data
         WHERE NOT EXISTS (SELECT 0
                  FROM TABLE(pk_translation.get_table_code_translation(i_lang, 'PERIODIC_OBSERVATION_DESC')) trl
                 WHERE trl.code_translation = def_data.code_translation);
    
        pk_translation.ins_bulk_translation(o_trl_table, g_flg_available);
        pk_alertlog.log_info('Translations: ' || SQL%ROWCOUNT || ' Inserted');
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQLERRM(-SQL%BULK_EXCEPTIONS(idx).error_code);
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  SQL%BULK_EXCEPTIONS(idx).error_code,
                                                  error_msg,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_periodic_obs_desc;

    /********************************************************************************************
    * Get Internal medication for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_int_med             Cursor of drugs
    * @param o_int_med_vers        Cursor of drugs versions
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/20
    ********************************************************************************************/
    FUNCTION get_inst_int_med
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_int_med        OUT pk_types.cursor_type,
        o_int_med_vers   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --DRUG_DEP_CLIN_SERV
        l_id_drug   drug_dep_clin_serv.id_drug%TYPE := NULL;
        l_drug_vers drug_dep_clin_serv.vers%TYPE := NULL;
    
        l_drug_array      table_varchar := table_varchar();
        l_drug_vers_array table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_int_med_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT mm.id_drug, mm.vers
              FROM alert_default.drug_clin_serv dcs, mi_med mm
             WHERE dcs.flg_type = 'P'
               AND dcs.id_software = c_id_software
               AND dcs.id_clinical_service IS NULL
               AND dcs.id_market = c_market
               AND dcs.version = c_version
               AND dcs.id_drug = mm.id_drug;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_INT_MED_INST_SOFT CURSOR';
                OPEN c_int_med_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_int_med_inst_soft
                        INTO l_id_drug, l_drug_vers;
                    EXIT WHEN c_int_med_inst_soft%NOTFOUND;
                
                    --DRUG_DEP_CLIN_SERV          
                    IF l_id_drug IS NOT NULL
                    THEN
                        SELECT COUNT(ddcs.id_drug_dep_clin_serv)
                          INTO l_count
                          FROM drug_dep_clin_serv ddcs
                         WHERE ddcs.id_drug = l_id_drug
                           AND ddcs.id_dep_clin_serv IS NULL
                           AND ddcs.flg_type = 'P'
                           AND ddcs.id_institution = i_id_institution
                           AND ddcs.id_software = i_id_software
                           AND ddcs.vers = l_drug_vers;
                    
                        IF l_count = 0
                        THEN
                            l_drug_array.extend;
                            l_drug_vers_array.extend;
                        
                            l_drug_array(l_index) := l_id_drug;
                            l_drug_vers_array(l_index) := l_drug_vers;
                        
                            l_index := l_index + 1;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_INT_MED_INST_SOFT CURSOR';
                CLOSE c_int_med_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_INT_MED CURSOR';
        OPEN o_int_med FOR
            SELECT column_value
              FROM TABLE(CAST(l_drug_array AS table_varchar));
    
        g_error := 'CLOSE O_INT_MED_VERS CURSOR';
        OPEN o_int_med_vers FOR
            SELECT column_value
              FROM TABLE(CAST(l_drug_vers_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_INT_MED',
                                              o_error);
            pk_types.open_my_cursor(o_int_med);
            pk_types.open_my_cursor(o_int_med_vers);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_int_med;

    /********************************************************************************************
    * Set Internal medication for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_int_med        Cursor of Instituition Internal medication
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/20
    ********************************************************************************************/
    FUNCTION set_inst_int_med
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_int_med   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_drug      pk_types.cursor_type;
        l_c_drug_vers pk_types.cursor_type;
    
        l_data_drug      table_varchar;
        l_data_drug_vers table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --DRUG_DEP_CLIN_SERV
            IF NOT get_inst_int_med(i_lang,
                                    i_market,
                                    i_version,
                                    i_id_institution,
                                    i_software(i),
                                    l_c_drug,
                                    l_c_drug_vers,
                                    l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_int_med := l_c_drug;
            
                LOOP
                    FETCH l_c_drug BULK COLLECT
                        INTO l_data_drug LIMIT g_array_size;
                
                    FETCH l_c_drug_vers BULK COLLECT
                        INTO l_data_drug_vers LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_drug.count
                        INSERT INTO drug_dep_clin_serv
                            (id_drug_dep_clin_serv, id_drug, flg_type, id_institution, id_software, vers, rank)
                        VALUES
                            (seq_drug_dep_clin_serv.nextval,
                             l_data_drug(j),
                             'P',
                             i_id_institution,
                             i_software(i),
                             l_data_drug_vers(j),
                             0);
                
                    EXIT WHEN l_c_drug%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_drug;
                CLOSE l_c_drug_vers;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_INT_MED',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_INT_MED',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_int_med;

    /********************************************************************************************
    * Get External medication for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_ext_med             Cursor of drugs
    * @param o_ext_med_vers        Cursor of drugs version
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/21
    ********************************************************************************************/
    FUNCTION get_inst_ext_med
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_ext_med        OUT pk_types.cursor_type,
        o_ext_med_vers   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --EMB_DEP_CLIN_SERV
        l_emb_id       emb_dep_clin_serv.emb_id%TYPE := NULL;
        l_edcs_version emb_dep_clin_serv.vers%TYPE := NULL;
    
        l_drug_array      table_varchar := table_varchar();
        l_drug_vers_array table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_ext_med_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT mm.emb_id, mm.vers
              FROM alert_default.emb_clin_serv ecs, me_med mm
             WHERE ecs.id_software = c_id_software
               AND ecs.id_market = c_market
               AND ecs.version = c_version
               AND ecs.flg_type = 'P'
               AND ecs.id_dietary_drug IS NULL
               AND ecs.id_manipulated IS NULL
               AND ecs.id_clinical_service IS NULL
               AND ecs.emb_id = mm.emb_id;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_EXT_MED_INST_SOFT CURSOR';
                OPEN c_ext_med_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_ext_med_inst_soft
                        INTO l_emb_id, l_edcs_version;
                    EXIT WHEN c_ext_med_inst_soft%NOTFOUND;
                
                    --EMB_DEP_CLIN_SERV          
                    IF l_emb_id IS NOT NULL
                    THEN
                        SELECT COUNT(edcs.id_emb_dep_clin_serv)
                          INTO l_count
                          FROM emb_dep_clin_serv edcs
                         WHERE edcs.emb_id = l_emb_id
                           AND edcs.id_dep_clin_serv IS NULL
                           AND edcs.flg_type = 'P'
                           AND edcs.id_dietary_drug IS NULL
                           AND edcs.id_manipulated IS NULL
                           AND edcs.id_institution = i_id_institution
                           AND edcs.id_software = i_id_software
                           AND edcs.vers = l_edcs_version;
                    
                        IF l_count = 0
                        THEN
                            l_drug_array.extend;
                            l_drug_vers_array.extend;
                        
                            l_drug_array(l_index) := l_emb_id;
                            l_drug_vers_array(l_index) := l_edcs_version;
                        
                            l_index := l_index + 1;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_EXT_MED_INST_SOFT CURSOR';
                CLOSE c_ext_med_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_EXT_MED CURSOR';
        OPEN o_ext_med FOR
            SELECT column_value
              FROM TABLE(CAST(l_drug_array AS table_varchar));
    
        g_error := 'CLOSE O_EXT_MED_VERS CURSOR';
        OPEN o_ext_med_vers FOR
            SELECT column_value
              FROM TABLE(CAST(l_drug_vers_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_EXT_MED',
                                              o_error);
            pk_types.open_my_cursor(o_ext_med);
            pk_types.open_my_cursor(o_ext_med_vers);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_ext_med;

    /********************************************************************************************
    * Set External medication for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_ext_med        Cursor of Instituition External medication
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/04/21
    ********************************************************************************************/
    FUNCTION set_inst_ext_med
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_ext_med   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_drug      pk_types.cursor_type;
        l_c_drug_vers pk_types.cursor_type;
    
        l_data_drug      table_varchar;
        l_data_drug_vers table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            --DRUG_DEP_CLIN_SERV
            IF NOT get_inst_ext_med(i_lang,
                                    i_market,
                                    i_version,
                                    i_id_institution,
                                    i_software(i),
                                    l_c_drug,
                                    l_c_drug_vers,
                                    l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_ext_med := l_c_drug;
            
                LOOP
                    FETCH l_c_drug BULK COLLECT
                        INTO l_data_drug LIMIT g_array_size;
                
                    FETCH l_c_drug_vers BULK COLLECT
                        INTO l_data_drug_vers LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_drug.count
                        INSERT INTO emb_dep_clin_serv
                            (id_emb_dep_clin_serv, id_software, emb_id, flg_type, id_institution, vers, rank)
                        VALUES
                            (seq_emb_dep_clin_serv.nextval,
                             i_software(i),
                             l_data_drug(j),
                             'P',
                             i_id_institution,
                             l_data_drug_vers(j),
                             0);
                
                    EXIT WHEN l_c_drug%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_drug;
                CLOSE l_c_drug_vers;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_EXT_MED',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_EXT_MED',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_ext_med;
    /********************************************************************************************
    * Validate that ALERT Universes doesn't have ID_CONTENT with null value.
    *
    * @param i_lang                Prefered language ID
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/10/13
    ********************************************************************************************/
    FUNCTION validate_universes
    (
        i_lang  IN language.id_language%TYPE,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_health_plan_count  NUMBER := 0;
        l_intervention_count NUMBER := 0;
    
        l_exception EXCEPTION;
    
        PROCEDURE validate_null_health_plans(o_hp_count OUT NUMBER) IS
        BEGIN
        
            g_error := 'HEALTH PLANS WITH NULL ID_CONTENT';
            SELECT COUNT(hp.id_health_plan)
              INTO o_hp_count
              FROM health_plan hp
             WHERE hp.flg_available = g_flg_available
               AND hp.id_content IS NULL;
        
        END validate_null_health_plans;
    
        PROCEDURE validate_null_interventions(o_interv_count OUT NUMBER) IS
        BEGIN
        
            g_error := 'INTERVENTIONS WITH NULL ID_CONTENT';
            SELECT COUNT(i.id_intervention)
              INTO o_interv_count
              FROM intervention i
             WHERE i.flg_status = pk_alert_constant.g_active
               AND i.id_content IS NULL;
        
            IF o_interv_count > 0
            THEN
                RAISE l_exception;
            END IF;
        
        END validate_null_interventions;
    
    BEGIN
    
        validate_null_health_plans(l_health_plan_count);
    
        IF l_health_plan_count > 0
        THEN
            RAISE l_exception;
        END IF;
    
        validate_null_interventions(l_intervention_count);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'VALIDATE UNIVERSES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'VALIDATE UNIVERSES',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END validate_universes;

    /*********************************************************************************************
    * Set HEALTH PROGRAM for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_health_program         Cursor of Instituition Interventions
    * @param o_inst_health_program_event         Cursor of Instituition Interventions
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2009/03/31
    ********************************************************************************************/
    FUNCTION set_inst_health_program
    (
        i_lang                      IN language.id_language%TYPE,
        i_market                    IN table_number,
        i_version                   IN table_varchar,
        i_id_institution            IN institution.id_institution%TYPE,
        i_software                  IN table_number,
        o_inst_health_program       OUT pk_types.cursor_type,
        o_inst_health_program_event OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_func_name := upper('set_inst_health_program');
        g_error     := 'MERGE HEALTH_PROGRAM_SOFT_INST';
        MERGE INTO health_program_soft_inst hpsi
        USING (SELECT def_hpsi.id_health_program, def_hpsi.id_software, def_hpsi.flg_active
                 FROM alert_default.health_program_soft_inst def_hpsi
                INNER JOIN alert_default.health_program_mrk_vrs hpmv
                   ON (hpmv.id_health_program = def_hpsi.id_health_program)
                WHERE def_hpsi.flg_active = 'Y'
                  AND hpmv.id_market IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                          column_value
                                           FROM TABLE(CAST(i_market AS table_number)) p)
                  AND hpmv.version IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                        column_value
                                         FROM TABLE(CAST(i_version AS table_varchar)) p)
                  AND def_hpsi.id_software IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                                column_value
                                                 FROM TABLE(CAST(i_software AS table_number)) p)) def_data
        ON (def_data.id_health_program = hpsi.id_health_program AND def_data.id_software = hpsi.id_software AND i_id_institution = hpsi.id_institution)
        WHEN MATCHED THEN
            UPDATE
               SET flg_active = def_data.flg_active
        WHEN NOT MATCHED THEN
            INSERT
                (id_health_program, id_institution, id_software, flg_active)
            VALUES
                (def_data.id_health_program, i_id_institution, def_data.id_software, def_data.flg_active);
    
        g_error := 'MERGE HEALTH_PROGRAM_SOFT_EVENT';
        MERGE INTO health_program_event hpe
        USING (SELECT temp_data.id_health_program, temp_data.id_event, temp_data.id_software, temp_data.flg_active
                 FROM (SELECT def_hpe.id_health_program,
                              nvl(pk_backoffice_default.get_event_alert(i_lang, def_hpe.id_event), 0) id_event /*def_hpe.id_event*/,
                              def_hpe.id_software,
                              def_hpe.flg_active
                         FROM alert_default.health_program_event def_hpe
                        INNER JOIN alert_default.health_program_mrk_vrs hpmv
                           ON (hpmv.id_health_program = def_hpe.id_health_program)
                        WHERE def_hpe.flg_active = 'Y'
                          AND hpmv.id_market IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                                  column_value
                                                   FROM TABLE(CAST(i_market AS table_number)) p)
                          AND hpmv.version IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                                column_value
                                                 FROM TABLE(CAST(i_version AS table_varchar)) p)
                          AND def_hpe.id_software IN
                              (SELECT /*+ opt_estimate(p rows = 10)*/
                                column_value
                                 FROM TABLE(CAST(i_software AS table_number)) p)) temp_data
                WHERE temp_data.id_event != 0) def_data
        ON (def_data.id_health_program = hpe.id_health_program AND def_data.id_event = hpe.id_event AND i_id_institution = hpe.id_institution AND def_data.id_software = hpe.id_software)
        WHEN MATCHED THEN
            UPDATE
               SET hpe.flg_active = def_data.flg_active
        WHEN NOT MATCHED THEN
            INSERT
                (id_health_program, id_event, id_institution, id_software, dt_hpg_event_tstz, flg_active)
            VALUES
                (def_data.id_health_program,
                 def_data.id_event,
                 i_id_institution,
                 def_data.id_software,
                 current_timestamp,
                 def_data.flg_active);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_BACKOFFICE_DEFAULT',
                                              'set_inst_health_program',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_health_program;

    FUNCTION get_event_alert
    (
        i_lang      IN language.id_language%TYPE,
        id_event_df IN event.id_event%TYPE
    ) RETURN NUMBER IS
    
        CURSOR c_events(c_id_event IN NUMBER) IS
            SELECT e.flg_group, e.id_event_group, e.id_group, e.flg_most_freq
              FROM alert_default.event e
             WHERE e.id_event = c_id_event;
    
        l_e_flg_group      event.flg_group%TYPE;
        l_e_id_event_group event.id_event_group%TYPE;
        l_e_id_group       event.id_group%TYPE;
        l_e_flg_most_freq  event.flg_most_freq%TYPE;
        l_id_event_group   event.id_event_group%TYPE;
        l_error            t_error_out;
        l_id_analysis      analysis.id_analysis%TYPE;
        l_id_event         event.id_event%TYPE;
        l_id_habit         habit.id_habit%TYPE;
        l_id_vital_sign    event.id_group%TYPE;
    
    BEGIN
    
        IF id_event_df IS NOT NULL
        THEN
        
            OPEN c_events(id_event_df);
        
            FETCH c_events
                INTO l_e_flg_group, l_e_id_event_group, l_e_id_group, l_e_flg_most_freq;
        
            SELECT nvl((SELECT eg.id_event_group
                         FROM event_group eg
                        WHERE eg.id_event_group = l_e_id_event_group),
                       0)
              INTO l_id_event_group
              FROM dual;
        
            IF l_e_flg_group = 'A'
            THEN
                SELECT nvl((SELECT a.id_analysis
                             FROM analysis a
                            WHERE a.id_content = (SELECT a2.id_content
                                                    FROM alert_default.analysis a2
                                                   WHERE a2.id_analysis = l_e_id_group)
                              AND a.id_content IS NOT NULL
                              AND a.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_analysis
                  FROM dual;
            
                IF l_id_analysis != 0
                THEN
                
                    SELECT nvl((SELECT id_event
                                 FROM (SELECT e.*
                                         FROM event e
                                        WHERE e.flg_group = l_e_flg_group
                                          AND e.id_event_group = l_id_event_group
                                          AND e.id_group = l_id_analysis
                                          AND e.flg_most_freq = l_e_flg_most_freq
                                          AND rownum = 1
                                        ORDER BY id_group, flg_group, id_event_group)),
                               NULL)
                      INTO l_id_event
                      FROM dual;
                
                END IF;
            
            ELSIF l_e_flg_group = 'H'
            THEN
                SELECT nvl((SELECT h.id_habit
                             FROM habit h
                            WHERE h.id_content = (SELECT h2.id_content
                                                    FROM alert_default.habit h2
                                                   WHERE h2.id_habit = l_e_id_group)
                              AND h.id_content IS NOT NULL
                              AND h.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_habit
                  FROM dual;
            
                IF l_id_habit != 0
                THEN
                
                    SELECT nvl((SELECT id_event
                                 FROM (SELECT e.*
                                         FROM event e
                                        WHERE e.flg_group = l_e_flg_group
                                          AND e.id_event_group = l_id_event_group
                                          AND e.id_group = l_id_habit
                                          AND e.flg_most_freq = l_e_flg_most_freq
                                          AND rownum = 1
                                        ORDER BY id_group, flg_group, id_event_group)),
                               NULL)
                      INTO l_id_event
                      FROM dual;
                
                END IF;
            
            ELSIF l_e_flg_group = 'VS'
            THEN
            
                l_id_vital_sign := l_e_id_group;
            
                IF l_id_vital_sign != 0
                THEN
                
                    SELECT nvl((SELECT id_event
                                 FROM (SELECT e.*
                                         FROM event e
                                        WHERE e.flg_group = l_e_flg_group
                                          AND e.id_event_group = l_id_event_group
                                          AND e.id_group = l_id_vital_sign
                                          AND e.flg_most_freq = l_e_flg_most_freq
                                          AND rownum = 1
                                        ORDER BY id_group, flg_group, id_event_group)),
                               NULL)
                      INTO l_id_event
                      FROM dual;
                
                END IF;
            
            END IF;
        
            CLOSE c_events;
        
        END IF;
    
        RETURN l_id_event;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_SAMPLE_TEXT',
                                              l_error);
            RETURN 0;
        
    END get_event_alert;

    /********************************************************************************************
    * Set Cancel_reason for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_cancel_reason          Cursor of Instituition Exams
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2009/01/05
    ********************************************************************************************/
    FUNCTION set_inst_cancel_reason
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_software           IN table_number,
        o_inst_cancel_reason OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_error := 'IF NOT get_inst_cancel_reason';
        MERGE INTO cancel_rea_soft_inst crsi
        USING (SELECT def_crsi.id_cancel_reason,
                      def_crsi.id_profile_template,
                      def_crsi.id_software,
                      def_crsi.flg_available,
                      def_crsi.rank,
                      def_crsi.id_cancel_rea_area
                 FROM alert_default.cancel_rea_soft_inst def_crsi
                INNER JOIN alert_default.cancel_reason_mrk_vrs crmv
                   ON (crmv.id_cancel_reason = def_crsi.id_cancel_reason)
                WHERE def_crsi.flg_available = 'Y'
                  AND crmv.id_market IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                          column_value
                                           FROM TABLE(CAST(i_market AS table_number)) p)
                  AND crmv.version IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                        column_value
                                         FROM TABLE(CAST(i_version AS table_varchar)) p)
                  AND def_crsi.id_software IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                                column_value
                                                 FROM TABLE(CAST(i_software AS table_number)) p)) def_data
        ON (crsi.id_cancel_reason = def_data.id_cancel_reason AND crsi.id_profile_template = def_data.id_profile_template AND crsi.id_software = def_data.id_software AND crsi.id_cancel_rea_area = def_data.id_cancel_rea_area AND crsi.id_institution = i_id_institution)
        WHEN MATCHED THEN
            UPDATE
               SET crsi.flg_available = def_data.flg_available
        WHEN NOT MATCHED THEN
            INSERT
                (id_cancel_reason,
                 id_profile_template,
                 id_software,
                 id_institution,
                 flg_available,
                 rank,
                 id_cancel_rea_area)
            VALUES
                (def_data.id_cancel_reason,
                 def_data.id_profile_template,
                 def_data.id_software,
                 i_id_institution,
                 def_data.flg_available,
                 def_data.rank,
                 def_data.id_cancel_rea_area);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_BACKOFFICE_DEFAULT',
                                              'SET_INST_CANCEL_REASON',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_cancel_reason;

    /********************************************************************************************
    * Set Default External Cause
    *
    * @param i_lang                Prefered language ID
    * @param o_external_cause      External Cause
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/05
    ********************************************************************************************/
    FUNCTION set_def_external_cause
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        o_external_cause OUT table_number,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_index NUMBER := 1;
    
        --Necessity
        l_id_external_cause_def     external_cause.id_external_cause%TYPE;
        l_id_external_cause         external_cause.id_external_cause%TYPE;
        l_external_cause_id_content external_cause.id_content%TYPE;
        l_rank                      external_cause.rank%TYPE := NULL;
    
        --TRANSLATION
        dml_errors EXCEPTION;
    
        CURSOR c_external_cause_id_content
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT ec.id_external_cause, ec.rank, ec.id_content
              FROM alert_default.external_cause ec
              JOIN alert_default.external_cause_mrk_vrs ecmv
                ON ecmv.id_external_cause = ec.id_external_cause
               AND ecmv.id_market = c_market
               AND ecmv.version = c_version
             WHERE ec.flg_available = g_flg_available;
    BEGIN
        o_external_cause := table_number();
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'GET EXTERNAL CAUSE DATA';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_def_external_cause ' || g_error);
            
                OPEN c_external_cause_id_content(i_version(i), i_market(j));
                LOOP
                
                    g_error := 'GET EXTERNAL CAUSE INFO';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_def_external_cause ' || g_error);
                
                    FETCH c_external_cause_id_content
                        INTO l_id_external_cause_def, l_rank, l_external_cause_id_content;
                    EXIT WHEN c_external_cause_id_content%NOTFOUND;
                
                    g_error := 'GET ALERT EXTERNAL CAUSE ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_def_external_cause ' || g_error);
                
                    SELECT nvl((SELECT ec.id_external_cause
                                 FROM external_cause ec
                                WHERE ec.id_content = l_external_cause_id_content
                                  AND ec.id_content IS NOT NULL
                                  AND ec.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_external_cause
                      FROM dual;
                
                    IF l_id_external_cause = 0
                    THEN
                        g_error := 'GET seq_external_cause.NEXTVAL';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_def_external_cause ' || g_error);
                    
                        SELECT seq_external_cause.nextval
                          INTO l_id_external_cause
                          FROM dual;
                    
                        g_error := 'INSERT INTO EXTERNAL_CAUSE';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_def_external_cause ' || g_error);
                    
                        INSERT INTO external_cause
                            (id_external_cause, code_external_cause, rank, adw_last_update, flg_available, id_content)
                        VALUES
                            (l_id_external_cause,
                             'EXTERNAL_CAUSE.CODE_EXTERNAL_CAUSE.' || l_id_external_cause,
                             l_rank,
                             SYSDATE,
                             g_flg_available,
                             l_external_cause_id_content);
                    
                        o_external_cause.extend;
                    
                        o_external_cause(l_index) := l_id_external_cause;
                    
                        l_index := l_index + 1;
                    
                    ELSIF l_id_external_cause != 0
                    
                    THEN
                        o_external_cause.extend;
                    
                        o_external_cause(l_index) := l_id_external_cause;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                
                END LOOP;
            
                CLOSE c_external_cause_id_content;
            
            END LOOP;
        
        END LOOP;
    
        -- 16/03/2011 RMGM: changed way how translations are loaded
        g_table_name := upper('external_cause');
        g_error      := 'SET DEF TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_DEF_EXTERNAL_CAUSE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_def_external_cause;

    /********************************************************************************************
    * Get diet set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_diet                Cursor of diet
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/06
    ********************************************************************************************/
    FUNCTION get_inst_diet
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_diet           OUT pk_types.cursor_type,
        o_size           OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_content_def diet.id_content%TYPE := NULL;
        l_id_diet        diet.id_diet%TYPE := NULL;
    
        l_id_diet_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        -->Changed by Mauro Sousa 28/04/2010
        CURSOR c_diet_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT d.id_content
              FROM alert_default.diet d
              JOIN alert_default.diet_instit_soft dis
                ON dis.id_diet = d.id_diet
               AND dis.id_software = c_id_software
               AND dis.flg_available = g_flg_available
              JOIN alert_default.diet_mrk_vrs dmv
                ON dmv.id_diet = d.id_diet
               AND dmv.id_market = c_market
               AND dmv.version = c_version
             WHERE d.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN c_diet_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_diet ' || g_error);
            
                OPEN c_diet_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_diet_inst_soft
                        INTO l_id_content_def;
                    EXIT WHEN c_diet_inst_soft%NOTFOUND;
                
                    g_error := 'l_id_diet';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_diet ' || g_error);
                    -->Changed by Mauro Sousa 28/04/2010
                    SELECT nvl((SELECT d.id_diet
                                 FROM diet d
                                WHERE d.id_content = l_id_content_def
                                  AND d.id_content IS NOT NULL
                                  AND d.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_diet
                      FROM dual;
                
                    IF l_id_diet != 0
                    THEN
                        SELECT COUNT(dis.id_diet)
                          INTO l_count
                          FROM diet_instit_soft dis
                         WHERE dis.id_diet = l_id_diet
                           AND dis.id_institution = i_id_institution
                           AND dis.id_software = i_id_software
                           AND dis.flg_available = g_flg_available;
                    
                        IF l_count = 0
                        THEN
                            l_id_diet_array.extend;
                            l_id_diet_array(l_index) := l_id_diet;
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE c_diet_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_diet ' || g_error);
                CLOSE c_diet_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'open o_diet CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_diet ' || g_error);
        OPEN o_diet FOR
            SELECT DISTINCT column_value
              FROM TABLE(CAST(l_id_diet_array AS table_number));
    
        SELECT COUNT(DISTINCT column_value)
          INTO o_size
          FROM TABLE(CAST(l_id_diet_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_DIET',
                                              o_error);
            pk_types.open_my_cursor(o_diet);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_diet;

    /********************************************************************************************
    * Set diet for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_diet          Cursor of Instituition diet
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/06
    ********************************************************************************************/
    FUNCTION set_inst_diet
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_diet      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_diet    pk_types.cursor_type; -- cursor to read default information
        l_data_diet table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        l_size      NUMBER;
        l_data_id   table_number := table_number();
        l_count     NUMBER := 1;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT get_inst_diet';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_diet ' || g_error);
        
            IF NOT
                get_inst_diet(i_lang, i_market, i_version, i_id_institution, i_software(i), l_c_diet, l_size, l_error)
            THEN
                RAISE l_exception;
            ELSE
                IF l_size >= 1
                THEN
                
                    g_error := 'IF l_size >= 1';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_diet ' || g_error);
                
                    LOOP
                        FETCH l_c_diet BULK COLLECT
                            INTO l_data_diet LIMIT l_size;
                    
                        FOR j IN 1 .. l_data_diet.count
                        LOOP
                        
                            g_error := 'INSERT INTO diet_instit_soft';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_diet ' || g_error);
                        
                            INSERT INTO diet_instit_soft
                                (id_diet, flg_available, id_software, id_institution)
                            VALUES
                                (l_data_diet(j), g_flg_available, i_software(i), i_id_institution);
                        
                            l_data_id.extend;
                            l_data_id(l_count) := l_data_diet(j);
                            l_count := l_count + 1;
                        
                        END LOOP;
                    
                        EXIT WHEN l_c_diet%NOTFOUND;
                    END LOOP;
                
                    CLOSE l_c_diet;
                
                END IF;
            
            END IF;
        
        END LOOP;
    
        g_error := 'OPEN o_inst_diet';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_diet ' || g_error);
    
        OPEN o_inst_diet FOR
            SELECT column_value
              FROM TABLE(CAST(l_data_id AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DIET',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DIET',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_diet;

    /********************************************************************************************
    * Get codification set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_codification        Cursor of diet
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/06
    ********************************************************************************************/
    FUNCTION get_inst_codification
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN market.id_market%TYPE,
        i_version        IN VARCHAR2,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_codification   OUT pk_types.cursor_type,
        o_flg_default    OUT pk_types.cursor_type,
        o_size           OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_codification_def codification.id_codification%TYPE := NULL;
        l_id_codification     codification.id_codification%TYPE := NULL;
        l_id_cdf_content      codification.id_content%TYPE := NULL;
        l_flg_default         codification_instit_soft.flg_default%TYPE := NULL;
    
        l_id_codification_array table_number := table_number();
        l_flg_default_array     table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_codification_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT c.id_codification, c.id_content, cis.flg_default
              FROM alert_default.codification_instit_soft cis
             INNER JOIN alert_default.codification c
                ON (c.id_codification = cis.id_codification AND c.flg_available = g_flg_available)
             INNER JOIN alert_default.codification_mrk_vrs cmv
                ON (cmv.id_codification = c.id_codification AND cmv.id_market = c_market AND cmv.version = c_version)
             WHERE cis.id_software = c_id_software
               AND cis.id_codification = cmv.id_codification
               AND cis.flg_available = g_flg_available;
    
    BEGIN
        g_error := 'OPEN c_codification_inst_soft CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_codification ' || g_error);
    
        OPEN c_codification_inst_soft(i_id_software, i_version, i_market);
        LOOP
            FETCH c_codification_inst_soft
                INTO l_id_codification_def, l_id_cdf_content, l_flg_default;
            EXIT WHEN c_codification_inst_soft%NOTFOUND;
        
            SELECT nvl((SELECT c.id_codification
                         FROM codification c
                        WHERE c.id_content = l_id_cdf_content),
                       0)
              INTO l_id_codification
              FROM dual;
        
            IF l_id_codification != 0
            THEN
            
                g_error := 'IF l_id_codification != 0';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_codification ' || g_error);
            
                SELECT COUNT(cis.id_codification)
                  INTO l_count
                  FROM codification_instit_soft cis
                 WHERE cis.id_codification = l_id_codification
                   AND cis.id_institution = i_id_institution
                   AND cis.id_software = i_id_software
                   AND cis.flg_available = g_flg_available;
            
                IF l_count = 0
                THEN
                    g_error := 'IF l_count = 0';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_codification ' || g_error);
                
                    l_id_codification_array.extend;
                    l_flg_default_array.extend;
                    l_id_codification_array(l_index) := l_id_codification;
                    l_flg_default_array(l_index) := l_flg_default;
                
                    l_index := l_index + 1;
                END IF;
            
            END IF;
        
        END LOOP;
    
        g_error := 'CLOSE c_codification_inst_soft CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_codification ' || g_error);
    
        CLOSE c_codification_inst_soft;
    
        g_error := 'open o_codification CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_codification ' || g_error);
    
        OPEN o_codification FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_codification_array AS table_number));
    
        g_error := 'OPEN o_flg_default CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_codification ' || g_error);
    
        OPEN o_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_default_array AS table_varchar));
    
        o_size := l_index - 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_CODIFICATION',
                                              o_error);
            pk_types.open_my_cursor(o_codification);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_codification;

    /********************************************************************************************
    * Set Cancel_reason for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_cancel_reason          Cursor of Instituition Exams
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2009/01/05
    ********************************************************************************************/
    FUNCTION set_inst_codification
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_software          IN table_number,
        o_inst_codification OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_codification pk_types.cursor_type; -- cursor to read default information
        l_c_flg_default  pk_types.cursor_type; -- cursor to read default information
    
        l_data_codification table_number;
        l_data_flg_default  table_varchar;
        l_size              NUMBER;
        l_next              codification_instit_soft.id_codif_instit_soft%TYPE;
        l_id_inst_codif     table_number := table_number();
        l_count             NUMBER := 1;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            FOR mkt IN 1 .. i_market.count
            LOOP
                FOR vrs IN 1 .. i_version.count
                LOOP
                
                    g_error := 'IF NOT get_inst_codification';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_codification ' || g_error);
                
                    IF NOT get_inst_codification(i_lang,
                                                 i_market(mkt),
                                                 i_version(vrs),
                                                 i_id_institution,
                                                 i_software(i),
                                                 l_c_codification,
                                                 l_c_flg_default,
                                                 l_size,
                                                 l_error)
                    THEN
                        RAISE l_exception;
                    ELSE
                    
                        g_error := 'IF l_size >= 1';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_codification ' || g_error);
                    
                        IF l_size >= 1
                        THEN
                            LOOP
                                FETCH l_c_codification BULK COLLECT
                                    INTO l_data_codification LIMIT l_size;
                            
                                FETCH l_c_flg_default BULK COLLECT
                                    INTO l_data_flg_default LIMIT l_size;
                            
                                FOR j IN 1 .. l_data_codification.count
                                LOOP
                                
                                    SELECT seq_codification_instit_soft.nextval
                                      INTO l_next
                                      FROM dual;
                                
                                    g_error := 'INSERT INTO codification_instit_soft';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_codification ' || g_error);
                                
                                    INSERT INTO codification_instit_soft
                                        (id_codif_instit_soft,
                                         id_codification,
                                         id_institution,
                                         id_software,
                                         flg_default,
                                         flg_available)
                                    VALUES
                                        (l_next,
                                         l_data_codification(j),
                                         i_id_institution,
                                         i_software(i),
                                         l_data_flg_default(j),
                                         g_flg_available);
                                
                                    l_id_inst_codif.extend;
                                    l_id_inst_codif(l_count) := l_next;
                                    l_count := l_count + 1;
                                
                                END LOOP;
                            
                                EXIT WHEN l_c_codification%NOTFOUND;
                            
                            END LOOP;
                        
                            CLOSE l_c_codification;
                            CLOSE l_c_flg_default;
                        END IF;
                    END IF;
                END LOOP;
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN o_inst_codification FOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_codification ' || g_error);
    
        OPEN o_inst_codification FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_inst_codif AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_CANCEL_REASON',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_CANCEL_REASON',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_codification;

    /********************************************************************************************
    * Get advanced input set of markets, versions and sotwares
    *
    * @param i_lang                      Prefered language ID
    * @param i_market                    Market ID's
    * @param i_version                   ALERT version's
    * @param i_id_institution            Institution ID
    * @param i_id_software               Software ID
    * @param o_advanced_input            Cursor of advanced input
    * @param o_advanced_input_field      Cursor of advanced input field
    * @param o_error_message             Cursor of error message
    * @param o_rank                      Cursor of rank
    * @param o_error                     Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/06
    ********************************************************************************************/
    FUNCTION get_inst_advanced_input
    (
        i_lang                 IN language.id_language%TYPE,
        i_market               IN table_number,
        i_version              IN table_varchar,
        i_id_institution       IN institution.id_institution%TYPE,
        i_id_software          IN software.id_software%TYPE,
        o_advanced_input       OUT pk_types.cursor_type,
        o_advanced_input_field OUT pk_types.cursor_type,
        o_error_message        OUT pk_types.cursor_type,
        o_rank                 OUT pk_types.cursor_type,
        o_market               OUT pk_types.cursor_type,
        o_size                 OUT NUMBER,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_advanced_input       advanced_input.id_advanced_input%TYPE := NULL;
        l_id_advanced_input_field advanced_input_soft_inst.id_advanced_input_field%TYPE := NULL;
        l_error_message           advanced_input_soft_inst.error_message%TYPE := NULL;
        l_rank                    advanced_input_soft_inst.rank%TYPE := NULL;
        l_market                  advanced_input_soft_inst.id_market%TYPE := NULL;
    
        l_id_advanced_input_array table_number := table_number();
        l_id_ai_field_array       table_number := table_number();
        l_error_message_array     table_number := table_number();
        l_rank_array              table_number := table_number();
        l_market_array            table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_advanced_input_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT aiis.id_advanced_input,
                            aiis.id_advanced_input_field,
                            aiis.error_message,
                            aiis.rank,
                            aiis.id_market
              FROM alert_default.advanced_input_soft_inst aiis, alert_default.advanced_input_mrk_vrs aimv
             WHERE aiis.id_software = c_id_software
               AND aiis.id_advanced_input = aimv.id_advanced_input
               AND aimv.id_market = c_market
               AND aimv.version = c_version
               AND aiis.id_market = c_market
               AND aiis.flg_active = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN c_advanced_input_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_advanced_input ' || g_error);
            
                OPEN c_advanced_input_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_advanced_input_inst_soft
                        INTO l_id_advanced_input, l_id_advanced_input_field, l_error_message, l_rank, l_market;
                    EXIT WHEN c_advanced_input_inst_soft%NOTFOUND;
                
                    g_error := 'IF l_id_advanced_input != 0';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_advanced_input ' || g_error);
                
                    IF l_id_advanced_input != 0
                    THEN
                        SELECT COUNT(aiis.id_advanced_input)
                          INTO l_count
                          FROM advanced_input_soft_inst aiis
                         WHERE aiis.id_advanced_input = l_id_advanced_input
                           AND aiis.id_institution = i_id_institution
                           AND aiis.id_software = i_id_software
                           AND aiis.flg_active = g_flg_available;
                    
                        g_error := 'IF l_count = 0';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_advanced_input ' || g_error);
                    
                        IF l_count = 0
                        THEN
                        
                            l_id_advanced_input_array.extend;
                            l_id_ai_field_array.extend;
                            l_error_message_array.extend;
                            l_rank_array.extend;
                            l_market_array.extend;
                        
                            l_id_advanced_input_array(l_index) := l_id_advanced_input;
                            l_id_ai_field_array(l_index) := l_id_advanced_input_field;
                            l_error_message_array(l_index) := l_error_message;
                            l_rank_array(l_index) := l_rank;
                            l_market_array(l_index) := l_market;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE c_advanced_input_inst_soft CURSOR';
                CLOSE c_advanced_input_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'open o_advanced_input CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_advanced_input ' || g_error);
    
        OPEN o_advanced_input FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_advanced_input_array AS table_number));
    
        g_error := 'open o_advanced_input_field CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_advanced_input ' || g_error);
    
        OPEN o_advanced_input_field FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_ai_field_array AS table_number));
    
        g_error := 'open o_error_message CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_advanced_input ' || g_error);
    
        OPEN o_error_message FOR
            SELECT column_value
              FROM TABLE(CAST(l_error_message_array AS table_number));
    
        g_error := 'open o_rank CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_advanced_input ' || g_error);
    
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        g_error := 'open o_market CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_advanced_input ' || g_error);
    
        OPEN o_market FOR
            SELECT column_value
              FROM TABLE(CAST(l_market_array AS table_number));
    
        o_size := l_index - 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_ADVANCED_INPUT',
                                              o_error);
            pk_types.open_my_cursor(o_advanced_input);
            pk_types.open_my_cursor(o_advanced_input_field);
            pk_types.open_my_cursor(o_error_message);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_advanced_input;

    /********************************************************************************************
    * Set advanced input for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_advanced_input          Cursor of Instituition advanced input
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2009/01/06
    ********************************************************************************************/
    FUNCTION set_inst_advanced_input
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN table_number,
        i_version             IN table_varchar,
        i_id_institution      IN institution.id_institution%TYPE,
        i_software            IN table_number,
        o_inst_advanced_input OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_advanced_input       pk_types.cursor_type; -- cursor to read default information
        l_c_advanced_input_field pk_types.cursor_type; -- cursor to read default information
        l_c_error_message        pk_types.cursor_type; -- cursor to read default information
        l_c_rank                 pk_types.cursor_type; -- cursor to read default information
        l_c_market               pk_types.cursor_type; -- cursor to read default information
    
        l_data_advanced_input       table_number;
        l_data_error_message        table_varchar;
        l_data_advanced_input_field table_number;
        l_data_rank                 table_number;
        l_data_market               table_number;
        l_size                      NUMBER;
        l_next_id_aisi              advanced_input_soft_inst.id_advanced_input_soft_inst%TYPE;
    
        l_aisi  table_number := table_number();
        l_count NUMBER := 1;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT get_inst_advanced_input';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_advanced_input ' || g_error);
        
            IF NOT get_inst_advanced_input(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software(i),
                                           l_c_advanced_input,
                                           l_c_advanced_input_field,
                                           l_c_error_message,
                                           l_c_rank,
                                           l_c_market,
                                           l_size,
                                           l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                IF l_size >= 1
                THEN
                
                    g_error := 'IF l_size >= 1';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_advanced_input ' || g_error);
                
                    LOOP
                        FETCH l_c_advanced_input BULK COLLECT
                            INTO l_data_advanced_input LIMIT l_size;
                    
                        FETCH l_c_advanced_input_field BULK COLLECT
                            INTO l_data_advanced_input_field LIMIT l_size;
                    
                        FETCH l_c_error_message BULK COLLECT
                            INTO l_data_error_message LIMIT l_size;
                    
                        FETCH l_c_rank BULK COLLECT
                            INTO l_data_rank LIMIT l_size;
                    
                        FETCH l_c_market BULK COLLECT
                            INTO l_data_market LIMIT l_size;
                    
                        FOR j IN 1 .. l_data_advanced_input.count
                        LOOP
                        
                            g_error := 'INSERT INTO advanced_input_soft_inst';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_advanced_input ' || g_error);
                        
                            SELECT seq_advanced_input_soft_inst.nextval
                              INTO l_next_id_aisi
                              FROM dual;
                        
                            INSERT INTO advanced_input_soft_inst
                                (id_advanced_input_soft_inst,
                                 id_advanced_input,
                                 id_advanced_input_field,
                                 id_institution,
                                 id_software,
                                 flg_active,
                                 error_message,
                                 rank,
                                 id_market)
                            VALUES
                                (l_next_id_aisi,
                                 l_data_advanced_input(j),
                                 l_data_advanced_input_field(j),
                                 i_id_institution,
                                 i_software(i),
                                 g_flg_available,
                                 l_data_error_message(j),
                                 l_data_rank(j),
                                 l_data_market(j));
                        
                            l_aisi.extend;
                            l_aisi(l_count) := l_next_id_aisi;
                            l_count := l_count + 1;
                        
                        END LOOP;
                    
                        EXIT WHEN l_c_advanced_input%NOTFOUND;
                    
                    END LOOP;
                
                    CLOSE l_c_advanced_input;
                    CLOSE l_c_advanced_input_field;
                    CLOSE l_c_error_message;
                    CLOSE l_c_rank;
                    CLOSE l_c_market;
                END IF;
            END IF;
        
        END LOOP;
    
        g_error := 'open o_inst_advanced_input CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_advanced_input ' || g_error);
    
        OPEN o_inst_advanced_input FOR
            SELECT column_value
              FROM TABLE(CAST(l_aisi AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'set_inst_advanced_input',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'set_inst_advanced_input',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_advanced_input;
    /********************************************************************************************
    * Get notes profile set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_profile_template         Cursor of events
    * @param o_notes_config         Cursor of events
    * @param o_flg_write         Cursor of events
    * @param o_flg_read         Cursor of events
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/08
    ********************************************************************************************/

    FUNCTION get_inst_notes_profile_inst
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN table_number,
        i_version          IN table_varchar,
        i_id_institution   IN institution.id_institution%TYPE,
        o_profile_template OUT pk_types.cursor_type,
        o_notes_config     OUT pk_types.cursor_type,
        o_flg_write        OUT pk_types.cursor_type,
        o_flg_read         OUT pk_types.cursor_type,
        o_size             OUT NUMBER,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_profile_template_def notes_profile_inst.id_profile_template%TYPE;
        l_notes_config_def     notes_profile_inst.id_notes_config%TYPE;
        l_flg_write_def        notes_profile_inst.flg_write%TYPE;
        l_flg_read_def         notes_profile_inst.flg_read%TYPE;
    
        l_profile_template notes_profile_inst.id_profile_template%TYPE;
        l_notes_config     notes_profile_inst.id_notes_config%TYPE;
    
        l_profile_template_array table_number := table_number();
        l_notes_config_array     table_number := table_number();
        l_flg_write_array        table_varchar := table_varchar();
        l_flg_read_array         table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_notes_profile_inst
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT npi.id_profile_template, npi.id_notes_config, npi.flg_write, npi.flg_read
              FROM alert_default.notes_profile_inst npi, alert_default.notes_config_mrk_vrs ncmv
             WHERE ncmv.id_market = c_market
               AND ncmv.version = c_version
               AND npi.flg_available = g_flg_available
               AND ncmv.id_notes_config = npi.id_notes_config;
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN c_notes_profile_inst CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_notes_profile_inst ' || g_error);
            
                OPEN c_notes_profile_inst(i_version(i), i_market(j));
                LOOP
                    FETCH c_notes_profile_inst
                        INTO l_profile_template_def, l_notes_config_def, l_flg_write_def, l_flg_read_def;
                    EXIT WHEN c_notes_profile_inst%NOTFOUND;
                
                    SELECT nvl((SELECT nc.id_notes_config
                                 FROM notes_config nc
                                WHERE nc.id_notes_config = l_notes_config_def),
                               0)
                      INTO l_notes_config
                      FROM dual;
                
                    SELECT nvl((SELECT pt.id_profile_template
                                 FROM profile_template pt
                                WHERE pt.id_profile_template = l_profile_template_def),
                               0)
                      INTO l_profile_template
                      FROM dual;
                
                    g_error := 'IF l_notes_config != 0 AND l_profile_template != 0';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_notes_profile_inst ' || g_error);
                
                    IF l_notes_config != 0
                       AND l_profile_template != 0
                    THEN
                    
                        --NOTES_PROFILE_INST
                        SELECT COUNT(npi.id_notes_profile_inst)
                          INTO l_count
                          FROM notes_profile_inst npi
                         WHERE npi.id_institution = i_id_institution
                           AND npi.id_notes_config = l_notes_config
                           AND npi.id_profile_template = l_profile_template;
                    
                        g_error := 'IF l_count = 0';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_notes_profile_inst ' || g_error);
                    
                        IF l_count = 0
                        THEN
                            l_profile_template_array.extend;
                            l_notes_config_array.extend;
                            l_flg_write_array.extend;
                            l_flg_read_array.extend;
                        
                            l_profile_template_array(l_index) := l_profile_template_def;
                            l_notes_config_array(l_index) := l_notes_config_def;
                            l_flg_write_array(l_index) := l_flg_write_def;
                            l_flg_read_array(l_index) := l_flg_read_def;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE c_notes_profile_inst CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_notes_profile_inst ' || g_error);
            
                CLOSE c_notes_profile_inst;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'OPEN o_profile_template CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_notes_profile_inst ' || g_error);
    
        OPEN o_profile_template FOR
            SELECT column_value
              FROM TABLE(CAST(l_profile_template_array AS table_number));
    
        g_error := 'OPEN o_notes_config CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_notes_profile_inst ' || g_error);
    
        OPEN o_notes_config FOR
            SELECT column_value
              FROM TABLE(CAST(l_notes_config_array AS table_number));
    
        g_error := 'OPEN o_flg_write CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_notes_profile_inst ' || g_error);
    
        OPEN o_flg_write FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_write_array AS table_varchar));
    
        g_error := 'OPEN o_flg_read CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_notes_profile_inst ' || g_error);
    
        OPEN o_flg_read FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_read_array AS table_varchar));
    
        o_size := l_index - 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_NOTES_PROFILE_INST',
                                              o_error);
            pk_types.open_my_cursor(o_profile_template);
            pk_types.open_my_cursor(o_notes_config);
            pk_types.open_my_cursor(o_flg_write);
            pk_types.open_my_cursor(o_flg_read);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_notes_profile_inst;

    /********************************************************************************************
    * Set notes profile for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_notes_profile          Cursor of Instituition Exams
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2009/01/11
    ********************************************************************************************/
    FUNCTION set_inst_notes_profile_inst
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_software           IN table_number,
        o_inst_notes_profile OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_profile_template pk_types.cursor_type; -- cursor to read default information
        l_c_notes_config     pk_types.cursor_type; -- cursor to read default information
        l_c_flg_write        pk_types.cursor_type; -- cursor to read default information
        l_c_flg_read         pk_types.cursor_type; -- cursor to read default information
    
        l_data_profile_template table_number;
        l_data_notes_config     table_varchar;
        l_data_flg_write        table_varchar;
        l_data_flg_read         table_varchar;
        l_size                  NUMBER;
        l_next_npi              notes_profile_inst.id_notes_profile_inst%TYPE;
        l_id_npi                table_number := table_number();
        l_count                 NUMBER := 1;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT get_inst_notes_profile_inst';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_notes_profile_inst ' || g_error);
        
            IF NOT get_inst_notes_profile_inst(i_lang,
                                               i_market,
                                               i_version,
                                               i_id_institution,
                                               l_c_profile_template,
                                               l_c_notes_config,
                                               l_c_flg_write,
                                               l_c_flg_read,
                                               l_size,
                                               l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'IF l_size >= 1';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_notes_profile_inst ' || g_error);
            
                IF l_size >= 1
                THEN
                
                    LOOP
                        FETCH l_c_profile_template BULK COLLECT
                            INTO l_data_profile_template LIMIT l_size;
                    
                        FETCH l_c_notes_config BULK COLLECT
                            INTO l_data_notes_config LIMIT l_size;
                    
                        FETCH l_c_flg_write BULK COLLECT
                            INTO l_data_flg_write LIMIT l_size;
                    
                        FETCH l_c_flg_read BULK COLLECT
                            INTO l_data_flg_read LIMIT l_size;
                    
                        FOR j IN 1 .. l_data_profile_template.count
                        LOOP
                        
                            SELECT seq_notes_profile_inst.nextval
                              INTO l_next_npi
                              FROM dual;
                        
                            g_error := 'INSERT INTO notes_profile_inst';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_notes_profile_inst ' || g_error);
                        
                            INSERT INTO notes_profile_inst
                                (id_notes_profile_inst,
                                 id_profile_template,
                                 id_institution,
                                 id_notes_config,
                                 flg_write,
                                 flg_read,
                                 flg_available)
                            VALUES
                                (l_next_npi,
                                 l_data_profile_template(j),
                                 i_id_institution,
                                 l_data_notes_config(j),
                                 l_data_flg_write(j),
                                 l_data_flg_read(j),
                                 g_flg_available);
                        
                            l_id_npi.extend;
                            l_id_npi(l_count) := l_next_npi;
                            l_count := l_count + 1;
                        
                        END LOOP;
                    
                        EXIT WHEN l_c_profile_template%NOTFOUND;
                    
                    END LOOP;
                
                    CLOSE l_c_profile_template;
                    CLOSE l_c_notes_config;
                    CLOSE l_c_flg_write;
                    CLOSE l_c_flg_read;
                END IF;
            END IF;
        
        END LOOP;
    
        g_error := 'OPEN o_inst_notes_profile CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_notes_profile_inst ' || g_error);
    
        OPEN o_inst_notes_profile FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_npi AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_NOTES_PROFILE_INST',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_NOTES_PROFILE_INST',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_notes_profile_inst;
    /********************************************************************************************
    * Get sr_interv_duration set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_sr_interv_duration  Cursor of sr_interv_duration
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/06
    ********************************************************************************************/
    FUNCTION get_inst_sr_interv_duration
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        o_sr_interv_duration OUT pk_types.cursor_type,
        o_avg_duration       OUT pk_types.cursor_type,
        o_size               OUT NUMBER,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_sr_interv_duration_def sr_interv_duration.id_sr_intervention%TYPE := NULL;
        l_id_sr_interv              intervention.id_intervention%TYPE := NULL;
    
        l_id_sr_interv_content intervention.id_content%TYPE := NULL;
        l_avg_duration         sr_interv_duration.avg_duration%TYPE := NULL;
    
        l_id_sr_interv_array table_number := table_number();
        l_avg_array          table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_sr_interv_inst_soft
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT sid.id_sr_intervention, si.id_content, sid.avg_duration
              FROM alert_default.sr_interv_duration      sid,
                   alert_default.sr_intervention         si,
                   alert_default.sr_intervention_mrk_vrs simv
             WHERE sid.id_sr_intervention = si.id_sr_intervention
               AND sid.id_sr_intervention = simv.id_sr_intervention
               AND simv.id_market = c_market
               AND simv.version = c_version
               AND sid.id_sr_intervention = si.id_sr_intervention
               AND si.flg_status = pk_alert_constant.g_active
               AND sid.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN c_sr_interv_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_interv_duration ' || g_error);
            
                OPEN c_sr_interv_inst_soft(i_version(i), i_market(j));
                LOOP
                    FETCH c_sr_interv_inst_soft
                        INTO l_id_sr_interv_duration_def, l_id_sr_interv_content, l_avg_duration;
                    EXIT WHEN c_sr_interv_inst_soft%NOTFOUND;
                
                    IF l_id_sr_interv_content IS NOT NULL
                    THEN
                    
                        SELECT nvl((SELECT si.id_intervention
                                     FROM intervention si
                                    WHERE si.id_content = l_id_sr_interv_content),
                                   0)
                          INTO l_id_sr_interv
                          FROM dual;
                    
                        g_error := 'IF l_id_sr_interv != 0';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_interv_duration ' || g_error);
                    
                        IF l_id_sr_interv != 0
                        THEN
                        
                            SELECT COUNT(sid.id_sr_intervention)
                              INTO l_count
                              FROM sr_interv_duration sid
                             WHERE sid.id_sr_intervention = l_id_sr_interv
                               AND sid.id_institution = i_id_institution
                               AND sid.flg_available = g_flg_available;
                        
                            g_error := ' IF l_count = 0';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_interv_duration ' || g_error);
                        
                            IF l_count = 0
                            THEN
                                l_id_sr_interv_array.extend;
                                l_id_sr_interv_array(l_index) := l_id_sr_interv;
                                l_avg_array.extend;
                                l_avg_array(l_index) := l_avg_duration;
                                l_index := l_index + 1;
                            
                            END IF;
                        
                        END IF;
                    
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE c_sr_interv_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_interv_duration ' || g_error);
            
                CLOSE c_sr_interv_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'open o_sr_interv_duration CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_interv_duration ' || g_error);
    
        OPEN o_sr_interv_duration FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_sr_interv_array AS table_number));
    
        g_error := 'open o_avg_duration CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_interv_duration ' || g_error);
    
        OPEN o_avg_duration FOR
            SELECT column_value
              FROM TABLE(CAST(l_avg_array AS table_number));
    
        o_size := l_index - 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_SR_INTERV_DURATION',
                                              o_error);
            pk_types.open_my_cursor(o_sr_interv_duration);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_sr_interv_duration;

    /********************************************************************************************
    * Set Interventions for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_SR_inst_interv         Cursor of Instituition Interventions
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/11
    ********************************************************************************************/
    FUNCTION set_sr_interv_duration_inst
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_sr_inst_interv OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_intervention pk_types.cursor_type;
        l_c_avg_duration pk_types.cursor_type;
    
        l_data_intervention    table_number;
        l_data_avg_duration    table_number;
        l_size                 NUMBER;
        l_id_data_intervention table_number := table_number();
        l_count                NUMBER := 1;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT get_inst_sr_interv_duration';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_sr_interv_duration_inst ' || g_error);
        
            IF NOT get_inst_sr_interv_duration(i_lang,
                                               i_market,
                                               i_version,
                                               i_id_institution,
                                               l_c_intervention,
                                               l_c_avg_duration,
                                               l_size,
                                               l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := ' IF l_size >= 1';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_sr_interv_duration_inst ' || g_error);
            
                IF l_size >= 1
                THEN
                    LOOP
                        FETCH l_c_intervention BULK COLLECT
                            INTO l_data_intervention LIMIT l_size;
                    
                        FETCH l_c_avg_duration BULK COLLECT
                            INTO l_data_avg_duration LIMIT l_size;
                    
                        FOR j IN 1 .. l_data_intervention.count
                        LOOP
                        
                            g_error := 'INSERT INTO sr_interv_duration';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_sr_interv_duration_inst ' || g_error);
                        
                            INSERT INTO sr_interv_duration
                                (id_sr_intervention, id_institution, avg_duration, flg_available)
                            VALUES
                                (l_data_intervention(j), i_id_institution, l_data_avg_duration(j), g_flg_available);
                        
                            l_id_data_intervention.extend;
                            l_id_data_intervention(l_count) := l_data_intervention(j);
                            l_count := l_count + 1;
                        
                        END LOOP;
                    
                        EXIT WHEN l_c_intervention%NOTFOUND;
                    
                    END LOOP;
                
                    CLOSE l_c_intervention;
                    CLOSE l_c_avg_duration;
                END IF;
            END IF;
        
        END LOOP;
    
        g_error := 'open o_sr_inst_interv CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_sr_interv_duration_inst ' || g_error);
    
        OPEN o_sr_inst_interv FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_data_intervention AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'set_sr_interv_duration_inst',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'set_sr_interv_duration_inst',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_sr_interv_duration_inst;

    /********************************************************************************************
    * Get sr_posit set of markets, versions and softwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_ID_sr_posit                 Cursor of ID_sr_posit
    * @param o_ID_sr_parent  Cursor of ID_sr_parent
    * @param o_rank       Cursor of rank
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/18
    ********************************************************************************************/
    FUNCTION get_inst_sr_posit
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_sr_posit    OUT pk_types.cursor_type,
        o_id_sr_parent   OUT pk_types.cursor_type,
        o_rank           OUT pk_types.cursor_type,
        o_size           OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --SR_POSIT
        l_id_sr_posit  sr_posit.id_sr_posit%TYPE := NULL;
        l_id_sr_parent sr_posit_instit_soft.id_sr_parent%TYPE := NULL;
        l_rank         sr_posit_instit_soft.rank%TYPE := NULL;
    
        l_id_sr_posit_array  table_number := table_number();
        l_id_sr_parent_array table_number := table_number();
        l_rank_array         table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_sr_posit_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT spis.id_sr_posit, spis.id_sr_parent, spis.rank
              FROM alert_default.sr_posit_instit_soft spis, alert_default.sr_posit_mrk_vrs spmv
             WHERE spmv.id_market = c_market
               AND spmv.version = c_version
               AND spmv.id_sr_posit = spis.id_sr_posit
               AND spis.flg_available = g_flg_available
               AND spis.id_software = c_id_software;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN c_sr_posit_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_posit ' || g_error);
            
                OPEN c_sr_posit_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_sr_posit_inst_soft
                        INTO l_id_sr_posit, l_id_sr_parent, l_rank;
                    EXIT WHEN c_sr_posit_inst_soft%NOTFOUND;
                
                    IF l_id_sr_posit IS NOT NULL
                    THEN
                    
                        g_error := 'l_count';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_posit ' || g_error);
                    
                        SELECT COUNT(DISTINCT spis.id_sr_posit_instit_soft)
                          INTO l_count
                          FROM sr_posit_instit_soft spis
                         WHERE spis.flg_available = g_flg_available
                           AND spis.id_software = i_id_software
                           AND spis.id_sr_posit = l_id_sr_posit
                           AND spis.id_institution = i_id_institution;
                    
                        g_error := 'IF l_count = 0';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_posit ' || g_error);
                    
                        IF l_count = 0
                        THEN
                            l_id_sr_posit_array.extend;
                            l_id_sr_parent_array.extend;
                            l_rank_array.extend;
                        
                            l_id_sr_posit_array(l_index) := l_id_sr_posit;
                            l_id_sr_parent_array(l_index) := l_id_sr_parent;
                            l_rank_array(l_index) := l_rank;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE c_sr_posit_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_posit ' || g_error);
            
                CLOSE c_sr_posit_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'OPEN o_ID_sr_posit CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_posit ' || g_error);
    
        OPEN o_id_sr_posit FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_sr_posit_array AS table_number));
    
        g_error := 'OPEN o_ID_sr_parent CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_posit ' || g_error);
    
        OPEN o_id_sr_parent FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_sr_parent_array AS table_number));
    
        g_error := 'OPEN o_rank CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_sr_posit ' || g_error);
    
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        o_size := l_index - 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'get_inst_sr_posit',
                                              o_error);
            pk_types.open_my_cursor(o_id_sr_posit);
            pk_types.open_my_cursor(o_id_sr_parent);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_sr_posit;

    /********************************************************************************************
    * Set sr_posit for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_sr_posit         Cursor of Instituition Interventions
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/18
    ********************************************************************************************/
    FUNCTION set_inst_sr_posit
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_sr_posit  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_sr_posit  pk_types.cursor_type;
        l_c_id_sr_parent pk_types.cursor_type;
        l_c_rank         pk_types.cursor_type;
    
        l_data_id_sr_posit  table_number;
        l_data_id_sr_parent table_number;
        l_data_rank         table_number;
    
        l_size  NUMBER;
        l_count NUMBER := 1;
    
        l_id_sr_posit_instit_soft table_number := table_number();
        l_next                    sr_posit_instit_soft.id_sr_posit_instit_soft%TYPE;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT get_inst_sr_posit';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_sr_posit ' || g_error);
        
            IF NOT get_inst_sr_posit(i_lang,
                                     i_market,
                                     i_version,
                                     i_id_institution,
                                     i_software(i),
                                     l_c_id_sr_posit,
                                     l_c_id_sr_parent,
                                     l_c_rank,
                                     l_size,
                                     l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'IF l_size >= 1';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_sr_posit ' || g_error);
            
                IF l_size >= 1
                THEN
                
                    LOOP
                        FETCH l_c_id_sr_posit BULK COLLECT
                            INTO l_data_id_sr_posit LIMIT l_size;
                    
                        FETCH l_c_id_sr_parent BULK COLLECT
                            INTO l_data_id_sr_parent LIMIT l_size;
                    
                        FETCH l_c_rank BULK COLLECT
                            INTO l_data_rank LIMIT l_size;
                    
                        FOR j IN 1 .. l_data_id_sr_posit.count
                        LOOP
                        
                            SELECT seq_sr_posit_instit_soft.nextval
                              INTO l_next
                              FROM dual;
                        
                            g_error := ' INSERT INTO sr_posit_instit_soft';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_sr_posit ' || g_error);
                        
                            INSERT INTO sr_posit_instit_soft
                                (id_sr_posit_instit_soft,
                                 id_sr_posit,
                                 id_sr_parent,
                                 rank,
                                 id_institution,
                                 id_software,
                                 flg_available)
                            VALUES
                                (l_next,
                                 l_data_id_sr_posit(j),
                                 l_data_id_sr_parent(j),
                                 l_data_rank(j),
                                 i_id_institution,
                                 i_software(i),
                                 g_flg_available);
                        
                            l_id_sr_posit_instit_soft.extend;
                            l_id_sr_posit_instit_soft(l_count) := l_next;
                            l_count := l_count + 1;
                        
                        END LOOP;
                    
                        EXIT WHEN l_c_id_sr_posit%NOTFOUND;
                    
                    END LOOP;
                
                    CLOSE l_c_id_sr_posit;
                    CLOSE l_c_id_sr_parent;
                    CLOSE l_c_rank;
                END IF;
            
            END IF;
        
        END LOOP;
    
        g_error := 'OPEN o_inst_sr_posit FOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_sr_posit ' || g_error);
    
        OPEN o_inst_sr_posit FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_sr_posit_instit_soft AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'set_inst_sr_posit',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'set_inst_sr_posit',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_sr_posit;
    /********************************************************************************************
    * Get the available urgency levels 
    *
    * @param i_lang                  Prefered language ID
    * @param i_id_institution        Institution ID
    * @param o_duration cursor 
    * @param o_id_content cursor
    * @param o_id_wtl cursor
    * @param o_id_language cursor
    * @param o_desc_translation cursor 
    * @param o_id_wtl_lan cursor
    * @param o_id_lang cursor
    * @param o_desc cursor
    * @param o_id_wtl_d cursor
    * @param o_flag_translation cursor
    * @param o_desc cursor
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/21
    ********************************************************************************************/
    FUNCTION get_inst_wtl_urg_level
    (
        i_lang             IN language.id_language%TYPE,
        i_id_institution   IN institution.id_institution%TYPE,
        o_duration         OUT pk_types.cursor_type,
        o_id_content       OUT pk_types.cursor_type,
        o_id_wtl           OUT pk_types.cursor_type,
        o_flg_status       OUT pk_types.cursor_type,
        o_flg_param        OUT pk_types.cursor_type,
        o_wtl_descr        OUT pk_types.cursor_type,
        o_flag_translation OUT VARCHAR2,
        o_size1            OUT NUMBER,
        o_size2            OUT NUMBER,
        
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_duration_def       wtl_urg_level.duration%TYPE;
        l_id_wtl_content_def wtl_urg_level.id_content%TYPE;
        l_id_wtl_def         wtl_urg_level.id_wtl_urg_level%TYPE;
        l_flg_status         wtl_urg_level.flg_status%TYPE;
        l_flg_param          wtl_urg_level.flg_parameterization_type%TYPE;
        l_wtl_descr          wtl_urg_level.desc_wtl_urg_level%TYPE;
    
        l_id_lang          language.id_language%TYPE;
        l_desc_translation pk_translation.t_desc_translation;
    
        l_duration_array   table_number := table_number();
        l_id_wtl_array     table_number := table_number();
        l_id_content_array table_varchar := table_varchar();
    
        l_flg_status_array table_varchar := table_varchar();
        l_flg_param_array  table_varchar := table_varchar();
        l_wtl_descr_array  table_varchar := table_varchar();
    
        l_next_wtl wtl_urg_level.id_wtl_urg_level%TYPE;
        l_id_wtl   wtl_urg_level.id_wtl_urg_level%TYPE;
    
        l_count              NUMBER := 0;
        l_index              NUMBER := 1;
        l_index_translation1 NUMBER := 1;
        l_index_translation2 NUMBER := 1;
    
        CURSOR c_wtl_urg_level IS
            SELECT DISTINCT wul.duration,
                            wul.id_content,
                            wul.id_wtl_urg_level,
                            wul.flg_status,
                            wul.flg_parameterization_type,
                            wul.desc_wtl_urg_level
              FROM alert_default.wtl_urg_level wul
             WHERE wul.flg_available = g_flg_available;
    
        l_count_ig NUMBER;
    
    BEGIN
    
        o_flag_translation := pk_alert_constant.g_no;
    
        g_error := 'OPEN c_wtl_urg_level';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
    
        OPEN c_wtl_urg_level;
        LOOP
            FETCH c_wtl_urg_level
                INTO l_duration_def, l_id_wtl_content_def, l_id_wtl_def, l_flg_status, l_flg_param, l_wtl_descr;
            EXIT WHEN c_wtl_urg_level%NOTFOUND;
        
            g_error := 'IF l_id_wtl_content_def IS NOT NULL';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
        
            IF l_id_wtl_content_def IS NOT NULL
            THEN
            
                SELECT COUNT(*)
                  INTO l_count_ig
                  FROM institution_group ig
                 WHERE ig.id_institution = i_id_institution
                   AND ig.flg_relation = 'INST_CNT';
            
                g_error := 'IF l_count_ig = 0';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
            
                IF l_count_ig = 0
                THEN
                
                    SELECT COUNT(wul.id_wtl_urg_level)
                      INTO l_count
                      FROM wtl_urg_level wul
                     WHERE wul.id_content = l_id_wtl_content_def
                       AND wul.flg_available = g_flg_available
                       AND wul.id_institution = i_id_institution
                       AND wul.id_group IS NULL;
                
                    SELECT nvl((SELECT wul.id_wtl_urg_level
                                 FROM wtl_urg_level wul
                                WHERE wul.id_content = l_id_wtl_content_def
                                  AND wul.flg_available = g_flg_available
                                  AND wul.id_institution = i_id_institution
                                  AND wul.id_group IS NULL
                                  AND rownum = 1),
                               0)
                      INTO l_id_wtl
                      FROM dual;
                
                ELSE
                
                    SELECT COUNT(wul.id_wtl_urg_level)
                      INTO l_count
                      FROM wtl_urg_level wul
                     WHERE wul.id_content = l_id_wtl_content_def
                       AND wul.flg_available = g_flg_available
                       AND wul.id_group IS NOT NULL
                       AND wul.id_institution IS NULL;
                
                    SELECT nvl((SELECT wul.id_wtl_urg_level
                                 FROM wtl_urg_level wul
                                WHERE wul.id_content = l_id_wtl_content_def
                                  AND wul.flg_available = g_flg_available
                                  AND wul.id_group IS NOT NULL
                                  AND wul.id_institution IS NULL
                                  AND rownum = 1),
                               0)
                      INTO l_id_wtl
                      FROM dual;
                
                END IF;
            
                g_error := 'IF l_count = 0';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
            
                IF l_count = 0
                THEN
                
                    l_duration_array.extend;
                    l_id_wtl_array.extend;
                    l_id_content_array.extend;
                    l_flg_status_array.extend;
                    l_flg_param_array.extend;
                    l_wtl_descr_array.extend;
                
                    SELECT seq_wtl_urg_level.nextval
                      INTO l_next_wtl
                      FROM dual;
                
                    l_duration_array(l_index) := l_duration_def;
                    l_id_wtl_array(l_index) := l_next_wtl;
                    l_id_content_array(l_index) := l_id_wtl_content_def;
                    l_flg_status_array(l_index) := l_flg_status;
                    l_flg_param_array(l_index) := l_flg_param;
                    l_wtl_descr_array(l_index) := l_wtl_descr;
                
                    l_index := l_index + 1;
                END IF;
            
            END IF;
        
        END LOOP;
    
        CLOSE c_wtl_urg_level;
    
        g_error := 'o_duration';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
    
        OPEN o_duration FOR
            SELECT column_value
              FROM TABLE(CAST(l_duration_array AS table_number));
    
        g_error := 'o_id_content';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
    
        OPEN o_id_content FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_content_array AS table_varchar));
    
        g_error := 'o_flg_status';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
        OPEN o_flg_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_status_array AS table_varchar));
    
        g_error := 'o_flg_param';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
        OPEN o_flg_param FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_param_array AS table_varchar));
    
        g_error := 'o_wtl_descr';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
        OPEN o_wtl_descr FOR
            SELECT column_value
              FROM TABLE(CAST(l_wtl_descr_array AS table_varchar));
    
        g_error := 'o_id_wtl';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_wtl_urg_level ' || g_error);
    
        OPEN o_id_wtl FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_wtl_array AS table_number));
    
        o_size1 := l_index_translation1 - 1;
        o_size2 := l_index_translation2 - 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'get_inst_wtl_urg_level',
                                              o_error);
        
            pk_types.open_my_cursor(o_duration);
            pk_types.open_my_cursor(o_id_content);
            pk_types.open_my_cursor(o_flg_status);
            pk_types.open_my_cursor(o_flg_param);
            pk_types.open_my_cursor(o_wtl_descr);
            pk_types.open_my_cursor(o_id_wtl);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_wtl_urg_level;
    /*********************************************************************************************
    * Set WTL for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_id_institution      Institution ID
    * @param o_inst_wtl         Cursor of wtl data
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/21
    ********************************************************************************************/
    FUNCTION set_inst_wtl_urg_level
    (
        i_lang           IN language.id_language%TYPE,
        i_id_institution IN institution.id_institution%TYPE,
        o_inst_wtl       OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_duration   pk_types.cursor_type;
        l_c_id_content pk_types.cursor_type;
        l_c_flg_status pk_types.cursor_type;
        l_c_flg_param  pk_types.cursor_type;
        l_c_wtl_descr  pk_types.cursor_type;
        l_c_id_wtl     pk_types.cursor_type;
    
        l_flag_translation VARCHAR2(1);
    
        l_data_duration   table_number;
        l_data_id_content table_varchar;
        l_data_id_wtl     table_number;
        l_data_flg_status table_varchar;
        l_data_flg_param  table_varchar;
        l_data_wtl_descr  table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        dml_errors  EXCEPTION;
    
        l_size1 NUMBER;
        l_size2 NUMBER;
    
        j PLS_INTEGER;
    
        l_count_ig NUMBER;
        l_group    institution_group.id_group%TYPE := 0;
    BEGIN
    
        SELECT COUNT(*)
          INTO l_count_ig
          FROM institution_group ig
         WHERE ig.id_institution = i_id_institution
           AND ig.flg_relation = 'INST_CNT';
    
        g_error := 'IF l_count_ig > 0';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_wtl_urg_level ' || g_error);
    
        IF l_count_ig > 0
        THEN
        
            SELECT nvl((SELECT ig.id_group
                         FROM institution_group ig
                        WHERE ig.id_institution = i_id_institution
                          AND ig.flg_relation = 'INST_CNT'
                          AND rownum = 1),
                       0)
              INTO l_group
              FROM dual;
        
        END IF;
    
        g_error := 'IF NOT get_inst_wtl_urg_level';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_wtl_urg_level ' || g_error);
    
        IF NOT get_inst_wtl_urg_level(i_lang,
                                      i_id_institution,
                                      l_c_duration,
                                      l_c_id_content,
                                      l_c_id_wtl,
                                      l_c_flg_status,
                                      l_c_flg_param,
                                      l_c_wtl_descr,
                                      l_flag_translation,
                                      l_size1,
                                      l_size2,
                                      l_error)
        
        THEN
            RAISE l_exception;
        ELSE
        
            o_inst_wtl := l_c_id_wtl;
        
            LOOP
            
                FETCH l_c_duration BULK COLLECT
                    INTO l_data_duration LIMIT g_array_size;
            
                FETCH l_c_id_content BULK COLLECT
                    INTO l_data_id_content LIMIT g_array_size;
            
                FETCH l_c_id_wtl BULK COLLECT
                    INTO l_data_id_wtl LIMIT g_array_size;
            
                FETCH l_c_flg_status BULK COLLECT
                    INTO l_data_flg_status LIMIT g_array_size;
            
                FETCH l_c_flg_param BULK COLLECT
                    INTO l_data_flg_param LIMIT g_array_size;
            
                FETCH l_c_wtl_descr BULK COLLECT
                    INTO l_data_wtl_descr LIMIT g_array_size;
            
                IF l_count_ig = 0
                THEN
                
                    g_error := ' IF l_count_ig = 0';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_wtl_urg_level ' || g_error);
                
                    FORALL j IN 1 .. l_data_duration.count
                    
                        INSERT INTO wtl_urg_level
                            (id_wtl_urg_level,
                             code,
                             flg_available,
                             duration,
                             id_institution,
                             id_content,
                             flg_status,
                             flg_parameterization_type,
                             id_professional,
                             dt_creation,
                             dt_last_update,
                             desc_wtl_urg_level)
                        VALUES
                            (l_data_id_wtl(j),
                             'WTL_URG_LEVEL.CODE.' || l_data_id_wtl(j),
                             g_flg_available,
                             l_data_duration(j),
                             i_id_institution,
                             l_data_id_content(j),
                             l_data_flg_status(j),
                             l_data_flg_param(j),
                             NULL,
                             current_timestamp,
                             NULL,
                             l_data_wtl_descr(j));
                    EXIT WHEN l_c_duration%NOTFOUND;
                
                ELSE
                
                    g_error := ' INSERT INTO wtl_urg_level';
                
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_wtl_urg_level ' || g_error);
                
                    FORALL j IN 1 .. l_data_duration.count
                    
                        INSERT INTO wtl_urg_level
                            (id_wtl_urg_level,
                             code,
                             flg_available,
                             duration,
                             id_group,
                             id_content,
                             flg_status,
                             flg_parameterization_type,
                             id_professional,
                             dt_creation,
                             dt_last_update,
                             desc_wtl_urg_level)
                        VALUES
                            (l_data_id_wtl(j),
                             'WTL_URG_LEVEL.CODE.' || l_data_id_wtl(j),
                             g_flg_available,
                             l_data_duration(j),
                             l_group,
                             l_data_id_content(j),
                             l_data_flg_status(j),
                             l_data_flg_param(j),
                             NULL,
                             current_timestamp,
                             NULL,
                             l_data_wtl_descr(j));
                
                    EXIT WHEN l_c_duration%NOTFOUND;
                
                END IF;
            END LOOP;
        
            CLOSE l_c_duration;
            CLOSE l_c_id_content;
            CLOSE l_c_id_wtl;
        
        END IF;
    
        -- 16/03/2011 RMGM: changed way how translations are loaded
        g_table_name := upper('wtl_urg_level');
        g_error      := 'SET DEF TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'set_inst_wtl_urg_level',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'set_inst_wtl_urg_level',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_wtl_urg_level;

    /********************************************************************************************
    * Get ORIGIN set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_id_origin            Cursor of origin identification
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/22
    ********************************************************************************************/
    FUNCTION get_inst_origin_soft_inst
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_origin      OUT pk_types.cursor_type,
        o_size           OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_origin    origin.id_origin%TYPE := NULL;
        l_orig_content origin.id_content%TYPE := NULL;
    
        l_id_origin_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_origin_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT o.id_content
              FROM alert_default.origin o, alert_default.origin_soft_inst osi, alert_default.origin_mrk_vrs omv
             WHERE osi.id_origin = o.id_origin
               AND omv.id_origin = o.id_origin
               AND o.flg_available = g_flg_available
               AND osi.flg_available = g_flg_available
               AND osi.id_software = c_id_software
               AND omv.version = c_version
               AND omv.id_market = c_market;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN c_origin_inst_soft CURSOR';
            
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_origin_soft_inst ' || g_error);
            
                OPEN c_origin_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_origin_inst_soft
                        INTO l_orig_content;
                    EXIT WHEN c_origin_inst_soft%NOTFOUND;
                
                    IF l_orig_content IS NOT NULL
                    THEN
                    
                        g_error := 'ORIGIN';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_origin_soft_inst ' || g_error);
                    
                        SELECT nvl((SELECT o.id_origin
                                     FROM origin o
                                    WHERE o.id_content = l_orig_content
                                      AND o.id_content IS NOT NULL
                                      AND o.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_origin
                          FROM dual;
                    
                        IF l_id_origin != 0
                        THEN
                        
                            g_error := 'COUNT';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_origin_soft_inst ' || g_error);
                        
                            SELECT COUNT(osi.id_origin_soft_inst)
                              INTO l_count
                              FROM origin_soft_inst osi
                             WHERE osi.id_software = i_id_software
                               AND osi.id_institution = i_id_institution
                               AND osi.flg_available = g_flg_available
                               AND osi.id_origin = l_id_origin;
                        
                            IF l_count = 0
                            THEN
                            
                                l_id_origin_array.extend;
                                l_id_origin_array(l_index) := l_id_origin;
                                l_index := l_index + 1;
                            
                            END IF;
                        
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE c_origin_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_origin_soft_inst ' || g_error);
            
                CLOSE c_origin_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE o_id_origin CURSOR';
        OPEN o_id_origin FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_origin_array AS table_number));
    
        SELECT COUNT(column_value)
          INTO o_size
          FROM TABLE(CAST(l_id_origin_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'get_inst_origin',
                                              o_error);
            pk_types.open_my_cursor(o_id_origin);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_origin_soft_inst;

    /********************************************************************************************
    * Set Default origin
    *
    * @param i_lang                Prefered language ID
    * @param i_institution         Institution identification
    * @param o_origin              Origin
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/22
    ********************************************************************************************/
    FUNCTION set_inst_origin
    (
        i_lang   IN language.id_language%TYPE,
        o_origin OUT pk_types.cursor_type,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_index NUMBER := 1;
    
        --ORIGIN
        l_id_origin_def             origin.id_origin%TYPE;
        l_rank_def                  origin.rank%TYPE;
        l_flg_adt_inp_available_def origin.flg_adt_inp_available%TYPE;
        l_id_content_def            origin.id_content%TYPE;
        l_record_status_def         origin.record_status%TYPE;
        l_import_code_def           origin.import_code%TYPE;
    
        l_id_origin origin.id_origin%TYPE;
    
        --TRANSLATION
        dml_errors EXCEPTION;
    
        CURSOR c_origin IS
            SELECT o.id_origin, o.rank, o.flg_adt_inp_available, o.id_content, o.record_status, o.import_code
              FROM alert_default.origin o
             WHERE o.flg_available = g_flg_available;
    
        l_origin table_number;
    
    BEGIN
    
        l_origin := table_number();
    
        g_error := 'GET ORIGIN DATA';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ORIGIN ' || g_error);
    
        OPEN c_origin;
        LOOP
        
            g_error := 'GET ORIGIN INFO';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ORIGIN ' || g_error);
        
            FETCH c_origin
                INTO l_id_origin_def,
                     l_rank_def,
                     l_flg_adt_inp_available_def,
                     l_id_content_def,
                     l_record_status_def,
                     l_import_code_def;
            EXIT WHEN c_origin%NOTFOUND;
        
            g_error := 'GET ALERT ORIGIN ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ORIGIN ' || g_error);
        
            SELECT nvl((SELECT o.id_origin
                         FROM origin o
                        WHERE o.id_content = l_id_content_def
                          AND o.id_content IS NOT NULL
                          AND o.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_id_origin
              FROM dual;
        
            IF l_id_origin = 0
            THEN
            
                g_error := 'GET SEQ_ORIGIN.NEXTVAL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ORIGIN ' || g_error);
            
                SELECT seq_origin.nextval
                  INTO l_id_origin
                  FROM dual;
            
                g_error := 'INSERT INTO ORIGIN';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ORIGIN ' || g_error);
            
                INSERT INTO origin
                    (id_origin,
                     code_origin,
                     rank,
                     adw_last_update,
                     flg_available,
                     institution_key,
                     flg_adt_inp_available,
                     id_content,
                     record_status,
                     import_code)
                VALUES
                    (l_id_origin,
                     'ORIGIN.CODE_ORIGIN.' || l_id_origin,
                     l_rank_def,
                     SYSDATE,
                     g_flg_available,
                     NULL, --(ADT-2867)
                     l_flg_adt_inp_available_def,
                     l_id_content_def,
                     l_record_status_def,
                     l_import_code_def);
            
                l_origin.extend;
            
                l_origin(l_index) := l_id_origin;
            
                l_index := l_index + 1;
            
            ELSE
            
                l_origin.extend;
            
                l_origin(l_index) := l_id_origin;
            
                l_index := l_index + 1;
            
            END IF;
        
        END LOOP;
    
        CLOSE c_origin;
    
        g_error := 'OPEN o_origin FOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_ORIGIN ' || g_error);
    
        OPEN o_origin FOR
            SELECT column_value
              FROM TABLE(CAST(l_origin AS table_number));
    
        -- 12/04/2012 RMGM: changed way how translations are loaded
        g_table_name := 'ORIGIN';
        g_error      := 'SET DEF TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_ORIGIN',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_origin;
    /********************************************************************************************
    * Set ORIGIN for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_origin           Cursor of Instituition Lens
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/22
    ********************************************************************************************/
    FUNCTION set_inst_origin_soft_inst
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_origin    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_origin pk_types.cursor_type;
    
        l_data_id_origin table_number;
        l_size           NUMBER;
        l_next           origin_soft_inst.id_origin_soft_inst%TYPE;
        l_id_osi         table_number := table_number();
        l_count          NUMBER := 1;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT get_inst_origin_soft_inst';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_origin_soft_inst ' || g_error);
        
            IF NOT get_inst_origin_soft_inst(i_lang,
                                             i_market,
                                             i_version,
                                             i_id_institution,
                                             i_software(i),
                                             l_c_id_origin,
                                             l_size,
                                             l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'IF l_size >= 1';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_origin_soft_inst ' || g_error);
            
                IF l_size >= 1
                THEN
                
                    LOOP
                        FETCH l_c_id_origin BULK COLLECT
                            INTO l_data_id_origin LIMIT l_size;
                    
                        g_error := 'FOR j IN 1 .. l_data_id_origin.COUNT';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_origin_soft_inst ' || g_error);
                    
                        FOR j IN 1 .. l_data_id_origin.count
                        LOOP
                        
                            SELECT seq_origin_soft_inst.nextval
                              INTO l_next
                              FROM dual;
                        
                            g_error := 'INSERT INTO origin_soft_inst';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_origin_soft_inst ' || g_error);
                        
                            INSERT INTO origin_soft_inst
                                (id_origin_soft_inst, id_origin, id_software, id_institution, flg_available)
                            VALUES
                                (l_next, l_data_id_origin(j), i_software(i), i_id_institution, g_flg_available);
                        
                            l_id_osi.extend;
                            l_id_osi(l_count) := l_next;
                            l_count := l_count + 1;
                        
                        END LOOP;
                    
                        EXIT WHEN l_c_id_origin%NOTFOUND;
                    
                    END LOOP;
                
                    CLOSE l_c_id_origin;
                
                END IF;
            
            END IF;
        
        END LOOP;
    
        g_error := 'OPEN o_inst_origin FOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_origin_soft_inst ' || g_error);
    
        OPEN o_inst_origin FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_osi AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'set_inst_origin_soft_inst',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'set_inst_origin_soft_inst',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_origin_soft_inst;

    /********************************************************************************************
    * Get order set of markets, versions and sotwares
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param i_id_software             Software ID
    * @param o_id_order_set            cursor 
    * @param o_id_order_set_internal   cursor
    * @param o_id_os_prev_vers         cursor
    * @param o_title                   cursor
    * @param o_author_desc             cursor
    * @param o_flg_target_professional cursor
    * @param o_flg_edit_permission     cursor
    * @param o_flg_status              cursor
    * @param o_notes_global            cursor
    * @param o_flg_additional_info     cursor
    * @param o_id_content              cursor
    * @param o_error                   Error
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/25
    ********************************************************************************************/
    FUNCTION get_inst_order_set
    (
        i_lang                    IN language.id_language%TYPE,
        i_market                  IN table_number,
        i_version                 IN table_varchar,
        i_id_institution          IN institution.id_institution%TYPE,
        i_id_software             IN software.id_software%TYPE,
        o_id_order_set            OUT pk_types.cursor_type,
        o_id_order_set_internal   OUT pk_types.cursor_type,
        o_id_os_prev_vers         OUT pk_types.cursor_type,
        o_title                   OUT pk_types.cursor_type,
        o_author_desc             OUT pk_types.cursor_type,
        o_flg_target_professional OUT pk_types.cursor_type,
        o_flg_edit_permission     OUT pk_types.cursor_type,
        o_flg_status              OUT pk_types.cursor_type,
        o_notes_global            OUT pk_types.cursor_type,
        o_flg_additional_info     OUT pk_types.cursor_type,
        o_id_content              OUT pk_types.cursor_type,
        o_flag_update             OUT pk_types.cursor_type,
        o_size                    OUT NUMBER,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_os_def           order_set.id_order_set%TYPE;
        l_id_os_inter_def     order_set.id_order_set_internal%TYPE;
        l_id_os_prev_vers_def order_set.id_order_set_previous_version%TYPE;
        l_title_def           order_set.title%TYPE;
        l_author_desc_def     order_set.author_desc%TYPE;
        l_flg_target_prof_def order_set.flg_target_professionals%TYPE;
        l_flg_edit_perm_def   order_set.flg_edit_permissions%TYPE;
        l_flg_status_def      order_set.flg_status%TYPE;
        l_notes_global_def    order_set.notes_global%TYPE;
        l_flg_add_info_def    order_set.flg_additional_info%TYPE;
        l_id_content_def      order_set.id_content%TYPE;
    
        l_id_os_array           table_number := table_number();
        l_id_os_inter_array     table_varchar := table_varchar();
        l_id_os_prev_vers_array table_number := table_number();
        l_title_array           table_varchar := table_varchar();
        l_author_desc_array     table_varchar := table_varchar();
        l_flg_target_prof_array table_varchar := table_varchar();
        l_flg_edit_perm_array   table_varchar := table_varchar();
        l_flg_status_array      table_varchar := table_varchar();
        l_notes_global_array    table_varchar := table_varchar();
        l_flg_add_info_array    table_varchar := table_varchar();
        l_id_content_array      table_varchar := table_varchar();
    
        l_next_order_set NUMBER;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_order_set
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT os.id_order_set,
                            os.id_order_set_internal,
                            os.id_order_set_previous_version,
                            os.title,
                            os.author_desc,
                            os.flg_target_professionals,
                            os.flg_edit_permissions,
                            os.flg_status,
                            os.notes_global,
                            os.flg_additional_info,
                            os.id_content
              FROM alert_default.order_set os
             INNER JOIN alert_default.order_set_mrk_vrs osmv
                ON (osmv.id_order_set = os.id_order_set AND osmv.id_market = c_market AND osmv.version = c_version)
             WHERE EXISTS (SELECT 0
                      FROM alert_default.order_set_task ost
                     WHERE ost.id_order_set = os.id_order_set
                       AND rownum = 1);
    
        l_id_order_set      order_set.id_order_set%TYPE;
        l_count_content     NUMBER := 0;
        l_flag_update_array table_varchar := table_varchar();
    
        CURSOR c_order_set_update
        (
            i_id_software    IN software.id_software%TYPE,
            i_id_institution IN institution.id_institution%TYPE,
            l_id_content_def IN order_set.id_content%TYPE
        ) IS
            SELECT DISTINCT os.id_order_set
              FROM order_set os
             WHERE os.id_institution = i_id_institution
               AND os.id_software = i_id_software
               AND os.id_content = l_id_content_def;
        /*ALERT-199256 12/10/2011*/
    BEGIN
        g_func_name := 'GET_INST_ORDER_SET ';
    
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN c_order_set';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_order_set(i_version(i), i_market(j));
                LOOP
                    g_error := 'FETCH C_ORDER_SET';
                    FETCH c_order_set
                        INTO l_id_os_def,
                             l_id_os_inter_def,
                             l_id_os_prev_vers_def,
                             l_title_def,
                             l_author_desc_def,
                             l_flg_target_prof_def,
                             l_flg_edit_perm_def,
                             l_flg_status_def,
                             l_notes_global_def,
                             l_flg_add_info_def,
                             l_id_content_def;
                    EXIT WHEN c_order_set%NOTFOUND;
                
                    IF l_id_content_def IS NOT NULL
                    THEN
                    
                        g_error := 'SELECT COUNT(os.id_order_set)';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT COUNT(os.id_order_set)
                          INTO l_count
                          FROM order_set os
                         WHERE os.id_institution = i_id_institution
                           AND os.id_content = l_id_content_def;
                    
                        IF l_count = 0
                        THEN
                        
                            l_id_os_array.extend;
                            l_id_os_inter_array.extend;
                            l_id_os_prev_vers_array.extend;
                            l_title_array.extend;
                            l_author_desc_array.extend;
                            l_flg_target_prof_array.extend;
                            l_flg_edit_perm_array.extend;
                            l_flg_status_array.extend;
                            l_notes_global_array.extend;
                            l_flg_add_info_array.extend;
                            l_id_content_array.extend;
                            l_flag_update_array.extend;
                        
                            g_error := 'seq_order_set.NEXTVAL';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            SELECT seq_order_set.nextval
                              INTO l_next_order_set
                              FROM dual;
                        
                            l_id_os_array(l_index) := l_next_order_set;
                            l_id_os_inter_array(l_index) := l_id_os_inter_def;
                            l_id_os_prev_vers_array(l_index) := l_id_os_prev_vers_def;
                            l_title_array(l_index) := l_title_def;
                            l_author_desc_array(l_index) := l_author_desc_def;
                            l_flg_target_prof_array(l_index) := l_flg_target_prof_def;
                            l_flg_edit_perm_array(l_index) := l_flg_edit_perm_def;
                            l_flg_status_array(l_index) := l_flg_status_def;
                            l_notes_global_array(l_index) := l_notes_global_def;
                            l_flg_add_info_array(l_index) := l_flg_add_info_def;
                            l_id_content_array(l_index) := l_id_content_def;
                            l_flag_update_array(l_index) := pk_alert_constant.get_no;
                        
                            l_index := l_index + 1;
                        ELSE
                        
                            g_error := 'l_count_content';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            SELECT COUNT(os.id_order_set)
                              INTO l_count_content
                              FROM order_set os
                             WHERE os.id_institution = i_id_institution
                               AND os.id_software = i_id_software
                               AND os.id_content = l_id_content_def
                               AND os.id_order_set_internal = l_id_os_inter_def
                               AND os.id_order_set_previous_version = l_id_os_prev_vers_def
                               AND os.title = l_title_def
                               AND os.author_desc = l_author_desc_def
                               AND os.flg_target_professionals = l_flg_target_prof_def
                               AND os.flg_edit_permissions = l_flg_edit_perm_def
                               AND os.flg_status = l_flg_status_def
                               AND os.notes_global = l_notes_global_def
                               AND os.flg_additional_info = l_flg_add_info_def;
                        
                            IF l_count_content = 0
                            THEN
                            
                                OPEN c_order_set_update(i_id_software, i_id_institution, l_id_content_def);
                                LOOP
                                
                                    g_error := 'c_order_set_update';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    FETCH c_order_set_update
                                        INTO l_id_order_set;
                                    EXIT WHEN c_order_set_update%NOTFOUND;
                                
                                    IF l_id_order_set != 0
                                    THEN
                                    
                                        g_error := 'IF l_id_order_set != 0';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        l_id_os_array.extend;
                                        l_id_os_inter_array.extend;
                                        l_id_os_prev_vers_array.extend;
                                        l_title_array.extend;
                                        l_author_desc_array.extend;
                                        l_flg_target_prof_array.extend;
                                        l_flg_edit_perm_array.extend;
                                        l_flg_status_array.extend;
                                        l_notes_global_array.extend;
                                        l_flg_add_info_array.extend;
                                        l_id_content_array.extend;
                                        l_flag_update_array.extend;
                                    
                                        l_id_os_array(l_index) := l_id_order_set;
                                        l_id_os_inter_array(l_index) := l_id_os_inter_def;
                                        l_id_os_prev_vers_array(l_index) := l_id_os_prev_vers_def;
                                        l_title_array(l_index) := l_title_def;
                                        l_author_desc_array(l_index) := l_author_desc_def;
                                        l_flg_target_prof_array(l_index) := l_flg_target_prof_def;
                                        l_flg_edit_perm_array(l_index) := l_flg_edit_perm_def;
                                        l_flg_status_array(l_index) := l_flg_status_def;
                                        l_notes_global_array(l_index) := l_notes_global_def;
                                        l_flg_add_info_array(l_index) := l_flg_add_info_def;
                                        l_id_content_array(l_index) := l_id_content_def;
                                        l_flag_update_array(l_index) := g_yes;
                                    
                                        l_index := l_index + 1;
                                    
                                    END IF;
                                
                                END LOOP;
                                g_error := 'CLOSE C_ORDER_SET_UPDATE CURSOR';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                CLOSE c_order_set_update;
                            END IF;
                        END IF;
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_ORDER_SET CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_order_set;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'OPEN O_ID_ORDER_SET';
        OPEN o_id_order_set FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_os_array AS table_number));
    
        g_error := 'OPEN O_ID_ORDER_SET_INTERNAL';
        OPEN o_id_order_set_internal FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_os_inter_array AS table_varchar));
    
        g_error := 'OPEN O_ID_OS_PREV_VERS';
        OPEN o_id_os_prev_vers FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_os_prev_vers_array AS table_number));
    
        g_error := 'OPEN O_TITLE';
        OPEN o_title FOR
            SELECT column_value
              FROM TABLE(CAST(l_title_array AS table_varchar));
    
        g_error := 'OPEN O_AUTHOR_DESC';
        OPEN o_author_desc FOR
            SELECT column_value
              FROM TABLE(CAST(l_author_desc_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_TARGET_PROFESSIONAL';
        OPEN o_flg_target_professional FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_target_prof_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_EDIT_PERMISSION';
        OPEN o_flg_edit_permission FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_edit_perm_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_STATUS';
        OPEN o_flg_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_status_array AS table_varchar));
    
        g_error := 'OPEN O_NOTES_GLOBAL';
        OPEN o_notes_global FOR
            SELECT column_value
              FROM TABLE(CAST(l_notes_global_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_ADDITIONAL_INFO';
        OPEN o_flg_additional_info FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_add_info_array AS table_varchar));
    
        g_error := 'OPEN O_ID_CONTENT';
        OPEN o_id_content FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_content_array AS table_varchar));
    
        g_error := 'OPEN O_FLAG_UPDATE';
        OPEN o_flag_update FOR
            SELECT column_value
              FROM TABLE(CAST(l_flag_update_array AS table_varchar));
    
        o_size := l_index - 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_order_set);
            pk_types.open_my_cursor(o_id_order_set_internal);
            pk_types.open_my_cursor(o_id_os_prev_vers);
            pk_types.open_my_cursor(o_title);
            pk_types.open_my_cursor(o_author_desc);
            pk_types.open_my_cursor(o_flg_target_professional);
            pk_types.open_my_cursor(o_flg_edit_permission);
            pk_types.open_my_cursor(o_flg_status);
            pk_types.open_my_cursor(o_notes_global);
            pk_types.open_my_cursor(o_flg_additional_info);
            pk_types.open_my_cursor(o_id_content);
            pk_types.open_my_cursor(o_flag_update);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_order_set;

    /*********************************************************************************************
    * Set orders set for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_order_set         Cursor of Instituition order sets
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/25
    ********************************************************************************************/
    FUNCTION set_inst_order_set
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_order_set OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_order_set            pk_types.cursor_type;
        l_c_id_order_set_internal   pk_types.cursor_type;
        l_c_id_os_prev_vers         pk_types.cursor_type;
        l_c_title                   pk_types.cursor_type;
        l_c_author_desc             pk_types.cursor_type;
        l_c_flg_target_professional pk_types.cursor_type;
        l_c_flg_edit_permission     pk_types.cursor_type;
        l_c_flg_status              pk_types.cursor_type;
        l_c_notes_global            pk_types.cursor_type;
        l_c_flg_additional_info     pk_types.cursor_type;
        l_c_id_content              pk_types.cursor_type;
        l_c_flag_update             pk_types.cursor_type;
    
        l_data_id_os           table_number;
        l_data_id_os_inter     table_varchar;
        l_data_id_os_prev_vers table_number;
        l_data_title           table_varchar;
        l_data_author_desc     table_varchar;
        l_data_flg_target_prof table_varchar;
        l_data_flg_edit_perm   table_varchar;
        l_data_flg_statu       table_varchar;
        l_data_notes_global    table_varchar;
        l_data_flg_add_info    table_varchar;
        l_data_id_content      table_varchar;
        l_flag_update          table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        k           PLS_INTEGER;
        l_id_os     table_number := table_number();
        l_size      NUMBER;
        l_count_os  NUMBER := 1;
    BEGIN
        g_func_name := 'SET_INST_ORDER_SET ';
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT get_inst_order_set';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_order_set(i_lang,
                                      i_market,
                                      i_version,
                                      i_id_institution,
                                      i_software(i),
                                      l_c_id_order_set,
                                      l_c_id_order_set_internal,
                                      l_c_id_os_prev_vers,
                                      l_c_title,
                                      l_c_author_desc,
                                      l_c_flg_target_professional,
                                      l_c_flg_edit_permission,
                                      l_c_flg_status,
                                      l_c_notes_global,
                                      l_c_flg_additional_info,
                                      l_c_id_content,
                                      l_c_flag_update,
                                      l_size,
                                      l_error)
            THEN
                RAISE l_exception;
            ELSE
                IF l_size >= 1
                THEN
                    g_error := 'IF l_size >= 1 THEN';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    LOOP
                        FETCH l_c_id_order_set BULK COLLECT
                            INTO l_data_id_os LIMIT l_size;
                    
                        FETCH l_c_id_order_set_internal BULK COLLECT
                            INTO l_data_id_os_inter LIMIT l_size;
                    
                        FETCH l_c_id_os_prev_vers BULK COLLECT
                            INTO l_data_id_os_prev_vers LIMIT l_size;
                    
                        FETCH l_c_title BULK COLLECT
                            INTO l_data_title LIMIT l_size;
                    
                        FETCH l_c_author_desc BULK COLLECT
                            INTO l_data_author_desc LIMIT l_size;
                    
                        FETCH l_c_flg_target_professional BULK COLLECT
                            INTO l_data_flg_target_prof LIMIT l_size;
                    
                        FETCH l_c_flg_edit_permission BULK COLLECT
                            INTO l_data_flg_edit_perm LIMIT l_size;
                    
                        FETCH l_c_flg_status BULK COLLECT
                            INTO l_data_flg_statu LIMIT l_size;
                    
                        FETCH l_c_notes_global BULK COLLECT
                            INTO l_data_notes_global LIMIT l_size;
                    
                        FETCH l_c_flg_additional_info BULK COLLECT
                            INTO l_data_flg_add_info LIMIT l_size;
                    
                        FETCH l_c_id_content BULK COLLECT
                            INTO l_data_id_content LIMIT l_size;
                    
                        FETCH l_c_flag_update BULK COLLECT
                            INTO l_flag_update LIMIT l_size;
                    
                        g_error := 'FOR k IN 1 .. l_flag_update.COUNT';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        FOR k IN 1 .. l_flag_update.count
                        LOOP
                            IF l_flag_update(k) = g_yes
                            THEN
                                g_error := 'UPDATE order_set';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                UPDATE order_set os
                                   SET os.id_order_set_internal         = l_data_id_os_inter(k),
                                       os.id_order_set_previous_version = l_data_id_os_prev_vers(k),
                                       os.title                         = l_data_title(k),
                                       os.author_desc                   = l_data_author_desc(k),
                                       os.flg_target_professionals      = l_data_flg_target_prof(k),
                                       os.flg_edit_permissions          = l_data_flg_edit_perm(k),
                                       os.flg_status                    = l_data_flg_statu(k),
                                       os.notes_global                  = l_data_notes_global(k),
                                       os.flg_additional_info           = l_data_flg_add_info(k)
                                 WHERE os.id_institution = i_id_institution
                                   AND os.id_software = i_software(i)
                                   AND os.id_content = l_data_id_content(k)
                                   AND os.id_order_set = l_data_id_os(k);
                            ELSE
                            
                                g_error := 'INSERT INTO order_set';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                INSERT INTO order_set
                                    (id_order_set,
                                     id_order_set_internal,
                                     id_order_set_previous_version,
                                     title,
                                     author_desc,
                                     flg_target_professionals,
                                     flg_edit_permissions,
                                     flg_status,
                                     notes_global,
                                     flg_additional_info,
                                     dt_order_set_tstz,
                                     id_institution,
                                     id_software,
                                     id_content)
                                VALUES
                                    (l_data_id_os(k),
                                     l_data_id_os_inter(k),
                                     l_data_id_os_prev_vers(k),
                                     l_data_title(k),
                                     l_data_author_desc(k),
                                     l_data_flg_target_prof(k),
                                     l_data_flg_edit_perm(k),
                                     l_data_flg_statu(k),
                                     l_data_notes_global(k),
                                     l_data_flg_add_info(k),
                                     current_timestamp,
                                     i_id_institution,
                                     i_software(i),
                                     l_data_id_content(k));
                            
                                g_error := 'l_id_os.EXTEND';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                l_id_os.extend;
                                l_id_os(l_count_os) := l_data_id_os(k);
                                l_count_os := l_count_os + 1;
                            
                            END IF;
                        END LOOP;
                        EXIT WHEN l_c_id_order_set%NOTFOUND;
                    END LOOP;
                
                    g_error := 'CLOSE L_C_ID_ORDER_SET';
                    CLOSE l_c_id_order_set;
                    g_error := 'CLOSE L_C_ID_ORDER_SET_INTERNAL';
                    CLOSE l_c_id_order_set_internal;
                    g_error := 'CLOSE L_C_ID_OS_PREV_VERS';
                    CLOSE l_c_id_os_prev_vers;
                    g_error := 'CLOSE L_C_TITLE';
                    CLOSE l_c_title;
                    g_error := 'CLOSE L_C_AUTHOR_DESC';
                    CLOSE l_c_author_desc;
                    g_error := 'CLOSE L_C_FLG_TARGET_PROFESSIONAL';
                    CLOSE l_c_flg_target_professional;
                    g_error := 'CLOSE L_C_FLG_EDIT_PERMISSION';
                    CLOSE l_c_flg_edit_permission;
                    g_error := 'CLOSE L_C_FLG_STATUS';
                    CLOSE l_c_flg_status;
                    g_error := 'CLOSE L_C_NOTES_GLOBAL';
                    CLOSE l_c_notes_global;
                    g_error := 'CLOSE L_C_FLG_ADDITIONAL_INFO';
                    CLOSE l_c_flg_additional_info;
                    g_error := 'CLOSE L_C_ID_CONTENT';
                    CLOSE l_c_id_content;
                    g_error := 'CLOSE L_C_FLAG_UPDATE';
                    CLOSE l_c_flag_update;
                END IF;
            END IF;
        END LOOP;
    
        g_error := 'OPEN O_INST_ORDER_SET';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_inst_order_set FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_os AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_order_set;

    /********************************************************************************************
    * Get order set link set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_id_order_set        Cursor of interventions
    * @param o_id_link             Cursor of interv bandaid flags
    * @param o_flg_link_type       Cursor of interv chargeable flags
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/26
    ********************************************************************************************/
    FUNCTION get_inst_order_set_link
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_order_set   OUT pk_types.cursor_type,
        o_id_link        OUT pk_types.cursor_type,
        o_flg_link_type  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        --order_Set_link data
        l_id_order_set_def  order_set_link.id_order_set%TYPE := NULL;
        l_flg_link_type_def order_set_link.flg_link_type%TYPE := NULL;
        l_id_content_def    order_set.id_content%TYPE := NULL;
        l_id_link_def       order_set_link.id_link%TYPE := NULL;
        l_id_order_set      order_set_link.id_order_set%TYPE := NULL;
    
        l_id_order_set_array  table_number := table_number();
        l_flg_link_type_array table_varchar := table_varchar();
    
        l_id_link_array table_number := table_number();
    
        l_count_spec  NUMBER := 0;
        l_count_soft  NUMBER := 0;
        l_count_dept  NUMBER := 0;
        l_count_array NUMBER := 0;
        l_index       NUMBER := 1;
        l_count_comp  NUMBER := 0;
        l_count_osl   NUMBER := 0;
    
        CURSOR c_order_set_link
        (
            c_id_software software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT osl.id_order_set, os.id_content, osl.id_link, osl.flg_link_type
              FROM alert_default.order_set_link osl, alert_default.order_set os, alert_default.order_set_mrk_vrs osmv
             WHERE osl.id_order_set = os.id_order_set
               AND osl.id_order_set = osmv.id_order_set
               AND osmv.id_market = c_market
               AND osmv.version = c_version
               AND ((osl.flg_link_type = 'E' AND osl.id_link = c_id_software) OR osl.flg_link_type = 'S' OR
                   osl.flg_link_type = 'C');
    
        CURSOR c_software_dept
        (
            c_id_software    IN software.id_software%TYPE,
            c_id_institution institution.id_institution%TYPE,
            c_id_order_set   IN order_set_link.id_order_set%TYPE,
            c_flg_link_type  IN order_set_link.flg_link_type%TYPE
        ) IS
            SELECT DISTINCT t.id_dept
              FROM software_dept sd, dept t
             WHERE sd.id_software = c_id_software
               AND sd.id_dept = t.id_dept
               AND t.id_institution = c_id_institution
               AND t.flg_available = g_yes
               AND t.id_dept NOT IN (SELECT osl.id_link
                                       FROM order_set_link osl
                                      WHERE osl.id_order_set = c_id_order_set
                                        AND osl.flg_link_type = c_flg_link_type);
    
        CURSOR c_order_sets
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT os.id_order_set, os.id_content
              FROM alert_default.order_set os, alert_default.order_set_mrk_vrs osmv
             WHERE os.id_order_set = osmv.id_order_set
               AND osmv.id_market = c_market
               AND osmv.version = c_version;
    
        l_id_dept dept.id_dept%TYPE;
    
        l_var_s VARCHAR2(1) := pk_order_sets.g_order_set_link_spec;
        l_var_e VARCHAR2(1) := pk_order_sets.g_order_set_link_envi;
        l_var_c VARCHAR2(1) := pk_order_sets.g_order_set_link_chief_compl;
    
        CURSOR c_orderset
        (
            c_id_order_set  IN order_set_link.id_order_set%TYPE,
            c_id_link       IN order_set_link.id_link%TYPE,
            c_flg_link_type IN order_set_link.flg_link_type%TYPE
        ) IS
            SELECT COUNT(osl.id_order_set)
              FROM order_set_link osl
             WHERE osl.id_order_set = c_id_order_set
               AND osl.id_link = c_id_link
               AND osl.flg_link_type = c_flg_link_type;
        /*ALERT-199256 12/10/2011*/
    BEGIN
        g_func_name := 'GET_INST_ORDER_SET_LINK ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'C_ORDER_SET_LINK';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.get_inst_order_set_link ' || g_error);
                OPEN c_order_set_link(i_id_software, i_version(i), i_market(j));
                LOOP
                    g_error := 'FETCH C_ORDER_SET_LINK';
                    FETCH c_order_set_link
                        INTO l_id_order_set_def, l_id_content_def, l_id_link_def, l_flg_link_type_def;
                    EXIT WHEN c_order_set_link%NOTFOUND;
                
                    g_error := 'SELECT ID_ORDER_SET ' || l_id_content_def;
                    SELECT nvl((SELECT os.id_order_set
                                 FROM order_set os
                                WHERE os.id_content = l_id_content_def
                                  AND os.id_content IS NOT NULL
                                  AND os.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_order_set
                      FROM dual;
                
                    IF l_id_order_set != 0
                    THEN
                    
                        IF l_flg_link_type_def = l_var_c
                        THEN
                            g_error := 'L_LINK_TYPE_DEF ' || l_id_link_def || '/' || l_id_order_set;
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            SELECT COUNT(ol.id_order_set)
                              INTO l_count_osl
                              FROM order_set_link ol
                             WHERE ol.id_order_set = l_id_order_set
                               AND ol.id_link = l_id_link_def
                               AND ol.flg_link_type = l_flg_link_type_def;
                        
                            IF l_count_osl = 0
                            THEN
                            
                                SELECT COUNT(c.id_complaint)
                                  INTO l_count_comp
                                  FROM complaint c
                                 WHERE c.id_complaint = l_id_link_def;
                            
                                IF l_count_comp != 0
                                THEN
                                    g_error := 'IF L_COUNT_COMP != 0';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    l_id_order_set_array.extend;
                                    l_id_link_array.extend;
                                    l_flg_link_type_array.extend;
                                
                                    l_id_order_set_array(l_index) := l_id_order_set;
                                    l_flg_link_type_array(l_index) := l_flg_link_type_def;
                                    l_id_link_array(l_index) := l_id_link_def;
                                
                                    l_index := l_index + 1;
                                END IF;
                            END IF;
                        
                        ELSIF l_flg_link_type_def = l_var_s
                        THEN
                            g_error := 'L_COUNT_SPEC';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            OPEN c_orderset(c_id_order_set  => l_id_order_set,
                                            c_id_link       => l_id_link_def,
                                            c_flg_link_type => l_flg_link_type_def);
                            FETCH c_orderset
                                INTO l_count_spec;
                            CLOSE c_orderset;
                        
                            IF l_count_spec = 0
                            THEN
                                g_error := 'IF L_COUNT_SPEC = 0';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                l_id_order_set_array.extend;
                                l_id_link_array.extend;
                                l_flg_link_type_array.extend;
                            
                                l_id_order_set_array(l_index) := l_id_order_set;
                                l_flg_link_type_array(l_index) := l_flg_link_type_def;
                                l_id_link_array(l_index) := l_id_link_def;
                            
                                l_index := l_index + 1;
                            END IF;
                        
                        ELSIF l_flg_link_type_def = l_var_e
                        THEN
                            g_error := 'L_COUNT_SOFT';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            SELECT COUNT(osl.id_order_set)
                              INTO l_count_soft
                              FROM order_set_link osl
                             WHERE osl.id_order_set = l_id_order_set
                               AND osl.id_link IN (SELECT DISTINCT sd.id_dept
                                                     FROM software_dept sd, dept t
                                                    WHERE sd.id_software = l_id_link_def
                                                      AND sd.id_dept = t.id_dept
                                                      AND t.id_institution = i_id_institution
                                                      AND t.flg_available = g_yes)
                               AND osl.flg_link_type = l_flg_link_type_def;
                        
                            g_error := 'L_COUNT_DEPT';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            SELECT COUNT(DISTINCT sd.id_dept)
                              INTO l_count_dept
                              FROM software_dept sd, dept t
                             WHERE sd.id_software = l_id_link_def
                               AND sd.id_dept = t.id_dept
                               AND t.id_institution = i_id_institution;
                        
                            IF l_count_soft != l_count_dept
                            THEN
                            
                                g_error := 'c_software_dept';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                OPEN c_software_dept(l_id_link_def,
                                                     i_id_institution,
                                                     l_id_order_set,
                                                     l_flg_link_type_def);
                                LOOP
                                    g_error := 'FETCH C_SOFTWARE_DEPT';
                                    FETCH c_software_dept
                                        INTO l_id_dept;
                                    EXIT WHEN c_software_dept%NOTFOUND;
                                
                                    g_error := 'L_COUNT_DEP';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    OPEN c_orderset(c_id_order_set  => l_id_order_set,
                                                    c_id_link       => l_id_dept,
                                                    c_flg_link_type => l_flg_link_type_def);
                                    FETCH c_orderset
                                        INTO l_count_spec;
                                    CLOSE c_orderset;
                                
                                    SELECT COUNT(*)
                                      INTO l_count_array
                                      FROM TABLE(CAST(l_id_link_array AS table_number)) t
                                     WHERE t.column_value = l_id_dept;
                                
                                    IF (l_id_dept IS NOT NULL AND l_count_array = 0 AND l_count_spec = 0)
                                    THEN
                                    
                                        g_error := 'IF L_ID_DEPT IS NOT NULL';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        l_id_order_set_array.extend;
                                        l_flg_link_type_array.extend;
                                        l_id_link_array.extend;
                                    
                                        l_id_order_set_array(l_index) := l_id_order_set;
                                        l_flg_link_type_array(l_index) := l_flg_link_type_def;
                                        l_id_link_array(l_index) := l_id_dept;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END LOOP;
                                g_error := 'CLOSE C_SOFTWARE_DEPT CURSOR';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                CLOSE c_software_dept;
                            END IF;
                        END IF;
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_ORDER_SET_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_order_set_link;
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_ORDER_SET CURSOR';
        OPEN o_id_order_set FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_order_set_array AS table_number));
    
        g_error := 'CLOSE O_ID_LINK CURSOR';
        OPEN o_id_link FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_link_array AS table_number));
    
        g_error := 'CLOSE O_FLG_LINK_TYPE CURSOR';
        OPEN o_flg_link_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_link_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_order_set);
            pk_types.open_my_cursor(o_id_link);
            pk_types.open_my_cursor(o_flg_link_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_order_set_link;

    /********************************************************************************************
    * Set order set link for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_order_set_link      Cursor of Instituition order set link
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/26
    ********************************************************************************************/
    FUNCTION set_inst_order_set_link
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_order_set_link OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_order_set  pk_types.cursor_type;
        l_c_id_link       pk_types.cursor_type;
        l_c_flg_link_type pk_types.cursor_type;
    
        l_data_id_order_set  table_number;
        l_data_id_link       table_number;
        l_data_flg_link_type table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_ORDER_SET_LINK';
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT get_inst_order_set_link';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_order_set_link(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software(i),
                                           l_c_id_order_set,
                                           l_c_id_link,
                                           l_c_flg_link_type,
                                           o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_order_set_link := l_c_id_order_set';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                o_order_set_link := l_c_id_order_set;
                LOOP
                    FETCH l_c_id_order_set BULK COLLECT
                        INTO l_data_id_order_set LIMIT g_array_size;
                
                    FETCH l_c_id_link BULK COLLECT
                        INTO l_data_id_link LIMIT g_array_size;
                
                    FETCH l_c_flg_link_type BULK COLLECT
                        INTO l_data_flg_link_type LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_id_order_set.count
                    
                        INSERT INTO order_set_link
                            (id_order_set, id_link, flg_link_type)
                        VALUES
                            (l_data_id_order_set(j), l_data_id_link(j), l_data_flg_link_type(j));
                
                    EXIT WHEN l_c_id_order_set%NOTFOUND;
                
                END LOOP;
                g_error := 'CLOSE L_C_ID_ORDER_SET';
                CLOSE l_c_id_order_set;
                g_error := 'CLOSE L_C_ID_LINK';
                CLOSE l_c_id_link;
                g_error := 'CLOSE L_C_FLG_LINK_TYPE';
                CLOSE l_c_flg_link_type;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_order_set_link;

    /********************************************************************************************
    * Get order set task of markets, versions and sotwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_id_order_set_task     cursor 
    * @param o_id_order_set          cursor
    * @param o_id_task_type          cursor
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/27
    ********************************************************************************************/
    FUNCTION get_inst_order_set_task
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_id_software       IN software.id_software%TYPE,
        o_id_order_set_task OUT pk_types.cursor_type,
        o_id_order_set      OUT pk_types.cursor_type,
        o_id_task_type      OUT pk_types.cursor_type,
        o_task_def          OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_ost_def order_set_task.id_order_set_task%TYPE;
        l_id_os_def  order_set_task.id_order_set%TYPE;
        l_id_tt_def  order_set_task.id_task_type%TYPE;
        l_id_content order_set.id_content%TYPE;
    
        l_id_ost_array table_number := table_number();
        l_id_os_array  table_number := table_number();
        l_id_tt_array  table_number := table_number();
    
        l_task_def_array table_number := table_number();
    
        l_id_os        order_set_task.id_order_set%TYPE;
        l_next_os_task NUMBER;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_order_set_task
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT ost.id_order_set_task, ost.id_order_set, os.id_content, ost.id_task_type
              FROM alert_default.order_set os, alert_default.order_set_mrk_vrs osmv, alert_default.order_set_task ost
             WHERE osmv.id_market = c_market
               AND osmv.version = c_version
               AND ost.id_order_set = os.id_order_set;
        /*ALERT-199256 12/10/2011*/
    BEGIN
        g_func_name := 'GET_INST_ORDER_SET_TASK ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN c_order_set_task CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_order_set_task(i_version(i), i_market(j));
                LOOP
                
                    FETCH c_order_set_task
                        INTO l_id_ost_def, l_id_os_def, l_id_content, l_id_tt_def;
                    EXIT WHEN c_order_set_task%NOTFOUND;
                
                    IF l_id_content IS NOT NULL
                    THEN
                    
                        g_error := 'l_id_os';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT nvl((SELECT os.id_order_set
                                     FROM order_set os
                                    WHERE os.id_institution = i_id_institution
                                      AND os.id_content = l_id_content
                                      AND rownum = 1),
                                   0)
                          INTO l_id_os
                          FROM dual;
                    
                        IF l_id_os != 0
                        THEN
                        
                            g_error := 'l_count';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            SELECT COUNT(*)
                              INTO l_count
                              FROM order_set_task ost
                             WHERE ost.id_order_set = l_id_os
                               AND ost.id_task_type = l_id_tt_def;
                        
                            g_error := 'IF l_count = 0';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            IF l_count = 0
                            THEN
                                l_id_ost_array.extend;
                                l_id_os_array.extend;
                                l_id_tt_array.extend;
                                l_task_def_array.extend;
                            
                                g_error := 'l_next_os_task';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                SELECT seq_order_set_task.nextval
                                  INTO l_next_os_task
                                  FROM dual;
                            
                                l_id_ost_array(l_index) := l_next_os_task;
                                l_id_os_array(l_index) := l_id_os;
                                l_id_tt_array(l_index) := l_id_tt_def;
                                l_task_def_array(l_index) := l_id_ost_def;
                            
                                l_index := l_index + 1;
                            
                            END IF;
                        END IF;
                    END IF;
                
                END LOOP;
                g_error := 'CLOSE C_ORDER_SET_TASK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_order_set_task;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_ORDER_SET_TASK';
        OPEN o_id_order_set_task FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_ost_array AS table_number));
        g_error := 'OPEN O_ID_ORDER_SET';
        OPEN o_id_order_set FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_os_array AS table_number));
        g_error := 'OPEN O_ID_TASK_TYPE';
        OPEN o_id_task_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_tt_array AS table_number));
        g_error := 'OPEN O_TASK_DEF';
        OPEN o_task_def FOR
            SELECT column_value
              FROM TABLE(CAST(l_task_def_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_order_set_task);
            pk_types.open_my_cursor(o_id_order_set);
            pk_types.open_my_cursor(o_id_task_type);
            pk_types.open_my_cursor(o_task_def);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_order_set_task;

    /********************************************************************************************
    * Set order set task for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_order_set_task      Cursor of Instituition diet
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/27
    ********************************************************************************************/
    FUNCTION set_inst_order_set_task
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_order_set_task OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_order_set_task pk_types.cursor_type; -- cursor to read default information
        l_c_id_order_set      pk_types.cursor_type; -- cursor to read default information
        l_c_id_task_type      pk_types.cursor_type; -- cursor to read default information
        l_c_task_def          pk_types.cursor_type; -- cursor to read default information
    
        l_data_order_set_task table_number;
        l_data_id_order_set   table_number;
        l_data_id_task_type   table_number;
        l_data_task_def       table_number;
    
        l_c_id_order_set_task1 pk_types.cursor_type;
        l_c_id_task_link       pk_types.cursor_type;
        l_c_flg_task_link_type pk_types.cursor_type;
    
        l_data_id_order_set_task1 table_number;
        l_data_id_task_link       table_varchar;
        l_data_flg_task_link_type table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_ORDER_SET_TASK ';
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT get_inst_order_set_task';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_order_set_task(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software(i),
                                           l_c_id_order_set_task,
                                           l_c_id_order_set,
                                           l_c_id_task_type,
                                           l_c_task_def,
                                           l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'o_order_set_task := l_c_id_order_set_task';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_order_set_task := l_c_id_order_set_task;
            
                LOOP
                    FETCH l_c_id_order_set_task BULK COLLECT
                        INTO l_data_order_set_task LIMIT g_array_size;
                
                    FETCH l_c_id_order_set BULK COLLECT
                        INTO l_data_id_order_set LIMIT g_array_size;
                
                    FETCH l_c_id_task_type BULK COLLECT
                        INTO l_data_id_task_type LIMIT g_array_size;
                
                    FETCH l_c_task_def BULK COLLECT
                        INTO l_data_task_def LIMIT g_array_size;
                
                    g_error := 'FORALL j IN 1 .. l_data_order_set_task.COUNT';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    FOR j IN 1 .. l_data_order_set_task.count
                    LOOP
                        INSERT INTO order_set_task
                            (id_order_set_task, id_order_set, id_task_type)
                        VALUES
                            (l_data_order_set_task(j), l_data_id_order_set(j), l_data_id_task_type(j));
                    
                        --> Changed by Mess 18/06/2010    
                        IF NOT get_inst_order_set_task_link(i_lang,
                                                            i_id_institution,
                                                            i_software(i),
                                                            l_data_task_def(j), --id do def
                                                            l_data_order_set_task(j), --id da seq do alert
                                                            l_c_id_order_set_task1,
                                                            l_c_id_task_link,
                                                            l_c_flg_task_link_type,
                                                            l_error)
                        
                        THEN
                            RAISE l_exception;
                        ELSE
                            g_error := 'l_c_id_order_set_task1';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            LOOP
                            
                                FETCH l_c_id_order_set_task1 BULK COLLECT
                                    INTO l_data_id_order_set_task1 LIMIT g_array_size;
                            
                                FETCH l_c_id_task_link BULK COLLECT
                                    INTO l_data_id_task_link LIMIT g_array_size;
                            
                                FETCH l_c_flg_task_link_type BULK COLLECT
                                    INTO l_data_flg_task_link_type LIMIT g_array_size;
                            
                                g_error := 'FORALL j IN 1 .. l_data_order_set_task1.COUNT';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                FORALL k IN 1 .. l_data_id_order_set_task1.count
                                    INSERT INTO order_set_task_link
                                        (id_order_set_task, id_task_link, flg_task_link_type)
                                    VALUES
                                        (l_data_order_set_task(j),
                                         l_data_id_task_link(k),
                                         l_data_flg_task_link_type(k));
                                EXIT WHEN l_c_id_order_set_task1%NOTFOUND;
                            
                            END LOOP;
                            g_error := 'CLOSE l_c_id_order_set_task1 CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_id_order_set_task1;
                        
                            g_error := 'CLOSE l_c_id_task_link CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_id_task_link;
                        
                            g_error := 'CLOSE l_c_flg_task_link_type CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_flg_task_link_type;
                        
                        END IF;
                    END LOOP;
                    EXIT WHEN l_c_id_order_set_task%NOTFOUND;
                
                END LOOP;
                g_error := 'CLOSE L_C_ID_ORDER_SET_TASK';
                CLOSE l_c_id_order_set_task;
                g_error := 'CLOSE L_C_ID_ORDER_SET';
                CLOSE l_c_id_order_set;
                g_error := 'CLOSE L_C_ID_TASK_TYPE';
                CLOSE l_c_id_task_type;
                g_error := 'CLOSE L_C_TASK_DEF';
                CLOSE l_c_task_def;
            
            END IF;
        
        END LOOP;
    
        --Apagar as TASKS que foram inseridas mas no tm links por estes no estarem configurados como contedo
        --porque iro aparecer as tasks vazias e d erro a aplicao!
        g_error := 'DELETE ORDER_SET_TASK';
        DELETE FROM order_set_task t
         WHERE t.id_order_set_task NOT IN (SELECT id_order_set_task
                                             FROM order_set_task_link)
           AND t.id_order_set IN (SELECT DISTINCT t.id_order_set
                                    FROM order_set t
                                    JOIN alert_default.order_set tt
                                      ON tt.id_content = t.id_content
                                     AND t.author_desc = tt.author_desc
                                   WHERE t.id_professional IS NULL);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_order_set_task;

    /********************************************************************************************
    * Get order set task link of markets, versions and sotwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_id_order_set_task     cursor 
    * @param o_id_order_set          cursor
    * @param o_flg_task_link_type    cursor
    * @param o_error                 Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/27
    ********************************************************************************************/
    FUNCTION get_inst_order_set_task_link
    (
        i_lang                IN language.id_language%TYPE,
        i_id_institution      IN institution.id_institution%TYPE,
        i_id_software         IN software.id_software%TYPE,
        i_id_order_set_task   IN order_set_task.id_order_set_task%TYPE,
        i_id_order_set_task_n IN order_set_task.id_order_set_task%TYPE,
        o_id_order_set_task   OUT pk_types.cursor_type,
        o_task_link           OUT pk_types.cursor_type,
        o_flg_task_link_type  OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_order_set_task order_set_task.id_order_set_task%TYPE;
        l_id_tl_def         order_set_task_link.id_task_link%TYPE;
        l_ftl_def           order_set_task_link.flg_task_link_type%TYPE;
        l_tt_def            order_set_task.id_task_type%TYPE;
    
        l_id_ost_array table_number := table_number();
        l_id_tl_array  table_varchar := table_varchar();
        l_ftl_array    table_varchar := table_varchar();
    
        l_id_task_link    order_set_task_link.id_task_link%TYPE := 0;
        l_id_task_link_cs table_number;
    
        g_config_prescription_type  sys_config.id_sys_config%TYPE := 'PRESCRIPTION_TYPE';
        g_config_prescription_value sys_config.value%TYPE := NULL;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_order_set_task_link(c_id_ost order_set_task.id_order_set_task%TYPE) IS
            SELECT DISTINCT ostl.id_order_set_task, ostl.id_task_link, ostl.flg_task_link_type, ost.id_task_type
              FROM alert_default.order_set_task_link ostl, alert_default.order_set_task ost
             WHERE ostl.id_order_set_task = ost.id_order_set_task
               AND ostl.id_order_set_task = c_id_ost
             ORDER BY ost.id_task_type DESC;
    
        l_number_2  NUMBER := 2;
        l_number_5  NUMBER := 5;
        l_number_3  NUMBER := 3;
        l_number_4  NUMBER := 4;
        l_number_9  NUMBER := 9;
        l_number_13 NUMBER := 13;
        l_number_15 NUMBER := 15;
        l_number_7  NUMBER := 7;
        l_number_8  NUMBER := 8;
        l_number_10 NUMBER := 43; /* ALERT-218903 replaced 10 by 43*/
        l_number_11 NUMBER := 11;
        l_number_12 NUMBER := 42; /*http://alertjira/browse/ALERT-195613*/
    
        l_var_n VARCHAR2(1) := 'N';
        l_var_e VARCHAR2(1) := 'E';
        l_var_g VARCHAR2(1) := 'G';
        l_var_c VARCHAR2(1) := 'C';
        l_var_a VARCHAR2(1) := 'A';
    BEGIN
        g_func_name := 'GET_INST_ORDER_SET_TASK_LINK';
        g_error     := 'OPEN c_order_set_task_link CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
    
        g_config_prescription_value := pk_sysconfig.get_config(g_config_prescription_type,
                                                               i_id_institution,
                                                               i_id_software);
    
        OPEN c_order_set_task_link(i_id_order_set_task);
        LOOP
            l_id_task_link_cs := table_number();
            l_id_task_link    := 0;
        
            FETCH c_order_set_task_link
                INTO l_id_order_set_task, l_id_tl_def, l_ftl_def, l_tt_def;
            EXIT WHEN c_order_set_task_link%NOTFOUND;
        
            IF l_tt_def NOT IN (l_number_2, l_number_5)
            THEN
            
                /* consulta de especialidade
                Para ORDER_SET_TASK.ID_TASK_TYPE = 3 >> ORDER_SET_TASK_LINK.ID_TASK_LINK = DEP_CLIN_SERV.ID_DEP_CLIN_SERV
                (no caso de ALERT DEFAULT este campo teria o ID_CLINICAL_SERVICE)*/
                IF l_tt_def = l_number_3
                THEN
                
                    g_error := 'l_id_task_link -- IF l_tt_def = 3';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                
                    SELECT cs.id_clinical_service
                      BULK COLLECT
                      INTO l_id_task_link_cs
                      FROM clinical_service cs
                     WHERE cs.flg_available = g_flg_available
                       AND cs.id_content IN (SELECT cs1.id_content
                                               FROM alert_default.clinical_service cs1
                                              WHERE cs1.id_clinical_service IN
                                                    (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                      column_value
                                                       FROM TABLE(CAST(pk_backoffice_default.check_clinical_service_parent(i_lang,
                                                                                                                           l_id_tl_def) AS
                                                                       table_number)) p)
                                                AND cs1.flg_available = g_flg_available);
                
                END IF;
            
                -- medicao local                
                IF l_tt_def = l_number_13
                   AND l_ftl_def = 'N'
                --> Added by MESS 02-06-2010  
                THEN
                    IF g_config_prescription_value IS NOT NULL
                    THEN
                        SELECT nvl((SELECT DISTINCT t.id_drug
                                     FROM mi_med t
                                    WHERE t.flg_available = g_yes
                                      AND t.flg_type = 'M'
                                      AND t.vers = g_config_prescription_value
                                      AND t.id_drug = l_id_tl_def
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    END IF;
                END IF;
            
                -- medicao para o exterior
            
                IF l_tt_def = l_number_15
                   AND l_ftl_def = 'N'
                --> Added by MESS 19-07-2010  
                THEN
                    IF g_config_prescription_value IS NOT NULL
                    THEN
                        SELECT nvl((SELECT DISTINCT t.med_id
                                     FROM me_med t
                                    WHERE t.flg_available = g_yes
                                      AND t.flg_comerc = g_yes
                                      AND t.vers = g_config_prescription_value
                                      AND t.med_id = l_id_tl_def
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    END IF;
                END IF;
            
                IF l_tt_def = l_number_4
                   OR (l_tt_def = l_number_9 AND l_ftl_def = l_var_n)
                THEN
                
                    g_error := 'l_id_task_link -- IF l_tt_def = 4
                           OR (l_tt_def = 9 AND l_ftl_def = ''N'')
                           OR (l_tt_def = 13 AND l_ftl_def = ''N'')
                           OR (l_tt_def = 15 AND l_ftl_def = ''N'')';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                
                    l_id_task_link := l_id_tl_def;
                END IF;
            
                IF l_tt_def IN (l_number_7, l_number_8)
                THEN
                
                    -- outros exames
                
                    IF l_ftl_def IN (l_var_n, l_var_e)
                    THEN
                    
                        g_error := 'l_id_task_link -- IF l_ftl_def IN (''N'', ''E'')';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT nvl((SELECT e.id_exam
                                     FROM exam e
                                    WHERE e.flg_available = g_flg_available
                                      AND e.id_content IN (SELECT e1.id_content
                                                             FROM alert_default.exam e1
                                                            WHERE e1.id_exam = l_id_tl_def
                                                              AND e1.flg_available = g_flg_available)
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    
                    ELSIF l_ftl_def = l_var_g
                    THEN
                    
                        g_error := 'l_id_task_link -- ELSIF l_ftl_def = ''G''';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT nvl((SELECT eg.id_exam_group
                                     FROM exam_group eg
                                    WHERE eg.id_exam_group = l_id_tl_def
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    
                    ELSIF l_ftl_def = l_var_c
                    THEN
                        --> Changed by MESS 23-04-2010
                        g_error := 'l_id_task_link -- EXAMS -- ELSIF l_ftl_def = ''C''';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        SELECT nvl((SELECT ec1.id_exam_codification
                                     FROM alert_default.exam_codification ec,
                                          alert_default.exam              e,
                                          alert_default.codification      c,
                                          exam                            e1,
                                          codification                    c1,
                                          exam_codification               ec1
                                    WHERE ec.id_exam_codification = l_id_tl_def
                                      AND ec.id_codification = c.id_codification
                                      AND ec.id_exam = e.id_exam
                                      AND ec.flg_available = g_flg_available
                                      AND e.flg_available = g_flg_available
                                      AND c.flg_available = g_flg_available
                                      AND e1.id_content = e.id_content
                                      AND c1.id_content = c.id_content
                                      AND e1.flg_available = g_flg_available
                                      AND c1.flg_available = g_flg_available
                                      AND ec1.id_codification = c1.id_codification
                                      AND ec1.id_exam = e1.id_exam
                                      AND ec1.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    
                    END IF;
                END IF;
                -- PATIENT EDUCATION
                IF l_tt_def = l_number_12
                   AND l_ftl_def = l_var_n
                
                --> Added by JM 10-04-2013  
                
                THEN
                    SELECT nvl((SELECT DISTINCT ntt.id_nurse_tea_topic
                                 FROM nurse_tea_topic ntt
                                WHERE ntt.flg_available = g_flg_available
                                  AND ntt.id_nurse_tea_topic = l_id_tl_def
                                  AND rownum = 1),
                               0)
                      INTO l_id_task_link
                      FROM dual;
                END IF;
            
                -- procedimentos
                IF l_tt_def = l_number_10
                THEN
                    IF l_ftl_def = l_var_n
                    THEN
                    
                        g_error := 'l_id_task_link -- IF l_ftl_def = ''N''';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT nvl((SELECT i.id_intervention
                                     FROM intervention i
                                    WHERE i.flg_status = pk_alert_constant.g_active
                                      AND i.id_content IN
                                          (SELECT i1.id_content
                                             FROM alert_default.intervention i1
                                            WHERE i1.id_intervention = l_id_tl_def
                                              AND i1.flg_status = pk_alert_constant.g_active)
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    
                    ELSIF l_ftl_def = l_var_c
                    THEN
                    
                        --> Changed by MESS 23-04-2010
                        g_error := 'l_id_task_link -- INTERVS -- ELSIF l_ftl_def = ''C''';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        SELECT nvl((SELECT ic1.id_interv_codification
                                     FROM alert_default.interv_codification ic,
                                          alert_default.intervention        i,
                                          alert_default.codification        c,
                                          intervention                      i1,
                                          codification                      c1,
                                          interv_codification               ic1
                                    WHERE ic.id_interv_codification = l_id_tl_def
                                      AND ic.id_codification = c.id_codification
                                      AND ic.id_intervention = i.id_intervention
                                      AND ic.flg_available = g_flg_available
                                      AND i.flg_status = pk_alert_constant.g_active
                                      AND c.flg_available = g_flg_available
                                      AND i1.id_content = i.id_content
                                      AND c1.id_content = c.id_content
                                      AND i1.flg_status = pk_alert_constant.g_active
                                      AND c1.flg_available = g_flg_available
                                      AND ic1.id_codification = c1.id_codification
                                      AND ic1.id_intervention = i1.id_intervention
                                      AND ic1.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    
                    END IF;
                END IF;
            
                -- id da anlise
                IF l_tt_def = l_number_11
                THEN
                
                    IF l_ftl_def IN (l_var_n, l_var_a)
                    THEN
                    
                        g_error := 'l_id_task_link -- IF l_ftl_def IN (''N'', ''A'')';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT nvl((SELECT a.id_analysis
                                     FROM analysis a
                                    WHERE a.flg_available = g_flg_available
                                      AND a.id_content IN (SELECT a1.id_content
                                                             FROM alert_default.analysis a1
                                                            WHERE a1.id_analysis = l_id_tl_def
                                                              AND a1.flg_available = g_flg_available)
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    
                    ELSIF l_ftl_def = l_var_g
                    THEN
                    
                        g_error := 'l_id_task_link -- ELSIF l_ftl_def = ''G''';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT nvl((SELECT ag.id_analysis_group
                                     FROM analysis_group ag
                                    WHERE ag.id_analysis_group = l_id_tl_def
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    
                    ELSIF l_ftl_def = l_var_c
                    THEN
                        --> Changed by MESS 23-04-2010
                        g_error := 'l_id_task_link -- INTERVS -- ELSIF l_ftl_def = ''C''';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        SELECT nvl((SELECT ac1.id_analysis_codification
                                     FROM alert_default.analysis_codification ac,
                                          alert_default.analysis              a,
                                          alert_default.codification          c,
                                          analysis                            a1,
                                          codification                        c1,
                                          analysis_codification               ac1
                                    WHERE ac.id_analysis_codification = l_id_tl_def
                                      AND ac.id_codification = c.id_codification
                                      AND ac.id_analysis = a.id_analysis
                                      AND ac.flg_available = g_flg_available
                                      AND a.flg_available = g_flg_available
                                      AND c.flg_available = g_flg_available
                                      AND a1.id_content = a.id_content
                                      AND c1.id_content = c.id_content
                                      AND a1.flg_available = g_flg_available
                                      AND c1.flg_available = g_flg_available
                                      AND ac1.id_codification = c1.id_codification
                                      AND ac1.id_analysis = a1.id_analysis
                                      AND ac1.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_task_link
                          FROM dual;
                    
                    END IF;
                
                END IF;
                IF l_id_task_link != 0
                THEN
                
                    g_error := 'l_count';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                
                    SELECT COUNT(*)
                      INTO l_count
                      FROM order_set_task_link ostl
                     WHERE ostl.flg_task_link_type = l_ftl_def
                       AND ostl.id_task_link = l_id_task_link
                       AND ostl.id_order_set_task = i_id_order_set_task_n;
                
                    IF l_count = 0
                    THEN
                        g_error := ' IF l_count = 0';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        l_id_ost_array.extend;
                        l_id_tl_array.extend;
                        l_ftl_array.extend;
                    
                        l_id_ost_array(l_index) := i_id_order_set_task_n;
                        l_id_tl_array(l_index) := l_id_task_link;
                        l_ftl_array(l_index) := l_ftl_def;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                ELSIF l_id_task_link_cs.count > 0
                THEN
                    FOR tl IN 1 .. l_id_task_link_cs.count
                    LOOP
                        g_error := 'l_count';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT COUNT(*)
                          INTO l_count
                          FROM order_set_task_link ostl
                         WHERE ostl.flg_task_link_type = l_ftl_def
                           AND ostl.id_task_link = l_id_task_link_cs(tl)
                           AND ostl.id_order_set_task = i_id_order_set_task_n;
                    
                        IF l_count = 0
                        THEN
                            g_error := ' IF l_count = 0';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            l_id_ost_array.extend;
                            l_id_tl_array.extend;
                            l_ftl_array.extend;
                        
                            l_id_ost_array(l_index) := i_id_order_set_task_n;
                            l_id_tl_array(l_index) := l_id_task_link_cs(tl);
                            l_ftl_array(l_index) := l_ftl_def;
                        
                            l_index := l_index + 1;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        END LOOP;
        g_error := 'CLOSE C_ORDER_SET_TASK_LINK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        CLOSE c_order_set_task_link;
        g_error := 'OPEN O_ID_ORDER_SET_TASK';
        OPEN o_id_order_set_task FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_ost_array AS table_number));
    
        g_error := 'OPEN O_TASK_LINK';
        OPEN o_task_link FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_tl_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_TASK_LINK_TYPE';
        OPEN o_flg_task_link_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_ftl_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_order_set_task);
            pk_types.open_my_cursor(o_task_link);
            pk_types.open_my_cursor(o_flg_task_link_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_order_set_task_link;

    /********************************************************************************************
    * Get institution order set task detail of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_order_set_task_detail     cursor 
    * @param o_id_order_set_task            cursor
    * @param o_flg_value_type               cursor
    * @param o_nvalue                       cursor
    * @param o_dvalue                       cursor
    * @param o_vvalue                       cursor
    * @param o_flg_detail_type              cursor
    * @param o_id_adv_input                 cursor
    * @param o_id_adv_input_field_det       cursor
    * @param o_id_unit_measure              cursor                                                                                    
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               SMSS
    * @version                              2.6
    * @since                                2010/01/28
    ********************************************************************************************/
    FUNCTION get_inst_order_set_task_detail
    (
        i_lang                     IN language.id_language%TYPE,
        i_market                   IN table_number,
        i_version                  IN table_varchar,
        i_id_institution           IN institution.id_institution%TYPE,
        i_id_software              IN software.id_software%TYPE,
        o_id_order_set_task_detail OUT pk_types.cursor_type,
        o_id_order_set_task        OUT pk_types.cursor_type,
        o_flg_value_type           OUT pk_types.cursor_type,
        o_nvalue                   OUT pk_types.cursor_type,
        o_dvalue                   OUT pk_types.cursor_type,
        o_vvalue                   OUT pk_types.cursor_type,
        o_flg_detail_type          OUT pk_types.cursor_type,
        o_id_adv_input             OUT pk_types.cursor_type,
        o_id_adv_input_field       OUT pk_types.cursor_type,
        o_id_adv_input_field_det   OUT pk_types.cursor_type,
        o_id_unit_measure          OUT pk_types.cursor_type,
        o_error                    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_order_set_task_detail_def order_set_task_detail.id_order_set_task_detail%TYPE;
        l_id_order_set_task_def        order_set_task_detail.id_order_set_task%TYPE;
        l_flg_value_type_def           order_set_task_detail.flg_value_type%TYPE;
        l_nvalue_def                   order_set_task_detail.nvalue%TYPE;
        l_dvalue_def                   order_set_task_detail.dvalue%TYPE;
        l_vvalue_def                   order_set_task_detail.vvalue%TYPE;
        l_flg_detail_type_def          order_set_task_detail.flg_detail_type%TYPE;
        l_id_adv_input_def             order_set_task_detail.id_advanced_input%TYPE;
        l_id_adv_input_field_def       order_set_task_detail.id_advanced_input_field%TYPE;
        l_id_adv_input_field_det_def   order_set_task_detail.id_advanced_input_field_det%TYPE;
        l_id_unit_measure_def          unit_measure.id_unit_measure%TYPE;
    
        l_id_ost_detail_array          table_number := table_number();
        l_id_order_set_task_array      table_number := table_number();
        l_flg_value_type_array         table_varchar := table_varchar();
        l_nvalue_array                 table_varchar := table_varchar();
        l_dvalue_array                 table_varchar := table_varchar();
        l_vvalue_array                 table_varchar := table_varchar();
        l_flg_detail_type_array        table_varchar := table_varchar();
        l_id_adv_input_array           table_number := table_number();
        l_id_adv_input_field_array     table_number := table_number();
        l_id_adv_input_field_det_array table_number := table_number();
        l_id_unit_measure_array        table_number := table_number();
    
        l_id_order_set_def  order_set_task.id_order_set%TYPE;
        l_id_task_type_def  order_set_task.id_task_type%TYPE;
        l_id_content        order_set.id_content%TYPE;
        l_id_order_set      order_set_task.id_order_set%TYPE;
        l_id_order_set_task order_set_task.id_order_set_task%TYPE;
        l_next_ostd_task    NUMBER;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_order_set_task_detail
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT ostd.id_order_set_task_detail,
                            ostd.id_order_set_task,
                            ostd.flg_value_type,
                            ostd.nvalue,
                            ostd.dvalue,
                            ostd.vvalue,
                            ostd.flg_detail_type,
                            ostd.id_advanced_input,
                            ostd.id_advanced_input_field,
                            ostd.id_advanced_input_field_det,
                            ostd.id_unit_measure,
                            ost.id_order_set,
                            ost.id_task_type,
                            os.id_content
              FROM alert_default.order_set os
             INNER JOIN alert_default.order_set_mrk_vrs osmv
                ON (osmv.id_order_set = os.id_order_set AND osmv.id_market = c_market AND osmv.version = c_version)
             INNER JOIN alert_default.order_set_task ost
                ON (ost.id_order_set = os.id_order_set)
             INNER JOIN alert_default.order_set_task_detail ostd
                ON (ostd.id_order_set_task = ost.id_order_set_task);
    
        CURSOR c_order_set_task
        (
            c_id_order_set IN order_set_task.id_order_set%TYPE,
            c_id_task_type IN order_set_task.id_task_type%TYPE
        ) IS
            SELECT DISTINCT ost.id_order_set_task
              FROM order_set_task ost
             WHERE ost.id_order_set = c_id_order_set
               AND ost.id_task_type = c_id_task_type;
    
    BEGIN
        g_func_name := 'GET_INST_ORDER_SET_TASK_DETAIL ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'c_order_set_task_detail';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                OPEN c_order_set_task_detail(i_version(i), i_market(j));
                LOOP
                    FETCH c_order_set_task_detail
                        INTO l_id_order_set_task_detail_def,
                             l_id_order_set_task_def,
                             l_flg_value_type_def,
                             l_nvalue_def,
                             l_dvalue_def,
                             l_vvalue_def,
                             l_flg_detail_type_def,
                             l_id_adv_input_def,
                             l_id_adv_input_field_def,
                             l_id_adv_input_field_det_def,
                             l_id_unit_measure_def,
                             l_id_order_set_def,
                             l_id_task_type_def,
                             l_id_content;
                    EXIT WHEN c_order_set_task_detail%NOTFOUND;
                
                    IF l_id_content IS NOT NULL
                    THEN
                    
                        g_error := 'l_id_order_set';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT nvl((SELECT os.id_order_set
                                     FROM order_set os
                                    WHERE os.id_institution = i_id_institution
                                      AND os.id_content = l_id_content
                                      AND rownum = 1),
                                   0)
                          INTO l_id_order_set
                          FROM dual;
                    
                        IF l_id_order_set != 0
                        THEN
                        
                            g_error := 'OPEN C_ORDER_SET_TASK CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            OPEN c_order_set_task(l_id_order_set, l_id_task_type_def);
                            LOOP
                                FETCH c_order_set_task
                                    INTO l_id_order_set_task;
                                EXIT WHEN c_order_set_task%NOTFOUND;
                            
                                SELECT COUNT(*)
                                  INTO l_count
                                  FROM order_set_task_detail ostd
                                 WHERE ostd.id_order_set_task = l_id_order_set_task
                                   AND ostd.flg_value_type = l_flg_value_type_def
                                   AND nvl(ostd.nvalue, 0) = nvl(l_nvalue_def, 0)
                                   AND nvl(ostd.dvalue, to_date('00:00:00', 'hh24:mi:ss')) =
                                       nvl(l_dvalue_def, to_date('00:00:00', 'hh24:mi:ss'))
                                   AND nvl(ostd.vvalue, '0') = nvl(l_vvalue_def, '0')
                                   AND ostd.flg_detail_type = l_flg_detail_type_def
                                   AND nvl(ostd.id_advanced_input, 0) = nvl(l_id_adv_input_def, 0)
                                   AND nvl(ostd.id_advanced_input_field, 0) = nvl(l_id_adv_input_field_def, 0)
                                   AND nvl(ostd.id_advanced_input_field_det, 0) = nvl(l_id_adv_input_field_det_def, 0)
                                   AND nvl(ostd.id_unit_measure, 0) = nvl(l_id_unit_measure_def, 0);
                            
                                IF l_count = 0
                                THEN
                                    g_error := 'IF l_count = 0';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    l_id_ost_detail_array.extend;
                                    l_id_order_set_task_array.extend;
                                    l_flg_value_type_array.extend;
                                    l_nvalue_array.extend;
                                    l_dvalue_array.extend;
                                    l_vvalue_array.extend;
                                    l_flg_detail_type_array.extend;
                                    l_id_adv_input_array.extend;
                                    l_id_adv_input_field_array.extend;
                                    l_id_adv_input_field_det_array.extend;
                                    l_id_unit_measure_array.extend;
                                
                                    SELECT seq_order_set_task_detail.nextval
                                      INTO l_next_ostd_task
                                      FROM dual;
                                
                                    l_id_ost_detail_array(l_index) := l_next_ostd_task;
                                    l_id_order_set_task_array(l_index) := l_id_order_set_task;
                                    l_flg_value_type_array(l_index) := l_flg_value_type_def;
                                    l_nvalue_array(l_index) := l_nvalue_def;
                                    l_dvalue_array(l_index) := l_dvalue_def;
                                    l_vvalue_array(l_index) := l_vvalue_def;
                                    l_flg_detail_type_array(l_index) := l_flg_detail_type_def;
                                    l_id_adv_input_array(l_index) := l_id_adv_input_def;
                                    l_id_adv_input_field_array(l_index) := l_id_adv_input_field_def;
                                    l_id_adv_input_field_det_array(l_index) := l_id_adv_input_field_det_def;
                                    l_id_unit_measure_array(l_index) := l_id_unit_measure_def;
                                
                                    l_index := l_index + 1;
                                
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_ORDER_SET_TASK CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_order_set_task;
                        END IF;
                    
                    END IF;
                
                END LOOP;
                g_error := 'CLOSE C_ORDER_SET_TASK_DETAIL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_order_set_task_detail;
            
            END LOOP;
        
        END LOOP;
        g_error := 'OPEN O_ID_ORDER_SET_TASK_DETAIL';
        OPEN o_id_order_set_task_detail FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_ost_detail_array AS table_number));
        g_error := 'OPEN O_ID_ORDER_SET_TASK';
        OPEN o_id_order_set_task FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_order_set_task_array AS table_number));
        g_error := 'OPEN O_FLG_VALUE_TYPE';
        OPEN o_flg_value_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_value_type_array AS table_varchar));
        g_error := 'OPEN O_NVALUE';
        OPEN o_nvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_nvalue_array AS table_varchar));
        g_error := 'OPEN O_DVALUE';
        OPEN o_dvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_dvalue_array AS table_varchar));
        g_error := 'OPEN O_VVALUE';
        OPEN o_vvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_vvalue_array AS table_varchar));
        g_error := 'OPEN O_FLG_DETAIL_TYPE';
        OPEN o_flg_detail_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_detail_type_array AS table_varchar));
        g_error := 'OPEN O_ID_ADV_INPUT';
        OPEN o_id_adv_input FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_array AS table_number));
        g_error := 'OPEN O_ID_ADV_INPUT_FIELD';
        OPEN o_id_adv_input_field FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_field_array AS table_number));
        g_error := 'OPEN O_ID_ADV_INPUT_FIELD_DET';
        OPEN o_id_adv_input_field_det FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_field_det_array AS table_number));
        g_error := 'OPEN O_ID_UNIT_MEASURE';
        OPEN o_id_unit_measure FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_unit_measure_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_order_set_task_detail);
            pk_types.open_my_cursor(o_id_order_set_task);
            pk_types.open_my_cursor(o_flg_value_type);
            pk_types.open_my_cursor(o_nvalue);
            pk_types.open_my_cursor(o_dvalue);
            pk_types.open_my_cursor(o_vvalue);
            pk_types.open_my_cursor(o_flg_detail_type);
            pk_types.open_my_cursor(o_id_adv_input);
            pk_types.open_my_cursor(o_id_adv_input_field);
            pk_types.open_my_cursor(o_id_adv_input_field_det);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_order_set_task_detail;

    /********************************************************************************************
    * Set order set task detail for a specific institution
    *
    * @param i_lang                            Prefered language ID
    * @param i_market                          Market ID's
    * @param i_version                         ALERT version's
    * @param i_id_institution                  Institution ID
    * @param i_software                        Software ID
    * @param o_inst_order_set_task_detail      Cursor of Instituition Transports
    * @param o_error                           Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/28
    ********************************************************************************************/
    FUNCTION set_inst_order_set_task_detail
    (
        i_lang                       IN language.id_language%TYPE,
        i_market                     IN table_number,
        i_version                    IN table_varchar,
        i_id_institution             IN institution.id_institution%TYPE,
        i_software                   IN table_number,
        o_inst_order_set_task_detail OUT pk_types.cursor_type,
        o_error                      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_order_set_task_detail pk_types.cursor_type;
        l_c_id_order_set_task        pk_types.cursor_type;
        l_c_flg_value_type           pk_types.cursor_type;
        l_c_nvalue                   pk_types.cursor_type;
        l_c_dvalue                   pk_types.cursor_type;
        l_c_vvalue                   pk_types.cursor_type;
        l_c_flg_detail_type          pk_types.cursor_type;
        l_c_id_adv_input             pk_types.cursor_type;
        l_c_id_adv_input_field       pk_types.cursor_type;
        l_c_id_adv_input_field_det   pk_types.cursor_type;
        l_c_id_unit_measure          pk_types.cursor_type;
    
        l_data_id_ost_detail          table_number;
        l_data_id_order_set_task      table_number;
        l_data_flg_value_type         table_varchar;
        l_data_nvalue                 table_varchar;
        l_data_dvalue                 table_varchar;
        l_data_vvalue                 table_varchar;
        l_data_flg_detail_type        table_varchar;
        l_data_id_adv_input           table_number;
        l_data_id_adv_input_field     table_number;
        l_data_id_adv_input_field_det table_number;
        l_data_id_unit_measure        table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
        --> Apagar os repetidos
        CURSOR c_tasks
        (
            c_id_software software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT MIN(id_order_set_task_detail) minimo,
                   COUNT(*),
                   id_order_set_task,
                   flg_value_type,
                   nvalue,
                   dvalue,
                   vvalue,
                   flg_detail_type,
                   id_advanced_input,
                   id_advanced_input_field,
                   id_advanced_input_field_det,
                   id_unit_measure
              FROM order_set_task_detail
             WHERE id_order_set_task IN
                   (SELECT t.id_order_set_task
                      FROM order_set_task t
                     WHERE t.id_order_set IN (SELECT t.id_order_set
                                                FROM order_set t
                                                JOIN alert_default.order_set os1
                                                  ON (os1.id_content = t.id_content)
                                                JOIN alert_default.order_set_mrk_vrs osmv
                                                  ON (osmv.id_order_set = os1.id_order_set AND osmv.id_market = c_market AND
                                                     osmv.version = c_version)))
             GROUP BY id_order_set_task,
                      flg_value_type,
                      nvalue,
                      dvalue,
                      vvalue,
                      flg_detail_type,
                      id_advanced_input,
                      id_advanced_input_field,
                      id_advanced_input_field_det,
                      id_unit_measure
            HAVING COUNT(*) > 1;
    
    BEGIN
        g_func_name := 'SET_INST_ORDER_SET_TASK_DETAIL ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT get_inst_order_set_task_detail';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_order_set_task_detail(i_lang,
                                                  i_market,
                                                  i_version,
                                                  i_id_institution,
                                                  i_software(i),
                                                  l_c_id_order_set_task_detail,
                                                  l_c_id_order_set_task,
                                                  l_c_flg_value_type,
                                                  l_c_nvalue,
                                                  l_c_dvalue,
                                                  l_c_vvalue,
                                                  l_c_flg_detail_type,
                                                  l_c_id_adv_input,
                                                  l_c_id_adv_input_field,
                                                  l_c_id_adv_input_field_det,
                                                  l_c_id_unit_measure,
                                                  l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'o_inst_order_set_task_detail := l_c_id_order_set_task_detail';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_inst_order_set_task_detail := l_c_id_order_set_task_detail;
                LOOP
                    FETCH l_c_id_order_set_task_detail BULK COLLECT
                        INTO l_data_id_ost_detail LIMIT g_array_size;
                
                    FETCH l_c_id_order_set_task BULK COLLECT
                        INTO l_data_id_order_set_task LIMIT g_array_size;
                
                    FETCH l_c_flg_value_type BULK COLLECT
                        INTO l_data_flg_value_type LIMIT g_array_size;
                
                    FETCH l_c_nvalue BULK COLLECT
                        INTO l_data_nvalue LIMIT g_array_size;
                
                    FETCH l_c_dvalue BULK COLLECT
                        INTO l_data_dvalue LIMIT g_array_size;
                
                    FETCH l_c_vvalue BULK COLLECT
                        INTO l_data_vvalue LIMIT g_array_size;
                
                    FETCH l_c_flg_detail_type BULK COLLECT
                        INTO l_data_flg_detail_type LIMIT g_array_size;
                
                    FETCH l_c_id_adv_input BULK COLLECT
                        INTO l_data_id_adv_input LIMIT g_array_size;
                
                    FETCH l_c_id_adv_input_field BULK COLLECT
                        INTO l_data_id_adv_input_field LIMIT g_array_size;
                
                    FETCH l_c_id_adv_input_field_det BULK COLLECT
                        INTO l_data_id_adv_input_field_det LIMIT g_array_size;
                
                    FETCH l_c_id_unit_measure BULK COLLECT
                        INTO l_data_id_unit_measure LIMIT g_array_size;
                
                    g_error := 'o_inst_order_set_task_detail := l_c_id_order_set_task_detail';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                
                    FORALL j IN 1 .. l_data_id_order_set_task.count
                    
                        INSERT INTO order_set_task_detail
                            (id_order_set_task_detail,
                             id_order_set_task,
                             flg_value_type,
                             nvalue,
                             dvalue,
                             vvalue,
                             flg_detail_type,
                             id_advanced_input,
                             id_advanced_input_field,
                             id_advanced_input_field_det,
                             id_unit_measure)
                        VALUES
                            (l_data_id_ost_detail(j),
                             l_data_id_order_set_task(j),
                             l_data_flg_value_type(j),
                             l_data_nvalue(j),
                             l_data_dvalue(j),
                             l_data_vvalue(j),
                             l_data_flg_detail_type(j),
                             l_data_id_adv_input(j),
                             l_data_id_adv_input_field(j),
                             l_data_id_adv_input_field_det(j),
                             l_data_id_unit_measure(j));
                
                    EXIT WHEN l_c_id_order_set_task_detail%NOTFOUND;
                
                END LOOP;
                g_error := 'CLOSE L_C_ID_ORDER_SET_TASK_DETAIL';
                CLOSE l_c_id_order_set_task_detail;
                g_error := 'CLOSE L_C_ID_ORDER_SET_TASK';
                CLOSE l_c_id_order_set_task;
                g_error := 'CLOSE L_C_FLG_VALUE_TYPE';
                CLOSE l_c_flg_value_type;
                g_error := 'CLOSE L_C_NVALUE';
                CLOSE l_c_nvalue;
                g_error := 'CLOSE L_C_DVALUE';
                CLOSE l_c_dvalue;
                g_error := 'CLOSE L_C_VVALUE';
                CLOSE l_c_vvalue;
                g_error := 'CLOSE L_C_FLG_DETAIL_TYPE';
                CLOSE l_c_flg_detail_type;
                g_error := 'CLOSE L_C_ID_ADV_INPUT';
                CLOSE l_c_id_adv_input;
                g_error := 'CLOSE L_C_ID_ADV_INPUT_FIELD';
                CLOSE l_c_id_adv_input_field;
                g_error := 'CLOSE L_C_ID_ADV_INPUT_FIELD_DET';
                CLOSE l_c_id_adv_input_field_det;
                g_error := 'CLOSE L_C_ID_UNIT_MEASURE';
                CLOSE l_c_id_unit_measure;
            END IF;
        
            FOR h IN 1 .. i_version.count
            LOOP
                FOR m IN 1 .. i_market.count
                LOOP
                    BEGIN
                        FOR k IN c_tasks(i_software(i), i_version(h), i_market(m))
                        LOOP
                            DELETE FROM order_set_task_detail ost
                             WHERE ost.id_order_set_task = k.id_order_set_task
                               AND ost.id_order_set_task_detail != k.minimo;
                        END LOOP;
                    END;
                END LOOP;
            END LOOP;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_order_set_task_detail;
    /********************************************************************************************
    * Get institution order set frequent of markets, versions and sotwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_id_order_set          cursor 
    * @param o_rank                  cursor                                                                                    
    * @param o_error                 Error
    *
    * @return                        true or false on success or error
    *
    * @author                        SMSS
    * @version                       2.6
    * @since                         2010/01/28
    ********************************************************************************************/
    FUNCTION get_inst_order_set_frequent
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_order_set   OUT pk_types.cursor_type,
        o_rank           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_order_set_def order_set_task_detail.id_order_set_task_detail%TYPE;
        l_rank_def         order_set_task_detail.id_order_set_task%TYPE;
    
        l_id_order_set_array table_number := table_number();
        l_rank_array         table_number := table_number();
    
        l_id_content   order_set.id_content%TYPE;
        l_id_order_set order_set_task.id_order_set%TYPE;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_order_set_frequent
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT osf.id_order_set, osf.rank, os.id_content
              FROM alert_default.order_set          os,
                   alert_default.order_set_mrk_vrs  osmv,
                   alert_default.order_set_frequent osf
             WHERE osmv.id_market = c_market
               AND osmv.version = c_version
               AND osmv.id_order_set = os.id_order_set
               AND osf.id_software = c_id_software
               AND osf.id_order_set = os.id_order_set;
        /*ALERT-199256 12/10/2011*/
    BEGIN
        g_func_name := 'GET_INST_ORDER_SET_FREQUENT ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'c_order_set_frequent';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                OPEN c_order_set_frequent(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_order_set_frequent
                        INTO l_id_order_set_def, l_rank_def, l_id_content;
                    EXIT WHEN c_order_set_frequent%NOTFOUND;
                
                    IF l_id_content IS NOT NULL
                    THEN
                    
                        g_error := 'l_id_order_set';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT nvl((SELECT os.id_order_set
                                     FROM order_set os
                                    WHERE os.id_institution = i_id_institution
                                      AND os.id_content = l_id_content
                                      AND rownum = 1),
                                   0)
                          INTO l_id_order_set
                          FROM dual;
                    
                        IF l_id_order_set != 0
                        THEN
                        
                            g_error := 'l_count';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            SELECT COUNT(*)
                              INTO l_count
                              FROM order_set_frequent osf
                             WHERE osf.id_order_set = l_id_order_set
                               AND osf.id_institution = i_id_institution
                               AND osf.id_software = i_id_software;
                        
                            IF l_count = 0
                            THEN
                            
                                g_error := ' IF l_count = 0';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                l_id_order_set_array.extend;
                                l_rank_array.extend;
                            
                                l_id_order_set_array(l_index) := l_id_order_set;
                                l_rank_array(l_index) := l_rank_def;
                            
                                l_index := l_index + 1;
                            
                            END IF;
                        END IF;
                    
                    END IF;
                
                END LOOP;
                g_error := 'CLOSE C_ORDER_SET_FREQUENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_order_set_frequent;
            
            END LOOP;
        
        END LOOP;
        g_error := 'OPEN O_ID_ORDER_SET';
        OPEN o_id_order_set FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_order_set_array AS table_number));
        g_error := 'OPEN O_RANK';
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_order_set);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_order_set_frequent;

    /********************************************************************************************
    * Set order set frequent for a specific institution
    *
    * @param i_lang                           Prefered language ID
    * @param i_market                         Market ID's
    * @param i_version                        ALERT version's
    * @param i_id_institution                 Institution ID
    * @param i_software                       Software ID
    * @param o_inst_order_set_frequent        Cursor of Instituition Transports
    * @param o_error                          Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/01/28
    ********************************************************************************************/
    FUNCTION set_inst_order_set_frequent
    (
        i_lang                    IN language.id_language%TYPE,
        i_market                  IN table_number,
        i_version                 IN table_varchar,
        i_id_institution          IN institution.id_institution%TYPE,
        i_software                IN table_number,
        o_inst_order_set_frequent OUT pk_types.cursor_type,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_order_set pk_types.cursor_type;
        l_c_rank         pk_types.cursor_type;
    
        l_data_id_order_set table_number;
        l_data_rank         table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_ORDER_SET_FREQUENT ';
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT GET_INST_ORDER_SET_FREQUENT';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_order_set_frequent(i_lang,
                                               i_market,
                                               i_version,
                                               i_id_institution,
                                               i_software(i),
                                               l_c_id_order_set,
                                               l_c_rank,
                                               l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := ' o_inst_order_set_frequent := l_c_id_order_set';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_inst_order_set_frequent := l_c_id_order_set;
            
                LOOP
                    FETCH l_c_id_order_set BULK COLLECT
                        INTO l_data_id_order_set LIMIT g_array_size;
                
                    FETCH l_c_rank BULK COLLECT
                        INTO l_data_rank LIMIT g_array_size;
                
                    g_error := 'FORALL j IN 1 .. l_data_id_order_set.COUNT';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                
                    FORALL j IN 1 .. l_data_id_order_set.count
                    
                        INSERT INTO order_set_frequent
                            (id_order_set, rank, id_institution, id_software)
                        VALUES
                            (l_data_id_order_set(j), l_data_rank(j), i_id_institution, i_software(i));
                
                    EXIT WHEN l_c_id_order_set%NOTFOUND;
                
                END LOOP;
                g_error := 'CLOSE L_C_ID_ORDER_SET';
                CLOSE l_c_id_order_set;
                g_error := 'CLOSE L_C_RANK';
                CLOSE l_c_rank;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_order_set_frequent;
    /********************************************************************************************
    * Get graphics set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_graphic             Cursor of graphics
        * @param o_rank            Cursor of ranks
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6.0.1
    * @since                       2010/03/11
    ********************************************************************************************/
    FUNCTION get_inst_graphic_soft_inst
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_graphic        OUT pk_types.cursor_type,
        o_rank           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        --Graphic_Soft_Inst
        l_id_graphic graphic_soft_inst.id_graphic%TYPE := NULL;
        l_rank       graphic_soft_inst.rank%TYPE := NULL;
    
        l_id_graphic_array table_number := table_number();
        l_rank_array       table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_graphic_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT gsi.id_graphic, gsi.rank
              FROM alert_default.graphic_soft_inst gsi, alert_default.graphic_mrk_vrs gmv
             WHERE gsi.id_software = c_id_software
               AND gsi.id_graphic = gmv.id_graphic
               AND gmv.id_market = c_market
               AND gmv.version = c_version;
    BEGIN
        g_func_name := 'GET_INST_GRAPHIC_SOFT_INST ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN  c_GRAPHIC_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                OPEN c_graphic_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_graphic_inst_soft
                        INTO l_id_graphic, l_rank;
                    EXIT WHEN c_graphic_inst_soft%NOTFOUND;
                
                    IF l_id_graphic != 0
                    
                    THEN
                    
                        g_error := 'COUNT';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        SELECT COUNT(gsi.id_graphic_soft_inst)
                          INTO l_count
                          FROM graphic_soft_inst gsi
                         WHERE gsi.id_graphic = l_id_graphic
                           AND gsi.id_institution = i_id_institution
                           AND gsi.id_software = i_id_software;
                    
                        IF l_count = 0
                        THEN
                        
                            g_error := 'IF l_count = 0';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            l_id_graphic_array.extend;
                            l_rank_array.extend;
                        
                            l_id_graphic_array(l_index) := l_id_graphic;
                            l_rank_array(l_index) := l_rank;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE c_GRAPHIC_inst_soft CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                CLOSE c_graphic_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'OPEN o_graphic';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_graphic FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_graphic_array AS table_number));
    
        g_error := ' OPEN o_rank';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_graphic);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_graphic_soft_inst;
    /********************************************************************************************
    * Set Graphic for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_graphic        Cursor of Instituition Exams
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/03/18
    ********************************************************************************************/
    FUNCTION set_inst_graphic_soft_inst
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_graphic   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_graphic pk_types.cursor_type;
        l_c_rank    pk_types.cursor_type;
    
        l_data_graphic table_number;
        l_data_rank    table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT get_inst_graphic_soft_inst';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_graphic_soft_inst ' || g_error);
        
            IF NOT get_inst_graphic_soft_inst(i_lang,
                                              i_market,
                                              i_version,
                                              i_id_institution,
                                              i_software(i),
                                              l_c_graphic,
                                              l_c_rank,
                                              l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_graphic := l_c_graphic;
            
                LOOP
                    FETCH l_c_graphic BULK COLLECT
                        INTO l_data_graphic LIMIT g_array_size;
                
                    FETCH l_c_rank BULK COLLECT
                        INTO l_data_rank LIMIT g_array_size;
                
                    g_error := 'FORALL j IN 1 .. l_data_graphic.COUNT';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.set_inst_graphic_soft_inst ' || g_error);
                
                    FORALL j IN 1 .. l_data_graphic.count
                    
                        INSERT INTO graphic_soft_inst
                            (id_graphic_soft_inst, id_graphic, id_institution, id_software, rank)
                        VALUES
                            (seq_graphic_soft_inst.nextval,
                             l_data_graphic(j),
                             i_id_institution,
                             i_software(i),
                             l_data_rank(j));
                
                    EXIT WHEN l_c_graphic%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_graphic;
                CLOSE l_c_rank;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_GRAPHIC_SOFT_INST',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_GRAPHIC_SOFT_INST',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_graphic_soft_inst;

    /********************************************************************************************
    * Set follow up entity for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_follow          Cursor of Instituition Exams
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      SMSS
    * @version                     2.6
    * @since                       2010/03/18
    ********************************************************************************************/
    FUNCTION set_inst_follow_up_entity_si
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_follow    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_error := 'IF NOT GET_INST_FOLLOW_UP_ENTITY_SI';
        MERGE INTO follow_up_entity_soft_inst fuesi
        USING (SELECT def_fuesi.id_follow_up_entity, def_fuesi.id_software, def_fuesi.flg_available, def_fuesi.rank
                 FROM alert_default.follow_up_entity_soft_inst def_fuesi
                INNER JOIN alert_default.follow_up_entity_mrk_vrs fuemv
                   ON (fuemv.id_follow_up_entity = def_fuesi.id_follow_up_entity)
                WHERE def_fuesi.flg_available = 'Y'
                  AND fuemv.id_market IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                           column_value
                                            FROM TABLE(CAST(i_market AS table_number)) p)
                  AND fuemv.version IN (SELECT /*+ opt_estimate(p rows = 10)*/
                                         column_value
                                          FROM TABLE(CAST(i_version AS table_varchar)) p)
                  AND def_fuesi.id_software IN
                      (SELECT /*+ opt_estimate(p rows = 10)*/
                        column_value
                         FROM TABLE(CAST(i_software AS table_number)) p)) def_data
        ON (fuesi.id_follow_up_entity = def_data.id_follow_up_entity AND fuesi.id_software = def_data.id_software AND fuesi.id_institution = i_id_institution)
        WHEN MATCHED THEN
            UPDATE
               SET fuesi.flg_available = def_data.flg_available
        WHEN NOT MATCHED THEN
            INSERT
                (id_follow_up_entity, id_institution, id_software, flg_available, rank)
            VALUES
                (def_data.id_follow_up_entity,
                 i_id_institution,
                 def_data.id_software,
                 def_data.flg_available,
                 def_data.rank);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_BACKOFFICE_DEFAULT',
                                              'set_inst_FOLLOW_UP_ENTITY_SI',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_follow_up_entity_si;
    /********************************************************************************************
    * Set DOC_AREAS by markets, versions and softwares into institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Set of Market ID's
    * @param i_version             Set of ALERT content version's
    * @param i_id_institution      Institution ID
    * @param i_software            Set of Software ID's
    * @param o_result              Number of records inserted
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     2.6.1
    * @since                       2013/01/22
    ********************************************************************************************/
    FUNCTION set_inst_doc_area
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_result         OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_next doc_area_inst_soft.id_doc_area_inst_soft%TYPE;
    BEGIN
        g_func_name := 'SET_INST_DOC_AREA';
        g_error     := 'GET DOC_AREA_INSTIT_SOFT NEXTVAL';
        SELECT MAX(dais.id_doc_area_inst_soft)
          INTO l_next
          FROM doc_area_inst_soft dais;
        g_error := 'LOAD DOC_AREA_INST_SOFT CONFIGURATIONS';
        INSERT INTO doc_area_inst_soft
            (id_doc_area_inst_soft,
             id_doc_area,
             id_institution,
             id_software,
             flg_mode,
             adw_last_update,
             flg_switch_mode,
             flg_type,
             flg_multiple,
             id_sys_shortcut_error,
             flg_scope_type,
             flg_data_paging_enabled,
             page_size,
             id_market)
            SELECT l_next + rownum,
                   def_data.id_doc_area,
                   i_id_institution,
                   def_data.id_software,
                   def_data.flg_mode,
                   SYSDATE,
                   def_data.flg_switch_mode,
                   def_data.flg_type,
                   def_data.flg_multiple,
                   def_data.id_sys_shortcut_error,
                   def_data.flg_scope_type,
                   def_data.flg_data_paging_enabled,
                   def_data.page_size,
                   NULL
              FROM (SELECT dais.id_doc_area,
                           dais.id_software,
                           dais.flg_mode,
                           dais.flg_type,
                           dais.flg_switch_mode,
                           dais.flg_multiple,
                           dais.id_sys_shortcut_error,
                           dais.flg_scope_type,
                           dais.flg_data_paging_enabled,
                           dais.page_size,
                           row_number() over(PARTITION BY dais.id_doc_area, dais.id_software ORDER BY dais.rowid) records_count
                      FROM alert_default.doc_area_inst_soft dais
                     INNER JOIN alert_default.doc_area_mrk_vrs damv
                        ON (damv.id_doc_area = dais.id_doc_area)
                     WHERE dais.id_software IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                 column_value
                                                  FROM TABLE(CAST(i_software AS table_number)) p)
                       AND damv.id_market IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                               column_value
                                                FROM TABLE(CAST(i_market AS table_number)) p)
                       AND damv.version IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                             column_value
                                              FROM TABLE(CAST(i_version AS table_varchar)) p)
                       AND EXISTS (SELECT 0
                              FROM doc_area da
                             WHERE da.id_doc_area = dais.id_doc_area
                               AND da.flg_available = g_flg_available)) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM doc_area_inst_soft al_dais
                     WHERE al_dais.id_doc_area = def_data.id_doc_area
                       AND al_dais.id_institution = i_id_institution
                       AND al_dais.id_software = def_data.id_software
                       AND al_dais.id_market IS NULL);
    
        o_result := SQL%ROWCOUNT;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_doc_area;

    /********************************************************************************************
    * Set DOC_TEMPLATE by markets, versions and softwares into institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Set of Market ID's
    * @param i_version             Set of ALERT content version's
    * @param i_id_institution      Institution ID
    * @param i_software            Set of Software ID's
    * @param o_result              Number of records inserted
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      JM
    * @version                     2.6.3
    * @since                       2013/04/08
    ********************************************************************************************/
    FUNCTION set_inst_doc_template_si
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_result         OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_next doc_area_inst_soft.id_doc_area_inst_soft%TYPE;
    BEGIN
        g_func_name := upper('set_inst_doc_template_si');
        g_error     := upper('GET set_inst_doc_template_si NEXTVAL');
        SELECT MAX(dtsi.id_doc_template_soft_inst)
          INTO l_next
          FROM doc_template_soft_inst dtsi;
        g_error := upper('LOAD set_inst_doc_template_si CONFIGURATIONS');
        INSERT INTO doc_template_soft_inst
            (id_doc_template_soft_inst, id_doc_template, id_software, id_institution, flg_available)
        
            SELECT l_next + rownum, def_data.id_doc_template, def_data.id_software, i_id_institution, g_flg_available
            
              FROM (SELECT dtsi.id_doc_template,
                           dtsi.id_software,
                           row_number() over(PARTITION BY dtsi.id_doc_template, dtsi.id_software ORDER BY dtsi.rowid) records_count
                      FROM alert_default.doc_template_soft_inst dtsi
                     WHERE dtsi.id_software IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                 column_value
                                                  FROM TABLE(CAST(i_software AS table_number)) p)
                       AND dtsi.id_market IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                               column_value
                                                FROM TABLE(CAST(i_market AS table_number)) p)
                       AND dtsi.version IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                             column_value
                                              FROM TABLE(CAST(i_version AS table_varchar)) p)
                       AND dtsi.flg_available = g_flg_available
                       AND EXISTS (SELECT 0
                              FROM doc_template dt
                             WHERE dt.id_doc_template = dtsi.id_doc_template
                               AND dt.flg_available = g_flg_available)) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM doc_template_soft_inst al_dtsi
                     WHERE al_dtsi.id_doc_template = def_data.id_doc_template
                       AND al_dtsi.id_software = def_data.id_software
                       AND al_dtsi.id_institution = i_id_institution);
    
        o_result := SQL%ROWCOUNT;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_doc_template_si;

    /********************************************************************************************
    * Get P1_SPEC_HELPS according to a P1_SPECIALITY
    *
    * @param i_lang                Prefered language ID
    * @param i_id_institution      Institution ID   
    * @param o_id_spec_help        Cursor of Spec_Help
    * @param o_code_title          Cursor of Code_Titles
    * @param o_code_text           Cursor of Code_Texts
    * @param o_rank                Cursor of Ranks
    * @param o_id_speciality       Cursor of P1_Specialities
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/14
    ********************************************************************************************/
    FUNCTION get_inst_p1_spec_help
    (
        i_lang           IN language.id_language%TYPE,
        i_id_institution IN institution.id_institution%TYPE,
        o_id_spec_help   OUT pk_types.cursor_type,
        o_code_title     OUT pk_types.cursor_type,
        o_code_text      OUT pk_types.cursor_type,
        o_rank           OUT pk_types.cursor_type,
        o_id_speciality  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_spec_help  p1_spec_help.id_spec_help%TYPE := NULL;
        l_code_title    p1_spec_help.code_title%TYPE := NULL;
        l_code_text     p1_spec_help.code_text%TYPE := NULL;
        l_rank          p1_spec_help.rank%TYPE := NULL;
        l_id_speciality p1_spec_help.id_speciality%TYPE := NULL;
    
        l_id_spec_help_array  table_number := table_number();
        l_code_title_array    table_varchar := table_varchar();
        l_code_text_array     table_varchar := table_varchar();
        l_rank_array          table_number := table_number();
        l_id_speciality_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_spec_help IS
            SELECT DISTINCT (psh.id_spec_help), psh.code_title, psh.code_text, psh.rank, p1s.id_speciality
              FROM alert_default.p1_spec_help psh
              JOIN p1_speciality p1s
                ON p1s.id_speciality = psh.id_speciality
               AND p1s.flg_available = g_flg_available
             WHERE psh.flg_available = g_flg_available;
    
    BEGIN
        g_error := 'get_institution_market -> id_institution : ' || i_id_institution;
        g_error := 'OPEN SPEC_HELP CURSOR';
        OPEN c_spec_help;
        LOOP
            FETCH c_spec_help
                INTO l_id_spec_help, l_code_title, l_code_text, l_rank, l_id_speciality;
            EXIT WHEN c_spec_help%NOTFOUND;
        
            SELECT COUNT(psh.id_spec_help)
              INTO l_count
              FROM p1_spec_help psh
              JOIN p1_speciality p1s
                ON p1s.id_speciality = psh.id_speciality
               AND p1s.flg_available = g_flg_available
             WHERE psh.flg_available = g_flg_available
               AND psh.id_institution = i_id_institution;
        
            IF l_count = 0
            THEN
                l_id_spec_help_array.extend;
                l_code_title_array.extend;
                l_code_text_array.extend;
                l_rank_array.extend;
                l_id_speciality_array.extend;
            
                l_id_spec_help_array(l_index) := l_id_spec_help;
                l_code_title_array(l_index) := l_code_title;
                l_code_text_array(l_index) := l_code_text;
                l_rank_array(l_index) := l_rank;
                l_id_speciality_array(l_index) := l_id_speciality;
            
                l_index := l_index + 1;
            END IF;
        END LOOP;
    
        g_error := 'CLOSE o_id_spec_help CURSOR';
        OPEN o_id_spec_help FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_spec_help_array AS table_number));
    
        g_error := 'CLOSE o_code_title CURSOR';
        OPEN o_code_title FOR
            SELECT column_value
              FROM TABLE(CAST(l_code_title_array AS table_varchar));
    
        g_error := 'CLOSE o_code_text CURSOR';
        OPEN o_code_text FOR
            SELECT column_value
              FROM TABLE(CAST(l_code_text_array AS table_varchar));
    
        g_error := 'CLOSE o_rank CURSOR';
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        g_error := 'CLOSE o_id_speciality CURSOR';
        OPEN o_id_speciality FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_speciality_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_P1_SPEC_HELP',
                                              o_error);
            pk_types.open_my_cursor(o_id_spec_help);
            pk_types.open_my_cursor(o_code_title);
            pk_types.open_my_cursor(o_code_text);
            pk_types.open_my_cursor(o_rank);
            pk_types.open_my_cursor(o_id_speciality);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_p1_spec_help;

    /********************************************************************************************
    * Set P1 for a specific institution
    *
    * @param i_lang                Prefered language ID  
    * @param i_id_institution      Institution ID
    * @param o_inst_vacc_group     Cursor of Instituition Vaccines
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/14
    ********************************************************************************************/
    FUNCTION set_inst_p1
    (
        i_lang           IN language.id_language%TYPE,
        i_id_institution IN institution.id_institution%TYPE,
        o_inst_p1        OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_spec_help  pk_types.cursor_type;
        l_c_code_title    pk_types.cursor_type;
        l_c_code_text     pk_types.cursor_type;
        l_c_rank          pk_types.cursor_type;
        l_c_id_speciality pk_types.cursor_type;
    
        l_data_id_spec_help  table_number;
        l_data_code_title    table_varchar;
        l_data_code_text     table_varchar;
        l_data_rank          table_number;
        l_data_id_speciality table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        dml_errors  EXCEPTION;
    BEGIN
    
        IF NOT get_inst_p1_spec_help(i_lang,
                                     i_id_institution,
                                     l_c_id_spec_help,
                                     l_c_code_title,
                                     l_c_code_text,
                                     l_c_rank,
                                     l_c_id_speciality,
                                     l_error)
        THEN
            RAISE l_exception;
        ELSE
            o_inst_p1 := l_c_id_spec_help;
        
            LOOP
                FETCH l_c_id_spec_help BULK COLLECT
                    INTO l_data_id_spec_help LIMIT g_array_size;
            
                FETCH l_c_code_title BULK COLLECT
                    INTO l_data_code_title LIMIT g_array_size;
            
                FETCH l_c_code_text BULK COLLECT
                    INTO l_data_code_text LIMIT g_array_size;
            
                FETCH l_c_rank BULK COLLECT
                    INTO l_data_rank LIMIT g_array_size;
            
                FETCH l_c_id_speciality BULK COLLECT
                    INTO l_data_id_speciality LIMIT g_array_size;
            
                FOR j IN 1 .. l_data_id_spec_help.count
                LOOP
                    g_error := 'INSERT INTO P1_SPEC_HELP';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_P1 ' || g_error);
                    INSERT INTO p1_spec_help
                        (id_spec_help,
                         code_title,
                         code_text,
                         rank,
                         id_institution,
                         id_speciality,
                         flg_available,
                         id_professional,
                         adw_last_update)
                    VALUES
                        (l_data_id_spec_help(j),
                         l_data_code_title(j),
                         l_data_code_text(j),
                         l_data_rank(j),
                         i_id_institution,
                         l_data_id_speciality(j),
                         'Y',
                         NULL,
                         SYSDATE);
                
                END LOOP;
            
                EXIT WHEN l_c_id_spec_help%NOTFOUND;
            
            END LOOP;
        
            CLOSE l_c_id_spec_help;
            CLOSE l_c_code_title;
            CLOSE l_c_code_text;
            CLOSE l_c_rank;
            CLOSE l_c_id_speciality;
        
        END IF;
    
        -- 16/03/2011 RMGM: changed way how translations are loaded
        g_table_name := upper('p1_spec_help');
        g_error      := 'SET DEF TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_P1',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_P1',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
        
            RETURN FALSE;
        
    END set_inst_p1;
    /********************************************************************************************
    * Get BodyDiagram_Age_Group set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_bd_age_grp          Cursor of BodyDiagram_Age_Group
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/15
    ********************************************************************************************/
    FUNCTION get_inst_bd_age_grp
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_bd_age_grp     OUT pk_types.cursor_type,
        o_bd_min_age     OUT pk_types.cursor_type,
        o_bd_max_age     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_body_diag_age_grp body_diag_age_grp.id_body_diag_age_grp%TYPE := NULL;
        l_bd_min_age           body_diag_age_grp.min_age%TYPE := NULL;
        l_bd_max_age           body_diag_age_grp.max_age%TYPE := NULL;
    
        l_body_diag_age_grp_array table_number := table_number();
        l_bd_min_age_array        table_number := table_number();
        l_bd_max_age_array        table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_bd_age_grp_inst_soft
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT bdsi.id_body_diag_age_grp, bdsi.min_age, bdsi.max_age
              FROM alert_default.bd_age_grp_soft_inst      bdsi,
                   alert_default.body_diag_age_grp_mrk_vrs bdmv,
                   body_diag_age_grp                       bdag
             WHERE bdsi.id_software = c_id_software
               AND bdsi.id_body_diag_age_grp = bdmv.id_body_diag_age_grp
               AND bdmv.id_market = c_market
               AND bdmv.version = c_version
               AND bdmv.id_body_diag_age_grp = bdag.id_body_diag_age_grp;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_BD_AGE_GRP_INST_SOFT CURSOR';
                OPEN c_bd_age_grp_inst_soft(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_bd_age_grp_inst_soft
                        INTO l_id_body_diag_age_grp, l_bd_min_age, l_bd_max_age;
                    EXIT WHEN c_bd_age_grp_inst_soft%NOTFOUND;
                
                    g_error := 'COUNT BD_AGE_GRP';
                    SELECT COUNT(bdsi.id_body_diag_age_grp)
                      INTO l_count
                      FROM bd_age_grp_soft_inst bdsi
                     WHERE bdsi.id_body_diag_age_grp = l_id_body_diag_age_grp
                       AND bdsi.id_institution = i_id_institution
                       AND bdsi.id_software = i_id_software;
                
                    IF l_count = 0
                    THEN
                        l_body_diag_age_grp_array.extend;
                        l_bd_min_age_array.extend;
                        l_bd_max_age_array.extend;
                    
                        l_body_diag_age_grp_array(l_index) := l_id_body_diag_age_grp;
                        l_bd_min_age_array(l_index) := l_bd_min_age;
                        l_bd_max_age_array(l_index) := l_bd_max_age;
                    
                        l_index := l_index + 1;
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_BD_AGE_GRP_INST_SOFT CURSOR';
                CLOSE c_bd_age_grp_inst_soft;
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_BD_AGE_GRP CURSOR';
        OPEN o_bd_age_grp FOR
            SELECT column_value
              FROM TABLE(CAST(l_body_diag_age_grp_array AS table_number));
    
        g_error := 'CLOSE O_BD_MIN_AGE CURSOR';
        OPEN o_bd_min_age FOR
            SELECT column_value
              FROM TABLE(CAST(l_bd_min_age_array AS table_number));
    
        g_error := 'CLOSE O_BD_MAX_AGE CURSOR';
        OPEN o_bd_max_age FOR
            SELECT column_value
              FROM TABLE(CAST(l_bd_max_age_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_BD_AGE_GRP',
                                              o_error);
            pk_types.open_my_cursor(o_bd_age_grp);
            pk_types.open_my_cursor(o_bd_min_age);
            pk_types.open_my_cursor(o_bd_max_age);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_bd_age_grp;

    /********************************************************************************************
    * Set BodyDiagrams for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_body_diagram   Cursor of Instituition BodyDiagrams
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/15
    ********************************************************************************************/
    FUNCTION set_inst_body_diagram
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_software          IN table_number,
        o_inst_body_diagram OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_body_diag_age_grp table_number;
        l_data_bd_min_age        table_number;
        l_data_bd_max_age        table_number;
    
        l_c_body_diag_age_grp pk_types.cursor_type;
        l_c_bd_min_age        pk_types.cursor_type;
        l_c_bd_max_age        pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            IF NOT get_inst_bd_age_grp(i_lang,
                                       i_market,
                                       i_version,
                                       i_id_institution,
                                       i_software(i),
                                       l_c_body_diag_age_grp,
                                       l_c_bd_min_age,
                                       l_c_bd_max_age,
                                       l_error)
            THEN
                RAISE l_exception;
            ELSE
            
                o_inst_body_diagram := l_c_body_diag_age_grp;
                LOOP
                    FETCH l_c_body_diag_age_grp BULK COLLECT
                        INTO l_data_body_diag_age_grp LIMIT g_array_size;
                
                    FETCH l_c_bd_min_age BULK COLLECT
                        INTO l_data_bd_min_age LIMIT g_array_size;
                
                    FETCH l_c_bd_max_age BULK COLLECT
                        INTO l_data_bd_max_age LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_body_diag_age_grp.count
                    LOOP
                        g_error := 'INSERT INTO BD_AGE_GRP_SOFT_INST (' || l_data_body_diag_age_grp(j) || ',' ||
                                   l_data_bd_min_age(j) || l_data_bd_max_age(j) || ',' || i_software(i) || ',' ||
                                   i_id_institution || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_BODY_DIAGRAM ' || g_error);
                    
                        INSERT INTO bd_age_grp_soft_inst
                            (id_body_diag_age_grp, min_age, max_age, id_software, id_institution)
                        VALUES
                            (l_data_body_diag_age_grp(j),
                             l_data_bd_min_age(j),
                             l_data_bd_max_age(j),
                             i_software(i),
                             i_id_institution);
                    END LOOP;
                    EXIT WHEN l_c_body_diag_age_grp%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_body_diag_age_grp;
                CLOSE l_c_bd_min_age;
                CLOSE l_c_bd_max_age;
            END IF;
        END LOOP;
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_BODY_DIAGRAM',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_BODY_DIAGRAM',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_body_diagram;
    /********************************************************************************************
    * Get SYS_CONFIG set of markets and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_sys_config          Cursor of SYS_CONFIG
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/15
    ********************************************************************************************/
    FUNCTION get_inst_sys_config
    (
        i_lang           IN language.id_language%TYPE,
        i_id_market      IN market.id_market%TYPE,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_sys_config     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_generic_value NUMBER(24) := 0;
        l_invalid_value VARCHAR2(50) := '-100';
    
    BEGIN
    
        g_error := 'CLOSE O_ID_SYS_CONFIG CURSOR';
        OPEN o_sys_config FOR
            SELECT def_data.id_sys_config,
                   def_data.value,
                   def_data.desc_sys_config,
                   def_data.id_software,
                   def_data.fill_type,
                   def_data.client_configuration,
                   def_data.internal_configuration,
                   def_data.global_configuration,
                   def_data.id_market
              FROM (SELECT temp_data.my_rowid,
                           temp_data.id_sys_config,
                           temp_data.value,
                           temp_data.desc_sys_config,
                           temp_data.id_software,
                           temp_data.fill_type,
                           temp_data.client_configuration,
                           temp_data.internal_configuration,
                           temp_data.global_configuration,
                           temp_data.id_market,
                           rank() over(PARTITION BY temp_data.id_sys_config, temp_data.value, temp_data.id_software, temp_data.id_market ORDER BY temp_data.my_rowid) frecords_count
                      FROM (SELECT sc.rowid my_rowid,
                                   sc.id_sys_config,
                                   nvl(nvl(sc.value, pk_utils.query_to_string(sc.value_qry, '|')), l_invalid_value) VALUE,
                                   sc.desc_sys_config,
                                   sc.id_software,
                                   sc.fill_type,
                                   sc.client_configuration,
                                   sc.internal_configuration,
                                   sc.global_configuration,
                                   sc.id_market
                              FROM alert_default.sys_config sc
                             WHERE sc.id_software IN (l_generic_value, i_id_software)
                               AND sc.id_market IN (l_generic_value, i_id_market)) temp_data
                     WHERE temp_data.value != l_invalid_value) def_data
             WHERE def_data.frecords_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM sys_config alert_sc
                     WHERE alert_sc.id_institution = i_id_institution
                       AND alert_sc.id_software = def_data.id_software
                       AND alert_sc.id_sys_config = def_data.id_sys_config);
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_SYS_CONFIG',
                                              o_error);
            pk_types.open_my_cursor(o_sys_config);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_sys_config;
    /********************************************************************************************
    * Set SYS_CONFIG for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_sys_config     Cursor of Instituition SYS_CONFIG
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/15
    ********************************************************************************************/
    FUNCTION set_inst_sys_config
    (
        i_lang            IN language.id_language%TYPE,
        i_market          IN table_number,
        i_id_institution  IN institution.id_institution%TYPE,
        i_software        IN table_number,
        o_inst_sys_config OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_id_sys_config   table_varchar;
        l_data_desc_sys_config table_varchar;
        l_data_sc_value        table_varchar;
        l_data_sc_software_id  table_number;
        l_data_sc_fill_type    table_varchar;
        l_data_sc_client_conf  table_varchar;
        l_data_sc_intern_conf  table_varchar;
        l_data_sc_global_conf  table_varchar;
        l_data_sc_market       table_number;
    
        l_c_sys_config pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        FOR k IN 1 .. i_market.count
        LOOP
            FOR i IN 1 .. i_software.count
            LOOP
                IF NOT
                    get_inst_sys_config(i_lang, i_market(k), i_id_institution, i_software(i), l_c_sys_config, l_error)
                THEN
                    RAISE l_exception;
                ELSE
                
                    LOOP
                        FETCH l_c_sys_config BULK COLLECT
                            INTO l_data_id_sys_config,
                                 l_data_sc_value,
                                 l_data_desc_sys_config,
                                 l_data_sc_software_id,
                                 l_data_sc_fill_type,
                                 l_data_sc_client_conf,
                                 l_data_sc_intern_conf,
                                 l_data_sc_global_conf,
                                 l_data_sc_market LIMIT g_array_size;
                    
                        FORALL j IN 1 .. l_data_id_sys_config.count
                            INSERT INTO sys_config
                                (id_sys_config,
                                 VALUE,
                                 desc_sys_config,
                                 id_institution,
                                 id_software,
                                 fill_type,
                                 client_configuration,
                                 internal_configuration,
                                 global_configuration,
                                 flg_schema,
                                 id_market)
                            VALUES
                                (l_data_id_sys_config(j),
                                 l_data_sc_value(j),
                                 l_data_desc_sys_config(j),
                                 i_id_institution,
                                 l_data_sc_software_id(j),
                                 l_data_sc_fill_type(j),
                                 l_data_sc_client_conf(j),
                                 l_data_sc_intern_conf(j),
                                 l_data_sc_global_conf(j),
                                 'A',
                                 l_data_sc_market(j));
                        EXIT WHEN l_c_sys_config%NOTFOUND;
                    
                    END LOOP;
                
                    CLOSE l_c_sys_config;
                END IF;
            END LOOP;
        END LOOP;
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_SYS_CONFIG',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_SYS_CONFIG',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_sys_config;

    /********************************************************************************************
    * Get Transports entities set of markets, versions and sotwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_id_disch_reason               Cursor of disch_reason
    * @param o_id_transp_entity         Cursor of transp_entity
    * @param o_error                 Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/16
    ********************************************************************************************/
    FUNCTION get_inst_disch_rea_transp_ei
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN table_number,
        i_version          IN table_varchar,
        i_id_institution   IN institution.id_institution%TYPE,
        o_id_disch_reason  OUT pk_types.cursor_type,
        o_id_transp_entity OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_disch_reason_def  discharge_reason.id_discharge_reason%TYPE := NULL;
        l_id_disch_reason      discharge_reason.id_discharge_reason%TYPE := NULL;
        l_id_transp_entity_def transp_entity.id_transp_entity%TYPE := NULL;
        l_id_transp_ent_inst   transp_entity.id_transp_entity%TYPE := NULL;
    
        l_id_disch_reason_array    table_number := table_number();
        l_id_transp_ent_inst_array table_number := table_number();
    
        l_count                 NUMBER := 0;
        l_count_transp_ent_inst NUMBER := 0;
        l_count_transp_entity   NUMBER := 0;
        l_index                 NUMBER := 1;
    
        CURSOR c_disch_rea_transp_ent_inst
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT drtei.id_discharge_reason, drtei.id_transp_entity
              FROM alert_default.disch_rea_transp_ent_inst drtei
              JOIN alert_default.discharge_reason_mrk_vrs drmk
                ON drmk.id_discharge_reason = drtei.id_discharge_reason
               AND drmk.id_market = c_market
               AND drmk.version = c_version
              JOIN alert_default.transp_entity_mrk_vrs temk
                ON temk.id_transp_entity = drtei.id_transp_entity
               AND temk.id_market = c_market
               AND temk.version = c_version
              JOIN alert_default.transp_entity def_te
                ON def_te.id_transp_entity = drtei.id_transp_entity
             WHERE drtei.flg_available = g_flg_available;
        /*http://alertjira/browse/ALERT-200182*/
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_DISCH_REA_TRANSP_ENT_INST CURSOR';
                OPEN c_disch_rea_transp_ent_inst(i_version(i), i_market(j));
                LOOP
                    FETCH c_disch_rea_transp_ent_inst
                        INTO l_id_disch_reason_def, l_id_transp_entity_def;
                    EXIT WHEN c_disch_rea_transp_ent_inst%NOTFOUND;
                
                    --DISCHARGE_REASON
                    g_error := 'DISCHARGE_REASON';
                    SELECT nvl((SELECT dr.id_discharge_reason
                                 FROM discharge_reason dr
                                WHERE dr.id_content =
                                      (SELECT def_dr.id_content
                                         FROM alert_default.discharge_reason def_dr
                                        WHERE def_dr.id_discharge_reason = l_id_disch_reason_def)
                                  AND dr.id_content IS NOT NULL
                                  AND dr.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_disch_reason
                      FROM dual;
                
                    --TRANSP_ENTITY
                    g_error := 'TRANSP_ENTITY';
                    SELECT nvl((SELECT tei.id_transp_ent_inst
                                 FROM transp_entity te
                                 JOIN transp_ent_inst tei
                                   ON (tei.id_transp_entity = te.id_transp_entity AND
                                      tei.flg_available = g_flg_available AND tei.id_institution = i_id_institution)
                                WHERE te.id_content =
                                      (SELECT def_te.id_content
                                         FROM alert_default.transp_entity def_te
                                        WHERE def_te.id_transp_entity = l_id_transp_entity_def)
                                  AND te.id_content IS NOT NULL
                                  AND te.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_transp_ent_inst
                      FROM dual;
                
                    IF l_id_disch_reason != 0
                       AND l_id_transp_ent_inst != 0
                    THEN
                    
                        g_error := 'COUNT DISCH_REA_TRANSP_ENT_INST';
                        SELECT COUNT(dri.id_disch_rea_transp_ent_inst)
                          INTO l_count
                          FROM disch_rea_transp_ent_inst dri
                         WHERE dri.id_discharge_reason = l_id_disch_reason
                           AND dri.id_transp_ent_inst = l_id_transp_ent_inst
                           AND dri.flg_available = g_flg_available;
                    
                        IF l_count = 0
                        THEN
                            l_id_disch_reason_array.extend;
                            l_id_transp_ent_inst_array.extend;
                        
                            l_id_disch_reason_array(l_index) := l_id_disch_reason;
                            l_id_transp_ent_inst_array(l_index) := l_id_transp_ent_inst;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_DISCH_REA_TRANSP_ENT_INST CURSOR';
                CLOSE c_disch_rea_transp_ent_inst;
            
            END LOOP;
        END LOOP;
        g_error := 'CLOSE O_ID_DISCH_REASON CURSOR';
        OPEN o_id_disch_reason FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_disch_reason_array AS table_number));
    
        g_error := 'CLOSE O_ID_TRANSP_ENTITY CURSOR';
        OPEN o_id_transp_entity FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_transp_ent_inst_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_DISCH_REA_TRANSP_EI',
                                              o_error);
            pk_types.open_my_cursor(o_id_disch_reason);
            pk_types.open_my_cursor(o_id_transp_entity);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_disch_rea_transp_ei;
    /********************************************************************************************
    * Get DISCHARGE_REASON/TRANSP_ENTITY relation set of markets and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_inst_disch_rea_transp_ei   Cursor of Instituition DISCHARGE_REASON/TRANSP_ENTITY relation
    * @param o_error               Error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/16
    ********************************************************************************************/
    FUNCTION set_inst_disch_rea_transp_ei
    (
        i_lang                     IN language.id_language%TYPE,
        i_market                   IN table_number,
        i_version                  IN table_varchar,
        i_id_institution           IN institution.id_institution%TYPE,
        o_inst_disch_rea_transp_ei OUT pk_types.cursor_type,
        o_error                    OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_id_disch_reason    table_number;
        l_data_id_transp_ent_inst table_number;
    
        l_c_id_disch_reason    pk_types.cursor_type;
        l_c_id_transp_ent_inst pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        IF NOT get_inst_disch_rea_transp_ei(i_lang,
                                            i_market,
                                            i_version,
                                            i_id_institution,
                                            l_c_id_disch_reason,
                                            l_c_id_transp_ent_inst,
                                            l_error)
        THEN
            RAISE l_exception;
        ELSE
        
            o_inst_disch_rea_transp_ei := l_c_id_disch_reason;
            LOOP
                FETCH l_c_id_disch_reason BULK COLLECT
                    INTO l_data_id_disch_reason LIMIT g_array_size;
            
                FETCH l_c_id_transp_ent_inst BULK COLLECT
                    INTO l_data_id_transp_ent_inst LIMIT g_array_size;
            
                FOR j IN 1 .. l_data_id_disch_reason.count
                LOOP
                    g_error := 'INSERT INTO DISCH_REA_TRANSP_ENT_INST (seq_disch_rea_transp_ent_inst.NEXTVAL, ' ||
                               l_data_id_disch_reason(j) || ', ' || l_data_id_transp_ent_inst(j) || ');';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_BODY_DIAGRAM ' || g_error);
                
                    INSERT INTO disch_rea_transp_ent_inst
                        (id_disch_rea_transp_ent_inst, id_discharge_reason, id_transp_ent_inst, flg_available)
                    VALUES
                        (seq_disch_rea_transp_ent_inst.nextval,
                         l_data_id_disch_reason(j),
                         l_data_id_transp_ent_inst(j),
                         'Y');
                
                END LOOP;
                EXIT WHEN l_c_id_disch_reason%NOTFOUND;
            
            END LOOP;
        
            CLOSE l_c_id_disch_reason;
            CLOSE l_c_id_transp_ent_inst;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DISCH_REA_TRANSP_EI',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DISCH_REA_TRANSP_EI',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_disch_rea_transp_ei;
    /********************************************************************************************
    * Get Profile_Discharge_Reason set of markets, versions and sotwares
    *
    * @param i_lang                  Prefered language ID
    * @param i_market                Market ID's
    * @param i_version               ALERT version's
    * @param i_id_institution        Institution ID
    * @param i_id_software           Software ID
    * @param o_id_disch_reason       Cursor of disch_reason
    * @param o_id_transp_entity      Cursor of transp_entity
    * @param o_error                 Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/16
    ********************************************************************************************/
    FUNCTION get_inst_profile_disch_reason
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN table_number,
        i_version             IN table_varchar,
        i_id_institution      IN institution.id_institution%TYPE,
        o_id_disch_reason     OUT pk_types.cursor_type,
        o_id_profile_template OUT pk_types.cursor_type,
        o_flg_available       OUT pk_types.cursor_type,
        o_id_flash_files      OUT pk_types.cursor_type,
        o_flg_access          OUT pk_types.cursor_type,
        o_rank                OUT pk_types.cursor_type,
        o_flg_default         OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_disch_reason_def discharge_reason.id_discharge_reason%TYPE := NULL;
        l_id_disch_reason     discharge_reason.id_discharge_reason%TYPE := NULL;
        l_id_profile_template profile_template.id_profile_template%TYPE := NULL;
        l_flg_available       profile_disch_reason.flg_available%TYPE := NULL;
        l_id_flash_files      discharge_flash_files.id_discharge_flash_files%TYPE := NULL;
        l_flg_access          profile_disch_reason.flg_access%TYPE := NULL;
        l_rank                profile_disch_reason.rank%TYPE := NULL;
        l_flg_default         profile_disch_reason.flg_default%TYPE := NULL;
    
        l_id_disch_reason_array     table_number := table_number();
        l_id_profile_template_array table_number := table_number();
        l_flg_available_array       table_varchar := table_varchar();
        l_id_flash_files_array      table_number := table_number();
        l_flg_access_array          table_varchar := table_varchar();
        l_rank_array                table_number := table_number();
        l_flg_default_array         table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_profile_disch_reason
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT pdr.id_discharge_reason,
                            pdr.id_profile_template,
                            pdr.flg_available,
                            pdr.id_discharge_flash_files,
                            pdr.flg_access,
                            pdr.rank,
                            pdr.flg_default
              FROM alert_default.profile_disch_reason pdr
              JOIN alert_default.discharge_reason_mrk_vrs drmk
                ON drmk.id_discharge_reason = pdr.id_discharge_reason
               AND drmk.id_market = c_market
               AND drmk.version = c_version
              JOIN discharge_flash_files dff
                ON dff.id_discharge_flash_files = pdr.id_discharge_flash_files
             WHERE pdr.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_PROFILE_DISCH_REASON CURSOR';
                OPEN c_profile_disch_reason(i_version(i), i_market(j));
                LOOP
                    FETCH c_profile_disch_reason
                        INTO l_id_disch_reason_def,
                             l_id_profile_template,
                             l_flg_available,
                             l_id_flash_files,
                             l_flg_access,
                             l_rank,
                             l_flg_default;
                    EXIT WHEN c_profile_disch_reason%NOTFOUND;
                
                    g_error := 'DISCHARGE_REASON';
                    SELECT nvl((SELECT dr.id_discharge_reason
                                 FROM discharge_reason dr
                                WHERE dr.id_content =
                                      (SELECT def_dr.id_content
                                         FROM alert_default.discharge_reason def_dr
                                        WHERE def_dr.id_discharge_reason = l_id_disch_reason_def)
                                  AND dr.id_content IS NOT NULL
                                  AND dr.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_disch_reason
                      FROM dual;
                
                    IF l_id_disch_reason != 0
                    THEN
                        g_error := 'COUNT PROFILE_DISCH_REASON';
                        SELECT COUNT(pdr.id_profile_disch_reason)
                          INTO l_count
                          FROM profile_disch_reason pdr
                         WHERE pdr.id_discharge_reason = l_id_disch_reason
                           AND pdr.id_institution = i_id_institution
                           AND pdr.id_profile_template = l_id_profile_template
                           AND pdr.id_discharge_flash_files = l_id_flash_files
                           AND pdr.flg_access = l_flg_access
                           AND pdr.flg_default = l_flg_default
                           AND pdr.rank = l_rank
                           AND pdr.flg_available = l_flg_available;
                    
                        IF l_count = 0
                        THEN
                            l_id_disch_reason_array.extend;
                            l_id_profile_template_array.extend;
                            l_flg_available_array.extend;
                            l_id_flash_files_array.extend;
                            l_flg_access_array.extend;
                            l_rank_array.extend;
                            l_flg_default_array.extend;
                        
                            l_id_disch_reason_array(l_index) := l_id_disch_reason;
                            l_id_profile_template_array(l_index) := l_id_profile_template;
                            l_flg_available_array(l_index) := l_flg_available;
                            l_id_flash_files_array(l_index) := l_id_flash_files;
                            l_flg_access_array(l_index) := l_flg_access;
                            l_rank_array(l_index) := l_rank;
                            l_flg_default_array(l_index) := l_flg_default;
                        
                            l_index := l_index + 1;
                        END IF;
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_PROFILE_DISCH_REASON CURSOR';
                CLOSE c_profile_disch_reason;
            
            END LOOP;
        END LOOP;
        g_error := 'CLOSE O_ID_DISCH_REASON CURSOR';
        OPEN o_id_disch_reason FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_disch_reason_array AS table_number));
    
        g_error := 'CLOSE O_ID_PROFILE_TEMPLATE CURSOR';
        OPEN o_id_profile_template FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_profile_template_array AS table_number));
    
        g_error := 'CLOSE O_FLG_AVAILABE CURSOR';
        OPEN o_flg_available FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_available_array AS table_varchar));
    
        g_error := 'CLOSE O_ID_FLASH_FILES CURSOR';
        OPEN o_id_flash_files FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_flash_files_array AS table_number));
    
        g_error := 'CLOSE O_FLG_ACCESS CURSOR';
        OPEN o_flg_access FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_access_array AS table_varchar));
    
        g_error := 'CLOSE O_RANK CURSOR';
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        g_error := 'CLOSE O_FLG_DEFAULT CURSOR';
        OPEN o_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_default_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_PROFILE_DISCH_REASON',
                                              o_error);
            pk_types.open_my_cursor(o_id_disch_reason);
            pk_types.open_my_cursor(o_id_profile_template);
            pk_types.open_my_cursor(o_flg_available);
            pk_types.open_my_cursor(o_id_flash_files);
            pk_types.open_my_cursor(o_flg_access);
            pk_types.open_my_cursor(o_rank);
            pk_types.open_my_cursor(o_flg_default);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_profile_disch_reason;
    /********************************************************************************************
    * Get Profile_Discharge_Reason set of markets and sotwares
    *
    * @param i_lang                       Prefered language ID
    * @param i_market                     Market ID's
    * @param i_version                    ALERT version's
    * @param i_id_institution             Institution ID
    * @param o_inst_profile_disch_reason  Cursor of Instituition PROFILE_DISCH_REASON
    * @param o_error                      Error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/16
    ********************************************************************************************/
    FUNCTION set_inst_profile_disch_reason
    (
        i_lang                      IN language.id_language%TYPE,
        i_market                    IN table_number,
        i_version                   IN table_varchar,
        i_id_institution            IN institution.id_institution%TYPE,
        o_inst_profile_disch_reason OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_id_disch_reason     table_number;
        l_data_id_profile_template table_number;
        l_data_flg_available       table_varchar;
        l_data_id_flash_files      table_number;
        l_data_flg_access          table_varchar;
        l_data_rank                table_number;
        l_data_flg_default         table_varchar;
    
        l_c_id_disch_reason     pk_types.cursor_type;
        l_c_id_profile_template pk_types.cursor_type;
        l_c_flg_available       pk_types.cursor_type;
        l_c_id_flash_files      pk_types.cursor_type;
        l_c_flg_access          pk_types.cursor_type;
        l_c_rank                pk_types.cursor_type;
        l_c_flg_default         pk_types.cursor_type;
    
        l_next                    profile_disch_reason.id_profile_disch_reason%TYPE;
        l_id_profile_disch_reason table_number := table_number();
        l_count                   NUMBER := 1;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        IF NOT get_inst_profile_disch_reason(i_lang,
                                             i_market,
                                             i_version,
                                             i_id_institution,
                                             l_c_id_disch_reason,
                                             l_c_id_profile_template,
                                             l_c_flg_available,
                                             l_c_id_flash_files,
                                             l_c_flg_access,
                                             l_c_rank,
                                             l_c_flg_default,
                                             l_error)
        THEN
            RAISE l_exception;
        ELSE
            o_inst_profile_disch_reason := l_c_id_disch_reason;
            LOOP
                FETCH l_c_id_disch_reason BULK COLLECT
                    INTO l_data_id_disch_reason LIMIT g_array_size;
            
                FETCH l_c_id_profile_template BULK COLLECT
                    INTO l_data_id_profile_template LIMIT g_array_size;
            
                FETCH l_c_flg_available BULK COLLECT
                    INTO l_data_flg_available LIMIT g_array_size;
            
                FETCH l_c_id_flash_files BULK COLLECT
                    INTO l_data_id_flash_files LIMIT g_array_size;
            
                FETCH l_c_flg_access BULK COLLECT
                    INTO l_data_flg_access LIMIT g_array_size;
            
                FETCH l_c_rank BULK COLLECT
                    INTO l_data_rank LIMIT g_array_size;
            
                FETCH l_c_flg_default BULK COLLECT
                    INTO l_data_flg_default LIMIT g_array_size;
            
                FOR j IN 1 .. l_data_id_disch_reason.count
                LOOP
                    g_error := 'GET MAX FROM PROFILE_DISCH_REASON';
                    SELECT MAX(pdr.id_profile_disch_reason) + 1
                      INTO l_next
                      FROM profile_disch_reason pdr;
                
                    g_error := 'INSERT INTO PROFILE_DISCH_REASON (' || l_next || ', ' || l_data_id_disch_reason(j) || ', ' ||
                               l_data_id_profile_template(j) || ', ' || i_id_institution || ', ' ||
                               l_data_flg_available(j) || ', ' || l_data_id_flash_files(j) || ', ' ||
                               l_data_flg_access(j) || ', ' || l_data_rank(j) || ', ' || l_data_flg_default(j) || ');';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROFILE_DISCH_REASON ' || g_error);
                
                    INSERT INTO profile_disch_reason
                        (id_profile_disch_reason,
                         id_discharge_reason,
                         id_profile_template,
                         id_institution,
                         flg_available,
                         id_discharge_flash_files,
                         flg_access,
                         rank,
                         flg_default)
                    VALUES
                        (l_next,
                         l_data_id_disch_reason(j),
                         l_data_id_profile_template(j),
                         i_id_institution,
                         l_data_flg_available(j),
                         l_data_id_flash_files(j),
                         l_data_flg_access(j),
                         l_data_rank(j),
                         l_data_flg_default(j));
                
                    l_id_profile_disch_reason.extend;
                    l_id_profile_disch_reason(l_count) := l_next;
                    l_count := l_count + 1;
                
                END LOOP;
                EXIT WHEN l_c_id_disch_reason%NOTFOUND;
            
            END LOOP;
        
            CLOSE l_c_id_disch_reason;
            CLOSE l_c_id_profile_template;
            CLOSE l_c_flg_available;
            CLOSE l_c_id_flash_files;
            CLOSE l_c_flg_access;
            CLOSE l_c_rank;
            CLOSE l_c_flg_default;
        
        END IF;
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_PROFILE_DISCH_REASON',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_PROFILE_DISCH_REASON',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_profile_disch_reason;
    /********************************************************************************************
    * Get PROTOCOL set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol                  Cursor of protocol
    * @param o_id_protocol_prev_vrs         Cursor of protocol_previous version
    * @param o_protocol_descr               Cursor of protocol description
    * @param o_flg_status                   Cursor of flg_status
    * @param o_id_ebm                       Cursor of EMB_ID
    * @param o_context_title                Cursor of Context_Title
    * @param o_context_adaptation           Cursor of Context_Adaptation
    * @param o_context_type_media           Cursor of Context_Type_Media
    * @param o_context_editor               Cursor of Context_Editor
    * @param o_context_edition_site         Cursor of Context_Edition_Site
    * @param o_context_edition              Cursor of Context_Edition
    * @param o_dt_context_edition           Cursor of Date_Context_Edition
    * @param o_context_access               Cursor of Context_Access
    * @param o_id_context_lang              Cursor of ID_Context_Language
    * @param o_flg_context_img              Cursor of Flg_Context_Image
    * @param o_context_subtitle             Cursor of Context_Subtitle
    * @param o_id_context_associated_lang   Cursor of Id_Context_Associated
    * @param o_flg_type_recommend           Cursor of Flg_Type_Recommend
    * @param o_context_desc                 Cursor of Context_description
    * @param o_id_content                   Cursor of Id_Content
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/04/19
    ********************************************************************************************/
    FUNCTION get_inst_protocol
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_id_institution        IN institution.id_institution%TYPE,
        i_id_software           IN software.id_software%TYPE,
        o_id_protocol           OUT pk_types.cursor_type,
        o_id_protocol_prev_vrs  OUT pk_types.cursor_type,
        o_protocol_descr        OUT pk_types.cursor_type,
        o_flg_status            OUT pk_types.cursor_type,
        o_id_ebm                OUT pk_types.cursor_type,
        o_context_title         OUT pk_types.cursor_type,
        o_context_adaptation    OUT pk_types.cursor_type,
        o_context_type_media    OUT pk_types.cursor_type,
        o_context_editor        OUT pk_types.cursor_type,
        o_context_edition_site  OUT pk_types.cursor_type,
        o_context_edition       OUT pk_types.cursor_type,
        o_dt_context_edition    OUT pk_types.cursor_type,
        o_context_access        OUT pk_types.cursor_type,
        o_id_context_lang       OUT pk_types.cursor_type,
        o_flg_context_img       OUT pk_types.cursor_type,
        o_context_subtitle      OUT pk_types.cursor_type,
        o_id_context_assoc_lang OUT pk_types.cursor_type,
        o_flg_type_recommend    OUT pk_types.cursor_type,
        o_context_desc          OUT pk_types.cursor_type,
        o_id_content            OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol_def       protocol.id_protocol%TYPE;
        l_id_protocol           protocol.id_protocol%TYPE;
        l_id_protocol_prev_vrs  protocol.id_protocol_previous_version%TYPE;
        l_protocol_descr        protocol.protocol_desc%TYPE;
        l_flg_status            protocol.flg_status%TYPE;
        l_id_ebm                protocol.id_ebm%TYPE;
        l_context_title         protocol.context_title%TYPE;
        l_context_adaptation    protocol.context_adaptation%TYPE;
        l_context_type_media    protocol.context_type_media%TYPE;
        l_context_editor        protocol.context_editor%TYPE;
        l_context_edition_site  protocol.context_edition_site%TYPE;
        l_context_edition       protocol.context_edition%TYPE;
        l_dt_context_edition    protocol.dt_context_edition%TYPE;
        l_context_access        protocol.context_access%TYPE;
        l_id_context_lang       protocol.id_context_language%TYPE;
        l_flg_context_img       protocol.flg_context_image%TYPE;
        l_context_subtitle      protocol.context_subtitle%TYPE;
        l_id_context_assoc_lang protocol.id_context_associated_language%TYPE;
        l_flg_type_recommend    protocol.flg_type_recommendation%TYPE;
        l_context_desc          protocol.context_desc%TYPE;
        l_id_content            protocol.id_content%TYPE;
    
        g_finished VARCHAR(1) := 'F';
    
        l_id_protocol_array           table_number := table_number();
        l_id_protocol_prev_vrs_array  table_number := table_number();
        l_protocol_descr_array        table_varchar := table_varchar();
        l_flg_status_array            table_varchar := table_varchar();
        l_id_ebm_array                table_number := table_number();
        l_context_title_array         table_varchar := table_varchar();
        l_context_adaptation_array    table_varchar := table_varchar();
        l_context_type_media_array    table_varchar := table_varchar();
        l_context_editor_array        table_varchar := table_varchar();
        l_context_edition_site_array  table_varchar := table_varchar();
        l_context_edition_array       table_varchar := table_varchar();
        l_dt_context_edition_array    table_varchar := table_varchar();
        l_context_access_array        table_varchar := table_varchar();
        l_id_context_lang_array       table_number := table_number();
        l_flg_context_img_array       table_varchar := table_varchar();
        l_context_subtitle_array      table_varchar := table_varchar();
        l_id_context_assoc_lang_array table_number := table_number();
        l_flg_type_recommend_array    table_varchar := table_varchar();
        l_context_desc_array          table_varchar := table_varchar();
        l_id_content_array            table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT p.id_protocol,
                            p.id_protocol_previous_version,
                            p.protocol_desc,
                            p.flg_status,
                            p.id_ebm,
                            p.context_title,
                            p.context_adaptation,
                            p.context_type_media,
                            p.context_editor,
                            p.context_edition_site,
                            p.context_edition,
                            p.dt_context_edition,
                            p.context_access,
                            p.id_context_language,
                            p.flg_context_image,
                            p.context_subtitle,
                            p.id_context_associated_language,
                            p.flg_type_recommendation,
                            to_char(p.context_desc),
                            p.id_content
              FROM alert_default.protocol p
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = p.id_protocol AND pmv.version = c_version AND pmv.id_market = c_market)
             WHERE EXISTS (SELECT 0
                      FROM alert_default.protocol_element pe
                     INNER JOIN alert_default.protocol_task pt
                        ON (pt.id_group_task = pe.id_protocol_element)
                     WHERE pe.id_protocol = p.id_protocol
                       AND pe.element_type = 'T');
    
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol
                        INTO l_id_protocol_def,
                             l_id_protocol_prev_vrs,
                             l_protocol_descr,
                             l_flg_status,
                             l_id_ebm,
                             l_context_title,
                             l_context_adaptation,
                             l_context_type_media,
                             l_context_editor,
                             l_context_edition_site,
                             l_context_edition,
                             l_dt_context_edition,
                             l_context_access,
                             l_id_context_lang,
                             l_flg_context_img,
                             l_context_subtitle,
                             l_id_context_assoc_lang,
                             l_flg_type_recommend,
                             l_context_desc,
                             l_id_content;
                    EXIT WHEN c_protocol%NOTFOUND;
                
                    g_error := 'COUNT PROTOCOL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT COUNT(p.id_protocol)
                      INTO l_count
                      FROM protocol p
                     WHERE p.id_content = (SELECT def_p.id_content
                                             FROM alert_default.protocol def_p
                                            WHERE def_p.id_content = l_id_content)
                       AND p.id_content IS NOT NULL
                       AND p.id_institution = i_id_institution
                       AND p.flg_status = g_finished;
                
                    IF l_count = 0
                    THEN
                        l_id_protocol_array.extend;
                        l_id_protocol_prev_vrs_array.extend;
                        l_protocol_descr_array.extend;
                        l_flg_status_array.extend;
                        l_id_ebm_array.extend;
                        l_context_title_array.extend;
                        l_context_adaptation_array.extend;
                        l_context_type_media_array.extend;
                        l_context_editor_array.extend;
                        l_context_edition_site_array.extend;
                        l_context_edition_array.extend;
                        l_dt_context_edition_array.extend;
                        l_context_access_array.extend;
                        l_id_context_lang_array.extend;
                        l_flg_context_img_array.extend;
                        l_context_subtitle_array.extend;
                        l_id_context_assoc_lang_array.extend;
                        l_flg_type_recommend_array.extend;
                        l_context_desc_array.extend;
                        l_id_content_array.extend;
                    
                        l_id_protocol_array(l_index) := l_id_protocol;
                        l_id_protocol_prev_vrs_array(l_index) := l_id_protocol_prev_vrs;
                        l_protocol_descr_array(l_index) := l_protocol_descr;
                        l_flg_status_array(l_index) := l_flg_status;
                        l_id_ebm_array(l_index) := l_id_ebm;
                        l_context_title_array(l_index) := l_context_title;
                        l_context_adaptation_array(l_index) := l_context_adaptation;
                        l_context_type_media_array(l_index) := l_context_type_media;
                        l_context_editor_array(l_index) := l_context_editor;
                        l_context_edition_site_array(l_index) := l_context_edition_site;
                        l_context_edition_array(l_index) := l_context_edition;
                        l_dt_context_edition_array(l_index) := l_dt_context_edition;
                        l_context_access_array(l_index) := l_context_access;
                        l_id_context_lang_array(l_index) := l_id_context_lang;
                        l_flg_context_img_array(l_index) := l_flg_context_img;
                        l_context_subtitle_array(l_index) := l_context_subtitle;
                        l_id_context_assoc_lang_array(l_index) := l_id_context_assoc_lang;
                        l_flg_type_recommend_array(l_index) := l_flg_type_recommend;
                        l_context_desc_array(l_index) := l_context_desc;
                        l_id_content_array(l_index) := l_id_content;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_PROTOCOL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE o_id_protocol CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_array AS table_number));
    
        g_error := 'CLOSE o_id_protocol_prev_vrs CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_prev_vrs FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_prev_vrs_array AS table_number));
    
        g_error := 'CLOSE o_protocol_descr CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_protocol_descr FOR
            SELECT column_value
              FROM TABLE(CAST(l_protocol_descr_array AS table_varchar));
    
        g_error := 'CLOSE o_flg_status CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_status_array AS table_varchar));
    
        g_error := 'CLOSE o_id_ebm CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_ebm FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_ebm_array AS table_number));
    
        g_error := 'CLOSE o_context_title CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_title FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_title_array AS table_varchar));
    
        g_error := 'CLOSE o_context_adaptation CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_adaptation FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_adaptation_array AS table_varchar));
    
        g_error := 'CLOSE o_context_type_media CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_type_media FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_type_media_array AS table_varchar));
    
        g_error := 'CLOSE o_context_editor CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_editor FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_editor_array AS table_varchar));
    
        g_error := 'CLOSE o_context_edition_site CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_edition_site FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_edition_site_array AS table_varchar));
    
        g_error := 'CLOSE o_context_edition CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_edition FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_edition_array AS table_varchar));
    
        g_error := 'CLOSE o_dt_context_edition CURSOR';
        OPEN o_dt_context_edition FOR
            SELECT column_value
              FROM TABLE(CAST(l_dt_context_edition_array AS table_varchar));
    
        g_error := 'CLOSE o_context_access CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_access FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_access_array AS table_varchar));
    
        g_error := 'CLOSE o_id_context_lang CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_context_lang FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_context_lang_array AS table_number));
    
        g_error := 'CLOSE o_flg_context_img CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_context_img FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_context_img_array AS table_varchar));
    
        g_error := 'CLOSE o_context_subtitle CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_subtitle FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_subtitle_array AS table_varchar));
    
        g_error := 'CLOSE o_id_context_assoc_lang CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_context_assoc_lang FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_context_assoc_lang_array AS table_number));
    
        g_error := 'CLOSE o_flg_type_recommend CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_type_recommend FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_type_recommend_array AS table_varchar));
    
        g_error := 'CLOSE o_context_desc CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_desc FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_desc_array AS table_varchar));
    
        g_error := 'CLOSE o_id_content CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_content FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_content_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
        
            pk_types.open_my_cursor(o_id_protocol);
            pk_types.open_my_cursor(o_id_protocol_prev_vrs);
            pk_types.open_my_cursor(o_context_subtitle);
            pk_types.open_my_cursor(o_protocol_descr);
            pk_types.open_my_cursor(o_flg_status);
            pk_types.open_my_cursor(o_id_ebm);
            pk_types.open_my_cursor(o_context_title);
            pk_types.open_my_cursor(o_context_adaptation);
            pk_types.open_my_cursor(o_context_type_media);
            pk_types.open_my_cursor(o_context_editor);
            pk_types.open_my_cursor(o_context_edition_site);
            pk_types.open_my_cursor(o_context_edition);
            pk_types.open_my_cursor(o_dt_context_edition);
            pk_types.open_my_cursor(o_context_access);
            pk_types.open_my_cursor(o_id_context_lang);
            pk_types.open_my_cursor(o_flg_context_img);
            pk_types.open_my_cursor(o_context_subtitle);
            pk_types.open_my_cursor(o_id_context_assoc_lang);
            pk_types.open_my_cursor(o_flg_type_recommend);
            pk_types.open_my_cursor(o_context_desc);
            pk_types.open_my_cursor(o_id_content);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol;
    /*********************************************************************************************
    * Set protocol for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_protocol      Cursor of Instituition protocol
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/20
    ********************************************************************************************/
    FUNCTION set_inst_protocol
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_protocol  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_protocol           pk_types.cursor_type;
        l_c_id_protocol_prev_vrs  pk_types.cursor_type;
        l_c_protocol_descr        pk_types.cursor_type;
        l_c_flg_status            pk_types.cursor_type;
        l_c_id_ebm                pk_types.cursor_type;
        l_c_context_title         pk_types.cursor_type;
        l_c_context_adaptation    pk_types.cursor_type;
        l_c_context_type_media    pk_types.cursor_type;
        l_c_context_editor        pk_types.cursor_type;
        l_c_context_edition_site  pk_types.cursor_type;
        l_c_context_edition       pk_types.cursor_type;
        l_c_dt_context_edition    pk_types.cursor_type;
        l_c_context_access        pk_types.cursor_type;
        l_c_id_context_lang       pk_types.cursor_type;
        l_c_flg_context_img       pk_types.cursor_type;
        l_c_context_subtitle      pk_types.cursor_type;
        l_c_id_context_assoc_lang pk_types.cursor_type;
        l_c_flg_type_recommend    pk_types.cursor_type;
        l_c_context_desc          pk_types.cursor_type;
        l_c_id_content            pk_types.cursor_type;
    
        l_data_id_protocol           table_number;
        l_data_id_protocol_prev_vrs  table_number;
        l_data_protocol_descr        table_varchar;
        l_data_flg_status            table_varchar;
        l_data_id_ebm                table_number;
        l_data_context_title         table_varchar;
        l_data_context_adaptation    table_varchar;
        l_data_context_type_media    table_varchar;
        l_data_context_editor        table_varchar;
        l_data_context_edition_site  table_varchar;
        l_data_context_edition       table_varchar;
        l_data_dt_context_edition    table_varchar;
        l_data_context_access        table_varchar;
        l_data_id_context_lang       table_number;
        l_data_flg_context_img       table_varchar;
        l_data_context_subtitle      table_varchar;
        l_data_id_context_assoc_lang table_number;
        l_data_flg_type_recommend    table_varchar;
        l_data_context_desc          table_varchar;
        l_data_id_content            table_varchar;
    
        --Call all SET Protocol functions
        l_c_protocol_link          pk_types.cursor_type;
        l_c_protocol_element       pk_types.cursor_type;
        l_c_protocol_criteria      pk_types.cursor_type;
        l_c_protocol_criteria_link pk_types.cursor_type;
        l_c_protocol_adv_input     pk_types.cursor_type;
        l_c_protocol_context_auth  pk_types.cursor_type;
        l_c_protocol_context_img   pk_types.cursor_type;
        l_c_protocol_relation      pk_types.cursor_type;
        l_c_protocol_frequent      pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT GET_INST_PROTOCOL';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL ' || g_error);
        
            IF NOT get_inst_protocol(i_lang,
                                     i_market,
                                     i_version,
                                     i_id_institution,
                                     i_software(i),
                                     l_c_id_protocol,
                                     l_c_id_protocol_prev_vrs,
                                     l_c_protocol_descr,
                                     l_c_flg_status,
                                     l_c_id_ebm,
                                     l_c_context_title,
                                     l_c_context_adaptation,
                                     l_c_context_type_media,
                                     l_c_context_editor,
                                     l_c_context_edition_site,
                                     l_c_context_edition,
                                     l_c_dt_context_edition,
                                     l_c_context_access,
                                     l_c_id_context_lang,
                                     l_c_flg_context_img,
                                     l_c_context_subtitle,
                                     l_c_id_context_assoc_lang,
                                     l_c_flg_type_recommend,
                                     l_c_context_desc,
                                     l_c_id_content,
                                     l_error)
            
            THEN
                RAISE l_exception;
            ELSE
                o_inst_protocol := l_c_id_protocol;
                LOOP
                    FETCH l_c_id_protocol BULK COLLECT
                        INTO l_data_id_protocol LIMIT g_array_size;
                
                    FETCH l_c_id_protocol_prev_vrs BULK COLLECT
                        INTO l_data_id_protocol_prev_vrs LIMIT g_array_size;
                
                    FETCH l_c_protocol_descr BULK COLLECT
                        INTO l_data_protocol_descr LIMIT g_array_size;
                
                    FETCH l_c_flg_status BULK COLLECT
                        INTO l_data_flg_status LIMIT g_array_size;
                
                    FETCH l_c_id_ebm BULK COLLECT
                        INTO l_data_id_ebm LIMIT g_array_size;
                
                    FETCH l_c_context_title BULK COLLECT
                        INTO l_data_context_title LIMIT g_array_size;
                
                    FETCH l_c_context_adaptation BULK COLLECT
                        INTO l_data_context_adaptation LIMIT g_array_size;
                
                    FETCH l_c_context_type_media BULK COLLECT
                        INTO l_data_context_type_media LIMIT g_array_size;
                
                    FETCH l_c_context_editor BULK COLLECT
                        INTO l_data_context_editor LIMIT g_array_size;
                
                    FETCH l_c_context_edition_site BULK COLLECT
                        INTO l_data_context_edition_site LIMIT g_array_size;
                
                    FETCH l_c_context_edition BULK COLLECT
                        INTO l_data_context_edition LIMIT g_array_size;
                
                    FETCH l_c_dt_context_edition BULK COLLECT
                        INTO l_data_dt_context_edition LIMIT g_array_size;
                
                    FETCH l_c_context_access BULK COLLECT
                        INTO l_data_context_access LIMIT g_array_size;
                
                    FETCH l_c_id_context_lang BULK COLLECT
                        INTO l_data_id_context_lang LIMIT g_array_size;
                
                    FETCH l_c_flg_context_img BULK COLLECT
                        INTO l_data_flg_context_img LIMIT g_array_size;
                
                    FETCH l_c_context_subtitle BULK COLLECT
                        INTO l_data_context_subtitle LIMIT g_array_size;
                
                    FETCH l_c_id_context_assoc_lang BULK COLLECT
                        INTO l_data_id_context_assoc_lang LIMIT g_array_size;
                
                    FETCH l_c_flg_type_recommend BULK COLLECT
                        INTO l_data_flg_type_recommend LIMIT g_array_size;
                
                    FETCH l_c_context_desc BULK COLLECT
                        INTO l_data_context_desc LIMIT g_array_size;
                
                    FETCH l_c_id_content BULK COLLECT
                        INTO l_data_id_content LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL (' || 'seq_protocol.nextval' || ', ' ||
                                   l_data_id_protocol_prev_vrs(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL ' || g_error);
                    
                        INSERT INTO protocol
                            (id_protocol,
                             id_protocol_previous_version,
                             protocol_desc,
                             dt_protocol,
                             flg_status,
                             id_ebm,
                             context_title,
                             context_adaptation,
                             context_type_media,
                             context_editor,
                             context_edition_site,
                             context_edition,
                             dt_context_edition,
                             context_access,
                             id_context_language,
                             flg_context_image,
                             context_subtitle,
                             id_context_associated_language,
                             id_professional,
                             id_institution,
                             id_software,
                             id_prof_cancel,
                             dt_cancel,
                             flg_type_recommendation,
                             adw_last_update,
                             context_desc,
                             id_content)
                        VALUES
                            (seq_protocol.nextval,
                             l_data_id_protocol_prev_vrs(j),
                             l_data_protocol_descr(j),
                             NULL,
                             l_data_flg_status(j),
                             l_data_id_ebm(j),
                             l_data_context_title(j),
                             l_data_context_adaptation(j),
                             l_data_context_type_media(j),
                             l_data_context_editor(j),
                             l_data_context_edition_site(j),
                             l_data_context_edition(j),
                             l_data_dt_context_edition(j),
                             l_data_context_access(j),
                             l_data_id_context_lang(j),
                             l_data_flg_context_img(j),
                             l_data_context_subtitle(j),
                             l_data_id_context_assoc_lang(j),
                             NULL,
                             i_id_institution,
                             i_software(i),
                             NULL,
                             NULL,
                             l_data_flg_type_recommend(j),
                             SYSDATE,
                             l_data_context_desc(j),
                             l_data_id_content(j));
                    END LOOP;
                
                    EXIT WHEN l_c_id_protocol%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_id_protocol;
                CLOSE l_c_id_protocol_prev_vrs;
                CLOSE l_c_protocol_descr;
                CLOSE l_c_flg_status;
                CLOSE l_c_id_ebm;
                CLOSE l_c_context_title;
                CLOSE l_c_context_adaptation;
                CLOSE l_c_context_type_media;
                CLOSE l_c_context_editor;
                CLOSE l_c_context_edition_site;
                CLOSE l_c_context_edition;
                CLOSE l_c_dt_context_edition;
                CLOSE l_c_context_access;
                CLOSE l_c_id_context_lang;
                CLOSE l_c_flg_context_img;
                CLOSE l_c_context_subtitle;
                CLOSE l_c_id_context_assoc_lang;
                CLOSE l_c_flg_type_recommend;
                CLOSE l_c_context_desc;
                CLOSE l_c_id_content;
            
            END IF;
        END LOOP;
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'SET PROTOCOL_LINK';
                IF NOT set_inst_protocol_link(i_lang,
                                              table_number(i_market(j)),
                                              table_varchar(i_version(i)),
                                              i_id_institution,
                                              i_software,
                                              l_c_protocol_link,
                                              l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_ELEMENT';
                IF NOT set_inst_protocol_element(i_lang,
                                                 table_number(i_market(j)),
                                                 table_varchar(i_version(i)),
                                                 i_id_institution,
                                                 i_software,
                                                 l_c_protocol_element,
                                                 l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_TASK';
                IF NOT set_inst_protocol_task(i_lang,
                                              table_number(i_market(j)),
                                              table_varchar(i_version(i)),
                                              i_id_institution,
                                              i_software,
                                              l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_CRITERIA';
                IF NOT set_inst_protocol_criteria(i_lang,
                                                  table_number(i_market(j)),
                                                  table_varchar(i_version(i)),
                                                  i_id_institution,
                                                  i_software,
                                                  l_c_protocol_criteria,
                                                  l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_CRITERIA_LINK';
                IF NOT set_inst_protocol_crit_link(i_lang,
                                                   table_number(i_market(j)),
                                                   table_varchar(i_version(i)),
                                                   i_id_institution,
                                                   i_software,
                                                   l_c_protocol_criteria_link,
                                                   l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_ADV_INPUT_VALUE';
                IF NOT set_inst_prtcl_adv_input_value(i_lang,
                                                      table_number(i_market(j)),
                                                      table_varchar(i_version(i)),
                                                      i_software,
                                                      l_c_protocol_adv_input,
                                                      l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_CONTEXT_AUTH';
                IF NOT set_inst_protocol_context_auth(i_lang,
                                                      table_number(i_market(j)),
                                                      table_varchar(i_version(i)),
                                                      i_id_institution,
                                                      i_software,
                                                      l_c_protocol_context_auth,
                                                      l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_CONTEXT_IMG';
                IF NOT set_inst_protocol_context_img(i_lang,
                                                     table_number(i_market(j)),
                                                     table_varchar(i_version(i)),
                                                     i_id_institution,
                                                     i_software,
                                                     l_c_protocol_context_img,
                                                     l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_RELATION';
                IF NOT set_inst_protocol_relation(i_lang,
                                                  table_number(i_market(j)),
                                                  table_varchar(i_version(i)),
                                                  i_id_institution,
                                                  i_software,
                                                  l_c_protocol_relation,
                                                  l_error)
                THEN
                    RAISE l_exception;
                END IF;
                g_error := 'SET PROTOCOL_FREQUENT';
                IF NOT set_inst_protocol_frequent(i_lang,
                                                  table_number(i_market(j)),
                                                  table_varchar(i_version(i)),
                                                  i_id_institution,
                                                  i_software,
                                                  l_c_protocol_frequent,
                                                  l_error)
                THEN
                    RAISE l_exception;
                END IF;
            END LOOP;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_PROTOCOL',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_PROTOCOL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_protocol;
    /********************************************************************************************
    * Get protocol link set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_id_protocol         Cursor of Protocol
    * @param o_id_link             Cursor of flags
    * @param o_link_type           Cursor of Link Type
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/20
    ********************************************************************************************/
    FUNCTION get_inst_protocol_link
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_protocol    OUT pk_types.cursor_type,
        o_id_link        OUT pk_types.cursor_type,
        o_link_type      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol_def protocol_link.id_protocol%TYPE := NULL;
        l_id_protocol     protocol_link.id_protocol%TYPE := NULL;
        l_link_type_def   protocol_link.link_type%TYPE := NULL;
        l_id_content_def  protocol.id_content%TYPE := NULL;
        l_id_link_def     protocol_link.id_link%TYPE := NULL;
    
        l_id_protocol_array table_number := table_number();
        l_link_type_array   table_varchar := table_varchar();
        l_id_link_array     table_number := table_number();
    
        l_detp_array table_number := table_number();
        l_temp_prot  protocol.id_protocol%TYPE := 0;
    
        l_dept_index       NUMBER := 1;
        l_count_spec       NUMBER := 0;
        l_count_cs         NUMBER := 0;
        l_count_dept       NUMBER := 0;
        l_count_diag       NUMBER := 0;
        l_count_prtcl_type NUMBER := 0;
        l_index            NUMBER := 1;
    
        l_id_clin_serv_def clinical_service.id_content%TYPE := NULL;
        l_id_clin_serv     clinical_service.id_clinical_service%TYPE := NULL;
        l_id_diagnosis     diagnosis.id_diagnosis%TYPE := NULL;
        l_id_speciality    speciality.id_speciality%TYPE := NULL;
    
        l_exception EXCEPTION;
    
        l_tab_diagnosis table_number := table_number();
    
        l_id_dept dept.id_dept%TYPE;
        l_var_s   VARCHAR2(1) := pk_protocol.g_protocol_link_spec;
        l_var_e   VARCHAR2(1) := pk_protocol.g_protocol_link_envi;
        l_var_t   VARCHAR2(1) := pk_protocol.g_protocol_link_type;
        l_var_h   VARCHAR2(1) := pk_protocol.g_protocol_link_pathol;
        l_var_p   VARCHAR2(1) := pk_protocol.g_protocol_link_prof;
        l_var_c   VARCHAR2(1) := pk_protocol.g_protocol_link_chief_compl;
    
        CURSOR c_protocol_link
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT pl.id_protocol, p.id_content, pl.id_link, pl.link_type
              FROM alert_default.protocol_link pl
              JOIN alert_default.protocol p
                ON (p.id_protocol = pl.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pl.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version)
             ORDER BY pl.id_protocol;
    
        CURSOR c_software_dept
        (
            c_id_software    IN software.id_software%TYPE,
            c_id_institution IN institution.id_institution%TYPE,
            c_depts          IN table_number
        ) IS
            SELECT DISTINCT t.id_dept
              FROM software_dept sd, dept t
             WHERE sd.id_software = c_id_software
               AND sd.id_dept = t.id_dept
               AND t.id_institution = c_id_institution
               AND t.flg_available = g_yes
               AND t.id_dept NOT IN (SELECT nvl(column_value, 0)
                                       FROM TABLE(CAST(c_depts AS table_number)))
               AND rownum = 1;
    
        CURSOR c_clinical_service(c_id_link IN protocol_link.id_link%TYPE) IS
            SELECT cs.id_content
              FROM alert_default.clinical_service cs
             WHERE cs.flg_available = g_yes
               AND cs.id_clinical_service IN
                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                     column_value
                      FROM TABLE(CAST(pk_backoffice_default.check_clinical_service_parent(i_lang, c_id_link) AS
                                      table_number)) p);
    
        CURSOR c_diagnosis
        (
            c_id_software           IN software.id_software%TYPE,
            c_id_institution        IN institution.id_institution%TYPE,
            c_id_link               IN protocol_link.id_link%TYPE,
            c_id_software_config    IN software.id_software%TYPE,
            c_id_institution_config IN institution.id_institution%TYPE
        ) IS
            SELECT DISTINCT d.id_diagnosis
              FROM diagnosis_content d
             WHERE d.id_software = c_id_software
               AND d.flg_type_dep_clin = pk_diagnosis.g_diag_pesq
               AND d.id_institution = c_id_institution
               AND d.id_diagnosis = c_id_link;
    
        CURSOR c_protocol
        (
            c_id_protocol IN protocol_link.id_protocol%TYPE,
            c_id_link     IN protocol_link.id_link%TYPE,
            c_link_type   IN protocol_link.link_type%TYPE
        ) IS
            SELECT COUNT(pl.id_protocol)
              FROM protocol_link pl
             WHERE pl.id_protocol = c_id_protocol
               AND pl.id_link = c_id_link
               AND pl.link_type = c_link_type;
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_LINK ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_link(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_link
                        INTO l_id_protocol_def, l_id_content_def, l_id_link_def, l_link_type_def;
                    EXIT WHEN c_protocol_link%NOTFOUND;
                
                    SELECT nvl((SELECT p.id_protocol
                                 FROM protocol p
                                WHERE p.id_content = l_id_content_def
                                  AND p.id_content IS NOT NULL
                                  AND p.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_protocol
                      FROM dual;
                
                    IF l_id_protocol != 0
                    THEN
                        IF l_temp_prot != l_id_protocol
                        THEN
                            l_temp_prot  := l_id_protocol;
                            l_detp_array := table_number();
                            l_dept_index := 1;
                        END IF;
                        IF l_link_type_def = l_var_c
                        THEN
                            g_error := 'L_LINK_TYPE_DEF ' || l_id_link_def || '/' || l_id_protocol;
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            SELECT COUNT(pl.id_protocol)
                              INTO l_count_spec
                              FROM protocol_link pl
                              JOIN complaint c
                                ON (c.id_complaint = pl.id_link)
                             WHERE pl.id_protocol = l_id_protocol
                               AND pl.id_link = l_id_link_def
                               AND pl.link_type = l_link_type_def;
                        
                            IF l_count_spec = 0
                            THEN
                                g_error := 'IF L_COUNT_SPEC = 0';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                l_id_protocol_array.extend;
                                l_id_link_array.extend;
                                l_link_type_array.extend;
                            
                                l_id_protocol_array(l_index) := l_id_protocol;
                                l_link_type_array(l_index) := l_link_type_def;
                                l_id_link_array(l_index) := l_id_link_def;
                            
                                l_index := l_index + 1;
                            END IF;
                        ELSIF l_link_type_def = l_var_p
                        THEN
                        
                            g_error := 'L_LINK_TYPE_DEF ' || l_id_link_def || '/' || l_id_protocol;
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            SELECT COUNT(p.id_protocol)
                              INTO l_count_spec
                              FROM protocol_link p
                              JOIN category c
                                ON (c.id_category = p.id_link)
                             WHERE p.id_protocol = l_id_protocol
                               AND p.id_link = l_id_link_def
                               AND p.link_type = l_link_type_def;
                        
                            IF l_count_spec = 0
                            THEN
                                g_error := 'IF L_COUNT_SPEC = 0';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                l_id_protocol_array.extend;
                                l_id_link_array.extend;
                                l_link_type_array.extend;
                            
                                l_id_protocol_array(l_index) := l_id_protocol;
                                l_link_type_array(l_index) := l_link_type_def;
                                l_id_link_array(l_index) := l_id_link_def;
                            
                                l_index := l_index + 1;
                            END IF;
                        
                        ELSIF l_link_type_def = l_var_s
                        THEN
                            --> by Speciality (PFH)
                            IF i_id_software != pk_alert_constant.g_soft_primary_care
                            THEN
                                g_error := 'GET SPECIALITY_ID';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT s.id_speciality
                                             FROM speciality s
                                            WHERE s.id_content =
                                                  (SELECT sd.id_content
                                                     FROM alert_default.speciality sd
                                                    WHERE sd.id_speciality = l_id_link_def)
                                              AND s.id_content IS NOT NULL
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_speciality
                                  FROM dual;
                            
                                IF l_id_speciality != 0
                                THEN
                                
                                    g_error := 'l_count_spec';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT COUNT(pl.id_protocol)
                                      INTO l_count_spec
                                      FROM protocol_link pl
                                      JOIN speciality s
                                        ON (s.id_speciality = pl.id_link)
                                     WHERE pl.id_protocol = l_id_protocol
                                       AND pl.id_link = l_id_speciality
                                       AND pl.link_type = l_link_type_def;
                                
                                    IF l_count_spec = 0
                                    THEN
                                        g_error := 'IF l_count_spec = 0';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        l_id_protocol_array.extend;
                                        l_id_link_array.extend;
                                        l_link_type_array.extend;
                                    
                                        l_id_protocol_array(l_index) := l_id_protocol;
                                        l_link_type_array(l_index) := l_link_type_def;
                                        l_id_link_array(l_index) := l_id_speciality;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END IF;
                                --> by Clinical_Service (CARE)
                            ELSE
                                g_error := 'OPEN C_CLINICAL_SERVICE CURSOR';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                OPEN c_clinical_service(l_id_link_def);
                                LOOP
                                    FETCH c_clinical_service
                                        INTO l_id_clin_serv_def;
                                    EXIT WHEN c_clinical_service%NOTFOUND;
                                
                                    g_error := 'GET_CLINICAL_SERVICE_ID';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT nvl((SELECT cs.id_clinical_service
                                                 FROM clinical_service cs
                                                WHERE cs.id_content = l_id_clin_serv_def
                                                  AND cs.id_content IS NOT NULL
                                                  AND cs.flg_available = g_yes
                                                  AND rownum = 1),
                                               0)
                                      INTO l_id_clin_serv
                                      FROM dual;
                                
                                    IF l_id_clin_serv != 0
                                    THEN
                                        g_error := 'OPEN C_PROTOCOL';
                                        OPEN c_protocol(c_id_protocol => l_id_protocol,
                                                        c_id_link     => l_id_clin_serv,
                                                        c_link_type   => l_link_type_def);
                                        FETCH c_protocol
                                            INTO l_count_cs;
                                        CLOSE c_protocol;
                                    
                                        IF l_count_cs = 0
                                        THEN
                                            l_id_protocol_array.extend;
                                            l_link_type_array.extend;
                                            l_id_link_array.extend;
                                        
                                            l_id_protocol_array(l_index) := l_id_protocol;
                                            l_link_type_array(l_index) := l_link_type_def;
                                            l_id_link_array(l_index) := l_id_clin_serv;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                
                                END LOOP;
                                g_error := 'CLOSE C_CLINICAL_SERVICE CURSOR';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                CLOSE c_clinical_service;
                            END IF;
                        
                        ELSIF l_link_type_def = l_var_e
                        THEN
                            --> by DEPT    
                            g_error := 'OPEN C_SOFTWARE_DEPT CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            OPEN c_software_dept(l_id_link_def, i_id_institution, l_detp_array);
                            LOOP
                                FETCH c_software_dept
                                    INTO l_id_dept;
                                EXIT WHEN c_software_dept%NOTFOUND;
                            
                                IF l_id_dept IS NOT NULL
                                THEN
                                    l_detp_array.extend;
                                    l_detp_array(l_dept_index) := l_id_dept;
                                    l_dept_index := l_dept_index + 1;
                                
                                    g_error := 'l_count_dept';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    OPEN c_protocol(c_id_protocol => l_id_protocol,
                                                    c_id_link     => l_id_dept,
                                                    c_link_type   => l_link_type_def);
                                    FETCH c_protocol
                                        INTO l_count_dept;
                                    CLOSE c_protocol;
                                
                                    IF l_count_dept = 0
                                    THEN
                                        l_id_protocol_array.extend;
                                        l_link_type_array.extend;
                                        l_id_link_array.extend;
                                    
                                        l_id_protocol_array(l_index) := l_id_protocol;
                                        l_link_type_array(l_index) := l_link_type_def;
                                        l_id_link_array(l_index) := l_id_dept;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_SOFTWARE_DEPT CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_software_dept;
                        
                        ELSIF l_link_type_def = l_var_h
                        --> by Diagnosis
                        THEN
                        
                            g_error := 'GET ID_DIAGNOSIS ' || l_id_link_def;
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            -- ID_CONTENT NOT SUPPORTED IN DIAGNOSIS
                            l_id_diagnosis := 0;
                        
                            IF l_id_diagnosis != 0
                            THEN
                            
                                g_error := 'OPEN C_DIAGNOSIS ' || l_id_diagnosis;
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                OPEN c_diagnosis(i_id_software,
                                                 i_id_institution,
                                                 l_id_diagnosis,
                                                 i_id_software,
                                                 i_id_institution);
                                FETCH c_diagnosis BULK COLLECT
                                    INTO l_tab_diagnosis;
                                CLOSE c_diagnosis;
                            
                                IF l_tab_diagnosis.count = 0
                                THEN
                                    g_error := 'OPEN C_DIAGNOSIS [0 0]';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    OPEN c_diagnosis(i_id_software, i_id_institution, l_id_link_def, 0, 0);
                                    FETCH c_diagnosis BULK COLLECT
                                        INTO l_tab_diagnosis;
                                    CLOSE c_diagnosis;
                                END IF;
                            
                                FOR i IN 1 .. l_tab_diagnosis.count
                                LOOP
                                    g_error := 'COUNT_DIAGNOSIS ' || l_tab_diagnosis(i) || '/' || l_id_protocol;
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    OPEN c_protocol(c_id_protocol => l_id_protocol,
                                                    c_id_link     => l_tab_diagnosis(i),
                                                    c_link_type   => l_link_type_def);
                                    FETCH c_protocol
                                        INTO l_count_diag;
                                    CLOSE c_protocol;
                                
                                    IF l_count_diag = 0
                                    THEN
                                        g_error := 'NEW ' || l_tab_diagnosis(i) || '/' || l_id_protocol;
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        l_id_protocol_array.extend;
                                        l_link_type_array.extend;
                                        l_id_link_array.extend;
                                    
                                        l_id_protocol_array(l_index) := l_id_protocol;
                                        l_link_type_array(l_index) := l_link_type_def;
                                        l_id_link_array(l_index) := l_id_diagnosis;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END LOOP;
                            END IF;
                        ELSIF l_link_type_def = l_var_t
                        --> by Protocol Type
                        THEN
                            g_error := 'l_count_prtcl_type';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            SELECT COUNT(pl.id_protocol)
                              INTO l_count_prtcl_type
                              FROM protocol_link pl
                              JOIN protocol_type pt
                                ON (pt.id_protocol_type = pl.id_link AND pt.flg_available = g_yes AND
                                   pt.id_protocol_type = l_id_link_def)
                             WHERE pl.id_protocol = l_id_protocol
                               AND pl.link_type = l_link_type_def;
                        
                            IF l_count_prtcl_type = 0
                            THEN
                            
                                l_id_protocol_array.extend;
                                l_link_type_array.extend;
                                l_id_link_array.extend;
                            
                                l_id_protocol_array(l_index) := l_id_protocol;
                                l_link_type_array(l_index) := l_link_type_def;
                                l_id_link_array(l_index) := l_id_link_def;
                            
                                l_index := l_index + 1;
                            END IF;
                        
                        END IF;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_link;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_array AS table_number));
    
        g_error := 'CLOSE O_ID_LINK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_link FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_link_array AS table_number));
    
        g_error := 'CLOSE O_LINK_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_link_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_link_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol);
            pk_types.open_my_cursor(o_id_link);
            pk_types.open_my_cursor(o_link_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_link;
    /*********************************************************************************************
    * Set Protocol link for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_protocol_link       Cursor of Instituition Protocol_Link
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/26
    ********************************************************************************************/
    FUNCTION set_inst_protocol_link
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_protocol_link  OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_protocol pk_types.cursor_type;
        l_c_id_link     pk_types.cursor_type;
        l_c_link_type   pk_types.cursor_type;
    
        l_data_id_protocol table_number;
        l_data_id_link     table_number;
        l_data_link_type   table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_LINK ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_LINK';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_protocol_link(i_lang,
                                          i_market,
                                          i_version,
                                          i_id_institution,
                                          i_software(i),
                                          l_c_id_protocol,
                                          l_c_id_link,
                                          l_c_link_type,
                                          o_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'o_protocol_link := l_c_id_protocol';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_protocol_link := l_c_id_protocol;
            
                LOOP
                
                    FETCH l_c_id_protocol BULK COLLECT
                        INTO l_data_id_protocol LIMIT g_array_size;
                
                    FETCH l_c_id_link BULK COLLECT
                        INTO l_data_id_link LIMIT g_array_size;
                
                    FETCH l_c_link_type BULK COLLECT
                        INTO l_data_link_type LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_LINK (seq_protocol_link.NEXTVAL,' || l_data_id_protocol(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_link
                            (id_protocol_link, id_protocol, id_link, link_type)
                        VALUES
                            (seq_protocol_link.nextval, l_data_id_protocol(j), l_data_id_link(j), l_data_link_type(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol%NOTFOUND;
                
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol;
                g_error := 'CLOSE L_C_ID_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_link;
                g_error := 'CLOSE L_C_LINK_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_link_type;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_link;
    /********************************************************************************************
    * Get Protocol Questions set by Protocol
    *
    * @param i_lang                         Prefered language ID
    * @param i_id_protocol                  Protocol ID   
    * @param o_id_protocol_question         Cursor of Protocol Question
    * @param o_descr_question               Cursor of Question Description  
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/04/20
    ********************************************************************************************/
    FUNCTION get_inst_protocol_question
    (
        i_lang                 IN language.id_language%TYPE,
        i_id_protocol_def      IN protocol_element.id_protocol%TYPE,
        o_id_protocol_question OUT pk_types.cursor_type,
        o_descr_question       OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol_question protocol_question.id_protocol_question%TYPE := NULL;
        l_descr_question       protocol_question.desc_protocol_question%TYPE := NULL;
    
        l_id_protocol_question_array table_number := table_number();
        l_descr_question_array       table_varchar := table_varchar();
    
        l_var_q VARCHAR2(1) := pk_protocol.g_element_question;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_question(c_id_protocol IN protocol_element.id_protocol%TYPE) IS
            SELECT DISTINCT pq.id_protocol_question, pq.desc_protocol_question
              FROM alert_default.protocol_question pq
              JOIN alert_default.protocol_element pe
                ON (pe.id_element = pq.id_protocol_question AND pe.element_type = l_var_q)
             WHERE pe.id_protocol = c_id_protocol;
    
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_QUESTION ';
    
        g_error := 'OPEN C_PROTOCOL_QUESTION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN c_protocol_question(i_id_protocol_def);
        LOOP
            FETCH c_protocol_question
                INTO l_id_protocol_question, l_descr_question;
            EXIT WHEN c_protocol_question%NOTFOUND;
        
            g_error := 'l_count_question';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            SELECT COUNT(pq.id_protocol_question)
              INTO l_count
              FROM protocol_question pq
             WHERE pq.id_protocol_question = l_id_protocol_question;
        
            g_error := 'IF l_count_question = 0';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF l_count = 0
            THEN
                l_id_protocol_question_array.extend;
                l_descr_question_array.extend;
            
                l_id_protocol_question_array(l_index) := l_id_protocol_question;
                l_descr_question_array(l_index) := l_descr_question;
            
                l_index := l_index + 1;
            END IF;
        
        END LOOP;
        g_error := 'CLOSE C_PROTOCOL_QUESTION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        CLOSE c_protocol_question;
    
        g_error := 'CLOSE O_ID_PROTOCOL_QUESTION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_question FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_question_array AS table_number));
    
        g_error := 'CLOSE O_DESCR_QUESTION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_descr_question FOR
            SELECT column_value
              FROM TABLE(CAST(l_descr_question_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol_question);
            pk_types.open_my_cursor(o_descr_question);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_question;
    /********************************************************************************************
    * Get Protocol Protocol set by Protocol
    *
    * @param i_lang                         Prefered language ID
    * @param i_id_protocol                  Protocol ID   
    * @param o_id_protocol_protocol         Cursor of Protocol Question
    * @param o_descr_question               Cursor of Protocol Description  
    * @param o_id_nested_protocol           Cursor of Nested Protocol
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/04/20
    ********************************************************************************************/
    FUNCTION get_inst_protocol_protocol
    (
        i_lang                 IN language.id_language%TYPE,
        i_id_protocol          IN protocol_element.id_protocol%TYPE,
        o_id_protocol_protocol OUT pk_types.cursor_type,
        o_descr_protocol       OUT pk_types.cursor_type,
        o_id_nested_protocol   OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_protocol_protocol protocol_protocol.id_protocol_protocol%TYPE := NULL;
        l_descr_protocol       protocol_protocol.desc_protocol_protocol%TYPE := NULL;
        l_id_nested_protocol   protocol_protocol.id_nested_protocol%TYPE := NULL;
    
        l_id_protocol protocol.id_protocol%TYPE := NULL;
    
        l_id_protocol_protocol_array table_number := table_number();
        l_descr_protocol_array       table_varchar := table_varchar();
        l_id_nested_protocol_array   table_number := table_number();
    
        l_var_p VARCHAR2(1) := pk_protocol.g_element_protocol;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_protocol(c_id_protocol IN protocol_element.id_protocol%TYPE) IS
            SELECT DISTINCT pp.id_protocol_protocol, pp.desc_protocol_protocol, pp.id_nested_protocol
              FROM alert_default.protocol_protocol pp
              JOIN alert_default.protocol_element pe
                ON (pe.id_element = pp.id_protocol_protocol AND pe.element_type = l_var_p)
             WHERE pe.id_protocol = c_id_protocol;
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_PROTOCOL ';
    
        --> by Protocol_Protocol
        g_error := 'OPEN C_PROTOCOL_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN c_protocol_protocol(i_id_protocol);
        LOOP
            FETCH c_protocol_protocol
                INTO l_id_protocol_protocol, l_descr_protocol, l_id_nested_protocol;
            EXIT WHEN c_protocol_protocol%NOTFOUND;
        
            SELECT nvl((SELECT t.id_protocol
                         FROM protocol t
                        WHERE t.id_content = (SELECT p.id_content
                                                FROM alert_default.protocol p
                                               WHERE p.id_protocol = l_id_nested_protocol)
                          AND rownum = 1),
                       0)
              INTO l_id_protocol
              FROM dual;
        
            g_error := 'l_count_protocol';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            SELECT COUNT(pp.id_protocol_protocol)
              INTO l_count
              FROM protocol_protocol pp
             WHERE pp.id_protocol_protocol = l_id_protocol_protocol;
        
            g_error := 'IF l_count_protocol = 0';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF l_count = 0
            THEN
            
                l_id_protocol_protocol_array.extend;
                l_descr_protocol_array.extend;
                l_id_nested_protocol_array.extend;
                l_id_protocol_protocol_array(l_index) := l_id_protocol_protocol;
                l_descr_protocol_array(l_index) := l_descr_protocol;
                l_id_nested_protocol_array(l_index) := l_id_protocol;
            
                l_index := l_index + 1;
            END IF;
        
        END LOOP;
        g_error := 'CLOSE C_PROTOCOL_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        CLOSE c_protocol_protocol;
    
        g_error := 'CLOSE O_ID_PROTOCOL_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_protocol_array AS table_number));
    
        g_error := 'CLOSE O_DESCR_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_descr_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_descr_protocol_array AS table_varchar));
    
        g_error := 'CLOSE O_ID_NESTED_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_nested_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_nested_protocol_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol_protocol);
            pk_types.open_my_cursor(o_descr_protocol);
            pk_types.open_my_cursor(o_id_nested_protocol);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_protocol;
    /********************************************************************************************
    * Get Protocol Task set by Protocol
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID   
    * @param i_version                      Version   
    * @param i_id_institution               Institution ID   
    * @param i_id_software                  Software ID                   
    * @param o_id_protocol_task             Cursor of Protocol Task
    * @param o_id_group_task                Cursor of Group Task ID
    * @param o_descr_protocol_task          Cursor of Task Description
    * @param o_id_task_link                 Cursor of Task Link
    * @param o_task_type                    Cursor of Task Type
    * @param o_task_notes                   Cursor of Task Notes
    * @param o_id_task_attach               Cursor of Task Attach
    * @param o_task_codif                   Cursor of Task Codificaton
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/03
    ********************************************************************************************/
    FUNCTION get_inst_protocol_task
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN table_number,
        i_version             IN table_varchar,
        i_id_institution      IN institution.id_institution%TYPE,
        i_id_software         IN software.id_software%TYPE,
        o_id_protocol_task    OUT pk_types.cursor_type,
        o_id_group_task       OUT pk_types.cursor_type,
        o_descr_protocol_task OUT pk_types.cursor_type,
        o_id_task_link        OUT pk_types.cursor_type,
        o_task_type           OUT pk_types.cursor_type,
        o_task_notes          OUT pk_types.cursor_type,
        o_id_task_attach      OUT pk_types.cursor_type,
        o_task_codif          OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol_def     protocol_element.id_protocol%TYPE := NULL;
        l_id_protocol         protocol_element.id_protocol%TYPE := NULL;
        l_id_content_def      protocol.id_content%TYPE := NULL;
        l_id_protocol_task    protocol_task.id_protocol_task%TYPE := NULL;
        l_id_group_task       protocol_task.id_group_task%TYPE := NULL;
        l_descr_protocol_task protocol_task.desc_protocol_task%TYPE := NULL;
        l_id_task_link        protocol_task.id_task_link%TYPE := NULL;
        l_task_type           protocol_task.task_type%TYPE := NULL;
        l_task_notes          protocol_task.task_notes%TYPE := NULL;
        l_id_task_attach      protocol_task.id_task_attach%TYPE := NULL;
        l_task_codif          protocol_task.task_codification%TYPE := NULL;
    
        l_id_protocol_task_array    table_number := table_number();
        l_id_group_task_array       table_number := table_number();
        l_descr_protocol_task_array table_varchar := table_varchar();
        l_id_task_link_array        table_number := table_number();
        l_task_type_array           table_number := table_number();
        l_task_notes_array          table_varchar := table_varchar();
        l_id_task_attach_array      table_number := table_number();
        l_task_codif_array          table_number := table_number();
    
        l_var_t VARCHAR2(1) := pk_protocol.g_element_task;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        --> Tasks Types
        l_var_analysis       NUMBER := pk_protocol.g_task_analysis; -- Analises := 1;
        l_var_appoint        NUMBER := pk_protocol.g_task_appoint; -- Consultas := 2;
        l_var_img            NUMBER := pk_protocol.g_task_img; -- Imagem: exam := 4;
        l_var_enfint         NUMBER := pk_protocol.g_task_enfint; -- Intervenes de enfermagem := 6;
        l_var_drug           NUMBER := pk_protocol.g_task_drug; -- Medicao : drug / tabelas infarmed := 7;
        l_var_otherexam      NUMBER := pk_protocol.g_task_otherexam; -- Outros exames : exam := 8;
        l_var_spec           NUMBER := pk_protocol.g_task_spec; -- Pareceres : speciality := 9;
        l_var_drug_ext       NUMBER := pk_protocol.g_task_drug_ext; -- Medicao exterior := 11;
        l_var_proc           NUMBER := pk_protocol.g_task_proc; -- Procedimentos := 12;
        l_var_monitorization NUMBER := pk_protocol.g_task_monitorization; -- monitorizacoes := 14;
        l_var_pat_educ       NUMBER := pk_protocol.g_task_patient_education;
    
        --Analysis
        l_id_analysis_def analysis.id_content%TYPE := NULL;
        l_id_analysis     analysis.id_analysis%TYPE := NULL;
        l_asys_codif      analysis_codification.id_analysis_codification%TYPE := NULL;
        --Appointment
        l_id_clin_serv_def clinical_service.id_content%TYPE := NULL;
        l_id_clin_serv     clinical_service.id_clinical_service%TYPE := NULL;
        l_id_dep_clin_serv dep_clin_serv.id_dep_clin_serv%TYPE := NULL;
        --ICNP Composition
        l_id_icnp_def icnp_composition.id_content%TYPE := NULL;
        l_id_icnp     icnp_composition.id_composition%TYPE := NULL;
        --Exams
        l_id_exam_img_def   exam.id_content%TYPE := NULL;
        l_id_exam_img       exam.id_exam%TYPE := NULL;
        l_exam_img          exam.flg_type%TYPE := pk_exam_constant.g_type_img;
        l_id_exam_other_def exam.id_content%TYPE := NULL;
        l_id_exam_other     exam.id_exam%TYPE := NULL;
        l_exam_other        exam.flg_type%TYPE := pk_exam_constant.g_type_exm;
        l_exam_img_codif    exam_codification.id_exam_codification%TYPE := NULL;
        l_exam_other_codif  exam_codification.id_exam_codification%TYPE := NULL;
        --Medication
        g_config_prescription_type sys_config.id_sys_config%TYPE := 'PRESCRIPTION_TYPE';
        l_id_drug                  mi_med.id_drug%TYPE := NULL;
        l_emb_id                   me_med.emb_id%TYPE := NULL;
        --Speciality
        l_id_spec speciality.id_speciality%TYPE;
        --Procedures
        l_id_intervention_def intervention.id_content%TYPE := NULL;
        l_id_intervention     intervention.id_intervention%TYPE := NULL;
        l_interv_codif        interv_codification.id_interv_codification%TYPE := NULL;
        --Vital_Sign
        l_id_vital_sign vital_sign.id_vital_sign%TYPE;
        l_count_vsi     NUMBER := 0;
    
        l_id_pat_educ nurse_tea_topic.id_nurse_tea_topic%TYPE;
    
        CURSOR c_protocol_task
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT pe.id_protocol,
                            p.id_content,
                            pt.id_protocol_task,
                            pt.id_group_task,
                            pt.desc_protocol_task,
                            pt.id_task_link,
                            pt.task_type,
                            pt.task_notes,
                            pt.id_task_attach,
                            pt.task_codification
              FROM alert_default.protocol_task pt
              JOIN alert_default.protocol_element pe
                ON (pe.id_element = pt.id_group_task AND pe.element_type = l_var_t)
              JOIN alert_default.protocol p
                ON (p.id_protocol = pe.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pe.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version);
    
        CURSOR c_analysis
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT a.id_content
              FROM alert_default.analysis a
              JOIN alert_default.analysis_mrk_vrs amv
                ON (amv.id_analysis = a.id_analysis AND amv.id_market = c_market AND amv.version = c_version)
              JOIN alert_default.analysis_instit_soft ais
                ON (ais.id_analysis = a.id_analysis AND ais.id_software = c_id_software AND ais.flg_available = g_yes AND
                   ais.flg_type = pk_alert_constant.g_analysis_request)
             WHERE a.flg_available = g_yes
               AND a.id_analysis = c_id_task_link;
    
        CURSOR c_appointment(c_id_task_link IN guideline_task_link.id_task_link%TYPE) IS
            SELECT cs.id_content
              FROM alert_default.clinical_service cs
             WHERE cs.flg_available = g_yes
               AND cs.id_clinical_service IN
                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                     column_value
                      FROM TABLE(CAST(pk_backoffice_default.check_clinical_service_parent(i_lang, c_id_task_link) AS
                                      table_number)) p);
    
        CURSOR c_icnp
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT i.id_content
              FROM alert_default.icnp_composition i
              JOIN alert_default.icnp_compo_cs ic
                ON (ic.id_composition = i.id_composition AND ic.id_market = c_market AND ic.version = c_version AND
                   ic.id_software = c_id_software)
              JOIN alert_default.clinical_service cs
                ON (cs.id_clinical_service = ic.id_clinical_service AND cs.flg_available = g_yes)
             WHERE i.flg_available = g_yes
               AND i.flg_type = 'A'
               AND i.id_software = c_id_software
               AND i.id_composition = c_id_task_link;
    
        CURSOR c_exams
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_exam_type    exam.flg_type%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT e.id_content
              FROM alert_default.exam e
              JOIN alert_default.exam_mrk_vrs emv
                ON (emv.id_exam = e.id_exam AND emv.id_market = c_market AND emv.version = c_version)
              JOIN alert_default.exam_clin_serv ecs
                ON (ecs.id_exam = e.id_exam AND ecs.id_software = c_id_software AND
                   ecs.flg_type = pk_exam_constant.g_exam_can_req)
             WHERE e.flg_available = g_yes
               AND e.id_exam = c_id_task_link
               AND e.flg_type = c_exam_type;
    
        CURSOR c_intervention
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT i.id_content
              FROM alert_default.intervention i
              JOIN alert_default.interv_mrk_vrs imv
                ON (imv.id_intervention = i.id_intervention AND imv.id_market = c_market AND imv.version = c_version)
              JOIN alert_default.interv_clin_serv ics
                ON (i.id_intervention = i.id_intervention AND ics.id_software = c_id_software AND
                   ics.flg_type = pk_procedures_constant.g_interv_can_req)
             WHERE i.flg_status = pk_alert_constant.g_active
               AND i.id_intervention = c_id_task_link;
    
        CURSOR c_vital_sign
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT vs.id_vital_sign
              FROM vital_sign vs
              JOIN alert_default.vs_soft_inst vsi
                ON (vsi.id_vital_sign = vs.id_vital_sign AND vsi.id_market = c_market AND vsi.version = c_version AND
                   vsi.flg_view = 'V2' AND vsi.id_software = c_id_software)
             WHERE vs.flg_available = g_yes
               AND vs.id_vital_sign = c_id_task_link;
    
        CURSOR c_prot_task
        (
            c_element_type      IN alert_default.protocol_element.element_type%TYPE,
            c_id_protocol       IN alert_default.protocol_element.id_protocol%TYPE,
            c_id_task_link      IN alert_default.protocol_task.id_task_link%TYPE,
            c_task_type         IN alert_default.protocol_task.task_type%TYPE,
            c_id_task_attach    IN alert_default.protocol_task.id_task_attach%TYPE,
            c_task_codification IN alert_default.protocol_task.task_codification%TYPE
        ) IS
            SELECT COUNT(pt.id_protocol_task)
              INTO l_count
              FROM alert_default.protocol_task pt
              JOIN alert_default.protocol_element pe
                ON (pe.id_element = pt.id_group_task AND pe.element_type = c_element_type)
             WHERE pe.id_protocol = c_id_protocol
               AND pt.id_task_link = c_id_task_link
               AND pt.task_type = c_task_type
               AND pt.id_task_attach = c_id_task_attach
               AND pt.task_codification = c_task_codification;
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_TASK ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_PROTOCOL_TASK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_task(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_task
                        INTO l_id_protocol_def,
                             l_id_content_def,
                             l_id_protocol_task,
                             l_id_group_task,
                             l_descr_protocol_task,
                             l_id_task_link,
                             l_task_type,
                             l_task_notes,
                             l_id_task_attach,
                             l_task_codif;
                    EXIT WHEN c_protocol_task%NOTFOUND;
                
                    g_error := 'GET PROTOCOL_ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT p.id_protocol
                                 FROM protocol p
                                WHERE p.id_content = l_id_content_def
                                  AND p.id_content IS NOT NULL
                                  AND p.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_protocol
                      FROM dual;
                
                    IF l_id_protocol != 0
                    THEN
                    
                        --> PAT EDUCATION 
                        IF l_task_type = l_var_pat_educ
                        
                        --> Added by JM 10-04-2013  
                        
                        THEN
                            SELECT nvl((SELECT DISTINCT ntt.id_nurse_tea_topic
                                         FROM nurse_tea_topic ntt
                                        WHERE ntt.flg_available = g_yes
                                          AND ntt.id_nurse_tea_topic = l_id_task_link
                                          AND rownum = 1),
                                       0)
                              INTO l_id_pat_educ
                              FROM dual;
                        
                            IF l_task_codif IS NULL
                            THEN
                                g_error := 'COUNT_TASK_PAT_EDUC';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                g_error := '2 OPEN C_PROT_TASK';
                                OPEN c_prot_task(c_element_type      => l_var_t,
                                                 c_id_protocol       => l_id_protocol,
                                                 c_id_task_link      => l_id_pat_educ,
                                                 c_task_type         => l_task_type,
                                                 c_id_task_attach    => l_id_task_attach,
                                                 c_task_codification => l_task_codif);
                                FETCH c_prot_task
                                    INTO l_count;
                                CLOSE c_prot_task;
                            
                                IF l_count = 0
                                THEN
                                    l_id_protocol_task_array.extend;
                                    l_id_group_task_array.extend;
                                    l_descr_protocol_task_array.extend;
                                    l_id_task_link_array.extend;
                                    l_task_type_array.extend;
                                    l_task_notes_array.extend;
                                    l_id_task_attach_array.extend;
                                    l_task_codif_array.extend;
                                
                                    l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                    l_id_group_task_array(l_index) := l_id_group_task;
                                    l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                    l_id_task_link_array(l_index) := l_id_analysis;
                                    l_task_type_array(l_index) := l_task_type;
                                    l_task_notes_array(l_index) := l_task_notes;
                                    l_id_task_attach_array(l_index) := l_id_task_attach;
                                    l_task_codif_array(l_index) := l_task_codif;
                                
                                    l_index := l_index + 1;
                                END IF;
                            
                            END IF;
                        END IF;
                    
                        --> ANALYSIS
                        IF l_task_type = l_var_analysis
                        THEN
                            OPEN c_analysis(l_id_task_link, i_id_software, i_version(i), i_market(j));
                            LOOP
                            
                                FETCH c_analysis
                                    INTO l_id_analysis_def;
                                EXIT WHEN c_analysis%NOTFOUND;
                            
                                SELECT nvl((SELECT a.id_analysis
                                             FROM analysis a
                                            WHERE a.id_content = l_id_analysis_def
                                              AND a.id_content IS NOT NULL
                                              AND a.flg_available = g_yes
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_analysis
                                  FROM dual;
                            
                                IF l_id_analysis != 0
                                THEN
                                
                                    IF l_task_codif IS NOT NULL
                                    THEN
                                        SELECT nvl((SELECT ac.id_analysis_codification
                                                     FROM analysis_codification ac
                                                    WHERE ac.id_analysis = l_id_analysis
                                                      AND ac.id_codification =
                                                          (SELECT t.id_codification
                                                             FROM codification t
                                                            WHERE t.id_content =
                                                                  (SELECT b.id_content
                                                                     FROM alert_default.codification b
                                                                     JOIN alert_default.analysis_codification ac1
                                                                       ON ac1.id_codification = b.id_codification
                                                                      AND ac1.id_analysis =
                                                                          (SELECT an.id_analysis
                                                                             FROM alert_default.analysis an
                                                                            WHERE an.id_content = l_id_analysis_def
                                                                              AND an.flg_available = g_yes)
                                                                      AND ac1.flg_available = g_yes)
                                                              AND t.flg_available = g_yes)
                                                      AND ac.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_asys_codif
                                          FROM dual;
                                    
                                        IF l_asys_codif != 0
                                        THEN
                                        
                                            g_error := '1 OPEN C_PROT_TASK';
                                            OPEN c_prot_task(c_element_type      => l_var_t,
                                                             c_id_protocol       => l_id_protocol,
                                                             c_id_task_link      => l_id_analysis,
                                                             c_task_type         => l_task_type,
                                                             c_id_task_attach    => l_id_task_attach,
                                                             c_task_codification => l_asys_codif);
                                            FETCH c_prot_task
                                                INTO l_count;
                                            CLOSE c_prot_task;
                                        
                                            IF l_count = 0
                                            THEN
                                            
                                                l_id_protocol_task_array.extend;
                                                l_id_group_task_array.extend;
                                                l_descr_protocol_task_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                                l_id_group_task_array(l_index) := l_id_group_task;
                                                l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                                l_id_task_link_array(l_index) := l_id_analysis;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_asys_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    ELSE
                                        g_error := 'COUNT_TASK_ANALYSIS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        g_error := '2 OPEN C_PROT_TASK';
                                        OPEN c_prot_task(c_element_type      => l_var_t,
                                                         c_id_protocol       => l_id_protocol,
                                                         c_id_task_link      => l_id_analysis,
                                                         c_task_type         => l_task_type,
                                                         c_id_task_attach    => l_id_task_attach,
                                                         c_task_codification => l_task_codif);
                                        FETCH c_prot_task
                                            INTO l_count;
                                        CLOSE c_prot_task;
                                    
                                        IF l_count = 0
                                        THEN
                                            l_id_protocol_task_array.extend;
                                            l_id_group_task_array.extend;
                                            l_descr_protocol_task_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                            l_id_group_task_array(l_index) := l_id_group_task;
                                            l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                            l_id_task_link_array(l_index) := l_id_analysis;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_ANALYSIS CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_analysis;
                            --> APPOINTMENT
                        ELSIF l_task_type = l_var_appoint
                        THEN
                            OPEN c_appointment(l_id_task_link);
                            LOOP
                                FETCH c_appointment
                                    INTO l_id_clin_serv_def;
                                EXIT WHEN c_appointment%NOTFOUND;
                            
                                g_error := 'GET SUBSEQUENT APPOINTMENT';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                IF l_id_clin_serv_def != -1 --> Consultas subsequentes
                                THEN
                                    g_error := 'GET_CLINICAL_SERVICE_ID';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT nvl((SELECT cs.id_clinical_service
                                                 FROM clinical_service cs
                                                WHERE cs.id_content = l_id_clin_serv_def
                                                  AND cs.id_content IS NOT NULL
                                                  AND cs.flg_available = g_yes
                                                  AND rownum = 1),
                                               0)
                                      INTO l_id_clin_serv
                                      FROM dual;
                                
                                    IF l_id_clin_serv != 0
                                    THEN
                                        SELECT nvl((SELECT dcs.id_dep_clin_serv
                                                     FROM dep_clin_serv dcs
                                                     JOIN department d
                                                       ON (d.id_department = dcs.id_department AND
                                                          d.flg_available = g_yes AND d.id_software = i_id_software AND
                                                          d.id_institution = i_id_institution)
                                                     JOIN dept dp
                                                       ON (dp.id_dept = d.id_dept)
                                                      AND dp.id_institution = i_id_institution
                                                     JOIN clinical_service cs
                                                       ON (cs.id_clinical_service = dcs.id_clinical_service AND
                                                          cs.flg_available = g_yes AND
                                                          cs.id_clinical_service = l_id_clin_serv)
                                                    WHERE dcs.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_dep_clin_serv
                                          FROM dual;
                                    
                                        IF l_id_dep_clin_serv != 0
                                        THEN
                                        
                                            g_error := '3 OPEN C_PROT_TASK';
                                            OPEN c_prot_task(c_element_type      => l_var_t,
                                                             c_id_protocol       => l_id_protocol,
                                                             c_id_task_link      => l_id_dep_clin_serv,
                                                             c_task_type         => l_task_type,
                                                             c_id_task_attach    => l_id_task_attach,
                                                             c_task_codification => l_task_codif);
                                            FETCH c_prot_task
                                                INTO l_count;
                                            CLOSE c_prot_task;
                                        
                                            IF l_count = 0
                                            THEN
                                                l_id_protocol_task_array.extend;
                                                l_id_group_task_array.extend;
                                                l_descr_protocol_task_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                                l_id_group_task_array(l_index) := l_id_group_task;
                                                l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                                l_id_task_link_array(l_index) := l_id_dep_clin_serv;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_task_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                ELSE
                                
                                    g_error := '4 OPEN C_PROT_TASK';
                                    OPEN c_prot_task(c_element_type      => l_var_t,
                                                     c_id_protocol       => l_id_protocol,
                                                     c_id_task_link      => -1,
                                                     c_task_type         => l_task_type,
                                                     c_id_task_attach    => l_id_task_attach,
                                                     c_task_codification => l_task_codif);
                                    FETCH c_prot_task
                                        INTO l_count;
                                    CLOSE c_prot_task;
                                
                                    IF l_count = 0
                                    THEN
                                        l_id_protocol_task_array.extend;
                                        l_id_group_task_array.extend;
                                        l_descr_protocol_task_array.extend;
                                        l_id_task_link_array.extend;
                                        l_task_type_array.extend;
                                        l_task_notes_array.extend;
                                        l_id_task_attach_array.extend;
                                        l_task_codif_array.extend;
                                    
                                        l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                        l_id_group_task_array(l_index) := l_id_group_task;
                                        l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                        l_id_task_link_array(l_index) := -1;
                                        l_task_type_array(l_index) := l_task_type;
                                        l_task_notes_array(l_index) := l_task_notes;
                                        l_id_task_attach_array(l_index) := l_id_task_attach;
                                        l_task_codif_array(l_index) := l_task_codif;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_APPOINTMENT CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_appointment;
                            --> ICNP_COMPOSITION
                        ELSIF l_task_type = l_var_enfint
                        THEN
                            OPEN c_icnp(l_id_task_link, i_id_software, i_version(i), i_market(j));
                            LOOP
                                FETCH c_icnp
                                    INTO l_id_icnp_def;
                                EXIT WHEN c_icnp%NOTFOUND;
                            
                                g_error := 'GET_ICNP_COMPOSITION_ID';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT ic.id_composition
                                             FROM icnp_composition ic
                                            WHERE ic.id_content = l_id_icnp_def
                                              AND ic.id_content IS NOT NULL
                                              AND ic.flg_available = g_yes
                                              AND ic.flg_type = 'A'
                                              AND ic.id_software = i_id_software
                                              AND ic.id_institution = i_id_institution
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_icnp
                                  FROM dual;
                            
                                IF l_id_icnp != 0
                                THEN
                                    g_error := '5 OPEN C_PROT_TASK';
                                    OPEN c_prot_task(c_element_type      => l_var_t,
                                                     c_id_protocol       => l_id_protocol,
                                                     c_id_task_link      => l_id_icnp,
                                                     c_task_type         => l_task_type,
                                                     c_id_task_attach    => l_id_task_attach,
                                                     c_task_codification => l_task_codif);
                                    FETCH c_prot_task
                                        INTO l_count;
                                    CLOSE c_prot_task;
                                
                                    IF l_count = 0
                                    THEN
                                        l_id_protocol_task_array.extend;
                                        l_id_group_task_array.extend;
                                        l_descr_protocol_task_array.extend;
                                        l_id_task_link_array.extend;
                                        l_task_type_array.extend;
                                        l_task_notes_array.extend;
                                        l_id_task_attach_array.extend;
                                        l_task_codif_array.extend;
                                    
                                        l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                        l_id_group_task_array(l_index) := l_id_group_task;
                                        l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                        l_id_task_link_array(l_index) := l_id_icnp;
                                        l_task_type_array(l_index) := l_task_type;
                                        l_task_notes_array(l_index) := l_task_notes;
                                        l_id_task_attach_array(l_index) := l_id_task_attach;
                                        l_task_codif_array(l_index) := l_task_codif;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_ICNP CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_icnp;
                            --> EXAM_IMG
                        ELSIF l_task_type = l_var_img
                        THEN
                            OPEN c_exams(l_id_task_link, l_exam_img, i_id_software, i_version(i), i_market(j));
                            LOOP
                                FETCH c_exams
                                    INTO l_id_exam_img_def;
                                EXIT WHEN c_exams%NOTFOUND;
                            
                                g_error := 'GET_EXAM_IMG_ID';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT e.id_exam
                                             FROM exam e
                                            WHERE e.id_content = l_id_exam_img_def
                                              AND e.id_content IS NOT NULL
                                              AND e.flg_available = g_yes
                                              AND e.flg_type = l_exam_img
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_exam_img
                                  FROM dual;
                            
                                IF l_id_exam_img != 0
                                THEN
                                
                                    IF l_task_codif IS NOT NULL
                                    THEN
                                        SELECT nvl((SELECT ec.id_exam_codification
                                                     FROM exam_codification ec
                                                    WHERE ec.id_exam = l_id_exam_img
                                                      AND ec.id_codification =
                                                          (SELECT t.id_codification
                                                             FROM codification t
                                                            WHERE t.id_content =
                                                                  (SELECT b.id_content
                                                                     FROM alert_default.codification b
                                                                     JOIN alert_default.exam_codification ec1
                                                                       ON ec1.id_codification = b.id_codification
                                                                      AND ec1.id_exam =
                                                                          (SELECT e.id_exam
                                                                             FROM alert_default.exam e
                                                                            WHERE e.id_content = l_id_exam_img_def
                                                                              AND e.flg_type = l_exam_img
                                                                              AND e.flg_available = g_yes)
                                                                      AND ec1.flg_available = g_yes)
                                                              AND t.flg_available = g_yes)
                                                      AND ec.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_exam_img_codif
                                          FROM dual;
                                    
                                        IF l_exam_img_codif != 0
                                        THEN
                                        
                                            g_error := '6 OPEN C_PROT_TASK';
                                            OPEN c_prot_task(c_element_type      => l_var_t,
                                                             c_id_protocol       => l_id_protocol,
                                                             c_id_task_link      => l_id_exam_img,
                                                             c_task_type         => l_task_type,
                                                             c_id_task_attach    => l_id_task_attach,
                                                             c_task_codification => l_exam_img_codif);
                                            FETCH c_prot_task
                                                INTO l_count;
                                            CLOSE c_prot_task;
                                        
                                            IF l_count = 0
                                            THEN
                                                l_id_protocol_task_array.extend;
                                                l_id_group_task_array.extend;
                                                l_descr_protocol_task_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                                l_id_group_task_array(l_index) := l_id_group_task;
                                                l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                                l_id_task_link_array(l_index) := l_id_exam_img;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_exam_img_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    ELSE
                                        g_error := '7 OPEN C_PROT_TASK';
                                        OPEN c_prot_task(c_element_type      => l_var_t,
                                                         c_id_protocol       => l_id_protocol,
                                                         c_id_task_link      => l_id_exam_img,
                                                         c_task_type         => l_task_type,
                                                         c_id_task_attach    => l_id_task_attach,
                                                         c_task_codification => l_task_codif);
                                        FETCH c_prot_task
                                            INTO l_count;
                                        CLOSE c_prot_task;
                                    
                                        IF l_count = 0
                                        THEN
                                            l_id_protocol_task_array.extend;
                                            l_id_group_task_array.extend;
                                            l_descr_protocol_task_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                            l_id_group_task_array(l_index) := l_id_group_task;
                                            l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                            l_id_task_link_array(l_index) := l_id_exam_img;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_EXAMS CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_exams;
                            --> EXAM_OTHER
                        ELSIF l_task_type = l_var_otherexam
                        THEN
                            OPEN c_exams(l_id_task_link, l_exam_other, i_id_software, i_version(i), i_market(j));
                            LOOP
                                FETCH c_exams
                                    INTO l_id_exam_other_def;
                                EXIT WHEN c_exams%NOTFOUND;
                            
                                g_error := 'GET_EXAM_OTHER_ID';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT e.id_exam
                                             FROM exam e
                                            WHERE e.id_content = l_id_exam_other_def
                                              AND e.id_content IS NOT NULL
                                              AND e.flg_available = g_yes
                                              AND e.flg_type = l_exam_other
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_exam_other
                                  FROM dual;
                            
                                IF l_id_exam_other != 0
                                THEN
                                
                                    IF l_task_codif IS NOT NULL
                                    THEN
                                        SELECT nvl((SELECT ec.id_exam_codification
                                                     FROM exam_codification ec
                                                    WHERE ec.id_exam = l_id_exam_other
                                                      AND ec.id_codification =
                                                          (SELECT t.id_codification
                                                             FROM codification t
                                                            WHERE t.id_content =
                                                                  (SELECT b.id_content
                                                                     FROM alert_default.codification b
                                                                     JOIN alert_default.exam_codification ec1
                                                                       ON ec1.id_codification = b.id_codification
                                                                      AND ec1.id_exam =
                                                                          (SELECT e.id_exam
                                                                             FROM alert_default.exam e
                                                                            WHERE e.id_content = l_id_exam_other_def
                                                                              AND e.flg_type = l_exam_other
                                                                              AND e.flg_available = g_yes)
                                                                      AND ec1.flg_available = g_yes)
                                                              AND t.flg_available = g_yes)
                                                      AND ec.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_exam_other_codif
                                          FROM dual;
                                    
                                        IF l_exam_other_codif != 0
                                        THEN
                                        
                                            g_error := '8 OPEN C_PROT_TASK';
                                            OPEN c_prot_task(c_element_type      => l_var_t,
                                                             c_id_protocol       => l_id_protocol,
                                                             c_id_task_link      => l_id_exam_img,
                                                             c_task_type         => l_task_type,
                                                             c_id_task_attach    => l_id_task_attach,
                                                             c_task_codification => l_exam_other_codif);
                                            FETCH c_prot_task
                                                INTO l_count;
                                            CLOSE c_prot_task;
                                        
                                            IF l_count = 0
                                            THEN
                                                l_id_protocol_task_array.extend;
                                                l_id_group_task_array.extend;
                                                l_descr_protocol_task_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                                l_id_group_task_array(l_index) := l_id_group_task;
                                                l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                                l_id_task_link_array(l_index) := l_id_exam_img;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_exam_other_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    ELSE
                                        g_error := '9 OPEN C_PROT_TASK';
                                        OPEN c_prot_task(c_element_type      => l_var_t,
                                                         c_id_protocol       => l_id_protocol,
                                                         c_id_task_link      => l_id_exam_img,
                                                         c_task_type         => l_task_type,
                                                         c_id_task_attach    => l_id_task_attach,
                                                         c_task_codification => l_task_codif);
                                        FETCH c_prot_task
                                            INTO l_count;
                                        CLOSE c_prot_task;
                                    
                                        IF l_count = 0
                                        THEN
                                            l_id_protocol_task_array.extend;
                                            l_id_group_task_array.extend;
                                            l_descr_protocol_task_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                            l_id_group_task_array(l_index) := l_id_group_task;
                                            l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                            l_id_task_link_array(l_index) := l_id_exam_img;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_EXAMS CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_exams;
                            --> Internal_Medication
                        ELSIF l_task_type = l_var_drug
                        THEN
                            g_error := 'PK_SYSCONFIG.GET_CONFIG PRESCRIPTION_TYPE ' || i_id_institution;
                            SELECT nvl((SELECT pk_sysconfig.get_config('PRESCRIPTION_TYPE',
                                                                      profissional(NULL, i_id_institution, i_id_software))
                                         FROM dual),
                                       NULL)
                              INTO g_config_prescription_type
                              FROM dual;
                        
                            g_error := 'SELECT ID_DRUG ' || g_config_prescription_type;
                            BEGIN
                                SELECT DISTINCT t.id_drug
                                  INTO l_id_drug
                                  FROM mi_med t
                                  JOIN drug_dep_clin_serv dcs
                                    ON (dcs.id_drug = t.id_drug AND dcs.id_institution = i_id_institution AND
                                       dcs.vers = g_config_prescription_type AND
                                       dcs.flg_type = pk_medication_types.c_ddcs_flg_type_pesq_p AND
                                       dcs.id_software = i_id_software)
                                 WHERE t.flg_available = g_yes
                                   AND t.flg_type = pk_guidelines.g_drug
                                   AND t.vers = g_config_prescription_type
                                   AND t.id_drug = l_id_task_link;
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_id_drug := NULL;
                            END;
                        
                            IF l_id_drug IS NOT NULL
                               AND g_config_prescription_type IS NOT NULL
                            THEN
                                g_error := '10 OPEN C_PROT_TASK';
                                OPEN c_prot_task(c_element_type      => l_var_t,
                                                 c_id_protocol       => l_id_protocol,
                                                 c_id_task_link      => l_id_drug,
                                                 c_task_type         => l_task_type,
                                                 c_id_task_attach    => l_id_task_attach,
                                                 c_task_codification => l_task_codif);
                                FETCH c_prot_task
                                    INTO l_count;
                                CLOSE c_prot_task;
                            
                                IF l_count = 0
                                THEN
                                    l_id_protocol_task_array.extend;
                                    l_id_group_task_array.extend;
                                    l_descr_protocol_task_array.extend;
                                    l_id_task_link_array.extend;
                                    l_task_type_array.extend;
                                    l_task_notes_array.extend;
                                    l_id_task_attach_array.extend;
                                    l_task_codif_array.extend;
                                
                                    l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                    l_id_group_task_array(l_index) := l_id_group_task;
                                    l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                    l_id_task_link_array(l_index) := l_id_drug;
                                    l_task_type_array(l_index) := l_task_type;
                                    l_task_notes_array(l_index) := l_task_notes;
                                    l_id_task_attach_array(l_index) := l_id_task_attach;
                                    l_task_codif_array(l_index) := l_task_codif;
                                
                                    l_index := l_index + 1;
                                END IF;
                            END IF;
                            --> External_Medication
                        ELSIF l_task_type = l_var_drug_ext
                        THEN
                            g_error := 'PK_SYSCONFIG.GET_CONFIG PRESCRIPTION_TYPE ' || i_id_institution;
                            SELECT nvl((SELECT pk_sysconfig.get_config('PRESCRIPTION_TYPE',
                                                                      profissional(NULL, i_id_institution, i_id_software))
                                         FROM dual),
                                       NULL)
                              INTO g_config_prescription_type
                              FROM dual;
                        
                            g_error := 'SELECT EMB_ID ' || g_config_prescription_type;
                            BEGIN
                                SELECT DISTINCT t.emb_id
                                  INTO l_emb_id
                                  FROM me_med t
                                  JOIN emb_dep_clin_serv edcs
                                    ON (edcs.emb_id = t.emb_id AND edcs.id_institution = i_id_institution AND
                                       edcs.vers = g_config_prescription_type AND
                                       edcs.flg_type = pk_medication_types.c_ddcs_flg_type_pesq_p AND
                                       edcs.id_software = i_id_software)
                                 WHERE t.flg_available = g_yes
                                   AND t.flg_comerc = g_yes
                                   AND t.vers = g_config_prescription_type
                                   AND t.emb_id = l_id_task_link;
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_emb_id := NULL;
                            END;
                        
                            IF l_emb_id IS NOT NULL
                               AND g_config_prescription_type IS NOT NULL
                            THEN
                            
                                g_error := '11 OPEN C_PROT_TASK';
                                OPEN c_prot_task(c_element_type      => l_var_t,
                                                 c_id_protocol       => l_id_protocol,
                                                 c_id_task_link      => l_emb_id,
                                                 c_task_type         => l_task_type,
                                                 c_id_task_attach    => l_id_task_attach,
                                                 c_task_codification => l_task_codif);
                                FETCH c_prot_task
                                    INTO l_count;
                                CLOSE c_prot_task;
                            
                                IF l_count = 0
                                THEN
                                    l_id_protocol_task_array.extend;
                                    l_id_group_task_array.extend;
                                    l_descr_protocol_task_array.extend;
                                    l_id_task_link_array.extend;
                                    l_task_type_array.extend;
                                    l_task_notes_array.extend;
                                    l_id_task_attach_array.extend;
                                    l_task_codif_array.extend;
                                
                                    l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                    l_id_group_task_array(l_index) := l_id_group_task;
                                    l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                    l_id_task_link_array(l_index) := l_emb_id;
                                    l_task_type_array(l_index) := l_task_type;
                                    l_task_notes_array(l_index) := l_task_notes;
                                    l_id_task_attach_array(l_index) := l_id_task_attach;
                                    l_task_codif_array(l_index) := l_task_codif;
                                
                                    l_index := l_index + 1;
                                END IF;
                            END IF;
                            --> Speciality
                        ELSIF l_task_type = l_var_spec
                        THEN
                            g_error := 'GET_SPECIALITY_ID';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            SELECT nvl((SELECT sp.id_speciality
                                         FROM speciality sp
                                        WHERE sp.id_content = (SELECT sp1.id_content
                                                                 FROM alert_default.speciality sp1
                                                                WHERE sp1.id_speciality = l_id_task_link
                                                                  AND sp1.flg_available = g_yes)
                                          AND sp.id_content IS NOT NULL
                                          AND sp.flg_available = g_yes
                                          AND rownum = 1),
                                       0)
                              INTO l_id_spec
                              FROM dual;
                        
                            IF l_id_spec != 0
                            THEN
                            
                                g_error := '12 OPEN C_PROT_TASK';
                                OPEN c_prot_task(c_element_type      => l_var_t,
                                                 c_id_protocol       => l_id_protocol,
                                                 c_id_task_link      => l_id_spec,
                                                 c_task_type         => l_task_type,
                                                 c_id_task_attach    => l_id_task_attach,
                                                 c_task_codification => l_task_codif);
                                FETCH c_prot_task
                                    INTO l_count;
                                CLOSE c_prot_task;
                            
                                IF l_count = 0
                                THEN
                                    l_id_protocol_task_array.extend;
                                    l_id_group_task_array.extend;
                                    l_descr_protocol_task_array.extend;
                                    l_id_task_link_array.extend;
                                    l_task_type_array.extend;
                                    l_task_notes_array.extend;
                                    l_id_task_attach_array.extend;
                                    l_task_codif_array.extend;
                                
                                    l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                    l_id_group_task_array(l_index) := l_id_group_task;
                                    l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                    l_id_task_link_array(l_index) := l_id_spec;
                                    l_task_type_array(l_index) := l_task_type;
                                    l_task_notes_array(l_index) := l_task_notes;
                                    l_id_task_attach_array(l_index) := l_id_task_attach;
                                    l_task_codif_array(l_index) := l_task_codif;
                                
                                    l_index := l_index + 1;
                                END IF;
                            END IF;
                            --> PROCEDURES
                        ELSIF l_task_type = l_var_proc
                        THEN
                            OPEN c_intervention(l_id_task_link, i_id_software, i_version(i), i_market(j));
                            LOOP
                                FETCH c_intervention
                                    INTO l_id_intervention_def;
                                EXIT WHEN c_intervention%NOTFOUND;
                            
                                g_error := 'GET_INTERVENTION_ID';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT i.id_intervention
                                             FROM intervention i
                                            WHERE i.id_content = l_id_intervention_def
                                              AND i.id_content IS NOT NULL
                                              AND i.flg_status = pk_alert_constant.g_active
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_intervention
                                  FROM dual;
                            
                                IF l_id_intervention != 0
                                THEN
                                    IF l_task_codif IS NOT NULL
                                    THEN
                                        SELECT nvl((SELECT ic.id_interv_codification
                                                     FROM interv_codification ic
                                                    WHERE ic.id_intervention = l_id_intervention
                                                      AND ic.id_codification =
                                                          (SELECT t.id_codification
                                                             FROM codification t
                                                            WHERE t.id_content =
                                                                  (SELECT b.id_content
                                                                     FROM alert_default.codification b
                                                                     JOIN alert_default.interv_codification ic1
                                                                       ON ic1.id_codification = b.id_codification
                                                                      AND ic1.id_intervention =
                                                                          (SELECT i.id_intervention
                                                                             FROM alert_default.intervention i
                                                                            WHERE i.id_intervention = l_id_task_link
                                                                              AND i.flg_status =
                                                                                  pk_alert_constant.g_active)
                                                                      AND ic1.flg_available = g_yes)
                                                              AND t.flg_available = g_yes)
                                                      AND ic.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_interv_codif
                                          FROM dual;
                                    
                                        IF l_interv_codif != 0
                                        THEN
                                        
                                            g_error := '13 OPEN C_PROT_TASK';
                                            OPEN c_prot_task(c_element_type      => l_var_t,
                                                             c_id_protocol       => l_id_protocol,
                                                             c_id_task_link      => l_id_intervention,
                                                             c_task_type         => l_task_type,
                                                             c_id_task_attach    => l_id_task_attach,
                                                             c_task_codification => l_interv_codif);
                                            FETCH c_prot_task
                                                INTO l_count;
                                            CLOSE c_prot_task;
                                        
                                            IF l_count = 0
                                            THEN
                                                l_id_protocol_task_array.extend;
                                                l_id_group_task_array.extend;
                                                l_descr_protocol_task_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                                l_id_group_task_array(l_index) := l_id_group_task;
                                                l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                                l_id_task_link_array(l_index) := l_id_intervention;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_interv_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    ELSE
                                    
                                        g_error := '14 OPEN C_PROT_TASK';
                                        OPEN c_prot_task(c_element_type      => l_var_t,
                                                         c_id_protocol       => l_id_protocol,
                                                         c_id_task_link      => l_id_intervention,
                                                         c_task_type         => l_task_type,
                                                         c_id_task_attach    => l_id_task_attach,
                                                         c_task_codification => l_task_codif);
                                        FETCH c_prot_task
                                            INTO l_count;
                                        CLOSE c_prot_task;
                                    
                                        IF l_count = 0
                                        THEN
                                            l_id_protocol_task_array.extend;
                                            l_id_group_task_array.extend;
                                            l_descr_protocol_task_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                            l_id_group_task_array(l_index) := l_id_group_task;
                                            l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                            l_id_task_link_array(l_index) := l_id_intervention;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_INTERVENTION CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_intervention;
                            --> Monitorizations
                        ELSIF l_task_type = l_var_monitorization
                        THEN
                            g_error := 'OPEN C_VITAL_SIGN ' || l_id_task_link;
                            OPEN c_vital_sign(l_id_task_link, i_id_software, i_version(i), i_market(j));
                            LOOP
                                g_error := 'FETCH C_VITAL_SIGN';
                                FETCH c_vital_sign
                                    INTO l_id_vital_sign;
                                EXIT WHEN c_vital_sign%NOTFOUND;
                            
                                IF l_id_vital_sign != 0
                                THEN
                                    g_error := 'CHECK VS_SOFT_INST FOR INSTITUTION';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT COUNT(vsi.id_vs_soft_inst)
                                      INTO l_count_vsi
                                      FROM vs_soft_inst vsi
                                     WHERE vsi.id_vital_sign = l_id_vital_sign
                                       AND vsi.id_institution = i_id_institution
                                       AND vsi.id_software = i_id_software
                                       AND vsi.flg_view = 'V2';
                                
                                    IF l_count_vsi != 0
                                    THEN
                                    
                                        g_error := '15 OPEN C_PROT_TASK';
                                        OPEN c_prot_task(c_element_type      => l_var_t,
                                                         c_id_protocol       => l_id_protocol,
                                                         c_id_task_link      => l_id_vital_sign,
                                                         c_task_type         => l_task_type,
                                                         c_id_task_attach    => l_id_task_attach,
                                                         c_task_codification => l_task_codif);
                                        FETCH c_prot_task
                                            INTO l_count;
                                        CLOSE c_prot_task;
                                    
                                        IF l_count = 0
                                        THEN
                                            l_id_protocol_task_array.extend;
                                            l_id_group_task_array.extend;
                                            l_descr_protocol_task_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_protocol_task_array(l_index) := l_id_protocol_task;
                                            l_id_group_task_array(l_index) := l_id_group_task;
                                            l_descr_protocol_task_array(l_index) := l_descr_protocol_task;
                                            l_id_task_link_array(l_index) := l_id_vital_sign;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_VITAL_SIGN CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_vital_sign;
                        
                        END IF; --> fim de todas as tasks
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_TASK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_task;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_PROTOCOL_TASK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_task FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_task_array AS table_number));
    
        g_error := 'CLOSE O_ID_GROUP_TASK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_group_task FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_group_task_array AS table_number));
    
        g_error := 'CLOSE O_DESC_PROTOCOL_TASK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_descr_protocol_task FOR
            SELECT column_value
              FROM TABLE(CAST(l_descr_protocol_task_array AS table_varchar));
    
        g_error := 'CLOSE O_ID_TASK_LINK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_task_link FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_task_link_array AS table_number));
    
        g_error := 'CLOSE O_TASK_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_task_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_task_type_array AS table_number));
    
        g_error := 'CLOSE O_TASK_NOTES CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_task_notes FOR
            SELECT column_value
              FROM TABLE(CAST(l_task_notes_array AS table_varchar));
    
        g_error := 'CLOSE O_ID_TASK_ATTACH CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_task_attach FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_task_attach_array AS table_number));
    
        g_error := 'CLOSE O_TASK_CODIFICATION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_task_codif FOR
            SELECT column_value
              FROM TABLE(CAST(l_task_codif_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol_task);
            pk_types.open_my_cursor(o_id_group_task);
            pk_types.open_my_cursor(o_descr_protocol_task);
            pk_types.open_my_cursor(o_id_task_link);
            pk_types.open_my_cursor(o_task_type);
            pk_types.open_my_cursor(o_task_notes);
            pk_types.open_my_cursor(o_id_task_attach);
            pk_types.open_my_cursor(o_task_codif);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_task;
    /********************************************************************************************
    * Get Protocol Text set by Protocol
    *
    * @param i_lang                         Prefered language ID
    * @param i_id_protocol                  Protocol ID   
    * @param o_id_protocol_text             Cursor of Protocol Text
    * @param o_descr_protocol_text          Cursor of Text Description  
    * @param o_text_type                    Cursor of Text Type
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/03
    ********************************************************************************************/
    FUNCTION get_inst_protocol_text
    (
        i_lang                IN language.id_language%TYPE,
        i_id_protocol         IN protocol_element.id_protocol%TYPE,
        o_id_protocol_text    OUT pk_types.cursor_type,
        o_descr_protocol_text OUT pk_types.cursor_type,
        o_text_type           OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_protocol_text    protocol_text.id_protocol_text%TYPE := NULL;
        l_descr_protocol_text protocol_text.desc_protocol_text%TYPE := NULL;
        l_text_type           protocol_text.protocol_text_type%TYPE := NULL;
    
        l_id_protocol_text_array    table_number := table_number();
        l_descr_protocol_text_array table_varchar := table_varchar();
        l_text_type_array           table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_text(c_id_protocol IN protocol_element.id_protocol%TYPE) IS
            SELECT DISTINCT pt.id_protocol_text, pt.desc_protocol_text, pt.protocol_text_type
              FROM alert_default.protocol_text pt
              JOIN alert_default.protocol_element pe
                ON pe.id_element = pt.id_protocol_text
               AND pe.element_type = pt.protocol_text_type
             WHERE pe.id_protocol = c_id_protocol;
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_TEXT ';
    
        g_error := 'OPEN C_PROTOCOL_TEXT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN c_protocol_text(i_id_protocol);
        LOOP
            FETCH c_protocol_text
                INTO l_id_protocol_text, l_descr_protocol_text, l_text_type;
            EXIT WHEN c_protocol_text%NOTFOUND;
        
            g_error := 'l_count_text';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            SELECT COUNT(pt.id_protocol_text)
              INTO l_count
              FROM protocol_text pt
             WHERE pt.id_protocol_text = l_id_protocol_text;
        
            g_error := 'IF l_count = 0';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF l_count = 0
            THEN
            
                l_id_protocol_text_array.extend;
                l_descr_protocol_text_array.extend;
                l_text_type_array.extend;
                l_id_protocol_text_array(l_index) := l_id_protocol_text;
                l_descr_protocol_text_array(l_index) := l_descr_protocol_text;
                l_text_type_array(l_index) := l_text_type;
            
                l_index := l_index + 1;
            END IF;
        
        END LOOP;
        g_error := 'CLOSE C_PROTOCOL_TEXT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        CLOSE c_protocol_text;
    
        g_error := 'CLOSE O_ID_PROTOCOL_TEXT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_text FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_text_array AS table_number));
    
        g_error := 'CLOSE O_DESCR_PROTOCOL_TEXT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_descr_protocol_text FOR
            SELECT column_value
              FROM TABLE(CAST(l_descr_protocol_text_array AS table_varchar));
    
        g_error := 'CLOSE O_TEXT_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_text_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_text_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol_text);
            pk_types.open_my_cursor(o_descr_protocol_text);
            pk_types.open_my_cursor(o_text_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_text;
    /********************************************************************************************
    * Get Protocol Elements set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol                  Cursor of Protocol
    * @param o_id_element                   Cursor of Elements
    * @param o_element_type                 Cursor of Element_Type
    * @param o_desc_element                 Cursor of Desc_Element
    * @param o_x_coordinate                 Cursor of x_coordinate
    * @param o_y_coordinate                 Cursor of y_coordinate
    * @param o_id_protocol_question         Cursor of Protocol Question
    * @param o_descr_question               Cursor of Question Description  
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/04/27
    ********************************************************************************************/
    FUNCTION get_inst_protocol_element
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_protocol    OUT pk_types.cursor_type,
        o_id_element     OUT pk_types.cursor_type,
        o_element_type   OUT pk_types.cursor_type,
        o_desc_element   OUT pk_types.cursor_type,
        o_x_coordinate   OUT pk_types.cursor_type,
        o_y_coordinate   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        --> Protocol_Element
        l_id_protocol_def protocol_element.id_protocol%TYPE := NULL;
        l_id_protocol     protocol_element.id_protocol%TYPE := NULL;
        l_id_content_def  protocol.id_content%TYPE := NULL;
        l_id_element      protocol_element.id_element%TYPE := NULL;
        l_element_type    protocol_element.element_type%TYPE := NULL;
        l_desc_element    protocol_element.desc_element%TYPE := NULL;
        l_x_coordinate    protocol_element.x_coordinate%TYPE := NULL;
        l_y_coordinate    protocol_element.y_coordinate%TYPE := NULL;
    
        l_id_protocol_array  table_number := table_number();
        l_id_element_array   table_number := table_number();
        l_element_type_array table_varchar := table_varchar();
        l_desc_element_array table_varchar := table_varchar();
        l_x_coordinate_array table_number := table_number();
        l_y_coordinate_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_element
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT pe.id_protocol,
                            p.id_content,
                            pe.id_element,
                            pe.element_type,
                            pe.desc_element,
                            pe.x_coordinate,
                            pe.y_coordinate
              FROM alert_default.protocol_element pe
              JOIN alert_default.protocol p
                ON (p.id_protocol = pe.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pe.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version)
             WHERE pe.flg_available = g_yes;
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_ELEMENT ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL_ELEMENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_element(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_element
                        INTO l_id_protocol_def,
                             l_id_content_def,
                             l_id_element,
                             l_element_type,
                             l_desc_element,
                             l_x_coordinate,
                             l_y_coordinate;
                    EXIT WHEN c_protocol_element%NOTFOUND;
                
                    SELECT nvl((SELECT p.id_protocol
                                 FROM protocol p
                                WHERE p.id_content = l_id_content_def
                                  AND p.id_content IS NOT NULL
                                  AND p.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_protocol
                      FROM dual;
                
                    SELECT COUNT(t.id_protocol_element)
                      INTO l_count
                      FROM protocol_element t
                     WHERE t.id_protocol = l_id_protocol
                       AND t.id_element = l_id_element
                       AND t.element_type = l_element_type
                       AND t.x_coordinate = l_x_coordinate
                       AND t.y_coordinate = l_y_coordinate;
                
                    IF l_id_protocol != 0
                       AND l_count = 0
                    THEN
                    
                        l_id_protocol_array.extend;
                        l_id_element_array.extend;
                        l_element_type_array.extend;
                        l_desc_element_array.extend;
                        l_x_coordinate_array.extend;
                        l_y_coordinate_array.extend;
                    
                        l_id_protocol_array(l_index) := l_id_protocol;
                        l_id_element_array(l_index) := l_id_element;
                        l_element_type_array(l_index) := l_element_type;
                        l_desc_element_array(l_index) := l_desc_element;
                        l_x_coordinate_array(l_index) := l_x_coordinate;
                        l_y_coordinate_array(l_index) := l_y_coordinate;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_ELEMENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_element;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_array AS table_number));
    
        g_error := 'OPEN O_ID_ELEMENT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_element FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_element_array AS table_number));
    
        g_error := 'OPEN O_ELEMENT_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_element_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_element_type_array AS table_varchar));
    
        g_error := 'OPEN O_DESC_ELEMENT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_desc_element FOR
            SELECT column_value
              FROM TABLE(CAST(l_desc_element_array AS table_varchar));
    
        g_error := 'OPEN O_X_COORDINATE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_x_coordinate FOR
            SELECT column_value
              FROM TABLE(CAST(l_x_coordinate_array AS table_number));
    
        g_error := 'OPEN O_Y_COORDINATE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_y_coordinate FOR
            SELECT column_value
              FROM TABLE(CAST(l_y_coordinate_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol);
            pk_types.open_my_cursor(o_id_element);
            pk_types.open_my_cursor(o_element_type);
            pk_types.open_my_cursor(o_desc_element);
            pk_types.open_my_cursor(o_x_coordinate);
            pk_types.open_my_cursor(o_y_coordinate);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_element;
    /*********************************************************************************************
    * Set Protocol Element for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_protocol_element    Cursor of Instituition Protocol_Element
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/04/26
    ********************************************************************************************/
    FUNCTION set_inst_protocol_element
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN table_number,
        i_version          IN table_varchar,
        i_id_institution   IN institution.id_institution%TYPE,
        i_software         IN table_number,
        o_protocol_element OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        --Protocol Question
        l_c_id_protocol_question pk_types.cursor_type;
        l_c_descr_question       pk_types.cursor_type;
    
        l_data_id_protocol_question table_number;
        l_data_descr_question       table_varchar;
        --Protocol Protocol
        l_c_id_protocol_protocol pk_types.cursor_type;
        l_c_descr_protocol       pk_types.cursor_type;
        l_c_id_nested_protocol   pk_types.cursor_type;
    
        l_data_id_protocol_protocol table_number;
        l_data_descr_protocol       table_varchar;
        l_data_id_nested_protocol   table_number;
    
        --Protocol Text
        l_c_id_protocol_text    pk_types.cursor_type;
        l_c_descr_protocol_text pk_types.cursor_type;
        l_c_protocol_text_type  pk_types.cursor_type;
    
        l_data_id_protocol_text    table_number;
        l_data_descr_protocol_text table_varchar;
        l_data_protocol_text_type  table_varchar;
    
        --Protocol Element
        l_c_id_protocol  pk_types.cursor_type;
        l_c_id_element   pk_types.cursor_type;
        l_c_element_type pk_types.cursor_type;
        l_c_desc_element pk_types.cursor_type;
        l_c_x_coordinate pk_types.cursor_type;
        l_c_y_coordinate pk_types.cursor_type;
    
        l_data_id_protocol  table_number;
        l_data_id_element   table_number;
        l_data_element_type table_varchar;
        l_data_desc_element table_varchar;
        l_data_x_coordinate table_number;
        l_data_y_coordinate table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
        l_id_protocol_def protocol_element.id_protocol%TYPE := NULL;
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_ELEMENT ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_ELEMENT';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_protocol_element(i_lang,
                                             i_market,
                                             i_version,
                                             i_id_institution,
                                             i_software(i),
                                             l_c_id_protocol,
                                             l_c_id_element,
                                             l_c_element_type,
                                             l_c_desc_element,
                                             l_c_x_coordinate,
                                             l_c_y_coordinate,
                                             o_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'o_protocol_link := l_c_id_protocol';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_protocol_element := l_c_id_protocol;
            
                LOOP
                
                    FETCH l_c_id_protocol BULK COLLECT
                        INTO l_data_id_protocol LIMIT g_array_size;
                
                    FETCH l_c_id_element BULK COLLECT
                        INTO l_data_id_element LIMIT g_array_size;
                
                    FETCH l_c_element_type BULK COLLECT
                        INTO l_data_element_type LIMIT g_array_size;
                
                    FETCH l_c_desc_element BULK COLLECT
                        INTO l_data_desc_element LIMIT g_array_size;
                
                    FETCH l_c_x_coordinate BULK COLLECT
                        INTO l_data_x_coordinate LIMIT g_array_size;
                
                    FETCH l_c_y_coordinate BULK COLLECT
                        INTO l_data_y_coordinate LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol.count
                    LOOP
                    
                        SELECT p.id_protocol
                          INTO l_id_protocol_def
                          FROM alert_default.protocol p
                         WHERE p.id_content = (SELECT t.id_content
                                                 FROM protocol t
                                                WHERE t.id_protocol = l_data_id_protocol(j));
                    
                        --> Protocol_Question          
                        IF NOT get_inst_protocol_question(i_lang,
                                                          l_id_protocol_def,
                                                          l_c_id_protocol_question,
                                                          l_c_descr_question,
                                                          o_error)
                        
                        THEN
                            RAISE l_exception;
                        ELSE
                            LOOP
                                FETCH l_c_id_protocol_question BULK COLLECT
                                    INTO l_data_id_protocol_question LIMIT g_array_size;
                            
                                FETCH l_c_descr_question BULK COLLECT
                                    INTO l_data_descr_question LIMIT g_array_size;
                            
                                FOR k IN 1 .. l_data_id_protocol_question.count
                                LOOP
                                
                                    g_error := 'INSERT INTO PROTOCOL_QUESTION (' || l_data_id_protocol_question(k) || ', ' ||
                                               l_data_descr_question(k) || ');';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    INSERT INTO protocol_question
                                        (id_protocol_question, desc_protocol_question)
                                    VALUES
                                        (l_data_id_protocol_question(k), l_data_descr_question(k));
                                
                                END LOOP;
                                EXIT WHEN l_c_id_protocol_question%NOTFOUND;
                            END LOOP;
                            g_error := 'CLOSE l_c_id_protocol_question CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_id_protocol_question;
                        
                            g_error := 'CLOSE l_c_descr_question CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_descr_question;
                        
                        END IF;
                    
                        --> Protocol_Protocol
                        IF NOT get_inst_protocol_protocol(i_lang,
                                                          l_id_protocol_def,
                                                          l_c_id_protocol_protocol,
                                                          l_c_descr_protocol,
                                                          l_c_id_nested_protocol,
                                                          o_error)
                        
                        THEN
                            RAISE l_exception;
                        ELSE
                            LOOP
                            
                                FETCH l_c_id_protocol_protocol BULK COLLECT
                                    INTO l_data_id_protocol_protocol LIMIT g_array_size;
                            
                                FETCH l_c_descr_protocol BULK COLLECT
                                    INTO l_data_descr_protocol LIMIT g_array_size;
                            
                                FETCH l_c_id_nested_protocol BULK COLLECT
                                    INTO l_data_id_nested_protocol LIMIT g_array_size;
                            
                                FOR t IN 1 .. l_data_id_protocol_protocol.count
                                LOOP
                                    g_error := 'INSERT INTO PROTOCOL_PROTOCOL (' || l_data_id_protocol_protocol(t) || ');';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    INSERT INTO protocol_protocol
                                        (id_protocol_protocol, desc_protocol_protocol, id_nested_protocol)
                                    VALUES
                                        (l_data_id_protocol_protocol(t),
                                         l_data_descr_protocol(t),
                                         l_data_id_nested_protocol(t));
                                
                                END LOOP;
                                EXIT WHEN l_c_id_protocol_protocol%NOTFOUND;
                            END LOOP;
                        
                            g_error := 'CLOSE l_c_id_protocol_protocol CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_id_protocol_protocol;
                        
                            g_error := 'CLOSE l_c_descr_protocol CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_descr_protocol;
                        
                            g_error := 'CLOSE l_c_id_nested_protocol CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_id_nested_protocol;
                        END IF;
                    
                        --> Protocol_Text
                        IF NOT get_inst_protocol_text(i_lang,
                                                      l_id_protocol_def,
                                                      l_c_id_protocol_text,
                                                      l_c_descr_protocol_text,
                                                      l_c_protocol_text_type,
                                                      o_error)
                        
                        THEN
                            RAISE l_exception;
                        ELSE
                            LOOP
                            
                                FETCH l_c_id_protocol_text BULK COLLECT
                                    INTO l_data_id_protocol_text LIMIT g_array_size;
                            
                                FETCH l_c_descr_protocol_text BULK COLLECT
                                    INTO l_data_descr_protocol_text LIMIT g_array_size;
                            
                                FETCH l_c_protocol_text_type BULK COLLECT
                                    INTO l_data_protocol_text_type LIMIT g_array_size;
                            
                                FOR q IN 1 .. l_data_id_protocol_text.count
                                LOOP
                                    g_error := 'INSERT INTO PROTOCOL_TEXT (' || l_data_id_protocol_text(q) || ');';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    INSERT INTO protocol_text
                                        (id_protocol_text, desc_protocol_text, protocol_text_type)
                                    VALUES
                                        (l_data_id_protocol_text(q),
                                         l_data_descr_protocol_text(q),
                                         l_data_protocol_text_type(q));
                                
                                END LOOP;
                                EXIT WHEN l_c_id_protocol_text%NOTFOUND;
                            END LOOP;
                        
                            g_error := 'CLOSE l_c_id_protocol_text CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_id_protocol_text;
                        
                            g_error := 'CLOSE l_c_descr_protocol_text CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_descr_protocol_text;
                        
                            g_error := 'CLOSE l_c_protocol_text_type CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE l_c_protocol_text_type;
                        END IF;
                    
                        --> Protocol_Element
                        g_error := 'INSERT INTO PROTOCOL_ELEMENT (seq_protocol_element.NEXTVAL,' ||
                                   l_data_id_protocol(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_element
                            (id_protocol_element,
                             id_protocol,
                             id_element,
                             element_type,
                             desc_element,
                             x_coordinate,
                             y_coordinate,
                             flg_available)
                        VALUES
                            (seq_protocol_element.nextval,
                             l_data_id_protocol(j),
                             l_data_id_element(j),
                             l_data_element_type(j),
                             l_data_desc_element(j),
                             l_data_x_coordinate(j),
                             l_data_y_coordinate(j),
                             'Y');
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol%NOTFOUND;
                
                END LOOP;
                g_error := 'CLOSE l_c_id_protocol CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol;
            
                g_error := 'CLOSE l_c_id_element CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_element;
            
                g_error := 'CLOSE l_c_element_type CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_element_type;
            
                g_error := 'CLOSE l_c_desc_element CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_desc_element;
            
                g_error := 'CLOSE l_c_x_coordinate CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_x_coordinate;
            
                g_error := 'CLOSE l_c_y_coordinate CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_y_coordinate;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_element;
    /*********************************************************************************************
    * Set Protocol Task for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_protocol_task       Cursor of Instituition Protocol_Taks_Link
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/19
    ********************************************************************************************/
    FUNCTION set_inst_protocol_task
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_protocol_task    pk_types.cursor_type;
        l_c_id_group_task       pk_types.cursor_type;
        l_c_descr_protocol_task pk_types.cursor_type;
        l_c_id_task_link        pk_types.cursor_type;
        l_c_task_type           pk_types.cursor_type;
        l_c_task_notes          pk_types.cursor_type;
        l_c_id_task_attach      pk_types.cursor_type;
        l_c_task_codif          pk_types.cursor_type;
    
        l_data_id_protocol_task    table_number;
        l_data_id_group_task       table_number;
        l_data_descr_protocol_task table_varchar;
        l_data_id_task_link        table_number;
        l_data_task_type           table_number;
        l_data_task_notes          table_varchar;
        l_data_id_task_attach      table_number;
        l_data_task_codif          table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_TASK ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_TASK';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_protocol_task(i_lang,
                                          i_market,
                                          i_version,
                                          i_id_institution,
                                          i_software(i),
                                          l_c_id_protocol_task,
                                          l_c_id_group_task,
                                          l_c_descr_protocol_task,
                                          l_c_id_task_link,
                                          l_c_task_type,
                                          l_c_task_notes,
                                          l_c_id_task_attach,
                                          l_c_task_codif,
                                          o_error)
            
            THEN
                RAISE l_exception;
            ELSE
                LOOP
                
                    FETCH l_c_id_protocol_task BULK COLLECT
                        INTO l_data_id_protocol_task LIMIT g_array_size;
                
                    FETCH l_c_id_group_task BULK COLLECT
                        INTO l_data_id_group_task LIMIT g_array_size;
                
                    FETCH l_c_descr_protocol_task BULK COLLECT
                        INTO l_data_descr_protocol_task LIMIT g_array_size;
                
                    FETCH l_c_id_task_link BULK COLLECT
                        INTO l_data_id_task_link LIMIT g_array_size;
                
                    FETCH l_c_task_type BULK COLLECT
                        INTO l_data_task_type LIMIT g_array_size;
                
                    FETCH l_c_task_notes BULK COLLECT
                        INTO l_data_task_notes LIMIT g_array_size;
                
                    FETCH l_c_id_task_attach BULK COLLECT
                        INTO l_data_id_task_attach LIMIT g_array_size;
                
                    FETCH l_c_task_codif BULK COLLECT
                        INTO l_data_task_codif LIMIT g_array_size;
                
                    FOR r IN 1 .. l_data_id_protocol_task.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_TASK (' || l_data_id_protocol_task(r) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_task
                            (id_protocol_task,
                             id_group_task,
                             desc_protocol_task,
                             id_task_link_old,
                             task_type,
                             task_notes,
                             id_task_attach,
                             task_codification,
                             id_task_link)
                        VALUES
                            (l_data_id_protocol_task(r),
                             l_data_id_group_task(r),
                             l_data_descr_protocol_task(r),
                             l_data_id_task_link(r),
                             l_data_task_type(r),
                             l_data_task_notes(r),
                             l_data_id_task_attach(r),
                             l_data_task_codif(r),
                             l_data_id_task_link(r));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol_task%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE l_c_id_protocol_task CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol_task;
            
                g_error := 'CLOSE l_c_id_group_task CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_group_task;
            
                g_error := 'CLOSE l_c_descr_protocol_task CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_descr_protocol_task;
            
                g_error := 'CLOSE l_c_id_task_link CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_task_link;
            
                g_error := 'CLOSE l_c_task_type CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_task_type;
            
                g_error := 'CLOSE l_c_task_notes CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_task_notes;
            
                g_error := 'CLOSE l_c_id_task_attach CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_task_attach;
            
                g_error := 'CLOSE l_c_task_codif CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_task_codif;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_task;
    /********************************************************************************************
    * Get Protocol Criteria set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol                  Cursor of Protocol ID 
    * @param o_criteria_type                Cursor of Criteria Type
    * @param o_gender                       Cursor of Gender
    * @param o_min_age                      Cursor of min age
    * @param o_max_age                      Cursor of max age
    * @param o_min_weight                   Cursor of min weight
    * @param o_max_weight                   Cursor of max weight
    * @param o_id_weight_unit_mea           Cursor of weight unit measure ID
    * @param o_min_height                   Cursor of min height
    * @param o_max_height                   Cursor of max height
    * @param o_id_height_unit_mea           Cursor of height unit measure ID
    * @param o_imc_min                      Cursor of min IMC
    * @param o_imc_max                      Cursor of max IMC
    * @param o_id_blood_pres_unit_mea       Cursor of Blood pressure unit measure ID
    * @param o_min_blood_press_s            Cursor of min Blood pressure sistolic
    * @param o_max_blood_press_s            Cursor of max Blood pressure sistolic
    * @param o_min_blood_press_d            Cursor of min Blood pressure diastolic
    * @param o_max_blood_press_d            Cursor of max Blood pressure diastolic
    * @param o_error                        Error  
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/03
    ********************************************************************************************/
    FUNCTION get_inst_protocol_criteria
    (
        i_lang                   IN language.id_language%TYPE,
        i_market                 IN table_number,
        i_version                IN table_varchar,
        i_id_institution         IN institution.id_institution%TYPE,
        i_id_software            IN software.id_software%TYPE,
        o_id_protocol            OUT pk_types.cursor_type,
        o_criteria_type          OUT pk_types.cursor_type,
        o_gender                 OUT pk_types.cursor_type,
        o_min_age                OUT pk_types.cursor_type,
        o_max_age                OUT pk_types.cursor_type,
        o_min_weight             OUT pk_types.cursor_type,
        o_max_weight             OUT pk_types.cursor_type,
        o_id_weight_unit_mea     OUT pk_types.cursor_type,
        o_min_height             OUT pk_types.cursor_type,
        o_max_height             OUT pk_types.cursor_type,
        o_id_height_unit_mea     OUT pk_types.cursor_type,
        o_imc_min                OUT pk_types.cursor_type,
        o_imc_max                OUT pk_types.cursor_type,
        o_id_blood_pres_unit_mea OUT pk_types.cursor_type,
        o_min_blood_press_s      OUT pk_types.cursor_type,
        o_max_blood_press_s      OUT pk_types.cursor_type,
        o_min_blood_press_d      OUT pk_types.cursor_type,
        o_max_blood_press_d      OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol            protocol_criteria.id_protocol%TYPE := NULL;
        l_id_protocol_def        protocol_criteria.id_protocol%TYPE := NULL;
        l_id_content_def         protocol.id_content%TYPE := NULL;
        l_criteria_type          protocol_criteria.criteria_type%TYPE := NULL;
        l_gender                 protocol_criteria.gender%TYPE := NULL;
        l_min_age                protocol_criteria.min_age%TYPE := NULL;
        l_max_age                protocol_criteria.max_age%TYPE := NULL;
        l_min_weight             protocol_criteria.min_weight%TYPE := NULL;
        l_max_weight             protocol_criteria.max_weight%TYPE := NULL;
        l_id_weight_unit_mea     protocol_criteria.id_weight_unit_measure%TYPE := NULL;
        l_min_height             protocol_criteria.min_height%TYPE := NULL;
        l_max_height             protocol_criteria.max_height%TYPE := NULL;
        l_id_height_unit_mea     protocol_criteria.id_height_unit_measure%TYPE := NULL;
        l_imc_min                protocol_criteria.imc_min%TYPE := NULL;
        l_imc_max                protocol_criteria.imc_max%TYPE := NULL;
        l_id_blood_pres_unit_mea protocol_criteria.id_blood_pressure_unit_measure%TYPE := NULL;
        l_min_blood_press_s      protocol_criteria.min_blood_pressure_s%TYPE := NULL;
        l_max_blood_press_s      protocol_criteria.max_blood_pressure_s%TYPE := NULL;
        l_min_blood_press_d      protocol_criteria.min_blood_pressure_d%TYPE := NULL;
        l_max_blood_press_d      protocol_criteria.max_blood_pressure_d%TYPE := NULL;
    
        l_id_protocol_array            table_number := table_number();
        l_criteria_type_array          table_varchar := table_varchar();
        l_gender_array                 table_varchar := table_varchar();
        l_min_age_array                table_number := table_number();
        l_max_age_array                table_number := table_number();
        l_min_weight_array             table_number := table_number();
        l_max_weight_array             table_number := table_number();
        l_id_weight_unit_mea_array     table_number := table_number();
        l_min_height_array             table_number := table_number();
        l_max_height_array             table_number := table_number();
        l_id_height_unit_mea_array     table_number := table_number();
        l_imc_min_array                table_number := table_number();
        l_imc_max_array                table_number := table_number();
        l_id_blood_pres_unit_mea_array table_number := table_number();
        l_min_blood_press_s_array      table_number := table_number();
        l_max_blood_press_s_array      table_number := table_number();
        l_min_blood_press_d_array      table_number := table_number();
        l_max_blood_press_d_array      table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_criteria
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT pc.id_protocol,
                            p.id_content,
                            pc.criteria_type,
                            pc.gender,
                            pc.min_age,
                            pc.max_age,
                            pc.min_weight,
                            pc.max_weight,
                            pc.id_weight_unit_measure,
                            pc.min_height,
                            pc.max_height,
                            pc.id_height_unit_measure,
                            pc.imc_min,
                            pc.imc_max,
                            pc.id_blood_pressure_unit_measure,
                            pc.min_blood_pressure_s,
                            pc.max_blood_pressure_s,
                            pc.min_blood_pressure_d,
                            pc.max_blood_pressure_d
              FROM alert_default.protocol_criteria pc
              JOIN alert_default.protocol p
                ON (p.id_protocol = pc.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pc.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version);
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_CRITERIA ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL_CRITERIA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_criteria(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_criteria
                        INTO l_id_protocol_def,
                             l_id_content_def,
                             l_criteria_type,
                             l_gender,
                             l_min_age,
                             l_max_age,
                             l_min_weight,
                             l_max_weight,
                             l_id_weight_unit_mea,
                             l_min_height,
                             l_max_height,
                             l_id_height_unit_mea,
                             l_imc_min,
                             l_imc_max,
                             l_id_blood_pres_unit_mea,
                             l_min_blood_press_s,
                             l_max_blood_press_s,
                             l_min_blood_press_d,
                             l_max_blood_press_d;
                    EXIT WHEN c_protocol_criteria%NOTFOUND;
                
                    g_error := 'GET ALERT ID_PROTOCOL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT p.id_protocol
                                 FROM protocol p
                                WHERE p.id_content = l_id_content_def
                                  AND p.id_content IS NOT NULL
                                  AND p.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_protocol
                      FROM dual;
                
                    IF l_id_protocol != 0
                    THEN
                        g_error := 'COUNT EXISTING CRITERIAS';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        SELECT COUNT(pc.id_protocol_criteria)
                          INTO l_count
                          FROM protocol_criteria pc
                         WHERE pc.id_protocol = l_id_protocol
                           AND pc.criteria_type = l_criteria_type;
                    
                        IF l_count = 0
                        THEN
                            l_id_protocol_array.extend;
                            l_criteria_type_array.extend;
                            l_gender_array.extend;
                            l_min_age_array.extend;
                            l_max_age_array.extend;
                            l_min_weight_array.extend;
                            l_max_weight_array.extend;
                            l_id_weight_unit_mea_array.extend;
                            l_min_height_array.extend;
                            l_max_height_array.extend;
                            l_id_height_unit_mea_array.extend;
                            l_imc_min_array.extend;
                            l_imc_max_array.extend;
                            l_id_blood_pres_unit_mea_array.extend;
                            l_min_blood_press_s_array.extend;
                            l_max_blood_press_s_array.extend;
                            l_min_blood_press_d_array.extend;
                            l_max_blood_press_d_array.extend;
                        
                            l_id_protocol_array(l_index) := l_id_protocol;
                            l_criteria_type_array(l_index) := l_criteria_type;
                            l_gender_array(l_index) := l_gender;
                            l_min_age_array(l_index) := l_min_age;
                            l_max_age_array(l_index) := l_max_age;
                            l_min_weight_array(l_index) := l_min_weight;
                            l_max_weight_array(l_index) := l_max_weight;
                            l_id_weight_unit_mea_array(l_index) := l_id_weight_unit_mea;
                            l_min_height_array(l_index) := l_min_height;
                            l_max_height_array(l_index) := l_max_height;
                            l_id_height_unit_mea_array(l_index) := l_id_height_unit_mea;
                            l_imc_min_array(l_index) := l_imc_min;
                            l_imc_max_array(l_index) := l_imc_max;
                            l_id_blood_pres_unit_mea_array(l_index) := l_id_blood_pres_unit_mea;
                            l_min_blood_press_s_array(l_index) := l_min_blood_press_s;
                            l_max_blood_press_s_array(l_index) := l_max_blood_press_s;
                            l_min_blood_press_d_array(l_index) := l_min_blood_press_d;
                            l_max_blood_press_d_array(l_index) := l_max_blood_press_d;
                        
                            l_index := l_index + 1;
                        
                        END IF;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_CRITERIA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_criteria;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_array AS table_number));
    
        g_error := 'CLOSE O_CRITERIA_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_criteria_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_criteria_type_array AS table_varchar));
    
        g_error := 'CLOSE O_GENDER CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_gender FOR
            SELECT column_value
              FROM TABLE(CAST(l_gender_array AS table_varchar));
    
        g_error := 'CLOSE O_MIN_AGE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_age FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_age_array AS table_number));
    
        g_error := 'CLOSE O_MAX_AGE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_age FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_age_array AS table_number));
    
        g_error := 'CLOSE O_MIN_WEIGHT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_weight FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_weight_array AS table_number));
    
        g_error := 'CLOSE O_MAX_WEIGHT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_weight FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_weight_array AS table_number));
    
        g_error := 'CLOSE O_ID_WEIGHT_UNIT_MEA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_weight_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_weight_unit_mea_array AS table_number));
    
        g_error := 'CLOSE O_MIN_HEIGHT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_height FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_height_array AS table_number));
    
        g_error := 'CLOSE O_MAX_HEIGHT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_height FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_height_array AS table_number));
    
        g_error := 'CLOSE O_ID_HEIGHT_UNIT_MEA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_height_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_height_unit_mea_array AS table_number));
    
        g_error := 'CLOSE O_IMC_MIN CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_imc_min FOR
            SELECT column_value
              FROM TABLE(CAST(l_imc_min_array AS table_number));
    
        g_error := 'CLOSE O_IMC_MAX CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_imc_max FOR
            SELECT column_value
              FROM TABLE(CAST(l_imc_max_array AS table_number));
    
        g_error := 'CLOSE O_ID_BLOOD_PRES_UNIT_MEA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_blood_pres_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_blood_pres_unit_mea_array AS table_number));
    
        g_error := 'CLOSE O_MIN_BLOOD_PRESS_S CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_blood_press_s FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_blood_press_s_array AS table_number));
    
        g_error := 'CLOSE O_MAX_BLOOD_PRESS_S CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_blood_press_s FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_blood_press_s_array AS table_number));
    
        g_error := 'CLOSE O_MIN_BLOOD_PRESS_D CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_blood_press_d FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_blood_press_d_array AS table_number));
    
        g_error := 'CLOSE O_MAX_BLOOD_PRESS_D CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_blood_press_d FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_blood_press_d_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol);
            pk_types.open_my_cursor(o_criteria_type);
            pk_types.open_my_cursor(o_gender);
            pk_types.open_my_cursor(o_min_age);
            pk_types.open_my_cursor(o_max_age);
            pk_types.open_my_cursor(o_min_weight);
            pk_types.open_my_cursor(o_max_weight);
            pk_types.open_my_cursor(o_id_weight_unit_mea);
            pk_types.open_my_cursor(o_min_height);
            pk_types.open_my_cursor(o_max_height);
            pk_types.open_my_cursor(o_id_height_unit_mea);
            pk_types.open_my_cursor(o_imc_min);
            pk_types.open_my_cursor(o_imc_max);
            pk_types.open_my_cursor(o_id_blood_pres_unit_mea);
            pk_types.open_my_cursor(o_min_blood_press_s);
            pk_types.open_my_cursor(o_max_blood_press_s);
            pk_types.open_my_cursor(o_min_blood_press_d);
            pk_types.open_my_cursor(o_max_blood_press_d);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_criteria;
    /*********************************************************************************************
    * Set Protocol Element for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_protocol_criteria   Cursor of Instituition Protocol_Criteria
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/04
    ********************************************************************************************/
    FUNCTION set_inst_protocol_criteria
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_software          IN table_number,
        o_protocol_criteria OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_protocol            pk_types.cursor_type;
        l_c_criteria_type          pk_types.cursor_type;
        l_c_gender                 pk_types.cursor_type;
        l_c_min_age                pk_types.cursor_type;
        l_c_max_age                pk_types.cursor_type;
        l_c_min_weight             pk_types.cursor_type;
        l_c_max_weight             pk_types.cursor_type;
        l_c_id_weight_unit_mea     pk_types.cursor_type;
        l_c_min_height             pk_types.cursor_type;
        l_c_max_height             pk_types.cursor_type;
        l_c_id_height_unit_mea     pk_types.cursor_type;
        l_c_imc_min                pk_types.cursor_type;
        l_c_imc_max                pk_types.cursor_type;
        l_c_id_blood_pres_unit_mea pk_types.cursor_type;
        l_c_min_blood_press_s      pk_types.cursor_type;
        l_c_max_blood_press_s      pk_types.cursor_type;
        l_c_min_blood_press_d      pk_types.cursor_type;
        l_c_max_blood_press_d      pk_types.cursor_type;
    
        l_data_id_protocol            table_number;
        l_data_criteria_type          table_varchar;
        l_data_gender                 table_varchar;
        l_data_min_age                table_number;
        l_data_max_age                table_number;
        l_data_min_weight             table_number;
        l_data_max_weight             table_number;
        l_data_id_weight_unit_mea     table_number;
        l_data_min_height             table_number;
        l_data_max_height             table_number;
        l_data_id_height_unit_mea     table_number;
        l_data_imc_min                table_number;
        l_data_imc_max                table_number;
        l_data_id_blood_pres_unit_mea table_number;
        l_data_min_blood_press_s      table_number;
        l_data_max_blood_press_s      table_number;
        l_data_min_blood_press_d      table_number;
        l_data_max_blood_press_d      table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_CRITERIA ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_CRITERIA';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_protocol_criteria(i_lang,
                                              i_market,
                                              i_version,
                                              i_id_institution,
                                              i_software(i),
                                              l_c_id_protocol,
                                              l_c_criteria_type,
                                              l_c_gender,
                                              l_c_min_age,
                                              l_c_max_age,
                                              l_c_min_weight,
                                              l_c_max_weight,
                                              l_c_id_weight_unit_mea,
                                              l_c_min_height,
                                              l_c_max_height,
                                              l_c_id_height_unit_mea,
                                              l_c_imc_min,
                                              l_c_imc_max,
                                              l_c_id_blood_pres_unit_mea,
                                              l_c_min_blood_press_s,
                                              l_c_max_blood_press_s,
                                              l_c_min_blood_press_d,
                                              l_c_max_blood_press_d,
                                              o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_protocol_criteria := l_c_id_protocol';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_protocol_criteria := l_c_id_protocol;
            
                LOOP
                
                    FETCH l_c_id_protocol BULK COLLECT
                        INTO l_data_id_protocol LIMIT g_array_size;
                    FETCH l_c_criteria_type BULK COLLECT
                        INTO l_data_criteria_type LIMIT g_array_size;
                    FETCH l_c_gender BULK COLLECT
                        INTO l_data_gender LIMIT g_array_size;
                    FETCH l_c_min_age BULK COLLECT
                        INTO l_data_min_age LIMIT g_array_size;
                    FETCH l_c_max_age BULK COLLECT
                        INTO l_data_max_age LIMIT g_array_size;
                    FETCH l_c_min_weight BULK COLLECT
                        INTO l_data_min_weight LIMIT g_array_size;
                    FETCH l_c_max_weight BULK COLLECT
                        INTO l_data_max_weight LIMIT g_array_size;
                    FETCH l_c_id_weight_unit_mea BULK COLLECT
                        INTO l_data_id_weight_unit_mea LIMIT g_array_size;
                    FETCH l_c_min_height BULK COLLECT
                        INTO l_data_min_height LIMIT g_array_size;
                    FETCH l_c_max_height BULK COLLECT
                        INTO l_data_max_height LIMIT g_array_size;
                    FETCH l_c_id_height_unit_mea BULK COLLECT
                        INTO l_data_id_height_unit_mea LIMIT g_array_size;
                    FETCH l_c_imc_min BULK COLLECT
                        INTO l_data_imc_min LIMIT g_array_size;
                    FETCH l_c_imc_max BULK COLLECT
                        INTO l_data_imc_max LIMIT g_array_size;
                    FETCH l_c_id_blood_pres_unit_mea BULK COLLECT
                        INTO l_data_id_blood_pres_unit_mea LIMIT g_array_size;
                    FETCH l_c_min_blood_press_s BULK COLLECT
                        INTO l_data_min_blood_press_s LIMIT g_array_size;
                    FETCH l_c_max_blood_press_s BULK COLLECT
                        INTO l_data_max_blood_press_s LIMIT g_array_size;
                    FETCH l_c_min_blood_press_d BULK COLLECT
                        INTO l_data_min_blood_press_d LIMIT g_array_size;
                    FETCH l_c_max_blood_press_d BULK COLLECT
                        INTO l_data_max_blood_press_d LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_CRITERIA (seq_protocol_criteria.NEXTVAL,' ||
                                   l_data_id_protocol(j) || ');';
                    
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_criteria
                            (id_protocol_criteria,
                             id_protocol,
                             criteria_type,
                             gender,
                             min_age,
                             max_age,
                             min_weight,
                             max_weight,
                             id_weight_unit_measure,
                             min_height,
                             max_height,
                             id_height_unit_measure,
                             imc_min,
                             imc_max,
                             id_blood_pressure_unit_measure,
                             min_blood_pressure_s,
                             max_blood_pressure_s,
                             min_blood_pressure_d,
                             max_blood_pressure_d)
                        VALUES
                            (seq_protocol_criteria.nextval,
                             l_data_id_protocol(j),
                             l_data_criteria_type(j),
                             l_data_gender(j),
                             l_data_min_age(j),
                             l_data_max_age(j),
                             l_data_min_weight(j),
                             l_data_max_weight(j),
                             l_data_id_weight_unit_mea(j),
                             l_data_min_height(j),
                             l_data_max_height(j),
                             l_data_id_height_unit_mea(j),
                             l_data_imc_min(j),
                             l_data_imc_max(j),
                             l_data_id_blood_pres_unit_mea(j),
                             l_data_min_blood_press_s(j),
                             l_data_max_blood_press_s(j),
                             l_data_min_blood_press_d(j),
                             l_data_max_blood_press_d(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol;
            
                g_error := 'CLOSE L_C_CRITERIA_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_criteria_type;
            
                g_error := 'CLOSE L_C_GENDER CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_gender;
            
                g_error := 'CLOSE L_C_MIN_AGE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_age;
            
                g_error := 'CLOSE L_C_MAX_AGE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_age;
            
                g_error := 'CLOSE L_C_MIN_WEIGHT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_weight;
            
                g_error := 'CLOSE L_C_MAX_WEIGHT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_weight;
            
                g_error := 'CLOSE L_C_ID_WEIGHT_UNIT_MEA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_weight_unit_mea;
            
                g_error := 'CLOSE L_C_MIN_HEIGHT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_height;
            
                g_error := 'CLOSE L_C_MAX_HEIGHT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_height;
            
                g_error := 'CLOSE L_C_ID_HEIGHT_UNIT_MEA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_height_unit_mea;
            
                g_error := 'CLOSE L_C_IMC_MIN CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_imc_min;
            
                g_error := 'CLOSE L_C_IMC_MAX CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_imc_max;
            
                g_error := 'CLOSE L_C_ID_BLOOD_PRES_UNIT_MEA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_blood_pres_unit_mea;
            
                g_error := 'CLOSE L_C_MIN_BLOOD_PRESS_S CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_blood_press_s;
            
                g_error := 'CLOSE L_C_MAX_BLOOD_PRESS_S CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_blood_press_s;
            
                g_error := 'CLOSE L_C_MIN_BLOOD_PRESS_D CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_blood_press_d;
            
                g_error := 'CLOSE L_C_MAX_BLOOD_PRESS_D CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_blood_press_d;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_criteria;
    /********************************************************************************************
    * Get Protocol Criteria Links set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol_criteria         Cursor of Protocol Criteria
    * @param o_id_link_other_criteria       Cursor of Link Other Criteria ID
    * @param o_id_link_other_criteria_type  Cursor of Link Other Criteria Type ID 
    * @param o_error                        Error  
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/05
    ********************************************************************************************/
    FUNCTION get_inst_protocol_crit_link
    (
        i_lang                    IN language.id_language%TYPE,
        i_market                  IN table_number,
        i_version                 IN table_varchar,
        i_id_institution          IN institution.id_institution%TYPE,
        i_id_software             IN software.id_software%TYPE,
        o_id_protocol_criteria    OUT pk_types.cursor_type,
        o_id_link_other_criteria  OUT pk_types.cursor_type,
        o_id_link_other_crit_type OUT pk_types.cursor_type,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol_criteria_def protocol_criteria_link.id_protocol_criteria%TYPE;
        l_id_link_other_criteria   protocol_criteria_link.id_link_other_criteria%TYPE;
        l_id_link_other_crit_type  protocol_criteria_link.id_link_other_criteria_type%TYPE;
        l_id_protocol              protocol.id_protocol%TYPE;
        l_protocol_content         protocol.id_content%TYPE;
        l_id_protocol_criteria     protocol_criteria.id_protocol_criteria%TYPE;
    
        l_criteria_type_def protocol_criteria.criteria_type%TYPE;
        l_criteria_type     protocol_criteria.criteria_type%TYPE;
    
        l_id_protocol_criteria_array   table_number := table_number();
        l_id_link_other_criteria_array table_number := table_number();
        l_id_link_other_cri_type_array table_number := table_number();
    
        l_index NUMBER := 1;
    
        l_id_analysis    analysis.id_analysis%TYPE := NULL;
        l_count_analysis NUMBER := 0;
    
        l_id_diagnosis    diagnosis.id_diagnosis%TYPE := NULL;
        l_count_diagnosis NUMBER := 0;
    
        l_id_img_exams    exam.id_exam%TYPE := NULL;
        l_count_img_exams NUMBER := 0;
    
        l_id_other_exams    exam.id_exam%TYPE := NULL;
        l_count_other_exams NUMBER := 0;
    
        l_id_icnp_diag    icnp_composition.id_composition%TYPE := NULL;
        l_count_icnp_diag NUMBER := 0;
    
        l_id_allergy    allergy.id_allergy%TYPE := NULL;
        l_count_allergy NUMBER := 0;
    
        CURSOR c_protocol_criteria_link
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT pcl.id_protocol_criteria,
                            pcl.id_link_other_criteria,
                            pcl.id_link_other_criteria_type,
                            p.id_content,
                            pc.criteria_type
              FROM alert_default.protocol_criteria_link pcl
              JOIN alert_default.protocol_criteria pc
                ON (pc.id_protocol_criteria = pcl.id_protocol_criteria)
              JOIN protocol_criteria_type pct
                ON (pct.id_protocol_criteria_type = pcl.id_link_other_criteria_type)
              JOIN alert_default.protocol p
                ON (p.id_protocol = pc.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pc.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version);
    
        CURSOR c_protocol_criteria(c_id_protocol IN protocol.id_protocol%TYPE) IS
            SELECT DISTINCT pc.id_protocol_criteria, pc.criteria_type
              FROM protocol_criteria pc
              JOIN protocol p1
                ON (p1.id_protocol = pc.id_protocol AND p1.id_protocol = c_id_protocol)
              JOIN alert_default.protocol p2
                ON (p2.id_content = p1.id_content)
              JOIN alert_default.protocol_criteria pc2
                ON (pc2.id_protocol = p2.id_protocol AND pc2.criteria_type = pc.criteria_type);
    
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_CRIT_LINK ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_PROTOCOL_CRITERIA_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_criteria_link(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_criteria_link
                        INTO l_id_protocol_criteria_def,
                             l_id_link_other_criteria,
                             l_id_link_other_crit_type,
                             l_protocol_content,
                             l_criteria_type_def;
                    EXIT WHEN c_protocol_criteria_link%NOTFOUND;
                
                    IF l_protocol_content IS NOT NULL
                    THEN
                        g_error := 'GET ALERT PROTOCOL ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        SELECT nvl((SELECT p.id_protocol
                                     FROM protocol p
                                    WHERE p.id_content = l_protocol_content
                                      AND p.id_content IS NOT NULL
                                      AND p.id_institution = i_id_institution
                                      AND rownum = 1),
                                   0)
                          INTO l_id_protocol
                          FROM dual;
                    
                        IF l_id_protocol != 0
                        THEN
                            g_error := 'OPEN C_PROTOCOL_CRITERIA CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            OPEN c_protocol_criteria(l_id_protocol);
                            LOOP
                                FETCH c_protocol_criteria
                                    INTO l_id_protocol_criteria, l_criteria_type;
                                EXIT WHEN c_protocol_criteria%NOTFOUND;
                            
                                IF l_id_protocol_criteria IS NOT NULL
                                   AND l_criteria_type_def = l_criteria_type
                                THEN
                                    --> Allergy
                                    IF l_id_link_other_crit_type = 1
                                    THEN
                                        SELECT nvl((SELECT a.id_allergy
                                                     FROM allergy a
                                                     JOIN allergy_inst_soft ais
                                                       ON (ais.id_allergy = a.id_allergy AND
                                                          ais.id_institution = i_id_institution)
                                                   --No valida por sw                 
                                                    WHERE a.id_allergy = l_id_link_other_criteria
                                                      AND a.flg_available = g_flg_available
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_allergy
                                          FROM dual;
                                    
                                        IF l_id_allergy != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by ALLERGY';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(pcl.id_protocol_criteria_link)
                                              INTO l_count_allergy
                                              FROM protocol_criteria_link pcl
                                             WHERE pcl.id_protocol_criteria = l_id_protocol_criteria
                                               AND pcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND pcl.id_link_other_criteria = l_id_allergy;
                                        
                                            IF l_count_allergy = 0
                                            THEN
                                                l_id_protocol_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_protocol_criteria_array(l_index) := l_id_protocol_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_allergy;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        
                                        END IF;
                                    END IF;
                                    --> Analysis
                                    IF l_id_link_other_crit_type = 2
                                    THEN
                                        g_error := 'GET ALERT ID_ANALYSIS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        SELECT nvl((SELECT a.id_analysis
                                                     FROM analysis a
                                                     JOIN analysis_instit_soft ais
                                                       ON (ais.id_analysis = a.id_analysis AND
                                                          ais.id_institution = i_id_institution AND
                                                          ais.flg_available = g_flg_available)
                                                   -->No valida por sw
                                                     JOIN analysis_param ap
                                                       ON (ap.id_analysis = a.id_analysis AND
                                                          ap.flg_available = g_flg_available)
                                                   -->No valida por sw                  
                                                    WHERE a.id_content =
                                                          (SELECT a2.id_content
                                                             FROM alert_default.analysis a2
                                                            WHERE a2.id_analysis = l_id_link_other_criteria
                                                              AND a2.flg_available = g_flg_available)
                                                      AND a.id_content IS NOT NULL
                                                      AND a.flg_available = g_flg_available
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_analysis
                                          FROM dual;
                                    
                                        IF l_id_analysis != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by ANALYSIS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(pcl.id_protocol_criteria_link)
                                              INTO l_count_analysis
                                              FROM protocol_criteria_link pcl
                                             WHERE pcl.id_protocol_criteria = l_id_protocol_criteria
                                               AND pcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND pcl.id_link_other_criteria = l_id_analysis;
                                        
                                            IF l_count_analysis = 0
                                            THEN
                                                l_id_protocol_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_protocol_criteria_array(l_index) := l_id_protocol_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_analysis;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                    --> Diagnosis
                                    IF l_id_link_other_crit_type = 3
                                    THEN
                                        SELECT nvl((SELECT d.id_diagnosis
                                                     FROM diagnosis d
                                                     JOIN diagnosis_dep_clin_serv ddcs
                                                       ON (ddcs.id_diagnosis = d.id_diagnosis AND
                                                          ddcs.id_institution = i_id_institution AND
                                                          ddcs.flg_type = pk_diagnosis.g_diag_pesq)
                                                   --No valida por sw                 
                                                    WHERE d.id_diagnosis = l_id_link_other_criteria
                                                      AND d.flg_available = g_flg_available
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_diagnosis
                                          FROM dual;
                                    
                                        IF l_id_diagnosis != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by DIAGNOSIS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(pcl.id_protocol_criteria_link)
                                              INTO l_count_diagnosis
                                              FROM protocol_criteria_link pcl
                                             WHERE pcl.id_protocol_criteria = l_id_protocol_criteria
                                               AND pcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND pcl.id_link_other_criteria = l_id_diagnosis;
                                        
                                            IF l_count_diagnosis = 0
                                            THEN
                                                l_id_protocol_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_protocol_criteria_array(l_index) := l_id_protocol_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_diagnosis;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        
                                        END IF;
                                    END IF;
                                    --> Image Exams
                                    IF l_id_link_other_crit_type = 4
                                    THEN
                                        g_error := 'GET ALERT ID_IMG_EXAMS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        SELECT nvl((SELECT e.id_exam
                                                     FROM exam e
                                                     JOIN exam_dep_clin_serv edcs
                                                       ON (edcs.id_exam = e.id_exam AND
                                                          edcs.id_institution = i_id_institution AND
                                                          edcs.flg_type = pk_exam_constant.g_exam_can_req)
                                                   --No valida por sw
                                                    WHERE e.id_content =
                                                          (SELECT e2.id_content
                                                             FROM alert_default.exam e2
                                                            WHERE e2.id_exam = l_id_link_other_criteria
                                                              AND e2.flg_available = g_flg_available)
                                                      AND e.id_content IS NOT NULL
                                                      AND e.flg_available = g_flg_available
                                                      AND e.flg_type = pk_exam_constant.g_type_img
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_img_exams
                                          FROM dual;
                                    
                                        IF l_id_img_exams != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by IMG_EXAMS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(pcl.id_protocol_criteria_link)
                                              INTO l_count_img_exams
                                              FROM protocol_criteria_link pcl
                                             WHERE pcl.id_protocol_criteria = l_id_protocol_criteria
                                               AND pcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND pcl.id_link_other_criteria = l_id_img_exams;
                                        
                                            IF l_count_img_exams = 0
                                            THEN
                                                l_id_protocol_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_protocol_criteria_array(l_index) := l_id_protocol_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_img_exams;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                    --> Other Exams
                                    IF l_id_link_other_crit_type = 6
                                    THEN
                                        g_error := 'GET ALERT ID_OTHER_EXAMS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        SELECT nvl((SELECT e.id_exam
                                                     FROM exam e
                                                     JOIN exam_dep_clin_serv edcs
                                                       ON (edcs.id_exam = e.id_exam AND
                                                          edcs.id_institution = i_id_institution AND
                                                          edcs.flg_type = pk_exam_constant.g_exam_can_req)
                                                   --No valida por sw
                                                    WHERE e.id_content =
                                                          (SELECT e2.id_content
                                                             FROM alert_default.exam e2
                                                            WHERE e2.id_exam = l_id_link_other_criteria
                                                              AND e2.flg_available = g_flg_available)
                                                      AND e.id_content IS NOT NULL
                                                      AND e.flg_available = g_flg_available
                                                      AND e.flg_type = pk_exam_constant.g_type_exm
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_other_exams
                                          FROM dual;
                                    
                                        IF l_id_other_exams != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by OTHER_EXAMS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(pcl.id_protocol_criteria_link)
                                              INTO l_count_other_exams
                                              FROM protocol_criteria_link pcl
                                             WHERE pcl.id_protocol_criteria = l_id_protocol_criteria
                                               AND pcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND pcl.id_link_other_criteria = l_id_other_exams;
                                        
                                            IF l_count_other_exams = 0
                                            THEN
                                                l_id_protocol_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_protocol_criteria_array(l_index) := l_id_protocol_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_other_exams;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                    --> ICNP Diagnosis
                                    IF l_id_link_other_crit_type = 7
                                    THEN
                                        g_error := 'GET ALERT ID_ICNP_DIAGNOSIS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        SELECT nvl((SELECT DISTINCT ic.id_composition
                                                     FROM icnp_composition ic
                                                     JOIN icnp_predefined_action ipa
                                                       ON (ipa.id_composition_parent = ic.id_composition AND
                                                          ipa.id_institution = i_id_institution AND
                                                          ipa.flg_available = g_flg_available)
                                                    WHERE ic.id_content =
                                                         --No valida por sw
                                                          (SELECT ic2.id_content
                                                             FROM alert_default.icnp_composition ic2
                                                             JOIN alert_default.icnp_predefined_action ipa2
                                                               ON (ipa2.id_composition_parent = ic2.id_composition AND
                                                                  ipa2.flg_available = g_flg_available AND
                                                                  ipa2.version = i_version(i) AND
                                                                  ipa2.id_market = i_market(j))
                                                            WHERE ic2.id_composition = l_id_link_other_criteria
                                                              AND ic2.flg_available = g_flg_available
                                                              AND ic2.id_software = i_id_software)
                                                      AND ic.id_content IS NOT NULL
                                                      AND ic.flg_available = g_flg_available
                                                      AND ic.flg_type = 'D'
                                                      AND ic.id_software = i_id_software
                                                      AND ic.id_institution = i_id_institution
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_icnp_diag
                                          FROM dual;
                                    
                                        IF l_id_icnp_diag != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by ICNP_DIAGNOSIS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(pcl.id_protocol_criteria_link)
                                              INTO l_count_icnp_diag
                                              FROM protocol_criteria_link pcl
                                             WHERE pcl.id_protocol_criteria = l_id_protocol_criteria
                                               AND pcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND pcl.id_link_other_criteria = l_id_icnp_diag;
                                        
                                            IF l_count_icnp_diag = 0
                                            THEN
                                                l_id_protocol_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_protocol_criteria_array(l_index) := l_id_protocol_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_icnp_diag;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_PROTOCOL_CRITERIA CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_protocol_criteria;
                        END IF;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_CRITERIA_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_criteria_link;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_PROTOCOL_CRITERIA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_criteria FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_criteria_array AS table_number));
    
        g_error := 'OPEN O_ID_LINK_OTHER_CRITERIA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_link_other_criteria FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_link_other_criteria_array AS table_number));
    
        g_error := 'OPEN O_ID_LINK_OTHER_CRIT_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_link_other_crit_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_link_other_cri_type_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol_criteria);
            pk_types.open_my_cursor(o_id_link_other_criteria);
            pk_types.open_my_cursor(o_id_link_other_crit_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_crit_link;
    /*********************************************************************************************
    * Set Protocol Criteria Link for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_protocol_criteria_link   Cursor of Instituition Protocol_Criteria_Link
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/05
    ********************************************************************************************/
    FUNCTION set_inst_protocol_crit_link
    (
        i_lang                   IN language.id_language%TYPE,
        i_market                 IN table_number,
        i_version                IN table_varchar,
        i_id_institution         IN institution.id_institution%TYPE,
        i_software               IN table_number,
        o_protocol_criteria_link OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_protocol_criteria pk_types.cursor_type;
        l_c_id_lk_oth_criteria   pk_types.cursor_type;
        l_c_id_lk_oth_cri_type   pk_types.cursor_type;
    
        l_data_id_protocol_criteria table_number;
        l_data_id_lk_oth_criteria   table_number;
        l_data_id_lk_oth_cri_type   table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_CRIT_LINK ';
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_CRITERIA_LINK';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_protocol_crit_link(i_lang,
                                               i_market,
                                               i_version,
                                               i_id_institution,
                                               i_software(i),
                                               l_c_id_protocol_criteria,
                                               l_c_id_lk_oth_criteria,
                                               l_c_id_lk_oth_cri_type,
                                               o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_protocol_criteria_link := l_c_id_protocol_criteria';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_protocol_criteria_link := l_c_id_protocol_criteria;
            
                LOOP
                
                    FETCH l_c_id_protocol_criteria BULK COLLECT
                        INTO l_data_id_protocol_criteria LIMIT g_array_size;
                
                    FETCH l_c_id_lk_oth_criteria BULK COLLECT
                        INTO l_data_id_lk_oth_criteria LIMIT g_array_size;
                
                    FETCH l_c_id_lk_oth_cri_type BULK COLLECT
                        INTO l_data_id_lk_oth_cri_type LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol_criteria.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_CRITERIA_LINK (seq_protocol_criteria_link.NEXTVAL,' ||
                                   l_data_id_protocol_criteria(j) || ');';
                    
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_criteria_link
                            (id_protocol_criteria_link,
                             id_protocol_criteria,
                             id_link_other_criteria_old,
                             id_link_other_criteria_type,
                             id_link_other_criteria)
                        VALUES
                            (seq_protocol_criteria_link.nextval,
                             l_data_id_protocol_criteria(j),
                             l_data_id_lk_oth_criteria(j),
                             l_data_id_lk_oth_cri_type(j),
                             l_data_id_lk_oth_criteria(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol_criteria%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL_CRITERIA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol_criteria;
            
                g_error := 'CLOSE L_C_ID_LINK_OTHER_CRITERIA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_lk_oth_criteria;
            
                g_error := 'CLOSE L_C_ID_LINK_OTHER_CRITERIA_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_lk_oth_cri_type;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_crit_link;
    /********************************************************************************************
    * Get Protocol ADV Input Value set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_adv_input_link            Cursor of adv input link
    * @param o_flg_type                     Cursor of Flg Type
    * @param o_value_type                   Cursor of Value Type
    * @param o_nvalue                       Cursor of n Value
    * @param o_dvalue                       Cursor of d Value
    * @param o_vvalue                       Cursor of v Value
    * @param o_vvalue_desc                  Cursor of v Value Description
    * @param o_criteria_value_type          Cursor of Criteria Value Type
    * @param o_id_adv_input                 Cursor of adv input
    * @param o_id_adv_input_field           Cursor of adv input field
    * @param o_id_adv_input_field_det       Cursor of adv input field det
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/04
    ********************************************************************************************/
    FUNCTION get_inst_prtcl_adv_input_value
    (
        i_lang                   IN language.id_language%TYPE,
        i_market                 IN table_number,
        i_version                IN table_varchar,
        i_id_software            IN software.id_software%TYPE,
        o_id_adv_input_link      OUT pk_types.cursor_type,
        o_flg_type               OUT pk_types.cursor_type,
        o_value_type             OUT pk_types.cursor_type,
        o_nvalue                 OUT pk_types.cursor_type,
        o_dvalue                 OUT pk_types.cursor_type,
        o_vvalue                 OUT pk_types.cursor_type,
        o_vvalue_desc            OUT pk_types.cursor_type,
        o_criteria_value_type    OUT pk_types.cursor_type,
        o_id_adv_input           OUT pk_types.cursor_type,
        o_id_adv_input_field     OUT pk_types.cursor_type,
        o_id_adv_input_field_det OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_adv_input_link      protocol_adv_input_value.id_adv_input_link%TYPE := NULL;
        l_flg_type               protocol_adv_input_value.flg_type%TYPE := NULL;
        l_value_type             protocol_adv_input_value.value_type%TYPE := NULL;
        l_nvalue                 protocol_adv_input_value.nvalue%TYPE := NULL;
        l_dvalue                 protocol_adv_input_value.dvalue%TYPE := NULL;
        l_vvalue                 protocol_adv_input_value.vvalue%TYPE := NULL;
        l_vvalue_desc            protocol_adv_input_value.value_desc%TYPE := NULL;
        l_criteria_value_type    protocol_adv_input_value.criteria_value_type%TYPE := NULL;
        l_id_adv_input           protocol_adv_input_value.id_advanced_input%TYPE := NULL;
        l_id_adv_input_field     protocol_adv_input_value.id_advanced_input_field%TYPE := NULL;
        l_id_adv_input_field_det protocol_adv_input_value.id_advanced_input_field_det%TYPE := NULL;
    
        l_id_adv_input_link_array      table_number := table_number();
        l_flg_type_array               table_varchar := table_varchar();
        l_value_type_array             table_varchar := table_varchar();
        l_nvalue_array                 table_number := table_number();
        l_dvalue_array                 table_date := table_date();
        l_vvalue_array                 table_varchar := table_varchar();
        l_vvalue_desc_array            table_varchar := table_varchar();
        l_criteria_value_type_array    table_number := table_number();
        l_id_adv_input_array           table_number := table_number();
        l_id_adv_input_field_array     table_number := table_number();
        l_id_adv_input_field_det_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        l_var_t VARCHAR2(1) := pk_protocol.g_adv_input_type_tasks;
        l_var_c VARCHAR2(1) := pk_protocol.g_adv_input_type_criterias;
    
        CURSOR c_prtcl_adv_input_value
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT paiv.id_adv_input_link,
                            paiv.flg_type,
                            paiv.value_type,
                            paiv.nvalue,
                            paiv.dvalue,
                            paiv.vvalue,
                            paiv.value_desc,
                            paiv.criteria_value_type,
                            paiv.id_advanced_input,
                            paiv.id_advanced_input_field,
                            paiv.id_advanced_input_field_det
              FROM alert_default.protocol_adv_input_value paiv
              JOIN alert_default.protocol_criteria pc
                ON (pc.id_protocol_criteria = paiv.id_adv_input_link)
              JOIN alert_default.protocol p
                ON (p.id_protocol = pc.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pc.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version)
             WHERE paiv.flg_type = l_var_c
            UNION ALL
            SELECT DISTINCT paiv.id_adv_input_link,
                            paiv.flg_type,
                            paiv.value_type,
                            paiv.nvalue,
                            paiv.dvalue,
                            paiv.vvalue,
                            paiv.value_desc,
                            paiv.criteria_value_type,
                            paiv.id_advanced_input,
                            paiv.id_advanced_input_field,
                            paiv.id_advanced_input_field_det
              FROM alert_default.protocol_adv_input_value paiv
              JOIN alert_default.protocol_task pt
                ON (pt.id_protocol_task = paiv.id_adv_input_link)
              JOIN alert_default.protocol_element pe
                ON (pe.id_element = pt.id_group_task AND pe.element_type = l_var_t AND pe.flg_available = g_yes)
              JOIN alert_default.protocol p
                ON (p.id_protocol = pe.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pe.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version)
             WHERE paiv.flg_type = l_var_t;
    
    BEGIN
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL_ADV_INPUT_VALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                OPEN c_prtcl_adv_input_value(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_prtcl_adv_input_value
                        INTO l_id_adv_input_link,
                             l_flg_type,
                             l_value_type,
                             l_nvalue,
                             l_dvalue,
                             l_vvalue,
                             l_vvalue_desc,
                             l_criteria_value_type,
                             l_id_adv_input,
                             l_id_adv_input_field,
                             l_id_adv_input_field_det;
                    EXIT WHEN c_prtcl_adv_input_value%NOTFOUND;
                
                    g_error := 'COUNT PROTOCOL_ADV_INPUT_VALUE';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                    SELECT COUNT(p.id_protocol_adv_input_value)
                      INTO l_count
                      FROM protocol_adv_input_value p
                     WHERE p.id_adv_input_link = l_id_adv_input_link
                       AND p.flg_type = l_flg_type
                       AND p.id_advanced_input = l_id_adv_input
                       AND p.id_advanced_input_field = l_id_adv_input_field
                       AND (p.id_advanced_input_field_det = l_id_adv_input_field_det OR
                           p.id_advanced_input_field_det IS NULL);
                
                    g_error := 'IF COUNT PROTOCOL_ADV_INPUT_VALUE = 0';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                    IF l_count = 0
                    THEN
                        l_id_adv_input_link_array.extend;
                        l_flg_type_array.extend;
                        l_value_type_array.extend;
                        l_nvalue_array.extend;
                        l_dvalue_array.extend;
                        l_vvalue_array.extend;
                        l_vvalue_desc_array.extend;
                        l_criteria_value_type_array.extend;
                        l_id_adv_input_array.extend;
                        l_id_adv_input_field_array.extend;
                        l_id_adv_input_field_det_array.extend;
                    
                        l_id_adv_input_link_array(l_index) := l_id_adv_input_link;
                        l_flg_type_array(l_index) := l_flg_type;
                        l_value_type_array(l_index) := l_value_type;
                        l_nvalue_array(l_index) := l_nvalue;
                        l_dvalue_array(l_index) := l_dvalue;
                        l_vvalue_array(l_index) := l_vvalue;
                        l_vvalue_desc_array(l_index) := l_vvalue_desc;
                        l_criteria_value_type_array(l_index) := l_criteria_value_type;
                        l_id_adv_input_array(l_index) := l_id_adv_input;
                        l_id_adv_input_field_array(l_index) := l_id_adv_input_field;
                        l_id_adv_input_field_det_array(l_index) := l_id_adv_input_field_det;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_ADV_INPUT_VALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE c_prtcl_adv_input_value;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_ADV_INPUT_LINK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_id_adv_input_link FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_link_array AS table_number));
    
        g_error := 'CLOSE O_FLG_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_type_array AS table_varchar));
    
        g_error := 'CLOSE O_VALUE_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_value_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_value_type_array AS table_varchar));
    
        g_error := 'CLOSE O_NVALUE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_nvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_nvalue_array AS table_number));
    
        g_error := 'CLOSE O_DVALUE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_dvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_dvalue_array AS table_date));
    
        g_error := 'CLOSE O_VVALUE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_vvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_vvalue_array AS table_varchar));
    
        g_error := 'CLOSE O_VVALUE_DESC CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_vvalue_desc FOR
            SELECT column_value
              FROM TABLE(CAST(l_vvalue_desc_array AS table_varchar));
    
        g_error := 'CLOSE O_CRITERIA_VALUE_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_criteria_value_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_criteria_value_type_array AS table_number));
    
        g_error := 'CLOSE O_ID_ADV_INPUT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_id_adv_input FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_array AS table_number));
    
        g_error := 'CLOSE O_ID_ADV_INPUT_FIELD CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_id_adv_input_field FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_field_array AS table_number));
    
        g_error := 'CLOSE O_ID_ADV_INPUT_FIELD_DET CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        OPEN o_id_adv_input_field_det FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_field_det_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_PROTOCOL_ADV_INPUT_VALUE',
                                              o_error);
            pk_types.open_my_cursor(o_id_adv_input_link);
            pk_types.open_my_cursor(o_flg_type);
            pk_types.open_my_cursor(o_value_type);
            pk_types.open_my_cursor(o_nvalue);
            pk_types.open_my_cursor(o_dvalue);
            pk_types.open_my_cursor(o_vvalue);
            pk_types.open_my_cursor(o_vvalue_desc);
            pk_types.open_my_cursor(o_criteria_value_type);
            pk_types.open_my_cursor(o_id_adv_input);
            pk_types.open_my_cursor(o_id_adv_input_field);
            pk_types.open_my_cursor(o_id_adv_input_field_det);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_prtcl_adv_input_value;
    /*********************************************************************************************
    * Set Protocol AVD Input VAlue for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param i_software                Software ID's
    * @param o_prtcl_adv_input_value   Cursor of Instituition Protocol_Advanced_Input_Value
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6
    * @since                           2010/05/04
    ********************************************************************************************/
    FUNCTION set_inst_prtcl_adv_input_value
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_software              IN table_number,
        o_prtcl_adv_input_value OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_adv_input_link      pk_types.cursor_type;
        l_c_flg_type               pk_types.cursor_type;
        l_c_value_type             pk_types.cursor_type;
        l_c_nvalue                 pk_types.cursor_type;
        l_c_dvalue                 pk_types.cursor_type;
        l_c_vvalue                 pk_types.cursor_type;
        l_c_vvalue_desc            pk_types.cursor_type;
        l_c_criteria_value_type    pk_types.cursor_type;
        l_c_id_adv_input           pk_types.cursor_type;
        l_c_id_adv_input_field     pk_types.cursor_type;
        l_c_id_adv_input_field_det pk_types.cursor_type;
    
        l_data_id_adv_input_link      table_number;
        l_data_flg_type               table_varchar;
        l_data_value_type             table_varchar;
        l_data_nvalue                 table_number;
        l_data_dvalue                 table_date;
        l_data_vvalue                 table_varchar;
        l_data_vvalue_desc            table_varchar;
        l_data_criteria_value_type    table_number;
        l_data_id_adv_input           table_number;
        l_data_id_adv_input_field     table_number;
        l_data_id_adv_input_field_det table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PRTCL_ADV_INPUT_VALUE';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
        
            IF NOT get_inst_prtcl_adv_input_value(i_lang,
                                                  i_market,
                                                  i_version,
                                                  i_software(i),
                                                  l_c_id_adv_input_link,
                                                  l_c_flg_type,
                                                  l_c_value_type,
                                                  l_c_nvalue,
                                                  l_c_dvalue,
                                                  l_c_vvalue,
                                                  l_c_vvalue_desc,
                                                  l_c_criteria_value_type,
                                                  l_c_id_adv_input,
                                                  l_c_id_adv_input_field,
                                                  l_c_id_adv_input_field_det,
                                                  o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_prtcl_adv_input_value := l_c_id_adv_input_link';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
            
                o_prtcl_adv_input_value := l_c_id_adv_input_link;
            
                LOOP
                
                    FETCH l_c_id_adv_input_link BULK COLLECT
                        INTO l_data_id_adv_input_link LIMIT g_array_size;
                    FETCH l_c_flg_type BULK COLLECT
                        INTO l_data_flg_type LIMIT g_array_size;
                    FETCH l_c_value_type BULK COLLECT
                        INTO l_data_value_type LIMIT g_array_size;
                    FETCH l_c_nvalue BULK COLLECT
                        INTO l_data_nvalue LIMIT g_array_size;
                    FETCH l_c_dvalue BULK COLLECT
                        INTO l_data_dvalue LIMIT g_array_size;
                    FETCH l_c_vvalue BULK COLLECT
                        INTO l_data_vvalue LIMIT g_array_size;
                    FETCH l_c_vvalue_desc BULK COLLECT
                        INTO l_data_vvalue_desc LIMIT g_array_size;
                    FETCH l_c_criteria_value_type BULK COLLECT
                        INTO l_data_criteria_value_type LIMIT g_array_size;
                    FETCH l_c_id_adv_input BULK COLLECT
                        INTO l_data_id_adv_input LIMIT g_array_size;
                    FETCH l_c_id_adv_input_field BULK COLLECT
                        INTO l_data_id_adv_input_field LIMIT g_array_size;
                    FETCH l_c_id_adv_input_field_det BULK COLLECT
                        INTO l_data_id_adv_input_field_det LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_adv_input_link.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_ADV_INPUT_VALUE (seq_protocol_adv_input_value.nextval,' ||
                                   l_data_id_adv_input_link(j) || ');';
                    
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                    
                        INSERT INTO protocol_adv_input_value
                            (id_protocol_adv_input_value,
                             id_adv_input_link,
                             flg_type,
                             value_type,
                             nvalue,
                             dvalue,
                             vvalue,
                             value_desc,
                             criteria_value_type,
                             id_advanced_input,
                             id_advanced_input_field,
                             id_advanced_input_field_det)
                        VALUES
                            (seq_protocol_adv_input_value.nextval,
                             l_data_id_adv_input_link(j),
                             l_data_flg_type(j),
                             l_data_value_type(j),
                             l_data_nvalue(j),
                             l_data_dvalue(j),
                             l_data_vvalue(j),
                             l_data_vvalue_desc(j),
                             l_data_criteria_value_type(j),
                             l_data_id_adv_input(j),
                             l_data_id_adv_input_field(j),
                             l_data_id_adv_input_field_det(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_adv_input_link%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_ADV_INPUT_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_id_adv_input_link;
            
                g_error := 'CLOSE L_C_FLG_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_flg_type;
            
                g_error := 'CLOSE L_C_VALUE_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_value_type;
            
                g_error := 'CLOSE L_C_NVALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_nvalue;
            
                g_error := 'CLOSE L_C_DVALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_dvalue;
            
                g_error := 'CLOSE L_C_VVALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_vvalue;
            
                g_error := 'CLOSE L_C_VVALUE_DESC CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_vvalue_desc;
            
                g_error := 'CLOSE L_C_CRITERIA_VALUE_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_criteria_value_type;
            
                g_error := 'CLOSE L_C_ID_ADV_INPUT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_id_adv_input;
            
                g_error := 'CLOSE L_C_ID_ADV_INPUT_FIELD CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_id_adv_input_field;
            
                g_error := 'CLOSE L_C_ID_ADV_INPUT_FIELD_DET CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_PROTOCOL_ADV_INPUT_VALUE ' || g_error);
                CLOSE l_c_id_adv_input_field_det;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_PROTOCOL_ADV_INPUT_VALUE',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_PROTOCOL_ADV_INPUT_VALUE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_prtcl_adv_input_value;
    /********************************************************************************************
    * Get Protocol Connector set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param o_id_protocol_connector        Cursor of Protocol Connector ID
    * @param o_desc_protocol_connector      Cursor of Protocol Connector Description
    * @param o_flg_desc_protocol_conn       Cursor of Flg Description Protocol Connector  
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/04
    ********************************************************************************************/
    FUNCTION get_inst_protocol_connector
    (
        i_lang                        IN language.id_language%TYPE,
        o_id_protocol_connector       OUT pk_types.cursor_type,
        o_desc_protocol_connector     OUT pk_types.cursor_type,
        o_flg_desc_protocol_connector OUT pk_types.cursor_type,
        o_error                       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol_connector       protocol_connector.id_protocol_connector%TYPE := NULL;
        l_descr_protocol_connector    protocol_connector.desc_protocol_connector%TYPE := NULL;
        l_flg_desc_protocol_connector protocol_connector.flg_desc_protocol_connector%TYPE := NULL;
    
        l_id_protocol_connector_array  table_number := table_number();
        l_descr_protocol_conn_array    table_varchar := table_varchar();
        l_flg_desc_protocol_conn_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_connector IS
            SELECT DISTINCT pc.id_protocol_connector, pc.desc_protocol_connector, pc.flg_desc_protocol_connector
              FROM alert_default.protocol_connector pc
             WHERE pc.flg_available = g_yes;
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_CONNECTOR ';
        g_error     := 'OPEN C_PROTOCOL_CONNECTOR CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN c_protocol_connector;
        LOOP
            FETCH c_protocol_connector
                INTO l_id_protocol_connector, l_descr_protocol_connector, l_flg_desc_protocol_connector;
            EXIT WHEN c_protocol_connector%NOTFOUND;
        
            g_error := 'l_count_connector';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            SELECT COUNT(pc.id_protocol_connector)
              INTO l_count
              FROM protocol_connector pc
             WHERE pc.id_protocol_connector = l_id_protocol_connector
               AND pc.flg_available = g_yes;
        
            g_error := 'IF l_count = 0';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF l_count = 0
            THEN
            
                l_id_protocol_connector_array.extend;
                l_descr_protocol_conn_array.extend;
                l_flg_desc_protocol_conn_array.extend;
            
                l_id_protocol_connector_array(l_index) := l_id_protocol_connector;
                l_descr_protocol_conn_array(l_index) := l_descr_protocol_connector;
                l_flg_desc_protocol_conn_array(l_index) := l_flg_desc_protocol_connector;
            
                l_index := l_index + 1;
            
            END IF;
        
        END LOOP;
        g_error := 'CLOSE C_PROTOCOL_CONNECTOR CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        CLOSE c_protocol_connector;
    
        g_error := 'CLOSE O_ID_PROTOCOL_CONNECTOR CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_connector FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_connector_array AS table_number));
    
        g_error := 'CLOSE O_DESCR_PROTOCOL_CONNECTOR CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_desc_protocol_connector FOR
            SELECT column_value
              FROM TABLE(CAST(l_descr_protocol_conn_array AS table_varchar));
    
        g_error := 'CLOSE O_FLG_DESCR_PRTCL_CONNECTOR CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_desc_protocol_connector FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_desc_protocol_conn_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol_connector);
            pk_types.open_my_cursor(o_desc_protocol_connector);
            pk_types.open_my_cursor(o_flg_desc_protocol_connector);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_connector;
    /********************************************************************************************
    * Get Protocol Context Author set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol                  Cursor of Protocol
    * @param o_first_name                   Cursor of First Name
    * @param o_last_name                    Cursor of Last Name
    * @param o_title                        Cursor of Title    
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/06
    ********************************************************************************************/
    FUNCTION get_inst_protocol_context_auth
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_protocol    OUT pk_types.cursor_type,
        o_first_name     OUT pk_types.cursor_type,
        o_last_name      OUT pk_types.cursor_type,
        o_title          OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol_def protocol_context_author.id_protocol%TYPE := NULL;
        l_id_protocol     protocol_context_author.id_protocol%TYPE := NULL;
        l_id_content_def  protocol.id_content%TYPE := NULL;
        l_first_name      protocol_context_author.first_name%TYPE := NULL;
        l_last_name       protocol_context_author.last_name%TYPE := NULL;
        l_title           protocol_context_author.title%TYPE := NULL;
    
        l_id_protocol_array table_number := table_number();
        l_first_name_array  table_varchar := table_varchar();
        l_last_name_array   table_varchar := table_varchar();
        l_title_array       table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_context_auth
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT pca.id_protocol, p.id_content, pca.first_name, pca.last_name, pca.title
              FROM alert_default.protocol_context_author pca
              JOIN alert_default.protocol p
                ON (p.id_protocol = pca.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pca.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version);
    
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_CONTEXT_AUTH ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL_CONTEXT_AUTH CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_context_auth(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_context_auth
                        INTO l_id_protocol_def, l_id_content_def, l_first_name, l_last_name, l_title;
                    EXIT WHEN c_protocol_context_auth%NOTFOUND;
                
                    g_error := 'GET ALERT ID_PROTOCOL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT p.id_protocol
                                 FROM protocol p
                                WHERE p.id_content = l_id_content_def
                                  AND p.id_content IS NOT NULL
                                  AND p.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_protocol
                      FROM dual;
                
                    g_error := 'COUNT PROTOCOL_CONTEXT_AUTHOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT COUNT(pca.id_protocol_context_author)
                      INTO l_count
                      FROM protocol_context_author pca
                     WHERE pca.id_protocol = l_id_protocol
                       AND pca.first_name = l_first_name
                       AND pca.last_name = l_last_name
                       AND pca.title = l_title;
                
                    IF l_id_protocol != 0
                       AND l_count = 0
                    THEN
                    
                        l_id_protocol_array.extend;
                        l_first_name_array.extend;
                        l_last_name_array.extend;
                        l_title_array.extend;
                    
                        l_id_protocol_array(l_index) := l_id_protocol;
                        l_first_name_array(l_index) := l_first_name;
                        l_last_name_array(l_index) := l_last_name;
                        l_title_array(l_index) := l_title;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_CONTEXT_AUTH CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_context_auth;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_array AS table_number));
    
        g_error := 'CLOSE O_FIRST_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_first_name FOR
            SELECT column_value
              FROM TABLE(CAST(l_first_name_array AS table_varchar));
    
        g_error := 'CLOSE O_LAST_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_last_name FOR
            SELECT column_value
              FROM TABLE(CAST(l_last_name_array AS table_varchar));
    
        g_error := 'CLOSE O_TITLE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_title FOR
            SELECT column_value
              FROM TABLE(CAST(l_title_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol);
            pk_types.open_my_cursor(o_first_name);
            pk_types.open_my_cursor(o_last_name);
            pk_types.open_my_cursor(o_title);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_protocol_context_auth;
    /*********************************************************************************************
    * Set Protocol Context Auth for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_protocol_context_auth    Cursor of Instituition Protocol_Context_Author
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/06
    ********************************************************************************************/
    FUNCTION set_inst_protocol_context_auth
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_id_institution        IN institution.id_institution%TYPE,
        i_software              IN table_number,
        o_protocol_context_auth OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_protocol pk_types.cursor_type;
        l_c_first_name  pk_types.cursor_type;
        l_c_last_name   pk_types.cursor_type;
        l_c_title       pk_types.cursor_type;
    
        l_data_id_protocol table_varchar;
        l_data_first_name  table_varchar;
        l_data_last_name   table_varchar;
        l_data_title       table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_CONTEXT_AUTH ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_CONTEXT_AUTH';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_protocol_context_auth(i_lang,
                                                  i_market,
                                                  i_version,
                                                  i_id_institution,
                                                  i_software(i),
                                                  l_c_id_protocol,
                                                  l_c_first_name,
                                                  l_c_last_name,
                                                  l_c_title,
                                                  o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_protocol_context_auth := l_c_id_protocol';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_protocol_context_auth := l_c_id_protocol;
            
                LOOP
                    FETCH l_c_id_protocol BULK COLLECT
                        INTO l_data_id_protocol LIMIT g_array_size;
                
                    FETCH l_c_first_name BULK COLLECT
                        INTO l_data_first_name LIMIT g_array_size;
                
                    FETCH l_c_last_name BULK COLLECT
                        INTO l_data_last_name LIMIT g_array_size;
                
                    FETCH l_c_title BULK COLLECT
                        INTO l_data_title LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_CONTEXT_AUTHOR (seq_protocol_context_author.NEXTVAL,' ||
                                   l_data_id_protocol(j) || ');';
                    
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_context_author
                            (id_protocol_context_author, id_protocol, first_name, last_name, title)
                        VALUES
                            (seq_protocol_context_author.nextval,
                             l_data_id_protocol(j),
                             l_data_first_name(j),
                             l_data_last_name(j),
                             l_data_title(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol;
            
                g_error := 'CLOSE L_C_FIRST_NAME CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_first_name;
            
                g_error := 'CLOSE L_C_LAST_NAME CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_last_name;
            
                g_error := 'CLOSE L_C_TITLE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_title;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_context_auth;
    /********************************************************************************************
    * Get Protocol Context Image set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol                  Cursor of Protocol
    * @param o_file_name                    Cursor of File Name
    * @param o_img_desc                     Cursor of Image Desc
    * @param o_dt_img                       Cursor of Date Image 
    * @param o_img                          Cursor of Image 
    * @param o_img_thumbnail                Cursor of Image Thumbanail 
    * @param o_flg_status                   Cursor of Flg_Status 
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/06
    ********************************************************************************************/
    FUNCTION get_inst_protocol_context_img
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_protocol    OUT pk_types.cursor_type,
        o_file_name      OUT pk_types.cursor_type,
        o_img_desc       OUT pk_types.cursor_type,
        o_dt_img         OUT pk_types.cursor_type,
        o_img            OUT pk_types.cursor_type,
        o_img_thumbnail  OUT pk_types.cursor_type,
        o_flg_status     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_protocol_def protocol_context_image.id_protocol%TYPE := NULL;
        l_id_protocol     protocol_context_image.id_protocol%TYPE := NULL;
        l_id_content_def  protocol.id_content%TYPE := NULL;
        l_file_name       protocol_context_image.file_name%TYPE := NULL;
        l_img_desc        protocol_context_image.img_desc%TYPE := NULL;
        l_dt_img          protocol_context_image.dt_img%TYPE := NULL;
        l_img             protocol_context_image.img%TYPE;
        l_img_thumbnail   protocol_context_image.img_thumbnail%TYPE;
        l_flg_status      protocol_context_image.flg_status%TYPE := NULL;
    
        l_id_protocol_array   table_number := table_number();
        l_file_name_array     table_varchar := table_varchar();
        l_img_desc_array      table_varchar := table_varchar();
        l_dt_img_array        table_date := table_date();
        l_img_array           table_blob := table_blob();
        l_img_thumbnail_array table_blob := table_blob();
        l_flg_status_array    table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_context_img
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT pci.id_protocol,
                   p.id_content,
                   pci.file_name,
                   pci.img_desc,
                   pci.dt_img,
                   pci.img,
                   pci.img_thumbnail,
                   pci.flg_status
              FROM alert_default.protocol_context_image pci
              JOIN alert_default.protocol p
                ON (p.id_protocol = pci.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pci.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version);
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_CONTEXT_IMG ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL_CONTEXT_IMG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_context_img(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_context_img
                        INTO l_id_protocol_def,
                             l_id_content_def,
                             l_file_name,
                             l_img_desc,
                             l_dt_img,
                             l_img,
                             l_img_thumbnail,
                             l_flg_status;
                    EXIT WHEN c_protocol_context_img%NOTFOUND;
                
                    g_error := 'GET ALERT ID_PROTOCOL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT p.id_protocol
                                 FROM protocol p
                                WHERE p.id_content = l_id_content_def
                                  AND p.id_content IS NOT NULL
                                  AND p.id_software = i_id_software
                                  AND p.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_protocol
                      FROM dual;
                
                    g_error := 'COUNT PROTOCOL_CONTEXT_IMAGE';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT COUNT(pci.id_protocol_context_image)
                      INTO l_count
                      FROM protocol_context_image pci
                     WHERE pci.id_protocol = l_id_protocol
                       AND pci.file_name = l_file_name
                       AND pci.img_desc = l_img_desc
                       AND pci.dt_img = l_dt_img
                       AND dbms_lob.compare(pci.img, l_img) > 0
                       AND dbms_lob.compare(pci.img_thumbnail, l_img_thumbnail) > 0
                       AND pci.flg_status = l_flg_status;
                
                    IF l_id_protocol != 0
                       AND l_count = 0
                    THEN
                    
                        l_id_protocol_array.extend;
                        l_file_name_array.extend;
                        l_img_desc_array.extend;
                        l_dt_img_array.extend;
                        l_img_array.extend;
                        l_img_thumbnail_array.extend;
                        l_flg_status_array.extend;
                    
                        l_id_protocol_array(l_index) := l_id_protocol;
                        l_file_name_array(l_index) := l_file_name;
                        l_img_desc_array(l_index) := l_img_desc;
                        l_dt_img_array(l_index) := l_dt_img;
                        l_img_array(l_index) := l_img;
                        l_img_thumbnail_array(l_index) := l_img_thumbnail;
                        l_flg_status_array(l_index) := l_flg_status;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_CONTEXT_IMG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_context_img;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_array AS table_number));
    
        g_error := 'CLOSE O_FILE_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_file_name FOR
            SELECT column_value
              FROM TABLE(CAST(l_file_name_array AS table_varchar));
    
        g_error := 'CLOSE O_IMG_DESC CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_img_desc FOR
            SELECT column_value
              FROM TABLE(CAST(l_file_name_array AS table_varchar));
    
        g_error := 'CLOSE O_DT_IMG CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_dt_img FOR
            SELECT column_value
              FROM TABLE(CAST(l_dt_img_array AS table_date));
    
        g_error := 'CLOSE O_IMG CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_img FOR
            SELECT column_value
              FROM TABLE(l_img_array);
    
        g_error := 'CLOSE O_IMG_THUMB CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_img_thumbnail FOR
            SELECT column_value
              FROM TABLE(l_img_thumbnail_array);
    
        g_error := 'CLOSE O_FLG_STATUS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_status_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol);
            pk_types.open_my_cursor(o_file_name);
            pk_types.open_my_cursor(o_img_desc);
            pk_types.open_my_cursor(o_dt_img);
            pk_types.open_my_cursor(o_img);
            pk_types.open_my_cursor(o_img_thumbnail);
            pk_types.open_my_cursor(o_flg_status);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_context_img;
    /*********************************************************************************************
    * Set Protocol Context Image for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_protocol_context_img     Cursor of Instituition Protocol_Context_Image
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/06
    ********************************************************************************************/
    FUNCTION set_inst_protocol_context_img
    (
        i_lang                 IN language.id_language%TYPE,
        i_market               IN table_number,
        i_version              IN table_varchar,
        i_id_institution       IN institution.id_institution%TYPE,
        i_software             IN table_number,
        o_protocol_context_img OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_protocol   pk_types.cursor_type;
        l_c_file_name     pk_types.cursor_type;
        l_c_img_desc      pk_types.cursor_type;
        l_c_dt_img        pk_types.cursor_type;
        l_c_img           pk_types.cursor_type;
        l_c_img_thumbnail pk_types.cursor_type;
        l_c_flg_status    pk_types.cursor_type;
    
        l_data_id_protocol   table_number;
        l_data_file_name     table_varchar;
        l_data_img_desc      table_varchar;
        l_data_dt_img        table_date;
        l_data_img           table_blob;
        l_data_img_thumbnail table_blob;
        l_data_flg_status    table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_CONTEXT_IMG ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_CONTEXT_IMG';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_protocol_context_img(i_lang,
                                                 i_market,
                                                 i_version,
                                                 i_id_institution,
                                                 i_software(i),
                                                 l_c_id_protocol,
                                                 l_c_file_name,
                                                 l_c_img_desc,
                                                 l_c_dt_img,
                                                 l_c_img,
                                                 l_c_img_thumbnail,
                                                 l_c_flg_status,
                                                 o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_protocol_context_img := l_c_id_protocol';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_protocol_context_img := l_c_id_protocol;
            
                LOOP
                
                    FETCH l_c_id_protocol BULK COLLECT
                        INTO l_data_id_protocol LIMIT g_array_size;
                
                    FETCH l_c_file_name BULK COLLECT
                        INTO l_data_file_name LIMIT g_array_size;
                
                    FETCH l_c_img_desc BULK COLLECT
                        INTO l_data_img_desc LIMIT g_array_size;
                
                    FETCH l_c_dt_img BULK COLLECT
                        INTO l_data_dt_img LIMIT g_array_size;
                
                    FETCH l_c_img BULK COLLECT
                        INTO l_data_img LIMIT g_array_size;
                
                    FETCH l_c_img_thumbnail BULK COLLECT
                        INTO l_data_img_thumbnail LIMIT g_array_size;
                
                    FETCH l_c_flg_status BULK COLLECT
                        INTO l_data_flg_status LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_CONTEXT_IMAGE (seq_protocol_context_image.NEXTVAL,' ||
                                   l_data_id_protocol(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_context_image
                            (id_protocol_context_image,
                             id_protocol,
                             file_name,
                             img_desc,
                             dt_img,
                             img,
                             img_thumbnail,
                             flg_status)
                        VALUES
                            (seq_protocol_context_image.nextval,
                             l_data_id_protocol(j),
                             l_data_file_name(j),
                             l_data_img_desc(j),
                             l_data_dt_img(j),
                             l_data_img(j),
                             l_data_img_thumbnail(j),
                             l_data_flg_status(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol;
            
                g_error := 'CLOSE L_C_FILE_NAME CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_file_name;
            
                g_error := 'CLOSE L_C_IMG_DESC CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_img_desc;
            
                g_error := 'CLOSE L_C_DT_IMG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_dt_img;
            
                g_error := 'CLOSE L_C_IMG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_img;
            
                g_error := 'CLOSE L_C_IMG_THUMBNAIL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_img_thumbnail;
            
                g_error := 'CLOSE L_C_FLG_STATUS CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_flg_status;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_context_img;
    /********************************************************************************************
    * Get Protocol Relations set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol                  Cursor of Protocol
    * @param o_id_protocol_element_par      Cursor of Protocol element parent
    * @param o_id_protocol_connector        Cursor of Protocol connector
    * @param o_id_protocol_element          Cursor of Protocol element
    * @param o_desc_relation                Cursor of Protocol relation description
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/06
    ********************************************************************************************/
    FUNCTION get_inst_protocol_relation
    (
        i_lang                    IN language.id_language%TYPE,
        i_market                  IN table_number,
        i_version                 IN table_varchar,
        i_id_institution          IN institution.id_institution%TYPE,
        i_id_software             IN software.id_software%TYPE,
        o_id_protocol             OUT pk_types.cursor_type,
        o_id_protocol_element_par OUT pk_types.cursor_type,
        o_id_protocol_connector   OUT pk_types.cursor_type,
        o_id_protocol_element     OUT pk_types.cursor_type,
        o_desc_relation           OUT pk_types.cursor_type,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_protocol_def          protocol_relation.id_protocol%TYPE := NULL;
        l_id_protocol              protocol_relation.id_protocol%TYPE := NULL;
        l_id_content_def           protocol.id_content%TYPE := NULL;
        l_id_protocol_element_par  protocol_relation.id_protocol_element_parent%TYPE := NULL;
        l_id_protocol_connector    protocol_relation.id_protocol_connector%TYPE := NULL;
        l_id_protocol_element      protocol_relation.id_protocol_element%TYPE := NULL;
        l_id_prtcl_element_par_def protocol_relation.id_protocol_element_parent%TYPE := NULL;
        l_id_prtcl_connector_def   protocol_relation.id_protocol_connector%TYPE := NULL;
        l_id_prtcl_element_def     protocol_relation.id_protocol_element%TYPE := NULL;
        l_desc_relation            protocol_relation.desc_relation%TYPE := NULL;
        l_id_relation              protocol_relation.id_protocol_relation%TYPE := NULL;
        l_id_relation_x            protocol_relation.id_protocol_relation%TYPE := NULL;
    
        l_id_protocol_array           table_number := table_number();
        l_id_prtcl_element_par_array  table_number := table_number();
        l_id_protocol_connector_array table_number := table_number();
        l_id_protocol_element_array   table_number := table_number();
        l_desc_relation_array         table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_relation
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT pr.id_protocol,
                   p.id_content,
                   pr.id_protocol_element_parent,
                   pr.id_protocol_connector,
                   pr.id_protocol_element,
                   pr.desc_relation,
                   pr.id_protocol_relation
              FROM alert_default.protocol_relation pr
              JOIN alert_default.protocol_element pe
                ON (pe.id_protocol_element = pr.id_protocol_element AND pe.flg_available = g_flg_available)
              JOIN alert_default.protocol_element pe1
                ON (pe1.id_protocol_element = pr.id_protocol_element_parent AND pe1.flg_available = g_flg_available)
              JOIN alert_default.protocol_connector pc
                ON (pc.id_protocol_connector = pr.id_protocol_connector AND pc.flg_available = g_flg_available)
              JOIN alert_default.protocol p
                ON (p.id_protocol = pr.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pr.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version)
             WHERE pr.flg_available = g_flg_available;
    
        CURSOR c_protocol_elements(c_id_protocol IN protocol.id_protocol%TYPE) IS
            SELECT alpe.id_protocol_element,
                   pc1.id_protocol_connector,
                   alpe1.id_protocol_element,
                   pr.id_protocol_relation
              FROM alert_default.protocol_relation pr
              JOIN alert_default.protocol_element pe
                ON (pe.id_protocol_element = pr.id_protocol_element AND pe.flg_available = g_flg_available)
              JOIN alert_default.protocol_element pe1
                ON (pe1.id_protocol_element = pr.id_protocol_element_parent AND pe1.flg_available = g_flg_available)
              JOIN alert_default.protocol_connector pc
                ON (pc.id_protocol_connector = pr.id_protocol_connector AND pc.flg_available = g_flg_available)
              JOIN protocol_element alpe
                ON (alpe.element_type = pe.element_type AND alpe.flg_available = g_flg_available AND
                   alpe.id_protocol = c_id_protocol AND alpe.id_element = pe.id_element)
              JOIN protocol_element alpe1
                ON (alpe1.element_type = pe1.element_type AND alpe1.flg_available = g_flg_available AND
                   alpe1.id_protocol = c_id_protocol AND alpe1.id_element = pe1.id_element)
              JOIN protocol_connector pc1
                ON (pc1.id_protocol_connector = pc.id_protocol_connector AND pc.flg_available = 'Y')
             WHERE pr.flg_available = g_flg_available;
    
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_RELATION ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL_RELATION CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_relation(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_relation
                        INTO l_id_protocol_def,
                             l_id_content_def,
                             l_id_prtcl_element_par_def,
                             l_id_prtcl_connector_def,
                             l_id_prtcl_element_def,
                             l_desc_relation,
                             l_id_relation;
                    EXIT WHEN c_protocol_relation%NOTFOUND;
                
                    g_error := 'GET ALERT ID_PROTOCOL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT p.id_protocol
                                 FROM protocol p
                                WHERE p.id_content = l_id_content_def
                                  AND p.id_content IS NOT NULL
                                  AND p.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_protocol
                      FROM dual;
                
                    IF l_id_protocol != 0
                    THEN
                        g_error := 'OPEN C_PROTOCOL_ELEMENTS CURSOR';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        OPEN c_protocol_elements(l_id_protocol);
                        LOOP
                            FETCH c_protocol_elements
                                INTO l_id_protocol_element,
                                     l_id_protocol_connector,
                                     l_id_protocol_element_par,
                                     l_id_relation_x;
                            EXIT WHEN c_protocol_elements%NOTFOUND;
                        
                            IF l_id_relation = l_id_relation_x
                            THEN
                                IF l_id_protocol_element != 0
                                   AND l_id_protocol_element_par != 0
                                   AND l_id_protocol_connector != 0
                                THEN
                                    g_error := 'COUNT PROTOCOL_RELATION';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT COUNT(pr.id_protocol_relation)
                                      INTO l_count
                                      FROM protocol_relation pr
                                     WHERE pr.id_protocol = l_id_protocol
                                       AND pr.id_protocol_element_parent = l_id_protocol_element_par
                                       AND pr.id_protocol_connector = l_id_protocol_connector
                                       AND pr.id_protocol_element = l_id_protocol_element;
                                
                                    IF l_count = 0
                                    THEN
                                    
                                        l_id_protocol_array.extend;
                                        l_id_prtcl_element_par_array.extend;
                                        l_id_protocol_connector_array.extend;
                                        l_id_protocol_element_array.extend;
                                        l_desc_relation_array.extend;
                                    
                                        l_id_protocol_array(l_index) := l_id_protocol;
                                        l_id_prtcl_element_par_array(l_index) := l_id_protocol_element_par;
                                        l_id_protocol_connector_array(l_index) := l_id_prtcl_connector_def;
                                        l_id_protocol_element_array(l_index) := l_id_protocol_element;
                                        l_desc_relation_array(l_index) := l_desc_relation;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END IF;
                            END IF;
                        END LOOP;
                        g_error := 'CLOSE C_PROTOCOL_ELEMENTS CURSOR';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        CLOSE c_protocol_elements;
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_PROTOCOL_RELATION CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_relation;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_array AS table_number));
    
        g_error := 'CLOSE O_FILE_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_element_par FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_prtcl_element_par_array AS table_number));
    
        g_error := 'CLOSE O_IMG_DESC CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_connector FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_connector_array AS table_number));
    
        g_error := 'CLOSE O_DT_IMG CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol_element FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_element_array AS table_number));
    
        g_error := 'CLOSE O_IMG CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_desc_relation FOR
            SELECT column_value
              FROM TABLE(CAST(l_desc_relation_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol);
            pk_types.open_my_cursor(o_id_protocol_element_par);
            pk_types.open_my_cursor(o_id_protocol_connector);
            pk_types.open_my_cursor(o_id_protocol_element);
            pk_types.open_my_cursor(o_desc_relation);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_relation;
    /*********************************************************************************************
    * Set Protocol Relation for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_protocol_relation        Cursor of Instituition Protocol Relation
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/10
    ********************************************************************************************/
    FUNCTION set_inst_protocol_relation
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_software          IN table_number,
        o_protocol_relation OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_protocol             pk_types.cursor_type;
        l_c_id_protocol_element_par pk_types.cursor_type;
        l_c_id_protocol_connector   pk_types.cursor_type;
        l_c_id_protocol_element     pk_types.cursor_type;
        l_c_desc_relation           pk_types.cursor_type;
    
        l_data_id_protocol             table_number;
        l_data_id_protocol_element_par table_number;
        l_data_id_protocol_connector   table_number;
        l_data_id_protocol_element     table_number;
        l_data_desc_relation           table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
        --Protocol_Connector                
        l_c_id_protocol_connector_x pk_types.cursor_type;
        l_c_desc_protocol_connector pk_types.cursor_type;
        l_c_flg_desc_protocol_conn  pk_types.cursor_type;
    
        l_data_id_protocol_connector_x table_number;
        l_data_desc_protocol_connector table_varchar;
        l_data_flg_desc_protocol_conn  table_varchar;
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_RELATION ';
    
        g_error := 'IF NOT GET_INST_PROTOCOL_CONNECTOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        IF NOT get_inst_protocol_connector(i_lang,
                                           l_c_id_protocol_connector_x,
                                           l_c_desc_protocol_connector,
                                           l_c_flg_desc_protocol_conn,
                                           o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error := 'o_protocol_relation := l_c_id_protocol_connector_x';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            o_protocol_relation := l_c_id_protocol_connector_x;
        
            LOOP
            
                FETCH l_c_id_protocol_connector_x BULK COLLECT
                    INTO l_data_id_protocol_connector_x LIMIT g_array_size;
            
                FETCH l_c_desc_protocol_connector BULK COLLECT
                    INTO l_data_desc_protocol_connector LIMIT g_array_size;
            
                FETCH l_c_flg_desc_protocol_conn BULK COLLECT
                    INTO l_data_flg_desc_protocol_conn LIMIT g_array_size;
            
                FOR j IN 1 .. l_data_id_protocol_connector_x.count
                LOOP
                    g_error := 'INSERT INTO PROTOCOL_CONNECTOR (' || l_data_id_protocol_connector_x(j) || ');';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    INSERT INTO protocol_connector
                        (id_protocol_connector, desc_protocol_connector, flg_desc_protocol_connector, flg_available)
                    VALUES
                        (l_data_id_protocol_connector_x(j),
                         l_data_desc_protocol_connector(j),
                         l_data_flg_desc_protocol_conn(j),
                         'Y');
                
                END LOOP;
                EXIT WHEN l_c_id_protocol_connector_x%NOTFOUND;
            END LOOP;
            g_error := 'CLOSE L_C_ID_PROTOCOL_CONNECTOR CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            CLOSE l_c_id_protocol_connector_x;
        
            g_error := 'CLOSE L_C_DESC_PROTOCOL_CONNECTOR CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            CLOSE l_c_desc_protocol_connector;
        
            g_error := 'CLOSE L_C_FLG_PROTOCOL_CONNECTOR CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            CLOSE l_c_flg_desc_protocol_conn;
        END IF;
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_RELATION';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_protocol_relation(i_lang,
                                              i_market,
                                              i_version,
                                              i_id_institution,
                                              i_software(i),
                                              l_c_id_protocol,
                                              l_c_id_protocol_element_par,
                                              l_c_id_protocol_connector,
                                              l_c_id_protocol_element,
                                              l_c_desc_relation,
                                              o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_protocol_relation := l_c_id_protocol';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                o_protocol_relation := l_c_id_protocol;
            
                LOOP
                    FETCH l_c_id_protocol BULK COLLECT
                        INTO l_data_id_protocol LIMIT g_array_size;
                
                    FETCH l_c_id_protocol_element_par BULK COLLECT
                        INTO l_data_id_protocol_element_par LIMIT g_array_size;
                
                    FETCH l_c_id_protocol_connector BULK COLLECT
                        INTO l_data_id_protocol_connector LIMIT g_array_size;
                
                    FETCH l_c_id_protocol_element BULK COLLECT
                        INTO l_data_id_protocol_element LIMIT g_array_size;
                
                    FETCH l_c_desc_relation BULK COLLECT
                        INTO l_data_desc_relation LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_RELATION (seq_protocol_relation.NEXTVAL,' ||
                                   l_data_id_protocol(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_relation
                            (id_protocol_relation,
                             id_protocol,
                             id_protocol_element_parent,
                             id_protocol_connector,
                             id_protocol_element,
                             desc_relation,
                             flg_available)
                        VALUES
                            (seq_protocol_relation.nextval,
                             l_data_id_protocol(j),
                             l_data_id_protocol_element_par(j),
                             l_data_id_protocol_connector(j),
                             l_data_id_protocol_element(j),
                             l_data_desc_relation(j),
                             'Y');
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL_ELEMENT_PAR CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol_element_par;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL_CONNECTOR CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol_connector;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL_ELEMENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol_element;
            
                g_error := 'CLOSE L_C_DESC_RELATION CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_desc_relation;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_relation;
    /********************************************************************************************
    * Get Protocol Frequent set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol                  Cursor of Protocol
    * @param o_id_software                  Cursor of Software ID
    * @param o_rank                         Cursor of Rank
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/10
    ********************************************************************************************/
    FUNCTION get_inst_protocol_frequent
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_protocol    OUT pk_types.cursor_type,
        o_id_software    OUT pk_types.cursor_type,
        o_rank           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_protocol_def protocol_frequent.id_protocol%TYPE := NULL;
        l_id_protocol     protocol_frequent.id_protocol%TYPE := NULL;
        l_id_content_def  protocol.id_content%TYPE := NULL;
        l_id_software     protocol_frequent.id_software%TYPE := NULL;
        l_rank            protocol_frequent.rank%TYPE := NULL;
    
        l_id_protocol_array table_number := table_number();
        l_id_software_array table_number := table_number();
        l_rank_array        table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_protocol_frequent
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT pf.id_protocol, p.id_content, pf.id_software, pf.rank
              FROM alert_default.protocol_frequent pf
              JOIN alert_default.protocol p
                ON (p.id_protocol = pf.id_protocol)
              JOIN alert_default.protocol_mrk_vrs pmv
                ON (pmv.id_protocol = pf.id_protocol AND pmv.id_market = c_market AND pmv.version = c_version)
             WHERE pf.id_software = c_id_software;
    
    BEGIN
        g_func_name := 'GET_INST_PROTOCOL_FREQUENT ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_PROTOCOL_FREQUENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_protocol_frequent(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_protocol_frequent
                        INTO l_id_protocol_def, l_id_content_def, l_id_software, l_rank;
                    EXIT WHEN c_protocol_frequent%NOTFOUND;
                
                    g_error := 'GET ALERT ID_PROTOCOL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT p.id_protocol
                                 FROM protocol p
                                WHERE p.id_content = l_id_content_def
                                  AND p.id_content IS NOT NULL
                                  AND p.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_protocol
                      FROM dual;
                
                    g_error := 'COUNT PROTOCOL_FREQUENT';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT COUNT(pf.id_protocol)
                      INTO l_count
                      FROM protocol_frequent pf
                     WHERE pf.id_protocol = l_id_protocol
                       AND pf.id_software = l_id_software;
                
                    IF l_id_protocol != 0
                       AND l_count = 0
                    THEN
                    
                        l_id_protocol_array.extend;
                        l_id_software_array.extend;
                        l_rank_array.extend;
                    
                        l_id_protocol_array(l_index) := l_id_protocol;
                        l_id_software_array(l_index) := l_id_software;
                        l_rank_array(l_index) := l_rank;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_PROTOCOL_FREQUENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_protocol_frequent;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_PROTOCOL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_protocol FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_protocol_array AS table_number));
    
        g_error := 'CLOSE O_ID_SOFTWARE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_software FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_software_array AS table_number));
    
        g_error := 'CLOSE O_RANK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_protocol);
            pk_types.open_my_cursor(o_id_software);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_protocol_frequent;
    /*********************************************************************************************
    * Set Protocol Frequent for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_protocol_frequent        Cursor of Instituition Protocol_Frequent
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/10
    ********************************************************************************************/
    FUNCTION set_inst_protocol_frequent
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_software          IN table_number,
        o_protocol_frequent OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_protocol pk_types.cursor_type;
        l_c_id_software pk_types.cursor_type;
        l_c_rank        pk_types.cursor_type;
    
        l_data_id_protocol table_number;
        l_data_id_software table_number;
        l_data_rank        table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_PROTOCOL_FREQUENT ';
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_PROTOCOL_FREQUENT';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_protocol_frequent(i_lang,
                                              i_market,
                                              i_version,
                                              i_id_institution,
                                              i_software(i),
                                              l_c_id_protocol,
                                              l_c_id_software,
                                              l_c_rank,
                                              o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_protocol_frequent := l_c_id_protocol';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_protocol_frequent := l_c_id_protocol;
            
                LOOP
                
                    FETCH l_c_id_protocol BULK COLLECT
                        INTO l_data_id_protocol LIMIT g_array_size;
                
                    FETCH l_c_id_software BULK COLLECT
                        INTO l_data_id_software LIMIT g_array_size;
                
                    FETCH l_c_rank BULK COLLECT
                        INTO l_data_rank LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_protocol.count
                    LOOP
                        g_error := 'INSERT INTO PROTOCOL_FREQUENT (' || l_data_id_protocol(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO protocol_frequent
                            (rank, id_protocol, id_institution, id_software)
                        VALUES
                            (l_data_rank(j), l_data_id_protocol(j), i_id_institution, l_data_id_software(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_protocol%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_PROTOCOL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_protocol;
            
                g_error := 'CLOSE L_C_ID_SOFTWARE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_software;
            
                g_error := 'CLOSE L_C_RANK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_rank;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_protocol_frequent;
    /********************************************************************************************
    * Get GUIDELINES set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_guideline                 Cursor of guideline
    * @param o_guideline_desc               Cursor of guideline_desc
    * @param o_flg_status                   Cursor of flg_status
    * @param o_context_title                Cursor of context_title  
    * @param o_context_adaptation           Cursor of context_adaptation
    * @param o_context_type_media           Cursor of context_type_media
    * @param o_context_editor               Cursor of context_editor 
    * @param o_id_guideline_ebm             Cursor of id_guideline_ebm
    * @param o_context_edition_site         Cursor of context_edition_site
    * @param o_context_edition              Cursor of context_edition
    * @param o_context_access               Cursor of context_access
    * @param o_id_context_language          Cursor of id_context_language
    * @param o_context_subtitle             Cursor of context_subtitle
    * @param o_id_context_assoc_lang        Cursor of id_context_assoc_lang
    * @param o_id_software                  Cursor of id_software
    * @param o_flg_type_recommend           Cursor of flg_type_recommend
    * @param o_context_desc                 Cursor of context_desc
    * @param o_id_content                   Cursor of id_content 
    * @param o_dt_context_edition           Cursor of dt_context_edition
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/11
    ********************************************************************************************/
    FUNCTION get_inst_guideline
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_id_institution        IN institution.id_institution%TYPE,
        i_id_software           IN software.id_software%TYPE,
        o_id_guideline          OUT pk_types.cursor_type,
        o_guideline_desc        OUT pk_types.cursor_type,
        o_flg_status            OUT pk_types.cursor_type,
        o_context_title         OUT pk_types.cursor_type,
        o_context_adaptation    OUT pk_types.cursor_type,
        o_context_type_media    OUT pk_types.cursor_type,
        o_context_editor        OUT pk_types.cursor_type,
        o_id_guideline_ebm      OUT pk_types.cursor_type,
        o_context_edition_site  OUT pk_types.cursor_type,
        o_context_edition       OUT pk_types.cursor_type,
        o_context_access        OUT pk_types.cursor_type,
        o_id_context_language   OUT pk_types.cursor_type,
        o_context_subtitle      OUT pk_types.cursor_type,
        o_id_context_assoc_lang OUT pk_types.cursor_type,
        o_id_software           OUT pk_types.cursor_type,
        o_flg_type_recommend    OUT pk_types.cursor_type,
        o_context_desc          OUT pk_types.cursor_type,
        o_id_content            OUT pk_types.cursor_type,
        o_dt_context_edition    OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_guideline_def      guideline.id_guideline%TYPE;
        l_guideline_desc        guideline.guideline_desc%TYPE;
        l_flg_status            guideline.flg_status%TYPE;
        l_context_title         guideline.context_title%TYPE;
        l_context_adaptation    guideline.context_adaptation%TYPE;
        l_context_type_media    guideline.context_type_media%TYPE;
        l_context_editor        guideline.context_editor%TYPE;
        l_id_guideline_ebm      guideline.id_guideline_ebm%TYPE;
        l_context_edition_site  guideline.context_edition_site%TYPE;
        l_context_edition       guideline.context_edition%TYPE;
        l_context_access        guideline.context_access%TYPE;
        l_id_context_language   guideline.id_context_language%TYPE;
        l_context_subtitle      guideline.context_subtitle%TYPE;
        l_id_context_assoc_lang guideline.id_context_associated_language%TYPE;
        l_id_software           guideline.id_software%TYPE;
        l_flg_type_recommend    guideline.flg_type_recommendation%TYPE;
        l_context_desc          guideline.context_desc%TYPE;
        l_id_content            guideline.id_content%TYPE;
        l_dt_context_edition    guideline.dt_context_edition%TYPE;
    
        l_id_guideline_array          table_number := table_number();
        l_guideline_desc_array        table_varchar := table_varchar();
        l_flg_status_array            table_varchar := table_varchar();
        l_context_title_array         table_varchar := table_varchar();
        l_context_adaptation_array    table_varchar := table_varchar();
        l_context_type_media_array    table_number := table_number();
        l_context_editor_array        table_varchar := table_varchar();
        l_id_guideline_ebm_array      table_number := table_number();
        l_context_edition_site_array  table_varchar := table_varchar();
        l_context_edition_array       table_varchar := table_varchar();
        l_context_access_array        table_varchar := table_varchar();
        l_id_context_language_array   table_number := table_number();
        l_context_subtitle_array      table_varchar := table_varchar();
        l_id_context_assoc_lang_array table_number := table_number();
        l_id_software_array           table_number := table_number();
        l_flg_type_recommend_array    table_varchar := table_varchar();
        l_context_desc_array          table_clob := table_clob();
        l_id_content_array            table_varchar := table_varchar();
        l_dt_context_edition_array    table_date := table_date();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_guideline
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT g.id_guideline,
                   g.guideline_desc,
                   g.flg_status,
                   g.context_title,
                   g.context_adaptation,
                   g.context_type_media,
                   g.context_editor,
                   g.id_guideline_ebm,
                   g.context_edition_site,
                   g.context_edition,
                   g.context_access,
                   g.id_context_language,
                   g.context_subtitle,
                   g.id_context_associated_language,
                   g.id_software,
                   g.flg_type_recommendation,
                   g.context_desc,
                   g.id_content,
                   g.dt_context_edition
              FROM alert_default.guideline g
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = g.id_guideline AND gmv.version = c_version AND gmv.id_market = c_market)
             WHERE EXISTS (SELECT 0
                      FROM alert_default.guideline_task_link gtl
                     WHERE gtl.id_guideline = g.id_guideline
                       AND rownum = 1);
    BEGIN
        g_func_name := 'GET_INST_GUIDELINE ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_GUIDELINE CURSOR MARKET [' || i_market(j) || '] SOFTWARE [' || i_id_software || ']';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guideline(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_guideline
                        INTO l_id_guideline_def,
                             l_guideline_desc,
                             l_flg_status,
                             l_context_title,
                             l_context_adaptation,
                             l_context_type_media,
                             l_context_editor,
                             l_id_guideline_ebm,
                             l_context_edition_site,
                             l_context_edition,
                             l_context_access,
                             l_id_context_language,
                             l_context_subtitle,
                             l_id_context_assoc_lang,
                             l_id_software,
                             l_flg_type_recommend,
                             l_context_desc,
                             l_id_content,
                             l_dt_context_edition;
                    EXIT WHEN c_guideline%NOTFOUND;
                
                    SELECT COUNT(g.id_guideline)
                      INTO l_count
                      FROM guideline g
                     WHERE g.id_content = (SELECT def_g.id_content
                                             FROM alert_default.guideline def_g
                                            WHERE def_g.id_content = l_id_content)
                       AND g.id_content IS NOT NULL
                       AND g.id_institution = i_id_institution;
                
                    g_error := 'COUNT GUIDELINE [' || l_count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    IF l_count = 0
                    THEN
                        g_error := 'EXISTING GUIDELINES = 0';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        l_id_guideline_array.extend;
                        l_guideline_desc_array.extend;
                        l_flg_status_array.extend;
                        l_context_title_array.extend;
                        l_context_adaptation_array.extend;
                        l_context_type_media_array.extend;
                        l_context_editor_array.extend;
                        l_id_guideline_ebm_array.extend;
                        l_context_edition_site_array.extend;
                        l_context_edition_array.extend;
                        l_context_access_array.extend;
                        l_id_context_language_array.extend;
                        l_context_subtitle_array.extend;
                        l_id_context_assoc_lang_array.extend;
                        l_id_software_array.extend;
                        l_flg_type_recommend_array.extend;
                        l_context_desc_array.extend;
                        l_id_content_array.extend;
                        l_dt_context_edition_array.extend;
                    
                        l_id_guideline_array(l_index) := l_id_guideline_def;
                        l_guideline_desc_array(l_index) := l_guideline_desc;
                        l_flg_status_array(l_index) := l_flg_status;
                        l_context_title_array(l_index) := l_context_title;
                        l_context_adaptation_array(l_index) := l_context_adaptation;
                        l_context_type_media_array(l_index) := l_context_type_media;
                        l_context_editor_array(l_index) := l_context_editor;
                        l_id_guideline_ebm_array(l_index) := l_id_guideline_ebm;
                        l_context_edition_site_array(l_index) := l_context_edition_site;
                        l_context_edition_array(l_index) := l_context_edition;
                        l_context_access_array(l_index) := l_context_access;
                        l_id_context_language_array(l_index) := l_id_context_language;
                        l_context_subtitle_array(l_index) := l_context_subtitle;
                        l_id_context_assoc_lang_array(l_index) := l_id_context_assoc_lang;
                        l_id_software_array(l_index) := l_id_software;
                        l_flg_type_recommend_array(l_index) := l_flg_type_recommend;
                        l_context_desc_array(l_index) := l_context_desc;
                        l_id_content_array(l_index) := l_id_content;
                        l_dt_context_edition_array(l_index) := l_dt_context_edition;
                    
                        l_index := l_index + 1;
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_GUIDELINE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guideline;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_GUIDELINE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_array AS table_number));
    
        g_error := 'OPEN O_GUIDELINE_DESC CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_guideline_desc FOR
            SELECT column_value
              FROM TABLE(CAST(l_guideline_desc_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_STATUS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_status_array AS table_varchar));
    
        g_error := 'OPEN o_context_title CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_title FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_title_array AS table_varchar));
    
        g_error := 'OPEN O_CONTEXT_ADAPTATION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_adaptation FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_adaptation_array AS table_varchar));
    
        g_error := 'OPEN O_CONTEXT_TYPE_MEDIA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_type_media FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_type_media_array AS table_number));
    
        g_error := 'OPEN O_CONTEXT_EDITOR CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_editor FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_editor_array AS table_varchar));
    
        g_error := 'OPEN O_ID_GUIDELINE_EBM CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline_ebm FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_ebm_array AS table_number));
    
        g_error := 'OPEN O_CONTEXT_EDITION_SITE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_edition_site FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_edition_site_array AS table_varchar));
    
        g_error := 'OPEN O_CONTEXT_EDITION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_edition FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_edition_array AS table_varchar));
    
        g_error := 'OPEN O_CONTEXT_ACCESS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_access FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_access_array AS table_varchar));
    
        g_error := 'OPEN O_ID_CONTEXT_LANGUAGE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_context_language FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_context_language_array AS table_number));
    
        g_error := 'OPEN O_CONTEXT_SUBTITLE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_subtitle FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_subtitle_array AS table_varchar));
    
        g_error := 'OPEN O_ID_CONTEXT_ASSOC_LANG CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_context_assoc_lang FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_context_assoc_lang_array AS table_number));
    
        g_error := 'CLOSE O_ID_SOFTWARE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_software FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_software_array AS table_number));
    
        g_error := 'OPEN O_FLG_TYPE_RECOMMEND CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_type_recommend FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_type_recommend_array AS table_varchar));
    
        g_error := 'OPEN O_CONTEXT_DESC CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_context_desc FOR
            SELECT column_value
              FROM TABLE(CAST(l_context_desc_array AS table_clob));
    
        g_error := 'OPEN O_ID_CONTENT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_content FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_content_array AS table_varchar));
    
        g_error := 'OPEN O_DT_CONTEXT_EDITION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_dt_context_edition FOR
            SELECT column_value
              FROM TABLE(CAST(l_dt_context_edition_array AS table_date));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_guideline);
            pk_types.open_my_cursor(o_guideline_desc);
            pk_types.open_my_cursor(o_flg_status);
            pk_types.open_my_cursor(o_context_title);
            pk_types.open_my_cursor(o_context_adaptation);
            pk_types.open_my_cursor(o_context_type_media);
            pk_types.open_my_cursor(o_context_editor);
            pk_types.open_my_cursor(o_id_guideline_ebm);
            pk_types.open_my_cursor(o_context_edition_site);
            pk_types.open_my_cursor(o_context_edition);
            pk_types.open_my_cursor(o_context_access);
            pk_types.open_my_cursor(o_id_context_language);
            pk_types.open_my_cursor(o_context_subtitle);
            pk_types.open_my_cursor(o_id_context_assoc_lang);
            pk_types.open_my_cursor(o_id_software);
            pk_types.open_my_cursor(o_flg_type_recommend);
            pk_types.open_my_cursor(o_context_desc);
            pk_types.open_my_cursor(o_id_content);
            pk_types.open_my_cursor(o_dt_context_edition);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guideline;
    /*********************************************************************************************
    * Set Guideline for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_inst_guideline      Cursor of Instituition protocol
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/11
    ********************************************************************************************/
    FUNCTION set_inst_guideline
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_inst_guideline OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_guideline          pk_types.cursor_type;
        l_c_guideline_desc        pk_types.cursor_type;
        l_c_flg_status            pk_types.cursor_type;
        l_c_context_title         pk_types.cursor_type;
        l_c_context_adaptation    pk_types.cursor_type;
        l_c_context_type_media    pk_types.cursor_type;
        l_c_context_editor        pk_types.cursor_type;
        l_c_id_guideline_ebm      pk_types.cursor_type;
        l_c_context_edition_site  pk_types.cursor_type;
        l_c_context_edition       pk_types.cursor_type;
        l_c_context_access        pk_types.cursor_type;
        l_c_id_context_language   pk_types.cursor_type;
        l_c_context_subtitle      pk_types.cursor_type;
        l_c_id_context_assoc_lang pk_types.cursor_type;
        l_c_id_software           pk_types.cursor_type;
        l_c_flg_type_recommend    pk_types.cursor_type;
        l_c_context_desc          pk_types.cursor_type;
        l_c_id_content            pk_types.cursor_type;
        l_c_dt_context_edition    pk_types.cursor_type;
    
        l_data_id_guideline          table_number;
        l_data_guideline_desc        table_varchar;
        l_data_flg_status            table_varchar;
        l_data_context_title         table_varchar;
        l_data_context_adaptation    table_varchar;
        l_data_context_type_media    table_number;
        l_data_context_editor        table_varchar;
        l_data_id_guideline_ebm      table_number;
        l_data_context_edition_site  table_varchar;
        l_data_context_edition       table_varchar;
        l_data_context_access        table_varchar;
        l_data_id_context_language   table_number;
        l_data_context_subtitle      table_varchar;
        l_data_id_context_assoc_lang table_number;
        l_data_id_software           table_number;
        l_data_flg_type_recommend    table_varchar;
        l_data_context_desc          table_clob;
        l_data_id_content            table_varchar;
        l_data_dt_context_edition    table_date;
    
        --Call all SET Guideline functions
        l_c_guideline_link          pk_types.cursor_type;
        l_c_guideline_task_link     pk_types.cursor_type;
        l_c_guideline_context_img   pk_types.cursor_type;
        l_c_guideline_context_auth  pk_types.cursor_type;
        l_c_guideline_criteria      pk_types.cursor_type;
        l_c_guideline_criteria_link pk_types.cursor_type;
        l_c_adv_id_adv_input_link   pk_types.cursor_type;
        l_c_guideline_frequent      pk_types.cursor_type;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        g_func_name := 'SET_INST_GUIDELINE ';
    
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT GET_INST_GUIDELINE';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_guideline(i_lang,
                                      i_market,
                                      i_version,
                                      i_id_institution,
                                      i_software(i),
                                      l_c_id_guideline,
                                      l_c_guideline_desc,
                                      l_c_flg_status,
                                      l_c_context_title,
                                      l_c_context_adaptation,
                                      l_c_context_type_media,
                                      l_c_context_editor,
                                      l_c_id_guideline_ebm,
                                      l_c_context_edition_site,
                                      l_c_context_edition,
                                      l_c_context_access,
                                      l_c_id_context_language,
                                      l_c_context_subtitle,
                                      l_c_id_context_assoc_lang,
                                      l_c_id_software,
                                      l_c_flg_type_recommend,
                                      l_c_context_desc,
                                      l_c_id_content,
                                      l_c_dt_context_edition,
                                      l_error)
            
            THEN
                pk_alertlog.log_debug('ERRO: PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                RAISE l_exception;
            ELSE
                o_inst_guideline := l_c_id_guideline;
                LOOP
                    FETCH l_c_id_guideline BULK COLLECT
                        INTO l_data_id_guideline LIMIT g_array_size;
                
                    FETCH l_c_guideline_desc BULK COLLECT
                        INTO l_data_guideline_desc LIMIT g_array_size;
                
                    FETCH l_c_flg_status BULK COLLECT
                        INTO l_data_flg_status LIMIT g_array_size;
                
                    FETCH l_c_context_title BULK COLLECT
                        INTO l_data_context_title LIMIT g_array_size;
                
                    FETCH l_c_context_adaptation BULK COLLECT
                        INTO l_data_context_adaptation LIMIT g_array_size;
                
                    FETCH l_c_context_type_media BULK COLLECT
                        INTO l_data_context_type_media LIMIT g_array_size;
                
                    FETCH l_c_context_editor BULK COLLECT
                        INTO l_data_context_editor LIMIT g_array_size;
                
                    FETCH l_c_id_guideline_ebm BULK COLLECT
                        INTO l_data_id_guideline_ebm LIMIT g_array_size;
                
                    FETCH l_c_context_edition_site BULK COLLECT
                        INTO l_data_context_edition_site LIMIT g_array_size;
                
                    FETCH l_c_context_edition BULK COLLECT
                        INTO l_data_context_edition LIMIT g_array_size;
                
                    FETCH l_c_context_access BULK COLLECT
                        INTO l_data_context_access LIMIT g_array_size;
                
                    FETCH l_c_id_context_language BULK COLLECT
                        INTO l_data_id_context_language LIMIT g_array_size;
                
                    FETCH l_c_context_subtitle BULK COLLECT
                        INTO l_data_context_subtitle LIMIT g_array_size;
                
                    FETCH l_c_id_context_assoc_lang BULK COLLECT
                        INTO l_data_id_context_assoc_lang LIMIT g_array_size;
                
                    FETCH l_c_id_software BULK COLLECT
                        INTO l_data_id_software LIMIT g_array_size;
                
                    FETCH l_c_flg_type_recommend BULK COLLECT
                        INTO l_data_flg_type_recommend LIMIT g_array_size;
                
                    FETCH l_c_context_desc BULK COLLECT
                        INTO l_data_context_desc LIMIT g_array_size;
                
                    FETCH l_c_id_content BULK COLLECT
                        INTO l_data_id_content LIMIT g_array_size;
                
                    FETCH l_c_dt_context_edition BULK COLLECT
                        INTO l_data_dt_context_edition LIMIT g_array_size;
                
                    g_error := 'INSERT INTO GUIDELINE WITH FORALL [' || l_data_id_guideline.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    FORALL j IN 1 .. l_data_id_guideline.count
                        INSERT INTO guideline
                            (id_guideline,
                             id_guideline_previous_version,
                             guideline_desc,
                             id_professional,
                             dt_guideline,
                             flg_status,
                             context_title,
                             context_adaptation,
                             context_type_media,
                             context_editor,
                             id_guideline_ebm,
                             context_edition_site,
                             context_edition,
                             dt_context_edition,
                             context_access,
                             id_context_language,
                             context_subtitle,
                             id_context_associated_language,
                             adw_last_update,
                             id_institution,
                             id_software,
                             id_prof_cancel,
                             dt_cancel,
                             flg_type_recommendation,
                             context_desc,
                             id_content)
                        VALUES
                            (seq_guideline.nextval,
                             NULL,
                             l_data_guideline_desc(j),
                             NULL,
                             SYSDATE,
                             l_data_flg_status(j),
                             l_data_context_title(j),
                             l_data_context_adaptation(j),
                             l_data_context_type_media(j),
                             l_data_context_editor(j),
                             l_data_id_guideline_ebm(j),
                             l_data_context_edition_site(j),
                             l_data_context_edition(j),
                             l_data_dt_context_edition(j),
                             l_data_context_access(j),
                             l_data_id_context_language(j),
                             l_data_context_subtitle(j),
                             l_data_id_context_assoc_lang(j),
                             SYSDATE,
                             i_id_institution,
                             l_data_id_software(j),
                             NULL,
                             NULL,
                             l_data_flg_type_recommend(j),
                             l_data_context_desc(j),
                             l_data_id_content(j));
                
                    EXIT WHEN l_c_id_guideline%NOTFOUND;
                
                END LOOP;
            
                CLOSE l_c_id_guideline;
                CLOSE l_c_guideline_desc;
                CLOSE l_c_flg_status;
                CLOSE l_c_context_title;
                CLOSE l_c_context_adaptation;
                CLOSE l_c_context_type_media;
                CLOSE l_c_context_editor;
                CLOSE l_c_id_guideline_ebm;
                CLOSE l_c_context_edition_site;
                CLOSE l_c_context_edition;
                CLOSE l_c_context_access;
                CLOSE l_c_id_context_language;
                CLOSE l_c_context_subtitle;
                CLOSE l_c_id_context_assoc_lang;
                CLOSE l_c_id_software;
                CLOSE l_c_flg_type_recommend;
                CLOSE l_c_context_desc;
                CLOSE l_c_id_content;
                CLOSE l_c_dt_context_edition;
            
            END IF;
        END LOOP;
    
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'SET GUIDELINE_LINK';
                IF NOT set_inst_guideline_link(i_lang,
                                               table_number(i_market(j)),
                                               table_varchar(i_version(i)),
                                               i_id_institution,
                                               i_software,
                                               l_c_guideline_link,
                                               l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET GUIDELINE_TASK_LINK';
                IF NOT set_inst_guideline_task_link(i_lang,
                                                    table_number(i_market(j)),
                                                    table_varchar(i_version(i)),
                                                    i_id_institution,
                                                    i_software,
                                                    l_c_guideline_task_link,
                                                    l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET GUIDELINE_CONTEXT_IMG';
                IF NOT set_inst_guideline_context_img(i_lang,
                                                      table_number(i_market(j)),
                                                      table_varchar(i_version(i)),
                                                      i_id_institution,
                                                      i_software,
                                                      l_c_guideline_context_img,
                                                      l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET GUIDELINE_CONTEXT_AUTH';
                IF NOT set_inst_guideline_cntext_auth(i_lang,
                                                      table_number(i_market(j)),
                                                      table_varchar(i_version(i)),
                                                      i_id_institution,
                                                      i_software,
                                                      l_c_guideline_context_auth,
                                                      l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET GUIDELINE_CRITERIA';
                IF NOT set_inst_guideline_criteria(i_lang,
                                                   table_number(i_market(j)),
                                                   table_varchar(i_version(i)),
                                                   i_id_institution,
                                                   i_software,
                                                   l_c_guideline_criteria,
                                                   l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET GUIDELINE_CRITERIA_LINK';
                IF NOT set_inst_guideline_crit_link(i_lang,
                                                    table_number(i_market(j)),
                                                    table_varchar(i_version(i)),
                                                    i_id_institution,
                                                    i_software,
                                                    l_c_guideline_criteria_link,
                                                    l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET GUIDELINE_ADV_INPUT';
                IF NOT set_inst_guide_adv_input_value(i_lang,
                                                      table_number(i_market(j)),
                                                      table_varchar(i_version(i)),
                                                      i_software,
                                                      l_c_adv_id_adv_input_link,
                                                      l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'SET GUIDELINE_FREQUENT';
                IF NOT set_inst_guideline_frequent(i_lang,
                                                   table_number(i_market(j)),
                                                   table_varchar(i_version(i)),
                                                   i_id_institution,
                                                   i_software,
                                                   l_c_guideline_frequent,
                                                   l_error)
                THEN
                    RAISE l_exception;
                END IF;
            END LOOP;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guideline;
    /********************************************************************************************
    * Get Guideline link set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_id_guideline        Cursor of Guideline
    * @param o_id_link             Cursor of flags
    * @param o_link_type           Cursor of Link Type
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/11
    ********************************************************************************************/
    FUNCTION get_inst_guideline_link
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_guideline   OUT pk_types.cursor_type,
        o_id_link        OUT pk_types.cursor_type,
        o_link_type      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_guideline_def guideline_link.id_guideline%TYPE := NULL;
        l_id_guideline     guideline_link.id_guideline%TYPE := NULL;
        l_link_type_def    guideline_link.link_type%TYPE := NULL;
        l_id_content_def   guideline.id_content%TYPE := NULL;
        l_id_link_def      guideline_link.id_link%TYPE := NULL;
    
        l_id_guideline_array table_number := table_number();
        l_link_type_array    table_varchar := table_varchar();
        l_id_link_array      table_number := table_number();
    
        l_tab_diagnosis table_number := table_number();
    
        l_detp_array table_number := table_number();
        l_temp_guid  guideline.id_guideline%TYPE := 0;
    
        l_dept_index NUMBER := 1;
    
        l_count_spec       NUMBER := 0;
        l_count_cs         NUMBER := 0;
        l_count_dept       NUMBER := 0;
        l_count_diag       NUMBER := 0;
        l_count_guide_type NUMBER := 0;
        l_index            NUMBER := 1;
    
        l_id_clin_serv_def clinical_service.id_content%TYPE := NULL;
        l_id_clin_serv     clinical_service.id_clinical_service%TYPE := NULL;
        l_id_diagnosis     diagnosis.id_diagnosis%TYPE := NULL;
        l_id_speciality    speciality.id_speciality%TYPE := NULL;
    
        l_exception EXCEPTION;
    
        l_id_dept dept.id_dept%TYPE;
    
        l_var_s VARCHAR2(1) := pk_guidelines.g_guide_link_spec;
        l_var_e VARCHAR2(1) := pk_guidelines.g_guide_link_envi;
        l_var_t VARCHAR2(1) := pk_guidelines.g_guide_link_type;
        l_var_h VARCHAR2(1) := pk_guidelines.g_guide_link_pathol;
        l_var_p VARCHAR2(1) := pk_guidelines.g_guide_link_prof;
        --l_var_d VARCHAR2(1) := pk_guidelines.g_guide_link_edit_prof;
        l_var_c VARCHAR2(1) := pk_guidelines.g_guide_link_chief_complaint;
    
        CURSOR c_guideline_link
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT gl.id_guideline, g.id_content, gl.id_link, gl.link_type
              FROM alert_default.guideline_link gl
              JOIN alert_default.guideline g
                ON (g.id_guideline = gl.id_guideline)
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = gl.id_guideline AND gmv.id_market = c_market AND gmv.version = c_version)
             ORDER BY gl.id_guideline;
    
        CURSOR c_software_dept
        (
            c_id_software    IN software.id_software%TYPE,
            c_id_institution IN institution.id_institution%TYPE,
            c_depts          IN table_number
        ) IS
            SELECT DISTINCT t.id_dept
              FROM software_dept sd, dept t
             WHERE sd.id_software = c_id_software
               AND sd.id_dept = t.id_dept
               AND t.id_institution = c_id_institution
               AND t.flg_available = g_yes
               AND t.id_dept NOT IN (SELECT nvl(column_value, 0)
                                       FROM TABLE(CAST(c_depts AS table_number)))
               AND rownum = 1;
    
        CURSOR c_clinical_service(c_id_link IN guideline_link.id_link%TYPE) IS
            SELECT cs.id_content
              FROM alert_default.clinical_service cs
             WHERE cs.flg_available = g_yes
               AND cs.id_clinical_service IN
                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                     column_value
                      FROM TABLE(CAST(pk_backoffice_default.check_clinical_service_parent(i_lang, c_id_link) AS
                                      table_number)) p);
    
        CURSOR c_diagnosis
        (
            c_id_software           IN software.id_software%TYPE,
            c_id_institution        IN institution.id_institution%TYPE,
            c_id_link               IN guideline_link.id_link%TYPE,
            c_id_software_config    IN software.id_software%TYPE,
            c_id_institution_config IN institution.id_institution%TYPE
        ) IS
            SELECT DISTINCT d.id_diagnosis
              FROM diagnosis_content d
             WHERE d.id_software = c_id_software
               AND d.flg_type_dep_clin = pk_diagnosis.g_diag_pesq
               AND d.id_institution = c_id_institution
               AND d.id_diagnosis = c_id_link;
    
        CURSOR c_guid
        (
            c_id_guideline IN guideline_link.id_guideline%TYPE,
            c_id_link      IN guideline_link.id_link%TYPE,
            c_link_type    IN guideline_link.link_type%TYPE
        ) IS
            SELECT COUNT(gl.id_guideline)
              FROM guideline_link gl
             WHERE gl.id_guideline = c_id_guideline
               AND gl.id_link = c_id_link
               AND gl.link_type = c_link_type;
    BEGIN
        g_func_name := 'GET_INST_GUIDELINE_LINK ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_GUIDELINE_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guideline_link(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_guideline_link
                        INTO l_id_guideline_def, l_id_content_def, l_id_link_def, l_link_type_def;
                    EXIT WHEN c_guideline_link%NOTFOUND;
                
                    SELECT nvl((SELECT g.id_guideline
                                 FROM guideline g
                                WHERE g.id_content = l_id_content_def
                                  AND g.id_content IS NOT NULL
                                  AND g.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_guideline
                      FROM dual;
                
                    IF l_id_guideline != 0
                    THEN
                        IF l_temp_guid != l_id_guideline
                        THEN
                            l_temp_guid  := l_id_guideline;
                            l_detp_array := table_number();
                            l_dept_index := 1;
                        END IF;
                    
                        IF l_link_type_def = l_var_c
                        THEN
                            g_error := 'L_LINK_TYPE_DEF ' || l_id_link_def || '/' || l_id_guideline;
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            SELECT COUNT(gl.id_guideline)
                              INTO l_count_spec
                              FROM guideline_link gl
                              JOIN complaint c
                                ON (c.id_complaint = gl.id_link)
                             WHERE gl.id_guideline = l_id_guideline
                               AND gl.id_link = l_id_link_def
                               AND gl.link_type = l_link_type_def;
                        
                            IF l_count_spec = 0
                            THEN
                                g_error := 'IF L_COUNT_SPEC = 0';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                l_id_guideline_array.extend;
                                l_id_link_array.extend;
                                l_link_type_array.extend;
                            
                                l_id_guideline_array(l_index) := l_id_guideline;
                                l_link_type_array(l_index) := l_link_type_def;
                                l_id_link_array(l_index) := l_id_link_def;
                            
                                l_index := l_index + 1;
                            END IF;
                        ELSIF l_link_type_def = l_var_p
                        THEN
                        
                            g_error := 'L_LINK_TYPE_DEF ' || l_id_link_def || '/' || l_id_guideline;
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            SELECT COUNT(gl.id_guideline)
                              INTO l_count_spec
                              FROM guideline_link gl
                              JOIN category c
                                ON (c.id_category = gl.id_link)
                             WHERE gl.id_guideline = l_id_guideline
                               AND gl.id_link = l_id_link_def
                               AND gl.link_type = l_link_type_def;
                        
                            IF l_count_spec = 0
                            THEN
                                g_error := 'IF L_COUNT_SPEC = 0';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                l_id_guideline_array.extend;
                                l_id_link_array.extend;
                                l_link_type_array.extend;
                            
                                l_id_guideline_array(l_index) := l_id_guideline;
                                l_link_type_array(l_index) := l_link_type_def;
                                l_id_link_array(l_index) := l_id_link_def;
                            
                                l_index := l_index + 1;
                            END IF;
                        
                        ELSIF l_link_type_def = l_var_s
                        THEN
                            --> by Speciality (PFH)
                            IF i_id_software != pk_alert_constant.g_soft_primary_care
                            THEN
                                g_error := 'NOT CARE GET SPECIALITY_ID ' || l_id_link_def;
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT s.id_speciality
                                             FROM speciality s
                                            WHERE s.id_content =
                                                  (SELECT sd.id_content
                                                     FROM alert_default.speciality sd
                                                    WHERE sd.id_speciality = l_id_link_def)
                                              AND s.id_content IS NOT NULL
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_speciality
                                  FROM dual;
                            
                                IF l_id_speciality != 0
                                THEN
                                
                                    g_error := 'SELECT COUNT ID_GUIDELINE ' || l_id_speciality;
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT COUNT(gl.id_guideline)
                                      INTO l_count_spec
                                      FROM guideline_link gl
                                      JOIN speciality s
                                        ON (s.id_speciality = gl.id_link)
                                     WHERE gl.id_guideline = l_id_guideline
                                       AND gl.id_link = l_id_speciality
                                       AND gl.link_type = l_link_type_def;
                                
                                    IF l_count_spec = 0
                                    THEN
                                        g_error := 'IF l_count_spec = 0';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        l_id_guideline_array.extend;
                                        l_id_link_array.extend;
                                        l_link_type_array.extend;
                                    
                                        l_id_guideline_array(l_index) := l_id_guideline;
                                        l_link_type_array(l_index) := l_link_type_def;
                                        l_id_link_array(l_index) := l_id_speciality;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END IF;
                                --> by Clinical_Service (CARE)
                            ELSE
                                g_error := 'OPEN C_CLINICAL_SERVICE CURSOR ' || l_id_link_def;
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                OPEN c_clinical_service(l_id_link_def);
                                LOOP
                                    g_error := 'FETCH C_CLINICAL_SERVICE ' || l_id_link_def;
                                    FETCH c_clinical_service
                                        INTO l_id_clin_serv_def;
                                    EXIT WHEN c_clinical_service%NOTFOUND;
                                
                                    g_error := 'GET_CLINICAL_SERVICE_ID ' || l_id_clin_serv_def;
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT nvl((SELECT cs.id_clinical_service
                                                 FROM clinical_service cs
                                                WHERE cs.id_content = l_id_clin_serv_def
                                                  AND cs.id_content IS NOT NULL
                                                  AND cs.flg_available = g_yes
                                                  AND rownum = 1),
                                               0)
                                      INTO l_id_clin_serv
                                      FROM dual;
                                
                                    IF l_id_clin_serv != 0
                                    THEN
                                        g_error := 'SELECT COUNT ID_GUIDELINE ' || l_id_guideline || '/' ||
                                                   l_id_clin_serv || '/' || l_link_type_def;
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        OPEN c_guid(c_id_guideline => l_id_guideline,
                                                    c_id_link      => l_id_clin_serv,
                                                    c_link_type    => l_link_type_def);
                                        FETCH c_guid
                                            INTO l_count_cs;
                                        CLOSE c_guid;
                                    
                                        IF l_count_cs = 0
                                        THEN
                                            l_id_guideline_array.extend;
                                            l_link_type_array.extend;
                                            l_id_link_array.extend;
                                        
                                            l_id_guideline_array(l_index) := l_id_guideline;
                                            l_link_type_array(l_index) := l_link_type_def;
                                            l_id_link_array(l_index) := l_id_clin_serv;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                
                                END LOOP;
                                g_error := 'CLOSE C_CLINICAL_SERVICE CURSOR';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                CLOSE c_clinical_service;
                            END IF;
                        ELSIF l_link_type_def = l_var_e
                        THEN
                            --> by DEPT     
                            g_error := 'OPEN C_SOFTWARE_DEPT CURSOR ' || l_link_type_def || '/' || l_id_link_def || '/' ||
                                       i_id_institution;
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            OPEN c_software_dept(l_id_link_def, i_id_institution, l_detp_array);
                            LOOP
                                g_error := 'FETCH C_SOFTWARE_DEPT ';
                                FETCH c_software_dept
                                    INTO l_id_dept;
                                EXIT WHEN c_software_dept%NOTFOUND;
                            
                                g_error := g_error || l_id_dept;
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            
                                IF l_id_dept IS NOT NULL
                                THEN
                                    l_detp_array.extend;
                                    l_detp_array(l_dept_index) := l_id_dept;
                                    l_dept_index := l_dept_index + 1;
                                
                                    g_error := 'COUNT(ID_GUIDELINE)';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    OPEN c_guid(c_id_guideline => l_id_guideline,
                                                c_id_link      => l_id_dept,
                                                c_link_type    => l_link_type_def);
                                    FETCH c_guid
                                        INTO l_count_dept;
                                    CLOSE c_guid;
                                
                                    IF l_count_dept = 0
                                    THEN
                                        l_id_guideline_array.extend;
                                        l_link_type_array.extend;
                                        l_id_link_array.extend;
                                    
                                        l_id_guideline_array(l_index) := l_id_guideline;
                                        l_link_type_array(l_index) := l_link_type_def;
                                        l_id_link_array(l_index) := l_id_dept;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_SOFTWARE_DEPT CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_software_dept;
                        
                        ELSIF l_link_type_def = l_var_h
                        --> by Diagnosis
                        THEN
                        
                            IF l_id_link_def != 0
                            THEN
                            
                                g_error := 'OPEN C_DIAGNOSIS ' || l_id_link_def;
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                OPEN c_diagnosis(i_id_software,
                                                 i_id_institution,
                                                 l_id_link_def,
                                                 i_id_software,
                                                 i_id_institution);
                                FETCH c_diagnosis BULK COLLECT
                                    INTO l_tab_diagnosis;
                                CLOSE c_diagnosis;
                            
                                IF l_tab_diagnosis.count = 0
                                THEN
                                    g_error := 'OPEN C_DIAGNOSIS [0 0]';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    OPEN c_diagnosis(i_id_software, i_id_institution, l_id_link_def, 0, 0);
                                    FETCH c_diagnosis BULK COLLECT
                                        INTO l_tab_diagnosis;
                                    CLOSE c_diagnosis;
                                END IF;
                            
                                FOR i IN 1 .. l_tab_diagnosis.count
                                LOOP
                                
                                    g_error := 'COUNT_DIAGNOSIS ' || l_tab_diagnosis(i) || '/' || l_id_guideline;
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    OPEN c_guid(c_id_guideline => l_id_guideline,
                                                c_id_link      => l_tab_diagnosis(i),
                                                c_link_type    => l_link_type_def);
                                    FETCH c_guid
                                        INTO l_count_diag;
                                    CLOSE c_guid;
                                
                                    IF l_count_diag = 0
                                    THEN
                                        g_error := 'NEW ' || l_tab_diagnosis(i) || '/' || l_id_guideline;
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        l_id_guideline_array.extend;
                                        l_link_type_array.extend;
                                        l_id_link_array.extend;
                                    
                                        l_id_guideline_array(l_index) := l_id_guideline;
                                        l_link_type_array(l_index) := l_link_type_def;
                                        l_id_link_array(l_index) := l_tab_diagnosis(i);
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END LOOP;
                            END IF;
                        
                        ELSIF l_link_type_def = l_var_t
                        --> by Protocol Type
                        THEN
                            g_error := 'l_count_prtcl_type';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        
                            SELECT COUNT(gl.id_guideline)
                              INTO l_count_guide_type
                              FROM guideline_link gl
                              JOIN protocol_type pt
                                ON (pt.id_protocol_type = gl.id_link AND pt.flg_available = g_yes AND
                                   pt.id_protocol_type = l_id_link_def)
                             WHERE gl.id_guideline = l_id_guideline
                               AND gl.link_type = l_link_type_def;
                        
                            IF l_count_guide_type = 0
                            THEN
                                l_id_guideline_array.extend;
                                l_link_type_array.extend;
                                l_id_link_array.extend;
                            
                                l_id_guideline_array(l_index) := l_id_guideline;
                                l_link_type_array(l_index) := l_link_type_def;
                                l_id_link_array(l_index) := l_id_link_def;
                            
                                l_index := l_index + 1;
                            END IF;
                        END IF;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_GUIDELINE_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guideline_link;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_GUIDELINE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_array AS table_number));
    
        g_error := 'OPEN O_ID_LINK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_link FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_link_array AS table_number));
    
        g_error := 'OPEN O_LINK_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_link_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_link_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_guideline);
            pk_types.open_my_cursor(o_id_link);
            pk_types.open_my_cursor(o_link_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guideline_link;
    /*********************************************************************************************
    * Set Guideline link for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_guideline_link      Cursor of Instituition Guideline_Link
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/12
    ********************************************************************************************/
    FUNCTION set_inst_guideline_link
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_guideline_link OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_guideline pk_types.cursor_type;
        l_c_id_link      pk_types.cursor_type;
        l_c_link_type    pk_types.cursor_type;
    
        l_data_id_guideline table_number;
        l_data_id_link      table_number;
        l_data_link_type    table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_GUIDELINE_LINK ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_GUIDELINE_LINK';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_guideline_link(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_software(i),
                                           l_c_id_guideline,
                                           l_c_id_link,
                                           l_c_link_type,
                                           o_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'o_guideline_link := l_c_id_guideline';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_guideline_link := l_c_id_guideline;
            
                LOOP
                    FETCH l_c_id_guideline BULK COLLECT
                        INTO l_data_id_guideline LIMIT g_array_size;
                
                    FETCH l_c_id_link BULK COLLECT
                        INTO l_data_id_link LIMIT g_array_size;
                
                    FETCH l_c_link_type BULK COLLECT
                        INTO l_data_link_type LIMIT g_array_size;
                
                    g_error := 'INSERT INTO GUIDELINE_LINK [' || l_data_id_guideline.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    FOR j IN 1 .. l_data_id_guideline.count
                    LOOP
                        g_error := 'INSERT INTO GUIDELINE_LINK (seq_guideline_link.NEXTVAL,' || l_data_id_guideline(j) || ', ' ||
                                   l_data_id_link(j) || ', ' || l_data_link_type(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO guideline_link
                            (id_guideline_link, id_guideline, id_link, link_type)
                        VALUES
                            (seq_guideline_link.nextval,
                             l_data_id_guideline(j),
                             l_data_id_link(j),
                             l_data_link_type(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_guideline%NOTFOUND;
                
                END LOOP;
                g_error := 'CLOSE l_c_id_guideline CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_guideline;
                g_error := 'CLOSE l_c_id_link CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_link;
                g_error := 'CLOSE l_c_link_type CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_link_type;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guideline_link;
    /********************************************************************************************
    * Get Guideline Task Link set by Protocol
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_id_guideline        Cursor of Guideline
    * @param o_id_task_link        Cursor of Task Link
    * @param o_task_type           Cursor of Task Type
    * @param o_task_notes          Cursor of Task Notes
    * @param o_id_task_attach      Cursor of Task Attach
    * @param o_task_codif          Cursor of Task Codificaton
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/12
    ********************************************************************************************/
    FUNCTION get_inst_guideline_task_link
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_guideline   OUT pk_types.cursor_type,
        o_id_task_link   OUT pk_types.cursor_type,
        o_task_type      OUT pk_types.cursor_type,
        o_task_notes     OUT pk_types.cursor_type,
        o_id_task_attach OUT pk_types.cursor_type,
        o_task_codif     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_guideline_def guideline_task_link.id_guideline%TYPE := NULL;
        l_id_guideline     guideline_task_link.id_guideline%TYPE := NULL;
        l_id_content_def   guideline.id_content%TYPE := NULL;
        l_id_task_link     guideline_task_link.id_task_link%TYPE := NULL;
        l_task_type        guideline_task_link.task_type%TYPE := NULL;
        l_task_notes       guideline_task_link.task_notes%TYPE := NULL;
        l_id_task_attach   guideline_task_link.id_task_attach%TYPE := NULL;
        l_task_codif       guideline_task_link.task_codification%TYPE := NULL;
    
        l_id_guideline_array   table_number := table_number();
        l_id_task_link_array   table_varchar := table_varchar();
        l_task_type_array      table_number := table_number();
        l_task_notes_array     table_varchar := table_varchar();
        l_id_task_attach_array table_number := table_number();
        l_task_codif_array     table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        --> Tasks Types
        l_var_analysis       NUMBER := pk_guidelines.g_task_analysis; -- Analises := 1;
        l_var_appoint        NUMBER := pk_guidelines.g_task_appoint; -- Consultas := 2;
        l_var_img            NUMBER := pk_guidelines.g_task_img; -- Imagem: exam := 4;
        l_var_enfint         NUMBER := pk_guidelines.g_task_enfint; -- Intervenes de enfermagem := 6;
        l_var_drug           NUMBER := pk_guidelines.g_task_drug; -- Medicao : drug / tabelas infarmed := 7;
        l_var_otherexam      NUMBER := pk_guidelines.g_task_otherexam; -- Outros exames : exam := 8;
        l_var_spec           NUMBER := pk_guidelines.g_task_spec; -- Pareceres : speciality := 9;
        l_var_drug_ext       NUMBER := pk_guidelines.g_task_drug_ext; -- Medicao exterior := 11;
        l_var_proc           NUMBER := pk_guidelines.g_task_proc; -- Procedimentos := 12;
        l_var_monitorization NUMBER := pk_guidelines.g_task_monitorization; -- monitorizacoes := 14;
        l_var_pat_educ       NUMBER := pk_guidelines.g_task_patient_education;
    
        --Analysis
        l_id_analysis_def analysis.id_content%TYPE := NULL;
        l_id_analysis     analysis.id_analysis%TYPE := NULL;
        l_asys_codif      analysis_codification.id_analysis_codification%TYPE := NULL;
        --Appointment
        l_id_clin_serv_def clinical_service.id_content%TYPE := NULL;
        l_id_clin_serv     clinical_service.id_clinical_service%TYPE := NULL;
        l_id_dep_clin_serv dep_clin_serv.id_dep_clin_serv%TYPE := NULL;
        --ICNP Composition
        l_id_icnp_def icnp_composition.id_content%TYPE := NULL;
        l_id_icnp     icnp_composition.id_composition%TYPE := NULL;
        --Exams
        l_id_exam_img_def   exam.id_content%TYPE := NULL;
        l_id_exam_img       exam.id_exam%TYPE := NULL;
        l_exam_img          exam.flg_type%TYPE := pk_exam_constant.g_type_img;
        l_id_exam_other_def exam.id_content%TYPE := NULL;
        l_id_exam_other     exam.id_exam%TYPE := NULL;
        l_exam_other        exam.flg_type%TYPE := pk_exam_constant.g_type_exm;
        l_exam_img_codif    exam_codification.id_exam_codification%TYPE := NULL;
        l_exam_other_codif  exam_codification.id_exam_codification%TYPE := NULL;
        --Medication
        g_config_prescription_type sys_config.id_sys_config%TYPE := 'PRESCRIPTION_TYPE';
        l_id_drug                  mi_med.id_drug%TYPE := NULL;
        l_emb_id                   me_med.emb_id%TYPE := NULL;
        --Speciality
        l_id_spec speciality.id_speciality%TYPE;
        --Procedures
        l_id_intervention_def intervention.id_content%TYPE := NULL;
        l_id_intervention     intervention.id_intervention%TYPE := NULL;
        l_interv_codif        interv_codification.id_interv_codification%TYPE := NULL;
        --Vital_Sign
        l_id_vital_sign vital_sign.id_vital_sign%TYPE;
        l_count_vsi     NUMBER := 0;
        --PAT EDUC
        l_id_pat_educ nurse_tea_topic.id_nurse_tea_topic%TYPE;
    
        CURSOR c_guideline_task
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT gtl.id_guideline,
                            g.id_content,
                            gtl.id_task_link,
                            gtl.task_type,
                            gtl.task_notes,
                            gtl.id_task_attach,
                            gtl.task_codification
              FROM alert_default.guideline_task_link gtl
              JOIN alert_default.guideline g
                ON (g.id_guideline = gtl.id_guideline)
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = gtl.id_guideline AND gmv.id_market = c_market AND gmv.version = c_version);
    
        CURSOR c_analysis
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT a.id_content
              FROM alert_default.analysis a
              JOIN alert_default.analysis_mrk_vrs amv
                ON (amv.id_analysis = a.id_analysis AND amv.id_market = c_market AND amv.version = c_version)
              JOIN alert_default.analysis_instit_soft ais
                ON (ais.id_analysis = a.id_analysis AND ais.id_software = c_id_software AND ais.flg_available = g_yes AND
                   ais.flg_type = pk_alert_constant.g_analysis_request)
             WHERE a.flg_available = g_yes
               AND a.id_analysis = c_id_task_link;
    
        CURSOR c_appointment(c_id_task_link IN guideline_task_link.id_task_link%TYPE) IS
            SELECT cs.id_content
              FROM alert_default.clinical_service cs
             WHERE cs.flg_available = g_yes
               AND cs.id_clinical_service IN
                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                     column_value
                      FROM TABLE(CAST(pk_backoffice_default.check_clinical_service_parent(i_lang, c_id_task_link) AS
                                      table_number)) p);
    
        CURSOR c_icnp
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT i.id_content
              FROM alert_default.icnp_composition i
              JOIN alert_default.icnp_compo_cs ic
                ON (ic.id_composition = i.id_composition AND ic.id_market = c_market AND ic.version = c_version AND
                   ic.id_software = c_id_software)
              JOIN alert_default.clinical_service cs
                ON (cs.id_clinical_service = ic.id_clinical_service AND cs.flg_available = g_yes)
             WHERE i.flg_available = g_yes
               AND i.flg_type = 'A'
               AND i.id_software = c_id_software
               AND i.id_composition = c_id_task_link;
    
        CURSOR c_exams
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_exam_type    exam.flg_type%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT e.id_content
              FROM alert_default.exam e
              JOIN alert_default.exam_mrk_vrs emv
                ON (emv.id_exam = e.id_exam AND emv.id_market = c_market AND emv.version = c_version)
              JOIN alert_default.exam_clin_serv ecs
                ON (ecs.id_exam = e.id_exam AND ecs.id_software = c_id_software AND
                   ecs.flg_type = pk_exam_constant.g_exam_can_req)
             WHERE e.flg_available = g_yes
               AND e.id_exam = c_id_task_link
               AND e.flg_type = c_exam_type;
    
        CURSOR c_intervention
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT i.id_content
              FROM alert_default.intervention i
              JOIN alert_default.interv_mrk_vrs imv
                ON (imv.id_intervention = i.id_intervention AND imv.id_market = c_market AND imv.version = c_version)
              JOIN alert_default.interv_clin_serv ics
                ON (i.id_intervention = i.id_intervention AND ics.id_software = c_id_software AND
                   ics.flg_type = pk_procedures_constant.g_interv_can_req)
             WHERE i.flg_status = pk_alert_constant.g_active
               AND i.id_intervention = c_id_task_link;
    
        CURSOR c_vital_sign
        (
            c_id_task_link IN guideline_task_link.id_task_link%TYPE,
            c_id_software  IN software.id_software%TYPE,
            c_version      IN VARCHAR2,
            c_market       IN NUMBER
        ) IS
            SELECT DISTINCT vs.id_vital_sign
              FROM vital_sign vs
              JOIN alert_default.vs_soft_inst vsi
                ON (vsi.id_vital_sign = vs.id_vital_sign AND vsi.id_market = c_market AND vsi.version = c_version AND
                   vsi.flg_view = 'V2' AND vsi.id_software = c_id_software)
             WHERE vs.flg_available = g_yes
               AND vs.id_vital_sign = c_id_task_link;
    
        CURSOR c_count_guid_task_link
        (
            c_id_guideline      IN guideline_task_link.id_guideline%TYPE,
            c_id_task_link      IN guideline_task_link.id_task_link%TYPE,
            c_task_type         IN guideline_task_link.task_type%TYPE,
            c_id_task_attach    IN guideline_task_link.id_task_attach%TYPE,
            c_task_codification IN guideline_task_link.task_codification%TYPE
        ) IS
            SELECT COUNT(gtl.id_guideline_task_link)
              FROM guideline_task_link gtl
             WHERE gtl.id_guideline = c_id_guideline
               AND gtl.id_task_link = c_id_task_link
               AND gtl.task_type = c_task_type
               AND (gtl.id_task_attach = c_id_task_attach OR (gtl.id_task_attach IS NULL AND c_id_task_attach IS NULL))
               AND (gtl.task_codification = c_task_codification OR
                   (gtl.task_codification IS NULL AND c_task_codification IS NULL));
    
    BEGIN
        g_func_name := 'GET_INST_GUIDELINE_TASK_LINK ';
    
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_GUIDELINE_TASK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guideline_task(i_id_software, i_version(i), i_market(j));
                LOOP
                    g_error := 'FETCH C_GUIDELINE_TASK';
                    FETCH c_guideline_task
                        INTO l_id_guideline_def,
                             l_id_content_def,
                             l_id_task_link,
                             l_task_type,
                             l_task_notes,
                             l_id_task_attach,
                             l_task_codif;
                    EXIT WHEN c_guideline_task%NOTFOUND;
                
                    g_error := 'SELECT ID_GUIDELINE ' || l_id_content_def;
                    SELECT nvl((SELECT g.id_guideline
                                 FROM guideline g
                                WHERE g.id_content = l_id_content_def
                                  AND g.id_content IS NOT NULL
                                  AND g.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_guideline
                      FROM dual;
                
                    IF l_id_guideline != 0
                    THEN
                    
                        --> PAT EDUCATION 
                        IF l_task_type = l_var_pat_educ
                        
                        --> Added by JM 10-04-2013  
                        
                        THEN
                            SELECT nvl((SELECT DISTINCT ntt.id_nurse_tea_topic
                                         FROM nurse_tea_topic ntt
                                        WHERE ntt.flg_available = g_yes
                                          AND ntt.id_nurse_tea_topic = l_id_task_link
                                          AND rownum = 1),
                                       0)
                              INTO l_id_pat_educ
                              FROM dual;
                            IF l_id_pat_educ != 0
                            THEN
                                IF l_task_codif IS NULL
                                THEN
                                    g_error := '2 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                               l_id_analysis;
                                    OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                c_id_task_link      => l_id_pat_educ,
                                                                c_task_type         => l_task_type,
                                                                c_id_task_attach    => l_id_task_attach,
                                                                c_task_codification => l_task_codif);
                                    FETCH c_count_guid_task_link
                                        INTO l_count;
                                    CLOSE c_count_guid_task_link;
                                
                                    g_error := 'IF COUNT_TASK_PATIENT_EDUCATION ' || l_count;
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    IF l_count = 0
                                    THEN
                                    
                                        g_error := 'ANALYSIS NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        l_id_guideline_array.extend;
                                        l_id_task_link_array.extend;
                                        l_task_type_array.extend;
                                        l_task_notes_array.extend;
                                        l_id_task_attach_array.extend;
                                        l_task_codif_array.extend;
                                    
                                        l_id_guideline_array(l_index) := l_id_guideline;
                                        l_id_task_link_array(l_index) := l_id_pat_educ;
                                        l_task_type_array(l_index) := l_task_type;
                                        l_task_notes_array(l_index) := l_task_notes;
                                        l_id_task_attach_array(l_index) := l_id_task_attach;
                                        l_task_codif_array(l_index) := l_task_codif;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                
                                END IF;
                            END IF;
                        END IF;
                    
                        --> ANALYSIS
                        IF l_task_type = l_var_analysis
                        THEN
                            g_error := 'OPEN C_ANALYSIS ' || l_id_task_link || '/' || i_id_software || '/' ||
                                       i_version(i) || '/' || i_market(j);
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            OPEN c_analysis(l_id_task_link, i_id_software, i_version(i), i_market(j));
                            LOOP
                                g_error := 'FETCH C_ANALYSIS';
                                FETCH c_analysis
                                    INTO l_id_analysis_def;
                                EXIT WHEN c_analysis%NOTFOUND;
                            
                                g_error := 'SELECT ID_ANALYSIS ' || l_id_analysis_def;
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT a.id_analysis
                                             FROM analysis a
                                            WHERE a.id_content = l_id_analysis_def
                                              AND a.id_content IS NOT NULL
                                              AND a.flg_available = g_yes
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_analysis
                                  FROM dual;
                            
                                IF l_id_analysis != 0
                                THEN
                                    IF l_task_codif IS NOT NULL
                                    THEN
                                        g_error := 'SELECT ID_ANALYSIS_CODIFICATION ' || l_task_codif;
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        SELECT nvl((SELECT ac.id_analysis_codification
                                                     FROM analysis_codification ac
                                                    WHERE ac.id_analysis = l_id_analysis
                                                      AND ac.id_codification =
                                                          (SELECT t.id_codification
                                                             FROM codification t
                                                            WHERE t.id_content =
                                                                  (SELECT b.id_content
                                                                     FROM alert_default.codification b
                                                                     JOIN alert_default.analysis_codification ac1
                                                                       ON ac1.id_codification = b.id_codification
                                                                      AND ac1.id_analysis =
                                                                          (SELECT an.id_analysis
                                                                             FROM alert_default.analysis an
                                                                            WHERE an.id_content = l_id_analysis_def
                                                                              AND an.flg_available = g_yes)
                                                                      AND ac1.flg_available = g_yes)
                                                              AND t.flg_available = g_yes)
                                                      AND ac.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_asys_codif
                                          FROM dual;
                                    
                                        IF l_asys_codif != 0
                                        THEN
                                        
                                            g_error := '1 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                       l_id_analysis;
                                            OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                        c_id_task_link      => l_id_analysis,
                                                                        c_task_type         => l_task_type,
                                                                        c_id_task_attach    => l_id_task_attach,
                                                                        c_task_codification => l_asys_codif);
                                            FETCH c_count_guid_task_link
                                                INTO l_count;
                                            CLOSE c_count_guid_task_link;
                                        
                                            g_error := 'COUNT_TASK_ANALYSIS_CODIF = 0';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            IF l_count = 0
                                            THEN
                                                l_id_guideline_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_guideline_array(l_index) := l_id_guideline;
                                                l_id_task_link_array(l_index) := l_id_analysis;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_asys_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    ELSE
                                        g_error := '2 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                   l_id_analysis;
                                        OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                    c_id_task_link      => l_id_analysis,
                                                                    c_task_type         => l_task_type,
                                                                    c_id_task_attach    => l_id_task_attach,
                                                                    c_task_codification => l_task_codif);
                                        FETCH c_count_guid_task_link
                                            INTO l_count;
                                        CLOSE c_count_guid_task_link;
                                    
                                        g_error := 'IF COUNT_TASK_ANALYSIS ' || l_count;
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        IF l_count = 0
                                        THEN
                                            g_error := 'ANALYSIS NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            l_id_guideline_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_guideline_array(l_index) := l_id_guideline;
                                            l_id_task_link_array(l_index) := l_id_analysis;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_ANALYSIS CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_analysis;
                            --> APPOINTMENT
                        ELSIF l_task_type = l_var_appoint
                        THEN
                            g_error := 'OPEN C_APPOINTMENT ' || l_id_task_link;
                            OPEN c_appointment(l_id_task_link);
                            LOOP
                                g_error := 'FETCH C_APPOINTMENT';
                                FETCH c_appointment
                                    INTO l_id_clin_serv_def;
                                EXIT WHEN c_appointment%NOTFOUND;
                            
                                g_error := 'GET SUBSEQUENT APPOINTMENT';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                IF l_id_clin_serv_def != -1 --> Consultas subsequentes
                                THEN
                                    g_error := 'GET_CLINICAL_SERVICE_ID';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT nvl((SELECT cs.id_clinical_service
                                                 FROM clinical_service cs
                                                WHERE cs.id_content = l_id_clin_serv_def
                                                  AND cs.id_content IS NOT NULL
                                                  AND cs.flg_available = g_yes
                                                  AND rownum = 1),
                                               0)
                                      INTO l_id_clin_serv
                                      FROM dual;
                                
                                    IF l_id_clin_serv != 0
                                    THEN
                                        g_error := 'SELECT ID_DEP_CLIN_SERV';
                                        SELECT nvl((SELECT dcs.id_dep_clin_serv
                                                     FROM dep_clin_serv dcs
                                                     JOIN department d
                                                       ON (d.id_department = dcs.id_department AND
                                                          d.flg_available = g_yes AND d.id_software = i_id_software AND
                                                          d.id_institution = i_id_institution)
                                                     JOIN dept dp
                                                       ON (dp.id_dept = d.id_dept AND
                                                          dp.id_institution = i_id_institution)
                                                     JOIN clinical_service cs
                                                       ON (cs.id_clinical_service = dcs.id_clinical_service AND
                                                          cs.flg_available = g_yes AND
                                                          cs.id_clinical_service = l_id_clin_serv)
                                                    WHERE dcs.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_dep_clin_serv
                                          FROM dual;
                                    
                                        IF l_id_dep_clin_serv != 0
                                        THEN
                                        
                                            g_error := '3 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                       l_id_dep_clin_serv;
                                            OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                        c_id_task_link      => l_id_dep_clin_serv,
                                                                        c_task_type         => l_task_type,
                                                                        c_id_task_attach    => l_id_task_attach,
                                                                        c_task_codification => l_task_codif);
                                            FETCH c_count_guid_task_link
                                                INTO l_count;
                                            CLOSE c_count_guid_task_link;
                                        
                                            g_error := 'IF COUNT_TASK_ANALYSIS = 0';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            IF l_count = 0
                                            THEN
                                                l_id_guideline_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_guideline_array(l_index) := l_id_guideline;
                                                l_id_task_link_array(l_index) := l_id_dep_clin_serv;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_task_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                ELSE
                                    g_error := '4 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/ -1';
                                    OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                c_id_task_link      => -1,
                                                                c_task_type         => l_task_type,
                                                                c_id_task_attach    => l_id_task_attach,
                                                                c_task_codification => l_task_codif);
                                    FETCH c_count_guid_task_link
                                        INTO l_count;
                                    CLOSE c_count_guid_task_link;
                                
                                    g_error := 'IF COUNT_TASK_ANALYSIS = 0';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    IF l_count = 0
                                    THEN
                                        g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        l_id_guideline_array.extend;
                                        l_id_task_link_array.extend;
                                        l_task_type_array.extend;
                                        l_task_notes_array.extend;
                                        l_id_task_attach_array.extend;
                                        l_task_codif_array.extend;
                                    
                                        l_id_guideline_array(l_index) := l_id_guideline;
                                        l_id_task_link_array(l_index) := -1;
                                        l_task_type_array(l_index) := l_task_type;
                                        l_task_notes_array(l_index) := l_task_notes;
                                        l_id_task_attach_array(l_index) := l_id_task_attach;
                                        l_task_codif_array(l_index) := l_task_codif;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_APPOINTMENT CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_appointment;
                            --> ICNP_COMPOSITION
                        ELSIF l_task_type = l_var_enfint
                        THEN
                            g_error := 'OPEN C_ICNP ' || l_id_task_link || '/' || i_id_software;
                            OPEN c_icnp(l_id_task_link, i_id_software, i_version(i), i_market(j));
                            LOOP
                                g_error := 'FETCH C_ICNP';
                                FETCH c_icnp
                                    INTO l_id_icnp_def;
                                EXIT WHEN c_icnp%NOTFOUND;
                            
                                g_error := 'GET_ICNP_COMPOSITION_ID';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT ic.id_composition
                                             FROM icnp_composition ic
                                            WHERE ic.id_content = l_id_icnp_def
                                              AND ic.id_content IS NOT NULL
                                              AND ic.flg_available = g_yes
                                              AND ic.flg_type = 'A'
                                              AND ic.id_software = i_id_software
                                              AND ic.id_institution = i_id_institution
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_icnp
                                  FROM dual;
                            
                                IF l_id_icnp != 0
                                THEN
                                    g_error := '5 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' || l_id_icnp;
                                    OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                c_id_task_link      => l_id_icnp,
                                                                c_task_type         => l_task_type,
                                                                c_id_task_attach    => l_id_task_attach,
                                                                c_task_codification => l_task_codif);
                                    FETCH c_count_guid_task_link
                                        INTO l_count;
                                    CLOSE c_count_guid_task_link;
                                
                                    g_error := 'IF COUNT_TASK_ICNP = 0';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    IF l_count = 0
                                    THEN
                                        g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        l_id_guideline_array.extend;
                                        l_id_task_link_array.extend;
                                        l_task_type_array.extend;
                                        l_task_notes_array.extend;
                                        l_id_task_attach_array.extend;
                                        l_task_codif_array.extend;
                                    
                                        l_id_guideline_array(l_index) := l_id_guideline;
                                        l_id_task_link_array(l_index) := l_id_icnp;
                                        l_task_type_array(l_index) := l_task_type;
                                        l_task_notes_array(l_index) := l_task_notes;
                                        l_id_task_attach_array(l_index) := l_id_task_attach;
                                        l_task_codif_array(l_index) := l_task_codif;
                                    
                                        l_index := l_index + 1;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_ICNP CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_icnp;
                            --> EXAM_IMG
                        ELSIF l_task_type = l_var_img
                        THEN
                            g_error := 'OPEN C_EXAMS ' || l_id_task_link || '/' || l_exam_img || '/' || i_id_software;
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            OPEN c_exams(l_id_task_link, l_exam_img, i_id_software, i_version(i), i_market(j));
                            LOOP
                                g_error := 'FETCH C_EXAMS';
                                FETCH c_exams
                                    INTO l_id_exam_img_def;
                                EXIT WHEN c_exams%NOTFOUND;
                            
                                g_error := 'GET_EXAM_IMG_ID ' || l_id_exam_img_def;
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT e.id_exam
                                             FROM exam e
                                            WHERE e.id_content = l_id_exam_img_def
                                              AND e.id_content IS NOT NULL
                                              AND e.flg_available = g_yes
                                              AND e.flg_type = l_exam_img
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_exam_img
                                  FROM dual;
                            
                                IF l_id_exam_img != 0
                                THEN
                                    IF l_task_codif IS NOT NULL
                                    THEN
                                        g_error := 'SELECT ID_EXAM_CODIFICATION';
                                        SELECT nvl((SELECT ec.id_exam_codification
                                                     FROM exam_codification ec
                                                    WHERE ec.id_exam = l_id_exam_img
                                                      AND ec.id_codification =
                                                          (SELECT t.id_codification
                                                             FROM codification t
                                                            WHERE t.id_content =
                                                                  (SELECT b.id_content
                                                                     FROM alert_default.codification b
                                                                     JOIN alert_default.exam_codification ec1
                                                                       ON ec1.id_codification = b.id_codification
                                                                      AND ec1.id_exam =
                                                                          (SELECT e.id_exam
                                                                             FROM alert_default.exam e
                                                                            WHERE e.id_content = l_id_exam_img_def
                                                                              AND e.flg_type = l_exam_img
                                                                              AND e.flg_available = g_yes)
                                                                      AND ec1.flg_available = g_yes)
                                                              AND t.flg_available = g_yes)
                                                      AND ec.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_exam_img_codif
                                          FROM dual;
                                    
                                        IF l_exam_img_codif != 0
                                        THEN
                                        
                                            g_error := '6 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                       l_id_exam_img;
                                            OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                        c_id_task_link      => l_id_exam_img,
                                                                        c_task_type         => l_task_type,
                                                                        c_id_task_attach    => l_id_task_attach,
                                                                        c_task_codification => l_exam_img_codif);
                                            FETCH c_count_guid_task_link
                                                INTO l_count;
                                            CLOSE c_count_guid_task_link;
                                        
                                            g_error := 'IF COUNT_TASK_EXAM_IMG_CODIF = 0';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        
                                            IF l_count = 0
                                            THEN
                                                g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name ||
                                                                      g_error);
                                            
                                                l_id_guideline_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_guideline_array(l_index) := l_id_guideline;
                                                l_id_task_link_array(l_index) := l_id_exam_img;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_exam_img_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    ELSE
                                        g_error := '7 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                   l_id_exam_img;
                                        OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                    c_id_task_link      => l_id_exam_img,
                                                                    c_task_type         => l_task_type,
                                                                    c_id_task_attach    => l_id_task_attach,
                                                                    c_task_codification => l_task_codif);
                                        FETCH c_count_guid_task_link
                                            INTO l_count;
                                        CLOSE c_count_guid_task_link;
                                    
                                        g_error := 'IF COUNT_TASK_EXAM_IMG = 0';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        IF l_count = 0
                                        THEN
                                            g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        
                                            l_id_guideline_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_guideline_array(l_index) := l_id_guideline;
                                            l_id_task_link_array(l_index) := l_id_exam_img;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_EXAMS CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_exams;
                            --> EXAM_OTHER
                        ELSIF l_task_type = l_var_otherexam
                        THEN
                            g_error := 'OPEN C_EXAMS ' || l_id_task_link || '/' || l_exam_other;
                            OPEN c_exams(l_id_task_link, l_exam_other, i_id_software, i_version(i), i_market(j));
                            LOOP
                                g_error := 'FETCH C_EXAMS';
                                FETCH c_exams
                                    INTO l_id_exam_other_def;
                                EXIT WHEN c_exams%NOTFOUND;
                            
                                g_error := 'GET_EXAM_OTHER_ID ' || l_id_exam_other_def;
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT e.id_exam
                                             FROM exam e
                                            WHERE e.id_content = l_id_exam_other_def
                                              AND e.id_content IS NOT NULL
                                              AND e.flg_available = g_yes
                                              AND e.flg_type = l_exam_other
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_exam_other
                                  FROM dual;
                            
                                IF l_id_exam_other != 0
                                THEN
                                
                                    IF l_task_codif IS NOT NULL
                                    THEN
                                        g_error := 'SELECT ID_EXAM_CODIFICATION ' || l_id_exam_other || '/' ||
                                                   l_task_codif;
                                        SELECT nvl((SELECT ec.id_exam_codification
                                                     FROM exam_codification ec
                                                    WHERE ec.id_exam = l_id_exam_other
                                                      AND ec.id_codification =
                                                          (SELECT t.id_codification
                                                             FROM codification t
                                                            WHERE t.id_content =
                                                                  (SELECT b.id_content
                                                                     FROM alert_default.codification b
                                                                     JOIN alert_default.exam_codification ec1
                                                                       ON ec1.id_codification = b.id_codification
                                                                      AND ec1.id_exam =
                                                                          (SELECT e.id_exam
                                                                             FROM alert_default.exam e
                                                                            WHERE e.id_content = l_id_exam_other_def
                                                                              AND e.flg_type = l_exam_other
                                                                              AND e.flg_available = g_yes)
                                                                      AND ec1.flg_available = g_yes)
                                                              AND t.flg_available = g_yes)
                                                      AND ec.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_exam_other_codif
                                          FROM dual;
                                    
                                        IF l_exam_other_codif != 0
                                        THEN
                                            g_error := '8 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                       l_exam_other_codif;
                                            OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                        c_id_task_link      => l_id_exam_img,
                                                                        c_task_type         => l_task_type,
                                                                        c_id_task_attach    => l_id_task_attach,
                                                                        c_task_codification => l_exam_other_codif);
                                            FETCH c_count_guid_task_link
                                                INTO l_count;
                                            CLOSE c_count_guid_task_link;
                                        
                                            IF l_count = 0
                                            THEN
                                                g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name ||
                                                                      g_error);
                                            
                                                l_id_guideline_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_guideline_array(l_index) := l_id_guideline;
                                                l_id_task_link_array(l_index) := l_id_exam_img;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_exam_other_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    ELSE
                                        g_error := '9 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                   l_id_exam_img;
                                        OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                    c_id_task_link      => l_id_exam_img,
                                                                    c_task_type         => l_task_type,
                                                                    c_id_task_attach    => l_id_task_attach,
                                                                    c_task_codification => l_task_codif);
                                        FETCH c_count_guid_task_link
                                            INTO l_count;
                                        CLOSE c_count_guid_task_link;
                                    
                                        IF l_count = 0
                                        THEN
                                            g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        
                                            l_id_guideline_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_guideline_array(l_index) := l_id_guideline;
                                            l_id_task_link_array(l_index) := l_id_exam_img;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_EXAMS CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_exams;
                            --> Internal_Medication
                        ELSIF l_task_type = l_var_drug
                        THEN
                            g_error := 'PK_SYSCONFIG.GET_CONFIG PRESCRIPTION_TYPE ' || i_id_institution;
                            SELECT nvl((SELECT pk_sysconfig.get_config('PRESCRIPTION_TYPE',
                                                                      profissional(NULL, i_id_institution, i_id_software))
                                         FROM dual),
                                       NULL)
                              INTO g_config_prescription_type
                              FROM dual;
                        
                            BEGIN
                                g_error := 'SELECT ID_DRUG ' || g_config_prescription_type;
                                SELECT DISTINCT t.id_drug
                                  INTO l_id_drug
                                  FROM mi_med t
                                  JOIN drug_dep_clin_serv dcs
                                    ON (dcs.id_drug = t.id_drug AND dcs.id_institution = i_id_institution AND
                                       dcs.vers = g_config_prescription_type AND
                                       dcs.flg_type = pk_medication_types.c_ddcs_flg_type_pesq_p AND
                                       dcs.id_software = i_id_software)
                                 WHERE t.flg_available = g_yes
                                   AND t.flg_type = pk_guidelines.g_drug
                                   AND t.vers = g_config_prescription_type
                                   AND t.id_drug = l_id_task_link;
                            
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_id_drug := NULL;
                            END;
                        
                            IF l_id_drug IS NOT NULL
                               AND g_config_prescription_type IS NOT NULL
                            THEN
                            
                                g_error := '10 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' || l_id_drug;
                                OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                            c_id_task_link      => l_id_drug,
                                                            c_task_type         => l_task_type,
                                                            c_id_task_attach    => l_id_task_attach,
                                                            c_task_codification => l_task_codif);
                                FETCH c_count_guid_task_link
                                    INTO l_count;
                                CLOSE c_count_guid_task_link;
                            
                                IF l_count = 0
                                THEN
                                    g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    l_id_guideline_array.extend;
                                    l_id_task_link_array.extend;
                                    l_task_type_array.extend;
                                    l_task_notes_array.extend;
                                    l_id_task_attach_array.extend;
                                    l_task_codif_array.extend;
                                
                                    l_id_guideline_array(l_index) := l_id_guideline;
                                    l_id_task_link_array(l_index) := l_id_drug;
                                    l_task_type_array(l_index) := l_task_type;
                                    l_task_notes_array(l_index) := l_task_notes;
                                    l_id_task_attach_array(l_index) := l_id_task_attach;
                                    l_task_codif_array(l_index) := l_task_codif;
                                
                                    l_index := l_index + 1;
                                END IF;
                            END IF;
                            --> External_Medication
                        ELSIF l_task_type = l_var_drug_ext
                        THEN
                            g_error := 'GET CONFIG PRESCRIPTION_TYPE';
                            SELECT nvl((SELECT pk_sysconfig.get_config('PRESCRIPTION_TYPE',
                                                                      profissional(NULL, i_id_institution, i_id_software))
                                         FROM dual),
                                       NULL)
                              INTO g_config_prescription_type
                              FROM dual;
                        
                            g_error := 'SELECT EMB_ID ' || g_config_prescription_type;
                            SELECT nvl((SELECT DISTINCT t.emb_id
                                         FROM me_med t
                                         JOIN emb_dep_clin_serv edcs
                                           ON (edcs.emb_id = t.emb_id AND edcs.id_institution = i_id_institution AND
                                              edcs.vers = g_config_prescription_type AND
                                              edcs.flg_type = pk_medication_types.c_ddcs_flg_type_pesq_p AND
                                              edcs.id_software = i_id_software)
                                        WHERE t.flg_available = g_yes
                                          AND t.flg_comerc = g_yes
                                          AND t.vers = g_config_prescription_type
                                          AND t.emb_id = l_id_task_link),
                                       '0')
                              INTO l_emb_id
                              FROM dual;
                        
                            IF l_emb_id != '0'
                               AND g_config_prescription_type IS NOT NULL
                            THEN
                                g_error := '11 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' || l_emb_id;
                                OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                            c_id_task_link      => l_emb_id,
                                                            c_task_type         => l_task_type,
                                                            c_id_task_attach    => l_id_task_attach,
                                                            c_task_codification => l_task_codif);
                                FETCH c_count_guid_task_link
                                    INTO l_count;
                                CLOSE c_count_guid_task_link;
                            
                                IF l_count = 0
                                THEN
                                    g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    l_id_guideline_array.extend;
                                    l_id_task_link_array.extend;
                                    l_task_type_array.extend;
                                    l_task_notes_array.extend;
                                    l_id_task_attach_array.extend;
                                    l_task_codif_array.extend;
                                
                                    l_id_guideline_array(l_index) := l_id_guideline;
                                    l_id_task_link_array(l_index) := l_emb_id;
                                    l_task_type_array(l_index) := l_task_type;
                                    l_task_notes_array(l_index) := l_task_notes;
                                    l_id_task_attach_array(l_index) := l_id_task_attach;
                                    l_task_codif_array(l_index) := l_task_codif;
                                
                                    l_index := l_index + 1;
                                END IF;
                            END IF;
                            --> Speciality
                        ELSIF l_task_type = l_var_spec
                        THEN
                            g_error := 'GET_SPECIALITY_ID';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            SELECT nvl((SELECT sp.id_speciality
                                         FROM speciality sp
                                        WHERE sp.id_content = (SELECT sp1.id_content
                                                                 FROM alert_default.speciality sp1
                                                                WHERE sp1.id_speciality = l_id_task_link
                                                                  AND sp1.flg_available = g_yes)
                                          AND sp.id_content IS NOT NULL
                                          AND sp.flg_available = g_yes
                                          AND rownum = 1),
                                       0)
                              INTO l_id_spec
                              FROM dual;
                        
                            IF l_id_spec != 0
                            THEN
                                g_error := '12 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' || l_id_spec;
                                OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                            c_id_task_link      => l_id_spec,
                                                            c_task_type         => l_task_type,
                                                            c_id_task_attach    => l_id_task_attach,
                                                            c_task_codification => l_task_codif);
                                FETCH c_count_guid_task_link
                                    INTO l_count;
                                CLOSE c_count_guid_task_link;
                            
                                IF l_count = 0
                                THEN
                                    g_error := 'NEW GUIDELINE_TASK_LINK ' || l_id_guideline;
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                
                                    l_id_guideline_array.extend;
                                    l_id_task_link_array.extend;
                                    l_task_type_array.extend;
                                    l_task_notes_array.extend;
                                    l_id_task_attach_array.extend;
                                    l_task_codif_array.extend;
                                
                                    l_id_guideline_array(l_index) := l_id_guideline;
                                    l_id_task_link_array(l_index) := l_id_spec;
                                    l_task_type_array(l_index) := l_task_type;
                                    l_task_notes_array(l_index) := l_task_notes;
                                    l_id_task_attach_array(l_index) := l_id_task_attach;
                                    l_task_codif_array(l_index) := l_task_codif;
                                
                                    l_index := l_index + 1;
                                END IF;
                            END IF;
                            --> PROCEDURES
                        ELSIF l_task_type = l_var_proc
                        THEN
                            g_error := 'OPEN C_INTERVENTION';
                            OPEN c_intervention(l_id_task_link, i_id_software, i_version(i), i_market(j));
                            LOOP
                                g_error := 'FETCH C_INTERVENTION';
                                FETCH c_intervention
                                    INTO l_id_intervention_def;
                                EXIT WHEN c_intervention%NOTFOUND;
                            
                                g_error := 'GET_INTERVENTION_ID';
                                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                SELECT nvl((SELECT i.id_intervention
                                             FROM intervention i
                                            WHERE i.id_content = l_id_intervention_def
                                              AND i.id_content IS NOT NULL
                                              AND i.flg_status = pk_alert_constant.g_active
                                              AND rownum = 1),
                                           0)
                                  INTO l_id_intervention
                                  FROM dual;
                            
                                IF l_id_intervention != 0
                                THEN
                                    IF l_task_codif IS NOT NULL
                                    THEN
                                        g_error := 'SELECT ID_INTERV_CODIFICATION';
                                        SELECT nvl((SELECT ic.id_interv_codification
                                                     FROM interv_codification ic
                                                    WHERE ic.id_intervention = l_id_intervention
                                                      AND ic.id_codification =
                                                          (SELECT t.id_codification
                                                             FROM codification t
                                                            WHERE t.id_content =
                                                                  (SELECT b.id_content
                                                                     FROM alert_default.codification b
                                                                     JOIN alert_default.interv_codification ic1
                                                                       ON ic1.id_codification = b.id_codification
                                                                      AND ic1.id_intervention =
                                                                          (SELECT i.id_intervention
                                                                             FROM alert_default.intervention i
                                                                            WHERE i.id_intervention = l_id_task_link
                                                                              AND i.flg_status =
                                                                                  pk_alert_constant.g_active)
                                                                      AND ic1.flg_available = g_yes)
                                                              AND t.flg_available = g_yes)
                                                      AND ic.flg_available = g_yes
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_interv_codif
                                          FROM dual;
                                    
                                        IF l_interv_codif != 0
                                        THEN
                                            g_error := '13 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                       l_id_intervention;
                                            OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                        c_id_task_link      => l_id_intervention,
                                                                        c_task_type         => l_task_type,
                                                                        c_id_task_attach    => l_id_task_attach,
                                                                        c_task_codification => l_interv_codif);
                                            FETCH c_count_guid_task_link
                                                INTO l_count;
                                            CLOSE c_count_guid_task_link;
                                        
                                            IF l_count = 0
                                            THEN
                                                l_id_guideline_array.extend;
                                                l_id_task_link_array.extend;
                                                l_task_type_array.extend;
                                                l_task_notes_array.extend;
                                                l_id_task_attach_array.extend;
                                                l_task_codif_array.extend;
                                            
                                                l_id_guideline_array(l_index) := l_id_guideline;
                                                l_id_task_link_array(l_index) := l_id_intervention;
                                                l_task_type_array(l_index) := l_task_type;
                                                l_task_notes_array(l_index) := l_task_notes;
                                                l_id_task_attach_array(l_index) := l_id_task_attach;
                                                l_task_codif_array(l_index) := l_interv_codif;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    ELSE
                                    
                                        g_error := '14 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                   l_id_intervention;
                                        OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                    c_id_task_link      => l_id_intervention,
                                                                    c_task_type         => l_task_type,
                                                                    c_id_task_attach    => l_id_task_attach,
                                                                    c_task_codification => l_task_codif);
                                        FETCH c_count_guid_task_link
                                            INTO l_count;
                                        CLOSE c_count_guid_task_link;
                                    
                                        IF l_count = 0
                                        THEN
                                            l_id_guideline_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_guideline_array(l_index) := l_id_guideline;
                                            l_id_task_link_array(l_index) := l_id_intervention;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_INTERVENTION CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_intervention;
                            --> Monitorizations
                        ELSIF l_task_type = l_var_monitorization
                        THEN
                            g_error := 'OPEN C_VITAL_SIGN';
                            OPEN c_vital_sign(l_id_task_link, i_id_software, i_version(i), i_market(j));
                            LOOP
                                g_error := 'FETCH C_VITAL_SIGN';
                                FETCH c_vital_sign
                                    INTO l_id_vital_sign;
                                EXIT WHEN c_vital_sign%NOTFOUND;
                            
                                IF l_id_vital_sign != 0
                                THEN
                                    g_error := 'CHECK VS_SOFT_INST FOR INSTITUTION';
                                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    SELECT COUNT(vsi.id_vs_soft_inst)
                                      INTO l_count_vsi
                                      FROM vs_soft_inst vsi
                                     WHERE vsi.id_vital_sign = l_id_vital_sign
                                       AND vsi.id_institution = i_id_institution
                                       AND vsi.id_software = i_id_software
                                       AND vsi.flg_view = 'V2';
                                
                                    IF l_count_vsi != 0
                                    THEN
                                    
                                        g_error := '15 OPEN C_COUNT_GUID_TASK_LINK ' || l_id_guideline || '/' ||
                                                   l_id_vital_sign;
                                        OPEN c_count_guid_task_link(c_id_guideline      => l_id_guideline,
                                                                    c_id_task_link      => l_id_vital_sign,
                                                                    c_task_type         => l_task_type,
                                                                    c_id_task_attach    => l_id_task_attach,
                                                                    c_task_codification => l_task_codif);
                                        FETCH c_count_guid_task_link
                                            INTO l_count;
                                        CLOSE c_count_guid_task_link;
                                    
                                        IF l_count = 0
                                        THEN
                                            l_id_guideline_array.extend;
                                            l_id_task_link_array.extend;
                                            l_task_type_array.extend;
                                            l_task_notes_array.extend;
                                            l_id_task_attach_array.extend;
                                            l_task_codif_array.extend;
                                        
                                            l_id_guideline_array(l_index) := l_id_guideline;
                                            l_id_task_link_array(l_index) := l_id_vital_sign;
                                            l_task_type_array(l_index) := l_task_type;
                                            l_task_notes_array(l_index) := l_task_notes;
                                            l_id_task_attach_array(l_index) := l_id_task_attach;
                                            l_task_codif_array(l_index) := l_task_codif;
                                        
                                            l_index := l_index + 1;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_VITAL_SIGN CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_vital_sign;
                        
                        END IF; --> fim de todas as tasks
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_GUIDELINE_TASK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guideline_task;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_GUIDELINE';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_array AS table_number));
    
        g_error := 'OPEN O_ID_TASK_LINK';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_task_link FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_task_link_array AS table_varchar));
    
        g_error := 'OPEN O_TASK_TYPE';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_task_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_task_type_array AS table_number));
    
        g_error := 'OPEN O_TASK_NOTES';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_task_notes FOR
            SELECT column_value
              FROM TABLE(CAST(l_task_notes_array AS table_varchar));
    
        g_error := 'OPEN O_ID_TASK_ATTACH';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_task_attach FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_task_attach_array AS table_number));
    
        g_error := 'OPEN O_TASK_CODIF';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_task_codif FOR
            SELECT column_value
              FROM TABLE(CAST(l_task_codif_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_guideline);
            pk_types.open_my_cursor(o_id_task_link);
            pk_types.open_my_cursor(o_task_type);
            pk_types.open_my_cursor(o_task_notes);
            pk_types.open_my_cursor(o_id_task_attach);
            pk_types.open_my_cursor(o_task_codif);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guideline_task_link;
    /*********************************************************************************************
    * Set Guideline Task link for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_guideline_task_link Cursor of Instituition Guideline_Taks_Link
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/18
    ********************************************************************************************/
    FUNCTION set_inst_guideline_task_link
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN table_number,
        i_version             IN table_varchar,
        i_id_institution      IN institution.id_institution%TYPE,
        i_software            IN table_number,
        o_guideline_task_link OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_guideline   pk_types.cursor_type;
        l_c_id_task_link   pk_types.cursor_type;
        l_c_task_type      pk_types.cursor_type;
        l_c_task_notes     pk_types.cursor_type;
        l_c_id_task_attach pk_types.cursor_type;
        l_c_task_codif     pk_types.cursor_type;
    
        l_data_id_guideline   table_number;
        l_data_id_task_link   table_varchar;
        l_data_task_type      table_number;
        l_data_task_notes     table_varchar;
        l_data_id_task_attach table_number;
        l_data_task_codif     table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_GUIDELINE_TASK_LINK ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_GUIDELINE_LINK';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_guideline_task_link(i_lang,
                                                i_market,
                                                i_version,
                                                i_id_institution,
                                                i_software(i),
                                                l_c_id_guideline,
                                                l_c_id_task_link,
                                                l_c_task_type,
                                                l_c_task_notes,
                                                l_c_id_task_attach,
                                                l_c_task_codif,
                                                o_error)
            THEN
                RAISE l_exception;
            ELSE
            
                g_error := 'o_guideline_task_link := l_c_id_guideline';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_guideline_task_link := l_c_id_guideline;
            
                LOOP
                
                    FETCH l_c_id_guideline BULK COLLECT
                        INTO l_data_id_guideline LIMIT g_array_size;
                
                    FETCH l_c_id_task_link BULK COLLECT
                        INTO l_data_id_task_link LIMIT g_array_size;
                
                    FETCH l_c_task_type BULK COLLECT
                        INTO l_data_task_type LIMIT g_array_size;
                
                    FETCH l_c_task_notes BULK COLLECT
                        INTO l_data_task_notes LIMIT g_array_size;
                
                    FETCH l_c_id_task_attach BULK COLLECT
                        INTO l_data_id_task_attach LIMIT g_array_size;
                
                    FETCH l_c_task_codif BULK COLLECT
                        INTO l_data_task_codif LIMIT g_array_size;
                
                    g_error := 'INSERT INTO GUIDELINE_TASK_LINK [' || l_data_id_guideline.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    FOR j IN 1 .. l_data_id_guideline.count
                    LOOP
                        g_error := 'INSERT INTO GUIDELINE_TASK_LINK (seq_guideline_task_link.NEXTVAL,' ||
                                   l_data_id_guideline(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        INSERT INTO guideline_task_link
                            (id_guideline_task_link,
                             id_guideline,
                             task_type,
                             task_notes,
                             id_task_attach,
                             task_codification,
                             id_task_link)
                        VALUES
                            (seq_guideline_task_link.nextval,
                             l_data_id_guideline(j),
                             l_data_task_type(j),
                             l_data_task_notes(j),
                             l_data_id_task_attach(j),
                             l_data_task_codif(j),
                             l_data_id_task_link(j));
                    END LOOP;
                    EXIT WHEN l_c_id_guideline%NOTFOUND;
                
                END LOOP;
                g_error := 'CLOSE l_c_id_guideline CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_guideline;
                g_error := 'CLOSE l_c_id_task_link CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_task_link;
                g_error := 'CLOSE l_c_task_type CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_task_type;
                g_error := 'CLOSE l_c_task_notes CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_task_notes;
                g_error := 'CLOSE l_c_id_task_attach CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_task_attach;
                g_error := 'CLOSE l_c_task_codif CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_task_codif;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guideline_task_link;
    /********************************************************************************************
    * Get Guideline Context Image set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_guideline                  Cursor of Guidelines
    * @param o_file_name                    Cursor of File Name
    * @param o_img_desc                     Cursor of Image Desc
    * @param o_dt_img                       Cursor of Date Image 
    * @param o_img                          Cursor of Image 
    * @param o_img_thumbnail                Cursor of Image Thumbanail 
    * @param o_flg_status                   Cursor of Flg_Status 
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/18
    ********************************************************************************************/
    FUNCTION get_inst_guideline_context_img
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_guideline   OUT pk_types.cursor_type,
        o_file_name      OUT pk_types.cursor_type,
        o_img_desc       OUT pk_types.cursor_type,
        o_dt_img         OUT pk_types.cursor_type,
        o_img            OUT pk_types.cursor_type,
        o_img_thumbnail  OUT pk_types.cursor_type,
        o_flg_status     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_guideline_def guideline_context_image.id_guideline%TYPE := NULL;
        l_id_guideline     guideline_context_image.id_guideline%TYPE := NULL;
        l_id_content_def   guideline.id_content%TYPE := NULL;
        l_file_name        guideline_context_image.file_name%TYPE := NULL;
        l_img_desc         guideline_context_image.img_desc%TYPE := NULL;
        l_dt_img           guideline_context_image.dt_img%TYPE := NULL;
        l_img              guideline_context_image.img%TYPE;
        l_img_thumbnail    guideline_context_image.img_thumbnail%TYPE;
        l_flg_status       guideline_context_image.flg_status%TYPE := NULL;
    
        l_id_guideline_array  table_number := table_number();
        l_file_name_array     table_varchar := table_varchar();
        l_img_desc_array      table_varchar := table_varchar();
        l_dt_img_array        table_date := table_date();
        l_img_array           table_blob := table_blob();
        l_img_thumbnail_array table_blob := table_blob();
        l_flg_status_array    table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_guideline_context_img
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT gci.id_guideline,
                   g.id_content,
                   gci.file_name,
                   gci.img_desc,
                   gci.dt_img,
                   gci.img,
                   gci.img_thumbnail,
                   gci.flg_status
              FROM alert_default.guideline_context_image gci
              JOIN alert_default.guideline g
                ON (g.id_guideline = gci.id_guideline)
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = gci.id_guideline AND gmv.id_market = c_market AND gmv.version = c_version);
    
    BEGIN
        g_func_name := 'GET_INST_GUIDELINE_CONTEXT_IMG ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_GUIDELINE_CONTEXT_IMG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guideline_context_img(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_guideline_context_img
                        INTO l_id_guideline_def,
                             l_id_content_def,
                             l_file_name,
                             l_img_desc,
                             l_dt_img,
                             l_img,
                             l_img_thumbnail,
                             l_flg_status;
                    EXIT WHEN c_guideline_context_img%NOTFOUND;
                
                    g_error := 'GET ALERT ID_GUIDELINE';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT g.id_guideline
                                 FROM guideline g
                                WHERE g.id_content = l_id_content_def
                                  AND g.id_content IS NOT NULL
                                  AND g.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_guideline
                      FROM dual;
                
                    g_error := 'COUNT GUIDELINE_CONTEXT_IMAGE';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT COUNT(gci.id_guideline_context_image)
                      INTO l_count
                      FROM guideline_context_image gci
                     WHERE gci.id_guideline = l_id_guideline
                       AND gci.file_name = l_file_name
                       AND gci.img_desc = l_img_desc
                       AND gci.dt_img = l_dt_img
                       AND dbms_lob.compare(gci.img, l_img) > 0
                       AND dbms_lob.compare(gci.img_thumbnail, l_img_thumbnail) > 0
                       AND gci.flg_status = l_flg_status;
                
                    IF l_id_guideline != 0
                       AND l_count = 0
                    THEN
                        l_id_guideline_array.extend;
                        l_file_name_array.extend;
                        l_img_desc_array.extend;
                        l_dt_img_array.extend;
                        l_img_array.extend;
                        l_img_thumbnail_array.extend;
                        l_flg_status_array.extend;
                    
                        l_id_guideline_array(l_index) := l_id_guideline;
                        l_file_name_array(l_index) := l_file_name;
                        l_img_desc_array(l_index) := l_img_desc;
                        l_dt_img_array(l_index) := l_dt_img;
                        l_img_array(l_index) := l_img;
                        l_img_thumbnail_array(l_index) := l_img_thumbnail;
                        l_flg_status_array(l_index) := l_flg_status;
                    
                        l_index := l_index + 1;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_GUIDELINE_CONTEXT_IMG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guideline_context_img;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_GUIDELINE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_array AS table_number));
    
        g_error := 'OPEN O_FILE_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_file_name FOR
            SELECT column_value
              FROM TABLE(CAST(l_file_name_array AS table_varchar));
    
        g_error := 'OPEN O_IMG_DESC CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_img_desc FOR
            SELECT column_value
              FROM TABLE(CAST(l_file_name_array AS table_varchar));
    
        g_error := 'OPEN O_DT_IMG CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_dt_img FOR
            SELECT column_value
              FROM TABLE(CAST(l_dt_img_array AS table_date));
    
        g_error := 'OPEN O_IMG CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_img FOR
            SELECT column_value
              FROM TABLE(l_img_array);
    
        g_error := 'OPEN O_IMG_THUMBNAIL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_img_thumbnail FOR
            SELECT column_value
              FROM TABLE(l_img_thumbnail_array);
    
        g_error := 'OPEN O_FLG_STATUS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_status_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_guideline);
            pk_types.open_my_cursor(o_file_name);
            pk_types.open_my_cursor(o_img_desc);
            pk_types.open_my_cursor(o_dt_img);
            pk_types.open_my_cursor(o_img);
            pk_types.open_my_cursor(o_img_thumbnail);
            pk_types.open_my_cursor(o_flg_status);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guideline_context_img;
    /*********************************************************************************************
    * Set Guideline Context Image for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_guideline_context_img    Cursor of Instituition Guideline_Context_Image
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/18
    ********************************************************************************************/
    FUNCTION set_inst_guideline_context_img
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_id_institution        IN institution.id_institution%TYPE,
        i_software              IN table_number,
        o_guideline_context_img OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_guideline  pk_types.cursor_type;
        l_c_file_name     pk_types.cursor_type;
        l_c_img_desc      pk_types.cursor_type;
        l_c_dt_img        pk_types.cursor_type;
        l_c_img           pk_types.cursor_type;
        l_c_img_thumbnail pk_types.cursor_type;
        l_c_flg_status    pk_types.cursor_type;
    
        l_data_id_guideline  table_number;
        l_data_file_name     table_varchar;
        l_data_img_desc      table_varchar;
        l_data_dt_img        table_date;
        l_data_img           table_blob;
        l_data_img_thumbnail table_blob;
        l_data_flg_status    table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_GUIDELINE_CONTEXT_IMG ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_GUIDELINE_CONTEXT_IMG';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_guideline_context_img(i_lang,
                                                  i_market,
                                                  i_version,
                                                  i_id_institution,
                                                  i_software(i),
                                                  l_c_id_guideline,
                                                  l_c_file_name,
                                                  l_c_img_desc,
                                                  l_c_dt_img,
                                                  l_c_img,
                                                  l_c_img_thumbnail,
                                                  l_c_flg_status,
                                                  o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_guideline_context_img := l_c_id_guideline';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                o_guideline_context_img := l_c_id_guideline;
            
                LOOP
                
                    FETCH l_c_id_guideline BULK COLLECT
                        INTO l_data_id_guideline LIMIT g_array_size;
                
                    FETCH l_c_file_name BULK COLLECT
                        INTO l_data_file_name LIMIT g_array_size;
                
                    FETCH l_c_img_desc BULK COLLECT
                        INTO l_data_img_desc LIMIT g_array_size;
                
                    FETCH l_c_dt_img BULK COLLECT
                        INTO l_data_dt_img LIMIT g_array_size;
                
                    FETCH l_c_img BULK COLLECT
                        INTO l_data_img LIMIT g_array_size;
                
                    FETCH l_c_img_thumbnail BULK COLLECT
                        INTO l_data_img_thumbnail LIMIT g_array_size;
                
                    FETCH l_c_flg_status BULK COLLECT
                        INTO l_data_flg_status LIMIT g_array_size;
                
                    g_error := 'INSERT INTO GUIDELINE_CONTEXT_IMAGE [' || l_data_id_guideline.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    FOR j IN 1 .. l_data_id_guideline.count
                    LOOP
                        g_error := 'INSERT INTO GUIDELINE_CONTEXT_IMAGE (seq_guideline_context_image.NEXTVAL,' ||
                                   l_data_id_guideline(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO guideline_context_image
                            (id_guideline_context_image,
                             id_guideline,
                             file_name,
                             img_desc,
                             dt_img,
                             img,
                             img_thumbnail,
                             flg_status)
                        VALUES
                            (seq_guideline_context_image.nextval,
                             l_data_id_guideline(j),
                             l_data_file_name(j),
                             l_data_img_desc(j),
                             l_data_dt_img(j),
                             l_data_img(j),
                             l_data_img_thumbnail(j),
                             l_data_flg_status(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_guideline%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_GUIDELINE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_guideline;
            
                g_error := 'CLOSE L_C_FILE_NAME CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_file_name;
            
                g_error := 'CLOSE L_C_IMG_DESC CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_img_desc;
            
                g_error := 'CLOSE L_C_DT_IMG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_dt_img;
            
                g_error := 'CLOSE L_C_IMG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_img;
            
                g_error := 'CLOSE L_C_IMG_THUMBNAIL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_img_thumbnail;
            
                g_error := 'CLOSE L_C_FLG_STATUS CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_flg_status;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guideline_context_img;
    /********************************************************************************************
    * Get Guideline Context Author set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_guideline                 Cursor of Guideline
    * @param o_first_name                   Cursor of First Name
    * @param o_last_name                    Cursor of Last Name
    * @param o_title                        Cursor of Title    
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/18
    ********************************************************************************************/
    FUNCTION get_inst_guideline_cntext_auth
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_guideline   OUT pk_types.cursor_type,
        o_first_name     OUT pk_types.cursor_type,
        o_last_name      OUT pk_types.cursor_type,
        o_title          OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_guideline_def guideline_context_author.id_guideline%TYPE := NULL;
        l_id_guideline     guideline_context_author.id_guideline%TYPE := NULL;
        l_id_content_def   guideline.id_content%TYPE := NULL;
        l_first_name       guideline_context_author.first_name%TYPE := NULL;
        l_last_name        guideline_context_author.last_name%TYPE := NULL;
        l_title            guideline_context_author.title%TYPE := NULL;
    
        l_id_guideline_array table_number := table_number();
        l_first_name_array   table_varchar := table_varchar();
        l_last_name_array    table_varchar := table_varchar();
        l_title_array        table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_guideline_context_auth
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT gca.id_guideline, g.id_content, gca.first_name, gca.last_name, gca.title
              FROM alert_default.guideline_context_author gca
              JOIN alert_default.guideline g
                ON (g.id_guideline = gca.id_guideline)
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = gca.id_guideline AND gmv.id_market = c_market AND gmv.version = c_version);
    
    BEGIN
        g_func_name := 'GET_INST_GUIDELINE_CNTEXT_AUTH ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_GUIDELINE_CONTEXT_AUTH CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guideline_context_auth(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_guideline_context_auth
                        INTO l_id_guideline_def, l_id_content_def, l_first_name, l_last_name, l_title;
                    EXIT WHEN c_guideline_context_auth%NOTFOUND;
                
                    g_error := 'GET ALERT ID_GUIDELINE';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT g.id_guideline
                                 FROM guideline g
                                WHERE g.id_content = l_id_content_def
                                  AND g.id_content IS NOT NULL
                                  AND g.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_guideline
                      FROM dual;
                
                    g_error := 'COUNT GUIDELINE_CONTEXT_AUTHOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT COUNT(gca.id_guideline_context_author)
                      INTO l_count
                      FROM guideline_context_author gca
                     WHERE gca.id_guideline = l_id_guideline
                       AND gca.first_name = l_first_name
                       AND gca.last_name = l_last_name
                       AND gca.title = l_title;
                
                    IF l_id_guideline != 0
                       AND l_count = 0
                    THEN
                    
                        l_id_guideline_array.extend;
                        l_first_name_array.extend;
                        l_last_name_array.extend;
                        l_title_array.extend;
                    
                        l_id_guideline_array(l_index) := l_id_guideline;
                        l_first_name_array(l_index) := l_first_name;
                        l_last_name_array(l_index) := l_last_name;
                        l_title_array(l_index) := l_title;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_GUIDELINE_CONTEXT_AUTH CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guideline_context_auth;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_GUIDELINE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_array AS table_number));
    
        g_error := 'OPEN O_FIRST_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_first_name FOR
            SELECT column_value
              FROM TABLE(CAST(l_first_name_array AS table_varchar));
    
        g_error := 'OPEN O_LAST_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_last_name FOR
            SELECT column_value
              FROM TABLE(CAST(l_last_name_array AS table_varchar));
    
        g_error := 'OPEN O_TITLE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_title FOR
            SELECT column_value
              FROM TABLE(CAST(l_title_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_guideline);
            pk_types.open_my_cursor(o_first_name);
            pk_types.open_my_cursor(o_last_name);
            pk_types.open_my_cursor(o_title);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guideline_cntext_auth;
    /*********************************************************************************************
    * Set Guideline Context Auth for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_guideline_context_auth   Cursor of Instituition Guideline_Context_Author
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/18
    ********************************************************************************************/
    FUNCTION set_inst_guideline_cntext_auth
    (
        i_lang                   IN language.id_language%TYPE,
        i_market                 IN table_number,
        i_version                IN table_varchar,
        i_id_institution         IN institution.id_institution%TYPE,
        i_software               IN table_number,
        o_guideline_context_auth OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_guideline pk_types.cursor_type;
        l_c_first_name   pk_types.cursor_type;
        l_c_last_name    pk_types.cursor_type;
        l_c_title        pk_types.cursor_type;
    
        l_data_id_guideline table_varchar;
        l_data_first_name   table_varchar;
        l_data_last_name    table_varchar;
        l_data_title        table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_GUIDELINE_CNTEXT_AUTH ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_GUIDELINE_CNTEXT_AUTH';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_guideline_cntext_auth(i_lang,
                                                  i_market,
                                                  i_version,
                                                  i_id_institution,
                                                  i_software(i),
                                                  l_c_id_guideline,
                                                  l_c_first_name,
                                                  l_c_last_name,
                                                  l_c_title,
                                                  o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_guideline_context_auth := l_c_id_guideline';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_guideline_context_auth := l_c_id_guideline;
            
                LOOP
                
                    FETCH l_c_id_guideline BULK COLLECT
                        INTO l_data_id_guideline LIMIT g_array_size;
                
                    FETCH l_c_first_name BULK COLLECT
                        INTO l_data_first_name LIMIT g_array_size;
                
                    FETCH l_c_last_name BULK COLLECT
                        INTO l_data_last_name LIMIT g_array_size;
                
                    FETCH l_c_title BULK COLLECT
                        INTO l_data_title LIMIT g_array_size;
                
                    g_error := 'INSERT INTO GUIDELINE_CONTEXT_AUTHOR [' || l_data_id_guideline.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    FOR j IN 1 .. l_data_id_guideline.count
                    LOOP
                        g_error := 'INSERT INTO GUIDELINE_CONTEXT_AUTHOR (seq_guideline_context_author.NEXTVAL,' ||
                                   l_data_id_guideline(j) || ');';
                    
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO guideline_context_author
                            (id_guideline_context_author, id_guideline, first_name, last_name, title)
                        VALUES
                            (seq_guideline_context_author.nextval,
                             l_data_id_guideline(j),
                             l_data_first_name(j),
                             l_data_last_name(j),
                             l_data_title(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_guideline%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_GUIDELINE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_guideline;
            
                g_error := 'CLOSE L_C_FIRST_NAME CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_first_name;
            
                g_error := 'CLOSE L_C_LAST_NAME CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_last_name;
            
                g_error := 'CLOSE L_C_TITLE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_title;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guideline_cntext_auth;
    /********************************************************************************************
    * Get Guideline Criteria set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_protocol                  Cursor of Guideline ID 
    * @param o_criteria_type                Cursor of Criteria Type
    * @param o_gender                       Cursor of Gender
    * @param o_min_age                      Cursor of min age
    * @param o_max_age                      Cursor of max age
    * @param o_min_weight                   Cursor of min weight
    * @param o_max_weight                   Cursor of max weight
    * @param o_id_weight_unit_mea           Cursor of weight unit measure ID
    * @param o_min_height                   Cursor of min height
    * @param o_max_height                   Cursor of max height
    * @param o_id_height_unit_mea           Cursor of height unit measure ID
    * @param o_imc_min                      Cursor of min IMC
    * @param o_imc_max                      Cursor of max IMC
    * @param o_id_blood_pres_unit_mea       Cursor of Blood pressure unit measure ID
    * @param o_min_blood_press_s            Cursor of min Blood pressure sistolic
    * @param o_max_blood_press_s            Cursor of max Blood pressure sistolic
    * @param o_min_blood_press_d            Cursor of min Blood pressure diastolic
    * @param o_max_blood_press_d            Cursor of max Blood pressure diastolic
    * @param o_error                        Error  
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/18
    ********************************************************************************************/
    FUNCTION get_inst_guideline_criteria
    (
        i_lang                   IN language.id_language%TYPE,
        i_market                 IN table_number,
        i_version                IN table_varchar,
        i_id_institution         IN institution.id_institution%TYPE,
        i_id_software            IN software.id_software%TYPE,
        o_id_guideline           OUT pk_types.cursor_type,
        o_criteria_type          OUT pk_types.cursor_type,
        o_gender                 OUT pk_types.cursor_type,
        o_min_age                OUT pk_types.cursor_type,
        o_max_age                OUT pk_types.cursor_type,
        o_min_weight             OUT pk_types.cursor_type,
        o_max_weight             OUT pk_types.cursor_type,
        o_id_weight_unit_mea     OUT pk_types.cursor_type,
        o_min_height             OUT pk_types.cursor_type,
        o_max_height             OUT pk_types.cursor_type,
        o_id_height_unit_mea     OUT pk_types.cursor_type,
        o_imc_min                OUT pk_types.cursor_type,
        o_imc_max                OUT pk_types.cursor_type,
        o_id_blood_pres_unit_mea OUT pk_types.cursor_type,
        o_min_blood_press_s      OUT pk_types.cursor_type,
        o_max_blood_press_s      OUT pk_types.cursor_type,
        o_min_blood_press_d      OUT pk_types.cursor_type,
        o_max_blood_press_d      OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_guideline           guideline_criteria.id_guideline%TYPE := NULL;
        l_id_guideline_def       guideline_criteria.id_guideline%TYPE := NULL;
        l_id_content_def         guideline.id_content%TYPE := NULL;
        l_criteria_type          guideline_criteria.criteria_type%TYPE := NULL;
        l_gender                 guideline_criteria.gender%TYPE := NULL;
        l_min_age                guideline_criteria.min_age%TYPE := NULL;
        l_max_age                guideline_criteria.max_age%TYPE := NULL;
        l_min_weight             guideline_criteria.min_weight%TYPE := NULL;
        l_max_weight             guideline_criteria.max_weight%TYPE := NULL;
        l_id_weight_unit_mea     guideline_criteria.id_weight_unit_measure%TYPE := NULL;
        l_min_height             guideline_criteria.min_height%TYPE := NULL;
        l_max_height             guideline_criteria.max_height%TYPE := NULL;
        l_id_height_unit_mea     guideline_criteria.id_height_unit_measure%TYPE := NULL;
        l_imc_min                guideline_criteria.imc_min%TYPE := NULL;
        l_imc_max                guideline_criteria.imc_max%TYPE := NULL;
        l_id_blood_pres_unit_mea guideline_criteria.id_blood_pressure_unit_measure%TYPE := NULL;
        l_min_blood_press_s      guideline_criteria.min_blood_pressure_s%TYPE := NULL;
        l_max_blood_press_s      guideline_criteria.max_blood_pressure_s%TYPE := NULL;
        l_min_blood_press_d      guideline_criteria.min_blood_pressure_d%TYPE := NULL;
        l_max_blood_press_d      guideline_criteria.max_blood_pressure_d%TYPE := NULL;
    
        l_id_guideline_array           table_number := table_number();
        l_criteria_type_array          table_varchar := table_varchar();
        l_gender_array                 table_varchar := table_varchar();
        l_min_age_array                table_number := table_number();
        l_max_age_array                table_number := table_number();
        l_min_weight_array             table_number := table_number();
        l_max_weight_array             table_number := table_number();
        l_id_weight_unit_mea_array     table_number := table_number();
        l_min_height_array             table_number := table_number();
        l_max_height_array             table_number := table_number();
        l_id_height_unit_mea_array     table_number := table_number();
        l_imc_min_array                table_number := table_number();
        l_imc_max_array                table_number := table_number();
        l_id_blood_pres_unit_mea_array table_number := table_number();
        l_min_blood_press_s_array      table_number := table_number();
        l_max_blood_press_s_array      table_number := table_number();
        l_min_blood_press_d_array      table_number := table_number();
        l_max_blood_press_d_array      table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_guideline_criteria
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT gc.id_guideline,
                            g.id_content,
                            gc.criteria_type,
                            gc.gender,
                            gc.min_age,
                            gc.max_age,
                            gc.min_weight,
                            gc.max_weight,
                            gc.id_weight_unit_measure,
                            gc.min_height,
                            gc.max_height,
                            gc.id_height_unit_measure,
                            gc.imc_min,
                            gc.imc_max,
                            gc.id_blood_pressure_unit_measure,
                            gc.min_blood_pressure_s,
                            gc.max_blood_pressure_s,
                            gc.min_blood_pressure_d,
                            gc.max_blood_pressure_d
              FROM alert_default.guideline_criteria gc
              JOIN alert_default.guideline g
                ON (g.id_guideline = gc.id_guideline)
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = gc.id_guideline AND gmv.id_market = c_market AND gmv.version = c_version);
    BEGIN
        g_func_name := 'GET_INST_GUIDELINE_CRITERIA ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_GUIDELINE_CRITERIA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guideline_criteria(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_guideline_criteria
                        INTO l_id_guideline_def,
                             l_id_content_def,
                             l_criteria_type,
                             l_gender,
                             l_min_age,
                             l_max_age,
                             l_min_weight,
                             l_max_weight,
                             l_id_weight_unit_mea,
                             l_min_height,
                             l_max_height,
                             l_id_height_unit_mea,
                             l_imc_min,
                             l_imc_max,
                             l_id_blood_pres_unit_mea,
                             l_min_blood_press_s,
                             l_max_blood_press_s,
                             l_min_blood_press_d,
                             l_max_blood_press_d;
                    EXIT WHEN c_guideline_criteria%NOTFOUND;
                
                    g_error := 'GET ALERT ID_GUIDELINE';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT g.id_guideline
                                 FROM guideline g
                                WHERE g.id_content = l_id_content_def
                                  AND g.id_content IS NOT NULL
                                  AND g.id_software = i_id_software
                                  AND g.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_guideline
                      FROM dual;
                
                    IF l_id_guideline != 0
                    THEN
                        g_error := 'COUNT EXISTING GUIDELINE_CRITERIAS';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        SELECT COUNT(gc.id_guideline_criteria)
                          INTO l_count
                          FROM guideline_criteria gc
                         WHERE gc.id_guideline = l_id_guideline
                           AND gc.criteria_type = l_criteria_type;
                    
                        IF l_count = 0
                        THEN
                            l_id_guideline_array.extend;
                            l_criteria_type_array.extend;
                            l_gender_array.extend;
                            l_min_age_array.extend;
                            l_max_age_array.extend;
                            l_min_weight_array.extend;
                            l_max_weight_array.extend;
                            l_id_weight_unit_mea_array.extend;
                            l_min_height_array.extend;
                            l_max_height_array.extend;
                            l_id_height_unit_mea_array.extend;
                            l_imc_min_array.extend;
                            l_imc_max_array.extend;
                            l_id_blood_pres_unit_mea_array.extend;
                            l_min_blood_press_s_array.extend;
                            l_max_blood_press_s_array.extend;
                            l_min_blood_press_d_array.extend;
                            l_max_blood_press_d_array.extend;
                        
                            l_id_guideline_array(l_index) := l_id_guideline;
                            l_criteria_type_array(l_index) := l_criteria_type;
                            l_gender_array(l_index) := l_gender;
                            l_min_age_array(l_index) := l_min_age;
                            l_max_age_array(l_index) := l_max_age;
                            l_min_weight_array(l_index) := l_min_weight;
                            l_max_weight_array(l_index) := l_max_weight;
                            l_id_weight_unit_mea_array(l_index) := l_id_weight_unit_mea;
                            l_min_height_array(l_index) := l_min_height;
                            l_max_height_array(l_index) := l_max_height;
                            l_id_height_unit_mea_array(l_index) := l_id_height_unit_mea;
                            l_imc_min_array(l_index) := l_imc_min;
                            l_imc_max_array(l_index) := l_imc_max;
                            l_id_blood_pres_unit_mea_array(l_index) := l_id_blood_pres_unit_mea;
                            l_min_blood_press_s_array(l_index) := l_min_blood_press_s;
                            l_max_blood_press_s_array(l_index) := l_max_blood_press_s;
                            l_min_blood_press_d_array(l_index) := l_min_blood_press_d;
                            l_max_blood_press_d_array(l_index) := l_max_blood_press_d;
                        
                            l_index := l_index + 1;
                        
                        END IF;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_GUIDELINE_CRITERIA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guideline_criteria;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_GUIDELINE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_array AS table_number));
    
        g_error := 'OPEN O_CRITERIA_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_criteria_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_criteria_type_array AS table_varchar));
    
        g_error := 'OPEN O_GENDER CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_gender FOR
            SELECT column_value
              FROM TABLE(CAST(l_gender_array AS table_varchar));
    
        g_error := 'OPEN O_MIN_AGE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_age FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_age_array AS table_number));
    
        g_error := 'OPEN O_MAX_AGE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_age FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_age_array AS table_number));
    
        g_error := 'OPEN O_MIN_WEIGHT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_weight FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_weight_array AS table_number));
    
        g_error := 'OPEN O_MAX_WEIGHT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_weight FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_weight_array AS table_number));
    
        g_error := 'OPEN O_ID_WEIGHT_UNIT_MEA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_weight_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_weight_unit_mea_array AS table_number));
    
        g_error := 'OPEN O_MIN_HEIGHT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_height FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_height_array AS table_number));
    
        g_error := 'OPEN O_MAX_HEIGHT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_height FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_height_array AS table_number));
    
        g_error := 'OPEN O_ID_HEIGHT_UNIT_MEA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_height_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_height_unit_mea_array AS table_number));
    
        g_error := 'OPEN O_IMC_MIN CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_imc_min FOR
            SELECT column_value
              FROM TABLE(CAST(l_imc_min_array AS table_number));
    
        g_error := 'OPEN O_IMC_MAX CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_imc_max FOR
            SELECT column_value
              FROM TABLE(CAST(l_imc_max_array AS table_number));
    
        g_error := 'OPEN O_ID_BLOOD_PRES_UNIT_MEA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_blood_pres_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_blood_pres_unit_mea_array AS table_number));
    
        g_error := 'OPEN O_MIN_BLOOD_PRESS_S CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_blood_press_s FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_blood_press_s_array AS table_number));
    
        g_error := 'OPEN O_MAX_BLOOD_PRESS_S CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_blood_press_s FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_blood_press_s_array AS table_number));
    
        g_error := 'OPEN O_MIN_BLOOD_PRESS_D CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_min_blood_press_d FOR
            SELECT column_value
              FROM TABLE(CAST(l_min_blood_press_d_array AS table_number));
    
        g_error := 'OPEN O_MAX_BLOOD_PRESS_D CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_max_blood_press_d FOR
            SELECT column_value
              FROM TABLE(CAST(l_max_blood_press_d_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_guideline);
            pk_types.open_my_cursor(o_criteria_type);
            pk_types.open_my_cursor(o_gender);
            pk_types.open_my_cursor(o_min_age);
            pk_types.open_my_cursor(o_max_age);
            pk_types.open_my_cursor(o_min_weight);
            pk_types.open_my_cursor(o_max_weight);
            pk_types.open_my_cursor(o_id_weight_unit_mea);
            pk_types.open_my_cursor(o_min_height);
            pk_types.open_my_cursor(o_max_height);
            pk_types.open_my_cursor(o_id_height_unit_mea);
            pk_types.open_my_cursor(o_imc_min);
            pk_types.open_my_cursor(o_imc_max);
            pk_types.open_my_cursor(o_id_blood_pres_unit_mea);
            pk_types.open_my_cursor(o_min_blood_press_s);
            pk_types.open_my_cursor(o_max_blood_press_s);
            pk_types.open_my_cursor(o_min_blood_press_d);
            pk_types.open_my_cursor(o_max_blood_press_d);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guideline_criteria;
    /*********************************************************************************************
    * Set Guideline Criteria for a specific institution
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param o_guideline_criteria  Cursor of Instituition Guideline_Criteria
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/18
    ********************************************************************************************/
    FUNCTION set_inst_guideline_criteria
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_software           IN table_number,
        o_guideline_criteria OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_guideline           pk_types.cursor_type;
        l_c_criteria_type          pk_types.cursor_type;
        l_c_gender                 pk_types.cursor_type;
        l_c_min_age                pk_types.cursor_type;
        l_c_max_age                pk_types.cursor_type;
        l_c_min_weight             pk_types.cursor_type;
        l_c_max_weight             pk_types.cursor_type;
        l_c_id_weight_unit_mea     pk_types.cursor_type;
        l_c_min_height             pk_types.cursor_type;
        l_c_max_height             pk_types.cursor_type;
        l_c_id_height_unit_mea     pk_types.cursor_type;
        l_c_imc_min                pk_types.cursor_type;
        l_c_imc_max                pk_types.cursor_type;
        l_c_id_blood_pres_unit_mea pk_types.cursor_type;
        l_c_min_blood_press_s      pk_types.cursor_type;
        l_c_max_blood_press_s      pk_types.cursor_type;
        l_c_min_blood_press_d      pk_types.cursor_type;
        l_c_max_blood_press_d      pk_types.cursor_type;
    
        l_data_id_guideline           table_number;
        l_data_criteria_type          table_varchar;
        l_data_gender                 table_varchar;
        l_data_min_age                table_number;
        l_data_max_age                table_number;
        l_data_min_weight             table_number;
        l_data_max_weight             table_number;
        l_data_id_weight_unit_mea     table_number;
        l_data_min_height             table_number;
        l_data_max_height             table_number;
        l_data_id_height_unit_mea     table_number;
        l_data_imc_min                table_number;
        l_data_imc_max                table_number;
        l_data_id_blood_pres_unit_mea table_number;
        l_data_min_blood_press_s      table_number;
        l_data_max_blood_press_s      table_number;
        l_data_min_blood_press_d      table_number;
        l_data_max_blood_press_d      table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        g_func_name := 'SET_INST_GUIDELINE_CRITERIA ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_GUIDELINE_CRITERIA';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_guideline_criteria(i_lang,
                                               i_market,
                                               i_version,
                                               i_id_institution,
                                               i_software(i),
                                               l_c_id_guideline,
                                               l_c_criteria_type,
                                               l_c_gender,
                                               l_c_min_age,
                                               l_c_max_age,
                                               l_c_min_weight,
                                               l_c_max_weight,
                                               l_c_id_weight_unit_mea,
                                               l_c_min_height,
                                               l_c_max_height,
                                               l_c_id_height_unit_mea,
                                               l_c_imc_min,
                                               l_c_imc_max,
                                               l_c_id_blood_pres_unit_mea,
                                               l_c_min_blood_press_s,
                                               l_c_max_blood_press_s,
                                               l_c_min_blood_press_d,
                                               l_c_max_blood_press_d,
                                               o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_guideline_criteria := l_c_id_guideline';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                o_guideline_criteria := l_c_id_guideline;
            
                LOOP
                
                    FETCH l_c_id_guideline BULK COLLECT
                        INTO l_data_id_guideline LIMIT g_array_size;
                    FETCH l_c_criteria_type BULK COLLECT
                        INTO l_data_criteria_type LIMIT g_array_size;
                    FETCH l_c_gender BULK COLLECT
                        INTO l_data_gender LIMIT g_array_size;
                    FETCH l_c_min_age BULK COLLECT
                        INTO l_data_min_age LIMIT g_array_size;
                    FETCH l_c_max_age BULK COLLECT
                        INTO l_data_max_age LIMIT g_array_size;
                    FETCH l_c_min_weight BULK COLLECT
                        INTO l_data_min_weight LIMIT g_array_size;
                    FETCH l_c_max_weight BULK COLLECT
                        INTO l_data_max_weight LIMIT g_array_size;
                    FETCH l_c_id_weight_unit_mea BULK COLLECT
                        INTO l_data_id_weight_unit_mea LIMIT g_array_size;
                    FETCH l_c_min_height BULK COLLECT
                        INTO l_data_min_height LIMIT g_array_size;
                    FETCH l_c_max_height BULK COLLECT
                        INTO l_data_max_height LIMIT g_array_size;
                    FETCH l_c_id_height_unit_mea BULK COLLECT
                        INTO l_data_id_height_unit_mea LIMIT g_array_size;
                    FETCH l_c_imc_min BULK COLLECT
                        INTO l_data_imc_min LIMIT g_array_size;
                    FETCH l_c_imc_max BULK COLLECT
                        INTO l_data_imc_max LIMIT g_array_size;
                    FETCH l_c_id_blood_pres_unit_mea BULK COLLECT
                        INTO l_data_id_blood_pres_unit_mea LIMIT g_array_size;
                    FETCH l_c_min_blood_press_s BULK COLLECT
                        INTO l_data_min_blood_press_s LIMIT g_array_size;
                    FETCH l_c_max_blood_press_s BULK COLLECT
                        INTO l_data_max_blood_press_s LIMIT g_array_size;
                    FETCH l_c_min_blood_press_d BULK COLLECT
                        INTO l_data_min_blood_press_d LIMIT g_array_size;
                    FETCH l_c_max_blood_press_d BULK COLLECT
                        INTO l_data_max_blood_press_d LIMIT g_array_size;
                
                    g_error := 'INSERT INTO GUIDELINE_CRITERIA [' || l_data_id_guideline.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                
                    FOR j IN 1 .. l_data_id_guideline.count
                    LOOP
                        g_error := 'INSERT INTO GUIDELINE_CRITERIA (seq_guideline_criteria.NEXTVAL,' ||
                                   l_data_id_guideline(j) || ');';
                    
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        INSERT INTO guideline_criteria
                            (id_guideline_criteria,
                             id_guideline,
                             criteria_type,
                             gender,
                             min_age,
                             max_age,
                             min_weight,
                             max_weight,
                             id_weight_unit_measure,
                             min_height,
                             max_height,
                             id_height_unit_measure,
                             imc_min,
                             imc_max,
                             id_blood_pressure_unit_measure,
                             min_blood_pressure_s,
                             max_blood_pressure_s,
                             min_blood_pressure_d,
                             max_blood_pressure_d)
                        VALUES
                            (seq_guideline_criteria.nextval,
                             l_data_id_guideline(j),
                             l_data_criteria_type(j),
                             l_data_gender(j),
                             l_data_min_age(j),
                             l_data_max_age(j),
                             l_data_min_weight(j),
                             l_data_max_weight(j),
                             l_data_id_weight_unit_mea(j),
                             l_data_min_height(j),
                             l_data_max_height(j),
                             l_data_id_height_unit_mea(j),
                             l_data_imc_min(j),
                             l_data_imc_max(j),
                             l_data_id_blood_pres_unit_mea(j),
                             l_data_min_blood_press_s(j),
                             l_data_max_blood_press_s(j),
                             l_data_min_blood_press_d(j),
                             l_data_max_blood_press_d(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_guideline%NOTFOUND;
                END LOOP;
            
                g_error := 'OPEN L_C_ID_GUIDELINE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_guideline;
            
                g_error := 'OPEN L_C_CRITERIA_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_criteria_type;
            
                g_error := 'OPEN L_C_GENDER CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_gender;
            
                g_error := 'OPEN L_C_MIN_AGE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_age;
            
                g_error := 'CLOSE L_C_MAX_AGE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_age;
            
                g_error := 'OPEN L_C_MIN_WEIGHT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_weight;
            
                g_error := 'OPEN L_C_MAX_WEIGHT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_weight;
            
                g_error := 'OPEN L_C_ID_WEIGHT_UNIT_MEA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_weight_unit_mea;
            
                g_error := 'OPEN L_C_MIN_HEIGHT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_height;
            
                g_error := 'OPEN L_C_MAX_HEIGHT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_height;
            
                g_error := 'OPEN L_C_ID_HEIGHT_UNIT_MEA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_height_unit_mea;
            
                g_error := 'OPEN L_C_IMC_MIN CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_imc_min;
            
                g_error := 'OPEN L_C_IMC_MAX CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_imc_max;
            
                g_error := 'OPEN L_C_ID_BLOOD_PRES_UNIT_MEA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_blood_pres_unit_mea;
            
                g_error := 'OPEN L_C_MIN_BLOOD_PRESS_S CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_blood_press_s;
            
                g_error := 'OPEN L_C_MAX_BLOOD_PRESS_S CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_blood_press_s;
            
                g_error := 'OPEN L_C_MIN_BLOOD_PRESS_D CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_min_blood_press_d;
            
                g_error := 'OPEN L_C_MAX_BLOOD_PRESS_D CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_max_blood_press_d;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guideline_criteria;
    /********************************************************************************************
    * Get Guideline Criteria Links set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_guideline_criteria        Cursor of Guideline Criteria
    * @param o_id_link_other_criteria       Cursor of Link Other Criteria ID
    * @param o_id_link_other_criteria_type  Cursor of Link Other Criteria Type ID 
    * @param o_error                        Error  
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/18
    ********************************************************************************************/
    FUNCTION get_inst_guideline_crit_link
    (
        i_lang                    IN language.id_language%TYPE,
        i_market                  IN table_number,
        i_version                 IN table_varchar,
        i_id_institution          IN institution.id_institution%TYPE,
        i_id_software             IN software.id_software%TYPE,
        o_id_guideline_criteria   OUT pk_types.cursor_type,
        o_id_link_other_criteria  OUT pk_types.cursor_type,
        o_id_link_other_crit_type OUT pk_types.cursor_type,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_guideline_criteria_def guideline_criteria_link.id_guideline_criteria%TYPE;
        l_id_link_other_criteria    guideline_criteria_link.id_link_other_criteria%TYPE;
        l_id_link_other_crit_type   guideline_criteria_link.id_link_other_criteria_type%TYPE;
        l_id_guideline              guideline.id_guideline%TYPE;
        l_guideline_content         guideline.id_content%TYPE;
        l_id_guideline_criteria     guideline_criteria.id_guideline_criteria%TYPE;
    
        l_criteria_type_def guideline_criteria.criteria_type%TYPE;
        l_criteria_type     guideline_criteria.criteria_type%TYPE;
    
        l_id_guideline_criteria_array  table_number := table_number();
        l_id_link_other_criteria_array table_number := table_number();
        l_id_link_other_cri_type_array table_number := table_number();
    
        l_index NUMBER := 1;
    
        l_id_analysis    analysis.id_analysis%TYPE := NULL;
        l_count_analysis NUMBER := 0;
    
        l_id_diagnosis    diagnosis.id_diagnosis%TYPE := NULL;
        l_count_diagnosis NUMBER := 0;
    
        l_id_img_exams    exam.id_exam%TYPE := NULL;
        l_count_img_exams NUMBER := 0;
    
        l_id_other_exams    exam.id_exam%TYPE := NULL;
        l_count_other_exams NUMBER := 0;
    
        l_id_icnp_diag    icnp_composition.id_composition%TYPE := NULL;
        l_count_icnp_diag NUMBER := 0;
    
        l_id_allergy    allergy.id_allergy%TYPE := NULL;
        l_count_allergy NUMBER := 0;
    
        CURSOR c_guideline_criteria_link
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT gcl.id_guideline_criteria,
                            gcl.id_link_other_criteria,
                            gcl.id_link_other_criteria_type,
                            g.id_content,
                            gc.criteria_type
              FROM alert_default.guideline_criteria_link gcl
              JOIN alert_default.guideline_criteria gc
                ON (gc.id_guideline_criteria = gcl.id_guideline_criteria)
              JOIN guideline_criteria_type gct
                ON (gct.id_guideline_criteria_type = gcl.id_link_other_criteria_type)
              JOIN alert_default.guideline g
                ON (g.id_guideline = gc.id_guideline)
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = gc.id_guideline AND gmv.id_market = c_market AND gmv.version = c_version);
    
        CURSOR c_guideline_criteria(c_id_guideline IN guideline.id_guideline%TYPE) IS
            SELECT DISTINCT gc.id_guideline_criteria, gc.criteria_type
              FROM guideline_criteria gc
              JOIN guideline g1
                ON (g1.id_guideline = gc.id_guideline)
               AND g1.id_guideline = c_id_guideline
              JOIN alert_default.guideline g2
                ON (g2.id_content = g1.id_content)
              JOIN alert_default.guideline_criteria gc2
                ON (gc2.id_guideline = g2.id_guideline AND gc2.criteria_type = gc.criteria_type);
    
    BEGIN
        g_func_name := 'GET_INST_GUIDELINE_CRIT_LINK ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_GUIDELINE_CRITERIA_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guideline_criteria_link(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_guideline_criteria_link
                        INTO l_id_guideline_criteria_def,
                             l_id_link_other_criteria,
                             l_id_link_other_crit_type,
                             l_guideline_content,
                             l_criteria_type_def;
                    EXIT WHEN c_guideline_criteria_link%NOTFOUND;
                
                    IF l_guideline_content IS NOT NULL
                    THEN
                        g_error := 'GET ALERT GUIDELINE ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        SELECT nvl((SELECT g.id_guideline
                                     FROM guideline g
                                    WHERE g.id_content = l_guideline_content
                                      AND g.id_content IS NOT NULL
                                      AND g.id_software = i_id_software
                                      AND g.id_institution = i_id_institution
                                      AND rownum = 1),
                                   0)
                          INTO l_id_guideline
                          FROM dual;
                    
                        IF l_id_guideline != 0
                        THEN
                            g_error := 'OPEN C_GUIDELINE_CRITERIA CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            OPEN c_guideline_criteria(l_id_guideline);
                            LOOP
                                FETCH c_guideline_criteria
                                    INTO l_id_guideline_criteria, l_criteria_type;
                                EXIT WHEN c_guideline_criteria%NOTFOUND;
                            
                                IF l_id_guideline_criteria IS NOT NULL
                                   AND l_criteria_type_def = l_criteria_type
                                THEN
                                    --> Allergy
                                    IF l_id_link_other_crit_type = 1
                                    THEN
                                        SELECT nvl((SELECT a.id_allergy
                                                     FROM allergy a
                                                     JOIN allergy_inst_soft ais
                                                       ON (ais.id_allergy = a.id_allergy AND
                                                          ais.id_institution = i_id_institution)
                                                   --No valida por sw                 
                                                    WHERE a.id_allergy = l_id_link_other_criteria
                                                      AND a.flg_available = g_flg_available
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_allergy
                                          FROM dual;
                                    
                                        IF l_id_allergy != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by ALLERGY';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(gcl.id_guideline_criteria_link)
                                              INTO l_count_allergy
                                              FROM guideline_criteria_link gcl
                                             WHERE gcl.id_guideline_criteria = l_id_guideline_criteria
                                               AND gcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND gcl.id_link_other_criteria = l_id_allergy;
                                        
                                            IF l_count_allergy = 0
                                            THEN
                                                l_id_guideline_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_guideline_criteria_array(l_index) := l_id_guideline_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_allergy;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        
                                        END IF;
                                    END IF;
                                    --> Analysis
                                    IF l_id_link_other_crit_type = 2
                                    THEN
                                        g_error := 'GET ALERT ID_ANALYSIS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        SELECT nvl((SELECT a.id_analysis
                                                     FROM analysis a
                                                     JOIN analysis_instit_soft ais
                                                       ON (ais.id_analysis = a.id_analysis AND
                                                          ais.id_institution = i_id_institution AND
                                                          ais.flg_available = g_flg_available)
                                                   -->No valida por sw
                                                     JOIN analysis_param ap
                                                       ON (ap.id_analysis = a.id_analysis AND
                                                          ap.flg_available = g_flg_available)
                                                   -->No valida por sw                  
                                                    WHERE a.id_content =
                                                          (SELECT a2.id_content
                                                             FROM alert_default.analysis a2
                                                            WHERE a2.id_analysis = l_id_link_other_criteria
                                                              AND a2.flg_available = g_flg_available)
                                                      AND a.id_content IS NOT NULL
                                                      AND a.flg_available = g_flg_available
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_analysis
                                          FROM dual;
                                    
                                        IF l_id_analysis != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by ANALYSIS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(gcl.id_guideline_criteria_link)
                                              INTO l_count_analysis
                                              FROM guideline_criteria_link gcl
                                             WHERE gcl.id_guideline_criteria = l_id_guideline_criteria
                                               AND gcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND gcl.id_link_other_criteria = l_id_analysis;
                                        
                                            IF l_count_analysis = 0
                                            THEN
                                                l_id_guideline_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_guideline_criteria_array(l_index) := l_id_guideline_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_analysis;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                    --> Diagnosis
                                    IF l_id_link_other_crit_type = 3
                                    THEN
                                        SELECT nvl((SELECT d.id_diagnosis
                                                     FROM diagnosis d
                                                     JOIN diagnosis_dep_clin_serv ddcs
                                                       ON (ddcs.id_diagnosis = d.id_diagnosis AND
                                                          ddcs.id_institution = i_id_institution AND
                                                          ddcs.flg_type = pk_diagnosis.g_diag_pesq)
                                                   --No valida por sw                 
                                                    WHERE d.id_diagnosis = l_id_link_other_criteria
                                                      AND d.flg_available = g_flg_available
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_diagnosis
                                          FROM dual;
                                    
                                        IF l_id_diagnosis != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by DIAGNOSIS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        
                                            SELECT COUNT(gcl.id_guideline_criteria_link)
                                              INTO l_count_diagnosis
                                              FROM guideline_criteria_link gcl
                                             WHERE gcl.id_guideline_criteria = l_id_guideline_criteria
                                               AND gcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND gcl.id_link_other_criteria = l_id_diagnosis;
                                        
                                            IF l_count_diagnosis = 0
                                            THEN
                                                l_id_guideline_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_guideline_criteria_array(l_index) := l_id_guideline_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_diagnosis;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        
                                        END IF;
                                    END IF;
                                    --> Image Exams
                                    IF l_id_link_other_crit_type = 4
                                    THEN
                                        g_error := 'GET ALERT ID_IMG_EXAMS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        SELECT nvl((SELECT e.id_exam
                                                     FROM exam e
                                                     JOIN exam_dep_clin_serv edcs
                                                       ON (edcs.id_exam = e.id_exam AND
                                                          edcs.id_institution = i_id_institution AND
                                                          edcs.flg_type = pk_exam_constant.g_exam_can_req)
                                                   --No valida por sw
                                                    WHERE e.id_content =
                                                          (SELECT e2.id_content
                                                             FROM alert_default.exam e2
                                                            WHERE e2.id_exam = l_id_link_other_criteria
                                                              AND e2.flg_available = g_flg_available)
                                                      AND e.id_content IS NOT NULL
                                                      AND e.flg_available = g_flg_available
                                                      AND e.flg_type = pk_exam_constant.g_type_img
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_img_exams
                                          FROM dual;
                                    
                                        IF l_id_img_exams != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by IMG_EXAMS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        
                                            SELECT COUNT(gcl.id_guideline_criteria_link)
                                              INTO l_count_img_exams
                                              FROM guideline_criteria_link gcl
                                             WHERE gcl.id_guideline_criteria = l_id_guideline_criteria
                                               AND gcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND gcl.id_link_other_criteria = l_id_img_exams;
                                        
                                            IF l_count_img_exams = 0
                                            THEN
                                                l_id_guideline_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_guideline_criteria_array(l_index) := l_id_guideline_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_img_exams;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                    --> Other Exams
                                    IF l_id_link_other_crit_type = 6
                                    THEN
                                        g_error := 'GET ALERT ID_OTHER_EXAMS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        SELECT nvl((SELECT e.id_exam
                                                     FROM exam e
                                                     JOIN exam_dep_clin_serv edcs
                                                       ON (edcs.id_exam = e.id_exam AND
                                                          edcs.id_institution = i_id_institution AND
                                                          edcs.flg_type = pk_exam_constant.g_exam_can_req)
                                                   --No valida por sw
                                                    WHERE e.id_content =
                                                          (SELECT e2.id_content
                                                             FROM alert_default.exam e2
                                                            WHERE e2.id_exam = l_id_link_other_criteria
                                                              AND e2.flg_available = g_flg_available)
                                                      AND e.id_content IS NOT NULL
                                                      AND e.flg_available = g_flg_available
                                                      AND e.flg_type = pk_exam_constant.g_type_exm
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_other_exams
                                          FROM dual;
                                    
                                        IF l_id_other_exams != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by OTHER_EXAMS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                            SELECT COUNT(gcl.id_guideline_criteria_link)
                                              INTO l_count_other_exams
                                              FROM guideline_criteria_link gcl
                                             WHERE gcl.id_guideline_criteria = l_id_guideline_criteria
                                               AND gcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND gcl.id_link_other_criteria = l_id_other_exams;
                                        
                                            IF l_count_other_exams = 0
                                            THEN
                                                l_id_guideline_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_guideline_criteria_array(l_index) := l_id_guideline_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_other_exams;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                    --> ICNP Diagnosis
                                    IF l_id_link_other_crit_type = 7
                                    THEN
                                        g_error := 'GET ALERT ID_ICNP_DIAGNOSIS';
                                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                    
                                        SELECT nvl((SELECT DISTINCT ic.id_composition
                                                     FROM icnp_composition ic
                                                     JOIN icnp_predefined_action ipa
                                                       ON (ipa.id_composition_parent = ic.id_composition AND
                                                          ipa.id_institution = i_id_institution AND
                                                          ipa.flg_available = g_flg_available)
                                                    WHERE ic.id_content =
                                                         --No valida por sw
                                                          (SELECT ic2.id_content
                                                             FROM alert_default.icnp_composition ic2
                                                             JOIN alert_default.icnp_predefined_action ipa2
                                                               ON (ipa2.id_composition_parent = ic2.id_composition AND
                                                                  ipa2.flg_available = g_flg_available AND
                                                                  ipa2.version = i_version(i) AND
                                                                  ipa2.id_market = i_market(j))
                                                            WHERE ic2.id_composition = l_id_link_other_criteria
                                                              AND ic2.flg_available = g_flg_available
                                                              AND ic2.id_software = i_id_software)
                                                      AND ic.id_content IS NOT NULL
                                                      AND ic.flg_available = g_flg_available
                                                      AND ic.flg_type = 'D'
                                                      AND ic.id_software = i_id_software
                                                      AND ic.id_institution = i_id_institution
                                                      AND rownum = 1),
                                                   0)
                                          INTO l_id_icnp_diag
                                          FROM dual;
                                    
                                        IF l_id_icnp_diag != 0
                                        THEN
                                            g_error := 'COUNT CRITERIA_LINK by ICNP_DIAGNOSIS';
                                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                                        
                                            SELECT COUNT(gcl.id_guideline_criteria_link)
                                              INTO l_count_icnp_diag
                                              FROM guideline_criteria_link gcl
                                             WHERE gcl.id_guideline_criteria = l_id_guideline_criteria
                                               AND gcl.id_link_other_criteria_type = l_id_link_other_crit_type
                                               AND gcl.id_link_other_criteria = l_id_icnp_diag;
                                        
                                            IF l_count_icnp_diag = 0
                                            THEN
                                                l_id_guideline_criteria_array.extend;
                                                l_id_link_other_criteria_array.extend;
                                                l_id_link_other_cri_type_array.extend;
                                            
                                                l_id_guideline_criteria_array(l_index) := l_id_guideline_criteria;
                                                l_id_link_other_criteria_array(l_index) := l_id_icnp_diag;
                                                l_id_link_other_cri_type_array(l_index) := l_id_link_other_crit_type;
                                            
                                                l_index := l_index + 1;
                                            END IF;
                                        END IF;
                                    END IF;
                                END IF;
                            END LOOP;
                            g_error := 'CLOSE C_GUIDELINE_CRITERIA CURSOR';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                            CLOSE c_guideline_criteria;
                        END IF;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_GUIDELINE_CRITERIA_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guideline_criteria_link;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_GUIDELINE_CRITERIA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline_criteria FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_criteria_array AS table_number));
    
        g_error := 'OPEN O_ID_LINK_OTHER_CRITERIA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_link_other_criteria FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_link_other_criteria_array AS table_number));
    
        g_error := 'OPEN O_ID_LINK_OTHER_CRIT_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_link_other_crit_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_link_other_cri_type_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_guideline_criteria);
            pk_types.open_my_cursor(o_id_link_other_criteria);
            pk_types.open_my_cursor(o_id_link_other_crit_type);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guideline_crit_link;
    /*********************************************************************************************
    * Set Guideline Criteria Link for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_guideline_criteria_link   Cursor of Instituition Guideline_Criteria_Link
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/18
    ********************************************************************************************/
    FUNCTION set_inst_guideline_crit_link
    (
        i_lang                    IN language.id_language%TYPE,
        i_market                  IN table_number,
        i_version                 IN table_varchar,
        i_id_institution          IN institution.id_institution%TYPE,
        i_software                IN table_number,
        o_guideline_criteria_link OUT pk_types.cursor_type,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_guideline_criteria pk_types.cursor_type;
        l_c_id_lk_oth_criteria    pk_types.cursor_type;
        l_c_id_lk_oth_cri_type    pk_types.cursor_type;
    
        l_data_id_guideline_criteria table_number;
        l_data_id_lk_oth_criteria    table_number;
        l_data_id_lk_oth_cri_type    table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        g_func_name := 'SET_INST_GUIDELINE_CRIT_LINK ';
        FOR i IN 1 .. i_software.count
        LOOP
            g_error := 'IF NOT GET_INST_GUIDELINE_CRITERIA_LINK';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_guideline_crit_link(i_lang,
                                                i_market,
                                                i_version,
                                                i_id_institution,
                                                i_software(i),
                                                l_c_id_guideline_criteria,
                                                l_c_id_lk_oth_criteria,
                                                l_c_id_lk_oth_cri_type,
                                                o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_guideline_criteria_link := l_c_idguideline_criteria';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_guideline_criteria_link := l_c_id_guideline_criteria;
            
                LOOP
                
                    FETCH l_c_id_guideline_criteria BULK COLLECT
                        INTO l_data_id_guideline_criteria LIMIT g_array_size;
                
                    FETCH l_c_id_lk_oth_criteria BULK COLLECT
                        INTO l_data_id_lk_oth_criteria LIMIT g_array_size;
                
                    FETCH l_c_id_lk_oth_cri_type BULK COLLECT
                        INTO l_data_id_lk_oth_cri_type LIMIT g_array_size;
                
                    g_error := 'INSERT INTO GUIDELINE_CRITERIA_LINK [' || l_data_id_guideline_criteria.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    FOR j IN 1 .. l_data_id_guideline_criteria.count
                    LOOP
                        g_error := 'INSERT INTO GUIDELINE_CRITERIA_LINK (seq_guideline_criteria_link.NEXTVAL,' ||
                                   l_data_id_guideline_criteria(j) || ');';
                    
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    
                        INSERT INTO guideline_criteria_link
                            (id_guideline_criteria_link,
                             id_guideline_criteria,
                             id_link_other_criteria_old,
                             id_link_other_criteria_type,
                             id_link_other_criteria)
                        VALUES
                            (seq_guideline_criteria_link.nextval,
                             l_data_id_guideline_criteria(j),
                             l_data_id_lk_oth_criteria(j),
                             l_data_id_lk_oth_cri_type(j),
                             l_data_id_lk_oth_criteria(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_guideline_criteria%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_GUIDELINE_CRITERIA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_guideline_criteria;
            
                g_error := 'CLOSE L_C_ID_LK_OTH_CRITERIA CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_lk_oth_criteria;
            
                g_error := 'CLOSE L_C_ID_LK_OTH_CRI_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_lk_oth_cri_type;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guideline_crit_link;
    /********************************************************************************************
    * Get Guideline ADV Input Value set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_adv_input_link            Cursor of adv input link
    * @param o_flg_type                     Cursor of Flg Type
    * @param o_value_type                   Cursor of Value Type
    * @param o_nvalue                       Cursor of n Value
    * @param o_dvalue                       Cursor of d Value
    * @param o_vvalue                       Cursor of v Value
    * @param o_vvalue_desc                  Cursor of v Value Description
    * @param o_criteria_value_type          Cursor of Criteria Value Type
    * @param o_id_adv_input                 Cursor of adv input
    * @param o_id_adv_input_field           Cursor of adv input field
    * @param o_id_adv_input_field_det       Cursor of adv input field det
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/19
    ********************************************************************************************/
    FUNCTION get_inst_guide_adv_input_value
    (
        i_lang                   IN language.id_language%TYPE,
        i_market                 IN table_number,
        i_version                IN table_varchar,
        i_id_software            IN software.id_software%TYPE,
        o_id_adv_input_link      OUT pk_types.cursor_type,
        o_flg_type               OUT pk_types.cursor_type,
        o_value_type             OUT pk_types.cursor_type,
        o_nvalue                 OUT pk_types.cursor_type,
        o_dvalue                 OUT pk_types.cursor_type,
        o_vvalue                 OUT pk_types.cursor_type,
        o_vvalue_desc            OUT pk_types.cursor_type,
        o_criteria_value_type    OUT pk_types.cursor_type,
        o_id_adv_input           OUT pk_types.cursor_type,
        o_id_adv_input_field     OUT pk_types.cursor_type,
        o_id_adv_input_field_det OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_adv_input_link      guideline_adv_input_value.id_adv_input_link%TYPE := NULL;
        l_flg_type               guideline_adv_input_value.flg_type%TYPE := NULL;
        l_value_type             guideline_adv_input_value.value_type%TYPE := NULL;
        l_nvalue                 guideline_adv_input_value.nvalue%TYPE := NULL;
        l_dvalue                 guideline_adv_input_value.dvalue%TYPE := NULL;
        l_vvalue                 guideline_adv_input_value.vvalue%TYPE := NULL;
        l_vvalue_desc            guideline_adv_input_value.value_desc%TYPE := NULL;
        l_criteria_value_type    guideline_adv_input_value.criteria_value_type%TYPE := NULL;
        l_id_adv_input           guideline_adv_input_value.id_advanced_input%TYPE := NULL;
        l_id_adv_input_field     guideline_adv_input_value.id_advanced_input_field%TYPE := NULL;
        l_id_adv_input_field_det guideline_adv_input_value.id_advanced_input_field_det%TYPE := NULL;
    
        l_id_adv_input_link_array      table_number := table_number();
        l_flg_type_array               table_varchar := table_varchar();
        l_value_type_array             table_varchar := table_varchar();
        l_nvalue_array                 table_number := table_number();
        l_dvalue_array                 table_date := table_date();
        l_vvalue_array                 table_varchar := table_varchar();
        l_vvalue_desc_array            table_varchar := table_varchar();
        l_criteria_value_type_array    table_number := table_number();
        l_id_adv_input_array           table_number := table_number();
        l_id_adv_input_field_array     table_number := table_number();
        l_id_adv_input_field_det_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        l_var_t VARCHAR2(1) := pk_guidelines.g_adv_input_type_tasks;
        l_var_c VARCHAR2(1) := pk_guidelines.g_adv_input_type_criterias;
    
        CURSOR c_guide_adv_input_value
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT gaiv.id_adv_input_link,
                            gaiv.flg_type,
                            gaiv.value_type,
                            gaiv.nvalue,
                            gaiv.dvalue,
                            gaiv.vvalue,
                            gaiv.value_desc,
                            gaiv.criteria_value_type,
                            gaiv.id_advanced_input,
                            gaiv.id_advanced_input_field,
                            gaiv.id_advanced_input_field_det
              FROM alert_default.guideline_adv_input_value gaiv
              JOIN alert_default.guideline_criteria gc
                ON (gc.id_guideline_criteria = gaiv.id_adv_input_link)
              JOIN alert_default.guideline g
                ON (g.id_guideline = gc.id_guideline)
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = gc.id_guideline AND gmv.id_market = c_market AND gmv.version = c_version)
             WHERE gaiv.flg_type = l_var_c
            UNION ALL
            SELECT DISTINCT gaiv.id_adv_input_link,
                            gaiv.flg_type,
                            gaiv.value_type,
                            gaiv.nvalue,
                            gaiv.dvalue,
                            gaiv.vvalue,
                            gaiv.value_desc,
                            gaiv.criteria_value_type,
                            gaiv.id_advanced_input,
                            gaiv.id_advanced_input_field,
                            gaiv.id_advanced_input_field_det
              FROM alert_default.guideline_adv_input_value gaiv
              JOIN alert_default.guideline_task_link gt
                ON (gt.id_guideline_task_link = gaiv.id_adv_input_link)
              JOIN alert_default.guideline g
                ON (g.id_guideline = gt.id_guideline)
              JOIN alert_default.guideline_mrk_vrs pmv
                ON (pmv.id_guideline = g.id_guideline AND pmv.id_market = c_market AND pmv.version = c_version)
             WHERE gaiv.flg_type = l_var_t;
    
    BEGIN
        g_func_name := 'GET_INST_GUIDE_ADV_INPUT_VALUE ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_GUIDELINE_ADV_INPUT_VALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guide_adv_input_value(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_guide_adv_input_value
                        INTO l_id_adv_input_link,
                             l_flg_type,
                             l_value_type,
                             l_nvalue,
                             l_dvalue,
                             l_vvalue,
                             l_vvalue_desc,
                             l_criteria_value_type,
                             l_id_adv_input,
                             l_id_adv_input_field,
                             l_id_adv_input_field_det;
                    EXIT WHEN c_guide_adv_input_value%NOTFOUND;
                
                    g_error := 'COUNT GUIDELINE_ADV_INPUT_VALUE';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT COUNT(p.id_guideline_adv_input_value)
                      INTO l_count
                      FROM guideline_adv_input_value p
                     WHERE p.id_adv_input_link = l_id_adv_input_link
                       AND p.flg_type = l_flg_type
                       AND p.id_advanced_input = l_id_adv_input
                       AND p.id_advanced_input_field = l_id_adv_input_field
                       AND (p.id_advanced_input_field_det = l_id_adv_input_field_det OR
                           p.id_advanced_input_field_det IS NULL);
                
                    g_error := 'IF COUNT GUIDELINE_ADV_INPUT_VALUE = 0';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    IF l_count = 0
                    THEN
                        l_id_adv_input_link_array.extend;
                        l_flg_type_array.extend;
                        l_value_type_array.extend;
                        l_nvalue_array.extend;
                        l_dvalue_array.extend;
                        l_vvalue_array.extend;
                        l_vvalue_desc_array.extend;
                        l_criteria_value_type_array.extend;
                        l_id_adv_input_array.extend;
                        l_id_adv_input_field_array.extend;
                        l_id_adv_input_field_det_array.extend;
                    
                        l_id_adv_input_link_array(l_index) := l_id_adv_input_link;
                        l_flg_type_array(l_index) := l_flg_type;
                        l_value_type_array(l_index) := l_value_type;
                        l_nvalue_array(l_index) := l_nvalue;
                        l_dvalue_array(l_index) := l_dvalue;
                        l_vvalue_array(l_index) := l_vvalue;
                        l_vvalue_desc_array(l_index) := l_vvalue_desc;
                        l_criteria_value_type_array(l_index) := l_criteria_value_type;
                        l_id_adv_input_array(l_index) := l_id_adv_input;
                        l_id_adv_input_field_array(l_index) := l_id_adv_input_field;
                        l_id_adv_input_field_det_array(l_index) := l_id_adv_input_field_det;
                    
                        l_index := l_index + 1;
                    
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_GUIDELINE_ADV_INPUT_VALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guide_adv_input_value;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_ADV_INPUT_LINK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_adv_input_link FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_link_array AS table_number));
    
        g_error := 'OPEN O_FLG_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_type_array AS table_varchar));
    
        g_error := 'OPEN O_VALUE_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_value_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_value_type_array AS table_varchar));
    
        g_error := 'OPEN O_NVALUE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_nvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_nvalue_array AS table_number));
    
        g_error := 'OPEN O_DVALUE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_dvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_dvalue_array AS table_date));
    
        g_error := 'OPEN O_VVALUE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_vvalue FOR
            SELECT column_value
              FROM TABLE(CAST(l_vvalue_array AS table_varchar));
    
        g_error := 'OPEN O_VVALUE_DESC CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_vvalue_desc FOR
            SELECT column_value
              FROM TABLE(CAST(l_vvalue_desc_array AS table_varchar));
    
        g_error := 'OPEN O_CRITERIA_VALUE_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_criteria_value_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_criteria_value_type_array AS table_number));
    
        g_error := 'OPEN O_ID_ADV_INPUT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_adv_input FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_array AS table_number));
    
        g_error := 'OPEN O_ID_ADV_INPUT_FIELD CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_adv_input_field FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_field_array AS table_number));
    
        g_error := 'OPEN O_ID_ADV_INPUT_FIELD_DET CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_adv_input_field_det FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_adv_input_field_det_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_adv_input_link);
            pk_types.open_my_cursor(o_flg_type);
            pk_types.open_my_cursor(o_value_type);
            pk_types.open_my_cursor(o_nvalue);
            pk_types.open_my_cursor(o_dvalue);
            pk_types.open_my_cursor(o_vvalue);
            pk_types.open_my_cursor(o_vvalue_desc);
            pk_types.open_my_cursor(o_criteria_value_type);
            pk_types.open_my_cursor(o_id_adv_input);
            pk_types.open_my_cursor(o_id_adv_input_field);
            pk_types.open_my_cursor(o_id_adv_input_field_det);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guide_adv_input_value;
    /*********************************************************************************************
    * Set Guideline AVD Input VAlue for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param i_software                Software ID's
    * @param o_guide_adv_input_value   Cursor of Instituition Guideline_Advanced_Input_Value
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6
    * @since                           2010/05/19
    ********************************************************************************************/
    FUNCTION set_inst_guide_adv_input_value
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_software              IN table_number,
        o_guide_adv_input_value OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_adv_input_link      pk_types.cursor_type;
        l_c_flg_type               pk_types.cursor_type;
        l_c_value_type             pk_types.cursor_type;
        l_c_nvalue                 pk_types.cursor_type;
        l_c_dvalue                 pk_types.cursor_type;
        l_c_vvalue                 pk_types.cursor_type;
        l_c_vvalue_desc            pk_types.cursor_type;
        l_c_criteria_value_type    pk_types.cursor_type;
        l_c_id_adv_input           pk_types.cursor_type;
        l_c_id_adv_input_field     pk_types.cursor_type;
        l_c_id_adv_input_field_det pk_types.cursor_type;
    
        l_data_id_adv_input_link      table_number;
        l_data_flg_type               table_varchar;
        l_data_value_type             table_varchar;
        l_data_nvalue                 table_number;
        l_data_dvalue                 table_date;
        l_data_vvalue                 table_varchar;
        l_data_vvalue_desc            table_varchar;
        l_data_criteria_value_type    table_number;
        l_data_id_adv_input           table_number;
        l_data_id_adv_input_field     table_number;
        l_data_id_adv_input_field_det table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    BEGIN
        g_func_name := 'SET_INST_GUIDE_ADV_INPUT_VALUE';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_GUIDE_ADV_INPUT_VALUE';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            IF NOT get_inst_guide_adv_input_value(i_lang,
                                                  i_market,
                                                  i_version,
                                                  i_software(i),
                                                  l_c_id_adv_input_link,
                                                  l_c_flg_type,
                                                  l_c_value_type,
                                                  l_c_nvalue,
                                                  l_c_dvalue,
                                                  l_c_vvalue,
                                                  l_c_vvalue_desc,
                                                  l_c_criteria_value_type,
                                                  l_c_id_adv_input,
                                                  l_c_id_adv_input_field,
                                                  l_c_id_adv_input_field_det,
                                                  o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_guide_adv_input_value := l_c_id_adv_input_link';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                o_guide_adv_input_value := l_c_id_adv_input_link;
            
                LOOP
                    FETCH l_c_id_adv_input_link BULK COLLECT
                        INTO l_data_id_adv_input_link LIMIT g_array_size;
                    FETCH l_c_flg_type BULK COLLECT
                        INTO l_data_flg_type LIMIT g_array_size;
                    FETCH l_c_value_type BULK COLLECT
                        INTO l_data_value_type LIMIT g_array_size;
                    FETCH l_c_nvalue BULK COLLECT
                        INTO l_data_nvalue LIMIT g_array_size;
                    FETCH l_c_dvalue BULK COLLECT
                        INTO l_data_dvalue LIMIT g_array_size;
                    FETCH l_c_vvalue BULK COLLECT
                        INTO l_data_vvalue LIMIT g_array_size;
                    FETCH l_c_vvalue_desc BULK COLLECT
                        INTO l_data_vvalue_desc LIMIT g_array_size;
                    FETCH l_c_criteria_value_type BULK COLLECT
                        INTO l_data_criteria_value_type LIMIT g_array_size;
                    FETCH l_c_id_adv_input BULK COLLECT
                        INTO l_data_id_adv_input LIMIT g_array_size;
                    FETCH l_c_id_adv_input_field BULK COLLECT
                        INTO l_data_id_adv_input_field LIMIT g_array_size;
                    FETCH l_c_id_adv_input_field_det BULK COLLECT
                        INTO l_data_id_adv_input_field_det LIMIT g_array_size;
                
                    g_error := 'INSERT INTO GUIDELINE_ADV_INPUT_VALUE [' || l_data_id_adv_input_link.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                
                    FOR j IN 1 .. l_data_id_adv_input_link.count
                    LOOP
                        g_error := 'INSERT INTO GUIDELINE_ADV_INPUT_VALUE (seq_guideline_adv_input_value.nextval,' ||
                                   l_data_id_adv_input_link(j) || ');';
                    
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                        INSERT INTO guideline_adv_input_value
                            (id_guideline_adv_input_value,
                             id_adv_input_link,
                             flg_type,
                             value_type,
                             nvalue,
                             dvalue,
                             vvalue,
                             value_desc,
                             criteria_value_type,
                             id_advanced_input,
                             id_advanced_input_field,
                             id_advanced_input_field_det)
                        VALUES
                            (seq_guideline_adv_input_value.nextval,
                             l_data_id_adv_input_link(j),
                             l_data_flg_type(j),
                             l_data_value_type(j),
                             l_data_nvalue(j),
                             l_data_dvalue(j),
                             l_data_vvalue(j),
                             l_data_vvalue_desc(j),
                             l_data_criteria_value_type(j),
                             l_data_id_adv_input(j),
                             l_data_id_adv_input_field(j),
                             l_data_id_adv_input_field_det(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_adv_input_link%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_ADV_INPUT_LINK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_adv_input_link;
            
                g_error := 'CLOSE L_C_FLG_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_flg_type;
            
                g_error := 'CLOSE L_C_VALUE_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_value_type;
            
                g_error := 'CLOSE L_C_NVALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_nvalue;
            
                g_error := 'CLOSE L_C_DVALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_dvalue;
            
                g_error := 'CLOSE L_C_VVALUE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_vvalue;
            
                g_error := 'CLOSE L_C_VVALUE_DESC CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_vvalue_desc;
            
                g_error := 'CLOSE L_C_CRITERIA_VALUE_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_criteria_value_type;
            
                g_error := 'CLOSE L_C_ID_ADV_INPUT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_adv_input;
            
                g_error := 'CLOSE L_C_ID_ADV_INPUT_FIELD CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_adv_input_field;
            
                g_error := 'CLOSE L_C_ID_ADV_INPUT_FIELD_DET CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_adv_input_field_det;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guide_adv_input_value;
    /********************************************************************************************
    * Get Guideline Frequent set of markets, versions and sotwares
    *
    * @param i_lang                         Prefered language ID
    * @param i_market                       Market ID's
    * @param i_version                      ALERT version's
    * @param i_id_institution               Institution ID
    * @param i_id_software                  Software ID
    * @param o_id_guideline                  Cursor of Guidelines
    * @param o_id_software                  Cursor of Software ID
    * @param o_rank                         Cursor of Rank
    * @param o_error                        Error
    *
    * @return                               true or false on success or error
    *
    * @author                               MESS
    * @version                              2.6
    * @since                                2010/05/19
    ********************************************************************************************/
    FUNCTION get_inst_guideline_frequent
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_guideline   OUT pk_types.cursor_type,
        o_id_software    OUT pk_types.cursor_type,
        o_rank           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_guideline_def guideline_frequent.id_guideline%TYPE := NULL;
        l_id_guideline     guideline_frequent.id_guideline%TYPE := NULL;
        l_id_content_def   guideline.id_content%TYPE := NULL;
        l_id_software      guideline_frequent.id_software%TYPE := NULL;
        l_rank             guideline_frequent.rank%TYPE := NULL;
    
        l_id_guideline_array table_number := table_number();
        l_id_software_array  table_number := table_number();
        l_rank_array         table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_guideline_frequent
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT gf.id_guideline, g.id_content, gf.id_software, gf.rank
              FROM alert_default.guideline_frequent gf
              JOIN alert_default.guideline g
                ON (g.id_guideline = gf.id_guideline)
              JOIN alert_default.guideline_mrk_vrs gmv
                ON (gmv.id_guideline = gf.id_guideline AND gmv.id_market = c_market AND gmv.version = c_version)
             WHERE gf.id_software = c_id_software;
    
    BEGIN
        g_func_name := 'GET_INST_GUIDELINE_FREQUENT ';
        FOR i IN 1 .. i_version.count
        LOOP
            FOR j IN 1 .. i_market.count
            LOOP
                g_error := 'OPEN C_GUIDELINE_FREQUENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                OPEN c_guideline_frequent(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_guideline_frequent
                        INTO l_id_guideline_def, l_id_content_def, l_id_software, l_rank;
                    EXIT WHEN c_guideline_frequent%NOTFOUND;
                
                    g_error := 'GET ALERT ID_GUIDELINE';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT nvl((SELECT g.id_guideline
                                 FROM guideline g
                                WHERE g.id_content = l_id_content_def
                                  AND g.id_content IS NOT NULL
                                  AND g.id_institution = i_id_institution
                                  AND rownum = 1),
                               0)
                      INTO l_id_guideline
                      FROM dual;
                
                    g_error := 'COUNT GUIDELINE_FREQUENT';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                    SELECT COUNT(gf.id_guideline)
                      INTO l_count
                      FROM guideline_frequent gf
                     WHERE gf.id_guideline = l_id_guideline
                       AND gf.id_software = l_id_software;
                
                    IF l_id_guideline != 0
                       AND l_count = 0
                    THEN
                        l_id_guideline_array.extend;
                        l_id_software_array.extend;
                        l_rank_array.extend;
                    
                        l_id_guideline_array(l_index) := l_id_guideline;
                        l_id_software_array(l_index) := l_id_software;
                        l_rank_array(l_index) := l_rank;
                    
                        l_index := l_index + 1;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_GUIDELINE_FREQUENT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE c_guideline_frequent;
            
            END LOOP;
        END LOOP;
    
        g_error := 'OPEN O_ID_GUIDELINE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_guideline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_guideline_array AS table_number));
    
        g_error := 'OPEN O_ID_SOFTWARE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_id_software FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_software_array AS table_number));
    
        g_error := 'OPEN O_RANK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_guideline);
            pk_types.open_my_cursor(o_id_software);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_guideline_frequent;
    /*********************************************************************************************
    * Set Guideline Frequent for a specific institution
    *
    * @param i_lang                     Prefered language ID
    * @param i_market                   Market ID's
    * @param i_version                  ALERT version's
    * @param i_id_institution           Institution ID
    * @param i_software                 Software ID's
    * @param o_guideline_frequent        Cursor of Instituition Guideline_Frequent
    * @param o_error                    Error
    *
    * @return                           true or false on success or error
    *
    * @author                           MESS
    * @version                          2.6
    * @since                            2010/05/19
    ********************************************************************************************/
    FUNCTION set_inst_guideline_frequent
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_software           IN table_number,
        o_guideline_frequent OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_guideline pk_types.cursor_type;
        l_c_id_software  pk_types.cursor_type;
        l_c_rank         pk_types.cursor_type;
    
        l_data_id_guideline table_number;
        l_data_id_software  table_number;
        l_data_rank         table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        l_pk        table_number := table_number();
    BEGIN
        g_func_name := 'SET_INST_GUIDELINE_FREQUENT ';
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_GUIDELINE_FREQUENT';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
        
            IF NOT get_inst_guideline_frequent(i_lang,
                                               i_market,
                                               i_version,
                                               i_id_institution,
                                               i_software(i),
                                               l_c_id_guideline,
                                               l_c_id_software,
                                               l_c_rank,
                                               o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_guideline_frequent := l_c_id_guideline';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
            
                o_guideline_frequent := l_c_id_guideline;
            
                LOOP
                
                    FETCH l_c_id_guideline BULK COLLECT
                        INTO l_data_id_guideline LIMIT g_array_size;
                
                    FETCH l_c_id_software BULK COLLECT
                        INTO l_data_id_software LIMIT g_array_size;
                
                    FETCH l_c_rank BULK COLLECT
                        INTO l_data_rank LIMIT g_array_size;
                
                    SELECT start_num.x + aa.y
                      BULK COLLECT
                      INTO l_pk
                      FROM (SELECT MAX(id_guideline_frequent) x
                              FROM guideline_frequent gf) start_num,
                           (SELECT rownum y
                              FROM TABLE(CAST(l_data_id_guideline AS table_number))) aa;
                
                    g_error := 'INSERT INTO GUIDELINE_FREQUENT [' || l_data_id_guideline.count || ']';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                
                    FOR j IN 1 .. l_data_id_guideline.count
                    LOOP
                        g_error := 'INSERT INTO GUIDELINE_FREQUENT (' || l_data_rank(j) || ', ' ||
                                   l_data_id_guideline(j) || ', ' || i_id_institution || ', ' || l_data_id_software(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_GUIDELINE_FREQUENT ' || g_error);
                        -->ALERT-197894 inserted id_guideline_frequent again, development not ready yet
                        INSERT INTO guideline_frequent
                            (id_guideline_frequent, rank, id_guideline, id_institution, id_software)
                        VALUES
                            (l_pk(j), l_data_rank(j), l_data_id_guideline(j), i_id_institution, l_data_id_software(j));
                    
                    END LOOP;
                    EXIT WHEN l_c_id_guideline%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_GUIDELINE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_guideline;
            
                g_error := 'CLOSE L_C_ID_SOFTWARE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_id_software;
            
                g_error := 'CLOSE L_C_RANK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.' || g_func_name || g_error);
                CLOSE l_c_rank;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_guideline_frequent;
    /********************************************************************************************
    * Get Comp_Config set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_comp_Axe            Cursor of Comp_Axe
    * @param o_complication        Cursor of Complication
    * @param o_id_clinical_service Cursor of Clinical_Service
    * @param o_flg_configuration   Cursor of Flg_Configuration
    * @param o_id_sys_list         Cursor of ID_Sys_List
    * @param o_rank                Cursor of Rank
    * @param o_flg_default         Cursor of Flg_Default
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/20
    ********************************************************************************************/
    FUNCTION get_inst_comp_config
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN table_number,
        i_version             IN table_varchar,
        i_id_institution      IN institution.id_institution%TYPE,
        i_id_software         IN software.id_software%TYPE,
        o_complication        OUT pk_types.cursor_type,
        o_comp_axe            OUT pk_types.cursor_type,
        o_id_clinical_service OUT pk_types.cursor_type,
        o_flg_configuration   OUT pk_types.cursor_type,
        o_id_sys_list         OUT pk_types.cursor_type,
        o_rank                OUT pk_types.cursor_type,
        o_flg_default         OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --COMP_AXE
        l_id_comp_axe_def comp_axe.id_comp_axe%TYPE := NULL;
        l_id_comp_axe     comp_axe.id_comp_axe%TYPE := NULL;
    
        --COMPLICATION
        l_id_complication_def complication.id_complication%TYPE;
        l_id_complication     complication.id_complication%TYPE;
    
        --CLINICAL_SERVICE
        l_id_clinical_service_def clinical_service.id_clinical_service%TYPE;
        l_id_clinical_service     clinical_service.id_clinical_service%TYPE;
    
        --COMP_CONFIG
        l_flg_configuration comp_config.flg_configuration%TYPE := NULL;
        l_id_sys_list       comp_config.id_sys_list%TYPE := NULL;
        l_rank              comp_config.rank%TYPE := NULL;
        l_flg_default       comp_config.flg_default%TYPE := NULL;
    
        l_id_comp_axe_array            table_number := table_number();
        l_id_complication_array        table_number := table_number();
        l_id_clinical_service_array    table_number := table_number();
        l_comp_flg_configuratiot_array table_varchar := table_varchar();
        l_comp_id_sys_list_array       table_number := table_number();
        l_comp_rank_array              table_number := table_number();
        l_comp_flg_default_array       table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_comp_config
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN NUMBER
        ) IS
            SELECT DISTINCT cc.id_complication,
                            cc.id_comp_axe,
                            cc.id_clinical_service,
                            cc.flg_configuration,
                            cc.id_sys_list,
                            cc.rank,
                            cc.flg_default
              FROM alert_default.comp_config cc
              LEFT JOIN alert_default.comp_axe ca
                ON (ca.id_comp_axe = cc.id_comp_axe AND ca.flg_available = g_flg_available)
              JOIN alert_default.comp_axe_mrk_vrs camv
                ON (camv.id_comp_axe = ca.id_comp_axe AND camv.id_market = c_market AND camv.version = c_version)
              LEFT JOIN alert_default.complication c
                ON (c.id_complication = cc.id_complication AND c.flg_available = g_flg_available)
              JOIN alert_default.comp_mrk_vrs cmv
                ON (cmv.id_complication = c.id_complication AND cmv.id_market = c_market AND cmv.version = c_version)
             WHERE cc.id_software = c_id_software
               AND (cc.id_clinical_service = -1 OR cc.id_clinical_service IS NULL);
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_COMP_CONFIG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
                OPEN c_comp_config(i_id_software, i_version(i), i_market(j));
                LOOP
                    FETCH c_comp_config
                        INTO l_id_complication_def,
                             l_id_comp_axe_def,
                             l_id_clinical_service_def,
                             l_flg_configuration,
                             l_id_sys_list,
                             l_rank,
                             l_flg_default;
                    EXIT WHEN c_comp_config%NOTFOUND;
                
                    --COMPLICATION
                    IF l_id_complication_def IS NOT NULL
                    THEN
                        g_error := 'GET COMPLICATION_ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
                        SELECT nvl((SELECT c.id_complication
                                     FROM complication c
                                    WHERE c.id_content =
                                          (SELECT c2.id_content
                                             FROM alert_default.complication c2
                                            WHERE c2.id_complication = l_id_complication_def)
                                      AND c.id_content IS NOT NULL
                                      AND c.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_complication
                          FROM dual;
                    ELSE
                        l_id_complication := NULL;
                    END IF;
                
                    --COMP_AXE
                    IF l_id_comp_axe_def IS NOT NULL
                    THEN
                        g_error := 'GET COMP_AXE_ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
                        SELECT nvl((SELECT ca.id_comp_axe
                                     FROM comp_axe ca
                                    WHERE ca.id_content = (SELECT ca2.id_content
                                                             FROM alert_default.comp_axe ca2
                                                            WHERE ca2.id_comp_axe = l_id_comp_axe_def)
                                      AND ca.id_content IS NOT NULL
                                      AND ca.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_comp_axe
                          FROM dual;
                    ELSE
                        l_id_comp_axe := NULL;
                    END IF;
                
                    --CLINICAL_SERVICE
                    IF l_id_clinical_service_def IS NOT NULL
                    THEN
                        g_error := 'GET CLINICAL_SERVICE_ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
                        SELECT nvl((SELECT cs.id_clinical_service
                                     FROM clinical_service cs
                                    WHERE cs.id_content =
                                          (SELECT cs2.id_content
                                             FROM alert_default.clinical_service cs2
                                            WHERE cs2.id_clinical_service = l_id_clinical_service_def)
                                      AND cs.id_content IS NOT NULL
                                      AND cs.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_clinical_service
                          FROM dual;
                    ELSE
                        l_id_clinical_service := -1;
                    END IF;
                
                    IF (l_id_complication != 0 OR l_id_complication IS NULL)
                       AND (l_id_comp_axe != 0 OR l_id_comp_axe IS NULL)
                       AND l_id_clinical_service != 0
                    THEN
                    
                        g_error := 'COUNT_COMP_CONFIG';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
                    
                        SELECT COUNT(cc.id_comp_config)
                          INTO l_count
                          FROM comp_config cc
                         WHERE cc.id_complication = l_id_complication
                           AND cc.id_comp_axe = l_id_comp_axe
                           AND cc.id_clinical_service = l_id_clinical_service
                           AND cc.id_institution = i_id_institution
                           AND cc.id_sys_list = l_id_sys_list
                           AND cc.id_software = i_id_software;
                    
                        IF l_count = 0
                        THEN
                            l_id_complication_array.extend;
                            l_id_comp_axe_array.extend;
                            l_id_clinical_service_array.extend;
                            l_comp_flg_configuratiot_array.extend;
                            l_comp_id_sys_list_array.extend;
                            l_comp_rank_array.extend;
                            l_comp_flg_default_array.extend;
                        
                            l_id_complication_array(l_index) := l_id_complication;
                            l_id_comp_axe_array(l_index) := l_id_comp_axe;
                            l_id_clinical_service_array(l_index) := l_id_clinical_service;
                            l_comp_flg_configuratiot_array(l_index) := l_flg_configuration;
                            l_comp_id_sys_list_array(l_index) := l_id_sys_list;
                            l_comp_rank_array(l_index) := l_rank;
                            l_comp_flg_default_array(l_index) := l_flg_default;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_COMP_CONFIG CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
                CLOSE c_comp_config;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_COMPLICATION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
        OPEN o_complication FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_complication_array AS table_number));
    
        g_error := 'CLOSE O_COMP_AXE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
        OPEN o_comp_axe FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_comp_axe_array AS table_number));
    
        g_error := 'CLOSE O_CLINICAL_SERVICE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
        OPEN o_id_clinical_service FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_clinical_service_array AS table_number));
    
        g_error := 'CLOSE O_FLG_CONFIGURATION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
        OPEN o_flg_configuration FOR
            SELECT column_value
              FROM TABLE(CAST(l_comp_flg_configuratiot_array AS table_varchar));
    
        g_error := 'CLOSE O_ID_SYS_LIST CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
        OPEN o_id_sys_list FOR
            SELECT column_value
              FROM TABLE(CAST(l_comp_id_sys_list_array AS table_number));
    
        g_error := 'CLOSE O_RANK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_comp_rank_array AS table_number));
    
        g_error := 'CLOSE O_FLG_DEFAULT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_CONFIG ' || g_error);
        OPEN o_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_comp_flg_default_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_COMP_CONFIG',
                                              o_error);
            pk_types.open_my_cursor(o_complication);
            pk_types.open_my_cursor(o_comp_axe);
            pk_types.open_my_cursor(o_id_clinical_service);
            pk_types.open_my_cursor(o_flg_configuration);
            pk_types.open_my_cursor(o_id_sys_list);
            pk_types.open_my_cursor(o_rank);
            pk_types.open_my_cursor(o_flg_default);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_comp_config;
    /*********************************************************************************************
    * Set Comp_Config Value for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param i_software                Software ID's
    * @param o_comp_config             Cursor of Instituition Comp_Config
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6
    * @since                           2010/05/21
    ********************************************************************************************/
    FUNCTION set_inst_comp_config
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_comp_config    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_complication     pk_types.cursor_type;
        l_c_id_comp_axe         pk_types.cursor_type;
        l_c_id_clinical_service pk_types.cursor_type;
        l_c_flg_configuration   pk_types.cursor_type;
        l_c_id_sys_list         pk_types.cursor_type;
        l_c_rank                pk_types.cursor_type;
        l_c_flg_default         pk_types.cursor_type;
    
        l_data_id_complication     table_number;
        l_data_id_comp_axe         table_number;
        l_data_id_clinical_service table_number;
        l_data_flg_configuration   table_varchar;
        l_data_id_sys_list         table_number;
        l_data_rank                table_number;
        l_data_flg_default         table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_COMP_CONFIG';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
        
            IF NOT get_inst_comp_config(i_lang,
                                        i_market,
                                        i_version,
                                        i_id_institution,
                                        i_software(i),
                                        l_c_id_complication,
                                        l_c_id_comp_axe,
                                        l_c_id_clinical_service,
                                        l_c_flg_configuration,
                                        l_c_id_sys_list,
                                        l_c_rank,
                                        l_c_flg_default,
                                        o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_comp_config := l_c_id_complication';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
            
                o_comp_config := l_c_id_complication;
            
                LOOP
                
                    FETCH l_c_id_complication BULK COLLECT
                        INTO l_data_id_complication LIMIT g_array_size;
                    FETCH l_c_id_comp_axe BULK COLLECT
                        INTO l_data_id_comp_axe LIMIT g_array_size;
                    FETCH l_c_id_clinical_service BULK COLLECT
                        INTO l_data_id_clinical_service LIMIT g_array_size;
                    FETCH l_c_flg_configuration BULK COLLECT
                        INTO l_data_flg_configuration LIMIT g_array_size;
                    FETCH l_c_id_sys_list BULK COLLECT
                        INTO l_data_id_sys_list LIMIT g_array_size;
                    FETCH l_c_rank BULK COLLECT
                        INTO l_data_rank LIMIT g_array_size;
                    FETCH l_c_flg_default BULK COLLECT
                        INTO l_data_flg_default LIMIT g_array_size;
                
                    FOR j IN 1 .. l_data_id_complication.count
                    LOOP
                        g_error := 'INSERT INTO COMP_CONFIG (seq_comp_config.nextval,' || l_data_id_complication(j) || ', ' ||
                                   l_data_id_comp_axe(j) || ', ' || l_data_id_clinical_service(j) || ', ' ||
                                   i_id_institution || ', ' || i_software(i) || ', ' || l_data_flg_configuration(j) || ', ' ||
                                   l_data_id_sys_list(j) || ', ' || l_data_rank(j) || ', ' || l_data_flg_default(j) || ');';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
                    
                        INSERT INTO comp_config
                            (id_comp_config,
                             id_complication,
                             id_comp_axe,
                             id_clinical_service,
                             id_institution,
                             id_software,
                             flg_configuration,
                             id_sys_list,
                             rank,
                             flg_default)
                        VALUES
                            (seq_comp_config.nextval,
                             l_data_id_complication(j),
                             l_data_id_comp_axe(j),
                             l_data_id_clinical_service(j),
                             i_id_institution,
                             i_software(i),
                             l_data_flg_configuration(j),
                             l_data_id_sys_list(j),
                             l_data_rank(j),
                             l_data_flg_default(j));
                    END LOOP;
                    EXIT WHEN l_c_id_complication%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_COMPLICATION CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
                CLOSE l_c_id_complication;
            
                g_error := 'CLOSE L_C_ID_COMP_AXE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
                CLOSE l_c_id_comp_axe;
            
                g_error := 'CLOSE L_C_ID_CLINICAL_SERVICE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
                CLOSE l_c_id_clinical_service;
            
                g_error := 'CLOSE L_C_FLG_CONFIGURATION CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
                CLOSE l_c_flg_configuration;
            
                g_error := 'CLOSE L_C_ID_SYS_LIST CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
                CLOSE l_c_id_sys_list;
            
                g_error := 'CLOSE L_C_RANK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
                CLOSE l_c_rank;
            
                g_error := 'CLOSE L_C_FLG_DEFAULT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_CONFIG ' || g_error);
                CLOSE l_c_flg_default;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_COMP_CONFIG',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_COMP_CONFIG',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_comp_config;
    /********************************************************************************************
    * Get Comp_Axe_Detail set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_id_comp_axe         Cursor of Comp_Axe_ID
    * @param o_id_parent_axe       Cursor of Comp_Axe_Parent_ID
    * @param o_id_comp_axe_group   Cursor of Comp_Axe_Group
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/05/21
    ********************************************************************************************/
    FUNCTION get_inst_comp_axe_detail
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        o_id_comp_axe       OUT pk_types.cursor_type,
        o_id_parent_axe     OUT pk_types.cursor_type,
        o_id_comp_axe_group OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --COMP_AXE
        l_id_comp_axe_def comp_axe.id_comp_axe%TYPE := NULL;
        l_id_comp_axe     comp_axe.id_comp_axe%TYPE := NULL;
    
        l_id_parent_axe_def comp_axe.id_comp_axe%TYPE := NULL;
        l_id_parent_axe     comp_axe.id_comp_axe%TYPE := NULL;
    
        --COMP_AXE_GROUP
        l_id_comp_axe_group_def comp_axe_detail.id_comp_axe_group%TYPE := NULL;
        l_id_comp_axe_group     comp_axe_detail.id_comp_axe_group%TYPE := NULL;
    
        l_id_comp_axe_array       table_number := table_number();
        l_id_parent_array         table_number := table_number();
        l_id_comp_axe_group_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_comp_axe_detail
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT t.id_comp_axe, t.id_parent_axe, t.id_comp_axe_group
              FROM alert_default.comp_axe_detail t
              JOIN alert_default.comp_axe ca
                ON ca.id_comp_axe = t.id_comp_axe
               AND ca.flg_available = g_yes
              JOIN alert_default.comp_axe_mrk_vrs camv
                ON camv.id_comp_axe = t.id_comp_axe
               AND camv.id_market = c_market
               AND camv.version = c_version
              LEFT JOIN alert_default.comp_axe_group cag
                ON cag.id_comp_axe_group = t.id_comp_axe_group
               AND cag.flg_available = g_yes;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_COMP_AXE_DETAIL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
                OPEN c_comp_axe_detail(i_version(i), i_market(j));
                LOOP
                    FETCH c_comp_axe_detail
                        INTO l_id_comp_axe_def, l_id_parent_axe_def, l_id_comp_axe_group_def;
                    EXIT WHEN c_comp_axe_detail%NOTFOUND;
                    --COMP_AXE
                    IF l_id_comp_axe_def IS NOT NULL
                    THEN
                        g_error := 'GET COMP_AXE_ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
                        SELECT nvl((SELECT ca.id_comp_axe
                                     FROM comp_axe ca
                                    WHERE ca.id_content = (SELECT ca2.id_content
                                                             FROM alert_default.comp_axe ca2
                                                            WHERE ca2.id_comp_axe = l_id_comp_axe_def)
                                      AND ca.id_content IS NOT NULL
                                      AND ca.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_comp_axe
                          FROM dual;
                    ELSE
                        l_id_comp_axe := NULL;
                    END IF;
                
                    --PARENT_COMP_AXE
                    IF l_id_parent_axe_def IS NOT NULL
                    THEN
                        g_error := 'GET COMP_AXE_ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
                        SELECT nvl((SELECT ca.id_comp_axe
                                     FROM comp_axe ca
                                    WHERE ca.id_content =
                                          (SELECT ca2.id_content
                                             FROM alert_default.comp_axe ca2
                                            WHERE ca2.id_comp_axe = l_id_parent_axe_def)
                                      AND ca.id_content IS NOT NULL
                                      AND ca.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_parent_axe
                          FROM dual;
                    ELSE
                        l_id_parent_axe := NULL;
                    END IF;
                    --COMP_AXE_GROUP
                    IF l_id_comp_axe_group_def IS NOT NULL
                    THEN
                        g_error := 'GET COMP_AXE_GROUP_ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
                        SELECT nvl((SELECT cag.id_comp_axe_group
                                     FROM comp_axe_group cag
                                    WHERE cag.id_content =
                                          (SELECT cag2.id_content
                                             FROM alert_default.comp_axe_group cag2
                                            WHERE cag2.id_comp_axe_group = l_id_comp_axe_group_def)
                                      AND cag.id_content IS NOT NULL
                                      AND cag.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_id_comp_axe_group
                          FROM dual;
                    ELSE
                        l_id_comp_axe_group := NULL;
                    END IF;
                    --> ALERT-197895
                    IF ((l_id_comp_axe != 0 OR l_id_comp_axe IS NULL) AND l_id_comp_axe_group != 0 AND
                       l_id_parent_axe != 0)
                    THEN
                    
                        g_error := 'COUNT_COMP_AXE_DETAIL';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
                    
                        SELECT COUNT(cad.id_comp_axe_detail)
                          INTO l_count
                          FROM comp_axe_detail cad
                         WHERE cad.id_comp_axe = l_id_comp_axe
                           AND cad.id_parent_axe = l_id_parent_axe
                           AND cad.id_comp_axe_group = l_id_comp_axe_group;
                    
                        IF l_count = 0
                        THEN
                        
                            l_id_comp_axe_array.extend;
                            l_id_parent_array.extend;
                            l_id_comp_axe_group_array.extend;
                        
                            l_id_comp_axe_array(l_index) := l_id_comp_axe;
                            l_id_parent_array(l_index) := l_id_parent_axe;
                            l_id_comp_axe_group_array(l_index) := l_id_comp_axe_group;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_COMP_AXE_DETAIL CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
                CLOSE c_comp_axe_detail;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_COMPLICATION CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
        OPEN o_id_comp_axe FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_comp_axe_array AS table_number));
    
        g_error := 'CLOSE O_COMP_AXE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
        OPEN o_id_parent_axe FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_parent_array AS table_number));
    
        g_error := 'CLOSE O_CLINICAL_SERVICE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_COMP_AXE_DETAIL ' || g_error);
        OPEN o_id_comp_axe_group FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_comp_axe_group_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_COMP_AXE_DETAIL',
                                              o_error);
            pk_types.open_my_cursor(o_id_comp_axe);
            pk_types.open_my_cursor(o_id_parent_axe);
            pk_types.open_my_cursor(o_id_comp_axe_group);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_comp_axe_detail;

    /*********************************************************************************************
    * Set Comp_Axe_Detail Value for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param o_comp_axe_detail         Cursor of Instituition Comp_Axe_Detail
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6
    * @since                           2010/05/31
    ********************************************************************************************/
    FUNCTION set_inst_comp_axe_detail
    (
        i_lang            IN language.id_language%TYPE,
        i_market          IN table_number,
        i_version         IN table_varchar,
        o_comp_axe_detail OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_comp_axe       pk_types.cursor_type;
        l_c_id_parent_axe     pk_types.cursor_type;
        l_c_id_comp_axe_group pk_types.cursor_type;
    
        l_data_id_comp_axe       table_number;
        l_data_id_parent_axe     table_number;
        l_data_id_comp_axe_group table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'IF NOT GET_INST_COMP_CONFIG';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_AXE_DETAIL ' || g_error);
    
        IF NOT get_inst_comp_axe_detail(i_lang,
                                        i_market,
                                        i_version,
                                        l_c_id_comp_axe,
                                        l_c_id_parent_axe,
                                        l_c_id_comp_axe_group,
                                        o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error := 'o_comp_axe_detail := l_c_id_comp_axe';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_AXE_DETAIL ' || g_error);
        
            o_comp_axe_detail := l_c_id_comp_axe;
        
            LOOP
            
                FETCH l_c_id_comp_axe BULK COLLECT
                    INTO l_data_id_comp_axe LIMIT g_array_size;
                FETCH l_c_id_parent_axe BULK COLLECT
                    INTO l_data_id_parent_axe LIMIT g_array_size;
                FETCH l_c_id_comp_axe_group BULK COLLECT
                    INTO l_data_id_comp_axe_group LIMIT g_array_size;
            
                FOR j IN 1 .. l_data_id_comp_axe.count
                LOOP
                    g_error := 'INSERT INTO COMP_AXE_DETAIL (seq_comp_axe_detail.nextval,' || l_data_id_comp_axe(j) || ', ' ||
                               l_data_id_parent_axe(j) || ', ' || l_data_id_comp_axe_group(j) || ');';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_AXE_DETAIL ' || g_error);
                
                    INSERT INTO comp_axe_detail
                        (id_comp_axe_detail, id_comp_axe, id_parent_axe, id_comp_axe_group)
                    VALUES
                        (seq_comp_axe_detail.nextval,
                         l_data_id_comp_axe(j),
                         l_data_id_parent_axe(j),
                         l_data_id_comp_axe_group(j));
                END LOOP;
                EXIT WHEN l_c_id_comp_axe%NOTFOUND;
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_COMP_AXE CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_AXE_DETAIL ' || g_error);
            CLOSE l_c_id_comp_axe;
        
            g_error := 'CLOSE L_C_ID_PARENT_AXE CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_AXE_DETAIL ' || g_error);
            CLOSE l_c_id_parent_axe;
        
            g_error := 'CLOSE L_C_ID_COMP_AXE_GROUP CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_COMP_AXE_DETAIL ' || g_error);
            CLOSE l_c_id_comp_axe_group;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_COMP_AXE_DETAIL',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_COMP_AXE_DETAIL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_comp_axe_detail;
    /********************************************************************************************
    * Get Checklist set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_checklist           Cursor of checklist
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6
    * @since                       2010/07/07
    ********************************************************************************************/
    FUNCTION get_inst_checklist
    (
        i_lang            IN language.id_language%TYPE,
        i_market          IN table_number,
        i_version         IN table_varchar,
        i_id_institution  IN institution.id_institution%TYPE,
        o_id_checklist    OUT pk_types.cursor_type,
        o_flg_cnt_creator OUT pk_types.cursor_type,
        o_internal_name   OUT pk_types.cursor_type,
        o_flg_status      OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --CHECKLIST
        l_id_checklist checklist.id_checklist%TYPE;
        l_id_content   checklist.id_content%TYPE;
    
        --CHECKLIST_INST
        l_flg_cnt_creator checklist_inst.flg_content_creator%TYPE;
        l_internal_name   checklist_inst.internal_name%TYPE;
        l_flg_status      checklist_inst.flg_status%TYPE;
    
        l_id_checklist_array    table_number := table_number();
        l_flg_cnt_creator_array table_varchar := table_varchar();
        l_internal_name_array   table_varchar := table_varchar();
        l_flg_status_array      table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_checklist_inst
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT c.flg_content_creator, c.internal_name, c.id_content, c.flg_status
              FROM alert_default.checklist c
              JOIN alert_default.checklist_mrk_vrs cmv
                ON cmv.flg_content_creator = c.flg_content_creator
               AND cmv.id_checklist = c.id_checklist
               AND cmv.id_market = c_market
               AND cmv.version = c_version
             WHERE c.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_CHECKLIST_INST CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_CHECKLIST ' || g_error);
                OPEN c_checklist_inst(i_version(i), i_market(j));
                LOOP
                    FETCH c_checklist_inst
                        INTO l_flg_cnt_creator, l_internal_name, l_id_content, l_flg_status;
                    EXIT WHEN c_checklist_inst%NOTFOUND;
                
                    g_error := 'GET ALERT CHECKLIST ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_CHECKLIST ' || g_error);
                    SELECT nvl((SELECT c.id_checklist
                                 FROM checklist c
                                WHERE c.id_content = l_id_content
                                  AND c.flg_content_creator = l_flg_cnt_creator
                                  AND c.id_content IS NOT NULL
                                  AND c.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_checklist
                      FROM dual;
                
                    IF l_id_checklist != 0
                    THEN
                    
                        g_error := 'COUNT';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_CHECKLIST ' || g_error);
                    
                        SELECT COUNT(ci.id_checklist)
                          INTO l_count
                          FROM checklist_inst ci
                         WHERE ci.id_checklist = l_id_checklist
                           AND ci.flg_content_creator = l_flg_cnt_creator
                           AND ci.id_institution = i_id_institution;
                    
                        IF l_count = 0
                        THEN
                            l_id_checklist_array.extend;
                            l_flg_cnt_creator_array.extend;
                            l_internal_name_array.extend;
                            l_flg_status_array.extend;
                        
                            l_id_checklist_array(l_index) := l_id_checklist;
                            l_flg_cnt_creator_array(l_index) := l_flg_cnt_creator;
                            l_internal_name_array(l_index) := l_internal_name;
                            l_flg_status_array(l_index) := l_flg_status;
                        
                            l_index := l_index + 1;
                        END IF;
                    
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_CHECKLIST_INST CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_CHECKLIST ' || g_error);
                CLOSE c_checklist_inst;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_CHECKLIST CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_CHECKLIST ' || g_error);
        OPEN o_id_checklist FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_checklist_array AS table_number));
    
        g_error := 'CLOSE O_FLG_CNT_CREATOR CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_CHECKLIST ' || g_error);
        OPEN o_flg_cnt_creator FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_cnt_creator_array AS table_varchar));
    
        g_error := 'CLOSE O_INTERNAL_NAME CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_CHECKLIST ' || g_error);
        OPEN o_internal_name FOR
            SELECT column_value
              FROM TABLE(CAST(l_internal_name_array AS table_varchar));
    
        g_error := 'CLOSE O_FLG_STATUS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_CHECKLIST ' || g_error);
        OPEN o_flg_status FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_status_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_CHECKLIST',
                                              o_error);
            pk_types.open_my_cursor(o_id_checklist);
            pk_types.open_my_cursor(o_flg_cnt_creator);
            pk_types.open_my_cursor(o_internal_name);
            pk_types.open_my_cursor(o_flg_status);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_checklist;

    /*********************************************************************************************
    * Set CHECKLIST_INST Value for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param o_checklist_inst          Cursor of Instituition CHECKLIST_INST
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6
    * @since                           2010/07/07
    ********************************************************************************************/
    FUNCTION set_inst_checklist_inst
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_checklist_inst OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_checklist    pk_types.cursor_type;
        l_c_flg_cnt_creator pk_types.cursor_type;
        l_c_internal_name   pk_types.cursor_type;
        l_c_flg_status      pk_types.cursor_type;
    
        l_data_id_checklist    table_number;
        l_data_flg_cnt_creator table_varchar;
        l_data_internal_name   table_varchar;
        l_data_flg_status      table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'IF NOT GET_INST_CHECKLIST_INST';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_CHECKLIST_INST ' || g_error);
    
        IF NOT get_inst_checklist(i_lang,
                                  i_market,
                                  i_version,
                                  i_id_institution,
                                  l_c_id_checklist,
                                  l_c_flg_cnt_creator,
                                  l_c_internal_name,
                                  l_c_flg_status,
                                  o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error := 'o_checklist_inst := l_c_id_checklist';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_CHECKLIST_INST ' || g_error);
        
            o_checklist_inst := l_c_id_checklist;
        
            LOOP
            
                FETCH l_c_id_checklist BULK COLLECT
                    INTO l_data_id_checklist LIMIT g_array_size;
                FETCH l_c_flg_cnt_creator BULK COLLECT
                    INTO l_data_flg_cnt_creator LIMIT g_array_size;
                FETCH l_c_internal_name BULK COLLECT
                    INTO l_data_internal_name LIMIT g_array_size;
                FETCH l_c_flg_status BULK COLLECT
                    INTO l_data_flg_status LIMIT g_array_size;
            
                FOR j IN 1 .. l_data_id_checklist.count
                LOOP
                    g_error := 'INSERT INTO COMP_CONFIG values (' || l_data_flg_cnt_creator(j) || ', ' ||
                               l_data_internal_name(j) || ', ' || i_id_institution || ', ' || l_data_id_checklist(j) || ', ' ||
                               g_flg_available || ', ' || l_data_flg_status(j) || ');';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_CHECKLIST_INST ' || g_error);
                
                    INSERT INTO checklist_inst
                        (flg_content_creator, internal_name, id_institution, id_checklist, flg_available, flg_status)
                    VALUES
                        (l_data_flg_cnt_creator(j),
                         l_data_internal_name(j),
                         i_id_institution,
                         l_data_id_checklist(j),
                         g_flg_available,
                         l_data_flg_status(j));
                END LOOP;
                EXIT WHEN l_c_id_checklist%NOTFOUND;
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_CHECKLIST CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_CHECKLIST_INST ' || g_error);
            CLOSE l_c_id_checklist;
        
            g_error := 'CLOSE L_C_FLG_CNT_CREATOR CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_CHECKLIST_INST ' || g_error);
            CLOSE l_c_flg_cnt_creator;
        
            g_error := 'CLOSE L_C_INTERNAL_NAME CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_CHECKLIST_INST ' || g_error);
            CLOSE l_c_internal_name;
        
            g_error := 'CLOSE L_C_FLG_STATUS CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_CHECKLIST_INST ' || g_error);
            CLOSE l_c_flg_status;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_CHECKLIST_INST',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_CHECKLIST_INST',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_checklist_inst;
    /********************************************************************************************
    * Get REHAB_AREA_INTERV set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_id_rehab_area       Cursor of Rehab_Area
    * @param o_id_interv           Cursor of Intervention
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.3.3
    * @since                       2010/09/24
    ********************************************************************************************/
    FUNCTION get_inst_rehab_area_interv
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_id_rehab_area  OUT pk_types.cursor_type,
        o_id_interv      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --REHAB_AREA
        l_id_rehab_area rehab_area.id_rehab_area%TYPE;
        l_ra_id_content rehab_area.id_content%TYPE;
    
        --INTERVENTION
        l_id_intervention   intervention.id_intervention%TYPE;
        l_interv_id_content intervention.id_content%TYPE;
    
        l_id_rehab_area_array   table_number := table_number();
        l_id_intervention_array table_number := table_number();
    
        --REHAB_AREA
        l_id_rehab_area1 rehab_area.id_rehab_area%TYPE;
        l_ra_id_content1 rehab_area.id_content%TYPE;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        --Execute Rehab_Area_Inst
        l_c_rehab_area_inst pk_types.cursor_type;
        l_error             t_error_out;
        l_exception         EXCEPTION;
    
        CURSOR c_rehab_area_interv
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT ra.id_content, i.id_content
              FROM alert_default.rehab_area_interv rai
              JOIN alert_default.rehab_area ra
                ON ra.id_rehab_area = rai.id_rehab_area
               AND ra.flg_available = g_flg_available
              JOIN alert_default.rehab_area_mrk_vrs ramv
                ON ramv.id_rehab_area = rai.id_rehab_area
               AND ramv.id_market = c_market
               AND ramv.version = c_version
              JOIN alert_default.intervention i
                ON i.id_intervention = rai.id_intervention
               AND i.flg_status = g_active
              JOIN alert_default.interv_mrk_vrs imv
                ON imv.id_intervention = i.id_intervention
               AND imv.id_market = ramv.id_market
               AND imv.version = ramv.version;
    
        CURSOR c_rehab_area_inst
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT ra.id_content
              FROM alert_default.rehab_area ra
              JOIN alert_default.rehab_area_mrk_vrs ramv
                ON ramv.id_rehab_area = ra.id_rehab_area
               AND ramv.id_market = c_market
               AND ramv.version = c_version
             WHERE ra.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_REHAB_AREA_INTERV CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                OPEN c_rehab_area_interv(i_version(i), i_market(j));
                LOOP
                    FETCH c_rehab_area_interv
                        INTO l_ra_id_content, l_interv_id_content;
                    EXIT WHEN c_rehab_area_interv%NOTFOUND;
                
                    g_error := 'GET ALERT REHAB_AREA ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                    SELECT nvl((SELECT ra.id_rehab_area
                                 FROM rehab_area ra
                                WHERE ra.id_content = l_ra_id_content
                                  AND ra.id_content IS NOT NULL
                                  AND rownum = 1),
                               0)
                      INTO l_id_rehab_area
                      FROM dual;
                
                    g_error := 'GET ALERT INTERVENTION ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                    SELECT nvl((SELECT i.id_intervention
                                 FROM intervention i
                                WHERE i.id_content = l_interv_id_content
                                  AND i.id_content IS NOT NULL
                                  AND i.flg_status = g_active
                                  AND rownum = 1),
                               0)
                      INTO l_id_intervention
                      FROM dual;
                
                    IF l_id_rehab_area != 0
                       AND l_id_intervention != 0
                    THEN
                    
                        g_error := 'COUNT';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                    
                        SELECT COUNT(rai.id_rehab_area_interv)
                          INTO l_count
                          FROM rehab_area_interv rai
                         WHERE rai.id_rehab_area = l_id_rehab_area
                           AND rai.id_intervention = l_id_intervention;
                    
                        IF l_count = 0
                        THEN
                            l_id_rehab_area_array.extend;
                            l_id_intervention_array.extend;
                        
                            l_id_rehab_area_array(l_index) := l_id_rehab_area;
                            l_id_intervention_array(l_index) := l_id_intervention;
                        
                            l_index := l_index + 1;
                        END IF;
                    END IF;
                
                END LOOP;
            
                g_error := 'CLOSE C_REHAB_AREA_INTERV CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                CLOSE c_rehab_area_interv;
            
                g_error := 'OPEN C_REHAB_AREA_INST CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                OPEN c_rehab_area_inst(i_version(i), i_market(j));
                LOOP
                    FETCH c_rehab_area_inst
                        INTO l_ra_id_content1;
                    EXIT WHEN c_rehab_area_inst%NOTFOUND;
                
                    g_error := 'GET ALERT REHAB_AREA ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                    SELECT nvl((SELECT ra.id_rehab_area
                                 FROM rehab_area ra
                                WHERE ra.id_content = l_ra_id_content1
                                  AND ra.id_content IS NOT NULL
                                  AND rownum = 1),
                               0)
                      INTO l_id_rehab_area1
                      FROM dual;
                
                    IF l_id_rehab_area1 != 0
                    THEN
                        -->Insere as REHAB_AREA_INST
                        g_error := 'CALL SET_REHAB_AREA_INST';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                        IF NOT set_inst_rehab_area_inst(i_lang,
                                                        i_id_institution,
                                                        l_id_rehab_area1,
                                                        l_c_rehab_area_inst,
                                                        l_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_REHAB_AREA_INST CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
                CLOSE c_rehab_area_inst;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_ID_REHAB_AREA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
        OPEN o_id_rehab_area FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_rehab_area_array AS table_number));
    
        g_error := 'CLOSE O_ID_INTERV CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INTERV ' || g_error);
        OPEN o_id_interv FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_intervention_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_REHAB_AREA_INTERV',
                                              o_error);
            pk_types.open_my_cursor(o_id_rehab_area);
            pk_types.open_my_cursor(o_id_interv);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_rehab_area_interv;
    /*********************************************************************************************
    * Set REHAB_AREA_INTERV Value for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param o_rehab_area_interv       Cursor of REHAB_AREA_INTERV
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6.0.3.3
    * @since                           2010/09/24
    ********************************************************************************************/
    FUNCTION set_inst_rehab_area_interv
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        o_rehab_area_interv OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_rehab_area pk_types.cursor_type;
        l_c_id_interv     pk_types.cursor_type;
    
        l_data_id_rehab_area table_number;
        l_data_id_interv     table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'IF NOT GET_INST_REHAB_AREA_INTERV';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_AREA_INTERV ' || g_error);
    
        IF NOT get_inst_rehab_area_interv(i_lang,
                                          i_market,
                                          i_version,
                                          i_id_institution,
                                          l_c_id_rehab_area,
                                          l_c_id_interv,
                                          o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error := 'o_rehab_area_interv := l_c_id_rehab_area';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_AREA_INTERV ' || g_error);
            o_rehab_area_interv := l_c_id_rehab_area;
        
            LOOP
            
                FETCH l_c_id_rehab_area BULK COLLECT
                    INTO l_data_id_rehab_area LIMIT g_array_size;
                FETCH l_c_id_interv BULK COLLECT
                    INTO l_data_id_interv LIMIT g_array_size;
            
                FORALL j IN 1 .. l_data_id_rehab_area.count
                
                    INSERT INTO rehab_area_interv
                        (id_rehab_area_interv, id_rehab_area, id_intervention)
                    VALUES
                        (seq_rehab_area_interv.nextval, l_data_id_rehab_area(j), l_data_id_interv(j));
                EXIT WHEN l_c_id_rehab_area%NOTFOUND;
            
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_REHAB_AREA CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_AREA_INTERV ' || g_error);
            CLOSE l_c_id_rehab_area;
        
            g_error := 'CLOSE L_C_ID_INTERVENTION CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_AREA_INTERV ' || g_error);
            CLOSE l_c_id_interv;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_REHAB_AREA_INTERV',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_REHAB_AREA_INTERV',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_rehab_area_interv;
    /********************************************************************************************
    * Get REHAB_AREA_INST_SOFT set of markets, versions and sotwares
    *
    * @param i_lang                   Prefered language ID
    * @param i_market                 Market ID's
    * @param i_version                ALERT version's
    * @param i_id_institution         Institution ID
    * @param i_id_software            Software ID
    * @param o_id_rehab_area_interv   Cursor of rehab_area_interv
    * @param o_id_rehab_ss_type       Cursor of id_rehab_ss_type
    * @param o_flg_execute            Cursor of flg_execute
    * @param o_flg_add_remove         Cursor of flg_add_remove
    * @param o_error                  Error
    *
    * @return                         true or false on success or error
    *
    * @author                         MESS
    * @version                        2.6.0.3.3
    * @since                          2010/09/24
    ********************************************************************************************/
    FUNCTION get_inst_rehab_inst_soft
    (
        i_lang                 IN language.id_language%TYPE,
        i_market               IN table_number,
        i_version              IN table_varchar,
        i_id_institution       IN institution.id_institution%TYPE,
        i_id_software          IN software.id_software%TYPE,
        o_id_rehab_area_interv OUT pk_types.cursor_type,
        o_id_rehab_ss_type     OUT pk_types.cursor_type,
        o_flg_execute          OUT pk_types.cursor_type,
        o_flg_add_remove       OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --REHAB_AREA
        l_id_rehab_area rehab_area.id_rehab_area%TYPE;
        l_ra_id_content rehab_area.id_content%TYPE;
    
        --INTERVENTION
        l_id_intervention   intervention.id_intervention%TYPE;
        l_interv_id_content intervention.id_content%TYPE;
    
        --REHAB_AREA_SESSION_TYPE
        l_id_rehab_ss_type rehab_session_type.id_rehab_session_type%TYPE;
        l_rst_id_content   rehab_session_type.id_content%TYPE;
    
        --REHAB_INST_SOFT
        l_id_rai_def     rehab_inst_soft.id_rehab_area_interv%TYPE;
        l_id_rai         rehab_inst_soft.id_rehab_area_interv%TYPE;
        l_flg_execute    rehab_inst_soft.flg_execute%TYPE;
        l_flg_add_remove rehab_inst_soft.flg_add_remove%TYPE;
    
        l_id_rehab_area_interv_array table_number := table_number();
        l_id_rehab_sst_array         table_varchar := table_varchar();
        l_flg_execute_array          table_varchar := table_varchar();
        l_flg_add_remove_array       table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_rehab_inst_soft
        (
            c_version     IN VARCHAR2,
            c_market      IN NUMBER,
            c_id_software IN software.id_software%TYPE
        ) IS
            SELECT DISTINCT ris.id_rehab_area_interv,
                            ris.flg_execute,
                            ris.flg_add_remove,
                            rst.id_content,
                            ra.id_content,
                            i.id_content
              FROM alert_default.rehab_inst_soft ris
              JOIN alert_default.rehab_session_type rst
                ON rst.id_rehab_session_type = ris.id_rehab_session_type
               AND rst.flg_available = g_flg_available
              JOIN alert_default.rehab_session_type_mrk_vrs rstmv
                ON rstmv.id_rehab_session_type = rst.id_rehab_session_type
               AND rstmv.id_market = c_market
               AND rstmv.version = c_version
              JOIN alert_default.rehab_area_interv rai
                ON rai.id_rehab_area_interv = ris.id_rehab_area_interv
              JOIN alert_default.rehab_area ra
                ON ra.id_rehab_area = rai.id_rehab_area
               AND ra.flg_available = g_flg_available
              JOIN alert_default.rehab_area_mrk_vrs ramv
                ON ramv.id_rehab_area = rai.id_rehab_area
               AND ramv.id_market = rstmv.id_market
               AND ramv.version = rstmv.version
              JOIN alert_default.intervention i
                ON i.id_intervention = rai.id_intervention
               AND i.flg_status = g_active
              JOIN alert_default.interv_mrk_vrs imv
                ON imv.id_intervention = i.id_intervention
               AND imv.id_market = rstmv.id_market
               AND imv.version = rstmv.version
             WHERE ris.id_software = c_id_software;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_REHAB_INST_SOFT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
                OPEN c_rehab_inst_soft(i_version(i), i_market(j), i_id_software);
                LOOP
                    FETCH c_rehab_inst_soft
                        INTO l_id_rai_def,
                             l_flg_execute,
                             l_flg_add_remove,
                             l_rst_id_content,
                             l_ra_id_content,
                             l_interv_id_content;
                    EXIT WHEN c_rehab_inst_soft%NOTFOUND;
                
                    g_error := 'GET ALERT REHAB_SESSION_TYPE ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_REHAB_SESSION_TYPE ' || g_error);
                    SELECT nvl((SELECT rst.id_rehab_session_type
                                 FROM rehab_session_type rst
                                WHERE rst.id_content = l_rst_id_content
                                  AND rst.id_content IS NOT NULL
                                  AND rownum = 1),
                               'Not Found')
                      INTO l_id_rehab_ss_type
                      FROM dual;
                
                    g_error := 'GET ALERT REHAB_AREA ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
                    SELECT nvl((SELECT ra.id_rehab_area
                                 FROM rehab_area ra
                                WHERE ra.id_content = l_ra_id_content
                                  AND ra.id_content IS NOT NULL
                                  AND rownum = 1),
                               0)
                      INTO l_id_rehab_area
                      FROM dual;
                
                    g_error := 'GET ALERT INTERVENTION ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
                    SELECT nvl((SELECT i.id_intervention
                                 FROM intervention i
                                WHERE i.id_content = l_interv_id_content
                                  AND i.id_content IS NOT NULL
                                  AND i.flg_status = g_active
                                  AND rownum = 1),
                               0)
                      INTO l_id_intervention
                      FROM dual;
                
                    IF l_id_rehab_ss_type != 'Not Found'
                       AND l_id_rehab_area != 0
                       AND l_id_intervention != 0
                    THEN
                    
                        g_error := 'GET ALERT REHAB_AREA_INTERV ID';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
                        SELECT nvl((SELECT rai.id_rehab_area_interv
                                     FROM rehab_area_interv rai
                                    WHERE rai.id_rehab_area = l_id_rehab_area
                                      AND rai.id_intervention = l_id_intervention
                                      AND rownum = 1),
                                   0)
                          INTO l_id_rai
                          FROM dual;
                    
                        IF l_id_rai != 0
                        THEN
                        
                            g_error := 'COUNT';
                            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
                            SELECT COUNT(ris.id_rehab_inst_soft)
                              INTO l_count
                              FROM rehab_inst_soft ris
                             WHERE ris.id_rehab_area_interv = l_id_rai
                               AND ris.id_institution = i_id_institution
                               AND ris.id_software = i_id_software;
                        
                            IF l_count = 0
                            THEN
                                l_id_rehab_area_interv_array.extend;
                                l_id_rehab_sst_array.extend;
                                l_flg_execute_array.extend;
                                l_flg_add_remove_array.extend;
                            
                                l_id_rehab_area_interv_array(l_index) := l_id_rai;
                                l_id_rehab_sst_array(l_index) := l_id_rehab_ss_type;
                                l_flg_execute_array(l_index) := l_flg_execute;
                                l_flg_add_remove_array(l_index) := l_flg_add_remove;
                            
                                l_index := l_index + 1;
                            END IF;
                        END IF;
                    END IF;
                END LOOP;
            
                g_error := 'CLOSE C_REHAB_INST_SOFT CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
                CLOSE c_rehab_inst_soft;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_ID_REHAB_AREA_INTERV CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
        OPEN o_id_rehab_area_interv FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_rehab_area_interv_array AS table_number));
    
        g_error := 'CLOSE O_ID_REHAB_SESSION_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
        OPEN o_id_rehab_ss_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_rehab_sst_array AS table_varchar));
    
        g_error := 'CLOSE O_FLG_EXECUTE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
        OPEN o_flg_execute FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_execute_array AS table_varchar));
    
        g_error := 'CLOSE O_FLG_ADD_REMOVE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_INST_SOFT ' || g_error);
        OPEN o_flg_add_remove FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_add_remove_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_REHAB_INST_SOFT',
                                              o_error);
            pk_types.open_my_cursor(o_id_rehab_area_interv);
            pk_types.open_my_cursor(o_id_rehab_ss_type);
            pk_types.open_my_cursor(o_flg_execute);
            pk_types.open_my_cursor(o_flg_add_remove);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_rehab_inst_soft;
    /*********************************************************************************************
    * Set REHAB_AREA_INST_SOFT Value for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param i_software                Software ID
    * @param o_rehab_inst_soft         Cursor of REHAB_INST_SOFT
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6.0.3.3
    * @since                           2010/09/24
    ********************************************************************************************/
    FUNCTION set_inst_rehab_inst_soft
    (
        i_lang            IN language.id_language%TYPE,
        i_market          IN table_number,
        i_version         IN table_varchar,
        i_id_institution  IN institution.id_institution%TYPE,
        i_software        IN table_number,
        o_rehab_inst_soft OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_rehab_area_interv pk_types.cursor_type;
        l_c_id_rehab_ss_type     pk_types.cursor_type;
        l_c_flg_execute          pk_types.cursor_type;
        l_c_flg_add_remove       pk_types.cursor_type;
    
        l_data_id_rehab_area_interv table_number;
        l_data_id_rehab_ss_type     table_varchar;
        l_data_flg_execute          table_varchar;
        l_data_flg_add_remove       table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
        --Execute all the Checklist relations
        l_c_rehab_st_freq pk_types.cursor_type;
    
    BEGIN
        FOR i IN 1 .. i_software.count
        LOOP
        
            g_error := 'IF NOT GET_INST_REHAB_INST_SOFT';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_INST_SOFT ' || g_error);
        
            IF NOT get_inst_rehab_inst_soft(i_lang,
                                            i_market,
                                            i_version,
                                            i_id_institution,
                                            i_software(i),
                                            l_c_id_rehab_area_interv,
                                            l_c_id_rehab_ss_type,
                                            l_c_flg_execute,
                                            l_c_flg_add_remove,
                                            o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_rehab_inst_soft := l_c_id_rehab_area_interv';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_INST_SOFT ' || g_error);
                o_rehab_inst_soft := l_c_id_rehab_area_interv;
            
                LOOP
                
                    FETCH l_c_id_rehab_area_interv BULK COLLECT
                        INTO l_data_id_rehab_area_interv LIMIT g_array_size;
                    FETCH l_c_id_rehab_ss_type BULK COLLECT
                        INTO l_data_id_rehab_ss_type LIMIT g_array_size;
                    FETCH l_c_flg_execute BULK COLLECT
                        INTO l_data_flg_execute LIMIT g_array_size;
                    FETCH l_c_flg_add_remove BULK COLLECT
                        INTO l_data_flg_add_remove LIMIT g_array_size;
                
                    FORALL j IN 1 .. l_data_id_rehab_area_interv.count
                    
                        INSERT INTO rehab_inst_soft
                            (id_rehab_area_interv,
                             id_rehab_inst_soft,
                             id_institution,
                             id_software,
                             id_rehab_session_type,
                             flg_execute,
                             flg_add_remove)
                        VALUES
                            (l_data_id_rehab_area_interv(j),
                             seq_rehab_inst_soft.nextval,
                             i_id_institution,
                             i_software(i),
                             l_data_id_rehab_ss_type(j),
                             l_data_flg_execute(j),
                             l_data_flg_add_remove(j));
                    EXIT WHEN l_c_id_rehab_area_interv%NOTFOUND;
                
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_REHAB_AREA_INTERV CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_INST_SOFT ' || g_error);
                CLOSE l_c_id_rehab_area_interv;
            
                g_error := 'CLOSE L_C_ID_REHAB_SESSION_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_INST_SOFT ' || g_error);
                CLOSE l_c_id_rehab_ss_type;
            
                g_error := 'CLOSE L_C_FLG_EXECUTE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_INST_SOFT ' || g_error);
                CLOSE l_c_flg_execute;
            
                g_error := 'CLOSE L_C_FLG_ADD_REMOVE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_INST_SOFT ' || g_error);
                CLOSE l_c_flg_add_remove;
            
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_REHAB_INST_SOFT',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_REHAB_INST_SOFT',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_rehab_inst_soft;
    /********************************************************************************************
    * Get REHAB_AREA_INST set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_id_institution      Institution ID
    * @param i_id_rehab_content    ID_CONTENT
    * @param o_id_rehab_area       Cursor of Rehab_Area
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.3.3
    * @since                       2010/11/25
    ********************************************************************************************/
    FUNCTION get_inst_rehab_area_inst
    (
        i_lang             IN language.id_language%TYPE,
        i_id_institution   IN institution.id_institution%TYPE,
        i_id_ra_rehab_area IN rehab_area.id_rehab_area%TYPE,
        o_id_rehab_area    OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --REHAB_AREA
        l_id_rehab_area_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
    BEGIN
    
        g_error := 'COUNT_INSTIT';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INST ' || g_error);
    
        SELECT COUNT(rai.id_rehab_area_inst)
          INTO l_count
          FROM rehab_area_inst rai
         WHERE rai.id_rehab_area = i_id_ra_rehab_area
           AND rai.id_institution = i_id_institution;
    
        IF l_count = 0
        THEN
            l_id_rehab_area_array.extend;
        
            l_id_rehab_area_array(l_index) := i_id_ra_rehab_area;
        
        END IF;
    
        g_error := 'CLOSE O_ID_REHAB_AREA CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_REHAB_AREA_INST ' || g_error);
        OPEN o_id_rehab_area FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_rehab_area_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_REHAB_AREA_INST',
                                              o_error);
            pk_types.open_my_cursor(o_id_rehab_area);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_rehab_area_inst;
    /********************************************************************************************
    * Set REHAB_AREA_INST set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_id_institution      Institution ID
    * @param i_id_rehab_content    ID_CONTENT
    * @param o_id_rehab_area       Cursor of Rehab_Area
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.3.3
    * @since                       2010/11/25
    ********************************************************************************************/
    FUNCTION set_inst_rehab_area_inst
    (
        i_lang             IN language.id_language%TYPE,
        i_id_institution   IN institution.id_institution%TYPE,
        i_id_ra_rehab_area IN rehab_area.id_rehab_area%TYPE,
        o_rehab_area_inst  OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_rehab_area pk_types.cursor_type;
    
        l_data_id_rehab_area table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        g_error := 'IF NOT GET_INST_REHAB_AREA_INST';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_AREA_INST ' || g_error);
    
        IF NOT get_inst_rehab_area_inst(i_lang, i_id_institution, i_id_ra_rehab_area, l_c_id_rehab_area, o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error := 'o_rehab_area_inst := l_c_id_rehab_area';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_AREA_INST ' || g_error);
            o_rehab_area_inst := l_c_id_rehab_area;
        
            LOOP
                FETCH l_c_id_rehab_area BULK COLLECT
                    INTO l_data_id_rehab_area LIMIT g_array_size;
            
                g_error := 'INSERT WITH FORALL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_AREA_INST ' || g_error);
                FORALL j IN 1 .. l_data_id_rehab_area.count
                
                    INSERT INTO rehab_area_inst
                        (id_rehab_area_inst, id_rehab_area, id_institution, flg_add_remove)
                    VALUES
                        (seq_rehab_area_inst.nextval, l_data_id_rehab_area(j), i_id_institution, 'A');
            
                EXIT WHEN l_c_id_rehab_area%NOTFOUND;
            
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_REHAB_AREA CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_REHAB_AREA_INST ' || g_error);
            CLOSE l_c_id_rehab_area;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_REHAB_AREA_INST',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_REHAB_AREA_INST',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_rehab_area_inst;
    /*********************************************************************************************
    * Set HIDRICS CHARACTERISTICS Value for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param o_hidrics_charact         Cursor of Instituition HIDRICS CHARACTERISTICS
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6
    * @since                           2010/07/12
    ********************************************************************************************/
    FUNCTION set_def_hidrics_charact
    (
        i_lang            IN language.id_language%TYPE,
        i_id_market       IN market.id_market%TYPE,
        i_id_institution  IN institution.id_institution%TYPE,
        o_hidrics_charact OUT table_number,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_hdrcs_charact_def hidrics_charact.id_hidrics_charact%TYPE;
        l_c_id_hdrcs_charact     hidrics_charact.id_hidrics_charact%TYPE;
        l_c_code                 hidrics_charact.code%TYPE;
        l_c_id_content           hidrics_charact.id_content%TYPE;
    
        --TRANSLATION
        l_id_lang                   language.id_language%TYPE;
        l_hdrcs_charact_translation pk_translation.t_desc_translation;
    
        l_index    NUMBER := 1;
        dml_errors EXCEPTION;
    
        --Execute all the Checklist relations
        l_c_hdrcs_charact_rel table_number := table_number();
        l_error               t_error_out;
        l_exception           EXCEPTION;
    
        CURSOR c_hdrcs_charact IS
            SELECT DISTINCT hc.id_hidrics_charact, hc.code, hc.id_content
              FROM alert_default.hidrics_charact hc
             WHERE hc.flg_available = g_flg_available;
    
    BEGIN
    
        o_hidrics_charact := table_number();
    
        g_error := 'OPEN C_HDRCS_CHARACT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
        OPEN c_hdrcs_charact;
        LOOP
            FETCH c_hdrcs_charact
                INTO l_c_id_hdrcs_charact_def, l_c_code, l_c_id_content;
            EXIT WHEN c_hdrcs_charact%NOTFOUND;
        
            g_error := 'GET ALERT HIDRICS_CHARACT ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
            SELECT nvl((SELECT hc.id_hidrics_charact
                         FROM hidrics_charact hc
                        WHERE hc.id_content = l_c_id_content
                          AND hc.id_content IS NOT NULL
                          AND hc.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_c_id_hdrcs_charact
              FROM dual;
        
            IF l_c_id_hdrcs_charact = 0
            THEN
                g_error := 'GET SEQ_HIDRICS_CHARACT.NEXTVAL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
                SELECT seq_hidrics_charact.nextval
                  INTO l_c_id_hdrcs_charact
                  FROM dual;
            
                g_error := 'INSERT INTO HIDRICS_CHARACT';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
                INSERT INTO hidrics_charact
                    (id_hidrics_charact, code_hidrics_charact, code, flg_available, id_content)
                VALUES
                    (l_c_id_hdrcs_charact,
                     'HIDRICS_CHARACT.CODE_HIDRICS_CHARACT.' || l_c_id_hdrcs_charact,
                     l_c_code,
                     g_flg_available,
                     l_c_id_content);
            
            END IF;
        
            o_hidrics_charact.extend;
            o_hidrics_charact(l_index) := l_c_id_hdrcs_charact;
            l_index := l_index + 1;
        
            -->Insere as Hidrics_Charact_Relations
            g_error := 'SET_INST_CHARACT_REL';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
            IF NOT set_inst_hidrics_charact_rel(i_lang,
                                                i_id_market,
                                                i_id_institution,
                                                l_c_id_hdrcs_charact_def,
                                                l_c_id_hdrcs_charact,
                                                l_c_hdrcs_charact_rel,
                                                l_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END LOOP;
    
        g_error := 'CLOSE C_HDRCS_CHARACT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
        CLOSE c_hdrcs_charact;
    
        -- 16/03/2011 RMGM: changed way how translations are loaded
        g_table_name := upper('hidrics_charact');
        g_error      := 'SET DEF TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_DEF_HIDRICS_CHARACT',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_def_hidrics_charact;
    /********************************************************************************************
    * Set Hidrics_Charact_Rel set 
    *
    * @param i_lang                   Prefered language ID
    * @param i_id_hdrcs_charact_def   Hidrics_Charact Default ID's
    * @param i_id_hdrcs_charact       Hidrics_Charact Alert ID's
    * @param o_hidrics_charact_rel    Cursor of Hidrics_Charact_Rel
    * @param o_error                  Error
    *    
    * @return                         true or false on success or error
    *
    * @author                         MESS
    * @version                        2.6
    * @since                          2010/07/13
    ********************************************************************************************/
    FUNCTION set_inst_hidrics_charact_rel
    (
        i_lang                 IN language.id_language%TYPE,
        i_id_market            IN market.id_market%TYPE,
        i_id_institution       IN institution.id_institution%TYPE,
        i_id_hdrcs_charact_def IN hidrics_charact.id_hidrics_charact%TYPE,
        i_id_hdrcs_charact     IN hidrics_charact.id_hidrics_charact%TYPE,
        o_hidrics_charact_rel  OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --HIDRICS_CHARACT_REL
        l_hidrics_charact_def hidrics_charact_rel.id_hidrics_charact%TYPE;
        l_hidrics_def         hidrics_charact_rel.id_hidrics%TYPE;
        l_hidrics             hidrics_charact_rel.id_hidrics%TYPE;
        l_rank                hidrics_charact_rel.rank%TYPE;
        l_way_def             hidrics_charact_rel.id_way%TYPE;
        l_way                 hidrics_charact_rel.id_way%TYPE;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_hdrcs_charact_rel
        (
            c_id_hdrcs_charact_def IN NUMBER,
            c_id_market            IN NUMBER
        ) IS
            SELECT DISTINCT hcr.id_hidrics, hcr.id_hidrics_charact, hcr.rank, hcr.id_way
              FROM alert_default.hidrics_charact_rel hcr
             WHERE hcr.flg_available = g_flg_available
               AND hcr.id_hidrics_charact = c_id_hdrcs_charact_def
               AND hcr.id_market = c_id_market;
    
    BEGIN
    
        o_hidrics_charact_rel := table_number();
    
        g_error := 'OPEN C_HDRCS_CHARACT_REL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CHARACT_REL ' || g_error);
        OPEN c_hdrcs_charact_rel(i_id_hdrcs_charact_def, i_id_market);
        LOOP
            FETCH c_hdrcs_charact_rel
                INTO l_hidrics_def, l_hidrics_charact_def, l_rank, l_way_def;
            EXIT WHEN c_hdrcs_charact_rel%NOTFOUND;
        
            g_error := 'GET ALERT HIDRICS ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
            SELECT nvl((SELECT h.id_hidrics
                         FROM hidrics h
                        WHERE h.id_content = (SELECT h1.id_content
                                                FROM alert_default.hidrics h1
                                               WHERE h1.id_hidrics = l_hidrics_def
                                                 AND h1.flg_available = g_flg_available)
                          AND h.id_content IS NOT NULL
                          AND h.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_hidrics
              FROM dual;
            g_error := 'GET ALERT WAY ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
            SELECT nvl((SELECT w.id_way
                         FROM way w
                        WHERE w.id_content = (SELECT w1.id_content
                                                FROM alert_default.way w1
                                               WHERE w1.id_way = l_way_def
                                                 AND w1.flg_available = g_flg_available)
                          AND w.id_content IS NOT NULL
                          AND w.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_way
              FROM dual;
        
            IF (l_hidrics != 0 AND l_way != 0)
            THEN
                g_error := 'COUNT HIDRICS_CHARACT_REL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CHARACT_REL ' || g_error);
                SELECT COUNT(hcr.id_hidrics_charact)
                  INTO l_count
                  FROM hidrics_charact_rel hcr
                 WHERE hcr.id_hidrics_charact = i_id_hdrcs_charact
                   AND hcr.id_hidrics = l_hidrics
                   AND hcr.id_department = 0
                   AND hcr.id_dept = 0
                   AND hcr.id_institution = i_id_institution
                   AND hcr.id_market = i_id_market
                   AND hcr.id_way = l_way;
            
                IF l_count = 0
                THEN
                
                    SELECT COUNT(hcr.id_hidrics_charact)
                      INTO l_count
                      FROM hidrics_charact_rel hcr
                     WHERE hcr.id_hidrics_charact = i_id_hdrcs_charact
                       AND hcr.id_hidrics = l_hidrics
                       AND hcr.id_department = 0
                       AND hcr.id_dept = 0
                       AND hcr.id_institution = 0
                       AND hcr.id_market = i_id_market
                       AND hcr.id_way = l_way;
                
                    IF l_count = 0
                    THEN
                    
                        g_error := 'INSERT INTO HIDRICS_CHARACT_REL';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CHARACT_REL ' || g_error);
                        INSERT INTO hidrics_charact_rel
                            (id_hidrics,
                             id_hidrics_charact,
                             rank,
                             flg_available,
                             id_department,
                             id_dept,
                             id_institution,
                             id_market,
                             id_way)
                        VALUES
                            (l_hidrics,
                             i_id_hdrcs_charact,
                             l_rank,
                             g_flg_available,
                             0,
                             0,
                             i_id_institution,
                             i_id_market,
                             l_way);
                    
                    END IF;
                END IF;
                o_hidrics_charact_rel.extend;
                o_hidrics_charact_rel(l_index) := i_id_hdrcs_charact;
                l_index := l_index + 1;
            
            END IF;
        
        END LOOP;
    
        g_error := 'CLOSE C_HDRCS_CHARACT_REL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CHARACT_REL ' || g_error);
        CLOSE c_hdrcs_charact_rel;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS_CHARACT_REL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_hidrics_charact_rel;
    /*********************************************************************************************
    * Set HIDRICS WAY Value for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param o_hidrics_way             Cursor of Instituition HIDRICS WAY
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          MESS
    * @version                         2.6
    * @since                           2010/07/13
    ********************************************************************************************/
    FUNCTION set_def_hidrics_way
    (
        i_lang           IN language.id_language%TYPE,
        i_id_market      IN market.id_market%TYPE,
        i_id_institution IN institution.id_institution%TYPE,
        o_hidrics_way    OUT table_number,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_hdrcs_way_def way.id_way%TYPE;
        l_c_id_hdrcs_way     way.id_way%TYPE;
        l_c_code             way.code%TYPE;
        l_c_id_content       way.id_content%TYPE;
        l_c_flg_type         way.flg_type%TYPE;
        -- 22/02/2011 RMGM: add new field to table way
        l_c_flg_way_type way.flg_way_type%TYPE;
    
        --TRANSLATION
        dml_errors EXCEPTION;
    
        l_index NUMBER := 1;
    
        --Execute all the Checklist relations
        l_c_hdrcs_way_rel table_number := table_number();
        l_c_hdrcs_loc_rel table_number := table_number();
        l_error           t_error_out;
        l_exception       EXCEPTION;
    
        CURSOR c_hdrcs_way IS
            SELECT DISTINCT wa.id_way, wa.code, wa.id_content, wa.flg_type, wa.flg_way_type
              FROM alert_default.way wa
             WHERE wa.flg_available = g_flg_available;
    BEGIN
    
        o_hidrics_way := table_number();
    
        g_error := 'OPEN C_HDRCS_WAY CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_WAY ' || g_error);
        OPEN c_hdrcs_way;
        LOOP
            FETCH c_hdrcs_way
                INTO l_c_id_hdrcs_way_def, l_c_code, l_c_id_content, l_c_flg_type, l_c_flg_way_type;
            EXIT WHEN c_hdrcs_way%NOTFOUND;
        
            g_error := 'GET ALERT HIDRICS_WAY ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_WAY ' || g_error);
            SELECT nvl((SELECT wa.id_way
                         FROM way wa
                        WHERE wa.id_content = l_c_id_content
                          AND wa.id_content IS NOT NULL
                          AND wa.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_c_id_hdrcs_way
              FROM dual;
        
            IF l_c_id_hdrcs_way = 0
            THEN
                g_error := 'GET SEQ_HIDRICS_WAY.NEXTVAL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_WAY ' || g_error);
                SELECT seq_way.nextval
                  INTO l_c_id_hdrcs_way
                  FROM dual;
            
                g_error := 'INSERT INTO HIDRICS_WAY';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_WAY ' || g_error);
                INSERT INTO way
                    (id_way, code_way, code, flg_available, id_content, flg_type, flg_way_type)
                VALUES
                    (l_c_id_hdrcs_way,
                     'WAY.CODE_WAY.' || l_c_id_hdrcs_way,
                     l_c_code,
                     g_flg_available,
                     l_c_id_content,
                     l_c_flg_type,
                     l_c_flg_way_type);
            
            END IF;
        
            o_hidrics_way.extend;
            o_hidrics_way(l_index) := l_c_id_hdrcs_way;
            l_index := l_index + 1;
        
            -->Insere as Hidrics_Way_Relations
            g_error := 'SET_INST_HIDRICS_WAY_REL';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
            IF NOT set_inst_hidrics_way_rel(i_lang,
                                            i_id_market,
                                            i_id_institution,
                                            l_c_id_hdrcs_way_def,
                                            l_c_id_hdrcs_way,
                                            l_c_hdrcs_way_rel,
                                            l_error)
            THEN
                RAISE l_exception;
            END IF;
            -->Insere as Hidrics_Loc_Relations
            g_error := 'SET_INST_HIDRICS_LOC_REL';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_CHARACT ' || g_error);
            IF NOT set_inst_hidrics_loc_rel(i_lang,
                                            i_id_market,
                                            i_id_institution,
                                            l_c_id_hdrcs_way_def,
                                            l_c_id_hdrcs_way,
                                            l_c_hdrcs_loc_rel,
                                            l_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END LOOP;
    
        g_error := 'CLOSE C_HDRCS_WAY CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_DEF_HIDRICS_WAY ' || g_error);
        CLOSE c_hdrcs_way;
    
        -- 16/03/2011 RMGM: changed way how translations are loaded
        g_table_name := upper('way');
        g_error      := 'SET DEF TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_DEF_HIDRICS_WAY',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_def_hidrics_way;
    /********************************************************************************************
    * Set Hidrics_Way_Rel set 
    *
    * @param i_lang                   Prefered language ID
    * @param i_id_hdrcs_way_def       Hidrics_Way Default ID's
    * @param i_id_hdrcs_way           Hidrics_Way Alert ID's
    * @param o_hidrics_way_rel        Cursor of Hidrics_Way_Rel
    * @param o_error                  Error
    *    
    * @return                         true or false on success or error
    *
    * @author                         MESS
    * @version                        2.6
    * @since                          2010/07/13
    ********************************************************************************************/
    FUNCTION set_inst_hidrics_way_rel
    (
        i_lang             IN language.id_language%TYPE,
        i_id_market        IN market.id_market%TYPE,
        i_id_institution   IN institution.id_institution%TYPE,
        i_id_hdrcs_way_def IN way.id_way%TYPE,
        i_id_hdrcs_way     IN way.id_way%TYPE,
        o_hidrics_way_rel  OUT table_number,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --HIDRICS_WAY_REL
        l_hidrics_way_def  hidrics_way_rel.id_way%TYPE;
        l_hidrics_def      hidrics_way_rel.id_hidrics%TYPE;
        l_hidrics          hidrics_way_rel.id_hidrics%TYPE;
        l_hidrics_type_def hidrics_way_rel.id_hidrics_type%TYPE;
        l_hidrics_type     hidrics_way_rel.id_hidrics_type%TYPE;
        l_rank             hidrics_way_rel.rank%TYPE;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_hdrcs_way_rel
        (
            c_id_hdrcs_way_def IN NUMBER,
            c_id_market        IN NUMBER
        ) IS
            SELECT DISTINCT hwr.id_way, hwr.id_hidrics, hwr.id_hidrics_type, hwr.rank
              FROM alert_default.hidrics_way_rel hwr
             WHERE hwr.flg_available = g_flg_available
               AND hwr.id_way = c_id_hdrcs_way_def
               AND hwr.id_market = c_id_market;
    
    BEGIN
    
        o_hidrics_way_rel := table_number();
    
        g_error := 'OPEN C_HDRCS_WAY_REL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_WAY_REL ' || g_error);
        OPEN c_hdrcs_way_rel(i_id_hdrcs_way_def, i_id_market);
        LOOP
            FETCH c_hdrcs_way_rel
                INTO l_hidrics_way_def, l_hidrics_def, l_hidrics_type_def, l_rank;
            EXIT WHEN c_hdrcs_way_rel%NOTFOUND;
        
            g_error := 'GET ALERT HIDRICS ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_WAY_REL ' || g_error);
            SELECT nvl((SELECT h.id_hidrics
                         FROM hidrics h
                        WHERE h.id_content = (SELECT h1.id_content
                                                FROM alert_default.hidrics h1
                                               WHERE h1.id_hidrics = l_hidrics_def
                                                 AND h1.flg_available = g_flg_available)
                          AND h.id_content IS NOT NULL
                          AND h.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_hidrics
              FROM dual;
        
            g_error := 'GET ALERT HIDRICS_TYPE ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_WAY_REL ' || g_error);
            SELECT nvl((SELECT ht.id_hidrics_type
                         FROM hidrics_type ht
                        WHERE ht.id_content = (SELECT t.id_content
                                                 FROM alert_default.hidrics_type t
                                                WHERE t.id_hidrics_type = l_hidrics_type_def
                                                  AND t.flg_available = 'Y')
                          AND ht.id_content IS NOT NULL
                          AND ht.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_hidrics_type
              FROM dual;
        
            IF l_hidrics != 0
               AND l_hidrics_type != 0
            THEN
                g_error := 'COUNT HIDRICS_WAY_REL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_WAY_REL ' || g_error);
                SELECT COUNT(hwr.id_way)
                  INTO l_count
                  FROM hidrics_way_rel hwr
                 WHERE hwr.id_way = i_id_hdrcs_way
                   AND hwr.id_hidrics = l_hidrics
                   AND hwr.id_hidrics_type = l_hidrics_type
                   AND hwr.id_department = 0
                   AND hwr.id_dept = 0
                   AND hwr.id_institution = i_id_institution
                   AND hwr.id_market = i_id_market;
            
                IF l_count = 0
                THEN
                    SELECT COUNT(hwr.id_way)
                      INTO l_count
                      FROM hidrics_way_rel hwr
                     WHERE hwr.id_way = i_id_hdrcs_way
                       AND hwr.id_hidrics = l_hidrics
                       AND hwr.id_hidrics_type = l_hidrics_type
                       AND hwr.id_department = 0
                       AND hwr.id_dept = 0
                       AND hwr.id_institution = 0
                       AND hwr.id_market = i_id_market;
                
                    IF l_count = 0
                    THEN
                        g_error := 'INSERT INTO HIDRICS_WAY_REL';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_WAY_REL ' || g_error);
                        INSERT INTO hidrics_way_rel
                            (id_way,
                             id_hidrics_type,
                             id_hidrics,
                             rank,
                             flg_available,
                             id_department,
                             id_dept,
                             id_institution,
                             id_market)
                        VALUES
                            (i_id_hdrcs_way,
                             l_hidrics_type,
                             l_hidrics,
                             l_rank,
                             g_flg_available,
                             0,
                             0,
                             i_id_institution,
                             i_id_market);
                    END IF;
                END IF;
            
                o_hidrics_way_rel.extend;
                o_hidrics_way_rel(l_index) := i_id_hdrcs_way;
                l_index := l_index + 1;
            
            END IF;
        
        END LOOP;
    
        g_error := 'CLOSE C_HDRCS_WAY_REL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_WAY_REL ' || g_error);
        CLOSE c_hdrcs_way_rel;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS_WAY_REL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_hidrics_way_rel;
    /********************************************************************************************
    * Set Hidrics_Location_Rel set 
    *
    * @param i_lang                   Prefered language ID
    * @param i_id_hdrcs_way_def       Hidrics_Way Default ID's
    * @param i_id_hdrcs_way           Hidrics_Way Alert ID's
    * @param o_hidrics_loc_rel        Cursor of Hidrics_Location_Rel
    * @param o_error                  Error
    *    
    * @return                         true or false on success or error
    *
    * @author                         MESS
    * @version                        2.6
    * @since                          2010/07/13
    ********************************************************************************************/
    FUNCTION set_inst_hidrics_loc_rel
    (
        i_lang             IN language.id_language%TYPE,
        i_id_market        IN market.id_market%TYPE,
        i_id_institution   IN institution.id_institution%TYPE,
        i_id_hdrcs_way_def IN way.id_way%TYPE,
        i_id_hdrcs_way     IN way.id_way%TYPE,
        o_hidrics_loc_rel  OUT table_number,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --HIDRICS_LOCATION_REL
        l_hidrics_way_def hidrics_location_rel.id_way%TYPE;
        l_hidrics_def     hidrics_location_rel.id_hidrics%TYPE;
        l_hidrics         hidrics_location_rel.id_hidrics%TYPE;
        l_hidrics_loc_def hidrics_location_rel.id_hidrics_location%TYPE;
        l_hidrics_loc     hidrics_location_rel.id_hidrics_location%TYPE;
        l_rank            hidrics_location_rel.rank%TYPE;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_hdrcs_loc_rel
        (
            c_id_hdrcs_way_def IN NUMBER,
            c_id_market        IN NUMBER
        ) IS
            SELECT DISTINCT hlr.id_way, hlr.id_hidrics, hlr.id_hidrics_location, hlr.rank
              FROM alert_default.hidrics_location_rel hlr
             WHERE hlr.flg_available = g_flg_available
               AND hlr.id_way = c_id_hdrcs_way_def
               AND hlr.id_market = c_id_market;
    
    BEGIN
    
        o_hidrics_loc_rel := table_number();
    
        g_error := 'OPEN C_HDRCS_LOC_REL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_LOC_REL ' || g_error);
        OPEN c_hdrcs_loc_rel(i_id_hdrcs_way_def, i_id_market);
        LOOP
            FETCH c_hdrcs_loc_rel
                INTO l_hidrics_way_def, l_hidrics_def, l_hidrics_loc_def, l_rank;
            EXIT WHEN c_hdrcs_loc_rel%NOTFOUND;
        
            g_error := 'GET ALERT HIDRICS ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_LOC_REL ' || g_error);
            SELECT nvl((SELECT h.id_hidrics
                         FROM hidrics h
                        WHERE h.id_content = (SELECT h1.id_content
                                                FROM alert_default.hidrics h1
                                               WHERE h1.id_hidrics = l_hidrics_def
                                                 AND h1.flg_available = g_flg_available)
                          AND h.id_content IS NOT NULL
                          AND h.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_hidrics
              FROM dual;
        
            g_error := 'GET ALERT HIDRICS_LOCATION ID';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_LOC_REL ' || g_error);
            SELECT nvl((SELECT hl.id_hidrics_location
                         FROM hidrics_location hl
                        WHERE (hl.id_body_part = (SELECT t.id_body_part
                                                    FROM alert_default.hidrics_location t
                                                   WHERE t.id_hidrics_location = l_hidrics_loc_def
                                                     AND t.flg_available = 'Y') OR
                              (hl.id_body_part IS NULL AND
                              (SELECT t.id_body_part
                                   FROM alert_default.hidrics_location t
                                  WHERE t.id_hidrics_location = l_hidrics_loc_def
                                    AND t.flg_available = 'Y') IS NULL))
                          AND (hl.id_body_side = (SELECT t.id_body_side
                                                    FROM alert_default.hidrics_location t
                                                   WHERE t.id_hidrics_location = l_hidrics_loc_def
                                                     AND t.flg_available = 'Y') OR
                              (hl.id_body_side IS NULL AND
                              (SELECT t.id_body_side
                                   FROM alert_default.hidrics_location t
                                  WHERE t.id_hidrics_location = l_hidrics_loc_def
                                    AND t.flg_available = 'Y') IS NULL))
                          AND hl.flg_available = g_flg_available
                          AND rownum = 1),
                       0)
              INTO l_hidrics_loc
              FROM dual;
        
            IF l_hidrics != 0
               AND l_hidrics_loc != 0
            THEN
                g_error := 'COUNT HIDRICS_LOC_REL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_LOC_REL ' || g_error);
                SELECT COUNT(hlr.id_way)
                  INTO l_count
                  FROM hidrics_location_rel hlr
                 WHERE hlr.id_way = i_id_hdrcs_way
                   AND hlr.id_hidrics = l_hidrics
                   AND hlr.id_hidrics_location = l_hidrics_loc
                   AND hlr.id_department = 0
                   AND hlr.id_dept = 0
                   AND hlr.id_institution = i_id_institution
                   AND hlr.id_market = i_id_market;
            
                IF l_count = 0
                THEN
                
                    SELECT COUNT(hlr.id_way)
                      INTO l_count
                      FROM hidrics_location_rel hlr
                     WHERE hlr.id_way = i_id_hdrcs_way
                       AND hlr.id_hidrics = l_hidrics
                       AND hlr.id_hidrics_location = l_hidrics_loc
                       AND hlr.id_department = 0
                       AND hlr.id_dept = 0
                       AND hlr.id_institution = 0
                       AND hlr.id_market = i_id_market;
                
                    IF l_count = 0
                    THEN
                        g_error := 'INSERT INTO HIDRICS_LOC_REL';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_LOC_REL ' || g_error);
                        INSERT INTO hidrics_location_rel
                            (id_hidrics_location,
                             id_way,
                             id_hidrics,
                             rank,
                             flg_available,
                             id_department,
                             id_dept,
                             id_institution,
                             id_market)
                        VALUES
                            (l_hidrics_loc,
                             i_id_hdrcs_way,
                             l_hidrics,
                             l_rank,
                             g_flg_available,
                             0,
                             0,
                             i_id_institution,
                             i_id_market);
                    END IF;
                END IF;
            
                o_hidrics_loc_rel.extend;
                o_hidrics_loc_rel(l_index) := l_hidrics_loc;
                l_index := l_index + 1;
            
            END IF;
        
        END LOOP;
    
        g_error := 'CLOSE C_HDRCS_LOC_REL CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_LOC_REL ' || g_error);
        CLOSE c_hdrcs_loc_rel;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS_LOC_REL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_hidrics_loc_rel;
    /********************************************************************************************
    * Set Hidrics_Configuration 
    *
    * @param i_lang                   Prefered language ID
    * @param o_hidrics_confs          Cursor of Hidrics_Location_Rel
    * @param o_error                  Error
    *    
    * @return                         true or false on success or error
    *
    * @author                         MESS
    * @version                        2.6
    * @since                          2010/07/13
    ********************************************************************************************/
    FUNCTION set_inst_hidrics_configuration
    (
        i_lang           IN language.id_language%TYPE,
        i_id_market      IN market.id_market%TYPE,
        i_id_institution IN institution.id_institution%TYPE,
        o_hidrics_confs  OUT table_number,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --HIDRICS_CONFIGURATION
        l_hidrics_confs_def hidrics_configurations.id_hidrics_configurations%TYPE;
        l_hidrics_confs     hidrics_configurations.id_hidrics_configurations%TYPE;
        l_hidrics_interval  hidrics_configurations.id_hidrics_interval%TYPE;
        l_dt_next_balance   hidrics_configurations.dt_def_next_balance%TYPE;
        l_almost_max_int    hidrics_configurations.almost_max_int%TYPE;
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_hdrcs_confs(c_market IN NUMBER) IS
            SELECT DISTINCT hc.id_hidrics_configurations,
                            hc.id_hidrics_interval,
                            hc.dt_def_next_balance,
                            hc.almost_max_int
              FROM alert_default.hidrics_configurations hc
             WHERE hc.id_market = c_market;
    
    BEGIN
    
        o_hidrics_confs := table_number();
    
        g_error := 'OPEN C_HDRCS_CONFS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CONFIGURATION ' || g_error);
        OPEN c_hdrcs_confs(i_id_market);
        LOOP
            FETCH c_hdrcs_confs
                INTO l_hidrics_confs_def, l_hidrics_interval, l_dt_next_balance, l_almost_max_int;
            EXIT WHEN c_hdrcs_confs%NOTFOUND;
        
            g_error := 'COUNT HIDRICS_CONFIGURATION';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CONFIGURATION ' || g_error);
            SELECT COUNT(hc.id_hidrics_configurations)
              INTO l_count
              FROM hidrics_configurations hc
             WHERE hc.id_hidrics_interval = l_hidrics_interval
               AND hc.id_department = 0
               AND hc.id_dept = 0
               AND hc.id_institution = i_id_institution
               AND hc.id_market = i_id_market;
        
            IF l_count = 0
            THEN
            
                SELECT COUNT(hc.id_hidrics_configurations)
                  INTO l_count
                  FROM hidrics_configurations hc
                 WHERE hc.id_hidrics_interval = l_hidrics_interval
                   AND hc.id_department = 0
                   AND hc.id_dept = 0
                   AND hc.id_institution = 0
                   AND hc.id_market = i_id_market;
            
                IF l_count = 0
                THEN
                    g_error := 'GET SEQ_HIDRICS_CONFIGURATION.NEXTVAL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CONFIGURATION ' || g_error);
                    SELECT seq_hidrics_configurations.nextval
                      INTO l_hidrics_confs
                      FROM dual;
                
                    g_error := 'INSERT INTO SEQ_HIDRICS_CONFIGURATION';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CONFIGURATION ' || g_error);
                    INSERT INTO hidrics_configurations
                        (id_hidrics_configurations,
                         id_hidrics_interval,
                         id_institution,
                         id_department,
                         id_dept,
                         dt_def_next_balance,
                         almost_max_int,
                         id_market)
                    VALUES
                        (l_hidrics_confs,
                         l_hidrics_interval,
                         i_id_institution,
                         0,
                         0,
                         l_dt_next_balance,
                         l_almost_max_int,
                         i_id_market);
                END IF;
            END IF;
        
            o_hidrics_confs.extend;
            o_hidrics_confs(l_index) := l_hidrics_confs;
            l_index := l_index + 1;
        
        END LOOP;
    
        g_error := 'CLOSE C_HDRCS_CONFS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_CONFIGURATION ' || g_error);
        CLOSE c_hdrcs_confs;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS_CONFIGURATION',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_hidrics_configuration;
    /********************************************************************************************
    * Get EXAM_BODY_STRUCTURE configuration set of markets, versions
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param o_exam_body_structure Cursor of Configuration details
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.2
    * @since                       2012/05/31
    ********************************************************************************************/
    FUNCTION get_inst_exam_body_structure
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN table_number,
        i_version             IN table_varchar,
        o_exam_body_structure OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_func_name := upper('get_inst_exam_body_structure');
        g_error     := 'OPEN CONFIGURATION CURSOR' || g_func_name;
        OPEN o_exam_body_structure FOR
            SELECT def_data.id_exam, def_data.id_body_structure, def_data.flg_main_laterality
              FROM (SELECT temp_data.l_row,
                           temp_data.id_body_structure,
                           temp_data.id_exam,
                           temp_data.flg_main_laterality,
                           row_number() over(PARTITION BY temp_data.id_body_structure, temp_data.id_exam ORDER BY temp_data.l_row) records_count
                      FROM (SELECT ebs.rowid l_row,
                                   nvl((SELECT ext_bs.id_body_structure
                                         FROM body_structure ext_bs
                                        WHERE ext_bs.id_content = bs.id_content
                                          AND ext_bs.flg_available = 'Y'
                                          AND rownum = 1),
                                       0) id_body_structure,
                                   nvl((SELECT ext_e.id_exam
                                         FROM exam ext_e
                                        WHERE ext_e.id_content = e.id_content
                                          AND ext_e.flg_available = 'Y'
                                          AND rownum = 1),
                                       0) id_exam,
                                   ebs.flg_main_laterality
                              FROM alert_default.exam_body_structure ebs
                             INNER JOIN alert_default.body_structure bs
                                ON (bs.id_body_structure = ebs.id_body_structure AND bs.flg_available = 'Y')
                             INNER JOIN alert_default.body_structure_mrk_vrs bsmv
                                ON (bsmv.id_body_structure = bs.id_body_structure)
                             INNER JOIN alert_default.exam e
                                ON (e.id_exam = ebs.id_exam AND e.flg_available = 'Y')
                             INNER JOIN alert_default.exam_mrk_vrs emv
                                ON (emv.id_exam = e.id_exam AND emv.id_market = bsmv.id_market AND
                                   emv.version = bsmv.version)
                             WHERE bsmv.id_market IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                       column_value
                                                        FROM TABLE(CAST(i_market AS table_number)) p)
                               AND bsmv.version IN (SELECT /*+ opt_estimate(TABLE t rows = 1) */
                                                     column_value
                                                      FROM TABLE(CAST(i_version AS table_varchar)) t)) temp_data
                     WHERE temp_data.id_body_structure > 0
                       AND temp_data.id_exam > 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM exam_body_structure ext_ebs
                     WHERE ext_ebs.id_exam = def_data.id_exam
                       AND ext_ebs.id_body_structure = def_data.id_body_structure
                       AND ext_ebs.flg_available = 'Y');
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_exam_body_structure);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_exam_body_structure;
    /*********************************************************************************************
    * Set EXAM_BODY_STRUCTURE Value for a specific institution
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID's
    * @param i_version                 ALERT version's
    * @param i_id_institution          Institution ID
    * @param o_exam_body_structure     Cursor of EXAM_BODY_STRUCTURE
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          RMGM
    * @version                         0.3
    * @since                           2012/05/31
    ********************************************************************************************/
    FUNCTION set_inst_exam_body_structure
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN table_number,
        i_version             IN table_varchar,
        o_exam_body_structure OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_id_body_structure table_number;
        l_data_id_exam           table_number;
        l_data_flg_main          table_varchar;
    
        l_error t_error_out;
    
        -- auxiliar outputs
        c_input_internal pk_types.cursor_type;
        l_aux1           table_number := table_number();
        l_auxf           table_number := table_number();
        --error handling
        l_exception EXCEPTION;
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    
    BEGIN
    
        g_error := 'OPEN CONFIGURATION CURSOR';
        IF NOT get_inst_exam_body_structure(i_lang, i_market, i_version, c_input_internal, o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_func_name := upper('get_inst_exam_body_structure');
        
            LOOP
                g_error := 'FETCH CONFIGURATION CURSOR ' || g_func_name;
                FETCH c_input_internal BULK COLLECT
                    INTO l_data_id_exam, l_data_id_body_structure, l_data_flg_main LIMIT g_array_size;
                g_error := 'LOAD CONFIGURATIONS ' || g_func_name;
                FORALL j IN 1 .. l_data_id_body_structure.count SAVE EXCEPTIONS
                    INSERT INTO exam_body_structure
                        (id_exam, id_body_structure, flg_available, flg_main_laterality)
                    VALUES
                        (l_data_id_exam(j), l_data_id_body_structure(j), g_flg_available, l_data_flg_main(j))
                    RETURNING id_exam BULK COLLECT INTO l_aux1;
                l_auxf := l_auxf MULTISET UNION l_aux1;
                EXIT WHEN c_input_internal%NOTFOUND;
            
            END LOOP;
            pk_alertlog.log_info(l_auxf.count || ' rows inserted');
            g_error := 'CLOSE CONFIGURATION CURSOR ' || g_func_name;
            CLOSE c_input_internal;
        
        END IF;
    
        g_error := 'RETURN DEFAULT IDS CONFIGURED ' || g_func_name;
        OPEN o_exam_body_structure FOR
            SELECT column_value
              FROM TABLE(CAST(l_auxf AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQLERRM(-SQL%BULK_EXCEPTIONS(idx).error_code);
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  SQL%BULK_EXCEPTIONS(idx).error_code,
                                                  error_msg,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_exam_body_structure;
    /********************************************************************************************
    * Set GET_INST_HABTIS by Market and Institution
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.5
    * @since                       2010/12/14
    ********************************************************************************************/
    FUNCTION get_inst_habits
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_id_habit       OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --HABIT
        l_id_habit_def habit.id_habit%TYPE;
        l_id_habit     habit.id_habit%TYPE;
    
        l_id_habit_array table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_habits
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT h.id_habit
              FROM alert_default.habit h
              JOIN alert_default.habit_mrk_vrs hmv
                ON hmv.id_habit = h.id_habit
               AND hmv.version = c_version
               AND hmv.id_market = c_market
             WHERE h.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_HABITS CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HABITS ' || g_error);
                OPEN c_habits(i_version(i), i_market(j));
                LOOP
                    g_error := 'FETCHING RESULTS';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HABITS ' || g_error);
                    FETCH c_habits
                        INTO l_id_habit_def;
                    EXIT WHEN c_habits%NOTFOUND;
                
                    g_error := 'GET ALERT HABIT ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HABITS ' || g_error);
                    SELECT nvl((SELECT h.id_habit
                                 FROM habit h
                                WHERE h.id_content = (SELECT h2.id_content
                                                        FROM alert_default.habit h2
                                                       WHERE h2.id_habit = l_id_habit_def
                                                         AND h2.flg_available = g_flg_available)
                                  AND h.id_content IS NOT NULL
                                  AND h.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_habit
                      FROM dual;
                
                    g_error := 'ALERT HABIT ID NOT EXISTS';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HABITS ' || g_error);
                    IF l_id_habit != 0
                    THEN
                        g_error := 'COUNT EXISTING RESULTS';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HABITS ' || g_error);
                        SELECT COUNT(hi.id_habit)
                          INTO l_count
                          FROM habit_inst hi
                         WHERE hi.id_institution = i_id_institution
                           AND hi.id_habit = l_id_habit
                           AND hi.flg_available = g_flg_available;
                    
                        g_error := 'COUNT = 0';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HABITS ' || g_error);
                        IF l_count = 0
                        THEN
                            l_id_habit_array.extend;
                            l_id_habit_array(l_index) := l_id_habit;
                            l_index := l_index + 1;
                        
                        END IF;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_HABITS CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HABITS ' || g_error);
                CLOSE c_habits;
            
            END LOOP;
        
        END LOOP;
    
        g_error := 'CLOSE O_ID_HABIT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HABITS ' || g_error);
        OPEN o_id_habit FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_habit_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_HABITS',
                                              o_error);
            pk_types.open_my_cursor(o_id_habit);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_habits;
    /********************************************************************************************
    * Set SET_INST_HABITS by Market, Software, Institution
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.5
    * @since                       2010/12/14
    ********************************************************************************************/
    FUNCTION set_inst_habits
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        o_id_habits      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_habit pk_types.cursor_type;
    
        l_data_id_habit table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'IF NOT GET_INST_HABITS';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HABITS ' || g_error);
        IF NOT get_inst_habits(i_lang, i_market, i_version, i_id_institution, l_c_id_habit, l_error)
        THEN
            RAISE l_exception;
        ELSE
        
            g_error := 'O_ID_HABITS := L_C_ID_HABIT';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HABITS ' || g_error);
            o_id_habits := l_c_id_habit;
        
            LOOP
                FETCH l_c_id_habit BULK COLLECT
                    INTO l_data_id_habit LIMIT g_array_size;
            
                g_error := 'INSERT WITH FORALL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HABITS ' || g_error);
                FORALL j IN 1 .. l_data_id_habit.count
                    INSERT INTO habit_inst
                        (id_habit, id_institution, flg_available)
                    VALUES
                        (l_data_id_habit(j), i_id_institution, g_flg_available);
                EXIT WHEN l_c_id_habit%NOTFOUND;
            
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_HABIT CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HABITS ' || g_error);
            CLOSE l_c_id_habit;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HABITS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HABITS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_habits;
    /********************************************************************************************
    * Get QUESTIONNAIRE_RESPONSE set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.4
    * @since                       2010/11/17
    ********************************************************************************************/
    FUNCTION get_inst_quest_response
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN table_number,
        i_version          IN table_varchar,
        o_id_questionnaire OUT pk_types.cursor_type,
        o_id_response      OUT pk_types.cursor_type,
        o_rank             OUT pk_types.cursor_type,
        o_id_content       OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --QUESTIONNAIRE
        l_id_questionnaire_def questionnaire.id_questionnaire%TYPE;
        l_id_questionnaire     questionnaire.id_questionnaire%TYPE;
        --RESPONSE
        l_id_response_def response.id_response%TYPE;
        l_id_response     response.id_response%TYPE;
        --QUESTIONNAIRE_RESPONSE
        l_rank       questionnaire_response.rank%TYPE;
        l_id_content questionnaire_response.id_content%TYPE;
    
        l_id_questionnaire_array table_number := table_number();
        l_id_response_array      table_number := table_number();
        l_rank_array             table_number := table_number();
        l_id_content_array       table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_quest_resp
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT qr.id_questionnaire, qr.id_response, qr.rank, qr.id_content
              FROM alert_default.questionnaire_response qr
              JOIN alert_default.questionnaire q
                ON q.id_questionnaire = qr.id_questionnaire
               AND q.flg_available = g_yes
              JOIN alert_default.questionnaire_mrk_vrs qmv
                ON qmv.id_questionnaire = qr.id_questionnaire
               AND qmv.id_market = c_market
               AND qmv.version = c_version
              JOIN alert_default.response r
                ON r.id_response = qr.id_response
               AND r.flg_available = g_yes
              JOIN alert_default.response_mrk_vrs rmv
                ON rmv.id_response = qr.id_response
               AND rmv.id_market = qmv.id_market
               AND rmv.version = qmv.version;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
            
                g_error := 'OPEN C_QUEST_RESP CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
                OPEN c_quest_resp(i_version(i), i_market(j));
                LOOP
                    FETCH c_quest_resp
                        INTO l_id_questionnaire_def, l_id_response_def, l_rank, l_id_content;
                    EXIT WHEN c_quest_resp%NOTFOUND;
                
                    --QUESTIONNARIE
                    g_error := 'GET QUESTIONNARIE ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
                    SELECT nvl((SELECT q1.id_questionnaire
                                 FROM questionnaire q1
                                WHERE q1.id_content =
                                      (SELECT q2.id_content
                                         FROM alert_default.questionnaire q2
                                        WHERE q2.id_questionnaire = l_id_questionnaire_def)
                                  AND q1.id_content IS NOT NULL
                                  AND q1.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_questionnaire
                      FROM dual;
                
                    --RESPONSE          
                    g_error := 'GET RESPONSE ID';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
                    SELECT nvl((SELECT r1.id_response
                                 FROM response r1
                                WHERE r1.id_content = (SELECT r2.id_content
                                                         FROM alert_default.response r2
                                                        WHERE r2.id_response = l_id_response_def)
                                  AND r1.id_content IS NOT NULL
                                  AND r1.flg_available = g_flg_available
                                  AND rownum = 1),
                               0)
                      INTO l_id_response
                      FROM dual;
                
                    IF l_id_questionnaire != 0
                       AND l_id_response != 0
                    THEN
                        g_error := 'COUNT QUESTIONNAIRE_RESPONSE EXISTING RESULTS';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
                    
                        SELECT COUNT(qr.id_questionnaire)
                          INTO l_count
                          FROM questionnaire_response qr
                         WHERE qr.id_questionnaire = l_id_questionnaire
                           AND qr.id_response = l_id_response;
                    
                        IF l_count = 0
                        THEN
                            l_id_questionnaire_array.extend;
                            l_id_response_array.extend;
                            l_rank_array.extend;
                            l_id_content_array.extend;
                        
                            l_id_questionnaire_array(l_index) := l_id_questionnaire;
                            l_id_response_array(l_index) := l_id_response;
                            l_rank_array(l_index) := l_rank;
                            l_id_content_array(l_index) := l_id_content;
                        
                            l_index := l_index + 1;
                        END IF;
                    END IF;
                END LOOP;
                g_error := 'CLOSE C_QUEST_RESP CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
                CLOSE c_quest_resp;
            
            END LOOP;
        END LOOP;
    
        g_error := 'CLOSE O_ID_QUESTIONNAIRE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
        OPEN o_id_questionnaire FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_questionnaire_array AS table_number));
    
        g_error := 'CLOSE O_ID_RESPONSE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
        OPEN o_id_response FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_response_array AS table_number));
    
        g_error := 'CLOSE O_RANK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        g_error := 'CLOSE O_ID_CONTENT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_QUEST_RESPONSE ' || g_error);
        OPEN o_id_content FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_content_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_QUEST_RESPONSE',
                                              o_error);
            pk_types.open_my_cursor(o_id_questionnaire);
            pk_types.open_my_cursor(o_id_response);
            pk_types.open_my_cursor(o_rank);
            pk_types.open_my_cursor(o_id_content);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_quest_response;
    /********************************************************************************************
    * Set QUESTIONNAIRE_RESPONSE
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.4
    * @since                       2010/11/17
    ********************************************************************************************/
    FUNCTION set_inst_quest_response
    (
        i_lang          IN language.id_language%TYPE,
        i_market        IN table_number,
        i_version       IN table_varchar,
        o_id_quest_resp OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_questionnaire pk_types.cursor_type;
        l_c_id_response      pk_types.cursor_type;
        l_c_rank             pk_types.cursor_type;
        l_c_id_content       pk_types.cursor_type;
    
        l_data_id_questionnaire table_number;
        l_data_id_response      table_number;
        l_data_rank             table_number;
        l_data_id_content       table_varchar;
    
        --LOG ERRORS    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'IF NOT GET_INST_QUEST_RESPONSE';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_QUEST_RESPONSE ' || g_error);
    
        IF NOT get_inst_quest_response(i_lang,
                                       i_market,
                                       i_version,
                                       l_c_id_questionnaire,
                                       l_c_id_response,
                                       l_c_rank,
                                       l_c_id_content,
                                       o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error := 'o_id_quest_resp := l_c_id_questionnaire';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_QUEST_RESPONSE ' || g_error);
            o_id_quest_resp := l_c_id_questionnaire;
        
            LOOP
                FETCH l_c_id_questionnaire BULK COLLECT
                    INTO l_data_id_questionnaire LIMIT g_array_size1;
                FETCH l_c_id_response BULK COLLECT
                    INTO l_data_id_response LIMIT g_array_size1;
                FETCH l_c_rank BULK COLLECT
                    INTO l_data_rank LIMIT g_array_size1;
                FETCH l_c_id_content BULK COLLECT
                    INTO l_data_id_content LIMIT g_array_size1;
            
                g_error := 'INSERT INTO QUESTIONNAIRE RESPONSE WITH FORALL';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_QUEST_RESPONSE ' || g_error);
                FORALL j IN 1 .. l_data_id_questionnaire.count
                
                    INSERT INTO questionnaire_response
                        (id_questionnaire, id_response, id_content, rank, flg_available)
                    VALUES
                        (l_data_id_questionnaire(j),
                         l_data_id_response(j),
                         l_data_id_content(j),
                         l_data_rank(j),
                         g_flg_available);
            
                EXIT WHEN l_c_id_questionnaire%NOTFOUND;
            
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_QUESTIONNAIRE CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_QUEST_RESPONSE ' || g_error);
            CLOSE l_c_id_questionnaire;
        
            g_error := 'CLOSE L_C_ID_RESPONSE CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_QUEST_RESPONSE ' || g_error);
            CLOSE l_c_id_response;
        
            g_error := 'CLOSE L_C_RANK CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_QUEST_RESPONSE ' || g_error);
            CLOSE l_c_rank;
        
            g_error := 'CLOSE L_C_ID_CONTENT CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_QUEST_RESPONSE ' || g_error);
            CLOSE l_c_id_content;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_QUEST_RESPONSE',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_QUEST_RESPONSE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_quest_response;
    /********************************************************************************************
    * Get EXAM_UESTIONNAIRE set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.4
    * @since                       2010/11/18
    ********************************************************************************************/
    FUNCTION get_inst_exam_questionnaire
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN table_number,
        i_version          IN table_varchar,
        o_id_exam          OUT pk_types.cursor_type,
        o_id_questionnaire OUT pk_types.cursor_type,
        o_flg_type         OUT pk_types.cursor_type,
        o_flg_mandatory    OUT pk_types.cursor_type,
        o_rank             OUT pk_types.cursor_type,
        o_gender           OUT pk_types.cursor_type,
        o_flg_time         OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --QUESTIONNAIRE
        l_id_questionnaire_def questionnaire.id_questionnaire%TYPE;
        l_id_questionnaire     questionnaire.id_questionnaire%TYPE;
    
        --EXAM
        l_id_exam_def exam.id_exam%TYPE;
        l_id_exam     exam.id_exam%TYPE;
        --EXAM_QUESTIONNAIRE
        l_flg_type      exam_questionnaire.flg_type%TYPE;
        l_flg_mandatory exam_questionnaire.flg_mandatory%TYPE;
        l_rank          exam_questionnaire.rank%TYPE;
        -- RG: added new table columns 2011/02/09
        --l_gender   exam_questionnaire.gender%TYPE;
        l_flg_time exam_questionnaire.flg_time%TYPE;
    
        l_id_exam_array          table_number := table_number();
        l_id_questionnaire_array table_number := table_number();
        l_flg_type_array         table_varchar := table_varchar();
        l_flg_mandatory_array    table_varchar := table_varchar();
        l_rank_array             table_number := table_number();
        -- RG: added new table columns 2011/02/09
        l_gender_array   table_varchar := table_varchar();
        l_flg_time_array table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_exam_quest
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT eq.id_exam, eq.id_questionnaire, eq.flg_type, eq.flg_mandatory, eq.rank, eq.flg_time
              FROM alert_default.exam_questionnaire eq
              JOIN alert_default.questionnaire q
                ON q.id_questionnaire = eq.id_questionnaire
               AND q.flg_available = g_yes
              JOIN alert_default.questionnaire_mrk_vrs qmv
                ON qmv.id_questionnaire = eq.id_questionnaire
               AND qmv.id_market = c_market
               AND qmv.version = c_version
              JOIN alert_default.exam e
                ON e.id_exam = eq.id_exam
               AND e.flg_available = g_yes
              JOIN alert_default.exam_mrk_vrs emv
                ON emv.id_exam = eq.id_exam
               AND emv.id_market = qmv.id_market
               AND emv.version = qmv.version;
    
    BEGIN
    
        dbms_output.put_line('get_inst_exam_questionnaire deprecated');
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_QUEST_RESPONSE',
                                              o_error);
            pk_types.open_my_cursor(o_id_exam);
            pk_types.open_my_cursor(o_id_questionnaire);
            pk_types.open_my_cursor(o_flg_type);
            pk_types.open_my_cursor(o_flg_mandatory);
            pk_types.open_my_cursor(o_rank);
            pk_types.open_my_cursor(o_gender);
            pk_types.open_my_cursor(o_flg_time);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_exam_questionnaire;
    /********************************************************************************************
    * Set EXAM_QUESTIONNAIRE
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.4
    * @since                       2010/11/18
    ********************************************************************************************/
    FUNCTION set_inst_exam_questionnaire
    (
        i_lang                 IN language.id_language%TYPE,
        i_market               IN table_number,
        i_version              IN table_varchar,
        o_id_exam_questionaire OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_exam          pk_types.cursor_type;
        l_c_id_questionnaire pk_types.cursor_type;
        l_c_flg_type         pk_types.cursor_type;
        l_c_flg_mandatory    pk_types.cursor_type;
        l_c_rank             pk_types.cursor_type;
        -- RG: added new table columns 2011/02/09
        l_c_gender   pk_types.cursor_type;
        l_c_flg_time pk_types.cursor_type;
    
        l_data_id_exam          table_number;
        l_data_id_questionnaire table_number;
        l_data_flg_type         table_varchar;
        l_data_flg_mandatory    table_varchar;
        l_data_rank             table_number;
        l_data_gender           table_varchar;
        l_data_flg_time         table_varchar;
        /*ALERT-205104 16/11/2011*/
        l_id_pk    exam_questionnaire.id_exam_questionnaire%TYPE;
        l_ids_list table_number := table_number();
        --LOG ERRORS    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        dbms_output.put_line('SET_INST_EXAM_QUESTIONNAIRE deprecated');
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_EXAM_QUESTIONNAIRE',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_EXAM_QUESTIONNAIRE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_exam_questionnaire;
    /********************************************************************************************
    * Set GET_INST TIMELINE Vertical Axis by Market, Software, Institution
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.5.1.2
    * @since                       2010/11/22
    ********************************************************************************************/
    FUNCTION get_inst_tl_vertical_axis
    (
        i_lang           IN language.id_language%TYPE,
        i_id_market      IN market.id_market%TYPE,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE,
        o_id_tl_timeline OUT pk_types.cursor_type,
        o_id_tl_software OUT pk_types.cursor_type,
        o_rank           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --TL_VA_INST_SOFT_MARKET
        l_id_tl_timeline tl_va_inst_soft_market.id_tl_timeline%TYPE;
        l_id_tl_software tl_va_inst_soft_market.id_tl_software%TYPE;
        l_rank           tl_va_inst_soft_market.rank%TYPE;
        --Arrays
        l_id_tl_timeline_array table_number := table_number();
        l_id_tl_software_array table_number := table_number();
        l_rank_array           table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_tl_vert_axis
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN market.id_market%TYPE
        ) IS
            SELECT DISTINCT tlva.id_tl_timeline, tlva.id_tl_software, tlva.rank
              FROM alert_default.tl_va_inst_soft_market tlva
             WHERE tlva.id_software = c_id_software
               AND tlva.id_market = c_market
               AND tlva.version = c_version
               AND tlva.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
            g_error := 'OPEN C_TL_VERT_AXIS CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_VERTICAL_AXIS ' || g_error);
            OPEN c_tl_vert_axis(i_id_software, i_version(i), i_id_market);
            LOOP
                FETCH c_tl_vert_axis
                    INTO l_id_tl_timeline, l_id_tl_software, l_rank;
                EXIT WHEN c_tl_vert_axis%NOTFOUND;
            
                g_error := 'COUNT EXISTING RESULTS';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_VERTICAL_AXIS ' || g_error);
                SELECT COUNT(1)
                  INTO l_count
                  FROM tl_va_inst_soft_market tlva
                 WHERE tlva.id_institution = i_id_institution
                   AND tlva.id_software = i_id_software
                   AND tlva.id_market = i_id_market
                   AND tlva.flg_available = g_flg_available;
            
                IF l_count = 0
                THEN
                    l_id_tl_timeline_array.extend;
                    l_id_tl_software_array.extend;
                    l_rank_array.extend;
                
                    l_id_tl_timeline_array(l_index) := l_id_tl_timeline;
                    l_id_tl_software_array(l_index) := l_id_tl_software;
                    l_rank_array(l_index) := l_rank;
                
                    l_index := l_index + 1;
                
                END IF;
            
            END LOOP;
        
            g_error := 'CLOSE C_TL_VERT_AXIS CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_VERTICAL_AXIS ' || g_error);
            CLOSE c_tl_vert_axis;
        
        END LOOP;
    
        g_error := 'CAST O_ID_TL_TIMELINE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_VERTICAL_AXIS ' || g_error);
        OPEN o_id_tl_timeline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_tl_timeline_array AS table_number));
    
        g_error := 'CAST O_ID_TL_SOFTWARE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_VERTICAL_AXIS ' || g_error);
        OPEN o_id_tl_software FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_tl_software_array AS table_number));
    
        g_error := 'CAST O_RANK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_VERTICAL_AXIS ' || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_TL_VERTICAL_AXIS',
                                              o_error);
            pk_types.open_my_cursor(o_id_tl_timeline);
            pk_types.open_my_cursor(o_id_tl_software);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_tl_vertical_axis;
    /********************************************************************************************
    * Set SET_INST TIMELINE Vertical Axis by Market, Software, Institution
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.5.1.2
    * @since                       2010/11/23
    ********************************************************************************************/
    FUNCTION set_inst_tl_vertical_axis
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_id_institution        IN institution.id_institution%TYPE,
        i_software              IN table_number,
        o_inst_tl_vertical_axis OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_tl_timeline pk_types.cursor_type;
        l_c_id_tl_software pk_types.cursor_type;
        l_c_rank           pk_types.cursor_type;
    
        l_data_id_tl_timeline table_number;
        l_data_id_tl_software table_number;
        l_data_rank           table_number;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            FOR k IN 1 .. i_market.count
            LOOP
                g_error := 'IF NOT GET_INST_TL_VERTICAL_AXIS';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_VERTICAL_AXIS ' || g_error);
                IF NOT get_inst_tl_vertical_axis(i_lang,
                                                 i_market(k),
                                                 i_version,
                                                 i_id_institution,
                                                 i_software(i),
                                                 l_c_id_tl_timeline,
                                                 l_c_id_tl_software,
                                                 l_c_rank,
                                                 l_error)
                THEN
                    RAISE l_exception;
                ELSE
                
                    g_error := ' o_inst_tl_vertical_axis := l_c_id_tl_timeline';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_VERTICAL_AXIS ' || g_error);
                    o_inst_tl_vertical_axis := l_c_id_tl_timeline;
                
                    LOOP
                        FETCH l_c_id_tl_timeline BULK COLLECT
                            INTO l_data_id_tl_timeline LIMIT g_array_size;
                        FETCH l_c_id_tl_software BULK COLLECT
                            INTO l_data_id_tl_software LIMIT g_array_size;
                        FETCH l_c_rank BULK COLLECT
                            INTO l_data_rank LIMIT g_array_size;
                    
                        g_error := 'INSERT WITH FORALL';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_VERTICAL_AXIS ' || g_error);
                    
                        FORALL j IN 1 .. l_data_id_tl_timeline.count
                        
                            INSERT INTO tl_va_inst_soft_market
                                ( --id_tl_va_inst_soft_market,
                                 id_tl_timeline,
                                 id_tl_software,
                                 flg_available,
                                 id_institution,
                                 id_software,
                                 id_market,
                                 rank)
                                SELECT --nvl(MAX(id_tl_va_inst_soft_market), 0) + 1,
                                 l_data_id_tl_timeline(j),
                                 l_data_id_tl_software(j),
                                 g_flg_available,
                                 i_id_institution,
                                 i_software(i),
                                 i_market(k),
                                 l_data_rank(j)
                                  FROM tl_va_inst_soft_market;
                    
                        EXIT WHEN l_c_id_tl_timeline%NOTFOUND;
                    
                    END LOOP;
                
                    g_error := 'CLOSE L_C_ID_TL_TIMELINE CURSOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_VERTICAL_AXIS ' || g_error);
                    CLOSE l_c_id_tl_timeline;
                    g_error := 'CLOSE L_C_ID_TL_SOFTWARE CURSOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_VERTICAL_AXIS ' || g_error);
                    CLOSE l_c_id_tl_software;
                    g_error := 'CLOSE L_C_RANK CURSOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_VERTICAL_AXIS ' || g_error);
                    CLOSE l_c_rank;
                
                END IF;
            
            END LOOP;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_TL_VERTICAL_AXIS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_TL_VERTICAL_AXIS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_tl_vertical_axis;
    /********************************************************************************************
    * Set GET_INST TIMELINE Horizontal Axis by Market, Software, Institution
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.5.1.2
    * @since                       2010/11/23
    ********************************************************************************************/
    FUNCTION get_inst_tl_horizontal_axis
    (
        i_lang               IN language.id_language%TYPE,
        i_id_market          IN market.id_market%TYPE,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        i_id_software        IN software.id_software%TYPE,
        o_id_tl_timeline     OUT pk_types.cursor_type,
        o_id_tl_scale_xupper OUT pk_types.cursor_type,
        o_id_tl_scale_xlower OUT pk_types.cursor_type,
        o_rank               OUT pk_types.cursor_type,
        o_flg_default        OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --TL_SCALE_INST_SOFT_MARKET
        l_id_tl_timeline     tl_scale_inst_soft_market.id_tl_timeline%TYPE;
        l_id_tl_scale_xupper tl_scale_inst_soft_market.id_tl_scale_xupper%TYPE;
        l_id_tl_scale_xlower tl_scale_inst_soft_market.id_tl_scale_xlower%TYPE;
        l_rank               tl_scale_inst_soft_market.rank%TYPE;
        l_flg_default        tl_scale_inst_soft_market.flg_default%TYPE;
        --Arrays
        l_id_tl_timeline_array     table_number := table_number();
        l_id_tl_scale_xupper_array table_number := table_number();
        l_id_tl_scale_xlower_array table_number := table_number();
        l_rank_array               table_number := table_number();
        l_flg_default_array        table_varchar := table_varchar();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_tl_horiz_axis
        (
            c_id_software IN software.id_software%TYPE,
            c_version     IN VARCHAR2,
            c_market      IN market.id_market%TYPE
        ) IS
            SELECT DISTINCT tlsc.id_tl_timeline,
                            tlsc.id_tl_scale_xupper,
                            tlsc.id_tl_scale_xlower,
                            tlsc.rank,
                            tlsc.flg_default
              FROM alert_default.tl_scale_inst_soft_market tlsc
             WHERE tlsc.id_software = c_id_software
               AND tlsc.id_market = c_market
               AND tlsc.version = c_version
               AND tlsc.flg_available = g_flg_available;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
            g_error := 'OPEN C_TL_HORIZ_AXIS CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_HORIZONTAL_AXIS ' || g_error);
            OPEN c_tl_horiz_axis(i_id_software, i_version(i), i_id_market);
            LOOP
                FETCH c_tl_horiz_axis
                    INTO l_id_tl_timeline, l_id_tl_scale_xupper, l_id_tl_scale_xlower, l_rank, l_flg_default;
                EXIT WHEN c_tl_horiz_axis%NOTFOUND;
            
                g_error := 'COUNT EXISTING RESULTS';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                SELECT COUNT(tlsc.id_tl_scale_inst_soft_market)
                  INTO l_count
                  FROM tl_scale_inst_soft_market tlsc
                 WHERE tlsc.id_institution = i_id_institution
                   AND tlsc.id_software = i_id_software
                   AND tlsc.id_market = i_id_market
                   AND tlsc.flg_available = g_flg_available;
            
                IF l_count = 0
                THEN
                    l_id_tl_timeline_array.extend;
                    l_id_tl_scale_xupper_array.extend;
                    l_id_tl_scale_xlower_array.extend;
                    l_rank_array.extend;
                    l_flg_default_array.extend;
                
                    l_id_tl_timeline_array(l_index) := l_id_tl_timeline;
                    l_id_tl_scale_xupper_array(l_index) := l_id_tl_scale_xupper;
                    l_id_tl_scale_xlower_array(l_index) := l_id_tl_scale_xlower;
                    l_rank_array(l_index) := l_rank;
                    l_flg_default_array(l_index) := l_flg_default;
                
                    l_index := l_index + 1;
                
                END IF;
            
            END LOOP;
        
            g_error := 'CLOSE C_TL_HORIZ_AXIS CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_HORIZONTAL_AXIS ' || g_error);
            CLOSE c_tl_horiz_axis;
        
        END LOOP;
    
        g_error := 'CAST O_ID_TL_TIMELINE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_HORIZONTAL_AXIS ' || g_error);
        OPEN o_id_tl_timeline FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_tl_timeline_array AS table_number));
    
        g_error := 'CAST O_ID_TL_SCALE_XUPPER CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_HORIZONTAL_AXIS ' || g_error);
        OPEN o_id_tl_scale_xupper FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_tl_scale_xupper_array AS table_number));
    
        g_error := 'CAST O_ID_TL_SCALE_XLOWER CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_HORIZONTAL_AXIS ' || g_error);
        OPEN o_id_tl_scale_xlower FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_tl_scale_xlower_array AS table_number));
    
        g_error := 'CAST O_RANK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_HORIZONTAL_AXIS ' || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        g_error := 'CAST O_FLG_DEFAULT CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_TL_HORIZONTAL_AXIS ' || g_error);
        OPEN o_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_default_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_TL_HORIZONTAL_AXIS',
                                              o_error);
            pk_types.open_my_cursor(o_id_tl_timeline);
            pk_types.open_my_cursor(o_id_tl_scale_xupper);
            pk_types.open_my_cursor(o_id_tl_scale_xlower);
            pk_types.open_my_cursor(o_rank);
            pk_types.open_my_cursor(o_flg_default);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_tl_horizontal_axis;
    /********************************************************************************************
    * Set SET_INST TIMELINE Horizontal Axis by Market, Software, Institution
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.5.1.2
    * @since                       2010/11/23
    ********************************************************************************************/
    FUNCTION set_inst_tl_horizontal_axis
    (
        i_lang                    IN language.id_language%TYPE,
        i_market                  IN table_number,
        i_version                 IN table_varchar,
        i_id_institution          IN institution.id_institution%TYPE,
        i_software                IN table_number,
        o_inst_tl_horizontal_axis OUT pk_types.cursor_type,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_tl_timeline     pk_types.cursor_type;
        l_c_id_tl_scale_xupper pk_types.cursor_type;
        l_c_id_tl_scale_xlower pk_types.cursor_type;
        l_c_rank               pk_types.cursor_type;
        l_c_flg_default        pk_types.cursor_type;
    
        l_data_id_tl_timeline     table_number;
        l_data_id_tl_scale_xupper table_number;
        l_data_id_tl_scale_xlower table_number;
        l_data_rank               table_number;
        l_data_flg_default        table_varchar;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        FOR i IN 1 .. i_software.count
        LOOP
            FOR k IN 1 .. i_market.count
            LOOP
                g_error := 'IF NOT GET_INST_TL_HORIZONTAL_AXIS';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                IF NOT get_inst_tl_horizontal_axis(i_lang,
                                                   i_market(k),
                                                   i_version,
                                                   i_id_institution,
                                                   i_software(i),
                                                   l_c_id_tl_timeline,
                                                   l_c_id_tl_scale_xupper,
                                                   l_c_id_tl_scale_xlower,
                                                   l_c_rank,
                                                   l_c_flg_default,
                                                   l_error)
                THEN
                    RAISE l_exception;
                ELSE
                
                    g_error := ' o_inst_tl_vertical_axis := l_c_id_tl_timeline';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                    o_inst_tl_horizontal_axis := l_c_id_tl_timeline;
                
                    LOOP
                        FETCH l_c_id_tl_timeline BULK COLLECT
                            INTO l_data_id_tl_timeline LIMIT g_array_size;
                        FETCH l_c_id_tl_scale_xupper BULK COLLECT
                            INTO l_data_id_tl_scale_xupper LIMIT g_array_size;
                        FETCH l_c_id_tl_scale_xlower BULK COLLECT
                            INTO l_data_id_tl_scale_xlower LIMIT g_array_size;
                        FETCH l_c_rank BULK COLLECT
                            INTO l_data_rank LIMIT g_array_size;
                        FETCH l_c_flg_default BULK COLLECT
                            INTO l_data_flg_default LIMIT g_array_size;
                    
                        g_error := 'INSERT WITH FORALL';
                        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                        FORALL j IN 1 .. l_data_id_tl_timeline.count
                            INSERT INTO tl_scale_inst_soft_market
                                (id_tl_scale_inst_soft_market,
                                 id_tl_timeline,
                                 id_tl_scale_xupper,
                                 id_tl_scale_xlower,
                                 flg_available,
                                 id_institution,
                                 id_software,
                                 id_market,
                                 rank,
                                 flg_default)
                                SELECT nvl(MAX(id_tl_scale_inst_soft_market), 0) + 1,
                                       l_data_id_tl_timeline(j),
                                       l_data_id_tl_scale_xupper(j),
                                       l_data_id_tl_scale_xlower(j),
                                       g_flg_available,
                                       i_id_institution,
                                       i_software(i),
                                       i_market(k),
                                       l_data_rank(j),
                                       l_data_flg_default(j)
                                  FROM tl_scale_inst_soft_market;
                        EXIT WHEN l_c_id_tl_timeline%NOTFOUND;
                    
                    END LOOP;
                
                    g_error := 'CLOSE L_C_ID_TL_TIMELINE CURSOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                    CLOSE l_c_id_tl_timeline;
                    g_error := 'CLOSE L_C_ID_TL_SCALE_XUPPER CURSOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                    CLOSE l_c_id_tl_scale_xupper;
                    g_error := 'CLOSE L_C_ID_TL_SCALE_XLOWER CURSOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                    CLOSE l_c_id_tl_scale_xlower;
                    g_error := 'CLOSE L_C_RANK CURSOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                    CLOSE l_c_rank;
                    g_error := 'CLOSE L_C_ID_FLG_DEFAULT CURSOR';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_TL_HORIZONTAL_AXIS ' || g_error);
                    CLOSE l_c_flg_default;
                
                END IF;
            
            END LOOP;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_TL_HORIZONTAL_AXIS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_TL_HORIZONTAL_AXIS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_tl_horizontal_axis;
    /********************************************************************************************
    * Get HIDRICS_DEVICE_REL set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.5.1.3
    * @since                       2011/01/13
    ********************************************************************************************/
    FUNCTION get_inst_hidrics_device_rel
    (
        i_lang              IN language.id_language%TYPE,
        i_id_market         IN market.id_market%TYPE,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        o_id_hidrics_device OUT pk_types.cursor_type,
        o_id_hidrics        OUT pk_types.cursor_type,
        o_id_way            OUT pk_types.cursor_type,
        o_rank              OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --HIDRICS
        l_id_hidrics_def hidrics_device_rel.id_hidrics%TYPE;
        l_id_hidrics     hidrics_device_rel.id_hidrics%TYPE;
        --HIDRICS_DEVICE
        l_id_hidrics_device_def hidrics_device_rel.id_hidrics_device%TYPE;
        l_id_hidrics_device     hidrics_device_rel.id_hidrics_device%TYPE;
        --WAY
        l_id_way_def hidrics_device_rel.id_way%TYPE;
        l_id_way     hidrics_device_rel.id_way%TYPE;
        --HIDRICS_DEVICE_REL
        l_rank hidrics_device_rel.rank%TYPE;
    
        l_id_hidrics_device_array table_number := table_number();
        l_id_hidrics_array        table_number := table_number();
        l_id_way_array            table_number := table_number();
        l_rank_array              table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_hidrics_device_rel
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT hdr.id_hidrics_device, hdr.id_hidrics, hdr.id_way, hdr.rank
              FROM alert_default.hidrics_device_rel hdr
              JOIN alert_default.hidrics_device hd
                ON hd.id_hidrics_device = hdr.id_hidrics_device
               AND hd.flg_available = g_flg_available
              JOIN alert_default.hidrics_device_mrk_vrs hdmv
                ON hdmv.id_hidrics_device = hd.id_hidrics_device
               AND hdmv.id_market = c_market
               AND hdmv.version = c_version
              JOIN alert_default.hidrics h
                ON h.id_hidrics = hdr.id_hidrics
               AND h.flg_available = g_flg_available
              JOIN alert_default.way w
                ON w.id_way = hdr.id_way
               AND w.flg_available = g_flg_available
             WHERE hdr.flg_available = g_flg_available
               AND hdr.id_market = hdmv.id_market;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            g_error := 'OPEN C_HIDRICS_DEVICE_REL CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
            OPEN c_hidrics_device_rel(i_version(i), i_id_market);
            LOOP
                FETCH c_hidrics_device_rel
                    INTO l_id_hidrics_device_def, l_id_hidrics_def, l_id_way_def, l_rank;
                EXIT WHEN c_hidrics_device_rel%NOTFOUND;
            
                --HIDRICS_DEVICE
                g_error := 'GET HIDRICS_DEVICE ID';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
                SELECT nvl((SELECT hd1.id_hidrics_device
                             FROM hidrics_device hd1
                            WHERE hd1.id_content = (SELECT hd2.id_content
                                                      FROM alert_default.hidrics_device hd2
                                                     WHERE hd2.id_hidrics_device = l_id_hidrics_device_def
                                                       AND hd2.flg_available = g_flg_available)
                              AND hd1.id_content IS NOT NULL
                              AND hd1.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_hidrics_device
                  FROM dual;
            
                --HIDRICS          
                g_error := 'GET HIDRICS ID';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
                SELECT nvl((SELECT h1.id_hidrics
                             FROM hidrics h1
                            WHERE h1.id_content = (SELECT h2.id_content
                                                     FROM alert_default.hidrics h2
                                                    WHERE h2.id_hidrics = l_id_hidrics_def
                                                      AND h2.flg_available = g_flg_available)
                              AND h1.id_content IS NOT NULL
                              AND h1.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_hidrics
                  FROM dual;
            
                --WAY          
                g_error := 'GET WAY ID';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
                SELECT nvl((SELECT w1.id_way
                             FROM way w1
                            WHERE w1.id_content = (SELECT w2.id_content
                                                     FROM alert_default.way w2
                                                    WHERE w2.id_way = l_id_way_def
                                                      AND w2.flg_available = g_flg_available)
                              AND w1.id_content IS NOT NULL
                              AND w1.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_way
                  FROM dual;
            
                IF l_id_hidrics_device != 0
                   AND l_id_hidrics != 0
                   AND l_id_way != 0
                THEN
                    g_error := 'COUNT HIDRICS_DEVICE_REL EXISTING RESULTS';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
                
                    SELECT COUNT(hdr.id_hidrics_device)
                      INTO l_count
                      FROM hidrics_device_rel hdr
                     WHERE hdr.id_hidrics_device = l_id_hidrics_device
                       AND hdr.id_hidrics = l_id_hidrics
                       AND hdr.id_way = l_id_way
                       AND hdr.id_institution = i_id_institution
                       AND hdr.id_market = i_id_market;
                
                    IF l_count = 0
                    THEN
                        l_id_hidrics_device_array.extend;
                        l_id_hidrics_array.extend;
                        l_id_way_array.extend;
                        l_rank_array.extend;
                    
                        l_id_hidrics_device_array(l_index) := l_id_hidrics_device;
                        l_id_hidrics_array(l_index) := l_id_hidrics;
                        l_id_way_array(l_index) := l_id_way;
                        l_rank_array(l_index) := l_rank;
                    
                        l_index := l_index + 1;
                    END IF;
                END IF;
            END LOOP;
            g_error := 'CLOSE C_HIDRICS_DEVICE_REL CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
            CLOSE c_hidrics_device_rel;
        
        END LOOP;
    
        g_error := 'CLOSE O_ID_HIDRICS_DEVICE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
        OPEN o_id_hidrics_device FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_hidrics_device_array AS table_number));
    
        g_error := 'CLOSE O_ID_HIDRICS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
        OPEN o_id_hidrics FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_hidrics_array AS table_number));
    
        g_error := 'CLOSE O_ID_WAY CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
        OPEN o_id_way FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_way_array AS table_number));
    
        g_error := 'CLOSE O_RANK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_DEVICE_REL ' || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_HIDRICS_DEVICE_REL',
                                              o_error);
            pk_types.open_my_cursor(o_id_hidrics_device);
            pk_types.open_my_cursor(o_id_hidrics);
            pk_types.open_my_cursor(o_id_way);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_hidrics_device_rel;
    /********************************************************************************************
    * Set HIDRICS_DEVICE_REL set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.5.1.3
    * @since                       2011/01/13
    ********************************************************************************************/
    FUNCTION set_inst_hidrics_device_rel
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN table_number,
        i_version            IN table_varchar,
        i_id_institution     IN institution.id_institution%TYPE,
        o_hidrics_device_rel OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_hidrics_device pk_types.cursor_type;
        l_c_id_hidrics        pk_types.cursor_type;
        l_c_id_way            pk_types.cursor_type;
        l_c_rank              pk_types.cursor_type;
    
        l_data_id_hidrics_device table_number;
        l_data_id_hidrics        table_number;
        l_data_id_way            table_varchar;
        l_data_rank              table_number;
    
        --LOG ERRORS    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        FOR k IN 1 .. i_market.count
        LOOP
            g_error := 'IF NOT GET_INST_HIDRICS_DEVICE_REL';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_DEVICE_REL ' || g_error);
            IF NOT get_inst_hidrics_device_rel(i_lang,
                                               i_market(k),
                                               i_version,
                                               i_id_institution,
                                               l_c_id_hidrics_device,
                                               l_c_id_hidrics,
                                               l_c_id_way,
                                               l_c_rank,
                                               o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_hidrics_device_rel := l_c_id_hidrics_device';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_DEVICE_REL ' || g_error);
                o_hidrics_device_rel := l_c_id_hidrics_device;
            
                LOOP
                    FETCH l_c_id_hidrics_device BULK COLLECT
                        INTO l_data_id_hidrics_device LIMIT g_array_size1;
                    FETCH l_c_id_hidrics BULK COLLECT
                        INTO l_data_id_hidrics LIMIT g_array_size1;
                    FETCH l_c_id_way BULK COLLECT
                        INTO l_data_id_way LIMIT g_array_size1;
                    FETCH l_c_rank BULK COLLECT
                        INTO l_data_rank LIMIT g_array_size1;
                
                    g_error := 'INSERT INTO HIDRICS_DEVICE_REL WITH FORALL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_DEVICE_REL ' || g_error);
                    FORALL j IN 1 .. l_data_id_hidrics_device.count
                    
                        INSERT INTO hidrics_device_rel
                            (id_hidrics_device,
                             id_hidrics,
                             id_way,
                             rank,
                             flg_available,
                             id_department,
                             id_dept,
                             id_institution,
                             id_market)
                        VALUES
                            (l_data_id_hidrics_device(j),
                             l_data_id_hidrics(j),
                             l_data_id_way(j),
                             l_data_rank(j),
                             g_flg_available,
                             0,
                             0,
                             i_id_institution,
                             i_market(k));
                
                    EXIT WHEN l_c_id_hidrics_device%NOTFOUND;
                
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_HIDRICS_DEVICE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_DEVICE_REL ' || g_error);
                CLOSE l_c_id_hidrics_device;
            
                g_error := 'CLOSE L_C_ID_HIDRICS CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_DEVICE_REL ' || g_error);
                CLOSE l_c_id_hidrics;
            
                g_error := 'CLOSE L_C_ID_WAY CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_DEVICE_REL ' || g_error);
                CLOSE l_c_id_way;
            
                g_error := 'CLOSE L_C_RANK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_DEVICE_REL ' || g_error);
                CLOSE l_c_rank;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS_DEVICE_REL',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS_DEVICE_REL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_hidrics_device_rel;
    /********************************************************************************************
    * Get HIDRICS_OCCURS_TYPE_REL set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.5.1.3
    * @since                       2011/01/13
    ********************************************************************************************/
    FUNCTION get_inst_hidrics_occurs_tp_rel
    (
        i_lang                   IN language.id_language%TYPE,
        i_id_market              IN market.id_market%TYPE,
        i_version                IN table_varchar,
        i_id_institution         IN institution.id_institution%TYPE,
        o_id_hidrics_occurs_type OUT pk_types.cursor_type,
        o_id_hidrics             OUT pk_types.cursor_type,
        o_rank                   OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --HIDRICS
        l_id_hidrics_def hidrics_occurs_type_rel.id_hidrics%TYPE;
        l_id_hidrics     hidrics_occurs_type_rel.id_hidrics%TYPE;
        --HIDRICS_OCCURS_TYPE
        l_id_hidrics_occurs_type_def hidrics_occurs_type_rel.id_hidrics_occurs_type%TYPE;
        l_id_hidrics_occurs_type     hidrics_occurs_type_rel.id_hidrics_occurs_type%TYPE;
        --HIDRICS_DEVICE_REL
        l_rank hidrics_occurs_type_rel.rank%TYPE;
    
        l_id_hidrics_occurs_type_array table_number := table_number();
        l_id_hidrics_array             table_number := table_number();
        l_rank_array                   table_number := table_number();
    
        l_count NUMBER := 0;
        l_index NUMBER := 1;
    
        CURSOR c_hidrics_occurs_tp_rel
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT hotr.id_hidrics_occurs_type, hotr.id_hidrics, hotr.rank
              FROM alert_default.hidrics_occurs_type_rel hotr
              JOIN alert_default.hidrics_occurs_type hot
                ON hot.id_hidrics_occurs_type = hotr.id_hidrics_occurs_type
               AND hot.flg_available = g_flg_available
              JOIN alert_default.hidrics_occurs_type_mrk_vrs hotmv
                ON hotmv.id_hidrics_occurs_type = hot.id_hidrics_occurs_type
               AND hotmv.id_market = c_market
               AND hotmv.version = c_version
              JOIN alert_default.hidrics h
                ON h.id_hidrics = hotr.id_hidrics
               AND h.flg_available = g_flg_available
             WHERE hotr.flg_available = g_flg_available
               AND hotr.id_market = hotmv.id_market;
    
    BEGIN
    
        FOR i IN 1 .. i_version.count
        LOOP
        
            g_error := 'OPEN C_HIDRICS_OCCURS_TP_REL CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_OCCURS_TYPE_REL ' || g_error);
            OPEN c_hidrics_occurs_tp_rel(i_version(i), i_id_market);
            LOOP
                FETCH c_hidrics_occurs_tp_rel
                    INTO l_id_hidrics_occurs_type_def, l_id_hidrics_def, l_rank;
                EXIT WHEN c_hidrics_occurs_tp_rel%NOTFOUND;
            
                --HIDRICS_OCCURS_TYPE
                g_error := 'GET HIDRICS_OCCURS_TYPE ID';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_OCCURS_TYPE_REL ' || g_error);
                SELECT nvl((SELECT hot1.id_hidrics_occurs_type
                             FROM hidrics_occurs_type hot1
                            WHERE hot1.id_content = (SELECT hot2.id_content
                                                       FROM alert_default.hidrics_occurs_type hot2
                                                      WHERE hot2.id_hidrics_occurs_type = l_id_hidrics_occurs_type_def
                                                        AND hot2.flg_available = g_flg_available)
                              AND hot1.id_content IS NOT NULL
                              AND hot1.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_hidrics_occurs_type
                  FROM dual;
            
                --HIDRICS          
                g_error := 'GET HIDRICS ID';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_OCCURS_TYPE_REL ' || g_error);
                SELECT nvl((SELECT h1.id_hidrics
                             FROM hidrics h1
                            WHERE h1.id_content = (SELECT h2.id_content
                                                     FROM alert_default.hidrics h2
                                                    WHERE h2.id_hidrics = l_id_hidrics_def
                                                      AND h2.flg_available = g_flg_available)
                              AND h1.id_content IS NOT NULL
                              AND h1.flg_available = g_flg_available
                              AND rownum = 1),
                           0)
                  INTO l_id_hidrics
                  FROM dual;
            
                IF l_id_hidrics_occurs_type != 0
                   AND l_id_hidrics != 0
                THEN
                    g_error := 'COUNT HIDRICS_DEVICE_REL EXISTING RESULTS';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_OCCURS_TYPE_REL ' || g_error);
                
                    SELECT COUNT(hotr.id_hidrics_occurs_type)
                      INTO l_count
                      FROM hidrics_occurs_type_rel hotr
                     WHERE hotr.id_hidrics_occurs_type = l_id_hidrics_occurs_type
                       AND hotr.id_hidrics = l_id_hidrics
                       AND hotr.id_institution = i_id_institution
                       AND hotr.id_market = i_id_market;
                
                    IF l_count = 0
                    THEN
                        l_id_hidrics_occurs_type_array.extend;
                        l_id_hidrics_array.extend;
                        l_rank_array.extend;
                    
                        l_id_hidrics_occurs_type_array(l_index) := l_id_hidrics_occurs_type;
                        l_id_hidrics_array(l_index) := l_id_hidrics;
                        l_rank_array(l_index) := l_rank;
                    
                        l_index := l_index + 1;
                    END IF;
                END IF;
            END LOOP;
            g_error := 'CLOSE C_HIDRICS_OCCURS_TP_REL CURSOR';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_OCCURS_TYPE_REL ' || g_error);
            CLOSE c_hidrics_occurs_tp_rel;
        
        END LOOP;
    
        g_error := 'CLOSE O_ID_HIDRICS_OCCURS_TYPE CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_OCCURS_TYPE_REL ' || g_error);
        OPEN o_id_hidrics_occurs_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_hidrics_occurs_type_array AS table_number));
    
        g_error := 'CLOSE O_ID_HIDRICS CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_OCCURS_TYPE_REL ' || g_error);
        OPEN o_id_hidrics FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_hidrics_array AS table_number));
    
        g_error := 'CLOSE O_RANK CURSOR';
        pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.GET_INST_HIDRICS_OCCURS_TYPE_REL ' || g_error);
        OPEN o_rank FOR
            SELECT column_value
              FROM TABLE(CAST(l_rank_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_HIDRICS_OCCURS_TYPE_REL',
                                              o_error);
            pk_types.open_my_cursor(o_id_hidrics_occurs_type);
            pk_types.open_my_cursor(o_id_hidrics);
            pk_types.open_my_cursor(o_rank);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_inst_hidrics_occurs_tp_rel;
    /********************************************************************************************
    * Set HIDRICS_DEVICE_REL set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @return                      true or false on success or error
    *
    * @author                      MESS
    * @version                     2.6.0.5.1.3
    * @since                       2011/01/13
    ********************************************************************************************/
    FUNCTION set_inst_hidrics_occurs_tp_rel
    (
        i_lang                  IN language.id_language%TYPE,
        i_market                IN table_number,
        i_version               IN table_varchar,
        i_id_institution        IN institution.id_institution%TYPE,
        o_hidrics_occurs_tp_rel OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_c_id_hidrics_occurs_type pk_types.cursor_type;
        l_c_id_hidrics             pk_types.cursor_type;
        l_c_rank                   pk_types.cursor_type;
    
        l_data_id_hidrics_oc_tp table_number;
        l_data_id_hidrics       table_number;
        l_data_rank             table_number;
    
        --LOG ERRORS    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        FOR k IN 1 .. i_market.count
        LOOP
            g_error := 'IF NOT GET_INST_HIDRICS_DEVICE_REL';
            pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_OCCURS_TYPE ' || g_error);
            IF NOT get_inst_hidrics_occurs_tp_rel(i_lang,
                                                  i_market(k),
                                                  i_version,
                                                  i_id_institution,
                                                  l_c_id_hidrics_occurs_type,
                                                  l_c_id_hidrics,
                                                  l_c_rank,
                                                  o_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'o_hidrics_occurs_tp_rel := l_c_id_hidrics_occurs_type';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_OCCURS_TYPE ' || g_error);
                o_hidrics_occurs_tp_rel := l_c_id_hidrics_occurs_type;
            
                LOOP
                    FETCH l_c_id_hidrics_occurs_type BULK COLLECT
                        INTO l_data_id_hidrics_oc_tp LIMIT g_array_size1;
                    FETCH l_c_id_hidrics BULK COLLECT
                        INTO l_data_id_hidrics LIMIT g_array_size1;
                    FETCH l_c_rank BULK COLLECT
                        INTO l_data_rank LIMIT g_array_size1;
                
                    g_error := 'INSERT INTO HIDRICS_OCCURS_TYPE_REL WITH FORALL';
                    pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_OCCURS_TYPE ' || g_error);
                    FORALL j IN 1 .. l_data_id_hidrics_oc_tp.count
                    
                        INSERT INTO hidrics_occurs_type_rel
                            (id_hidrics_occurs_type,
                             id_hidrics,
                             rank,
                             flg_available,
                             id_department,
                             id_dept,
                             id_institution,
                             id_market)
                        VALUES
                            (l_data_id_hidrics_oc_tp(j),
                             l_data_id_hidrics(j),
                             l_data_rank(j),
                             g_flg_available,
                             0,
                             0,
                             i_id_institution,
                             i_market(k));
                
                    EXIT WHEN l_c_id_hidrics_occurs_type%NOTFOUND;
                
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_HIDRICS_OCCURS_TYPE CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_OCCURS_TYPE ' || g_error);
                CLOSE l_c_id_hidrics_occurs_type;
            
                g_error := 'CLOSE L_C_ID_HIDRICS CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_OCCURS_TYPE ' || g_error);
                CLOSE l_c_id_hidrics;
            
                g_error := 'CLOSE L_C_RANK CURSOR';
                pk_alertlog.log_debug('PK_BACKOFFICE_DEFAULT.SET_INST_HIDRICS_OCCURS_TYPE ' || g_error);
                CLOSE l_c_rank;
            
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS_OCCURS_TYPE',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HIDRICS_OCCURS_TYPE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_hidrics_occurs_tp_rel;
    /********************************************************************************************
    * Get Default Habits char relation
    *
    * @param i_lang                Prefered language ID
    * @param i_market                Prefered market ID
    * @param i_version                Prefered content version
    * @param o_habit_char              Habits_characterization ids array
    * @param o_habit              Habit ids array
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.1
    * @since                       2011/04/21
    ********************************************************************************************/
    FUNCTION get_inst_habit_char_rel
    (
        i_lang       IN language.id_language%TYPE,
        i_market     IN market.id_market%TYPE,
        i_version    IN VARCHAR2,
        o_habit_char OUT table_number,
        o_habit      OUT table_number,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        --def
        l_id_habit_char_def habit_characterization.id_habit_characterization%TYPE;
        l_id_habit_def      habit.id_habit%TYPE;
        -- alert
        l_id_habit_char habit_characterization.id_habit_characterization%TYPE;
        l_id_habit      habit.id_habit%TYPE;
    
        l_valid NUMBER;
        -- arrays vars
        l_index NUMBER := 1;
    
        CURSOR c_habit_char_rel
        (
            i_mkt  market.id_market%TYPE,
            i_vers VARCHAR2
        ) IS
            SELECT hcr.id_habit_characterization, hcr.id_habit
              FROM alert_default.habit_charact_relation hcr
             INNER JOIN alert_default.habit h
                ON (h.id_habit = hcr.id_habit AND h.flg_available = pk_alert_constant.get_available)
             INNER JOIN alert_default.habit_mrk_vrs hmv
                ON (hmv.id_habit = h.id_habit AND hmv.id_market = i_mkt AND hmv.version = i_vers)
             INNER JOIN alert_default.habit_characterization hc
                ON (hc.id_habit_characterization = hcr.id_habit_characterization AND
                   hc.flg_available = pk_alert_constant.get_available)
             INNER JOIN alert_default.habit_characterization_mrk_vrs hcmv
                ON (hcmv.id_habit_characterization = hc.id_habit_characterization AND hcmv.id_market = i_mkt AND
                   hcmv.version = i_vers)
             WHERE hcr.flg_available = pk_alert_constant.get_available;
    
    BEGIN
        o_habit_char := table_number();
        o_habit      := table_number();
    
        g_error := 'Open c_habit_char_rel';
        OPEN c_habit_char_rel(i_market, i_version);
        LOOP
            g_error := 'Fetch c_habit_char_rel';
            FETCH c_habit_char_rel
                INTO l_id_habit_char_def, l_id_habit_def;
            EXIT WHEN c_habit_char_rel%NOTFOUND;
        
            g_error := 'get habit alert id';
            SELECT nvl((SELECT h.id_habit
                         FROM habit h
                        WHERE h.id_content = (SELECT def_h.id_content
                                                FROM alert_default.habit def_h
                                               WHERE def_h.id_habit = l_id_habit_def)
                          AND h.flg_available = pk_alert_constant.get_available),
                       0)
              INTO l_id_habit
              FROM dual;
        
            g_error := 'get habit charact alert id';
            SELECT nvl((SELECT hc.id_habit_characterization
                         FROM habit_characterization hc
                        WHERE hc.id_content =
                              (SELECT def_hc.id_content
                                 FROM alert_default.habit_characterization def_hc
                                WHERE def_hc.id_habit_characterization = l_id_habit_char_def)
                          AND hc.flg_available = pk_alert_constant.get_available),
                       0)
              INTO l_id_habit_char
              FROM dual;
        
            IF (l_id_habit_char != 0 AND l_id_habit != 0)
            THEN
                SELECT nvl(COUNT(*), 0)
                  INTO l_valid
                  FROM habit_charact_relation hcr
                 WHERE hcr.id_habit_characterization = l_id_habit_char
                   AND hcr.id_habit = l_id_habit;
            
                IF l_valid = 0
                THEN
                    g_error := 'add to arrays';
                    o_habit_char.extend;
                    o_habit.extend;
                
                    o_habit_char(l_index) := l_id_habit_char;
                    o_habit(l_index) := l_id_habit;
                
                    l_index := l_index + 1;
                END IF;
            END IF;
        
        END LOOP;
        g_error := 'Close c_habit_char_rel';
        CLOSE c_habit_char_rel;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_INST_HABIT_CHAR_REL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_habit_char_rel;
    /********************************************************************************************
    * Set Default Habits Char REl
    *
    * @param i_lang                Prefered language ID
    * @param i_market                Prefered market ID
    * @param i_version                Prefered content version
    * @param o_habit_char              Habits_characterization ids array
    * @param o_habit              Habit ids array
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.1
    * @since                       2011/04/21
    ********************************************************************************************/
    FUNCTION set_inst_habit_char_rel
    (
        i_lang       IN language.id_language%TYPE,
        i_market     IN market.id_market%TYPE,
        i_version    IN VARCHAR2,
        o_habit_char OUT table_number,
        o_habit      OUT table_number,
        o_error      OUT t_error_out
        
    ) RETURN BOOLEAN IS
    
        --error handling
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num   NUMBER;
        error_msg   VARCHAR2(2000);
        l_exception EXCEPTION;
    
    BEGIN
    
        o_habit      := table_number();
        o_habit_char := table_number();
    
        g_error := 'get_inst_habit_char_rel info';
        IF NOT get_inst_habit_char_rel(i_lang, i_market, i_version, o_habit_char, o_habit, o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error := 'FORALL INSERT ';
        
            FORALL i IN 1 .. o_habit_char.count SAVE EXCEPTIONS
            
                INSERT INTO habit_charact_relation
                    (id_habit_characterization, id_habit, flg_available)
                VALUES
                    (o_habit_char(i), o_habit(i), pk_alert_constant.get_available);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HABIT_CHAR_REL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' - (index) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  'SET_INST_HABIT_CHAR_REL',
                                                  o_error);
                pk_utils.undo_changes;
                pk_alert_exceptions.reset_error_state;
            END LOOP;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_HABIT_CHAR_REL',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_habit_char_rel;
    /********************************************************************************************
    * Get a list of supply for a set of markets and versions.
    *
    * @param i_lang                        Prefered language ID
    * @param i_market                      Market ID's
    * @param i_version                     ALERT version's
    * @param i_id_institution              Institution ID
    * @param i_id_software                 Software ID
    * @param o_id_supply                   Cursor of default data
    * @param o_quantity                    Cursor of default data
    * @param o_id_unit_measure             Cursor of default data
    * @param o_flg_cons_type               Cursor of default data
    * @param o_flg_reusable                Cursor of default data
    * @param o_flg_editable                Cursor of default data
    * @param o_total_avail_quantity        Cursor of default data
    * @param o_flg_preparing               Cursor of default data
    * @param o_flg_countable               Cursor of default data
    * @param o_error                       Error
    *
    *
    * @return                              true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           08-NOV-2011
    ********************************************************************************************/
    FUNCTION get_supply_soft_inst
    (
        i_lang                 IN language.id_language%TYPE,
        i_market               IN market.id_market%TYPE,
        i_version              IN VARCHAR2,
        i_id_institution       IN institution.id_institution%TYPE,
        i_id_software          IN software.id_software%TYPE,
        o_id_supply            OUT pk_types.cursor_type,
        o_quantity             OUT pk_types.cursor_type,
        o_id_unit_measure      OUT pk_types.cursor_type,
        o_flg_cons_type        OUT pk_types.cursor_type,
        o_flg_reusable         OUT pk_types.cursor_type,
        o_flg_editable         OUT pk_types.cursor_type,
        o_total_avail_quantity OUT pk_types.cursor_type,
        o_flg_preparing        OUT pk_types.cursor_type,
        o_flg_countable        OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_supply_soft_inst      alert_default.supply_soft_inst.id_supply_soft_inst%TYPE := NULL;
        l_id_supply_def            alert_default.supply_soft_inst.id_supply%TYPE := NULL;
        l_id_supply                alert_default.supply_soft_inst.id_supply%TYPE := NULL;
        l_quantity_def             alert_default.supply_soft_inst.quantity%TYPE := NULL;
        l_id_unit_measure_def      alert_default.supply_soft_inst.id_unit_measure%TYPE := NULL;
        l_flg_cons_type_def        alert_default.supply_soft_inst.flg_cons_type%TYPE := NULL;
        l_flg_reusable_def         alert_default.supply_soft_inst.flg_reusable%TYPE := NULL;
        l_flg_editable_def         alert_default.supply_soft_inst.flg_editable%TYPE := NULL;
        l_total_avail_quantity_def alert_default.supply_soft_inst.total_avail_quantity%TYPE := NULL;
        l_flg_preparing_def        alert_default.supply_soft_inst.flg_preparing%TYPE := NULL;
        l_flg_countable_def        alert_default.supply_soft_inst.flg_countable%TYPE := NULL;
    
        l_id_supply_array            table_number := table_number();
        l_quantity_array             table_number := table_number();
        l_id_unit_measure_array      table_number := table_number();
        l_flg_cons_type_array        table_varchar := table_varchar();
        l_flg_reusable_array         table_varchar := table_varchar();
        l_flg_editable_array         table_varchar := table_varchar();
        l_total_avail_quantity_array table_number := table_number();
        l_flg_preparing_array        table_varchar := table_varchar();
        l_flg_countable_array        table_varchar := table_varchar();
    
        l_index NUMBER := 1;
    
        CURSOR c_sup_soft_inst
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT ss.id_supply,
                            ss.quantity,
                            ss.id_unit_measure,
                            ss.flg_cons_type,
                            ss.flg_reusable,
                            ss.flg_editable,
                            ss.total_avail_quantity,
                            ss.flg_preparing,
                            ss.flg_countable
              FROM alert_default.supply_soft_inst ss
              JOIN alert_default.supply su
                ON (ss.id_supply = su.id_supply AND su.flg_available = pk_alert_constant.get_available)
              JOIN alert_default.supply_mrk_vrs smv
                ON (su.id_supply = smv.id_supply)
             WHERE smv.id_market = c_market
               AND smv.version = c_version
               AND ss.id_software = i_id_software;
    
        -- stats
        l_cnt_get NUMBER(24) := 0;
    BEGIN
        g_func_name := 'GET_SUPPLY_SOFT_INST';
    
        g_error := 'OPEN C_SUP_SOFT_INST';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN c_sup_soft_inst(i_version, i_market);
        LOOP
            FETCH c_sup_soft_inst
                INTO l_id_supply_def,
                     l_quantity_def,
                     l_id_unit_measure_def,
                     l_flg_cons_type_def,
                     l_flg_reusable_def,
                     l_flg_editable_def,
                     l_total_avail_quantity_def,
                     l_flg_preparing_def,
                     l_flg_countable_def;
            EXIT WHEN c_sup_soft_inst%NOTFOUND;
        
            g_error := 'SELECT ID_SUPPLY';
            pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
            SELECT nvl((SELECT su.id_supply
                         FROM supply su
                         JOIN alert_default.supply asu
                           ON (su.id_content = asu.id_content AND asu.flg_available = pk_alert_constant.get_available)
                        WHERE asu.id_supply = l_id_supply_def
                          AND su.flg_available = pk_alert_constant.get_available
                          AND rownum = 1),
                       0)
              INTO l_id_supply
              FROM dual;
        
            g_error := 'SELECT ID_SUPPLY_SOFT_INST';
            pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
            SELECT nvl((SELECT ss.id_supply_soft_inst
                         FROM supply_soft_inst ss
                        WHERE ss.id_institution = i_id_institution
                          AND ss.id_software = i_id_software
                          AND ss.id_supply = l_id_supply
                          AND ss.flg_cons_type = l_flg_cons_type_def
                          AND rownum = 1),
                       0)
              INTO l_id_supply_soft_inst
              FROM dual;
        
            -- process all content fetched in alert_default
            l_cnt_get := l_cnt_get + 1;
        
            IF l_id_supply_soft_inst = 0
               AND l_id_supply != 0
            THEN
                l_id_supply_array.extend;
                l_quantity_array.extend;
                l_id_unit_measure_array.extend;
                l_flg_cons_type_array.extend;
                l_flg_reusable_array.extend;
                l_flg_editable_array.extend;
                l_total_avail_quantity_array.extend;
                l_flg_preparing_array.extend;
                l_flg_countable_array.extend;
            
                l_id_supply_array(l_index) := l_id_supply;
                l_quantity_array(l_index) := l_quantity_def;
                l_id_unit_measure_array(l_index) := l_id_unit_measure_def;
                l_flg_cons_type_array(l_index) := l_flg_cons_type_def;
                l_flg_reusable_array(l_index) := l_flg_reusable_def;
                l_flg_editable_array(l_index) := l_flg_editable_def;
                l_total_avail_quantity_array(l_index) := l_total_avail_quantity_def;
                l_flg_preparing_array(l_index) := l_flg_preparing_def;
                l_flg_countable_array(l_index) := l_flg_countable_def;
            
                l_index := l_index + 1;
            
            END IF;
        END LOOP;
    
        CLOSE c_sup_soft_inst;
    
        g_error := 'OPEN O_ID_SUPPLY';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_id_supply FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_array AS table_number));
    
        g_error := 'OPEN O_QUANTITY';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_quantity FOR
            SELECT column_value
              FROM TABLE(CAST(l_quantity_array AS table_number));
    
        g_error := 'OPEN O_ID_UNIT_MEASURE';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_id_unit_measure FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_unit_measure_array AS table_number));
    
        g_error := 'OPEN O_FLG_CONS_TYPE';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_flg_cons_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_cons_type_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_REUSABLE';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_flg_reusable FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_reusable_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_EDITABLE';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_flg_editable FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_editable_array AS table_varchar));
    
        g_error := 'OPEN O_TOTAL_AVAIL_QUANTITY';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_total_avail_quantity FOR
            SELECT column_value
              FROM TABLE(CAST(l_total_avail_quantity_array AS table_number));
    
        g_error := 'OPEN O_FLG_PREPARING';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_flg_preparing FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_preparing_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_COUNTABLE';
        pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
        OPEN o_flg_countable FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_countable_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_supply);
            pk_types.open_my_cursor(o_quantity);
            pk_types.open_my_cursor(o_id_unit_measure);
            pk_types.open_my_cursor(o_flg_cons_type);
            pk_types.open_my_cursor(o_flg_reusable);
            pk_types.open_my_cursor(o_flg_editable);
            pk_types.open_my_cursor(o_total_avail_quantity);
            pk_types.open_my_cursor(o_flg_preparing);
            pk_types.open_my_cursor(o_flg_countable);
            RETURN FALSE;
    END get_supply_soft_inst;
    /********************************************************************************************
    * Set supplies for a specific institution and software.
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID
    * @param i_version                 Version ID
    * @param i_id_institution          Institution ID
    * @param i_id_software             Software ID
    * @param o_supply                  Cursor of supplies
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           08-NOV-2011
    ********************************************************************************************/
    FUNCTION set_supply_soft_inst
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN market.id_market%TYPE,
        i_version        IN VARCHAR2,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_supply         OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_supply            pk_types.cursor_type;
        l_c_quantity             pk_types.cursor_type;
        l_c_id_unit_measure      pk_types.cursor_type;
        l_c_flg_cons_type        pk_types.cursor_type;
        l_c_flg_reusable         pk_types.cursor_type;
        l_c_flg_editable         pk_types.cursor_type;
        l_c_total_avail_quantity pk_types.cursor_type;
        l_c_flg_preparing        pk_types.cursor_type;
        l_c_flg_countable        pk_types.cursor_type;
    
        l_data_id_supply            table_number := table_number();
        l_data_quantity             table_number := table_number();
        l_data_id_unit_measure      table_number := table_number();
        l_data_flg_cons_type        table_varchar := table_varchar();
        l_data_flg_reusable         table_varchar := table_varchar();
        l_data_flg_editable         table_varchar := table_varchar();
        l_data_total_avail_quantity table_number := table_number();
        l_data_flg_preparing        table_varchar := table_varchar();
        l_data_flg_countable        table_varchar := table_varchar();
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
        -- translation
        dml_errors   EXCEPTION;
        l_table_name user_tables.table_name%TYPE;
        --error handling
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
        -- stats vars
        l_cnt_ins NUMBER(24) := 0;
    BEGIN
        g_func_name  := 'SET_SUPPLY_SOFT_INST';
        l_table_name := 'SUPPLY_SOFT_INST';
        FOR sw IN 1 .. i_id_software.count
        LOOP
            g_error := 'CALL GET_SUPPLY_SOFT_INST';
            pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
            IF NOT get_supply_soft_inst(i_lang                 => i_lang,
                                        i_market               => i_market,
                                        i_version              => i_version,
                                        i_id_institution       => i_id_institution,
                                        i_id_software          => i_id_software(sw),
                                        o_id_supply            => l_c_id_supply,
                                        o_quantity             => l_c_quantity,
                                        o_id_unit_measure      => l_c_id_unit_measure,
                                        o_flg_cons_type        => l_c_flg_cons_type,
                                        o_flg_reusable         => l_c_flg_reusable,
                                        o_flg_editable         => l_c_flg_editable,
                                        o_total_avail_quantity => l_c_total_avail_quantity,
                                        o_flg_preparing        => l_c_flg_preparing,
                                        o_flg_countable        => l_c_flg_countable,
                                        o_error                => l_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error := 'O_SUPPLY = L_C_ID_SUPPLY';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                o_supply := l_c_id_supply;
            
                LOOP
                    FETCH l_c_id_supply BULK COLLECT
                        INTO l_data_id_supply LIMIT g_array_size;
                    FETCH l_c_quantity BULK COLLECT
                        INTO l_data_quantity LIMIT g_array_size;
                    FETCH l_c_id_unit_measure BULK COLLECT
                        INTO l_data_id_unit_measure LIMIT g_array_size;
                    FETCH l_c_flg_cons_type BULK COLLECT
                        INTO l_data_flg_cons_type LIMIT g_array_size;
                    FETCH l_c_flg_reusable BULK COLLECT
                        INTO l_data_flg_reusable LIMIT g_array_size;
                    FETCH l_c_flg_editable BULK COLLECT
                        INTO l_data_flg_editable LIMIT g_array_size;
                    FETCH l_c_total_avail_quantity BULK COLLECT
                        INTO l_data_total_avail_quantity LIMIT g_array_size;
                    FETCH l_c_flg_preparing BULK COLLECT
                        INTO l_data_flg_preparing LIMIT g_array_size;
                    FETCH l_c_flg_countable BULK COLLECT
                        INTO l_data_flg_countable LIMIT g_array_size;
                
                    l_cnt_ins := l_cnt_ins + l_data_id_supply.count;
                
                    g_error := 'INSERT WITH FORALL';
                    pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                    FORALL j IN 1 .. l_data_id_supply.count SAVE EXCEPTIONS
                        INSERT INTO supply_soft_inst
                            (id_supply_soft_inst,
                             id_supply,
                             id_institution,
                             id_software,
                             id_professional,
                             id_dept,
                             quantity,
                             id_unit_measure,
                             flg_cons_type,
                             flg_reusable,
                             flg_editable,
                             total_avail_quantity,
                             flg_preparing,
                             flg_countable)
                        VALUES
                            (seq_supply_soft_inst.nextval,
                             l_data_id_supply(j),
                             i_id_institution,
                             i_id_software(sw),
                             0,
                             0,
                             l_data_quantity(j),
                             l_data_id_unit_measure(j),
                             l_data_flg_cons_type(j),
                             l_data_flg_reusable(j),
                             l_data_flg_editable(j),
                             l_data_total_avail_quantity(j),
                             l_data_flg_preparing(j),
                             l_data_flg_countable(j));
                    EXIT WHEN l_c_id_supply%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_SUPPLY';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_id_supply;
                g_error := 'CLOSE L_C_QUANTITY';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_quantity;
                g_error := 'CLOSE L_C_ID_UNIT_MEASURE';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_id_unit_measure;
                g_error := 'CLOSE L_C_FLG_CONS_TYPE';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_flg_cons_type;
                g_error := 'CLOSE L_C_FLG_REUSABLE';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_flg_reusable;
                g_error := 'CLOSE L_C_FLG_EDITABLE';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_flg_editable;
                g_error := 'CLOSE L_C_TOTAL_AVAIL_QUANTITY';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_total_avail_quantity;
                g_error := 'CLOSE L_C_FLG_PREPARING';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_flg_preparing;
                g_error := 'CLOSE L_C_FLG_COUNTABLE';
                pk_alertlog.log_debug(g_package_name || '.' || g_func_name || ' - ' || g_error);
                CLOSE l_c_flg_countable;
            END IF;
        END LOOP;
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_supply_soft_inst;
    /********************************************************************************************
    * Get a list of supply sup. area for a set of markets and versions.
    *
    * @param i_lang                        Prefered language ID
    * @param i_market                      Market ID's
    * @param i_version                     ALERT version's
    * @param i_id_institution              Institution ID
    * @param i_id_software                 Software ID
    * @param o_id_supply_soft_inst         Cursor of default data
    * @param o_id_supply_area              Cursor of default data
    * @param o_error                       Error
    *
    * @return                              true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           08-NOV-2011
    ********************************************************************************************/
    FUNCTION get_supply_sup_area
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN market.id_market%TYPE,
        i_version             IN VARCHAR2,
        i_id_institution      IN institution.id_institution%TYPE,
        i_id_software         IN software.id_software%TYPE,
        o_id_supply_soft_inst OUT pk_types.cursor_type,
        o_id_supply_area      OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_supply_soft_inst   alert_default.supply_sup_area.id_supply_soft_inst%TYPE := NULL;
        l_supply_sup_area_exist NUMBER(24) := 0;
    
        l_id_supply_soft_inst_def   alert_default.supply_sup_area.id_supply_soft_inst%TYPE := NULL;
        l_id_supply_soft_inst_array table_number := table_number();
        l_supply_content_id         alert_default.supply.id_content%TYPE := NULL;
        l_flg_cons_type_def         supply_soft_inst.flg_cons_type%TYPE;
    
        l_id_supply_area       alert_default.supply_sup_area.id_supply_area%TYPE := NULL;
        l_id_supply_area_array table_number := table_number();
    
        l_index NUMBER := 1;
        -- stats
        l_cnt_get NUMBER(24) := 0;
    
        CURSOR c_sup_area
        (
            c_version  IN VARCHAR2,
            c_market   IN NUMBER,
            c_software IN NUMBER
        ) IS
            SELECT DISTINCT ssa.id_supply_soft_inst, ssa.id_supply_area, su.id_content, ss.flg_cons_type
              FROM alert_default.supply_sup_area ssa
             INNER JOIN alert_default.supply_soft_inst ss
                ON (ssa.id_supply_soft_inst = ss.id_supply_soft_inst)
             INNER JOIN alert_default.supply su
                ON (ss.id_supply = su.id_supply AND su.flg_available = pk_alert_constant.get_available)
             INNER JOIN alert_default.supply_mrk_vrs smv
                ON (su.id_supply = smv.id_supply)
             INNER JOIN supply_area sa
                ON (sa.id_supply_area = ssa.id_supply_area)
             WHERE smv.id_market = c_market
               AND smv.version = c_version
               AND ss.id_software = i_id_software
               AND ssa.flg_available = g_flg_available
               AND ss.id_software = c_software;
    BEGIN
        g_func_name := 'GET_SUPPLY_SUP_AREA';
    
        g_error := 'OPEN C_SUP_AREA';
        OPEN c_sup_area(i_version, i_market, i_id_software);
        LOOP
            FETCH c_sup_area
                INTO l_id_supply_soft_inst_def, l_id_supply_area, l_supply_content_id, l_flg_cons_type_def;
            EXIT WHEN c_sup_area%NOTFOUND;
        
            g_error := 'SELECT ID_SUPPLY_SOFT_INST';
            SELECT nvl((SELECT ssi.id_supply_soft_inst
                         FROM supply_soft_inst ssi
                        INNER JOIN supply s
                           ON (s.id_supply = ssi.id_supply AND s.flg_available = pk_alert_constant.get_available)
                        WHERE ssi.id_institution = i_id_institution
                          AND ssi.id_software = i_id_software
                          AND s.id_content = l_supply_content_id
                          AND ssi.flg_cons_type = l_flg_cons_type_def
                          AND rownum = 1),
                       0)
              INTO l_id_supply_soft_inst
              FROM dual;
        
            g_error := 'CHECK RECORD CONFIGURATION ON SUPPLY_SUP_AREA';
            SELECT nvl(COUNT(*), 0)
              INTO l_supply_sup_area_exist
              FROM supply_sup_area ssa
             WHERE ssa.id_supply_area = l_id_supply_area
               AND ssa.id_supply_soft_inst = l_id_supply_soft_inst
               AND ssa.flg_available = pk_alert_constant.get_available;
        
            -- process all content fetched in alert_default
            l_cnt_get := l_cnt_get + 1;
        
            IF l_id_supply_soft_inst != 0
               AND l_supply_sup_area_exist = 0
            THEN
                l_id_supply_soft_inst_array.extend;
                l_id_supply_area_array.extend;
            
                l_id_supply_soft_inst_array(l_index) := l_id_supply_soft_inst;
                l_id_supply_area_array(l_index) := l_id_supply_area;
            
                l_index := l_index + 1;
            END IF;
        END LOOP;
    
        CLOSE c_sup_area;
    
        g_error := 'OPEN O_ID_SUPPLY_SOFT_INST';
        OPEN o_id_supply_soft_inst FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_soft_inst_array AS table_number));
        g_error := 'OPEN O_ID_SUPPLY_AREA';
        OPEN o_id_supply_area FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_area_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_supply_soft_inst);
            pk_types.open_my_cursor(o_id_supply_area);
            RETURN FALSE;
    END get_supply_sup_area;

    /********************************************************************************************
    * Set supply sup. area for a specific market and version.
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID
    * @param i_version                 Version ID
    * @param i_id_institution          Institution ID
    * @param i_id_software             Software ID
    * @param o_id_supply_soft_inst     Cursor of supply soft. inst.
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           08-NOV-2011
    ********************************************************************************************/
    FUNCTION set_supply_sup_area
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN market.id_market%TYPE,
        i_version             IN VARCHAR2,
        i_id_institution      IN institution.id_institution%TYPE,
        i_id_software         IN table_number,
        o_id_supply_soft_inst OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_supply_area      pk_types.cursor_type;
        l_c_id_supply_soft_inst pk_types.cursor_type;
    
        l_data_id_supply_area      table_number := table_number();
        l_data_id_supply_soft_inst table_number := table_number();
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        -- stats vars
        l_cnt_ins NUMBER(24) := 0;
        -- translation
        dml_errors   EXCEPTION;
        l_table_name user_tables.table_name%TYPE;
        --error handling
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    BEGIN
        g_func_name  := 'SET_SUPPLY_SUP_AREA';
        l_table_name := 'SUPPLY_SUP_AREA';
        FOR sw IN 1 .. i_id_software.count
        LOOP
            g_error := 'CALL GET_SUPPLY_SUP_AREA';
            IF NOT get_supply_sup_area(i_lang                => i_lang,
                                       i_market              => i_market,
                                       i_version             => i_version,
                                       i_id_institution      => i_id_institution,
                                       i_id_software         => i_id_software(sw),
                                       o_id_supply_soft_inst => l_c_id_supply_soft_inst,
                                       o_id_supply_area      => l_c_id_supply_area,
                                       o_error               => l_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error               := 'o_id_supply_soft_inst = l_c_id_supply_soft_inst';
                o_id_supply_soft_inst := l_c_id_supply_soft_inst;
                LOOP
                    FETCH l_c_id_supply_soft_inst BULK COLLECT
                        INTO l_data_id_supply_soft_inst LIMIT g_array_size;
                
                    FETCH l_c_id_supply_area BULK COLLECT
                        INTO l_data_id_supply_area LIMIT g_array_size;
                
                    l_cnt_ins := l_cnt_ins + l_data_id_supply_soft_inst.count;
                
                    g_error := 'INSERT WITH FORALL';
                    FORALL j IN 1 .. l_data_id_supply_soft_inst.count SAVE EXCEPTIONS
                        INSERT INTO supply_sup_area
                            (id_supply_area, id_supply_soft_inst, flg_available)
                        VALUES
                            (l_data_id_supply_area(j), l_data_id_supply_soft_inst(j), g_flg_available);
                    EXIT WHEN l_c_id_supply_soft_inst%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_SUPPLY_SOFT_INST';
                CLOSE l_c_id_supply_soft_inst;
            END IF;
        END LOOP;
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_supply_sup_area;
    /********************************************************************************************
    * Get a list of supply loc. default for a set of markets and versions.
    *
    * @param i_lang                        Prefered language ID
    * @param i_market                      Market ID's
    * @param i_version                     ALERT version's
    * @param i_id_institution              Institution ID
    * @param i_id_software                 Software ID
    * @param o_id_supply_location          Cursor of default data
    * @param o_id_supply_soft_inst         Cursor of default data
    * @param o_flg_default                 Cursor of default data
    * @param o_error                       Error
    *
    * @return                              true or false on success or error
    *
    * @author                      RMGM
    * @version                     2.6.1.3
    * @since                       2011/11/09
    ********************************************************************************************/
    FUNCTION get_supply_loc_default
    (
        i_lang                IN language.id_language%TYPE,
        i_market              IN market.id_market%TYPE,
        i_version             IN VARCHAR2,
        i_id_institution      IN institution.id_institution%TYPE,
        i_id_software         IN software.id_software%TYPE,
        o_id_supply_location  OUT pk_types.cursor_type,
        o_id_supply_soft_inst OUT pk_types.cursor_type,
        o_flg_default         OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_supply_loc_default_exist alert_default.supply_loc_default.id_supply_loc_default%TYPE := NULL;
        l_id_supply_location_def      alert_default.supply_loc_default.id_supply_location%TYPE := NULL;
        l_id_supply_soft_inst         alert_default.supply_loc_default.id_supply_soft_inst%TYPE := NULL;
        l_id_supply_soft_inst_def     alert_default.supply_loc_default.id_supply_soft_inst%TYPE := NULL;
        l_flg_default_def             alert_default.supply_loc_default.flg_default%TYPE := NULL;
        l_supply_content_id           supply.id_content%TYPE := NULL;
    
        l_id_supply_location_array  table_number := table_number();
        l_id_supply_soft_inst_array table_number := table_number();
        l_flg_default_array         table_varchar := table_varchar();
    
        l_index NUMBER := 1;
        -- stats
        l_cnt_get NUMBER(24) := 0;
    
        CURSOR c_sup_loc_def
        (
            c_version  IN VARCHAR2,
            c_market   IN NUMBER,
            c_software IN software.id_software%TYPE
        ) IS
            SELECT DISTINCT sd.id_supply_location, sd.flg_default, s.id_content
              FROM alert_default.supply_loc_default sd
             INNER JOIN alert_default.supply_soft_inst ssi
                ON (ssi.id_supply_soft_inst = sd.id_supply_soft_inst)
             INNER JOIN alert_default.supply s
                ON (s.id_supply = ssi.id_supply AND s.flg_available = pk_alert_constant.get_available)
             INNER JOIN alert_default.supply_mrk_vrs smv
                ON (smv.id_supply = s.id_supply)
             INNER JOIN supply_location sl
                ON (sl.id_supply_location = sd.id_supply_location)
             WHERE smv.id_market = c_market
               AND smv.version = c_version
               AND ssi.id_software = c_software;
    BEGIN
        g_func_name := 'GET_SUPPLY_LOC_DEFAULT';
    
        g_error := 'OPEN C_SUP_LOC_DEF';
        OPEN c_sup_loc_def(i_version, i_market, i_id_software);
        LOOP
            FETCH c_sup_loc_def
                INTO l_id_supply_location_def, l_flg_default_def, l_supply_content_id;
            EXIT WHEN c_sup_loc_def%NOTFOUND;
        
            g_error := 'SELECT ID_SUPPLY_SOFT_INST';
            SELECT nvl((SELECT ssi.id_supply_soft_inst
                         FROM supply_soft_inst ssi
                        INNER JOIN supply s
                           ON (s.id_supply = ssi.id_supply AND s.flg_available = pk_alert_constant.get_available)
                        WHERE ssi.id_institution = i_id_institution
                          AND ssi.id_software = i_id_software
                          AND s.id_content = l_supply_content_id
                          AND rownum = 1),
                       0)
              INTO l_id_supply_soft_inst
              FROM dual;
        
            g_error := 'SELECT ID_SUPPLY_LOC_DEFAULT';
            SELECT nvl((SELECT d.id_supply_loc_default
                         FROM supply_loc_default d
                        WHERE d.id_supply_location = l_id_supply_location_def
                          AND d.id_supply_soft_inst = l_id_supply_soft_inst
                          AND rownum = 1),
                       0)
              INTO l_id_supply_loc_default_exist
              FROM dual;
            -- add all content processed in alert_default
            l_cnt_get := l_cnt_get + 1;
        
            IF l_id_supply_loc_default_exist = 0
               AND (l_id_supply_soft_inst != 0 AND l_id_supply_soft_inst IS NOT NULL)
            THEN
            
                l_id_supply_location_array.extend;
                l_id_supply_soft_inst_array.extend;
                l_flg_default_array.extend;
            
                l_id_supply_location_array(l_index) := l_id_supply_location_def;
                l_id_supply_soft_inst_array(l_index) := l_id_supply_soft_inst;
                l_flg_default_array(l_index) := l_flg_default_def;
            
                l_index := l_index + 1;
            END IF;
        END LOOP;
    
        CLOSE c_sup_loc_def;
    
        g_error := 'OPEN O_ID_SUPPLY_LOCATION';
        OPEN o_id_supply_location FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_location_array AS table_number));
    
        g_error := 'OPEN O_ID_SUPPLY_SOFT_INST';
        OPEN o_id_supply_soft_inst FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_soft_inst_array AS table_number));
    
        g_error := 'OPEN O_FLG_DEFAULT';
        OPEN o_flg_default FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_default_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_supply_location);
            pk_types.open_my_cursor(o_id_supply_soft_inst);
            pk_types.open_my_cursor(o_flg_default);
            RETURN FALSE;
    END get_supply_loc_default;
    /********************************************************************************************
    * Set supply loc. default for a specific market and version.
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID
    * @param i_version                 Version ID
    * @param i_id_institution          Institution ID
    * @param i_id_software             Software ID
    * @param o_id_supply_location      Cursor of supply location
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           09-NOV-2011
    ********************************************************************************************/
    FUNCTION set_supply_loc_default
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN market.id_market%TYPE,
        i_version            IN VARCHAR2,
        i_id_institution     IN institution.id_institution%TYPE,
        i_id_software        IN table_number,
        o_id_supply_location OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_supply_location  pk_types.cursor_type;
        l_c_id_supply_soft_inst pk_types.cursor_type;
        l_c_flg_default         pk_types.cursor_type;
    
        l_data_id_supply_location  table_number := table_number();
        l_data_id_supply_soft_inst table_number := table_number();
        l_data_flg_default         table_varchar := table_varchar();
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        -- stats vars
        l_cnt_ins NUMBER(24) := 0;
    
        -- translation
        dml_errors   EXCEPTION;
        l_table_name user_tables.table_name%TYPE;
        --error handling
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    BEGIN
        g_func_name  := 'SET_SUPPLY_LOC_DEFAULT';
        l_table_name := 'SUPPLY_LOC_DEFAULT';
        FOR sw IN 1 .. i_id_software.count
        LOOP
            g_error := 'CALL GET_SUPPLY_LOC_DEFAULT';
            IF NOT get_supply_loc_default(i_lang                => i_lang,
                                          i_market              => i_market,
                                          i_version             => i_version,
                                          i_id_institution      => i_id_institution,
                                          i_id_software         => i_id_software(sw),
                                          o_id_supply_location  => l_c_id_supply_location,
                                          o_id_supply_soft_inst => l_c_id_supply_soft_inst,
                                          o_flg_default         => l_c_flg_default,
                                          o_error               => l_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error              := 'o_id_supply_location = l_c_id_supply_location';
                o_id_supply_location := l_c_id_supply_location;
                LOOP
                    FETCH l_c_id_supply_location BULK COLLECT
                        INTO l_data_id_supply_location LIMIT g_array_size;
                
                    FETCH l_c_id_supply_soft_inst BULK COLLECT
                        INTO l_data_id_supply_soft_inst LIMIT g_array_size;
                
                    FETCH l_c_flg_default BULK COLLECT
                        INTO l_data_flg_default LIMIT g_array_size;
                
                    l_cnt_ins := l_cnt_ins + l_data_id_supply_location.count;
                
                    g_error := 'INSERT WITH FORALL';
                    FORALL j IN 1 .. l_data_id_supply_location.count SAVE EXCEPTIONS
                        INSERT INTO supply_loc_default
                            (id_supply_location, id_supply_loc_default, id_supply_soft_inst, flg_default)
                        VALUES
                            (l_data_id_supply_location(j),
                             seq_supply_loc_default.nextval,
                             l_data_id_supply_soft_inst(j),
                             l_data_flg_default(j));
                    EXIT WHEN l_c_id_supply_location%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_SUPPLY_LOCATION';
                CLOSE l_c_id_supply_location;
                g_error := 'CLOSE L_C_ID_SUPPLY_SOFT_INST';
                CLOSE l_c_id_supply_soft_inst;
                g_error := 'CLOSE L_C_FLG_DEFAULT';
                CLOSE l_c_flg_default;
            
            END IF;
        END LOOP;
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_supply_loc_default;
    /********************************************************************************************
    * Get a list of supply context for a set of markets and versions.
    *
    * @param i_lang                        Prefered language ID
    * @param i_market                      Market ID's
    * @param i_version                     ALERT version's
    * @param i_id_institution              Institution ID
    * @param i_id_software                 Software ID
    * @param o_id_supply                   Cursor of default data
    * @param o_quantity                    Cursor of default data
    * @param o_id_unit_measure             Cursor of default data
    * @param o_id_context                  Cursor of default data
    * @param o_flg_context                 Cursor of default data
    * @param o_error                       Error
    *
    * @return                              true or false on success or error
    *
    * @author                      RMGM
    * @version                     2.6.1.5
    * @since                       2011/11/09
    ********************************************************************************************/
    FUNCTION get_supply_context
    (
        i_lang            IN language.id_language%TYPE,
        i_market          IN market.id_market%TYPE,
        i_version         IN VARCHAR2,
        i_id_institution  IN institution.id_institution%TYPE,
        i_id_software     IN software.id_software%TYPE,
        o_id_supply       OUT pk_types.cursor_type,
        o_quantity        OUT pk_types.cursor_type,
        o_id_unit_measure OUT pk_types.cursor_type,
        o_id_context      OUT pk_types.cursor_type,
        o_flg_context     OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_supply_context   alert_default.supply_context.id_supply_context%TYPE := NULL;
        l_id_supply_def       alert_default.supply_context.id_supply%TYPE := NULL;
        l_id_supply           alert_default.supply_context.id_supply%TYPE := NULL;
        l_quantity_def        alert_default.supply_context.quantity%TYPE := NULL;
        l_id_unit_measure_def alert_default.supply_context.id_unit_measure%TYPE := NULL;
        l_id_context_def      alert_default.supply_context.id_context%TYPE := NULL;
        l_flg_context_def     alert_default.supply_context.flg_context%TYPE := NULL;
    
        l_id_context_alert alert_default.supply_context.id_context%TYPE := NULL;
    
        l_id_supply_array       table_number := table_number();
        l_quantity_array        table_number := table_number();
        l_id_unit_measure_array table_number := table_number();
        l_id_context_array      table_number := table_number();
        l_flg_context_array     table_varchar := table_varchar();
    
        l_index NUMBER := 1;
    
        -- context constants
        l_medication_ctx CONSTANT VARCHAR2(1) := 'M';
        l_interv_ctx     CONSTANT VARCHAR2(1) := 'P';
        l_mfr_ctx        CONSTANT VARCHAR2(1) := 'F';
        l_icnp_ctx       CONSTANT VARCHAR2(1) := 'I';
        l_labtest_ctx    CONSTANT VARCHAR2(1) := 'A';
        l_imageexm_ctx   CONSTANT VARCHAR2(1) := 'E';
        l_otherexm_ctx   CONSTANT VARCHAR2(1) := 'O';
        l_srinterv_ctx   CONSTANT VARCHAR2(1) := 'S';
        -- stats
        l_cnt_get NUMBER(24) := 0;
        CURSOR c_sup_context
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT sc.id_supply, sc.quantity, sc.id_unit_measure, sc.id_context, sc.flg_context
              FROM alert_default.supply_context sc
              JOIN alert_default.supply su
                ON (su.id_supply = sc.id_supply AND su.flg_available = pk_alert_constant.get_available)
              JOIN alert_default.supply_mrk_vrs smv
                ON (smv.id_supply = su.id_supply)
             WHERE smv.id_market = c_market
               AND smv.version = c_version
               AND sc.id_software = i_id_software;
    BEGIN
        g_func_name := 'GET_SUPPLY_CONTEXT';
    
        g_error := 'OPEN C_SUP_CONTEXT';
        OPEN c_sup_context(i_version, i_market);
        LOOP
            FETCH c_sup_context
                INTO l_id_supply_def, l_quantity_def, l_id_unit_measure_def, l_id_context_def, l_flg_context_def;
            EXIT WHEN c_sup_context%NOTFOUND;
        
            g_error := 'SELECT ID_SUPPLY';
            SELECT nvl((SELECT su.id_supply
                         FROM supply su
                         JOIN alert_default.supply asu
                           ON (su.id_content = asu.id_content AND asu.flg_available = pk_alert_constant.get_available)
                        WHERE asu.id_supply = l_id_supply_def
                          AND su.flg_available = pk_alert_constant.get_available
                          AND rownum = 1),
                       0)
              INTO l_id_supply
              FROM dual;
        
            g_error := 'GET ID_CONTEXT';
            IF (l_flg_context_def = l_medication_ctx)
            THEN
                -- compare medication
                SELECT nvl((SELECT mm.id_drug
                             FROM mi_med mm
                            WHERE mm.id_drug = to_char(l_id_context_def)
                              AND mm.flg_available = pk_alert_constant.get_available
                              AND EXISTS (SELECT 0
                                     FROM drug_dep_clin_serv ddcs
                                    WHERE ddcs.id_institution = i_id_institution
                                      AND ddcs.id_software = i_id_software
                                      AND ddcs.id_drug = mm.id_drug
                                      AND rownum = 1)),
                           0)
                  INTO l_id_context_alert
                  FROM dual;
            
            ELSIF (l_flg_context_def = l_interv_ctx OR l_flg_context_def = l_mfr_ctx)
            THEN
                -- compare procedures
                SELECT nvl((SELECT i.id_intervention
                             FROM intervention i
                            INNER JOIN alert_default.intervention def_i
                               ON (def_i.id_content = i.id_content AND def_i.flg_status = 'A')
                            WHERE i.flg_status = 'A'
                              AND def_i.id_intervention = l_id_context_def
                              AND EXISTS (SELECT 0
                                     FROM interv_dep_clin_serv idcs
                                    WHERE idcs.id_institution = i_id_institution
                                      AND idcs.id_software = i_id_software
                                      AND idcs.id_intervention = i.id_intervention
                                      AND rownum = 1)),
                           0)
                  INTO l_id_context_alert
                  FROM dual;
            ELSIF (l_flg_context_def = l_icnp_ctx)
            THEN
                -- compare nursing procedures
                SELECT nvl((SELECT ic.id_composition
                             FROM icnp_composition ic
                            INNER JOIN alert_default.icnp_composition def_ic
                               ON (def_ic.id_content = ic.id_content AND
                                  def_ic.flg_available = pk_alert_constant.get_available AND
                                  def_ic.id_software = ic.id_software)
                            WHERE ic.flg_available = pk_alert_constant.get_available
                              AND def_ic.id_composition = l_id_context_def
                              AND ic.id_software = i_id_software
                              AND ic.id_institution = i_id_institution),
                           0)
                  INTO l_id_context_alert
                  FROM dual;
            
            ELSIF (l_flg_context_def = l_labtest_ctx)
            THEN
                -- compare lab tests
                SELECT nvl((SELECT a.id_analysis
                             FROM analysis a
                            INNER JOIN alert_default.analysis def_a
                               ON (def_a.id_content = a.id_content AND
                                  def_a.flg_available = pk_alert_constant.get_available)
                            WHERE a.flg_available = pk_alert_constant.get_available
                              AND def_a.id_analysis = l_id_context_def
                              AND EXISTS (SELECT 0
                                     FROM analysis_instit_soft ais
                                    WHERE ais.id_institution = i_id_institution
                                      AND ais.id_software = i_id_software
                                      AND ais.id_analysis = a.id_analysis
                                      AND ais.flg_available = pk_alert_constant.get_available
                                      AND rownum = 1)),
                           0)
                  INTO l_id_context_alert
                  FROM dual;
            
            ELSIF (l_flg_context_def = l_imageexm_ctx OR l_flg_context_def = l_otherexm_ctx)
            THEN
                -- compare exams
                SELECT nvl((SELECT e.id_exam
                             FROM exam e
                            INNER JOIN alert_default.exam def_e
                               ON (def_e.id_content = e.id_content AND
                                  def_e.flg_available = pk_alert_constant.get_available)
                            WHERE e.flg_available = pk_alert_constant.get_available
                              AND def_e.id_exam = l_id_context_def
                              AND EXISTS (SELECT 0
                                     FROM exam_dep_clin_serv edcs
                                    WHERE edcs.id_institution = i_id_institution
                                      AND edcs.id_software = i_id_software
                                      AND edcs.id_exam = e.id_exam
                                      AND rownum = 1)),
                           0)
                  INTO l_id_context_alert
                  FROM dual;
            ELSIF (l_flg_context_def = l_srinterv_ctx)
            THEN
                -- compare surgical interventions
                SELECT nvl((SELECT sri.id_intervention
                             FROM intervention sri
                            INNER JOIN alert_default.intervention def_sri
                               ON (def_sri.id_content = sri.id_content AND def_sri.flg_status = 'A')
                            WHERE sri.flg_status = 'A'
                              AND def_sri.id_intervention = l_id_context_def
                              AND EXISTS (SELECT 0
                                     FROM interv_dep_clin_serv srdcs
                                    WHERE srdcs.id_institution = i_id_institution
                                      AND srdcs.id_software = i_id_software
                                      AND srdcs.id_intervention = sri.id_intervention
                                      AND rownum = 1)),
                           0)
                  INTO l_id_context_alert
                  FROM dual;
            ELSE
                l_id_context_alert := NULL;
            END IF;
        
            g_error := 'CHECK IF RECORD EXISTS';
            IF l_id_context_alert IS NULL
            THEN
                SELECT nvl((SELECT sc.id_supply_context
                             FROM supply_context sc
                            WHERE sc.id_institution = i_id_institution
                              AND sc.id_software = i_id_software
                              AND sc.id_supply = l_id_supply
                              AND sc.id_context IS NULL
                              AND rownum = 1),
                           0)
                  INTO l_id_supply_context
                  FROM dual;
            ELSE
                SELECT nvl((SELECT sc.id_supply_context
                             FROM supply_context sc
                            WHERE sc.id_institution = i_id_institution
                              AND sc.id_software = i_id_software
                              AND sc.id_supply = l_id_supply
                              AND sc.id_context = l_id_context_alert
                              AND sc.flg_context = l_flg_context_def
                              AND rownum = 1),
                           0)
                  INTO l_id_supply_context
                  FROM dual;
            END IF;
            -- process all content fetched in alert_default
            l_cnt_get := l_cnt_get + 1;
        
            IF l_id_supply_context = 0
               AND (l_id_context_alert != 0 AND l_id_context_alert IS NOT NULL)
               AND (l_id_supply != 0 AND l_id_supply IS NOT NULL)
            THEN
                l_id_supply_array.extend;
                l_quantity_array.extend;
                l_id_unit_measure_array.extend;
                l_id_context_array.extend;
                l_flg_context_array.extend;
            
                l_id_supply_array(l_index) := l_id_supply;
                l_quantity_array(l_index) := l_quantity_def;
                l_id_unit_measure_array(l_index) := l_id_unit_measure_def;
                l_id_context_array(l_index) := l_id_context_def;
                l_flg_context_array(l_index) := l_flg_context_def;
            
                l_index := l_index + 1;
            END IF;
        END LOOP;
    
        CLOSE c_sup_context;
    
        g_error := 'OPEN O_ID_SUPPLY';
        OPEN o_id_supply FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_array AS table_number));
    
        g_error := 'OPEN O_QUANTITY';
        OPEN o_quantity FOR
            SELECT column_value
              FROM TABLE(CAST(l_quantity_array AS table_number));
    
        g_error := 'OPEN O_ID_UNIT_MEASURE';
        OPEN o_id_unit_measure FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_unit_measure_array AS table_number));
    
        g_error := 'OPEN O_ID_CONTEXT';
        OPEN o_id_context FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_context_array AS table_number));
    
        g_error := 'OPEN O_FLG_CONTEXT';
        OPEN o_flg_context FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_context_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_supply);
            pk_types.open_my_cursor(o_quantity);
            pk_types.open_my_cursor(o_id_unit_measure);
            pk_types.open_my_cursor(o_id_context);
            pk_types.open_my_cursor(o_flg_context);
            RETURN FALSE;
    END get_supply_context;
    /********************************************************************************************
    * Set supplies context.
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID
    * @param i_version                 Version
    * @param i_id_institution          Institution ID
    * @param i_id_software             Software ID
    * @param o_id_supply               Cursor of supplies identifier
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           09-NOV-2011
    ********************************************************************************************/
    FUNCTION set_supply_context
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN market.id_market%TYPE,
        i_version        IN VARCHAR2,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_id_supply      OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_supply       pk_types.cursor_type;
        l_c_quantity        pk_types.cursor_type;
        l_c_id_unit_measure pk_types.cursor_type;
        l_c_id_context      pk_types.cursor_type;
        l_c_flg_context     pk_types.cursor_type;
    
        l_data_id_supply       table_number := table_number();
        l_data_quantity        table_number := table_number();
        l_data_id_unit_measure table_number := table_number();
        l_data_id_context      table_varchar := table_varchar();
        l_data_flg_context     table_varchar := table_varchar();
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        -- stats vars
        l_cnt_ins NUMBER(24) := 0;
        -- translation
        dml_errors   EXCEPTION;
        l_table_name user_tables.table_name%TYPE;
        --error handling
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    BEGIN
        g_func_name  := 'SET_SUPPLY_TYPE';
        l_table_name := 'SUPPLY_CONTEXT';
        FOR sw IN 1 .. i_id_software.count
        LOOP
            g_error := 'CALL GET_SUPPLY_CONTEXT';
            IF NOT get_supply_context(i_lang            => i_lang,
                                      i_market          => i_market,
                                      i_version         => i_version,
                                      i_id_institution  => i_id_institution,
                                      i_id_software     => i_id_software(sw),
                                      o_id_supply       => l_c_id_supply,
                                      o_quantity        => l_c_quantity,
                                      o_id_unit_measure => l_c_id_unit_measure,
                                      o_id_context      => l_c_id_context,
                                      o_flg_context     => l_c_flg_context,
                                      o_error           => l_error)
            THEN
                RAISE l_exception;
            ELSE
                g_error     := 'O_ID_SUPPLY = L_C_ID_SUPPLY';
                o_id_supply := l_c_id_supply;
            
                LOOP
                    FETCH l_c_id_supply BULK COLLECT
                        INTO l_data_id_supply LIMIT g_array_size;
                
                    FETCH l_c_quantity BULK COLLECT
                        INTO l_data_quantity LIMIT g_array_size;
                
                    FETCH l_c_id_unit_measure BULK COLLECT
                        INTO l_data_id_unit_measure LIMIT g_array_size;
                
                    FETCH l_c_id_context BULK COLLECT
                        INTO l_data_id_context LIMIT g_array_size;
                
                    FETCH l_c_flg_context BULK COLLECT
                        INTO l_data_flg_context LIMIT g_array_size;
                
                    l_cnt_ins := l_cnt_ins + l_data_id_supply.count;
                
                    g_error := 'INSERT WITH FORALL';
                    FORALL j IN 1 .. l_data_id_supply.count SAVE EXCEPTIONS
                        INSERT INTO supply_context
                            (id_supply_context,
                             id_supply,
                             quantity,
                             id_unit_measure,
                             id_context,
                             flg_context,
                             id_software,
                             id_institution,
                             id_dept,
                             id_professional)
                        VALUES
                            (seq_supply_context.nextval,
                             l_data_id_supply(j),
                             l_data_quantity(j),
                             l_data_id_unit_measure(j),
                             l_data_id_context(j),
                             l_data_flg_context(j),
                             i_id_software(sw),
                             i_id_institution,
                             0,
                             0);
                    EXIT WHEN l_c_id_supply%NOTFOUND;
                END LOOP;
            
                g_error := 'CLOSE L_C_ID_SUPPLY';
                CLOSE l_c_id_supply;
                g_error := 'CLOSE L_C_QUANTITY';
                CLOSE l_c_quantity;
                g_error := 'CLOSE L_C_ID_UNIT_MEASURE';
                CLOSE l_c_id_unit_measure;
                g_error := 'CLOSE L_C_ID_CONTEXT';
                CLOSE l_c_id_context;
                g_error := 'CLOSE L_C_FLG_CONTEXT';
                CLOSE l_c_flg_context;
            
            END IF;
        END LOOP;
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_supply_context;
    /********************************************************************************************
    * Get Clinical Decision Rules definitions for a set of markets and versions.
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_id_supply_reason    Cursor of default data
    * @param o_id_content          Cursor of default data
    * @param o_flg_type            Cursor of default data
    * @param o_code_supply_reason  Cursor of default data
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           09-NOV-2011
    ********************************************************************************************/
    FUNCTION get_supply_reason
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN market.id_market%TYPE,
        i_version          IN VARCHAR2,
        o_id_supply_reason OUT pk_types.cursor_type,
        o_id_content       OUT pk_types.cursor_type,
        o_flg_type         OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_supply_reason supply_reason.id_supply_reason%TYPE := NULL;
    
        l_flg_type_def          alert_default.supply_reason.flg_type%TYPE := NULL;
        l_id_content_def        alert_default.supply_reason.id_content%TYPE := NULL;
        l_id_supply_reason_last supply_reason.id_supply_reason%TYPE;
    
        l_id_supply_reason_array table_number := table_number();
        l_flg_type_array         table_varchar := table_varchar();
        l_id_content_array       table_varchar := table_varchar();
    
        l_index NUMBER := 1;
    
        -- stats
        l_cnt_get NUMBER(24) := 0;
    
        CURSOR c_supply_reason
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT DISTINCT sr.flg_type, sr.id_content
              FROM alert_default.supply_reason sr
              JOIN alert_default.supply_reason_mrk_vrs srmv
                ON (sr.id_supply_reason = srmv.id_supply_reason)
             WHERE srmv.id_market = c_market
               AND srmv.version = c_version
               AND sr.flg_available = g_flg_available;
    BEGIN
        g_func_name := 'GET_SUPPLY_REASON';
    
        g_error := 'GET MAX(ID_SUPPLY_REASON)';
        SELECT MAX(id_supply_reason)
          INTO l_id_supply_reason_last
          FROM supply_reason;
    
        g_error := 'OPEN C_SUPPLY_REASON';
        OPEN c_supply_reason(i_version, i_market);
        LOOP
            FETCH c_supply_reason
                INTO l_flg_type_def, l_id_content_def;
            EXIT WHEN c_supply_reason%NOTFOUND;
        
            g_error := 'SELECT ID_SUPPLY_REASON';
            SELECT nvl((SELECT su.id_supply_reason
                         FROM supply_reason su
                        WHERE su.id_institution = 0
                          AND su.id_content = l_id_content_def
                          AND su.id_content IS NOT NULL
                          AND su.flg_available = pk_alert_constant.get_available
                          AND rownum = 1),
                       0)
              INTO l_id_supply_reason
              FROM dual;
            -- process all content fetched in alert_default
            l_cnt_get := l_cnt_get + 1;
            IF l_id_supply_reason = 0
            THEN
                l_id_supply_reason_last := l_id_supply_reason_last + 1;
            
                l_id_supply_reason_array.extend;
                l_flg_type_array.extend;
                l_id_content_array.extend;
            
                l_id_supply_reason_array(l_index) := l_id_supply_reason_last;
                l_flg_type_array(l_index) := l_flg_type_def;
                l_id_content_array(l_index) := l_id_content_def;
            
                l_index := l_index + 1;
            END IF;
        END LOOP;
        g_error := 'CLOSE C_SUPPLY_REASON';
        CLOSE c_supply_reason;
    
        g_error := 'OPEN O_ID_SUPPLY_REASON';
        OPEN o_id_supply_reason FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_reason_array AS table_number));
    
        g_error := 'OPEN O_ID_CONTENT';
        OPEN o_id_content FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_content_array AS table_varchar));
    
        g_error := 'OPEN O_FLG_TYPE';
        OPEN o_flg_type FOR
            SELECT column_value
              FROM TABLE(CAST(l_flg_type_array AS table_varchar));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_supply_reason);
            pk_types.open_my_cursor(o_id_content);
            pk_types.open_my_cursor(o_flg_type);
            RETURN FALSE;
    END get_supply_reason;
    /********************************************************************************************
    * Set supply reasons for a specific market and version.
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID
    * @param i_version                 Version ID
    * @param o_id_supply_reason      Cursor of supply reasons
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           09-NOV-2011
    ********************************************************************************************/
    FUNCTION set_supply_reason
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN market.id_market%TYPE,
        i_version          IN VARCHAR2,
        o_id_supply_reason OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_c_id_content       pk_types.cursor_type;
        l_c_flg_type         pk_types.cursor_type;
        l_c_id_supply_reason pk_types.cursor_type;
    
        l_data_id_supply_reason table_number := table_number();
        l_data_id_content       table_varchar := table_varchar();
        l_data_flg_type         table_varchar := table_varchar();
    
        l_error     t_error_out;
        l_exception EXCEPTION;
        -- stats vars
        l_cnt_ins NUMBER(24) := 0;
    
        -- translation
        dml_errors   EXCEPTION;
        l_table_name user_tables.table_name%TYPE;
        --error handling
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    BEGIN
        g_func_name := 'SET_SUPPLY_REASON';
    
        g_error := 'CALL GET_SUPPLY_REASON';
        IF NOT get_supply_reason(i_lang             => i_lang,
                                 i_market           => i_market,
                                 i_version          => i_version,
                                 o_id_supply_reason => l_c_id_supply_reason,
                                 o_id_content       => l_c_id_content,
                                 o_flg_type         => l_c_flg_type,
                                 o_error            => l_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error            := 'O_ID_SUPPLY_REASON = L_C_ID_SUPPLY_REASON';
            o_id_supply_reason := l_c_id_supply_reason;
            LOOP
            
                FETCH l_c_id_supply_reason BULK COLLECT
                    INTO l_data_id_supply_reason LIMIT g_array_size;
            
                FETCH l_c_id_content BULK COLLECT
                    INTO l_data_id_content LIMIT g_array_size;
            
                FETCH l_c_flg_type BULK COLLECT
                    INTO l_data_flg_type LIMIT g_array_size;
            
                l_cnt_ins := l_cnt_ins + l_data_id_supply_reason.count;
            
                g_error := 'INSERT WITH FORALL';
                FORALL j IN 1 .. l_data_id_content.count SAVE EXCEPTIONS
                    INSERT INTO supply_reason
                        (id_supply_reason, code_supply_reason, flg_type, id_institution, flg_available, id_content)
                    VALUES
                        (l_data_id_supply_reason(j),
                         'SUPPLY_REASON.CODE_SUPPLY_REASON.' || l_data_id_supply_reason(j),
                         l_data_flg_type(j),
                         0,
                         g_flg_available,
                         l_data_id_content(j));
                EXIT WHEN l_c_id_content%NOTFOUND;
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_SUPPLY_REASON';
            CLOSE l_c_id_supply_reason;
            g_error := 'CLOSE L_C_ID_CONTENT';
            CLOSE l_c_id_content;
            g_error := 'CLOSE L_C_FLG_TYPE';
            CLOSE l_c_flg_type;
        
        END IF;
    
        --> TRANSLATIONS
        l_table_name := 'SUPPLY_REASON';
        g_error      := 'CALL SET_DEF_TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_supply_reason;
    /********************************************************************************************
    * Get Supply Relation Configuration for a set of markets and versions.
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param o_id_supply           Cursor of default data
    * @param o_id_supply_item      Cursor of default data
    * @param o_id_quantity         Cursor of default data
    * @param o_unit_mea            Cursor of default data
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           23-NOV-2011
    ********************************************************************************************/
    FUNCTION get_supply_relation
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN market.id_market%TYPE,
        i_version        IN VARCHAR2,
        o_id_supply      OUT pk_types.cursor_type,
        o_id_supply_item OUT pk_types.cursor_type,
        o_id_quantity    OUT pk_types.cursor_type,
        o_unit_mea       OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        -- def vars
        l_id_supply_def      supply_relation.id_supply%TYPE := NULL;
        l_id_supply_item_def supply_relation.id_supply_item%TYPE := NULL;
        l_quantity_def       supply_relation.quantity%TYPE := NULL;
        l_unit_mea_def       supply_relation.id_unit_measure%TYPE := NULL;
    
        -- alert vars
        l_id_supply      supply_relation.id_supply%TYPE := NULL;
        l_id_supply_item supply_relation.id_supply_item%TYPE := NULL;
        -- arrays
        l_id_supply_id_array       table_number := table_number();
        l_id_supply_item_array     table_number := table_number();
        l_id_supply_unit_mea_array table_number := table_number();
        l_id_supply_quantity_array table_number := table_number();
    
        l_index        NUMBER := 1;
        l_valid_um     NUMBER := 0;
        l_valid_record NUMBER := 0;
    
        -- stats
        l_cnt_get NUMBER(24) := 0;
    
        CURSOR c_supply_relation
        (
            c_version IN VARCHAR2,
            c_market  IN NUMBER
        ) IS
            SELECT sr.id_supply, sr.id_supply_item, sr.quantity, sr.id_unit_measure
              FROM alert_default.supply_relation sr
             INNER JOIN alert_default.supply s
                ON (s.id_supply = sr.id_supply AND s.flg_available = pk_alert_constant.get_available)
             INNER JOIN alert_default.supply_mrk_vrs smv
                ON (smv.id_supply = s.id_supply AND smv.id_market = sr.id_market AND smv.version = sr.version)
             WHERE sr.id_market = c_market
               AND sr.version = c_version;
    BEGIN
        g_func_name := 'GET_SUPPLY_RELATION';
    
        g_error := 'OPEN C_SUPPLY_RELATION';
        OPEN c_supply_relation(i_version, i_market);
        LOOP
            FETCH c_supply_relation
                INTO l_id_supply_def, l_id_supply_item_def, l_quantity_def, l_unit_mea_def;
            EXIT WHEN c_supply_relation%NOTFOUND;
        
            g_error := 'SELECT ALERT ID_SUPPLY';
            SELECT nvl((SELECT s.id_supply
                         FROM supply s
                        INNER JOIN alert_default.supply defs
                           ON (defs.id_content = s.id_content AND defs.flg_available = pk_alert_constant.get_available)
                        WHERE defs.id_supply = l_id_supply_def
                          AND s.flg_available = pk_alert_constant.get_available
                          AND rownum = 1),
                       0)
              INTO l_id_supply
              FROM dual;
        
            g_error := 'SELECT ALERT ID_SUPPLY_ITEM';
            SELECT nvl((SELECT s.id_supply
                         FROM supply s
                        INNER JOIN alert_default.supply defs
                           ON (defs.id_content = s.id_content AND defs.flg_available = pk_alert_constant.get_available)
                        WHERE defs.id_supply = l_id_supply_item_def
                          AND s.flg_available = pk_alert_constant.get_available
                          AND rownum = 1),
                       0)
              INTO l_id_supply_item
              FROM dual;
        
            g_error := 'CHECK UNIT MEASURE';
            IF l_unit_mea_def IS NOT NULL
            THEN
                SELECT nvl(COUNT(*), 0)
                  INTO l_valid_um
                  FROM unit_measure um
                 WHERE um.id_unit_measure = l_unit_mea_def
                   AND um.flg_available = pk_alert_constant.get_available;
            ELSE
                l_valid_um := NULL;
            END IF;
        
            SELECT nvl(COUNT(*), 0)
              INTO l_valid_record
              FROM supply_relation sr
             WHERE sr.id_supply = l_id_supply
               AND sr.id_supply_item = l_id_supply_item;
        
            -- process all content fetched in alert_default
            l_cnt_get := l_cnt_get + 1;
            IF (l_id_supply != 0 AND l_id_supply_item != 0 AND l_valid_record = 0)
               AND (l_valid_um > 0 OR l_valid_um IS NULL)
            THEN
                l_id_supply_id_array.extend;
                l_id_supply_item_array.extend;
                l_id_supply_unit_mea_array.extend;
                l_id_supply_quantity_array.extend;
            
                l_id_supply_id_array(l_index) := l_id_supply;
                l_id_supply_item_array(l_index) := l_id_supply_item;
                l_id_supply_unit_mea_array(l_index) := l_unit_mea_def;
                l_id_supply_quantity_array(l_index) := l_quantity_def;
            
                l_index := l_index + 1;
            END IF;
        END LOOP;
        g_error := 'CLOSE C_SUPPLY_RELATION';
        CLOSE c_supply_relation;
    
        g_error := 'OPEN O_ID_SUPPLY';
        OPEN o_id_supply FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_id_array AS table_number));
    
        g_error := 'OPEN O_ID_SUPPLY_ITEM';
        OPEN o_id_supply_item FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_item_array AS table_number));
    
        g_error := 'OPEN O_ID_SUPPLY_QUANTITY';
        OPEN o_id_quantity FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_quantity_array AS table_number));
    
        g_error := 'OPEN O_ID_SUPPLY_UNIT_MEA';
        OPEN o_unit_mea FOR
            SELECT column_value
              FROM TABLE(CAST(l_id_supply_unit_mea_array AS table_number));
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_supply);
            pk_types.open_my_cursor(o_id_supply_item);
            pk_types.open_my_cursor(o_id_quantity);
            pk_types.open_my_cursor(o_unit_mea);
            RETURN FALSE;
    END get_supply_relation;
    /********************************************************************************************
    * Set supply Relation for a specific market and version.
    *
    * @param i_lang                    Prefered language ID
    * @param i_market                  Market ID
    * @param i_version                 Version ID
    * @param o_id_supply               Cursor of supply reasons
    * @param o_error                   Error
    *
    * @return                          true or false on success or error
    *
    * @author                          RMGM
    * @version                         v2.6.1.5
    * @since                           23-NOV-2011
    ********************************************************************************************/
    FUNCTION set_supply_relation
    (
        i_lang               IN language.id_language%TYPE,
        i_market             IN market.id_market%TYPE,
        i_version            IN VARCHAR2,
        o_id_supply_relation OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        -- fecthing cursors
        l_c_id_supply      pk_types.cursor_type;
        l_c_id_supply_item pk_types.cursor_type;
        l_c_quantity       pk_types.cursor_type;
        l_c_id_unit_mea    pk_types.cursor_type;
    
        -- arrays
        l_data_id_supply      table_number := table_number();
        l_data_id_supply_item table_number := table_number();
        l_data_quantity       table_number := table_number();
        l_data_id_unit_mea    table_number := table_number();
    
        l_error t_error_out;
        -- stats vars
        l_cnt_ins NUMBER(24) := 0;
    
        -- translation
        dml_errors   EXCEPTION;
        l_exception  EXCEPTION;
        l_table_name user_tables.table_name%TYPE;
        --error handling
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    BEGIN
        g_func_name := 'SET_SUPPLY_RELATION';
    
        g_error := 'CALL GET_SUPPLY_RELATION';
        IF NOT get_supply_relation(i_lang,
                                   i_market,
                                   i_version,
                                   l_c_id_supply,
                                   l_c_id_supply_item,
                                   l_c_quantity,
                                   l_c_id_unit_mea,
                                   l_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error              := 'O_ID_SUPPLY_RELATION = L_C_ID_SUPPLY_RELATION';
            o_id_supply_relation := l_c_id_supply;
            LOOP
            
                FETCH l_c_id_supply BULK COLLECT
                    INTO l_data_id_supply LIMIT g_array_size;
            
                FETCH l_c_id_supply_item BULK COLLECT
                    INTO l_data_id_supply_item LIMIT g_array_size;
            
                FETCH l_c_quantity BULK COLLECT
                    INTO l_data_quantity LIMIT g_array_size;
            
                FETCH l_c_id_unit_mea BULK COLLECT
                    INTO l_data_id_unit_mea LIMIT g_array_size;
            
                l_cnt_ins := l_cnt_ins + l_data_id_supply.count;
            
                g_error := 'INSERT WITH FORALL';
                FORALL j IN 1 .. l_data_id_supply.count SAVE EXCEPTIONS
                    INSERT INTO supply_relation
                        (id_supply, id_supply_item, quantity, id_unit_measure)
                    VALUES
                        (l_data_id_supply(j), l_data_id_supply_item(j), l_data_quantity(j), l_data_id_unit_mea(j));
                EXIT WHEN l_c_id_supply%NOTFOUND;
            END LOOP;
        
            g_error := 'CLOSE L_C_ID_SUPPLY';
            CLOSE l_c_id_supply;
            g_error := 'CLOSE L_C_ID_ITEM';
            CLOSE l_c_id_supply_item;
            g_error := 'CLOSE L_C_QUANTITY';
            CLOSE l_c_quantity;
            g_error := 'CLOSE L_C_UNIT_MEA';
            CLOSE l_c_id_unit_mea;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_supply_relation;
    /********************************************************************************************
    * Returns True or False and list of result notes configuration details by market/version/software
    *
    * @param i_lang                  Language id
    * @param i_market                Market id Array
    * @param i_version               Version Array
    * @param i_id_institution        Institution id
    * @param i_id_software           Software id Array
    * @param o_resnt                 Default detailed cursor output
    * @param o_error                 error output
    *
    * @return                        true (sucess), false (error)
    *
    * @author                        RMGM
    * @since                         2012/04/18
    * @version                       2.6.1.8
    ********************************************************************************************/
    FUNCTION get_inst_result_notes
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_resnt          OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_func_name := upper('get_inst_result_notes');
        g_error     := 'OPEN CONFIGURATION CURSOR';
        OPEN o_resnt FOR
            SELECT def_data.id_result_notes, def_data.id_software, def_data.rank
              FROM (SELECT temp_data.my_rowid,
                           temp_data.id_result_notes,
                           temp_data.id_software,
                           temp_data.rank,
                           rank() over(PARTITION BY temp_data.id_result_notes, temp_data.id_software ORDER BY temp_data.my_rowid) frecords_count
                      FROM (SELECT def_rnis.rowid my_rowid,
                                   nvl((SELECT rn.id_result_notes
                                         FROM alert_default.result_notes def_rn
                                        INNER JOIN result_notes rn
                                           ON (rn.id_content = def_rn.id_content)
                                        WHERE def_rn.id_result_notes = def_rnis.id_result_notes
                                          AND def_rn.flg_available = g_flg_available),
                                       0) id_result_notes,
                                   def_rnis.id_software,
                                   def_rnis.rank
                              FROM alert_default.result_notes_instit_soft def_rnis
                             WHERE def_rnis.id_market IN (SELECT /*+ dynamic_sampling(m 2) */
                                                           m.column_value
                                                            FROM TABLE(i_market) m)
                               AND def_rnis.version IN (SELECT /*+ dynamic_sampling(v 2) */
                                                         v.column_value
                                                          FROM TABLE(i_version) v)
                               AND def_rnis.id_software IN (SELECT /*+ dynamic_sampling(s 2) */
                                                             s.column_value
                                                              FROM TABLE(i_id_software) s)
                               AND def_rnis.flg_available = g_flg_available) temp_data
                    -- remove content not available in ALERT DB
                     WHERE temp_data.id_result_notes != 0) def_data
            -- remove duplicates
             WHERE def_data.frecords_count = 1
               AND NOT EXISTS (SELECT 0
                    -- unique key validation 
                      FROM result_notes_instit_soft rnis
                     WHERE rnis.id_result_notes = def_data.id_result_notes
                       AND rnis.id_institution = i_id_institution
                       AND rnis.id_software = def_data.id_software
                       AND rnis.flg_available = g_flg_available);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_resnt);
            RETURN FALSE;
    END get_inst_result_notes;
    /********************************************************************************************
    * Returns True or False and list of result notes configuration ids by market/version/software
    *
    * @param i_lang                  Language id
    * @param i_market                Market id Array
    * @param i_version               Version Array
    * @param i_id_institution        Institution id
    * @param i_id_software           Software id Array
    * @param o_resnt                 Default detailed cursor output
    * @param o_error                 error output
    *
    * @return                        true (sucess), false (error)
    *
    * @author                        RMGM
    * @since                         2012/04/18
    * @version                       2.6.1.8
    ********************************************************************************************/
    FUNCTION set_inst_result_notes
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_resnt          OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        -- colection arrays
        l_id_rn_array table_number := table_number();
        l_id_sw_array table_number := table_number();
        l_rank_array  table_number := table_number();
        -- auxiliar outputs
        l_tbl_code       VARCHAR2(200) := 'RESULT_NOTES.CODE_RESULT_NOTES.';
        c_input_internal pk_types.cursor_type;
        l_aux1           table_varchar := table_varchar();
        --error handling
        l_exception EXCEPTION;
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    BEGIN
        g_error := 'GET DEFAULT CONFIGURATIONS';
        IF NOT get_inst_result_notes(i_lang,
                                     i_market,
                                     i_version,
                                     i_id_institution,
                                     i_id_software,
                                     c_input_internal,
                                     o_error)
        THEN
            RAISE l_exception;
        ELSE
            g_error     := 'COLLECT DEFAULT CONFIGURATIONS';
            g_func_name := upper('set_inst_result_notes');
            LOOP
                FETCH c_input_internal BULK COLLECT
                    INTO l_id_rn_array, l_id_sw_array, l_rank_array LIMIT g_array_size1;
                g_error := 'LOAD DEFAULT CONFIGURATIONS';
                FORALL idx IN 1 .. l_id_rn_array.count SAVE EXCEPTIONS
                    INSERT INTO result_notes_instit_soft
                        (id_res_notes_instit_soft, id_result_notes, id_institution, id_software, flg_available, rank)
                    VALUES
                        (seq_result_notes_instit_soft.nextval,
                         l_id_rn_array(idx),
                         i_id_institution,
                         l_id_sw_array(idx),
                         g_flg_available,
                         l_rank_array(idx))
                    RETURNING id_res_notes_instit_soft BULK COLLECT INTO l_aux1;
                EXIT WHEN c_input_internal%NOTFOUND;
            END LOOP;
            g_error := 'CLOSE DEFAULT CONFIGURATIONS CURSOR';
            CLOSE c_input_internal;
        END IF;
        pk_alertlog.log_info(l_aux1.count || ' rows inserted');
        g_error := 'RETURN DEFAULT IDS CONFIGURED';
        OPEN o_resnt FOR
            SELECT column_value
              FROM TABLE(CAST(l_aux1 AS table_varchar));
        RETURN TRUE;
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQLERRM(-SQL%BULK_EXCEPTIONS(idx).error_code);
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  SQL%BULK_EXCEPTIONS(idx).error_code,
                                                  error_msg,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_result_notes;
    /********************************************************************************************
    * Returns list of analysis collection configuration properties
    *
    * @param i_lang                  Language id
    * @param i_market                Market id Array
    * @param i_version               Version Array
    * @param i_id_institution        Institution id
    * @param i_id_software           Software id
    * @param o_labcollection         id_collection output cursor
    * @param o_error                 error output
    *
    * @return                        true (sucess), false (error)
    *
    * @author                        RMGM
    * @since                         2011/12/19
    * @version                       2.6.1.6
    ********************************************************************************************/
    FUNCTION get_inst_analysis_collection
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_labcolection   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_function_name VARCHAR2(100 CHAR) := upper('get_inst_analysis_collection');
        l_error         VARCHAR2(1000 CHAR);
    
    BEGIN
    
        OPEN o_labcolection FOR
            SELECT def_data.id_analysis_instit_soft,
                   def_data.num_collection,
                   def_data.flg_interval_type,
                   def_data.flg_status
              FROM (SELECT temp_data.id_analysis_instit_soft,
                           temp_data.num_collection,
                           temp_data.flg_interval_type,
                           temp_data.flg_status,
                           row_number() over(PARTITION BY temp_data.id_analysis_instit_soft, temp_data.num_collection, temp_data.flg_interval_type ORDER BY temp_data.l_row) records_count
                      FROM (SELECT norm_data.id_analysis,
                                   nvl((SELECT ais1.id_analysis_instit_soft
                                         FROM analysis_instit_soft ais1
                                        WHERE ais1.id_analysis = norm_data.id_analysis
                                          AND ais1.id_sample_type = norm_data.id_sample_type
                                          AND ais1.id_software = norm_data.id_software
                                          AND ais1.id_institution = i_id_institution
                                          AND ais1.flg_available = g_flg_available),
                                       0) id_analysis_instit_soft,
                                   norm_data.num_collection,
                                   norm_data.flg_interval_type,
                                   norm_data.flg_status,
                                   norm_data.l_row
                              FROM (SELECT nvl((SELECT a.id_analysis
                                                 FROM analysis a
                                                WHERE a.id_content =
                                                      (SELECT a2.id_content
                                                         FROM alert_default.analysis a2
                                                        WHERE a2.id_analysis = def_ais.id_analysis)
                                                  AND a.id_content IS NOT NULL
                                                  AND a.flg_available = g_flg_available
                                                  AND rownum = 1),
                                               0) id_analysis,
                                           nvl((SELECT sp.id_sample_type
                                                 FROM sample_type sp
                                                WHERE sp.id_content =
                                                      (SELECT sp2.id_content
                                                         FROM alert_default.sample_type sp2
                                                        WHERE sp2.id_sample_type = def_ais.id_sample_type)
                                                  AND sp.id_content IS NOT NULL
                                                  AND sp.flg_available = g_flg_available
                                                  AND rownum = 1),
                                               0) id_sample_type,
                                           def_ais.id_software,
                                           def_acol.num_collection,
                                           def_acol.flg_interval_type,
                                           def_acol.flg_status,
                                           def_acol.rowid l_row
                                      FROM alert_default.analysis_instit_soft def_ais
                                     INNER JOIN alert_default.analysis_collection def_acol
                                        ON (def_acol.id_analysis_instit_soft = def_ais.id_analysis_instit_soft AND
                                           def_acol.flg_available = g_flg_available)
                                     WHERE def_ais.id_software IN
                                           (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                             column_value
                                              FROM TABLE(CAST(i_id_software AS table_number)) p)
                                       AND def_ais.flg_available = g_flg_available
                                       AND EXISTS (SELECT 0
                                              FROM alert_default.analysis_sample_type def_ast
                                             INNER JOIN alert_default.ast_mkt_vrs astmv
                                                ON (astmv.id_content = def_ast.id_content)
                                             WHERE def_ast.id_analysis = def_ais.id_analysis
                                               AND def_ast.id_sample_type = def_ais.id_sample_type
                                               AND astmv.id_market IN
                                                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                     column_value
                                                      FROM TABLE(CAST(i_market AS table_number)) p)
                                               AND astmv.version IN
                                                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                     column_value
                                                      FROM TABLE(CAST(i_version AS table_varchar)) p))
                                       AND rownum > 0) norm_data
                             WHERE norm_data.id_analysis != 0
                               AND norm_data.id_sample_type != 0) temp_data
                     WHERE temp_data.id_analysis_instit_soft != 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM analysis_collection acol
                     WHERE acol.id_analysis_instit_soft = def_data.id_analysis_instit_soft
                       AND acol.num_collection = def_data.num_collection
                       AND acol.flg_interval_type = def_data.flg_interval_type
                       AND acol.flg_available = g_flg_available);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_function_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_analysis_collection;
    /********************************************************************************************
    * Returns True or False and list of analysis collection new Id's
    *
    * @param i_lang                  Language id
    * @param i_market                Market id Array
    * @param i_version               Version Array
    * @param i_id_institution        Institution id
    * @param i_id_software           Software id Array
    * @param o_labcollection         id_collection output cursor
    * @param o_error                 error output
    *
    * @return                        true (sucess), false (error)
    *
    * @author                        RMGM
    * @since                         2011/12/19
    * @version                       2.6.1.6
    ********************************************************************************************/
    FUNCTION set_inst_analysis_collection
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_labcolection   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_function_name VARCHAR2(100 CHAR) := upper('set_inst_analysis_collection');
        l_error         t_error_out;
        -- input cursor
        c_labcol pk_types.cursor_type;
        -- collection arrays
        l_ac_ais_id_array       table_number := table_number();
        l_ac_numcol_array       table_number := table_number();
        l_ac_flg_interval_array table_varchar := table_varchar();
        l_flg_status_array      table_varchar := table_varchar();
    
        -- error handling
        l_exception EXCEPTION;
    
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_cd  VARCHAR2(500);
        error_msg VARCHAR2(2000);
    
    BEGIN
        g_error := 'CLOSE ANALYSIS COLLECTION CURSOR';
        IF NOT
            get_inst_analysis_collection(i_lang, i_market, i_version, i_id_institution, i_id_software, c_labcol, l_error)
        THEN
            RAISE l_exception;
        ELSE
            o_labcolection := c_labcol;
            LOOP
                FETCH c_labcol BULK COLLECT
                    INTO l_ac_ais_id_array,
                         l_ac_numcol_array,
                         l_ac_flg_interval_array,
                         l_flg_status_array LIMIT g_array_size;
            
                FORALL i IN 1 .. l_ac_ais_id_array.count SAVE EXCEPTIONS
                    INSERT INTO analysis_collection
                        (id_analysis_collection,
                         id_analysis_instit_soft,
                         num_collection,
                         flg_interval_type,
                         flg_available,
                         flg_status)
                    VALUES
                        (seq_analysis_collection.nextval,
                         l_ac_ais_id_array(i),
                         l_ac_numcol_array(i),
                         l_ac_flg_interval_array(i),
                         g_flg_available,
                         l_flg_status_array(i));
            
                EXIT WHEN c_labcol%NOTFOUND;
            END LOOP;
            CLOSE c_labcol;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_cd  := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                error_msg := substr(SQLERRM(error_cd), 1, 600);
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  error_cd,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  l_function_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              l_function_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_function_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_analysis_collection;
    /********************************************************************************************
    * Returns list of analysis collection configuration properties
    *
    * @param i_lang                  Language id
    * @param i_market                Market id Array
    * @param i_version               Version Array
    * @param i_id_institution        Institution id
    * @param i_id_software           Software id
    * @param o_labcolection_int      id_collection output cursor
    * @param o_error                 error output
    *
    * @return                        true (sucess), false (error)
    *
    * @author                        RMGM
    * @since                         2011/12/19
    * @version                       2.6.1.6
    ********************************************************************************************/
    FUNCTION get_inst_lab_collection_int
    (
        i_lang             IN language.id_language%TYPE,
        i_market           IN table_number,
        i_version          IN table_varchar,
        i_id_institution   IN institution.id_institution%TYPE,
        i_id_software      IN table_number,
        o_labcolection_int OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_function_name VARCHAR2(100 CHAR) := upper('get_inst_lab_collection_int');
        l_error         VARCHAR2(1000 CHAR);
    
        -- def vars
        l_aci_ais_id       analysis_collection.id_analysis_instit_soft%TYPE;
        l_aci_ordecol_def  analysis_collection_int.order_collection%TYPE;
        l_aci_interval_def analysis_collection_int.interval%TYPE;
    
        -- alert vars
        l_aci_ac_id_alert analysis_collection_int.id_analysis_collection%TYPE;
    
        -- collection arrays
        l_aci_ac_id_array    table_number := table_number();
        l_aci_ordecol_array  table_number := table_number();
        l_aci_interval_array table_number := table_number();
    
        -- auxiliar vars
        l_record_validation NUMBER := 0;
        l_index             NUMBER := 1;
    
        -- cursors
        CURSOR c_def_labcol_int
        (
            c_software IN software.id_software%TYPE,
            c_version  IN VARCHAR2,
            c_market   IN NUMBER
        ) IS
            SELECT aais.id_analysis_instit_soft, aci.order_collection, aci.interval
              FROM alert_default.analysis_collection_int aci
             INNER JOIN alert_default.analysis_collection ac
                ON (ac.id_analysis_collection = aci.id_analysis_collection)
             INNER JOIN alert_default.analysis_instit_soft ais
                ON (ais.id_analysis_instit_soft = ac.id_analysis_instit_soft)
             INNER JOIN alert_default.analysis_sample_type ast
                ON (ast.id_analysis = ais.id_analysis AND ast.id_sample_type = ais.id_sample_type)
             INNER JOIN alert_default.ast_mkt_vrs amv
                ON (amv.id_content = ast.id_content AND amv.id_market = c_market AND amv.version = c_version)
             INNER JOIN analysis_sample_type aast
                ON (aast.id_content = ast.id_content AND aast.flg_available = g_flg_available)
             INNER JOIN analysis_instit_soft aais
                ON (aais.id_analysis = aast.id_analysis AND aais.id_sample_type = aast.id_sample_type AND
                   aais.flg_type = ais.flg_type AND aais.id_institution = i_id_institution AND
                   aais.id_software = c_software AND aais.flg_available = g_flg_available)
             WHERE aci.flg_available = g_flg_available
               AND ac.flg_available = g_flg_available
               AND ast.flg_available = g_flg_available
               AND ais.flg_available = g_flg_available
               AND ais.id_software = c_software;
    
    BEGIN
        FOR i IN 1 .. i_version.count
        LOOP
        
            FOR j IN 1 .. i_market.count
            LOOP
                FOR k IN 1 .. i_id_software.count
                LOOP
                    g_error := 'OPEN ANALYSIS COLLECTION DETAIL CURSOR';
                    OPEN c_def_labcol_int(i_id_software(k), i_version(i), i_market(j));
                    LOOP
                        g_error := 'FETCH ANALYSIS COLLECTION DETAIL CURSOR';
                        FETCH c_def_labcol_int
                            INTO l_aci_ais_id, l_aci_ordecol_def, l_aci_interval_def;
                        EXIT WHEN c_def_labcol_int%NOTFOUND;
                    
                        g_error := 'GET ALERT ANALYSIS COLLECTION ID';
                        SELECT nvl((SELECT ac.id_analysis_collection
                                     FROM analysis_collection ac
                                    WHERE ac.id_analysis_instit_soft = l_aci_ais_id
                                      AND ac.flg_available = g_flg_available
                                      AND rownum = 1),
                                   0)
                          INTO l_aci_ac_id_alert
                          FROM dual;
                    
                        g_error := 'GET ALERT RECORD VALIDATION';
                        SELECT nvl((SELECT aci.id_analysis_collection_int
                                     FROM analysis_collection_int aci
                                    WHERE aci.id_analysis_collection = l_aci_ac_id_alert
                                      AND aci.flg_available = g_flg_available
                                      AND rownum = 1
                                   
                                   ),
                                   0)
                          INTO l_record_validation
                          FROM dual;
                    
                        IF (l_aci_ac_id_alert != 0 AND l_record_validation = 0)
                        THEN
                            l_aci_ac_id_array.extend;
                            l_aci_ordecol_array.extend;
                            l_aci_interval_array.extend;
                        
                            l_aci_ac_id_array(l_index) := l_aci_ac_id_alert;
                            l_aci_ordecol_array(l_index) := l_aci_ordecol_def;
                            l_aci_interval_array(l_index) := l_aci_interval_def;
                        
                            l_index := l_index + 1;
                        END IF;
                        -- end content cursor                         
                    END LOOP;
                    g_error := 'CLOSE ANALYSIS COLLECTION CURSOR';
                    CLOSE c_def_labcol_int;
                    -- end software cursor
                END LOOP;
                -- end market cursor
            END LOOP;
            -- end version cursor
        END LOOP;
        g_error := 'OPEN RETURN CURSOR';
        OPEN o_labcolection_int FOR
            SELECT f1.cval id_labcol, f2.cval ordercol, f3.cval interv
              FROM (SELECT rownum rn, column_value cval
                      FROM TABLE(CAST(l_aci_ac_id_array AS table_number))) f1
             INNER JOIN (SELECT rownum rn, column_value cval
                           FROM TABLE(CAST(l_aci_ordecol_array AS table_number))) f2
                ON (f2.rn = f1.rn)
             INNER JOIN (SELECT rownum rn, column_value cval
                           FROM TABLE(CAST(l_aci_interval_array AS table_number))) f3
                ON (f3.rn = f1.rn);
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_function_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_inst_lab_collection_int;
    /********************************************************************************************
    * Returns True or False and list of analysis collection internal new Id's
    *
    * @param i_lang                  Language id
    * @param i_market                Market id Array
    * @param i_version               Version Array
    * @param i_id_institution        Institution id
    * @param i_id_software           Software id Array
    * @param o_labcollection_int         id_collection output cursor
    * @param o_error                 error output
    *
    * @return                        true (sucess), false (error)
    *
    * @author                        RMGM
    * @since                         2011/12/21
    * @version                       2.6.1.6
    ********************************************************************************************/
    FUNCTION set_inst_lab_collection_int
    (
        i_lang              IN language.id_language%TYPE,
        i_market            IN table_number,
        i_version           IN table_varchar,
        i_id_institution    IN institution.id_institution%TYPE,
        i_id_software       IN table_number,
        o_labcollection_int OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_function_name VARCHAR2(100 CHAR) := upper('set_inst_lab_collection_int');
        l_error         t_error_out;
        -- input cursor
        c_labcol_int pk_types.cursor_type;
        -- collection arrays
        l_aci_ac_id_array    table_number := table_number();
        l_aci_ordecol_array  table_number := table_number();
        l_aci_interval_array table_number := table_number();
    
        -- error handling
        l_exception EXCEPTION;
    
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_cd  VARCHAR2(500);
        error_msg VARCHAR2(2000);
    
    BEGIN
        g_error := 'CLOSE ANALYSIS COLLECTION CURSOR';
        IF NOT get_inst_lab_collection_int(i_lang,
                                           i_market,
                                           i_version,
                                           i_id_institution,
                                           i_id_software,
                                           c_labcol_int,
                                           l_error)
        THEN
            RAISE l_exception;
        ELSE
            o_labcollection_int := c_labcol_int;
            LOOP
                FETCH c_labcol_int BULK COLLECT
                    INTO l_aci_ac_id_array, l_aci_ordecol_array, l_aci_interval_array LIMIT g_array_size;
            
                FORALL i IN 1 .. l_aci_ac_id_array.count SAVE EXCEPTIONS
                    INSERT INTO analysis_collection_int
                        (id_analysis_collection_int, id_analysis_collection, order_collection, INTERVAL, flg_available)
                    VALUES
                        (seq_analysis_collection_int.nextval,
                         l_aci_ac_id_array(i),
                         l_aci_ordecol_array(i),
                         l_aci_interval_array(i),
                         g_flg_available);
            
                EXIT WHEN c_labcol_int%NOTFOUND;
            END LOOP;
            CLOSE c_labcol_int;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_cd  := SQL%BULK_EXCEPTIONS(idx).error_code;
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                error_msg := substr(SQLERRM(error_cd), 1, 600);
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  error_msg,
                                                  error_cd,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  l_function_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              l_function_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_function_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_inst_lab_collection_int;
    /********************************************************************************************
    * Get OCCUPATION DEFAULT content universe
    *
    * @param i_lang                Prefered language ID
    * @param i_market              List of markets to colect content
    * @param i_version             List of content versions to colect content     
    * @param o_id_occupation       List of ids configured
    * @param o_error               Error Out
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     2.6.1.8
    * @since                       2012/05/25
    ********************************************************************************************/
    FUNCTION get_def_occupation
    (
        i_lang          IN language.id_language%TYPE,
        i_market        IN table_number,
        i_version       IN table_varchar,
        o_id_occupation OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_func_name := upper('get_def_occupation');
        g_error     := 'OPEN CONFIGURATION CURSOR';
        OPEN o_id_occupation FOR
            SELECT def_data.id_content, def_data.ocp_rank
              FROM (SELECT temp_data.l_row,
                           temp_data.id_content,
                           temp_data.ocp_rank,
                           rank() over(PARTITION BY temp_data.id_content ORDER BY temp_data.l_row) records_count
                      FROM (SELECT ocp.rowid l_row, ocp.id_content, nvl(ocp.rank, 0) ocp_rank
                              FROM alert_default.occupation ocp
                             INNER JOIN alert_default.occupation_mrk_vrs ocpmv
                                ON (ocpmv.id_occupation = ocp.id_occupation)
                             WHERE ocp.flg_available = g_flg_available
                               AND ocpmv.id_market IN (SELECT /*+ dynamic_sampling(t 2) */
                                                        t.column_value
                                                         FROM TABLE(i_market) t)
                               AND ocpmv.version IN (SELECT /*+ dynamic_sampling(t 2) */
                                                      t.column_value
                                                       FROM TABLE(i_version) t)) temp_data) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM occupation ext_ocp
                     WHERE ext_ocp.id_content = def_data.id_content
                       AND ext_ocp.flg_available = g_flg_available);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_id_occupation);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_def_occupation;
    /********************************************************************************************
    * Set OCCUPATION DEFAULT content universe
    *
    * @param i_lang                Prefered language ID
    * @param i_market              List of markets to colect content
    * @param i_version             List of content versions to colect content     
    * @param o_id_occupation       List of ids configured
    * @param o_error               Error Out
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     2.6.1.8
    * @since                       2012/05/25
    ********************************************************************************************/
    FUNCTION set_def_occupation
    (
        i_lang          IN language.id_language%TYPE,
        i_market        IN table_number,
        i_version       IN table_varchar,
        o_id_occupation OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        -- occupation
        l_code_occupation occupation.code_occupation%TYPE := 'OCCUPATION.CODE_OCCUPATION.';
    
        l_data_id_content table_varchar := table_varchar();
        l_data_rank       table_number := table_number();
    
        -- auxiliar outputs
        c_input_internal pk_types.cursor_type;
        l_aux1           table_number := table_number();
        l_auxf           table_number := table_number();
    
        --TRANSLATION
        dml_errors EXCEPTION;
    
        --error handling
        l_exception EXCEPTION;
        bulk_errors EXCEPTION;
        PRAGMA EXCEPTION_INIT(bulk_errors, -24381);
        error_num NUMBER;
        error_msg VARCHAR2(2000);
    BEGIN
        g_error := 'OPEN CONFIGURATION CURSOR';
        IF NOT get_def_occupation(i_lang, i_market, i_version, c_input_internal, o_error)
        THEN
            RAISE l_exception;
        ELSE
            LOOP
                g_func_name := upper('set_def_occupation');
                g_error     := 'FETCH CONFIGURATION CURSOR';
                FETCH c_input_internal BULK COLLECT
                    INTO l_data_id_content, l_data_rank LIMIT g_array_size1;
                g_error := 'LOAD CONFIGURATIONS';
                dbms_output.put_line(l_data_id_content.count);
                FORALL a IN 1 .. l_data_id_content.count SAVE EXCEPTIONS
                    INSERT INTO occupation
                        (id_occupation, code_occupation, adw_last_update, rank, flg_available, id_content)
                    VALUES
                        (alert_adtcod_cfg.seq_occupation.nextval,
                         l_code_occupation || alert_adtcod_cfg.seq_occupation.currval,
                         SYSDATE,
                         l_data_rank(a),
                         g_flg_available,
                         l_data_id_content(a))
                    RETURNING id_occupation BULK COLLECT INTO l_aux1;
            
                g_error := 'MERGE CONFIGURED IDS';
                l_auxf  := l_auxf MULTISET UNION l_aux1;
                EXIT WHEN c_input_internal%NOTFOUND;
            END LOOP;
            g_error := 'CLOSE CONFIGURATION CURSOR';
            CLOSE c_input_internal;
        
            pk_alertlog.log_info(l_auxf.count || ' rows inserted');
            OPEN o_id_occupation FOR
                SELECT column_value
                  FROM TABLE(CAST(l_auxf AS table_number));
        END IF;
    
        -- 15/03/2011 RMGM: changed way how translations are loaded
        g_table_name := 'OCCUPATION';
        g_error      := 'SET TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN bulk_errors THEN
            FOR idx IN 1 .. SQL%bulk_exceptions.count
            LOOP
                error_msg := SQLERRM(-SQL%BULK_EXCEPTIONS(idx).error_code);
                error_num := SQL%BULK_EXCEPTIONS(idx).error_index;
                g_error   := g_error || ' ( index ) ' || error_num;
                pk_alert_exceptions.process_error(i_lang,
                                                  SQL%BULK_EXCEPTIONS(idx).error_code,
                                                  error_msg,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  g_func_name,
                                                  o_error);
            
            END LOOP;
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_def_occupation;
    /********************************************************************************************
    * Set ICNP_COMPOSITION for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_result              Number of records loaded
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.2
    * @since                       2013/01/11
    ********************************************************************************************/
    FUNCTION set_inst_icnp_composition
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_result         OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_icnp_comp_code VARCHAR2(200) := 'ICNP_COMPOSITION.CODE_ICNP_COMPOSITION.';
        l_icnp_compo_seq NUMBER(24) := 0;
        --TRANSLATION
        dml_errors EXCEPTION;
    BEGIN
        g_error := 'LOADING ICNP_COMPOSITION ';
        SELECT seq_icnp_composition.nextval
          INTO l_icnp_compo_seq
          FROM dual;
        --        l_icnp_compo_seq := seq_icnp_composition.nextval;
        INSERT INTO icnp_composition
            (id_composition,
             flg_type,
             flg_nurse_tea,
             flg_repeat,
             flg_gender,
             flg_available,
             adw_last_update,
             code_icnp_composition,
             id_vs,
             id_doc_template,
             flg_task,
             flg_solved,
             id_content,
             id_institution,
             id_software)
            SELECT seq_icnp_composition.nextval,
                   def_data.flg_type,
                   def_data.flg_nurse_tea,
                   def_data.flg_repeat,
                   def_data.flg_gender,
                   g_flg_available,
                   SYSDATE,
                   l_icnp_comp_code || seq_icnp_composition.currval,
                   def_data.id_vs,
                   def_data.id_doc_template,
                   def_data.flg_task,
                   def_data.flg_solved,
                   def_data.id_content,
                   i_id_institution,
                   def_data.id_software
              FROM (SELECT temp_data.id_content,
                           temp_data.flg_type,
                           temp_data.flg_nurse_tea,
                           temp_data.flg_repeat,
                           temp_data.flg_gender,
                           temp_data.id_vs,
                           temp_data.id_doc_template,
                           temp_data.flg_task,
                           temp_data.flg_solved,
                           temp_data.id_software,
                           row_number() over(PARTITION BY temp_data.id_software, temp_data.id_content ORDER BY temp_data.l_row) records_count
                      FROM (SELECT ic.rowid l_row,
                                   ic.id_content,
                                   ic.flg_type,
                                   ic.flg_nurse_tea,
                                   ic.flg_repeat,
                                   ic.flg_gender,
                                   ic.id_vs,
                                   ic.id_doc_template,
                                   ic.flg_task,
                                   ic.flg_solved,
                                   ic.id_software
                              FROM alert_default.icnp_composition ic
                             INNER JOIN alert_default.icnp_comp_mkt_vrs icmv
                                ON (icmv.id_composition = ic.id_composition)
                             WHERE ic.id_software IN
                                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                     column_value
                                      FROM TABLE(CAST(i_id_software AS table_number)) p)
                               AND icmv.id_market IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                       column_value
                                                        FROM TABLE(CAST(i_market AS table_number)) p)
                               AND icmv.version IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                     column_value
                                                      FROM TABLE(CAST(i_version AS table_varchar)) p)
                               AND ic.flg_available = g_flg_available) temp_data) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM icnp_composition ext_ic
                     WHERE ext_ic.id_content = def_data.id_content
                       AND ext_ic.id_institution = i_id_institution
                       AND ext_ic.id_software = def_data.id_software
                       AND ext_ic.flg_available = g_flg_available);
    
        g_table_name := 'HEALTH_PLAN_ENTITY';
        g_error      := 'SET DEF TRANSLATIONS';
    
        o_result := SQL%ROWCOUNT;
        RETURN TRUE;
    EXCEPTION
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_DEF_TRANSLATIONS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_BACKOFFICE_DEFAULT',
                                              'SET_ICNP_COMPOSITION',
                                              o_error);
            RETURN FALSE;
    END set_inst_icnp_composition;
    /********************************************************************************************
    * Set ICNP_COMPOSITION_HIST for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_result              Number of records loaded
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.2
    * @since                       2013/01/11
    ********************************************************************************************/
    FUNCTION set_inst_icnp_composition_hist
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_result         OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'LOADING ICNP_COMPOSITION_HIST ';
    
        INSERT INTO icnp_composition_hist
            (id_composition_hist,
             id_composition,
             flg_most_recent,
             dt_composition_hist,
             id_cancel_reason,
             reason_notes,
             flg_cancel)
            SELECT seq_icnp_composition_hist.nextval,
                   def_data.id_composition,
                   g_flg_available,
                   current_timestamp,
                   NULL,
                   NULL,
                   'N'
              FROM (SELECT temp_data.id_composition,
                           row_number() over(PARTITION BY temp_data.id_software, temp_data.id_composition ORDER BY temp_data.l_row) records_count
                      FROM (SELECT ic.rowid l_row,
                                   nvl((SELECT ext_ic.id_composition
                                         FROM icnp_composition ext_ic
                                        WHERE ext_ic.id_content = ic.id_content
                                          AND ext_ic.flg_available = g_flg_available
                                          AND ext_ic.id_institution = i_id_institution
                                          AND ext_ic.id_software = ic.id_software),
                                       0) id_composition,
                                   ic.id_software
                              FROM alert_default.icnp_composition ic
                             INNER JOIN alert_default.icnp_comp_mkt_vrs icmv
                                ON (icmv.id_composition = ic.id_composition)
                             WHERE ic.id_software IN
                                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                     column_value
                                      FROM TABLE(CAST(i_id_software AS table_number)) p)
                               AND icmv.id_market IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                       column_value
                                                        FROM TABLE(CAST(i_market AS table_number)) p)
                               AND icmv.version IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                     column_value
                                                      FROM TABLE(CAST(i_version AS table_varchar)) p)
                               AND ic.flg_available = g_flg_available) temp_data
                     WHERE temp_data.id_composition != 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM icnp_composition_hist ich
                     WHERE ich.id_composition = def_data.id_composition);
        o_result := SQL%ROWCOUNT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_BACKOFFICE_DEFAULT',
                                              'SET_ICNP_COMPOSITION_HIST',
                                              o_error);
            RETURN FALSE;
    END set_inst_icnp_composition_hist;
    /********************************************************************************************
    * Set ICNP_COMPOSITION_TERM for a set of markets, versions and sotwares
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_id_software         Software ID
    * @param o_result              Number of records loaded
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.2
    * @since                       2013/01/11
    ********************************************************************************************/
    FUNCTION set_inst_icnp_composition_term
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN table_number,
        o_result         OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'LOADING ICNP_COMPOSITION_TERM ';
        INSERT INTO icnp_composition_term
            (id_composition_term, id_term, id_composition, desc_term, rank, id_language, flg_main_focus)
            SELECT seq_icnp_composition_term.nextval,
                   def_data.id_term,
                   def_data.id_composition,
                   def_data.desc_term,
                   def_data.rank,
                   def_data.id_language,
                   def_data.flg_main_focus
              FROM (SELECT temp_data.id_term,
                           temp_data.id_composition,
                           temp_data.desc_term,
                           temp_data.rank,
                           temp_data.id_language,
                           temp_data.flg_main_focus,
                           row_number() over(PARTITION BY temp_data.id_composition, temp_data.id_term, temp_data.id_language ORDER BY temp_data.l_row) records_count
                      FROM (SELECT ict.rowid l_row,
                                   ict.id_term,
                                   nvl((SELECT ext_ic.id_composition
                                         FROM icnp_composition ext_ic
                                        WHERE ext_ic.id_content = ic.id_content
                                          AND ext_ic.flg_available = g_flg_available
                                          AND ext_ic.id_institution = i_id_institution
                                          AND ext_ic.id_software = ic.id_software),
                                       0) id_composition,
                                   ict.desc_term,
                                   ict.rank,
                                   ict.id_language,
                                   ict.flg_main_focus
                              FROM alert_default.icnp_composition_term ict
                             INNER JOIN alert_default.icnp_composition ic
                                ON (ic.id_composition = ict.id_composition AND ic.flg_available = g_flg_available)
                             INNER JOIN alert_default.icnp_comp_mkt_vrs icmv
                                ON (icmv.id_composition = ict.id_composition)
                             WHERE icmv.id_market IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                       column_value
                                                        FROM TABLE(CAST(i_market AS table_number)) p)
                               AND icmv.version IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                     column_value
                                                      FROM TABLE(CAST(i_version AS table_varchar)) p)) temp_data
                     WHERE temp_data.id_composition != 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM icnp_composition_term ext_ict
                     WHERE ext_ict.id_term = def_data.id_term
                       AND ext_ict.id_composition = def_data.id_composition
                       AND ext_ict.id_language = def_data.id_language);
        o_result := SQL%ROWCOUNT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_BACKOFFICE_DEFAULT',
                                              'SET_ICNP_COMPOSITION_TERM',
                                              o_error);
            RETURN FALSE;
    END set_inst_icnp_composition_term;
    /********************************************************************************************
    * Set ICNP TASK COMPOSITION BY SOFTWARE AND specified institution.
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param o_inst_interv_drug    Cursor of default data
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.1
    * @since                       2013/01/17
    ********************************************************************************************/
    FUNCTION set_inst_task_comp_search
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_result         OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'LOADING ICNP_TASK_COMP_SOFT_INST';
        INSERT INTO icnp_task_comp_soft_inst
            (id_task, id_task_type, id_composition, id_software, id_institution, flg_available)
            SELECT def_data.id_task,
                   def_data.id_task_type,
                   def_data.id_composition,
                   def_data.id_software,
                   i_id_institution,
                   g_flg_available
              FROM (SELECT temp_data.id_task,
                           temp_data.id_task_type,
                           temp_data.id_composition,
                           temp_data.id_software,
                           row_number() over(PARTITION BY temp_data.id_task, temp_data.id_task_type, temp_data.id_composition, temp_data.id_software ORDER BY temp_data.l_row) records_count
                      FROM (SELECT def_tbl.rowid l_row,
                                   pk_default_content.get_dest_task_by_type(i_lang, def_tbl.id_task, def_tbl.id_task_type) id_task,
                                   def_tbl.id_task_type,
                                   nvl((SELECT ic.id_composition
                                         FROM icnp_composition ic
                                        INNER JOIN alert_default.icnp_composition def_ic
                                           ON (def_ic.id_content = ic.id_content AND def_ic.id_software = ic.id_software AND
                                              def_ic.flg_available = g_flg_available)
                                        WHERE ic.flg_available = g_flg_available
                                          AND ic.id_software = def_tbl.id_software
                                          AND ic.id_institution = i_id_institution
                                          AND def_ic.id_composition = def_tbl.id_composition),
                                       0) id_composition,
                                   def_tbl.id_software
                              FROM alert_default.icnp_task_composition def_tbl
                             INNER JOIN alert_default.icnp_task_comp_mkt_vrs itcmv
                                ON (itcmv.id_icnp_task_composition = def_tbl.id_icnp_task_composition)
                             WHERE def_tbl.flg_available = g_flg_available
                               AND def_tbl.id_software IN
                                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                     column_value
                                      FROM TABLE(CAST(i_software AS table_number)) p)
                               AND itcmv.id_market IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                        column_value
                                                         FROM TABLE(CAST(i_market AS table_number)) p)
                               AND itcmv.version IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                      column_value
                                                       FROM TABLE(CAST(i_version AS table_varchar)) p)) temp_data
                     WHERE temp_data.id_task != 0
                       AND temp_data.id_composition != 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM icnp_task_comp_soft_inst dest_tbl
                     WHERE dest_tbl.id_task = def_data.id_task
                       AND dest_tbl.id_task_type = def_data.id_task_type
                       AND dest_tbl.id_composition = def_data.id_composition
                       AND dest_tbl.id_software = def_data.id_software
                       AND dest_tbl.id_institution = i_id_institution);
    
        o_result := SQL%ROWCOUNT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_BACKOFFICE_DEFAULT',
                                              'SET_ICNP_TASK_COMP_SEARCH',
                                              o_error);
            RETURN FALSE;
    END set_inst_task_comp_search;
    /********************************************************************************************
    * Set Default Positionings
    *
    * @param i_lang                Prefered language ID
    * @param o_positioning         Positioning
    * @param o_error               Error
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     2.6.1
    * @since                       2013/03/28
    ********************************************************************************************/
    FUNCTION set_def_positioning
    (
        i_lang    IN language.id_language%TYPE,
        i_market  IN table_number,
        i_version IN table_varchar,
        o_result  OUT NUMBER,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        --TRANSLATION
        dml_errors EXCEPTION;
    
    BEGIN
        g_error := 'SET POSITIONING BY MARKET AND CONTENT VERSION';
        INSERT INTO positioning
            (id_positioning, code_positioning, rank, flg_available, adw_last_update, id_content)
            SELECT seq_positioning.nextval,
                   'POSITIONING.CODE_POSITIONING.' || seq_positioning.currval,
                   def_data.rank,
                   g_flg_available,
                   SYSDATE,
                   def_data.id_content
              FROM (SELECT p.rank,
                           p.id_content,
                           row_number() over(PARTITION BY p.id_content ORDER BY pmv.rowid) records_count
                      FROM alert_default.positioning p
                     INNER JOIN alert_default.positioning_mrk_vrs pmv
                        ON (pmv.id_positioning = p.id_positioning)
                     WHERE p.flg_available = g_flg_available
                       AND pmv.id_market IN (SELECT /*+ dynamic_sampling(2) */
                                              column_value
                                               FROM TABLE(CAST(i_market AS table_number)) p)
                       AND pmv.version IN (SELECT /*+ dynamic_sampling(2) */
                                            column_value
                                             FROM TABLE(CAST(i_version AS table_varchar)) p)) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM positioning ext_p
                     WHERE ext_p.flg_available = g_flg_available
                       AND ext_p.id_content = def_data.id_content);
    
        o_result := SQL%ROWCOUNT;
        -- 16/03/2011 RMGM: changed way how translations are loaded
        g_table_name := 'POSITIONING';
        g_error      := 'SET DEF TRANSLATIONS';
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_DEF_TRANSLATIONS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_DEF_POSITIONING',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_def_positioning;
    /********************************************************************************************
    * Set Default Interventions Categories
    *
    * @param i_lang                Prefered language ID
    * @param o_interv_cat          Interventions categories
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2009/03/31
    ********************************************************************************************/
    FUNCTION set_inst_interv_cat
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        o_result         OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_error := 'INSERT INTO INTERV_INT_CAT';
        INSERT INTO interv_int_cat
            (id_interv_category, id_intervention, rank, adw_last_update, id_software, id_institution, flg_add_remove)
            SELECT def_data.id_interv_category,
                   def_data.id_intervention,
                   0,
                   SYSDATE,
                   def_data.id_software,
                   i_id_institution,
                   'A'
              FROM (SELECT temp_data.id_interv_category,
                           temp_data.id_intervention,
                           temp_data.id_software,
                           row_number() over(PARTITION BY temp_data.id_interv_category, temp_data.id_intervention, temp_data.id_software ORDER BY temp_data.l_row) records_count
                      FROM (SELECT iic.id_interv_category,
                                   nvl((SELECT ext_i.id_intervention
                                         FROM intervention ext_i
                                        WHERE ext_i.flg_status = 'A'
                                          AND ext_i.id_content = i.id_content),
                                       0) id_intervention,
                                   iic.id_software,
                                   iic.rowid l_row
                              FROM alert_default.interv_int_cat iic
                             INNER JOIN alert_default.intervention i
                                ON (i.id_intervention = iic.id_intervention AND i.flg_status = 'A')
                             INNER JOIN alert_default.interv_mrk_vrs imv
                                ON (imv.id_intervention = i.id_intervention)
                             WHERE iic.id_software IN
                                   (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                     column_value
                                      FROM TABLE(CAST(i_software AS table_number)) p)
                               AND imv.id_market IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                      column_value
                                                       FROM TABLE(CAST(i_market AS table_number)) p)
                               AND imv.version IN (SELECT /*+ opt_estimate(TABLE p rows = 1) */
                                                    column_value
                                                     FROM TABLE(CAST(i_version AS table_varchar)) p)) temp_data
                     WHERE temp_data.id_intervention != 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM interv_int_cat ext_iic
                     WHERE ext_iic.id_interv_category = def_data.id_interv_category
                       AND ext_iic.id_intervention = def_data.id_intervention
                       AND ext_iic.id_software = def_data.id_software
                       AND ext_iic.id_institution = i_id_institution);
    
        o_result := SQL%ROWCOUNT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_BACKOFFICE_DEFAULT',
                                              'SET_INST_INTERV_CAT',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_interv_cat;
    /********************************************************************************************
    * Set Default Dashboard areas configuration
    *
    * @param i_lang                Prefered language ID
    * @param o_result_tbl          Number of records inserted
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.1
    * @since                       2013/05/15
    ********************************************************************************************/
    FUNCTION set_dash_da_mkt_search
    (
        i_lang        IN language.id_language%TYPE,
        i_institution IN institution.id_institution%TYPE,
        i_mkt         IN table_number,
        i_vers        IN table_varchar,
        i_software    IN table_number,
        o_result_tbl  OUT NUMBER,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_func_name := upper('set_dash_da_mkt_search');
        g_error     := 'LOAD DASHBOARD DOC AREAS BY MKT';
        INSERT INTO dash_doc_area_mkt
            (id_doc_area, id_market, flg_available)
            SELECT def_data.id_doc_area, def_data.id_market, g_flg_available
              FROM (SELECT temp_data.id_doc_area,
                           temp_data.id_market,
                           row_number() over(PARTITION BY temp_data.id_doc_area, temp_data.id_market ORDER BY temp_data.l_row) records_count
                      FROM (SELECT def_tbl.id_doc_area, def_tbl.id_market, def_tbl.rowid l_row
                              FROM alert_default.dash_doc_area_mkt def_tbl
                             WHERE def_tbl.flg_available = g_flg_available
                               AND def_tbl.version IN (SELECT /*+ dynamic_sampling(p 2)*/
                                                        column_value
                                                         FROM TABLE(CAST(i_vers AS table_varchar)) p)
                               AND def_tbl.id_market IN
                                   (SELECT /*+ dynamic_sampling(p 2)*/
                                     column_value
                                      FROM TABLE(CAST(i_mkt AS table_number)) p)) temp_data
                     WHERE NOT EXISTS (SELECT 0
                              FROM dash_doc_area_mkt dest_tbl
                             WHERE dest_tbl.id_doc_area = temp_data.id_doc_area
                               AND dest_tbl.id_market = temp_data.id_market
                               AND dest_tbl.flg_available = g_flg_available)) def_data
             WHERE def_data.records_count = 1;
        o_result_tbl := SQL%ROWCOUNT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            RETURN FALSE;
    END set_dash_da_mkt_search;
    /********************************************************************************************
    * Set Default Dashboard areas configuration
    *
    * @param i_lang                Prefered language ID
    * @param o_result_tbl          Number of records inserted
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.1
    * @since                       2013/05/15
    ********************************************************************************************/
    FUNCTION set_dash_da_inst_search
    (
        i_lang        IN language.id_language%TYPE,
        i_institution IN institution.id_institution%TYPE,
        i_mkt         IN table_number,
        i_vers        IN table_varchar,
        i_software    IN table_number,
        o_result_tbl  OUT NUMBER,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_func_name := upper('set_dash_da_inst_search');
        g_error     := 'LOAD DASHBOARD DOC AREAS BY INSTITUTION';
        INSERT INTO dash_doc_area_inst
            (id_doc_area, id_institution, flg_available)
            SELECT def_data.id_doc_area, i_institution, g_flg_available
              FROM (SELECT temp_data.id_doc_area,
                           row_number() over(PARTITION BY temp_data.id_doc_area ORDER BY temp_data.l_row) records_count
                      FROM (SELECT def_tbl.id_doc_area, def_tbl.rowid l_row
                              FROM alert_default.dash_doc_area_mkt def_tbl
                             WHERE def_tbl.flg_available = g_flg_available
                               AND def_tbl.version IN (SELECT /*+ dynamic_sampling(p 2)*/
                                                        column_value
                                                         FROM TABLE(CAST(i_vers AS table_varchar)) p)
                               AND def_tbl.id_market IN
                                   (SELECT /*+ dynamic_sampling(p 2)*/
                                     column_value
                                      FROM TABLE(CAST(i_mkt AS table_number)) p)) temp_data
                     WHERE NOT EXISTS (SELECT 0
                              FROM dash_doc_area_inst dest_tbl
                             WHERE dest_tbl.id_doc_area = temp_data.id_doc_area
                               AND dest_tbl.id_institution = i_institution
                               AND dest_tbl.flg_available = g_flg_available)) def_data
             WHERE def_data.records_count = 1;
        o_result_tbl := SQL%ROWCOUNT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            RETURN FALSE;
    END set_dash_da_inst_search;
    /********************************************************************************************
    * Set Default Task Goal Task configuration Social Worker
    *
    * @param i_lang                Prefered language ID
    * @param i_institution         Institution ID
    * @param i_mkt                 Market ID list
    * @param i_vers                content version tag list
    * @param i_software            softwar ID list                
    * @param o_result              Number of records inserted
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.1
    * @since                       2013/05/17
    ********************************************************************************************/
    FUNCTION set_taskgoaltask_search
    (
        i_lang        IN language.id_language%TYPE,
        i_institution IN institution.id_institution%TYPE,
        i_mkt         IN table_number,
        i_vers        IN table_varchar,
        i_software    IN table_number,
        o_result      OUT NUMBER,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_max_id NUMBER := 0;
    BEGIN
        g_func_name := upper('set_taskgoaltask_search');
        g_error     := 'GET MAX ID FROM DEST TABLE';
        SELECT nvl((SELECT MAX(t.id_task_goal_task)
                     FROM task_goal_task t),
                   0)
          INTO l_max_id
          FROM dual;
        g_error := 'SET TASK GOAL TASK CONFIGURATION';
        INSERT INTO task_goal_task
            (id_task_goal_task, id_interv_plan, id_task_goal, id_software, id_institution, flg_available)
            SELECT l_max_id + rownum,
                   def_data.id_interv_plan,
                   def_data.id_task_goal,
                   def_data.id_software,
                   i_institution,
                   g_flg_available
              FROM (SELECT temp_data.id_interv_plan,
                           temp_data.id_task_goal,
                           temp_data.id_software,
                           row_number() over(PARTITION BY temp_data.id_interv_plan, temp_data.id_task_goal, temp_data.id_software ORDER BY temp_data.l_row) records_count
                      FROM (SELECT def_tbl.rowid l_row,
                                   def_tbl.id_software,
                                   nvl((SELECT ext_ip.id_interv_plan
                                         FROM interv_plan ext_ip
                                        INNER JOIN alert_default.interv_plan def_ip
                                           ON (def_ip.id_content = ext_ip.id_content)
                                        WHERE ext_ip.flg_available = g_flg_available
                                          AND def_ip.flg_available = g_flg_available
                                          AND def_ip.id_interv_plan = def_tbl.id_interv_plan),
                                       0) id_interv_plan,
                                   nvl((SELECT ext_tg.id_task_goal
                                         FROM task_goal ext_tg
                                        INNER JOIN alert_default.task_goal def_tg
                                           ON (def_tg.id_content = ext_tg.id_content)
                                        WHERE def_tg.id_task_goal = def_tbl.id_task_goal),
                                       0) id_task_goal
                              FROM alert_default.task_goal_task def_tbl
                             WHERE def_tbl.flg_available = g_flg_available
                               AND def_tbl.id_software IN
                                   (SELECT /*+ dynamic_sampling(2) */
                                     column_value
                                      FROM TABLE(CAST(i_software AS table_number)) p)
                               AND def_tbl.id_market IN
                                   (SELECT /*+ dynamic_sampling(2) */
                                     column_value
                                      FROM TABLE(CAST(i_mkt AS table_number)) p)
                               AND def_tbl.version IN (SELECT /*+ dynamic_sampling(2) */
                                                        column_value
                                                         FROM TABLE(CAST(i_vers AS table_varchar)) p)) temp_data
                     WHERE temp_data.id_interv_plan > 0
                       AND temp_data.id_task_goal > 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM task_goal_task dest_tbl
                     WHERE dest_tbl.id_interv_plan = def_data.id_interv_plan
                       AND dest_tbl.id_task_goal = def_data.id_task_goal
                       AND dest_tbl.id_software = def_data.id_software
                       AND dest_tbl.id_institution = i_institution);
    
        o_result := SQL%ROWCOUNT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            RETURN FALSE;
    END set_taskgoaltask_search;
    /********************************************************************************************
    * Set Default Task Goal Task configuration Social Worker
    *
    * @param i_lang                Prefered language ID
    * @param i_institution         Institution ID
    * @param i_mkt                 Market ID list
    * @param i_vers                content version tag list
    * @param i_software            softwar ID list                
    * @param o_result              Number of records inserted
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.1
    * @since                       2013/05/17
    ********************************************************************************************/
    FUNCTION set_intervplan_search
    (
        i_lang        IN language.id_language%TYPE,
        i_institution IN institution.id_institution%TYPE,
        i_mkt         IN table_number,
        i_vers        IN table_varchar,
        i_software    IN table_number,
        o_result      OUT NUMBER,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_func_name := upper('set_intervplan_search');
        g_error     := 'SET INTERV PLAN SEARCH CONFIGURATION';
        INSERT INTO interv_plan_dep_clin_serv
            (id_interv_plan, id_software, id_institution, flg_available, flg_type, id_interv_plan_dep_clin_serv)
            SELECT def_data.id_interv_plan,
                   def_data.id_software,
                   i_institution,
                   g_flg_available,
                   def_data.flg_type,
                   seq_interv_plan_dep_clin_serv.nextval
              FROM (SELECT temp_data.id_software,
                           temp_data.id_interv_plan,
                           temp_data.flg_type,
                           row_number() over(PARTITION BY temp_data.id_software, temp_data.id_interv_plan, temp_data.flg_type ORDER BY temp_data.l_row) records_count
                      FROM (SELECT def_tbl.rowid l_row,
                                   def_tbl.id_software,
                                   nvl((SELECT ext_ip.id_interv_plan
                                         FROM interv_plan ext_ip
                                        INNER JOIN alert_default.interv_plan def_ip
                                           ON (def_ip.id_content = ext_ip.id_content)
                                        WHERE ext_ip.flg_available = g_flg_available
                                          AND def_ip.flg_available = g_flg_available
                                          AND def_ip.id_interv_plan = def_tbl.id_interv_plan),
                                       0) id_interv_plan,
                                   def_tbl.flg_type
                              FROM alert_default.interv_plan_dep_clin_serv def_tbl
                             WHERE def_tbl.flg_available = g_flg_available
                               AND def_tbl.id_software IN
                                   (SELECT /*+ dynamic_sampling(2) */
                                     column_value
                                      FROM TABLE(CAST(i_software AS table_number)) p)
                               AND def_tbl.id_market IN
                                   (SELECT /*+ dynamic_sampling(2) */
                                     column_value
                                      FROM TABLE(CAST(i_mkt AS table_number)) p)
                               AND def_tbl.version IN (SELECT /*+ dynamic_sampling(2) */
                                                        column_value
                                                         FROM TABLE(CAST(i_vers AS table_varchar)) p)) temp_data
                     WHERE temp_data.id_interv_plan > 0) def_data
             WHERE def_data.records_count = 1
               AND NOT EXISTS (SELECT 0
                      FROM interv_plan_dep_clin_serv dest_tbl
                     WHERE dest_tbl.id_interv_plan = def_data.id_interv_plan
                       AND dest_tbl.id_software = def_data.id_software
                       AND dest_tbl.id_institution = i_institution
                       AND dest_tbl.flg_type = def_data.flg_type);
        o_result := SQL%ROWCOUNT;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            RETURN FALSE;
    END set_intervplan_search;
    /********************************************************************************************
    * Checks and removes all order set, guideline and protocols without tasks
    *
    * @param i_lang                    Prefered language ID
    * @param i_id_institution          Institution ID
    * @param o_error                   Error
    *
    * @author                          RMGM
    * @version                         v2.6.2.0
    * @since                           16/02/2012
    ********************************************************************************************/
    PROCEDURE orders_double_check
    (
        i_lang           IN language.id_language%TYPE,
        i_id_institution IN institution.id_institution%TYPE,
        o_error          OUT t_error_out
    ) IS
        CURSOR c_orderset IS
            SELECT DISTINCT os.id_order_set
              FROM order_set os
             INNER JOIN alert_default.order_set def_os
                ON (def_os.id_content = os.id_content AND def_os.author_desc = os.author_desc)
             WHERE os.id_institution = i_id_institution
               AND NOT EXISTS (SELECT 0
                      FROM order_set_task ost
                     WHERE ost.id_order_set = os.id_order_set);
    
        CURSOR c_guidelines IS
            SELECT g.id_guideline
              FROM guideline g
             INNER JOIN alert_default.guideline def_g
                ON (def_g.id_content = g.id_content)
             WHERE g.id_institution = i_id_institution
               AND NOT EXISTS (SELECT 0
                      FROM guideline_task_link gtl
                     WHERE gtl.id_guideline = g.id_guideline);
        CURSOR c_protocols IS
            SELECT p.id_protocol
              FROM protocol p
             INNER JOIN alert_default.protocol def_p
                ON (def_p.id_content = p.id_content)
             WHERE p.id_institution = i_id_institution
               AND NOT EXISTS (SELECT *
                      FROM protocol_element pe
                     INNER JOIN protocol_task pt
                        ON (pt.id_group_task = pe.id_protocol_element)
                     WHERE pe.id_protocol = p.id_protocol
                       AND pe.element_type = 'T');
    BEGIN
    
        g_error := 'DELETE ORDER_SET_TASK_DETAIL';
        DELETE FROM order_set_task_detail ostd
         WHERE ostd.id_order_set_task IN
               (SELECT t.id_order_set_task
                  FROM order_set_task t
                 WHERE t.id_task_type NOT IN (2, 5, 28, 29, 30, 31, 32, 33, 34, 35, 36, 40, 41)
                   AND t.id_order_set_task NOT IN (SELECT id_order_set_task
                                                     FROM order_set_task_link)
                   AND t.id_order_set IN (SELECT DISTINCT t.id_order_set
                                            FROM order_set t
                                            JOIN alert_default.order_set tt
                                              ON tt.id_content = t.id_content
                                             AND t.author_desc = tt.author_desc
                                           WHERE t.id_professional IS NULL));
    
        g_error := 'DELETE ORDER_SET_TASK';
        DELETE FROM order_set_task t
         WHERE t.id_task_type NOT IN (2, 5, 28, 29, 30, 31, 32, 33, 34, 35, 36, 40, 41)
           AND t.id_order_set_task NOT IN (SELECT id_order_set_task
                                             FROM order_set_task_link)
           AND t.id_order_set IN (SELECT DISTINCT t.id_order_set
                                    FROM order_set t
                                    JOIN alert_default.order_set tt
                                      ON tt.id_content = t.id_content
                                     AND t.author_desc = tt.author_desc
                                   WHERE t.id_professional IS NULL);
        -- order set    
        FOR os IN c_orderset
        LOOP
        
            DELETE FROM order_set_task_detail ostd
             WHERE ostd.id_order_set_task IN (SELECT ost.id_order_set_task
                                                FROM order_set_task ost
                                               WHERE ost.id_order_set = os.id_order_set);
        
            DELETE order_set_task_link ostl
             WHERE ostl.id_order_set_task IN (SELECT ost.id_order_set_task
                                                FROM order_set_task ost
                                               WHERE ost.id_order_set = os.id_order_set);
        
            DELETE FROM order_set_task_dependency ostd
             WHERE ostd.id_order_set = os.id_order_set;
        
            DELETE FROM order_set_task ost
             WHERE ost.id_order_set = os.id_order_set;
        
            DELETE FROM order_set_frequent osf
             WHERE osf.id_order_set = os.id_order_set;
        
            DELETE order_set_link osl
             WHERE osl.id_order_set = os.id_order_set;
        
            DELETE FROM order_set_process_task_link osptl
             WHERE osptl.id_order_set_process_task IN
                   (SELECT ospt.id_order_set_process_task
                      FROM order_set_process_task ospt
                     INNER JOIN order_set_process osp
                        ON (osp.id_order_set_process = ospt.id_order_set_process)
                     WHERE osp.id_order_set = os.id_order_set);
        
            DELETE FROM order_set_process_task_det osptd
             WHERE osptd.id_order_set_process_task IN
                   (SELECT ospt.id_order_set_process_task
                      FROM order_set_process_task ospt
                     INNER JOIN order_set_process osp
                        ON (osp.id_order_set_process = ospt.id_order_set_process)
                     WHERE osp.id_order_set = os.id_order_set);
        
            DELETE FROM order_set_process_task_depend osptd
             WHERE osptd.id_order_set_process IN
                   (SELECT osp.id_order_set_process
                      FROM order_set_process osp
                     WHERE osp.id_order_set = os.id_order_set);
        
            DELETE FROM order_set_process_task ospt
             WHERE ospt.id_order_set_process IN
                   (SELECT osp.id_order_set_process
                      FROM order_set_process osp
                     WHERE osp.id_order_set = os.id_order_set);
        
            DELETE FROM order_set_process osp
             WHERE osp.id_order_set = os.id_order_set;
        
            DELETE FROM order_set os1
             WHERE os1.id_order_set = os.id_order_set;
        
        END LOOP;
        -- guidelines
        FOR gl IN c_guidelines
        LOOP
            -- guideline_process_task_hist
            DELETE FROM guideline_process_task_hist gpth
             WHERE gpth.id_guideline_process_task IN
                   (SELECT gpt.id_guideline_process_task
                      FROM guideline_process_task gpt
                     WHERE gpt.id_guideline_process IN
                           (SELECT gp.id_guideline_process
                              FROM guideline_process gp
                             WHERE gp.id_guideline = gl.id_guideline));
            -- guideline_process_task_det
            DELETE FROM guideline_process_task_det gtpd
             WHERE gtpd.id_guideline_process_task IN
                   (SELECT gpt.id_guideline_process_task
                      FROM guideline_process_task gpt
                     WHERE gpt.id_guideline_process IN
                           (SELECT gp.id_guideline_process
                              FROM guideline_process gp
                             WHERE gp.id_guideline = gl.id_guideline));
            -- guideline_process_task
            DELETE FROM guideline_process_task gpt
             WHERE gpt.id_guideline_process IN (SELECT gp.id_guideline_process
                                                  FROM guideline_process gp
                                                 WHERE gp.id_guideline = gl.id_guideline);
            -- guideline_process
            DELETE FROM guideline_process gp
             WHERE gp.id_guideline = gl.id_guideline;
        
            -- guideline_task_link
            DELETE FROM guideline_task_link gtl
             WHERE gtl.id_guideline = gl.id_guideline;
            -- guideline_link
            DELETE FROM guideline_link gl1
             WHERE gl1.id_guideline = gl.id_guideline;
            --
            DELETE FROM guideline_frequent gf
             WHERE gf.id_guideline = gl.id_guideline;
        
            -- guideline_adv_input_value
            DELETE FROM guideline_adv_input_value gaiv
             WHERE gaiv.id_adv_input_link IN
                   (SELECT gcl.id_guideline_criteria_link
                      FROM guideline_criteria_link gcl
                     WHERE gcl.id_guideline_criteria IN
                           (SELECT gc.id_guideline_criteria
                              FROM guideline_criteria gc
                             WHERE gc.id_guideline = gl.id_guideline));
            -- guideline_criteria_link                           
            DELETE FROM guideline_criteria_link gcl
             WHERE gcl.id_guideline_criteria IN (SELECT gc.id_guideline_criteria
                                                   FROM guideline_criteria gc
                                                  WHERE gc.id_guideline = gl.id_guideline);
            -- guideline_criteria
            DELETE FROM guideline_criteria gc
             WHERE gc.id_guideline = gl.id_guideline;
            -- guideline_context_image
            DELETE FROM guideline_context_image gci
             WHERE gci.id_guideline = gl.id_guideline;
            -- guideline_context_author
            DELETE FROM guideline_context_author gca
             WHERE gca.id_guideline = gl.id_guideline;
            -- guideline
            DELETE FROM guideline g
             WHERE g.id_guideline = gl.id_guideline;
        
        END LOOP;
        -- protocols
        FOR ptcl IN c_protocols
        LOOP
            DELETE FROM protocol_frequent pf
             WHERE pf.id_protocol = ptcl.id_protocol;
        
            DELETE FROM protocol_relation pr
             WHERE (pr.id_protocol = ptcl.id_protocol OR pr.id_protocol_element_parent = ptcl.id_protocol);
        
            DELETE FROM protocol_context_image pci
             WHERE pci.id_protocol = ptcl.id_protocol;
        
            DELETE FROM protocol_context_author pca
             WHERE pca.id_protocol = ptcl.id_protocol;
        
            DELETE FROM protocol_adv_input_value paiv
             WHERE ((paiv.id_adv_input_link IN
                   (SELECT pt.id_protocol_task
                        FROM protocol_task pt
                       INNER JOIN protocol_element pe
                          ON (pe.id_protocol_element = pt.id_group_task AND pe.element_type = 'T')
                       WHERE pe.id_protocol = ptcl.id_protocol) AND paiv.flg_type = 'C') OR
                   (paiv.id_adv_input_link IN (SELECT pc.id_protocol_criteria
                                                  FROM protocol_criteria pc
                                                 WHERE pc.id_protocol = ptcl.id_protocol) AND paiv.flg_type = 'T'));
        
            DELETE FROM protocol_criteria_link pcl
             WHERE pcl.id_protocol_criteria IN (SELECT pc.id_protocol_criteria
                                                  FROM protocol_criteria pc
                                                 WHERE pc.id_protocol = ptcl.id_protocol);
        
            DELETE FROM protocol_criteria pc
             WHERE pc.id_protocol = ptcl.id_protocol;
        
            DELETE FROM protocol_task pt
             WHERE pt.id_group_task IN (SELECT pe.id_protocol_element
                                          FROM protocol_element pe
                                         WHERE pe.id_protocol = ptcl.id_protocol
                                           AND pe.element_type = 'T');
        
            DELETE FROM protocol_element pe
             WHERE pe.id_protocol = ptcl.id_protocol;
        
            DELETE FROM protocol_protocol pp
             WHERE pp.id_nested_protocol = ptcl.id_protocol;
        
            DELETE FROM protocol_link pl
             WHERE pl.id_protocol = ptcl.id_protocol;
        
            DELETE FROM protocol p
             WHERE p.id_protocol = ptcl.id_protocol;
        END LOOP;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              'AA',
                                              g_package_owner,
                                              g_package_name,
                                              'ORDERS_DOUBLE_CHECK',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
    END orders_double_check;
    /********************************************************************************************
    * Check the list of child clinical_services ids from a parent selection
    *
    * @param i_lang                Language ID
    * @param i_clinical_service    Primary clinical service Parent ID
    *
    * @return                      table of child clinical services ids
    *
    * @author                      RMGM
    * @version                     2.6.1.9
    * @since                       2012/06/20
    ********************************************************************************************/
    FUNCTION check_clinical_service_parent
    (
        i_lang      IN language.id_language%TYPE,
        i_cs_parent IN clinical_service.id_clinical_service%TYPE
    ) RETURN table_number IS
        l_cs_list table_number := table_number();
        o_error   t_error_out;
    BEGIN
        g_func_name := upper('check_clinical_service_parent');
        g_error     := 'GET CS CHILD STRUCTURE' || i_cs_parent;
        SELECT def_data.id_clinical_service
          BULK COLLECT
          INTO l_cs_list
          FROM (SELECT csr.rowid,
                       csr.id_clinical_service,
                       rank() over(PARTITION BY csr.id_clinical_service ORDER BY csr.rowid) records_count
                  FROM alert_default.clinical_serv_rel csr
                 WHERE csr.flg_available = g_flg_available
                 START WITH csr.id_clinical_service = i_cs_parent
                CONNECT BY PRIOR csr.id_clinical_service = csr.id_cs_parent) def_data
         WHERE def_data.records_count = 1;
    
        RETURN l_cs_list;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN l_cs_list;
    END check_clinical_service_parent;
    /********************************************************************************************
    * Set a Default Parameterization for a specific institution using new engine
    *
    * @param i_lang                Prefered language ID
    * @param i_market              Market ID's
    * @param i_version             ALERT version's
    * @param i_id_institution      Institution ID
    * @param i_software            Software ID's
    * @param i_commit_at_end       Commit automatic in transaction (Y, N)    
    * @param o_error               Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      RMGM
    * @version                     0.1
    * @since                       2013/05/05
    ********************************************************************************************/
    FUNCTION set_inst_default_param_new
    (
        i_lang           IN language.id_language%TYPE,
        i_market         IN table_number,
        i_version        IN table_varchar,
        i_id_institution IN institution.id_institution%TYPE,
        i_software       IN table_number,
        i_commit_at_end  IN VARCHAR2,
        o_results        OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        i_d_institution       institution.id_institution%TYPE := NULL;
        i_id_clinical_service table_number := table_number();
        i_dep_clin_serv       table_number := table_number();
        i_process_type        table_varchar := table_varchar('SEARCH', 'TRANSLATION');
        i_areas               table_varchar := table_varchar();
        i_tables              table_varchar := table_varchar();
        i_id_content          table_varchar := table_varchar();
        i_flg_dcs_all         VARCHAR2(1) := 'N';
        i_dependencies        VARCHAR2(1) := 'N';
        o_execution_id        NUMBER := 0;
        l_exception           EXCEPTION;
    BEGIN
        g_error := 'SET DEFAULT INSTITUTION CONFIGURATIONS';
        alert_core_func.pk_tool_engine.set_default_configuration(i_lang                => i_lang,
                                                                 i_market              => i_market,
                                                                 i_version             => i_version,
                                                                 i_institution         => i_id_institution,
                                                                 i_d_institution       => i_d_institution,
                                                                 i_software            => i_software,
                                                                 i_id_content          => i_id_content,
                                                                 i_flg_dcs_all         => i_flg_dcs_all,
                                                                 i_id_clinical_service => i_id_clinical_service,
                                                                 i_dep_clin_serv       => i_dep_clin_serv,
                                                                 i_dependencies        => i_dependencies,
                                                                 i_process_type        => i_process_type,
                                                                 i_areas               => i_areas,
                                                                 i_tables              => i_tables,
                                                                 o_execution_id        => o_execution_id,
                                                                 o_error               => o_error);
    
        g_error := 'SET BODY STRUCTURE RELATION + SYS_CONFIG';
        IF NOT pk_exam_utils.create_body_struct_rel(i_lang               => i_lang,
                                                    i_prof               => profissional(0, i_id_institution, 0),
                                                    i_mcs_concept        => NULL,
                                                    i_mcs_concept_parent => NULL,
                                                    o_error              => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        OPEN o_results FOR
            SELECT ex_det.id_execution_det,
                   nvl(pk_translation.get_translation(i_lang, ex_det.code_tool_area), ex_det.tool_area_name) area_name,
                   ex_det.tool_table_name table_name,
                   nvl(pk_translation.get_translation(i_lang, ex_det.code_tool_process_type), ex_det.internal_name) process_name,
                   ex_det.rec_inserted,
                   ex_det.execution_status,
                   ex_det.execution_length
              FROM alert_core_data.v_exec_hist_details ex_det
             WHERE ex_det.id_execution = o_execution_id;
    
        IF i_commit_at_end = g_flg_available
        THEN
            COMMIT;
        END IF;
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || o_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DEFAULT_PARAM_NEW',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_INST_DEFAULT_PARAM_NEW',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_inst_default_param_new;
BEGIN
    -- Initializes log context

    pk_alertlog.who_am_i(owner => g_package_owner, name => g_package_name);
    pk_alertlog.log_init(g_package_name);

    g_flg_available := pk_alert_constant.g_available;
    g_yes           := pk_alert_constant.g_yes;
    g_active        := pk_alert_constant.g_active;

    g_array_size  := 100;
    g_array_size1 := 10000;
    g_generic     := 0;

END pk_backoffice_default;
/
