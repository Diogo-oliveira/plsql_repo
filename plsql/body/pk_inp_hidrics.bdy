CREATE OR REPLACE PACKAGE BODY pk_inp_hidrics AS

    --Private vars
    g_ehd_edt_typ_l          CONSTANT VARCHAR2(1 CHAR) := 'L'; --Set line data
    g_cfg_auto_balance       CONSTANT sys_config.id_sys_config%TYPE := 'HIDRICS_AUTO_BALANCE';
    g_cd_ehd_flg_type        CONSTANT sys_domain.code_domain%TYPE := 'EPIS_HIDRICS_DET.FLG_TYPE';
    g_cd_ehc_flg_lvl_control CONSTANT sys_domain.code_domain%TYPE := 'EPIS_HID_COLLECTOR.FLG_LEVEL_CONTROL';
    g_cd_ehc_flg_restart     CONSTANT sys_domain.code_domain%TYPE := 'EPIS_HID_COLLECTOR.FLG_RESTART';

    -- variables used to find the graph maximum scale
    g_graph_max_scale NUMBER;

    --Have all the id's already sent to hist
    g_epis_hid_hist      table_number;
    g_epis_hid_det_hist  table_number;
    g_epis_hid_bal_hist  table_number;
    g_epis_hid_char_hist table_number;
    g_epis_hid_line_hist table_number;
    g_epis_hid_col_hist  table_number;
    g_epis_hid_ftxt_hist table_number;

    e_error                      EXCEPTION;
    e_cfg_vars_not_defined       EXCEPTION;
    g_epis_hid_balance_not_found EXCEPTION;
    g_epis_hid_wrong_date        EXCEPTION;

    --
    /*******************************************************************************************************************************************
    * cancel_assoc_icnp_interv        De-associate Integration of Therapeutic Attitudes
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           ID of hidric episode
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @author                         António Neto
    * @version                        2.6.0.5
    * @since                          02-Mar-2011
    *******************************************************************************************************************************************/
    FUNCTION cancel_assoc_icnp_interv
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_icnp_interv EXCEPTION;
    BEGIN
        pk_icnp_fo_api_db.set_sugg_status_cancel(i_lang         => i_lang,
                                                 i_prof         => i_prof,
                                                 i_request_id   => i_id_epis_hidrics,
                                                 i_task_type_id => pk_alert_constant.g_task_inp_hidrics,
                                                 i_sysdate_tstz => current_timestamp);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              'ERROR ON PK_ICNP_FO_API_DB.SET_SUGG_STATUS_CANCEL: ' ||
                                              i_id_epis_hidrics || ' ' || SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ASSOC_ICNP_INTERV',
                                              o_error);
            RETURN FALSE;
    END cancel_assoc_icnp_interv;

    /*******************************************************************************************************************************************
    * create_assoc_icnp_interv        Associate Integration of Therapeutic Attitudes
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           ID of hidric episode
    * @param I_EPISODE                ID of episode
    * @param I_HIDRICS_TYPE           ID of hidric type
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @author                         António Neto
    * @version                        2.6.0.5
    * @since                          02-Mar-2011
    *******************************************************************************************************************************************/
    FUNCTION create_assoc_icnp_interv
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_hidrics_type IN hidrics_type.id_hidrics_type%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_icnp_sug_interv table_number;
        l_icnp_interv EXCEPTION;
    BEGIN
        pk_icnp_fo_api_db.create_sugg(i_lang               => i_lang,
                                      i_prof               => i_prof,
                                      i_id_episode         => i_id_episode,
                                      i_request_id         => i_id_epis_hidrics,
                                      i_task_id            => i_id_hidrics_type,
                                      i_task_type_id       => pk_alert_constant.g_task_inp_hidrics,
                                      i_sysdate_tstz       => current_timestamp,
                                      o_id_icnp_sug_interv => l_id_icnp_sug_interv);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              'ERROR ON PK_ICNP_FO_API_DB.CREATE_SUGG: ' || i_id_epis_hidrics || ' ' ||
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_ASSOC_ICNP_INTERV',
                                              o_error);
            RETURN FALSE;
    END create_assoc_icnp_interv;

    /**********************************************************************************************
    * Returns information about a given request
    *
    * @param i_lang                  Language ID
    * @param i_prof                  Professional
    * @param i_id_request            Request ID
    * @param o_description           Description
    * @param o_instructions          Instructions
    * @param o_flg_status            Flg_status
    *                        
    * @author                        António Neto
    * @version                       v2.6.0.5
    * @since                         02-Mar-2011
    **********************************************************************************************/
    PROCEDURE get_therapeutic_status
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_request   IN NUMBER,
        o_description  OUT VARCHAR2,
        o_instructions OUT VARCHAR2,
        o_flg_status   OUT VARCHAR2
    ) IS
        l_interv_desc   CONSTANT VARCHAR2(24 CHAR) := 'HIDRICS_T003';
        l_hid_type_desc CONSTANT VARCHAR2(24 CHAR) := 'HIDRICS_T001';
        l_error t_error_out;
    BEGIN
        SELECT pk_message.get_message(i_lang, l_hid_type_desc) || ': ' ||
               pk_translation.get_translation(i_lang, ht.code_hidrics_type),
               pk_message.get_message(i_lang, l_interv_desc) || ': ' ||
               pk_translation.get_translation(i_lang, hi.code_hidrics_interval),
               decode(eh.flg_status,
                      pk_inp_hidrics_constant.g_epis_hidric_r,
                      pk_alert_constant.g_yes,
                      pk_inp_hidrics_constant.g_epis_hidric_e,
                      pk_alert_constant.g_yes,
                      pk_alert_constant.g_no)
          INTO o_description, o_instructions, o_flg_status
          FROM epis_hidrics eh
         INNER JOIN hidrics_type ht
            ON eh.id_hidrics_type = ht.id_hidrics_type
         INNER JOIN hidrics_interval hi
            ON eh.id_hidrics_interval = hi.id_hidrics_interval
         INNER JOIN hidrics_interval hi
            ON eh.id_hidrics_interval = hi.id_hidrics_interval
         WHERE eh.id_epis_hidrics = i_id_request;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              'ERROR ON GET_THERAPEUTIC_STATUS: ' || SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_THERAPEUTIC_STATUS',
                                              l_error);
        
    END;

    /**
    * Adds a new value to a table_varchar object
    *
    * @param   io_table                    Table that will have the new value
    * @param   i_value                     New value
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE add_value
    (
        io_table IN OUT table_varchar,
        i_value  IN VARCHAR2
    ) IS
    BEGIN
    
        io_table.extend();
        io_table(io_table.count) := i_value;
    
    END add_value;

    /**
    * Adds a new value to a table_number object
    *
    * @param   io_table                    Table that will have the new value
    * @param   i_value                     New value
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE add_value
    (
        io_table IN OUT table_number,
        i_value  IN NUMBER
    ) IS
    BEGIN
        io_table.extend();
        io_table(io_table.count) := i_value;
    END add_value;

    /**
    * Adds a new value to a table_number object
    *
    * @param   io_table                    Table that will have the new value
    * @param   i_value                     New value
    *
    * @author  Sofia Mendes
    * @version v2.6.0.5
    * @since   21-Dec-2010
    */
    PROCEDURE add_value
    (
        io_table IN OUT table_table_number,
        i_value  IN table_number
    ) IS
    BEGIN
        IF (i_value IS NOT NULL)
        THEN
            io_table.extend();
            io_table(io_table.count) := i_value;
        END IF;
    END add_value;

    /**
    * Adds a new value to a table_number object
    *
    * @param   io_table_1                    Table that will have the new value
    * @param   i_value_1                     New value
    * @param   io_table_2                    Table that will have the new value
    * @param   i_value_2                     New value
    * @param   io_table_3                    Table that will have the new value
    * @param   i_value_3                     New value
    *
    * @author  Sofia Mendes
    * @version v2.6.0.5
    * @since   13-Jan-2011
    */
    PROCEDURE add_3_values
    (
        io_table_1 IN OUT table_varchar,
        i_value_1  IN VARCHAR2,
        io_table_2 IN OUT table_varchar,
        i_value_2  IN VARCHAR2,
        io_table_3 IN OUT table_varchar,
        i_value_3  IN VARCHAR2
    ) IS
    BEGIN
        io_table_1.extend();
        io_table_1(io_table_1.count) := i_value_1;
    
        io_table_2.extend();
        io_table_2(io_table_2.count) := i_value_2;
    
        io_table_3.extend();
        io_table_3(io_table_3.count) := i_value_3;
    END add_3_values;

    /**
    * get oldest epis_hidrics from a visit
    *
    * @param   i_episode                   Epis_hidrics episode
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   24-Jul-2010
    */
    FUNCTION get_oldest_hid(i_episode IN epis_hidrics.id_episode%TYPE) RETURN epis_hidrics_balance.id_epis_hidrics%TYPE IS
        l_epis_hidrics epis_hidrics_balance.id_epis_hidrics%TYPE;
    BEGIN
        g_error := 'GET HID IN GREATER DELAY OR THE NEXT HID';
        pk_alertlog.log_debug(g_error);
        SELECT t.id_epis_hidrics
          INTO l_epis_hidrics
          FROM (SELECT ehb.id_epis_hidrics,
                       row_number() over(ORDER BY eh.dt_next_balance, ehb.dt_open_tstz, eh.dt_initial_tstz, eh.dt_creation_tstz) line_number
                  FROM epis_hidrics eh
                  JOIN epis_hidrics_balance ehb
                    ON ehb.id_epis_hidrics = eh.id_epis_hidrics
                   AND ehb.flg_status IN
                       (pk_inp_hidrics_constant.g_epis_hid_balance_r, pk_inp_hidrics_constant.g_epis_hid_balance_e)
                 WHERE eh.flg_status IN
                       (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e)
                   AND eh.id_episode IN (SELECT e.id_episode
                                           FROM episode e
                                          WHERE e.id_visit = (SELECT e2.id_visit
                                                                FROM episode e2
                                                               WHERE e2.id_episode = i_episode))) t
         WHERE t.line_number = 1;
    
        RETURN l_epis_hidrics;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_oldest_hid;

    /**
    * Get the messages to appear in an error popup to be displayed when different user are performing conflicting 
    * actions at the same time.
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)   
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Sofia Mendes
    * @version v2.6.0.3
    * @since   03-Nov-2010
    */
    FUNCTION get_conflict_popup_msg
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        o_flg_show  OUT VARCHAR2,
        o_msg_title OUT VARCHAR2,
        o_msg       OUT VARCHAR2,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        o_flg_show  := pk_alert_constant.get_yes;
        o_msg_title := pk_message.get_message(i_lang => i_lang, i_prof => i_prof, i_code_mess => 'COMMON_T001');
    
        o_msg := pk_message.get_message(i_lang => i_lang, i_prof => i_prof, i_code_mess => 'INP_HIDRICS_T001');
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_CONFLICT_POPUP_MSG',
                                              o_error);
            RETURN FALSE;
    END get_conflict_popup_msg;

    /**
    * Get the epis_hidrics status
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id    
    *
    * @return  epis_hidrics.flg_status%TYPE
    *
    * @author  Sofia Mendes
    * @version v2.6.0.3.3
    * @since   08-Okt-2010
    */
    FUNCTION get_epis_hidrics_status(i_epis_hidrics epis_hidrics.id_epis_hidrics%TYPE) RETURN epis_hidrics.flg_status%TYPE IS
        l_status epis_hidrics.flg_status%TYPE;
    BEGIN
        SELECT eh.flg_status
          INTO l_status
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        RETURN l_status;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_epis_hidrics_status;

    /**
    * Checks if it is necessary to display an error popup when different user are performing conflicting 
    * actions at the same time.
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)   
    * @param   i_epis_hidrics              Epis hidrics identifier
    * @param   i_epis_hidrics_status       Epis hidrics status
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Sofia Mendes
    * @version v2.6.0.3
    * @since   03-Nov-2010
    */
    FUNCTION check_show_conflict_pop
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_epis_hidrics        IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hidrics_status IN epis_hidrics.flg_status%TYPE,
        o_flg_show            OUT VARCHAR2,
        o_msg_title           OUT VARCHAR2,
        o_msg                 OUT VARCHAR2,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_hidrics_status epis_hidrics.flg_status%TYPE;
        l_func_name           VARCHAR2(30 CHAR) := 'CHECK_SHOW_CONFLICT_POP';
    BEGIN
        IF (i_epis_hidrics_status IS NULL)
        THEN
            g_error := 'get_epis_hidrics_status for id_epis_hidrics: ' || i_epis_hidrics;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            l_epis_hidrics_status := get_epis_hidrics_status(i_epis_hidrics);
        ELSE
            l_epis_hidrics_status := i_epis_hidrics_status;
        END IF;
    
        IF (l_epis_hidrics_status IN (pk_inp_hidrics_constant.g_epis_hidric_i,
                                      pk_inp_hidrics_constant.g_epis_hidric_c,
                                      pk_inp_hidrics_constant.g_epis_hidric_f))
        THEN
            g_error := 'CALL get_conflict_popup_msg';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF NOT get_conflict_popup_msg(i_lang      => i_lang,
                                          i_prof      => i_prof,
                                          o_flg_show  => o_flg_show,
                                          o_msg_title => o_msg_title,
                                          o_msg       => o_msg,
                                          o_error     => o_error)
            THEN
                RETURN FALSE;
            END IF;
        ELSE
            o_flg_show := pk_alert_constant.get_no;
        END IF;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END check_show_conflict_pop;

    /**
    * Gets the configuration variables: inst, soft, department and dept
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_episode                   Episode id
    * @param   i_cfg_type                  Configuration type
    * @param   o_inst                      institution id
    * @param   o_soft                      software id
    * @param   o_department                department id
    * @param   o_dept                      dept id
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @value   i_cfg_type                  W - Way
    *                                      L - Location
    *                                      H - Fluid (Hidric)
    *                                      C - Characterization of Fluid (Hidric)
    *                                      I - Interval
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   20-05-2010
    */
    FUNCTION get_cfg_vars
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_episode    IN episode.id_episode%TYPE,
        i_cfg_type   IN VARCHAR2,
        o_inst       OUT institution.id_institution%TYPE,
        o_soft       OUT software.id_software%TYPE,
        o_department OUT department.id_department%TYPE,
        o_dept       OUT dept.id_dept%TYPE,
        o_id_market  OUT market.id_market%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_CFG_VARS';
        --
        l_department department.id_department%TYPE;
        l_dept       dept.id_dept%TYPE;
        l_total_dept PLS_INTEGER;
        l_id_market  market.id_market%TYPE;
        --
        l_cfg_deft_dept sys_config.id_sys_config%TYPE := 'HIDRICS_DEFAULT_DEPT';
        l_deft_dept     sys_config.value%TYPE;
        --
        e_controlled_error EXCEPTION;
        l_action_message sys_message.desc_message%TYPE;
        l_error_code     sys_message.code_message%TYPE;
        l_error_message  sys_message.desc_message%TYPE;
    BEGIN
        g_error := 'Init';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        g_error := 'GET ID_DEPARTMENT';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        BEGIN
            SELECT nvl(dcs.id_department, -1) id_department
              INTO l_department
              FROM epis_info ei
              LEFT JOIN dep_clin_serv dcs
                ON dcs.id_dep_clin_serv = ei.id_dep_clin_serv
             WHERE ei.id_episode = i_episode;
        EXCEPTION
            WHEN no_data_found THEN
                l_department := -1;
        END;
    
        g_error := 'GET ID_DEPT';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF l_department = -1
        THEN
            BEGIN
                SELECT sd.id_dept,
                       (SELECT COUNT(*)
                          FROM software_dept sd2
                          JOIN dept d2
                            ON d2.id_dept = sd2.id_dept
                         WHERE sd2.id_software = i_prof.software
                           AND d2.id_institution = i_prof.institution) total_dept
                  INTO l_dept, l_total_dept
                  FROM software_dept sd
                  JOIN dept d
                    ON d.id_dept = sd.id_dept
                 WHERE sd.id_software = i_prof.software
                   AND d.id_institution = i_prof.institution
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_total_dept := 0;
            END;
        
            --If l_total_dept = 1 then use the l_dept
            IF l_total_dept != 1
            THEN
                l_deft_dept := pk_sysconfig.get_config(i_code_cf => l_cfg_deft_dept, i_prof => i_prof);
            
                --If more then one id_dept for the current software or there were 0 dept for the current software use the configured value
                IF l_deft_dept IS NOT NULL
                THEN
                    l_dept := to_number(l_deft_dept);
                ELSIF l_total_dept = 0
                THEN
                    --If there isn't also any configured value then raise a error
                    g_error := 'ID_DEPT IS NOT DEFINED EITHER IN SOFTWARE_DEPT OR IN CFG: ' || l_cfg_deft_dept ||
                               ' FOR SOFT: ' || to_char(i_prof.software);
                    RAISE e_controlled_error;
                END IF;
            END IF;
        END IF;
    
        g_error     := 'CALL pk_utils.get_institution_market. ID_INSITUTION: ' || i_prof.institution;
        l_id_market := pk_utils.get_institution_market(i_lang => i_lang, i_id_institution => i_prof.institution);
    
        BEGIN
            IF i_cfg_type = pk_inp_hidrics_constant.g_cfg_var_h --Fluid (Hidric)
            THEN
                g_error := 'GET HIDRICS CFG_VARS';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
            
                SELECT id_institution, id_software, id_department, id_dept, id_market
                  INTO o_inst, o_soft, o_department, o_dept, o_id_market
                  FROM (SELECT nvl(hr.id_institution, 0) id_institution,
                               nvl(hr.id_software, 0) id_software,
                               nvl(hr.id_market, 0) id_market,
                               nvl(hr.id_department, 0) id_department,
                               nvl(hr.id_dept, 0) id_dept,
                               row_number() over(ORDER BY decode(nvl(hr.id_market, 0), l_id_market, 1, 2), decode(hr.id_institution, i_prof.institution, 1, 2), decode(hr.id_software, i_prof.software, 1, 2), decode(nvl(hr.id_department, 0), l_department, 1, 2), decode(nvl(hr.id_dept, 0), l_dept, 1, 2)) line_number
                          FROM hidrics_relation hr
                         WHERE EXISTS (SELECT 1
                                  FROM hidrics h
                                 WHERE h.id_hidrics = hr.id_hidrics
                                   AND h.flg_available = pk_alert_constant.g_yes)
                           AND hr.flg_available = pk_alert_constant.g_yes
                           AND hr.flg_state = pk_alert_constant.g_active
                           AND hr.id_institution IN (0, i_prof.institution)
                           AND hr.id_software IN (0, i_prof.software)
                           AND nvl(hr.id_market, 0) IN (0, l_id_market)
                           AND ((l_department != -1 AND nvl(hr.id_department, 0) IN (0, l_department)) OR
                               (l_department = -1 AND nvl(hr.id_dept, 0) IN (0, l_dept))))
                 WHERE line_number = 1;
            ELSIF i_cfg_type = pk_inp_hidrics_constant.g_cfg_var_w -- Way
            THEN
                g_error := 'GET WAYS CFG_VARS';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
            
                SELECT id_institution, NULL, id_department, id_dept, id_market
                  INTO o_inst, o_soft, o_department, o_dept, o_id_market
                  FROM (SELECT nvl(hwr.id_institution, 0) id_institution,
                               nvl(hwr.id_department, 0) id_department,
                               nvl(hwr.id_dept, 0) id_dept,
                               nvl(hwr.id_market, 0) id_market,
                               row_number() over(ORDER BY decode(nvl(hwr.id_market, 0), l_id_market, 1, 2), decode(nvl(hwr.id_department, 0), l_department, 1, 2), decode(nvl(hwr.id_dept, 0), l_dept, 1, 2), decode(hwr.id_institution, i_prof.institution, 1, 2)) line_number
                          FROM hidrics_way_rel hwr
                         WHERE EXISTS (SELECT 1
                                  FROM way hw
                                 WHERE hw.id_way = hwr.id_way
                                   AND hw.flg_available = pk_alert_constant.g_yes)
                           AND hwr.flg_available = pk_alert_constant.g_yes
                           AND nvl(hwr.id_market, 0) IN (0, l_id_market)
                           AND ((l_department != -1 AND nvl(hwr.id_department, 0) IN (0, l_department)) OR
                               (l_department = -1 AND nvl(hwr.id_dept, 0) IN (0, l_dept)))
                           AND id_institution IN (0, i_prof.institution))
                 WHERE line_number = 1;
            ELSIF i_cfg_type = pk_inp_hidrics_constant.g_cfg_var_l -- Location
            THEN
                g_error := 'GET LOCATIONS CFG_VARS';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
            
                SELECT id_institution, NULL, id_department, id_dept, id_market
                  INTO o_inst, o_soft, o_department, o_dept, o_id_market
                  FROM (SELECT nvl(hlr.id_institution, 0) id_institution,
                               nvl(hlr.id_department, 0) id_department,
                               nvl(hlr.id_dept, 0) id_dept,
                               nvl(hlr.id_market, 0) id_market,
                               row_number() over(ORDER BY decode(nvl(hlr.id_market, 0), l_id_market, 1, 2), decode(nvl(hlr.id_department, 0), l_department, 1, 2), decode(nvl(hlr.id_dept, 0), l_dept, 1, 2), decode(hlr.id_institution, i_prof.institution, 1, 2)) line_number
                          FROM hidrics_location_rel hlr
                        /*join hidrics_location hl on hl.id_hidrics_location = hlr.id_hidrics_location
                        AND hl.flg_available = pk_alert_constant.g_yes*/
                         WHERE EXISTS (SELECT 1
                                  FROM hidrics_location hl
                                 WHERE hl.id_hidrics_location = hlr.id_hidrics_location
                                   AND hl.flg_available = pk_alert_constant.g_yes)
                           AND hlr.flg_available = pk_alert_constant.g_yes
                           AND /* nvl(*/
                               hlr.id_market /*, 0)*/
                               IN (0, l_id_market)
                           AND ((l_department != -1 AND nvl(hlr.id_department, 0) IN (0, l_department)) OR
                               (l_department = -1 AND nvl(hlr.id_dept, 0) IN (0, l_dept)))
                           AND hlr.id_institution IN (0, i_prof.institution))
                 WHERE line_number = 1;
            ELSIF i_cfg_type = pk_inp_hidrics_constant.g_cfg_var_c -- Charaterization of Fluid (Hidric)
            THEN
                g_error := 'GET CHARACTERIZATION OF FLUID CFG_VARS';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
            
                SELECT id_institution, NULL, id_department, id_dept, id_market
                  INTO o_inst, o_soft, o_department, o_dept, o_id_market
                  FROM (SELECT nvl(hcr.id_institution, 0) id_institution,
                               nvl(hcr.id_department, 0) id_department,
                               nvl(hcr.id_dept, 0) id_dept,
                               nvl(hcr.id_market, 0) id_market,
                               row_number() over(ORDER BY decode(nvl(hcr.id_market, 0), l_id_market, 1, 2), decode(nvl(hcr.id_department, 0), l_department, 1, 2), decode(nvl(hcr.id_dept, 0), l_dept, 1, 2), decode(hcr.id_institution, i_prof.institution, 1, 2)) line_number
                          FROM hidrics_charact_rel hcr
                         WHERE EXISTS (SELECT 1
                                  FROM hidrics_charact hc
                                 WHERE hc.id_hidrics_charact = hcr.id_hidrics_charact
                                   AND hc.flg_available = pk_alert_constant.g_yes)
                           AND hcr.flg_available = pk_alert_constant.g_yes
                           AND nvl(hcr.id_market, 0) IN (0, l_id_market)
                           AND ((l_department != -1 AND nvl(hcr.id_department, 0) IN (0, l_department)) OR
                               (l_department = -1 AND nvl(hcr.id_dept, 0) IN (0, l_dept)))
                           AND id_institution IN (0, i_prof.institution))
                 WHERE line_number = 1;
            ELSIF i_cfg_type = pk_inp_hidrics_constant.g_cfg_var_d -- Device
            THEN
                BEGIN
                
                    g_error := 'GET CHARACTERIZATION OF FLUID CFG_VARS';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                
                    SELECT id_institution, NULL, id_department, id_dept, id_market
                      INTO o_inst, o_soft, o_department, o_dept, o_id_market
                      FROM (SELECT nvl(hdr.id_institution, 0) id_institution,
                                   nvl(hdr.id_department, 0) id_department,
                                   nvl(hdr.id_dept, 0) id_dept,
                                   nvl(hdr.id_market, 0) id_market,
                                   row_number() over(ORDER BY decode(nvl(hdr.id_market, 0), l_id_market, 1, 2), decode(nvl(hdr.id_department, 0), l_department, 1, 2), decode(nvl(hdr.id_dept, 0), l_dept, 1, 2), decode(hdr.id_institution, i_prof.institution, 1, 2)) line_number
                              FROM hidrics_device_rel hdr
                             WHERE EXISTS (SELECT 1
                                      FROM hidrics_device hd
                                     WHERE hd.id_hidrics_device = hdr.id_hidrics_device
                                       AND hd.flg_available = pk_alert_constant.g_yes)
                               AND hdr.flg_available = pk_alert_constant.g_yes
                               AND /*nvl(*/
                                   hdr.id_market /*, 0)*/
                                   IN (0, l_id_market)
                               AND ((l_department != -1 AND nvl(hdr.id_department, 0) IN (0, l_department)) OR
                                   (l_department = -1 AND nvl(hdr.id_dept, 0) IN (0, l_dept)))
                               AND id_institution IN (0, i_prof.institution))
                     WHERE line_number = 1;
                
                EXCEPTION
                    WHEN no_data_found THEN
                        g_error := l_func_name || ' - CFG_VAR NOT DEFINED - CFG_TYPE: ' || i_cfg_type || '; ID_INST: ' ||
                                   i_prof.institution || '; ID_SOFT: ' || i_prof.software || '; ID_DEPARTMENT: ' ||
                                   l_department || '; ID_DEPT: ' || l_dept;
                        pk_alertlog.log_debug(g_error);
                    
                END;
            
            ELSIF i_cfg_type = pk_inp_hidrics_constant.g_cfg_var_o -- Ocurrence type
            THEN
                BEGIN
                
                    g_error := 'GET OCCURRENCE TYPE CFG_VARS';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                
                    SELECT id_institution, NULL, id_department, id_dept, id_market
                      INTO o_inst, o_soft, o_department, o_dept, o_id_market
                      FROM (SELECT nvl(hot.id_institution, 0) id_institution,
                                   nvl(hot.id_department, 0) id_department,
                                   nvl(hot.id_dept, 0) id_dept,
                                   nvl(hot.id_market, 0) id_market,
                                   row_number() over(ORDER BY decode(nvl(hot.id_market, 0), l_id_market, 1, 2), decode(nvl(hot.id_department, 0), l_department, 1, 2), decode(nvl(hot.id_dept, 0), l_dept, 1, 2), decode(hot.id_institution, i_prof.institution, 1, 2)) line_number
                              FROM hidrics_occurs_type_rel hot
                             WHERE EXISTS (SELECT 1
                                      FROM hidrics_occurs_type ht
                                     WHERE ht.id_hidrics_occurs_type = hot.id_hidrics_occurs_type
                                       AND ht.flg_available = pk_alert_constant.g_yes)
                               AND hot.flg_available = pk_alert_constant.g_yes
                               AND nvl(hot.id_market, 0) IN (0, l_id_market)
                               AND ((l_department != -1 AND nvl(hot.id_department, 0) IN (0, l_department)) OR
                                   (l_department = -1 AND nvl(hot.id_dept, 0) IN (0, l_dept)))
                               AND id_institution IN (0, i_prof.institution))
                     WHERE line_number = 1;
                
                EXCEPTION
                    WHEN no_data_found THEN
                        g_error := l_func_name || ' - CFG_VAR NOT DEFINED - CFG_TYPE: ' || i_cfg_type || '; ID_INST: ' ||
                                   i_prof.institution || '; ID_SOFT: ' || i_prof.software || '; ID_DEPARTMENT: ' ||
                                   l_department || '; ID_DEPT: ' || l_dept;
                        pk_alertlog.log_debug(g_error);
                    
                END;
            
            ELSIF i_cfg_type = pk_inp_hidrics_constant.g_cfg_var_i -- Interval
            THEN
                g_error := 'GET HIDRICS INTERVAL CFG VARS';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
            
                SELECT id_institution, NULL, id_department, id_dept, id_market
                  INTO o_inst, o_soft, o_department, o_dept, o_id_market
                  FROM (SELECT nvl(hid.id_institution, 0) id_institution,
                               nvl(hid.id_department, 0) id_department,
                               nvl(hid.id_dept, 0) id_dept,
                               nvl(hid.id_market, 0) id_market,
                               row_number() over(ORDER BY decode(nvl(hid.id_market, 0), l_id_market, 1, 2), decode(nvl(hid.id_department, 0), l_department, 1, 2), decode(nvl(hid.id_dept, 0), l_dept, 1, 2), decode(hid.id_institution, i_prof.institution, 1, 2)) line_number
                          FROM hidrics_configurations hid
                         WHERE EXISTS (SELECT 1
                                  FROM hidrics_interval hi
                                 WHERE hi.id_hidrics_interval = hid.id_hidrics_interval
                                   AND hi.flg_available = pk_alert_constant.g_yes)
                           AND nvl(hid.id_market, 0) IN (0, l_id_market)
                           AND ((l_department != 0 AND nvl(hid.id_department, 0) IN (0, l_department)) OR
                               (l_department = 0 AND nvl(hid.id_dept, 0) IN (0, l_dept)))
                           AND hid.id_institution IN (0, i_prof.institution))
                 WHERE line_number = 1;
            ELSIF i_cfg_type = pk_inp_hidrics_constant.g_cfg_var_r -- Fluid restriction alerts
            THEN
                g_error := 'GET HIDRICS INTERVAL CFG VARS';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
            
                SELECT id_institution, NULL, id_department, id_dept, id_market
                  INTO o_inst, o_soft, o_department, o_dept, o_id_market
                  FROM (SELECT nvl(hid.id_institution, 0) id_institution,
                               nvl(hid.id_department, 0) id_department,
                               nvl(hid.id_dept, 0) id_dept,
                               nvl(hid.id_market, 0) id_market,
                               row_number() over(ORDER BY decode(nvl(hid.id_market, 0), l_id_market, 1, 2), decode(nvl(hid.id_department, 0), l_department, 1, 2), decode(nvl(hid.id_dept, 0), l_dept, 1, 2), decode(hid.id_institution, i_prof.institution, 1, 2)) line_number
                          FROM hidrics_configurations hid
                         WHERE almost_max_int IS NOT NULL
                           AND ((l_department != -1 AND nvl(hid.id_department, 0) IN (0, l_department)) OR
                               (l_department = -1 AND nvl(hid.id_dept, 0) IN (0, l_dept)))
                           AND hid.id_institution IN (0, i_prof.institution)
                           AND nvl(hid.id_market, 0) IN (0, l_id_market))
                 WHERE line_number = 1;
            END IF;
        EXCEPTION
            WHEN no_data_found THEN
                g_error := l_func_name || ' - CFG_VAR NOT DEFINED - CFG_TYPE: ' || i_cfg_type || '; ID_INST: ' ||
                           i_prof.institution || '; ID_SOFT: ' || i_prof.software || '; ID_DEPARTMENT: ' ||
                           l_department || '; ID_DEPT: ' || l_dept;
                pk_alertlog.log_debug(g_error);
                RAISE e_cfg_vars_not_defined;
        END;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_cfg_vars_not_defined THEN
            l_action_message := pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_ERR_ACT001');
            l_error_code     := 'HIDRICS_ERR001';
            l_error_message  := pk_message.get_message(i_lang => i_lang, i_code_mess => l_error_code);
        
            pk_alert_exceptions.process_error(i_lang        => i_lang,
                                              i_sqlcode     => l_error_code,
                                              i_sqlerrm     => l_error_message,
                                              i_message     => g_error,
                                              i_owner       => g_package_owner,
                                              i_package     => g_package_name,
                                              i_function    => l_func_name,
                                              i_action_type => 'U',
                                              i_action_msg  => l_action_message,
                                              o_error       => o_error);
            RAISE e_cfg_vars_not_defined;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_cfg_vars;

    /*******************************************************************************************************************************************
    * get_hidrics_type_list           Function that returns the list of available hidrics
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param O_HIDRICS_LIST           Cursor that returns the list of hidrics
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/21
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_type_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        o_hidrict_list OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'GET CURSOR O_HIDRICT_LIST';
        OPEN o_hidrict_list FOR
            SELECT ht.id_hidrics_type,
                   pk_translation.get_translation(i_lang, ht.code_hidrics_type) desc_hidrics_type,
                   ht.acronym hid_type,
                   ht.id_parent
              FROM hidrics_type ht
             WHERE flg_available = pk_alert_constant.g_yes
             ORDER BY ht.id_parent || rank;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_TYPE_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_hidrict_list);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_hidrics_type_list;

    /*******************************************************************************************************************************************
    * get_hidrics_type_list           Function that returns the list of available intervals
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param O_HIDRICS_INT            Cursor that returns the list of available intervals
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/21
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_interval
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        o_hidric_int OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'GET CURSOR O_HIDRIC_INT';
        OPEN o_hidric_int FOR
            SELECT id_hidrics_interval,
                   pk_translation.get_translation(i_lang, code_hidrics_interval) desc_hidrics_int,
                   flg_type,
                   hi.interval_minutes
              FROM hidrics_interval hi
             WHERE hi.flg_available = g_yes
             ORDER BY rank ASC;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_INTERVAL',
                                              o_error);
            pk_types.open_my_cursor(o_hidric_int);
            RETURN FALSE;
    END;

    /*******************************************************************************************************************************************
    * get_next_balance_date           Calculate the next balance date given a data and an interval (in minutes)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_date                   Date
    * @param i_interval_minutes       Interval: nr of minutes
    * 
    * @return                         Next balance calculation date
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.5
    * @since                          21-Mar-2011
    *******************************************************************************************************************************************/
    FUNCTION get_next_balance_date
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_date             IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp,
        i_interval_minutes IN hidrics_interval.interval_minutes%TYPE
    ) RETURN epis_hidrics.dt_next_balance%TYPE IS
        l_error t_error_out;
    BEGIN
        g_error := 'CALC DT next balance. i_interval_minutes: ' || i_interval_minutes;
        pk_alertlog.log_debug(g_error);
        RETURN i_date + numtodsinterval(i_interval_minutes, 'MINUTE');
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_NEXT_BALANCE_DATE',
                                              l_error);
            RETURN NULL;
    END get_next_balance_date;

    /*******************************************************************************************************************************************
    * get_next_balance_date           Calculate the next balance date given a data and an interval (in minutes)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_date                   Date
    * @param i_interval_minutes       Interval: nr of minutes
    * @param o_next_bal_dt            Next balance calculation date
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.5
    * @since                          21-Mar-2011
    *******************************************************************************************************************************************/
    FUNCTION get_next_balance_date
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_date             IN VARCHAR2,
        i_interval_minutes IN hidrics_interval.interval_minutes%TYPE,
        o_next_bal_dt      OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_date TIMESTAMP WITH LOCAL TIME ZONE;
        l_internal_error EXCEPTION;
    BEGIN
        -- Convert start date to timestamp
        g_error := 'CALL GET_STRING_TSTZ FOR l_dt_begin';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                             i_prof      => i_prof,
                                             i_timestamp => i_date,
                                             i_timezone  => NULL,
                                             o_timestamp => l_date,
                                             o_error     => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'CALC DT next balance. i_interval_minutes: ' || i_interval_minutes;
        pk_alertlog.log_debug(g_error);
        o_next_bal_dt := pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                     i_date => get_next_balance_date(i_lang             => i_lang,
                                                                                     i_prof             => i_prof,
                                                                                     i_date             => l_date,
                                                                                     i_interval_minutes => i_interval_minutes),
                                                     i_prof => i_prof);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_NEXT_BALANCE_DATE',
                                              o_error);
            RETURN FALSE;
    END get_next_balance_date;

    /*******************************************************************************************************************************************
    * get_total_hidrics               Function that returns the total admitions and eliminitions
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_EPIS_HIDRICS           EPISODE HIDRICS ID
    * @param I_EPIS_HID_BAL           HIDRIC BALANCE ID
    * @param I_DATE                   Limit date for calculations; If NULL calculates all values otherwise only the values <= i_date 
    * @param O_TOTAL_ADMIN            Total IN
    * @param O_TOTAL_ELIMIN           Total OUT
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/22
    *******************************************************************************************************************************************/
    FUNCTION get_total_hidrics
    (
        i_lang          IN language.id_language%TYPE,
        i_epis_hidrics  IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hid_bals IN table_number,
        i_date          IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_total_admin   OUT NUMBER,
        o_total_elimin  OUT NUMBER,
        o_times_admin   OUT NUMBER,
        o_times_elimin  OUT NUMBER,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        --
        CURSOR c_epis_hidrics(i_flg_type hidrics.flg_type%TYPE) IS
            SELECT nvl(SUM(ehd.value_hidrics), 0) total_admin, nvl(SUM(ehd.nr_times), 0) total_times
              FROM epis_hidrics_det ehd
              JOIN epis_hidrics_line ehl
                ON ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line
              JOIN hidrics hid
                ON hid.id_hidrics = ehl.id_hidrics
             WHERE ehd.id_epis_hidrics = i_epis_hidrics
               AND ehd.id_epis_hidrics_balance IN (SELECT /*+opt_estimate (table t rows=0.0001)*/
                                                    column_value
                                                     FROM TABLE(i_epis_hid_bals) t)
               AND hid.flg_type = i_flg_type
               AND nvl(ehd.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                   pk_inp_hidrics_constant.g_epis_hid_det_type_a
               AND ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a
               AND (ehd.dt_execution_tstz <= i_date OR i_date IS NULL);
    BEGIN
        g_error := 'OPEN C_EPIS_HIDRICS(A)';
        OPEN c_epis_hidrics(pk_inp_hidrics_constant.g_hidrics_flg_type_a);
        FETCH c_epis_hidrics
            INTO o_total_admin, o_times_admin;
        CLOSE c_epis_hidrics;
    
        g_error := 'OPEN C_EPIS_HIDRICS(E)';
        OPEN c_epis_hidrics(pk_inp_hidrics_constant.g_hidrics_flg_type_e);
        FETCH c_epis_hidrics
            INTO o_total_elimin, o_times_elimin;
        CLOSE c_epis_hidrics;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     g_package_owner,
                                                     g_package_name,
                                                     'GET_TOTAL_HIDRICS_BULK',
                                                     o_error);
    END get_total_hidrics;

    /******************************************************************************************** 
    * Check conflicts upon created drafts (verify if drafts can be requested or not) 
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id  
    * @param       i_draft                   draft id 
    * @param       o_flg_conflict            array of draft conflicts indicators
    * @param       o_msg_template            array of message/pop-up templates
    * @param       o_msg_title               array of message titles 
    * @param       o_msg_body                array of message bodies
    * @param       o_error                   error message 
    * 
    * @value       o_flg_conflict            {*} 'Y' the draft has conflicts  
    *                                        {*} 'N' no conflicts found 
    *    
    * @value       o_msg_template            {*} ' WARNING_READ' Warning Read
    *                                        {*} 'WARNING_CONFIRMATION' Warning Confirmation
    *                                        {*} 'WARNING_CANCEL' Warning Cancel
    *                                        {*} 'WARNING_HELP_SAVE' Warning Help Save
    *                                        {*} 'WARNING_SECURITY' Warning Security
    *                                        {*} 'CONFIRMATION' Confirmation
    *                                        {*} 'DETAIL' Detail
    *                                        {*} 'HELP' Help
    *                                        {*} 'WIZARD' Wizard
    *                                        {*} 'ADVANCED_INPUT' Advanced Input
    *         
    * @return                                True on success, false otherwise
    *
    * @author                                Luís Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/25
    ********************************************************************************************/
    FUNCTION check_drafts_conflicts
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_draft        IN table_number,
        o_flg_conflict OUT table_varchar,
        o_msg_template OUT table_varchar,
        o_msg_title    OUT table_varchar,
        o_msg_body     OUT table_varchar,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        --
        CURSOR c_epis_hid(l_id_epis_hid epis_hidrics.id_epis_hidrics%TYPE) IS
            SELECT eh.*
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = l_id_epis_hid;
        --
        l_flg_conflict table_varchar := table_varchar();
        l_msg_template table_varchar := table_varchar();
        l_msg_title    table_varchar := table_varchar();
        l_msg_body     table_varchar := table_varchar();
    
        l_flg_show       VARCHAR2(1 CHAR);
        l_msg_title_desc sys_message.desc_message%TYPE;
        l_msg_desc       sys_message.desc_message%TYPE;
    BEGIN
        g_error := 'GET HIDRICS CONFLICT STATUS';
        pk_alertlog.log_debug(g_error);
        --
    
        --
        FOR i IN 1 .. i_draft.count
        LOOP
            --
            FOR hid IN c_epis_hid(i_draft(i))
            LOOP
                l_flg_conflict.extend(1);
                l_msg_template.extend(1);
                l_msg_title.extend(1);
                l_msg_body.extend(1);
                --
                IF (hid.flg_status = pk_inp_hidrics_constant.g_epis_hidric_l)
                THEN
                    l_flg_conflict(l_flg_conflict.count) := pk_alert_constant.g_yes;
                    l_msg_template(l_msg_template.count) := pk_alert_constant.g_modal_win_warning_read;
                
                    g_error := 'CALL pk_inp_hidrics.get_epis_hidrics_descs';
                    IF NOT pk_inp_hidrics.get_epis_hidrics_descs(i_lang         => i_lang,
                                                                 i_prof         => i_prof,
                                                                 i_episode      => i_episode,
                                                                 i_epis_hidrics => table_number(hid.id_epis_hidrics),
                                                                 i_code_msg     => 'INP_HIDRICS_M002',
                                                                 o_flg_show     => l_flg_show,
                                                                 o_msg_title    => l_msg_title_desc,
                                                                 o_msg          => l_msg_desc,
                                                                 o_error        => o_error)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                    l_msg_title(l_msg_title.count) := l_msg_title_desc;
                    l_msg_body(l_msg_body.count) := l_msg_desc;
                ELSE
                    l_flg_conflict(l_flg_conflict.count) := pk_alert_constant.g_no;
                    l_msg_template(l_msg_template.count) := '';
                    l_msg_title(l_msg_title.count) := '';
                    l_msg_body(l_msg_body.count) := '';
                END IF;
            END LOOP;
        END LOOP;
    
        --
        o_flg_conflict := l_flg_conflict;
        o_msg_template := l_msg_template;
        o_msg_title    := l_msg_title;
        o_msg_body     := l_msg_body;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     g_package_owner,
                                                     g_package_name,
                                                     'CHECK_DRAFTS_CONFLICTS',
                                                     o_error);
    END check_drafts_conflicts;

    /******************************************************************************************** 
    * Get the number of hours in a hidrics interval
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_interval_minutes        interval considered in the current hidrics record
    * @param       i_hidrics_view            current view: H - hour
                                                           I - interval
    *         
    * @return                                interval (number of hours)
    *
    * @author                                José ilva
    * @version                               2.6.0.3
    * @since                                 2010/06/21
    ********************************************************************************************/
    FUNCTION get_epis_hidrics_interval
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_interval_minutes IN hidrics_interval.interval_minutes%TYPE,
        i_hidric_view      IN sys_domain.val%TYPE
    ) RETURN NUMBER IS
    
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_INTERVAL';
        l_error     t_error_out;
        l_interval  NUMBER;
    
    BEGIN
    
        IF nvl(i_hidric_view, pk_inp_hidrics_constant.g_graph_interval) = pk_inp_hidrics_constant.g_graph_interval
        THEN
        
            g_error := 'GET HIDRICS INTERVAL';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
        
            l_interval := i_interval_minutes / 60;
        
        ELSIF i_hidric_view = pk_inp_hidrics_constant.g_graph_hour
        THEN
            g_error := 'GET HIDRICS HOUR';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            l_interval := 1;
        END IF;
    
        --
        RETURN l_interval;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_epis_hidrics_interval;

    /******************************************************************************************** 
    * Check if this hidrics type is a hidrics balance
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_hidrics_type            Hidrics type ID
    *         
    * @return                                It is a hidrics balance (True or False)
    *
    * @author                                José Silva
    * @version                               2.6.0.3
    * @since                                 2010/06/14
    ********************************************************************************************/
    FUNCTION is_hidrics_balance
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_hidrics_type IN hidrics_type.id_hidrics_type%TYPE
    ) RETURN NUMBER IS
    
        l_is_balance NUMBER := 0;
        l_acronym    hidrics_type.acronym%TYPE;
        l_error      t_error_out;
    
    BEGIN
    
        SELECT h.acronym
          INTO l_acronym
          FROM hidrics_type h
         WHERE h.id_hidrics_type = i_hidrics_type;
    
        IF l_acronym = pk_inp_hidrics_constant.g_hid_type_h
        THEN
            l_is_balance := 1;
        END IF;
    
        --
        RETURN l_is_balance;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'IS_HIDRICS_BALANCE',
                                              l_error);
            RETURN 0;
    END is_hidrics_balance;

    /******************************************************************************************** 
    * Checks if the hidrics is an elimination or administration based on the hidrics type ID
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_hidrics_type            Hidrics type ID
    *         
    * @return                                Hidrics type: A - administration, E - elimination
    *
    * @author                                José ilva
    * @version                               2.6.0.3
    * @since                                 2010/07/26
    ********************************************************************************************/
    FUNCTION get_hidrics_type
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_hidrics_type IN hidrics_type.id_hidrics_type%TYPE
    ) RETURN VARCHAR2 IS
    
        l_type_hidrics hidrics.flg_type%TYPE;
        l_acronym      hidrics_type.acronym%TYPE;
        l_error        t_error_out;
    
    BEGIN
    
        SELECT h.acronym
          INTO l_acronym
          FROM hidrics_type h
         WHERE h.id_hidrics_type = i_hidrics_type;
    
        IF l_acronym IN (pk_inp_hidrics_constant.g_hid_type_d,
                         pk_inp_hidrics_constant.g_hid_type_r,
                         pk_inp_hidrics_constant.g_hid_type_o,
                         pk_inp_hidrics_constant.g_hid_type_all)
        THEN
            l_type_hidrics := pk_inp_hidrics_constant.g_hidrics_flg_type_e;
        ELSIF l_acronym IN (pk_inp_hidrics_constant.g_hid_type_i)
        THEN
            l_type_hidrics := pk_inp_hidrics_constant.g_hidrics_flg_type_a;
        ELSE
            l_type_hidrics := '';
        END IF;
    
        --
        RETURN l_type_hidrics;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_TYPE',
                                              l_error);
            RETURN '';
    END get_hidrics_type;

    /******************************************************************************************** 
    * Gets the total administration for a specific balance
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_epis_hidrics            Episode hidrics ID
    * @param       i_total_admin             Total administrations
    * @param       i_dt_open                 Balance begin date
    * @param       i_dt_close                Balance end date
    *         
    * @return                                It is a hidrics balance (True or False)
    *
    * @author                                José ilva
    * @version                               2.6.0.3
    * @since                                 2010/06/30
    ********************************************************************************************/
    FUNCTION get_total_admin
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_total_admin  IN epis_hidrics_balance.total_admin%TYPE,
        i_dt_open      IN epis_hidrics_balance.dt_open_tstz%TYPE,
        i_dt_close     IN epis_hidrics_balance.dt_close_balance_tstz%TYPE
    ) RETURN NUMBER IS
    
        l_total_admin      NUMBER(26, 2) := 0;
        l_error            t_error_out;
        l_count            NUMBER := 0;
        l_import_iv_fluids sys_config.id_sys_config%TYPE;
    BEGIN
        l_total_admin := nvl(i_total_admin, 0);
    
        g_error := 'GET import_iv_fluids sys_config';
        pk_alertlog.log_debug(g_error);
        l_import_iv_fluids := pk_sysconfig.get_config(i_code_cf => pk_inp_hidrics_constant.g_import_iv_fluids,
                                                      i_prof    => i_prof);
    
        IF l_import_iv_fluids = pk_alert_constant.g_yes
        THEN
            SELECT COUNT(1)
              INTO l_count
              FROM epis_hidrics eh
              JOIN hidrics_type ht
                ON ht.id_hidrics_type = eh.id_hidrics_type
             WHERE eh.id_epis_hidrics = i_epis_hidrics
               AND ht.acronym IN (pk_inp_hidrics_constant.g_hid_type_i, pk_inp_hidrics_constant.g_hid_type_h);
        
            IF l_count > 0
            THEN
                g_error := 'get total admin for id_epis_hidrics ' || i_epis_hidrics;
                pk_alertlog.log_debug(g_error);
                l_total_admin := l_total_admin +
                                 nvl(pk_api_pfh_clindoc_in.get_fluid_balance_med_tot(i_lang,
                                                                                     i_prof,
                                                                                     i_epis_hidrics,
                                                                                     i_dt_open,
                                                                                     nvl(i_dt_close, current_timestamp)),
                                     0);
            END IF;
        END IF;
    
        RETURN l_total_admin;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TOTAL_ADMIN',
                                              l_error);
            RETURN 0;
    END get_total_admin;

    /******************************************************************************************** 
    * Check if balance hour
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_dt_start                Start date
    * @param       o_msg_title               Title message
    * @param       o_msg_text                Text message
    * @param       o_show_msg                'Y' - show message; Otherwise 'N'
    * @param       o_error                   Current total administrations
    *         
    * @return                                Returns TRUE if success, otherwise returns FALSE
    *
    * @author                                Alexandre Santos
    * @version                               2.6.0.3
    * @since                                 2010/07/02
    ********************************************************************************************/
    FUNCTION check_balance_hour
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_dt_start  IN VARCHAR2,
        o_msg_title OUT VARCHAR2,
        o_msg_text  OUT VARCHAR2,
        o_show_msg  OUT VARCHAR2,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'CHECK_BALANCE_HOUR';
        --
        l_minute PLS_INTEGER;
    BEGIN
        l_minute   := extract(minute FROM pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_start, NULL));
        o_show_msg := pk_alert_constant.g_no;
    
        IF NOT (l_minute = 0 OR l_minute = 30)
        THEN
            o_msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_T082');
            o_msg_text  := pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_M044');
            o_show_msg  := pk_alert_constant.g_yes;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END check_balance_hour;

    /*******************************************************************************************************************************************
    * Get the message for the restrictions on Max Intake, Min Output and Almost Max Intake
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_ID_EPIS_HIDRICS        EPIS_HIDRICS ID
    * @param I_FLG_TYPE               Type of message to return
    * @param I_VALUE_INTAKE_OUTPUT    Max Intake/Almost Max Intake/Min Output value
    * @param I_MIN_OUTPUT             Min Output value
    * @param IO_MSG_TITLE             Title to be returned
    * @param IO_MSG_TEXT              Text to be returned
    * 
    * @value I_FLG_TYPE               'OH' - Only Header, 'TI' - Title and Text in Max Intake, 'TO' - Title and Text in Min Output
    *                                 'AI' - Title and Text in Almost Max Intake
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @author                         António Neto
    * @version                        2.6.1.0.1
    * @since                          28-Apr-2011
    *******************************************************************************************************************************************/
    FUNCTION get_msg_max_min_intake_output
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_type            IN VARCHAR2,
        i_value_intake_output IN NUMBER,
        io_msg_title          IN OUT VARCHAR2,
        io_msg_text           IN OUT VARCHAR2
    ) RETURN BOOLEAN IS
        l_replace1  sys_alert_event.replace1%TYPE;
        l_msg_title sys_message.desc_message%TYPE;
        l_msg_text  sys_message.desc_message%TYPE;
    BEGIN
        l_replace1 := '(' || i_value_intake_output || ' ' || get_hidrics_um(i_lang, i_prof, i_id_epis_hidrics) || ')';
    
        IF i_flg_type = 'OH'
        THEN
            l_msg_title := l_replace1;
            l_msg_text  := NULL;
        ELSIF i_flg_type = 'TI'
              OR i_flg_type = 'AI'
        THEN
            IF io_msg_title IS NULL
            THEN
                l_msg_title := pk_message.get_message(i_lang, 'HIDRICS_T083');
            ELSE
                l_msg_title := pk_message.get_message(i_lang, 'HIDRICS_T091');
                l_msg_text  := io_msg_text || chr(10);
            END IF;
        
            l_msg_text := l_msg_text || REPLACE(CASE
                                                    WHEN i_flg_type = 'TI' THEN
                                                     pk_message.get_message(i_lang, 'HIDRICS_M040')
                                                    ELSE
                                                     pk_message.get_message(i_lang, 'HIDRICS_M034')
                                                END,
                                                '@1',
                                                l_replace1);
        ELSIF i_flg_type = 'TO'
        THEN
            IF io_msg_title IS NULL
            THEN
                l_msg_title := pk_message.get_message(i_lang, 'HIDRICS_T084');
            ELSE
                l_msg_title := pk_message.get_message(i_lang, 'HIDRICS_T091');
                l_msg_text  := io_msg_text || chr(10);
            END IF;
            l_msg_text := l_msg_text || REPLACE(pk_message.get_message(i_lang, 'HIDRICS_M035'), '@1', l_replace1);
        END IF;
    
        io_msg_title := l_msg_title;
        io_msg_text  := l_msg_text;
    
        RETURN TRUE;
    
    END get_msg_max_min_intake_output;

    /******************************************************************************************** 
    * Check if the current total value exceeds fluid restrictions
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_max_intake              Maximum intake
    * @param       i_min_output              Minimum output
    * @param       i_flg_type                Hidrics type: (A)dministration or (E)limination
    * @param       i_total_admin             Current total administrations
    * @param       i_total_elim              Current total eliminations
    * @param       i_flg_reg_type            Record type: N - regular values, T - balance values
    *         
    * @return                                Shows text in red color: Y - yes, N - No
    *
    * @author                                José ilva
    * @version                               2.6.0.3
    * @since                                 2010/06/14
    ********************************************************************************************/
    FUNCTION check_restriction_alerts
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        i_max_intake   IN epis_hidrics.max_intake%TYPE,
        i_min_output   IN epis_hidrics.min_output%TYPE,
        i_hidrics_type IN hidrics_type.id_hidrics_type%TYPE,
        i_flg_context  IN VARCHAR2,
        i_dt_execution IN epis_hidrics_det.dt_execution_tstz%TYPE,
        o_msg_title    OUT VARCHAR2,
        o_msg_text     OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name VARCHAR2(30 CHAR) := 'CHECK_RESTRICTION_ALERTS';
    
        l_total_admin epis_hidrics_balance.total_admin%TYPE;
        l_total_elim  epis_hidrics_balance.total_elim%TYPE;
        l_id_balance  epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_dt_open     epis_hidrics_balance.dt_open_tstz%TYPE;
        l_dt_close    epis_hidrics_balance.dt_close_balance_tstz%TYPE;
    
        l_count     NUMBER;
        l_replace1  sys_alert_event.replace1%TYPE;
        l_msg_title sys_message.desc_message%TYPE;
        l_msg_text  sys_message.desc_message%TYPE;
    
        l_inst       institution.id_institution%TYPE;
        l_soft       software.id_software%TYPE;
        l_department department.id_department%TYPE;
        l_dept       dept.id_dept%TYPE;
        l_almost_max hidrics_configurations.almost_max_int%TYPE;
    
        l_max_intake   epis_hidrics.max_intake%TYPE;
        l_min_output   epis_hidrics.min_output%TYPE;
        l_hidrics_type hidrics_type.id_hidrics_type%TYPE;
        l_episode      epis_hidrics.id_episode%TYPE;
        l_id_market    market.id_market%TYPE;
    
        l_ret BOOLEAN;
    
        CURSOR c_count_alert
        (
            i_sys_alert sys_alert.id_sys_alert%TYPE,
            i_id_reg    sys_alert_event.id_record%TYPE
        ) IS
            SELECT COUNT(*)
              FROM sys_alert_event sa
             WHERE sa.id_sys_alert = i_sys_alert
               AND sa.id_record = i_id_reg;
    
        CURSOR c_max_intake IS
            SELECT h.almost_max_int
              FROM hidrics_configurations h
             WHERE h.id_institution = l_inst
               AND h.id_department = l_department
               AND h.id_dept = l_dept
               AND h.almost_max_int IS NOT NULL;
    
        CURSOR c_epis_balance IS
            SELECT eb.total_admin, eb.total_elim, eb.id_epis_hidrics_balance, eb.dt_open_tstz, eb.dt_close_balance_tstz
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics_balance = nvl(i_epis_balance, eb.id_epis_hidrics_balance)
               AND eb.id_epis_hidrics = i_epis_hidrics
               AND (eb.dt_close_balance_tstz IS NOT NULL OR
                   i_flg_context <> pk_inp_hidrics_constant.g_context_msg_end_balance)
             ORDER BY dt_close_balance_tstz DESC NULLS FIRST;
    
    BEGIN
        g_error := 'GET TOTAL BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN c_epis_balance;
        FETCH c_epis_balance
            INTO l_total_admin, l_total_elim, l_id_balance, l_dt_open, l_dt_close;
        CLOSE c_epis_balance;
    
        g_error       := 'SUM MEDICATION ADMIN';
        l_total_admin := get_total_admin(i_lang, i_prof, i_epis_hidrics, l_total_admin, l_dt_open, l_dt_close);
    
        g_error := 'GET HIDRICS INFO';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF i_episode IS NULL
        THEN
            SELECT e.max_intake, e.min_output, e.id_hidrics_type, e.id_episode
              INTO l_max_intake, l_min_output, l_hidrics_type, l_episode
              FROM epis_hidrics e
             WHERE e.id_epis_hidrics = i_epis_hidrics;
        ELSE
            l_max_intake   := i_max_intake;
            l_min_output   := i_min_output;
            l_hidrics_type := i_hidrics_type;
            l_episode      := i_episode;
        END IF;
    
        IF i_flg_context IN
           (pk_inp_hidrics_constant.g_context_end_balance, pk_inp_hidrics_constant.g_context_new_record)
        THEN
            g_error := 'CHECK ALERT TOTAL BALANCE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
        
            IF l_dt_close IS NOT NULL
               AND l_total_admin - l_total_elim <> 0
               AND is_hidrics_balance(i_lang, i_prof, l_hidrics_type) > 0
            THEN
                OPEN c_count_alert(pk_inp_hidrics_constant.g_alert_total_balance, l_id_balance);
                FETCH c_count_alert
                    INTO l_count;
                CLOSE c_count_alert;
            
                IF l_count = 0
                THEN
                    IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                            i_prof                => i_prof,
                                                            i_sys_alert           => pk_inp_hidrics_constant.g_alert_total_balance,
                                                            i_id_episode          => l_episode,
                                                            i_id_record           => l_id_balance,
                                                            i_dt_record           => current_timestamp,
                                                            i_id_professional     => NULL,
                                                            i_id_room             => NULL,
                                                            i_id_clinical_service => NULL,
                                                            i_flg_type_dest       => NULL,
                                                            i_replace1            => NULL,
                                                            o_error               => o_error)
                    THEN
                        RAISE e_error;
                    END IF;
                END IF;
            ELSE
                DELETE FROM sys_alert_event sa
                 WHERE sa.id_sys_alert = pk_inp_hidrics_constant.g_alert_total_balance
                   AND sa.id_record = l_id_balance;
            END IF;
        
            g_error := 'CHECK ALERT MIN OUTPUT';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF l_min_output IS NOT NULL
               AND l_total_elim < l_min_output
               AND l_total_elim <> 0
            THEN
                OPEN c_count_alert(pk_inp_hidrics_constant.g_alert_min_output, l_id_balance);
                FETCH c_count_alert
                    INTO l_count;
                CLOSE c_count_alert;
            
                IF l_count = 0
                THEN
                
                    l_ret := get_msg_max_min_intake_output(i_lang                => i_lang,
                                                           i_prof                => i_prof,
                                                           i_id_epis_hidrics     => i_epis_hidrics,
                                                           i_flg_type            => 'OH',
                                                           i_value_intake_output => l_min_output,
                                                           io_msg_title          => l_replace1,
                                                           io_msg_text           => l_msg_text);
                
                    IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                            i_prof                => i_prof,
                                                            i_sys_alert           => pk_inp_hidrics_constant.g_alert_min_output,
                                                            i_id_episode          => l_episode,
                                                            i_id_record           => l_id_balance,
                                                            i_dt_record           => current_timestamp,
                                                            i_id_professional     => NULL,
                                                            i_id_room             => NULL,
                                                            i_id_clinical_service => NULL,
                                                            i_flg_type_dest       => NULL,
                                                            i_replace1            => l_replace1,
                                                            o_error               => o_error)
                    THEN
                        RAISE e_error;
                    END IF;
                END IF;
            ELSE
                DELETE FROM sys_alert_event sa
                 WHERE sa.id_sys_alert = pk_inp_hidrics_constant.g_alert_min_output
                   AND sa.id_record = l_id_balance;
            END IF;
        
            g_error := 'CHECK ALERT MAX INTAKE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF l_max_intake IS NOT NULL
               AND l_total_admin >= l_max_intake
            THEN
                OPEN c_count_alert(pk_inp_hidrics_constant.g_alert_max_intake, l_id_balance);
                FETCH c_count_alert
                    INTO l_count;
                CLOSE c_count_alert;
            
                IF l_count = 0
                THEN
                
                    l_ret := get_msg_max_min_intake_output(i_lang                => i_lang,
                                                           i_prof                => i_prof,
                                                           i_id_epis_hidrics     => i_epis_hidrics,
                                                           i_flg_type            => 'OH',
                                                           i_value_intake_output => l_max_intake,
                                                           io_msg_title          => l_replace1,
                                                           io_msg_text           => l_msg_text);
                
                    IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                            i_prof                => i_prof,
                                                            i_sys_alert           => pk_inp_hidrics_constant.g_alert_max_intake,
                                                            i_id_episode          => l_episode,
                                                            i_id_record           => l_id_balance,
                                                            i_dt_record           => current_timestamp,
                                                            i_id_professional     => NULL,
                                                            i_id_room             => NULL,
                                                            i_id_clinical_service => NULL,
                                                            i_flg_type_dest       => NULL,
                                                            i_replace1            => l_replace1,
                                                            o_error               => o_error)
                    THEN
                        RAISE e_error;
                    END IF;
                END IF;
            ELSE
                DELETE FROM sys_alert_event sa
                 WHERE sa.id_sys_alert = pk_inp_hidrics_constant.g_alert_max_intake
                   AND sa.id_record = l_id_balance;
            END IF;
        
        ELSIF i_flg_context IN
              (pk_inp_hidrics_constant.g_context_msg_end_balance, pk_inp_hidrics_constant.g_context_msg_new_record)
        THEN
        
            IF i_flg_context = pk_inp_hidrics_constant.g_context_msg_new_record
            THEN
                IF l_max_intake IS NOT NULL
                THEN
                    g_error := 'CHECK MSG MAX INTAKE';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    IF l_total_admin >= l_max_intake
                    THEN
                        l_ret := get_msg_max_min_intake_output(i_lang                => i_lang,
                                                               i_prof                => i_prof,
                                                               i_id_epis_hidrics     => i_epis_hidrics,
                                                               i_flg_type            => 'TI',
                                                               i_value_intake_output => l_max_intake,
                                                               io_msg_title          => l_msg_title,
                                                               io_msg_text           => l_msg_text);
                    
                    ELSE
                        g_error := 'GET CONF VARS - INTERVAL';
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        IF NOT (get_cfg_vars(i_lang       => i_lang,
                                             i_prof       => i_prof,
                                             i_episode    => l_episode,
                                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_r,
                                             o_inst       => l_inst,
                                             o_soft       => l_soft,
                                             o_department => l_department,
                                             o_dept       => l_dept,
                                             o_id_market  => l_id_market,
                                             o_error      => o_error))
                        THEN
                            RAISE e_error;
                        END IF;
                    
                        g_error := 'GET HIDRICS MAX INTAKE';
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        OPEN c_max_intake;
                        FETCH c_max_intake
                            INTO l_almost_max;
                        CLOSE c_max_intake;
                    
                        IF l_total_admin >= (l_almost_max * l_max_intake / 100)
                        THEN
                            l_ret := get_msg_max_min_intake_output(i_lang                => i_lang,
                                                                   i_prof                => i_prof,
                                                                   i_id_epis_hidrics     => i_epis_hidrics,
                                                                   i_flg_type            => 'AI',
                                                                   i_value_intake_output => l_max_intake,
                                                                   io_msg_title          => l_msg_title,
                                                                   io_msg_text           => l_msg_text);
                        END IF;
                    
                    END IF;
                END IF;
            
                IF l_min_output IS NOT NULL
                   AND l_total_elim < l_min_output
                   AND l_total_elim <> 0
                THEN
                    l_ret := get_msg_max_min_intake_output(i_lang                => i_lang,
                                                           i_prof                => i_prof,
                                                           i_id_epis_hidrics     => i_epis_hidrics,
                                                           i_flg_type            => 'TO',
                                                           i_value_intake_output => l_min_output,
                                                           io_msg_title          => l_msg_title,
                                                           io_msg_text           => l_msg_text);
                
                END IF;
            ELSIF i_flg_context = pk_inp_hidrics_constant.g_context_msg_end_balance
            THEN
                g_error := 'CHECK MSG MIN OUTPUT';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                IF l_max_intake IS NOT NULL
                   AND l_total_admin >= l_max_intake
                THEN
                    l_ret := get_msg_max_min_intake_output(i_lang                => i_lang,
                                                           i_prof                => i_prof,
                                                           i_id_epis_hidrics     => i_epis_hidrics,
                                                           i_flg_type            => 'TI',
                                                           i_value_intake_output => l_max_intake,
                                                           io_msg_title          => l_msg_title,
                                                           io_msg_text           => l_msg_text);
                END IF;
            
                IF l_min_output IS NOT NULL
                   AND l_total_elim < l_min_output
                   AND l_total_elim <> 0
                THEN
                    l_ret := get_msg_max_min_intake_output(i_lang                => i_lang,
                                                           i_prof                => i_prof,
                                                           i_id_epis_hidrics     => i_epis_hidrics,
                                                           i_flg_type            => 'TO',
                                                           i_value_intake_output => l_min_output,
                                                           io_msg_title          => l_msg_title,
                                                           io_msg_text           => l_msg_text);
                
                END IF;
            
            END IF;
        
            o_msg_text  := l_msg_text;
            o_msg_title := l_msg_title;
        
        END IF;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN e_cfg_vars_not_defined THEN
            pk_alert_exceptions.reset_error_state;
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END check_restriction_alerts;

    /******************************************************************************************** 
    * Check if the current total value exceeds fluid restrictions
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_epis_hidrics            episode hidrics ID
    * @param       i_max_intake              Maximum intake
    * @param       i_min_output              Minimum output
    * @param       i_flg_type                Hidrics type: (A)dministration or (E)limination
    * @param       i_total_admin             Current total administrations
    * @param       i_total_elim              Current total eliminations
    * @param       i_flg_reg_type            Record type: N - regular values, T - balance values
    *         
    * @return                                Shows text in red color: Y - yes, N - No
    *
    * @author                                José ilva
    * @version                               2.6.0.3
    * @since                                 2010/06/10
    ********************************************************************************************/
    FUNCTION check_fluid_restrictions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_max_intake   IN epis_hidrics.max_intake%TYPE,
        i_min_output   IN epis_hidrics.min_output%TYPE,
        i_flg_type     IN hidrics.flg_type%TYPE,
        i_total_admin  IN epis_hidrics_balance.total_admin%TYPE,
        i_total_elim   IN epis_hidrics_balance.total_elim%TYPE,
        i_dt_open      IN epis_hidrics_balance.dt_open_tstz%TYPE,
        i_dt_close     IN epis_hidrics_balance.dt_close_balance_tstz%TYPE,
        i_flg_reg_type IN VARCHAR2 DEFAULT NULL,
        i_hidrics_type IN hidrics_type.id_hidrics_type%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
        --
        l_show_red_color VARCHAR2(24 CHAR) := pk_alert_constant.g_no;
        l_error          t_error_out;
        l_total_admin    epis_hidrics_balance.total_admin%TYPE;
    
    BEGIN
    
        IF nvl(i_flg_reg_type, pk_inp_hidrics_constant.g_element_total) = pk_inp_hidrics_constant.g_element_total
        THEN
        
            l_total_admin := get_total_admin(i_lang, i_prof, i_epis_hidrics, i_total_admin, i_dt_open, i_dt_close);
        
            IF i_flg_type IS NULL
               AND i_flg_reg_type = pk_inp_hidrics_constant.g_element_total
               AND l_total_admin <> 0
               AND is_hidrics_balance(i_lang, i_prof, i_hidrics_type) > 0
            THEN
                l_show_red_color := pk_alert_constant.g_yes;
            ELSIF nvl(i_flg_type, pk_inp_hidrics_constant.g_hidrics_flg_type_a) =
                  pk_inp_hidrics_constant.g_hidrics_flg_type_a
                  AND i_max_intake < l_total_admin
            THEN
                l_show_red_color := pk_alert_constant.g_yes;
            ELSIF nvl(i_flg_type, pk_inp_hidrics_constant.g_hidrics_flg_type_e) =
                  pk_inp_hidrics_constant.g_hidrics_flg_type_e
                  AND i_min_output > i_total_elim
            THEN
                l_show_red_color := pk_alert_constant.g_yes;
            END IF;
        END IF;
    
        --
        RETURN l_show_red_color;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CHECK_FLUID_RESTRICTIONS',
                                              l_error);
            RETURN pk_alert_constant.g_no;
    END check_fluid_restrictions;

    /*******************************************************************************************************************************************
    * INSERT_EPIS_HIDRICS             Function responsable for update an hidrics registry
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE that should be associated with current request
    * @param I_ID_EPIS_HIDRICS        EPIS_HIDRICS ID
    * @param I_DT_INITIAL_STR         Begin date for this request
    * @param I_DT_END_STR             End date for this request
    * @param I_HID_INTERV             ID of interval between hidrics registries
    * @param i_interval_minutes       Interval in minutes
    * @param I_NOTES                  Notes associated with current request
    * @param I_HID_TYPE               ID of current hidric type
    * @param I_EPIS_HIDRICS_FLG_STAT  EPIS_HIDRICS flag status
    * @param O_ID_EPIS_HIDRICS        Cursor that returns created id_epis_hidrics
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_EPIS_HIDRICS_FLG_STAT  {*} 'D' Draft {*} 'R' Required
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Luís Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/19
    *******************************************************************************************************************************************/
    FUNCTION insert_epis_hidrics
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_episode               IN episode.id_episode%TYPE,
        i_patient               IN patient.id_patient%TYPE,
        i_hidrics_type          IN epis_hidrics.id_hidrics_type%TYPE,
        i_dt_initial_str        IN VARCHAR2,
        i_dt_end_str            IN VARCHAR2,
        i_dt_next_balance       IN VARCHAR2,
        i_hid_interv            IN hidrics_interval.id_hidrics_interval%TYPE,
        i_interval_minutes      IN hidrics_interval.interval_minutes%TYPE,
        i_notes                 IN epis_hidrics.notes%TYPE,
        i_epis_hidrics_flg_stat IN epis_hidrics.flg_status%TYPE,
        i_flg_restricted        IN epis_hidrics.flg_restricted%TYPE,
        i_max_intake            IN epis_hidrics.max_intake%TYPE,
        i_min_output            IN epis_hidrics.min_output%TYPE,
        i_flg_action            IN epis_hidrics.flg_action%TYPE,
        o_id_epis_hidrics       OUT epis_hidrics.id_epis_hidrics%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_dt_initial      epis_hidrics.dt_initial_tstz%TYPE;
        l_dt_end          epis_hidrics.dt_end_tstz%TYPE;
        l_dt_next_balance epis_hidrics.dt_next_balance%TYPE;
        l_next_eh         epis_hidrics.id_epis_hidrics%TYPE;
        l_rowids          table_varchar := table_varchar();
        l_icnp_interv EXCEPTION;
    BEGIN
        -- Prepare dates
        l_dt_initial      := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_initial_str, NULL);
        l_dt_end          := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_end_str, NULL);
        l_dt_next_balance := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_next_balance, NULL);
    
        --    
        g_error   := 'GET SEQ_EPIS_HIDRICS.NEXTVAL';
        l_next_eh := ts_epis_hidrics.next_key;
    
        --
        g_error := 'CALL TS_EPIS_HIDRICS.INS WITH ID_EPIS_HIDRICS ' || l_next_eh;
        pk_alertlog.log_debug(g_error);
        l_rowids := table_varchar();
        ts_epis_hidrics.ins(id_epis_hidrics_in     => l_next_eh,
                            id_hidrics_type_in     => i_hidrics_type,
                            id_professional_in     => i_prof.id,
                            id_episode_in          => i_episode,
                            id_patient_in          => i_patient,
                            id_hidrics_interval_in => i_hid_interv,
                            flg_status_in          => i_epis_hidrics_flg_stat,
                            notes_in               => i_notes,
                            id_prof_cancel_in      => NULL,
                            notes_cancel_in        => NULL,
                            id_prof_inter_in       => NULL,
                            notes_inter_in         => NULL,
                            dt_creation_tstz_in    => g_sysdate_tstz,
                            dt_initial_tstz_in     => l_dt_initial,
                            dt_end_tstz_in         => l_dt_end,
                            dt_next_balance_in     => l_dt_next_balance,
                            dt_cancel_tstz_in      => NULL,
                            dt_inter_tstz_in       => NULL,
                            flg_restricted_in      => i_flg_restricted,
                            max_intake_in          => i_max_intake,
                            min_output_in          => i_min_output,
                            id_prof_last_change_in => i_prof.id,
                            dt_epis_hidrics_in     => g_sysdate_tstz,
                            flg_action_in          => i_flg_action,
                            interval_minutes_in    => i_interval_minutes,
                            rows_out               => l_rowids);
    
        g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS ' || l_next_eh;
        pk_alertlog.log_debug(g_error);
        t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
        --
    
        IF i_epis_hidrics_flg_stat = pk_inp_hidrics_constant.g_epis_hidric_r
        THEN
            IF NOT create_assoc_icnp_interv(i_lang            => i_lang,
                                            i_prof            => i_prof,
                                            i_id_epis_hidrics => l_next_eh,
                                            i_id_episode      => i_episode,
                                            i_id_hidrics_type => i_hidrics_type,
                                            o_error           => o_error)
            THEN
                RAISE l_icnp_interv;
            END IF;
        END IF;
    
        o_id_epis_hidrics := l_next_eh;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'INSERT_EPIS_HIDRICS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END insert_epis_hidrics;

    /*******************************************************************************************************************************************
    * UPDATE_EPIS_HIDRICS             Function responsable for update an hidrics registry
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE that should be associated with current request
    * @param I_ID_EPIS_HIDRICS        EPIS_HIDRICS ID
    * @param I_DT_INITIAL_STR         Begin date for this request
    * @param I_DT_END_STR             End date for this request
    * @param I_HID_INTERV             ID of interval between hidrics registries
    * @param i_interval_minutes       Interval in minutes (cames from 'Other' option)
    * @param I_NOTES                  Notes associated with current request
    * @param I_HID_TYPE               ID of current hidric type
    * @param I_EPIS_HIDRICS_FLG_STAT  EPIS_HIDRICS flag status
    * @param O_ID_EPIS_HIDRICS        Cursor that returns created id_epis_hidrics
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_EPIS_HIDRICS_FLG_STAT  {*} 'D' Draft {*} 'R' Required
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Luï¿½Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/19
    *******************************************************************************************************************************************/
    FUNCTION update_epis_hidrics
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_episode               IN episode.id_episode%TYPE,
        i_epis_hidrics          IN epis_hidrics.id_epis_hidrics%TYPE,
        i_dt_initial_str        IN VARCHAR2,
        i_dt_end_str            IN VARCHAR2,
        i_dt_next_balance       IN VARCHAR2,
        i_hid_interv            IN hidrics_interval.id_hidrics_interval%TYPE,
        i_interval_minutes      IN epis_hidrics.interval_minutes%TYPE,
        i_notes                 IN epis_hidrics.notes%TYPE,
        i_hid_type              IN epis_hidrics.id_hidrics_type%TYPE,
        i_epis_hidrics_flg_stat IN epis_hidrics.flg_status%TYPE,
        i_flg_restricted        IN epis_hidrics.flg_restricted%TYPE,
        i_max_intake            IN epis_hidrics.max_intake%TYPE,
        i_min_output            IN epis_hidrics.min_output%TYPE,
        o_id_epis_hidrics       OUT epis_hidrics.id_epis_hidrics%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_dt_initial      epis_hidrics.dt_initial_tstz%TYPE;
        l_dt_end          epis_hidrics.dt_end_tstz%TYPE;
        l_dt_next_balance epis_hidrics.dt_next_balance%TYPE;
        l_rowids          table_varchar := table_varchar();
        l_hid_type        epis_hidrics.id_hidrics_type%TYPE;
        --
        l_icnp_interv EXCEPTION;
    
        CURSOR c_epis_hid IS
            SELECT eh.id_hidrics_type
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = i_epis_hidrics;
    BEGIN
        -- Prepare dates
        l_dt_initial      := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_initial_str, NULL);
        l_dt_end          := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_end_str, NULL);
        l_dt_next_balance := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_next_balance, NULL);
        --
        g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || i_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        IF i_epis_hidrics_flg_stat != pk_inp_hidrics_constant.g_epis_hidric_pd
        THEN
            set_epis_hid_hist(i_epis_hidrics => i_epis_hidrics, i_flg_status => i_epis_hidrics_flg_stat);
        END IF;
        --
        g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH ID_EPIS_HIDRICS ' || i_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        l_rowids := table_varchar();
        ts_epis_hidrics.upd(id_epis_hidrics_in     => i_epis_hidrics,
                            id_hidrics_type_in     => i_hid_type,
                            id_professional_in     => i_prof.id,
                            id_hidrics_interval_in => i_hid_interv,
                            interval_minutes_in    => i_interval_minutes,
                            interval_minutes_nin   => FALSE,
                            flg_status_in          => i_epis_hidrics_flg_stat,
                            notes_nin              => FALSE,
                            notes_in               => i_notes,
                            id_prof_cancel_in      => NULL,
                            notes_cancel_in        => NULL,
                            id_prof_inter_in       => NULL,
                            notes_inter_in         => NULL,
                            dt_creation_tstz_in    => g_sysdate_tstz,
                            dt_initial_tstz_in     => l_dt_initial,
                            dt_end_tstz_nin        => FALSE,
                            dt_end_tstz_in         => l_dt_end,
                            dt_next_balance_in     => l_dt_next_balance,
                            dt_next_balance_nin    => FALSE,
                            dt_cancel_tstz_in      => NULL,
                            dt_inter_tstz_in       => NULL,
                            flg_restricted_in      => i_flg_restricted,
                            flg_restricted_nin     => FALSE,
                            max_intake_in          => i_max_intake,
                            max_intake_nin         => FALSE,
                            min_output_in          => i_min_output,
                            min_output_nin         => FALSE,
                            id_prof_last_change_in => i_prof.id,
                            dt_epis_hidrics_in     => g_sysdate_tstz,
                            flg_action_in          => pk_inp_hidrics_constant.g_flg_action_u,
                            rows_out               => l_rowids);
    
        --De or associate Integration of Therapeutic Attitudes (António Neto ALERT-164844)
        IF i_epis_hidrics_flg_stat = pk_inp_hidrics_constant.g_epis_hidric_r
        THEN
        
            IF i_hid_type IS NULL
            THEN
                g_error := 'OPEN C_EPIS_HID';
                OPEN c_epis_hid;
                FETCH c_epis_hid
                    INTO l_hid_type;
                CLOSE c_epis_hid;
            ELSE
                l_hid_type := i_hid_type;
            END IF;
        
            IF NOT create_assoc_icnp_interv(
                                            
                                            i_lang            => i_lang,
                                            i_prof            => i_prof,
                                            i_id_epis_hidrics => i_epis_hidrics,
                                            i_id_episode      => i_episode,
                                            i_id_hidrics_type => l_hid_type,
                                            o_error           => o_error)
            THEN
                RAISE l_icnp_interv;
            END IF;
        ELSIF i_epis_hidrics_flg_stat IN (pk_inp_hidrics_constant.g_epis_hidric_i,
                                          pk_inp_hidrics_constant.g_epis_hidric_c,
                                          pk_inp_hidrics_constant.g_epis_hidric_f,
                                          pk_inp_hidrics_constant.g_epis_hidric_o)
        THEN
        
            IF NOT cancel_assoc_icnp_interv(i_lang            => i_lang,
                                            i_prof            => i_prof,
                                            i_id_epis_hidrics => i_epis_hidrics,
                                            o_error           => o_error)
            THEN
                RAISE l_icnp_interv;
            END IF;
        
        END IF;
        --
        g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS ' || i_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
        --
        o_id_epis_hidrics := i_epis_hidrics;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'UPDATE_EPIS_HIDRICS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END update_epis_hidrics;

    /*******************************************************************************************************************************************
    * create_epis_hidrics             Internal function responsable for registering hidrics requests
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE that should be associated with current request
    * @param I_DT_INITIAL_STR         Begin date for this request
    * @param I_DT_END_STR             End date for this request
    * @param I_HID_INTERV             ID of interval between hidrics registries
    * @param I_NOTES                  Notes associated with current request
    * @param I_HID_TYPE               ID of current hidric type
    * @param I_UNIT_MEASURE           ID of unit measure associated 
    * @param I_FLG_TYPE               Type of action: N-New; U-Update
    * @param I_FLG_TASK_STATUS        Type of task: D-Draft; F-Final
    * @param O_ID_EPIS_HIDRICS        Cursor that returns created id_epis_hidrics
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_TYPE               {*} 'N' New {*} 'U' Update
    * @value I_FLG_TASK_STATUS        {*} 'D' Draft {*} 'F' Final
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Luï¿½Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/16
    *******************************************************************************************************************************************/
    FUNCTION create_epis_hidrics
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_episode         IN episode.id_episode%TYPE,
        i_dt_initial_str  IN VARCHAR2,
        i_dt_end_str      IN VARCHAR2,
        i_hid_interv      IN hidrics_interval.id_hidrics_interval%TYPE,
        i_notes           IN epis_hidrics.notes%TYPE,
        i_hid_type        IN hidrics_type.id_hidrics_type%TYPE,
        i_unit_measure    IN epis_hidrics_balance.id_unit_measure%TYPE,
        i_flg_type        IN VARCHAR2,
        i_flg_task_status IN epis_hidrics.flg_status%TYPE DEFAULT g_flg_task_status_f,
        o_id_epis_hidrics OUT epis_hidrics.id_epis_hidrics%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_next_ehb              epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_id_epis_hidric        epis_hidrics.id_epis_hidrics%TYPE;
        l_flg_ti_type           hidrics_type.flg_ti_type%TYPE;
        l_epis_hidrics_flg_stat epis_hidrics.flg_status%TYPE;
        l_flg_action            epis_hidrics.flg_action%TYPE;
        l_ht_acronym            hidrics_type.acronym%TYPE;
        --
        l_msg_text  sys_message.desc_message%TYPE;
        l_msg_title sys_message.desc_message%TYPE;
        --
        l_char          VARCHAR2(1 CHAR);
        l_char_det      VARCHAR2(1 CHAR);
        l_status_hidric BOOLEAN := FALSE;
        l_found         BOOLEAN;
        t_ti_log_ins_exception EXCEPTION;
        l_rowids table_varchar := table_varchar();
        --
        CURSOR c_episode IS
            SELECT 'X'
              FROM episode
             WHERE id_episode = i_episode
               AND flg_status <> g_epis_cancelled;
        --
        CURSOR c_epis_hidric IS
            SELECT eh.id_epis_hidrics
              FROM epis_hidrics eh
             WHERE eh.id_episode IN (SELECT epi.id_episode
                                       FROM episode epi
                                      WHERE epi.id_visit = (SELECT epi.id_visit
                                                              FROM episode epi
                                                             WHERE epi.id_episode = i_episode))
               AND eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e);
    
        CURSOR c_epis_hidric_det(l_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE) IS
            SELECT 'X'
              FROM epis_hidrics_det
             WHERE id_epis_hidrics = l_epis_hidrics;
    
        CURSOR c_epis_balance IS
            SELECT eb.id_epis_hidrics_balance
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics = l_id_epis_hidric;
        --
    
        l_icnp_interv EXCEPTION;
    BEGIN
        -- Verify if this is one ACTIVE episode
        g_error := 'OPEN C_EPISODE';
        OPEN c_episode;
        FETCH c_episode
            INTO l_char;
        l_found := c_episode%FOUND;
        CLOSE c_episode;
        --
        IF l_found
        THEN
            -- Verify if exists one Input and Outake requested or in process for this visit
            g_error := 'OPEN C_EPIS_HIDRIC';
            pk_alertlog.log_debug(g_error);
            OPEN c_epis_hidric;
            FETCH c_epis_hidric
                INTO l_id_epis_hidric;
            l_found := c_epis_hidric%FOUND;
            CLOSE c_epis_hidric;
        
            IF i_flg_task_status = pk_inp_hidrics_constant.g_epis_hidric_d
            THEN
                l_epis_hidrics_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_d;
                l_flg_action            := pk_inp_hidrics_constant.g_flg_action_d;
            ELSE
                l_epis_hidrics_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_r;
                l_flg_action            := pk_inp_hidrics_constant.g_flg_action_r;
            END IF;
        
            --
            IF NOT l_found
            THEN
                l_status_hidric := TRUE;
                --
                g_error := 'CALL INSERT_EPIS_HIDRICS';
                pk_alertlog.log_debug(g_error);
                IF NOT insert_epis_hidrics(i_lang                  => i_lang,
                                           i_prof                  => i_prof,
                                           i_episode               => i_episode,
                                           i_patient               => NULL,
                                           i_hidrics_type          => i_hid_type,
                                           i_interval_minutes      => NULL,
                                           i_dt_initial_str        => i_dt_initial_str,
                                           i_dt_end_str            => i_dt_end_str,
                                           i_dt_next_balance       => NULL,
                                           i_hid_interv            => i_hid_interv,
                                           i_notes                 => i_notes,
                                           i_epis_hidrics_flg_stat => l_epis_hidrics_flg_stat,
                                           i_flg_restricted        => NULL,
                                           i_max_intake            => NULL,
                                           i_min_output            => NULL,
                                           i_flg_action            => l_flg_action,
                                           o_id_epis_hidrics       => o_id_epis_hidrics,
                                           o_error                 => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
            ELSE
                IF i_flg_type <> g_create_hidrics_action_update
                THEN
                    -- Verify if this Input and Outake is one request or in process
                    OPEN c_epis_hidric_det(l_id_epis_hidric);
                    FETCH c_epis_hidric_det
                        INTO l_char_det;
                    l_found := c_epis_hidric_det%FOUND;
                    CLOSE c_epis_hidric_det;
                
                    -- Get FLAG associated with HIDRICS_TYPE information transfer between episodes
                    SELECT ht.flg_ti_type
                      INTO l_flg_ti_type
                      FROM epis_hidrics eh
                      JOIN hidrics_type ht
                        ON ht.id_hidrics_type = eh.id_hidrics_type
                     WHERE eh.id_epis_hidrics = l_id_epis_hidric;
                
                    --              
                    IF NOT l_found
                    THEN
                        g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        set_epis_hid_hist(i_epis_hidrics => l_id_epis_hidric);
                        --
                        g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS(1) = ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        l_rowids := table_varchar();
                        ts_epis_hidrics.upd(id_epis_hidrics_in     => l_id_epis_hidric,
                                            flg_status_in          => pk_inp_hidrics_constant.g_epis_hidric_c,
                                            id_prof_cancel_in      => i_prof.id,
                                            notes_cancel_in        => i_notes,
                                            dt_cancel_tstz_in      => g_sysdate_tstz,
                                            id_prof_last_change_in => i_prof.id,
                                            dt_epis_hidrics_in     => g_sysdate_tstz,
                                            flg_action_in          => pk_inp_hidrics_constant.g_flg_action_c,
                                            rows_out               => l_rowids);
                    
                        g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS(1) ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
                    
                        -- Writting into the status log
                        IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                                 i_prof       => i_prof,
                                                 i_id_episode => i_episode,
                                                 i_flg_status => pk_inp_hidrics_constant.g_epis_hidric_c,
                                                 i_id_record  => l_id_epis_hidric,
                                                 i_flg_type   => l_flg_ti_type,
                                                 o_error      => o_error))
                        THEN
                            RAISE t_ti_log_ins_exception;
                        END IF;
                        --
                        g_error := 'SEND TO HIST - HIDRICS_BALANCE i_where: id_epis_hidrics = ' || l_id_epis_hidric ||
                                   ' AND flg_status in (''' || pk_inp_hidrics_constant.g_epis_hidric_r || ''', ''' ||
                                   pk_inp_hidrics_constant.g_epis_hidric_e || ''')';
                        pk_alertlog.log_debug(g_error);
                        set_epis_hid_bal_hist(i_where => 'id_epis_hidrics = ' || l_id_epis_hidric ||
                                                         ' AND flg_status in (''' ||
                                                         pk_inp_hidrics_constant.g_epis_hidric_r || ''', ''' ||
                                                         pk_inp_hidrics_constant.g_epis_hidric_e || ''')');
                        --                    
                        g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD WITH EPIS_HIDRICS(2) = ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        l_rowids := table_varchar();
                        ts_epis_hidrics_balance.upd(flg_status_in            => pk_inp_hidrics_constant.g_epis_hidric_c,
                                                    dt_close_balance_tstz_in => g_sysdate_tstz,
                                                    id_prof_last_change_in   => i_prof.id,
                                                    dt_eh_balance_in         => g_sysdate_tstz,
                                                    where_in                 => 'id_epis_hidrics = ' || --
                                                                                l_id_epis_hidric || --
                                                                                ' AND flg_status IN (''' ||
                                                                                pk_inp_hidrics_constant.g_epis_hidric_r ||
                                                                                ''', ''' ||
                                                                                pk_inp_hidrics_constant.g_epis_hidric_e ||
                                                                                ''')',
                                                    rows_out                 => l_rowids);
                    
                        g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE(2) ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        t_data_gov_mnt.process_update(i_lang,
                                                      i_prof,
                                                      'EPIS_HIDRICS_BALANCE',
                                                      l_rowids,
                                                      o_error,
                                                      table_varchar('FLG_STATUS', 'DT_CLOSE_BALANCE_TSTZ'));
                    
                    ELSE
                        g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        set_epis_hid_hist(i_epis_hidrics => l_id_epis_hidric);
                        --
                        g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS(3) = ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        l_rowids := table_varchar();
                        ts_epis_hidrics.upd(id_epis_hidrics_in     => l_id_epis_hidric,
                                            flg_status_in          => pk_inp_hidrics_constant.g_epis_hidric_i,
                                            id_prof_inter_in       => i_prof.id,
                                            notes_inter_in         => i_notes,
                                            dt_inter_tstz_in       => g_sysdate_tstz,
                                            id_prof_last_change_in => i_prof.id,
                                            dt_epis_hidrics_in     => g_sysdate_tstz,
                                            flg_action_in          => pk_inp_hidrics_constant.g_flg_action_i,
                                            rows_out               => l_rowids);
                    
                        g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS(3) ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
                    
                        -- Writting into the status log
                        IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                                 i_prof       => i_prof,
                                                 i_id_episode => i_episode,
                                                 i_flg_status => pk_inp_hidrics_constant.g_epis_hidric_i,
                                                 i_id_record  => l_id_epis_hidric,
                                                 i_flg_type   => l_flg_ti_type,
                                                 o_error      => o_error))
                        THEN
                            RAISE t_ti_log_ins_exception;
                        END IF;
                        --
                        g_error := 'SEND TO HIST - HIDRICS_BALANCE i_where: id_epis_hidrics = ' || l_id_epis_hidric ||
                                   ' AND flg_status in (''' || pk_inp_hidrics_constant.g_epis_hidric_r || ''', ''' ||
                                   pk_inp_hidrics_constant.g_epis_hidric_e || ''')';
                        pk_alertlog.log_debug(g_error);
                        set_epis_hid_bal_hist(i_where => 'id_epis_hidrics = ' || l_id_epis_hidric ||
                                                         ' AND flg_status in (''' ||
                                                         pk_inp_hidrics_constant.g_epis_hidric_r || ''', ''' ||
                                                         pk_inp_hidrics_constant.g_epis_hidric_e || ''')');
                        --                    
                        g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD WITH EPIS_HIDRICS(4) = ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        l_rowids := table_varchar();
                        ts_epis_hidrics_balance.upd(flg_status_in            => pk_inp_hidrics_constant.g_epis_hidric_i,
                                                    dt_close_balance_tstz_in => g_sysdate_tstz,
                                                    id_prof_last_change_in   => i_prof.id,
                                                    dt_eh_balance_in         => g_sysdate_tstz,
                                                    where_in                 => 'id_epis_hidrics = ' || --
                                                                                l_id_epis_hidric || --
                                                                                ' AND flg_status IN (''' ||
                                                                                pk_inp_hidrics_constant.g_epis_hidric_r ||
                                                                                ''', ''' ||
                                                                                pk_inp_hidrics_constant.g_epis_hidric_e ||
                                                                                ''')',
                                                    rows_out                 => l_rowids);
                    
                        g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE(4) ' || l_id_epis_hidric;
                        pk_alertlog.log_debug(g_error);
                        t_data_gov_mnt.process_update(i_lang,
                                                      i_prof,
                                                      'EPIS_HIDRICS_BALANCE',
                                                      l_rowids,
                                                      o_error,
                                                      table_varchar('FLG_STATUS', 'DT_CLOSE_BALANCE_TSTZ'));
                    
                    END IF;
                    --
                    g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => 'CREATE_EPIS_HIDRICS');
                    FOR r_balance IN c_epis_balance
                    LOOP
                        IF NOT check_restriction_alerts(i_lang         => i_lang,
                                                        i_prof         => i_prof,
                                                        i_episode      => NULL,
                                                        i_epis_hidrics => l_id_epis_hidric,
                                                        i_epis_balance => r_balance.id_epis_hidrics_balance,
                                                        i_max_intake   => NULL,
                                                        i_min_output   => NULL,
                                                        i_hidrics_type => NULL,
                                                        i_flg_context  => pk_inp_hidrics_constant.g_context_end_balance,
                                                        i_dt_execution => NULL,
                                                        o_msg_title    => l_msg_title,
                                                        o_msg_text     => l_msg_text,
                                                        o_error        => o_error)
                        THEN
                            RAISE e_error;
                        END IF;
                    END LOOP;
                
                    --deassociate Integration of Therapeutic Attitudes (António Neto ALERT-164844)
                    IF NOT cancel_assoc_icnp_interv(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_id_epis_hidrics => l_id_epis_hidric,
                                                    o_error           => o_error)
                    THEN
                        RAISE l_icnp_interv;
                    END IF;
                
                    l_status_hidric := TRUE;
                    --
                    g_error := 'CALL INSERT_EPIS_HIDRICS';
                    pk_alertlog.log_debug(g_error);
                    IF NOT insert_epis_hidrics(i_lang                  => i_lang,
                                               i_prof                  => i_prof,
                                               i_episode               => i_episode,
                                               i_patient               => NULL,
                                               i_hidrics_type          => i_hid_type,
                                               i_interval_minutes      => NULL,
                                               i_dt_initial_str        => i_dt_initial_str,
                                               i_dt_end_str            => i_dt_end_str,
                                               i_dt_next_balance       => NULL,
                                               i_hid_interv            => i_hid_interv,
                                               i_notes                 => i_notes,
                                               i_epis_hidrics_flg_stat => l_epis_hidrics_flg_stat,
                                               i_flg_restricted        => NULL,
                                               i_max_intake            => NULL,
                                               i_min_output            => NULL,
                                               i_flg_action            => l_flg_action,
                                               o_id_epis_hidrics       => o_id_epis_hidrics,
                                               o_error                 => o_error)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                END IF;
            END IF;
            --
            g_error    := 'GET SEQ_EPIS_HIDRICS_BALANCE.NEXTVAL(2)';
            l_next_ehb := ts_epis_hidrics_balance.next_key;
        
            --
            IF l_status_hidric = TRUE
            THEN
                g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.INS WITH ID_EPIS_HIDRICS_BALANCE(2) ' || l_next_ehb;
                pk_alertlog.log_debug(g_error);
                l_rowids := table_varchar();
                ts_epis_hidrics_balance.ins(id_epis_hidrics_balance_in => l_next_ehb,
                                            id_epis_hidrics_in         => nvl(o_id_epis_hidrics, l_id_epis_hidric),
                                            id_prof_close_in           => NULL,
                                            flg_status_in              => pk_inp_hidrics_constant.g_epis_hidric_r,
                                            total_admin_in             => NULL,
                                            total_elim_in              => NULL,
                                            id_unit_measure_in         => i_unit_measure,
                                            dt_close_balance_tstz_in   => NULL,
                                            dt_open_tstz_in            => pk_date_utils.get_string_tstz(i_lang,
                                                                                                        i_prof,
                                                                                                        i_dt_initial_str,
                                                                                                        NULL),
                                            dt_register_tstz_in        => g_sysdate_tstz,
                                            id_prof_last_change_in     => i_prof.id,
                                            dt_eh_balance_in           => g_sysdate_tstz,
                                            rows_out                   => l_rowids);
            
                g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE(1) ' || l_next_ehb;
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
            
            ELSE
                g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.INS WITH ID_EPIS_HIDRICS_BALANCE(2) ' || l_next_ehb;
                pk_alertlog.log_debug(g_error);
                l_rowids := table_varchar();
                ts_epis_hidrics_balance.ins(id_epis_hidrics_balance_in => l_next_ehb,
                                            id_epis_hidrics_in         => nvl(o_id_epis_hidrics, l_id_epis_hidric),
                                            id_prof_close_in           => NULL,
                                            flg_status_in              => pk_inp_hidrics_constant.g_epis_hidric_r,
                                            total_admin_in             => NULL,
                                            total_elim_in              => NULL,
                                            id_unit_measure_in         => i_unit_measure,
                                            dt_close_balance_tstz_in   => NULL,
                                            dt_open_tstz_in            => pk_date_utils.get_string_tstz(i_lang,
                                                                                                        i_prof,
                                                                                                        i_dt_initial_str,
                                                                                                        NULL),
                                            dt_register_tstz_in        => g_sysdate_tstz,
                                            id_prof_last_change_in     => i_prof.id,
                                            dt_eh_balance_in           => g_sysdate_tstz,
                                            rows_out                   => l_rowids);
            
                g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE(2) ' || l_next_ehb;
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
            
            END IF;
        
            -- Get FLAG associated with HIDRICS_TYPE information transfer between episodes
            SELECT ht.flg_ti_type, ht.acronym
              INTO l_flg_ti_type, l_ht_acronym
              FROM hidrics_type ht
             WHERE ht.id_hidrics_type = i_hid_type;
        
            -- Writting into the status log
            IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                     i_prof       => i_prof,
                                     i_id_episode => i_episode,
                                     i_flg_status => pk_inp_hidrics_constant.g_epis_hidric_r,
                                     i_id_record  => nvl(o_id_epis_hidrics, l_id_epis_hidric),
                                     i_flg_type   => l_flg_ti_type,
                                     o_error      => o_error))
            THEN
                RAISE t_ti_log_ins_exception;
            END IF;
        END IF;
    
        g_error := 'CALL TO PK_CPOE.SYNC_TASK';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                 i_prof                 => i_prof,
                                 i_episode              => i_episode,
                                 i_task_type            => CASE l_ht_acronym
                                                               WHEN pk_inp_hidrics_constant.g_hid_type_h THEN
                                                                pk_alert_constant.g_task_type_hidric_in_out
                                                               WHEN pk_inp_hidrics_constant.g_hid_type_d THEN
                                                                pk_alert_constant.g_task_type_hidric_out
                                                               WHEN pk_inp_hidrics_constant.g_hid_type_r THEN
                                                                pk_alert_constant.g_task_type_hidric_drain
                                                               WHEN pk_inp_hidrics_constant.g_hid_type_i THEN
                                                                pk_alert_constant.g_task_type_hidric_in
                                                               WHEN pk_inp_hidrics_constant.g_hid_type_o THEN
                                                                pk_alert_constant.g_task_type_hidric_out_group
                                                               WHEN pk_inp_hidrics_constant.g_hid_type_all THEN
                                                                pk_alert_constant.g_task_type_hidric_out_all
                                                               WHEN pk_inp_hidrics_constant.g_hid_type_g THEN
                                                                pk_alert_constant.g_task_type_hidric_irrigations
                                                               ELSE
                                                                NULL
                                                           END,
                                 i_task_request         => nvl(o_id_epis_hidrics, l_id_epis_hidric),
                                 i_task_start_timestamp => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_timestamp => i_dt_initial_str,
                                                                                         i_timezone  => NULL),
                                 o_error                => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN t_ti_log_ins_exception THEN
            DECLARE
                l_error_in      t_error_in := t_error_in();
                l_error_message sys_message.desc_message%TYPE := pk_message.get_message(i_lang, 'COMMON_M001');
            BEGIN
                l_error_in.set_all(i_lang,
                                   'ERR_WRITTING_LOG',
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   'CREATE_EPIS_HIDRICS');
                l_error_in.set_action(l_error_message, 'S');
                g_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_EPIS_HIDRICS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END create_epis_hidrics;

    /*******************************************************************************************************************************************
    * INACT_PREV_HIDRIC               Cancel or interrupt previouse registry
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE that should be associated with current request
    * @param I_EPIS_HIDRICS           epis_hidrics identifier
    * @param I_NOTES                  Notes associated with current request
    * @param i_hid_type               Hidrics type
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_TYPE               {*} 'N' New {*} 'U' Update
    * @value I_FLG_TASK_STATUS        {*} 'D' Draft {*} 'F' Final
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Luï¿½Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/16
    *
    * @author                         Alexandre Santos
    * @version                        2.6.0.3
    * @since                          2010/07/02
    *******************************************************************************************************************************************/
    FUNCTION inact_prev_hidric
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_id_epis_hidric IN epis_hidrics.id_epis_hidrics%TYPE,
        i_notes          IN epis_hidrics.notes%TYPE,
        i_hid_type       IN hidrics_type.id_hidrics_type%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_flg_ti_type    hidrics_type.flg_ti_type%TYPE;
        l_id_epis_hidric epis_hidrics.id_epis_hidrics%TYPE;
        --
        l_msg_text  sys_message.desc_message%TYPE;
        l_msg_title sys_message.desc_message%TYPE;
        --
        l_char_det VARCHAR2(1 CHAR);
        l_found    BOOLEAN;
        t_ti_log_ins_exception EXCEPTION;
        l_rowids table_varchar := table_varchar();
        --
    
        l_icnp_interv EXCEPTION;
    
        CURSOR c_epis_hidric_det(l_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE) IS
            SELECT 'X'
              FROM epis_hidrics_det
             WHERE id_epis_hidrics = l_epis_hidrics;
        --
        CURSOR c_epis_hidric IS
            SELECT eh.id_epis_hidrics
              FROM epis_hidrics eh
              JOIN hidrics_type ht
                ON ht.id_hidrics_type = eh.id_hidrics_type
             WHERE eh.id_episode IN (SELECT epi.id_episode
                                       FROM episode epi
                                      WHERE epi.id_visit = (SELECT epi.id_visit
                                                              FROM episode epi
                                                             WHERE epi.id_episode = i_episode))
               AND eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e)
               AND (i_id_epis_hidric IS NULL OR eh.id_epis_hidrics != i_id_epis_hidric)
               AND instr(decode(ht.acronym,
                                'I', --Current epis_hidrics is a intake
                                'ADRG', --Then the new one can be a 'A' - All output, 'D' - Output or 'R' - Drainage records
                                'A', --If it's a all output
                                 'IGH', --Then it can be a 'I' - Intake
                                 'D', --If it's a output
                                'IRGH', --Then it can be 'I' - Intake or a 'R' - Drainage records
                                'R', --If it's a drainage records
                                 'IDGH', --Then it can be 'I' - Intake or a 'D' - Output
                                 'H', --Otherwise is a balance and can't exist other intakes
                                'ADRG'),
                         (SELECT ht2.acronym
                            FROM hidrics_type ht2
                           WHERE ht2.id_hidrics_type = i_hid_type)) = 0;
    
        CURSOR c_epis_balance IS
            SELECT eb.id_epis_hidrics_balance
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics = l_id_epis_hidric;
    
    BEGIN
        -- Verify if exists one Input and Outake requested or in process for this visit
        g_error := 'Loop through C_EPIS_HIDRIC';
        pk_alertlog.log_debug(g_error);
        OPEN c_epis_hidric;
        <<epis_hidrcis_loop>>
        LOOP
            FETCH c_epis_hidric
                INTO l_id_epis_hidric;
            EXIT WHEN c_epis_hidric%NOTFOUND;
        
            -- Verify if this Input and Outake is one request or in process
            OPEN c_epis_hidric_det(l_id_epis_hidric);
            FETCH c_epis_hidric_det
                INTO l_char_det;
            l_found := c_epis_hidric_det%FOUND;
            CLOSE c_epis_hidric_det;
        
            -- Get FLAG associated with HIDRICS_TYPE information transfer between episodes
            BEGIN
                SELECT ht.flg_ti_type
                  INTO l_flg_ti_type
                  FROM epis_hidrics eh
                  JOIN hidrics_type ht
                    ON ht.id_hidrics_type = eh.id_hidrics_type
                 WHERE eh.id_epis_hidrics = l_id_epis_hidric;
            EXCEPTION
                WHEN no_data_found THEN
                    -- It will be returned because there are no hidrics to cancel or inactivate
                    RETURN TRUE;
            END;
        
            --              
            IF NOT l_found
            THEN
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_hist(i_epis_hidrics => l_id_epis_hidric);
                --
                g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS(1) = ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                l_rowids := table_varchar();
                ts_epis_hidrics.upd(id_epis_hidrics_in     => l_id_epis_hidric,
                                    flg_status_in          => pk_inp_hidrics_constant.g_epis_hidric_c,
                                    id_prof_cancel_in      => i_prof.id,
                                    notes_cancel_in        => i_notes,
                                    dt_cancel_tstz_in      => g_sysdate_tstz,
                                    id_prof_last_change_in => i_prof.id,
                                    dt_epis_hidrics_in     => g_sysdate_tstz,
                                    flg_action_in          => pk_inp_hidrics_constant.g_flg_action_c,
                                    rows_out               => l_rowids);
            
                g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS(1) ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
            
                -- Writting into the status log
                IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                         i_prof       => i_prof,
                                         i_id_episode => i_episode,
                                         i_flg_status => pk_inp_hidrics_constant.g_epis_hidric_c,
                                         i_id_record  => l_id_epis_hidric,
                                         i_flg_type   => l_flg_ti_type,
                                         o_error      => o_error))
                THEN
                    RAISE t_ti_log_ins_exception;
                END IF;
                --
                g_error := 'SEND TO HIST - HIDRICS_BALANCE i_where: id_epis_hidrics = ' || l_id_epis_hidric ||
                           ' AND flg_status in (''' || pk_inp_hidrics_constant.g_epis_hidric_r || ''', ''' ||
                           pk_inp_hidrics_constant.g_epis_hidric_e || ''')';
                pk_alertlog.log_debug(g_error);
                set_epis_hid_bal_hist(i_where => 'id_epis_hidrics = ' || l_id_epis_hidric || ' AND flg_status in (''' ||
                                                 pk_inp_hidrics_constant.g_epis_hidric_r || ''', ''' ||
                                                 pk_inp_hidrics_constant.g_epis_hidric_e || ''')');
                --                    
                g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD WITH EPIS_HIDRICS(2) = ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                l_rowids := table_varchar();
                ts_epis_hidrics_balance.upd(flg_status_in            => pk_inp_hidrics_constant.g_epis_hidric_c,
                                            dt_close_balance_tstz_in => g_sysdate_tstz,
                                            id_prof_last_change_in   => i_prof.id,
                                            dt_eh_balance_in         => g_sysdate_tstz,
                                            where_in                 => 'id_epis_hidrics = ' || --
                                                                        l_id_epis_hidric || --
                                                                        ' AND flg_status IN (''' ||
                                                                        pk_inp_hidrics_constant.g_epis_hidric_r ||
                                                                        ''', ''' ||
                                                                        pk_inp_hidrics_constant.g_epis_hidric_e || ''')',
                                            rows_out                 => l_rowids);
            
                g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE(2) ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_update(i_lang,
                                              i_prof,
                                              'EPIS_HIDRICS_BALANCE',
                                              l_rowids,
                                              o_error,
                                              table_varchar('FLG_STATUS', 'DT_CLOSE_BALANCE_TSTZ'));
            
            ELSE
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_hist(i_epis_hidrics => l_id_epis_hidric);
                --
                g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS(3) = ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                l_rowids := table_varchar();
                ts_epis_hidrics.upd(id_epis_hidrics_in     => l_id_epis_hidric,
                                    flg_status_in          => pk_inp_hidrics_constant.g_epis_hidric_i,
                                    id_prof_inter_in       => i_prof.id,
                                    notes_inter_in         => i_notes,
                                    dt_inter_tstz_in       => g_sysdate_tstz,
                                    id_prof_last_change_in => i_prof.id,
                                    dt_epis_hidrics_in     => g_sysdate_tstz,
                                    flg_action_in          => pk_inp_hidrics_constant.g_flg_action_i,
                                    rows_out               => l_rowids);
            
                g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS(3) ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
            
                -- Writting into the status log
                IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                         i_prof       => i_prof,
                                         i_id_episode => i_episode,
                                         i_flg_status => pk_inp_hidrics_constant.g_epis_hidric_i,
                                         i_id_record  => l_id_epis_hidric,
                                         i_flg_type   => l_flg_ti_type,
                                         o_error      => o_error))
                THEN
                    RAISE t_ti_log_ins_exception;
                END IF;
                --
                g_error := 'SEND TO HIST - HIDRICS_BALANCE i_where: id_epis_hidrics = ' || l_id_epis_hidric ||
                           ' AND flg_status in (''' || pk_inp_hidrics_constant.g_epis_hidric_r || ''', ''' ||
                           pk_inp_hidrics_constant.g_epis_hidric_e || ''')';
                pk_alertlog.log_debug(g_error);
                set_epis_hid_bal_hist(i_where => 'id_epis_hidrics = ' || l_id_epis_hidric || ' AND flg_status in (''' ||
                                                 pk_inp_hidrics_constant.g_epis_hidric_r || ''', ''' ||
                                                 pk_inp_hidrics_constant.g_epis_hidric_e || ''')');
                --                    
                g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD WITH EPIS_HIDRICS(4) = ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                l_rowids := table_varchar();
                ts_epis_hidrics_balance.upd(flg_status_in            => pk_inp_hidrics_constant.g_epis_hidric_i,
                                            dt_close_balance_tstz_in => g_sysdate_tstz,
                                            id_prof_last_change_in   => i_prof.id,
                                            dt_eh_balance_in         => g_sysdate_tstz,
                                            where_in                 => 'id_epis_hidrics = ' || --
                                                                        l_id_epis_hidric || --
                                                                        ' AND flg_status IN (''' ||
                                                                        pk_inp_hidrics_constant.g_epis_hidric_r ||
                                                                        ''', ''' ||
                                                                        pk_inp_hidrics_constant.g_epis_hidric_e || ''')',
                                            rows_out                 => l_rowids);
            
                g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE(4) ' || l_id_epis_hidric;
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_update(i_lang,
                                              i_prof,
                                              'EPIS_HIDRICS_BALANCE',
                                              l_rowids,
                                              o_error,
                                              table_varchar('FLG_STATUS', 'DT_CLOSE_BALANCE_TSTZ'));
            END IF;
        
            g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => 'INACT_PREV_HIDRIC');
            FOR r_balance IN c_epis_balance
            LOOP
                IF NOT check_restriction_alerts(i_lang         => i_lang,
                                                i_prof         => i_prof,
                                                i_episode      => NULL,
                                                i_epis_hidrics => l_id_epis_hidric,
                                                i_epis_balance => r_balance.id_epis_hidrics_balance,
                                                i_max_intake   => NULL,
                                                i_min_output   => NULL,
                                                i_hidrics_type => NULL,
                                                i_flg_context  => pk_inp_hidrics_constant.g_context_end_balance,
                                                i_dt_execution => NULL,
                                                o_msg_title    => l_msg_title,
                                                o_msg_text     => l_msg_text,
                                                o_error        => o_error)
                THEN
                    RAISE e_error;
                END IF;
            END LOOP;
        
            --deassociate Integration of Therapeutic Attitudes (António Neto ALERT-164844)
            IF NOT cancel_assoc_icnp_interv(i_lang            => i_lang,
                                            i_prof            => i_prof,
                                            i_id_epis_hidrics => l_id_epis_hidric,
                                            o_error           => o_error)
            THEN
                RAISE l_icnp_interv;
            END IF;
        END LOOP epis_hidrcis_loop;
        CLOSE c_epis_hidric;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN t_ti_log_ins_exception THEN
            DECLARE
                l_error_in      t_error_in := t_error_in();
                l_error_message sys_message.desc_message%TYPE := pk_message.get_message(i_lang, 'COMMON_M001');
            BEGIN
                l_error_in.set_all(i_lang,
                                   'ERR_WRITTING_LOG',
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   'INACT_PREV_HIDRIC');
                l_error_in.set_action(l_error_message, 'S');
                g_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'INACT_PREV_HIDRIC',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END inact_prev_hidric;

    /*******************************************************************************************************************************************
    * CREATE_HIDRIC                   Internal function responsable for registering hidrics requests
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE that should be associated with current request
    * @param I_DT_INITIAL_STR         Begin date for this request
    * @param I_DT_END_STR             End date for this request
    * @param I_HID_INTERV             ID of interval between hidrics registries
    * @param I_NOTES                  Notes associated with current request
    * @param I_HID_TYPE               ID of current hidric type
    * @param I_UNIT_MEASURE           ID of unit measure associated 
    * @param I_FLG_TYPE               Type of action: N-New; U-Update
    * @param I_FLG_TASK_STATUS        Type of task: D-Draft; F-Final
    * @param O_ID_EPIS_HIDRICS        Cursor that returns created id_epis_hidrics
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_TYPE               {*} 'N' New {*} 'U' Update
    * @value I_FLG_TASK_STATUS        {*} 'D' Draft {*} 'F' Final
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Luï¿½Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/16
    *******************************************************************************************************************************************/
    FUNCTION create_hidric
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_patient          IN patient.id_patient%TYPE,
        i_dt_initial_str   IN VARCHAR2,
        i_dt_end_str       IN VARCHAR2,
        i_dt_next_balance  IN VARCHAR2,
        i_hid_interv       IN hidrics_interval.id_hidrics_interval%TYPE,
        i_interval_minutes IN epis_hidrics.interval_minutes%TYPE,
        i_notes            IN epis_hidrics.notes%TYPE,
        i_hid_type         IN hidrics_type.id_hidrics_type%TYPE,
        i_unit_measure     IN epis_hidrics_balance.id_unit_measure%TYPE,
        i_flg_task_status  IN epis_hidrics.flg_status%TYPE DEFAULT g_flg_task_status_f,
        i_flg_restricted   IN epis_hidrics.flg_restricted%TYPE,
        i_max_intake       IN epis_hidrics.max_intake%TYPE,
        i_min_output       IN epis_hidrics.min_output%TYPE,
        o_id_epis_hidrics  OUT epis_hidrics.id_epis_hidrics%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_next_ehb              epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_id_epis_hidric        epis_hidrics.id_epis_hidrics%TYPE;
        l_flg_ti_type           hidrics_type.flg_ti_type%TYPE;
        l_ht_acronym            hidrics_type.acronym%TYPE;
        l_epis_hid_bal_flg_stat epis_hidrics_balance.flg_status%TYPE;
        --
        l_status_hidric BOOLEAN := FALSE;
        l_found         BOOLEAN;
        t_ti_log_ins_exception EXCEPTION;
        l_rowids table_varchar := table_varchar();
        --
        CURSOR c_epis_hidric IS
            SELECT eh.id_epis_hidrics
              FROM epis_hidrics eh
             WHERE eh.id_episode IN (SELECT epi.id_episode
                                       FROM episode epi
                                      WHERE epi.id_visit = (SELECT epi.id_visit
                                                              FROM episode epi
                                                             WHERE epi.id_episode = i_episode))
               AND eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e);
    
    BEGIN
        -- Verify if exists one Input and Outake requested or in process for this visit
        g_error := 'OPEN C_EPIS_HIDRIC';
        pk_alertlog.log_debug(g_error);
        OPEN c_epis_hidric;
        FETCH c_epis_hidric
            INTO l_id_epis_hidric;
        l_found := c_epis_hidric%FOUND;
        CLOSE c_epis_hidric;
    
        --
        IF i_flg_task_status = pk_inp_hidrics_constant.g_epis_hidric_d
        THEN
            l_epis_hid_bal_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_d;
        ELSE
            l_epis_hid_bal_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_r;
        END IF;
    
        --
        IF NOT l_found
           OR i_flg_task_status = g_flg_task_status_d
        THEN
            l_status_hidric := TRUE;
            --
            g_error := 'CALL INSERT_EPIS_HIDRICS';
            pk_alertlog.log_debug(g_error);
            IF NOT insert_epis_hidrics(i_lang                  => i_lang,
                                       i_prof                  => i_prof,
                                       i_episode               => i_episode,
                                       i_patient               => i_patient,
                                       i_hidrics_type          => i_hid_type,
                                       i_dt_initial_str        => i_dt_initial_str,
                                       i_dt_end_str            => i_dt_end_str,
                                       i_dt_next_balance       => i_dt_next_balance,
                                       i_hid_interv            => i_hid_interv,
                                       i_interval_minutes      => i_interval_minutes,
                                       i_notes                 => i_notes,
                                       i_epis_hidrics_flg_stat => i_flg_task_status,
                                       i_flg_restricted        => i_flg_restricted,
                                       i_max_intake            => i_max_intake,
                                       i_min_output            => i_min_output,
                                       i_flg_action            => i_flg_task_status,
                                       o_id_epis_hidrics       => o_id_epis_hidrics,
                                       o_error                 => o_error)
            THEN
                RETURN FALSE;
            END IF;
        
        ELSE
            -- IF there is an previouse hidric registry active, it should be cancelled/inactivated
            IF NOT inact_prev_hidric(i_lang           => i_lang,
                                     i_prof           => i_prof,
                                     i_episode        => i_episode,
                                     i_id_epis_hidric => NULL,
                                     i_notes          => i_notes,
                                     i_hid_type       => i_hid_type,
                                     o_error          => o_error)
            THEN
                RETURN FALSE;
            END IF;
            --
            l_status_hidric := TRUE;
            --
            g_error := 'CALL INSERT_EPIS_HIDRICS';
            pk_alertlog.log_debug(g_error);
            IF NOT insert_epis_hidrics(i_lang                  => i_lang,
                                       i_prof                  => i_prof,
                                       i_episode               => i_episode,
                                       i_patient               => i_patient,
                                       i_hidrics_type          => i_hid_type,
                                       i_dt_initial_str        => i_dt_initial_str,
                                       i_dt_end_str            => i_dt_end_str,
                                       i_dt_next_balance       => i_dt_next_balance,
                                       i_hid_interv            => i_hid_interv,
                                       i_interval_minutes      => i_interval_minutes,
                                       i_notes                 => i_notes,
                                       i_epis_hidrics_flg_stat => i_flg_task_status,
                                       i_flg_restricted        => i_flg_restricted,
                                       i_max_intake            => i_max_intake,
                                       i_min_output            => i_min_output,
                                       i_flg_action            => pk_inp_hidrics_constant.g_flg_action_r,
                                       o_id_epis_hidrics       => o_id_epis_hidrics,
                                       o_error                 => o_error)
            THEN
                RETURN FALSE;
            END IF;
        END IF;
        --
        g_error    := 'GET SEQ_EPIS_HIDRICS_BALANCE.NEXTVAL(2)';
        l_next_ehb := ts_epis_hidrics_balance.next_key;
    
        --
        IF l_status_hidric = TRUE
        THEN
            g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.INS WITH ID_EPIS_HIDRICS_BALANCE(1) ' || l_next_ehb;
            pk_alertlog.log_debug(g_error);
            l_rowids := table_varchar();
            ts_epis_hidrics_balance.ins(id_epis_hidrics_balance_in => l_next_ehb,
                                        id_epis_hidrics_in         => nvl(o_id_epis_hidrics, l_id_epis_hidric),
                                        id_prof_close_in           => NULL,
                                        flg_status_in              => l_epis_hid_bal_flg_stat,
                                        total_admin_in             => NULL,
                                        total_elim_in              => NULL,
                                        id_unit_measure_in         => i_unit_measure,
                                        dt_close_balance_tstz_in   => NULL,
                                        dt_open_tstz_in            => pk_date_utils.get_string_tstz(i_lang,
                                                                                                    i_prof,
                                                                                                    i_dt_initial_str,
                                                                                                    NULL),
                                        dt_register_tstz_in        => g_sysdate_tstz,
                                        id_prof_last_change_in     => i_prof.id,
                                        dt_eh_balance_in           => g_sysdate_tstz,
                                        rows_out                   => l_rowids);
        
            g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE(1) ' || l_next_ehb;
            pk_alertlog.log_debug(g_error);
            t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
        
        ELSE
            g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.INS WITH ID_EPIS_HIDRICS_BALANCE(2) ' || l_next_ehb;
            pk_alertlog.log_debug(g_error);
            l_rowids := table_varchar();
            ts_epis_hidrics_balance.ins(id_epis_hidrics_balance_in => l_next_ehb,
                                        id_epis_hidrics_in         => nvl(o_id_epis_hidrics, l_id_epis_hidric),
                                        id_prof_close_in           => NULL,
                                        flg_status_in              => l_epis_hid_bal_flg_stat,
                                        total_admin_in             => NULL,
                                        total_elim_in              => NULL,
                                        id_unit_measure_in         => i_unit_measure,
                                        dt_close_balance_tstz_in   => NULL,
                                        dt_open_tstz_in            => pk_date_utils.get_string_tstz(i_lang,
                                                                                                    i_prof,
                                                                                                    i_dt_initial_str,
                                                                                                    NULL),
                                        dt_register_tstz_in        => g_sysdate_tstz,
                                        id_prof_last_change_in     => i_prof.id,
                                        dt_eh_balance_in           => g_sysdate_tstz,
                                        rows_out                   => l_rowids);
        
            g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE(2) ' || l_next_ehb;
            pk_alertlog.log_debug(g_error);
            t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
        
        END IF;
    
        -- Get FLAG associated with HIDRICS_TYPE information transfer between episodes
        SELECT ht.flg_ti_type, ht.acronym
          INTO l_flg_ti_type, l_ht_acronym
          FROM hidrics_type ht
         WHERE ht.id_hidrics_type = i_hid_type;
    
        IF l_id_epis_hidric IS NOT NULL
        THEN
            -- Writting into the status log
            IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                     i_prof       => i_prof,
                                     i_id_episode => i_episode,
                                     i_flg_status => pk_inp_hidrics_constant.g_epis_hidric_r,
                                     i_id_record  => nvl(o_id_epis_hidrics, l_id_epis_hidric),
                                     i_flg_type   => l_flg_ti_type,
                                     o_error      => o_error))
            THEN
                RAISE t_ti_log_ins_exception;
            END IF;
        END IF;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN t_ti_log_ins_exception THEN
            DECLARE
                l_error_in      t_error_in := t_error_in();
                l_error_message sys_message.desc_message%TYPE := pk_message.get_message(i_lang, 'COMMON_M001');
            BEGIN
                l_error_in.set_all(i_lang,
                                   'ERR_WRITTING_LOG',
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   'CREATE_HIDRIC');
                l_error_in.set_action(l_error_message, 'S');
                g_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_HIDRIC',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END create_hidric;

    /*******************************************************************************************************************************************
    * SET_HIDRICS                     Internal function responsable for registering hidrics requests
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE that should be associated with current request
    * @param I_PATIENT                ID_PATIENT that should be associated with current request
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_DT_INITIAL_STR         Begin date for this request
    * @param I_DT_END_STR             End date for this request
    * @param I_DT_NEXT_BALANCE        Date of next balance
    * @param I_HID_INTERV             ID of interval between hidrics registries
    * @param i_interval_minutes       Interval that was selected when ID_HIDCRICS_INTERVAL = 'Other'
    * @param I_NOTES                  Notes associated with current request
    * @param I_HID_TYPE               ID of current hidric type
    * @param I_UNIT_MEASURE           ID of unit measure associated 
    * @param I_FLG_TYPE               Type of action: N-New; U-Update
    * @param I_FLG_TASK_STATUS        Type of task: D-Draft; F-Final
    * @param I_FLG_RESTRICTED         Fluid restriction: Y - yes, N - No
    * @param I_MAX_INTAKE             Maximum intake
    * @param I_MIN_OUTPUT             Minimum output
    * @param O_ID_EPIS_HIDRICS        Cursor that returns created id_epis_hidrics
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_TYPE               {*} 'N' New {*} 'U' Update
    * @value I_FLG_TASK_STATUS        {*} 'D' Draft {*} 'F' Final
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Luï¿½Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/20
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/05/21
    *******************************************************************************************************************************************/
    FUNCTION set_hidrics
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_patient          IN patient.id_patient%TYPE,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_dt_initial_str   IN VARCHAR2,
        i_dt_end_str       IN VARCHAR2,
        i_dt_next_balance  IN VARCHAR2,
        i_hid_interv       IN hidrics_interval.id_hidrics_interval%TYPE,
        i_interval_minutes IN epis_hidrics.interval_minutes%TYPE,
        i_notes            IN epis_hidrics.notes%TYPE,
        i_hid_type         IN hidrics_type.id_hidrics_type%TYPE,
        i_unit_measure     IN epis_hidrics_balance.id_unit_measure%TYPE,
        i_flg_type         IN VARCHAR2,
        i_flg_task_status  IN epis_hidrics.flg_status%TYPE DEFAULT g_flg_task_status_f,
        i_flg_restricted   IN epis_hidrics.flg_restricted%TYPE,
        i_max_intake       IN epis_hidrics.max_intake%TYPE,
        i_min_output       IN epis_hidrics.min_output%TYPE,
        o_id_epis_hidrics  OUT epis_hidrics.id_epis_hidrics%TYPE,
        o_flg_show         OUT VARCHAR2,
        o_msg_title        OUT VARCHAR2,
        o_msg              OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name             VARCHAR2(30 CHAR) := 'SET_HIDRICS';
        l_epis_hidrics_flg_stat epis_hidrics.flg_status%TYPE;
        l_ht_acronym            hidrics_type.acronym%TYPE;
        --
        l_char   VARCHAR2(1 CHAR);
        l_found  BOOLEAN;
        l_rowids table_varchar := table_varchar();
        t_ti_log_ins_exception EXCEPTION;
        l_edition VARCHAR2(1 CHAR);
        --
        CURSOR c_episode IS
            SELECT 'X'
              FROM episode
             WHERE id_episode = i_episode
               AND flg_status <> g_epis_cancelled;
        --
        l_epis_hid_balance epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_dt_execution     epis_hidrics_det.dt_execution_tstz%TYPE;
        l_dt_open          epis_hidrics_balance.dt_open_tstz%TYPE;
    
        l_flg_profile     profile_template.flg_profile%TYPE;
        l_sys_alert_event sys_alert_event%ROWTYPE;
    
        e_date_compare EXCEPTION;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        l_flg_profile := nvl(pk_hand_off_core.get_flg_profile(i_lang, i_prof, NULL), '#');
    
        g_error := 'get_epis_hidrics_status for id_epis_hidrics: ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_epis_hidrics_flg_stat := get_epis_hidrics_status(i_epis_hidrics);
    
        g_error := 'check_show_conflict_pop for id_epis_hidrics: ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_show_conflict_pop(i_lang                => i_lang,
                                       i_prof                => i_prof,
                                       i_epis_hidrics        => i_epis_hidrics,
                                       i_epis_hidrics_status => l_epis_hidrics_flg_stat,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg                 => o_msg,
                                       o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF (o_flg_show = pk_alert_constant.get_yes)
        THEN
            RETURN TRUE;
        END IF;
    
        -- Verify if this is one ACTIVE episode
        g_error := 'OPEN C_EPISODE';
        OPEN c_episode;
        FETCH c_episode
            INTO l_char;
        l_found := c_episode%FOUND;
        CLOSE c_episode;
    
        -- Control edition
        IF i_epis_hidrics IS NOT NULL
        THEN
            l_edition := pk_alert_constant.g_yes;
        ELSE
            l_edition := pk_alert_constant.g_no;
        END IF;
    
        --        
        IF i_flg_task_status = pk_inp_hidrics_constant.g_epis_hidric_d
           AND l_edition = pk_alert_constant.g_no
        THEN
            l_epis_hidrics_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_d;
        ELSIF l_edition = pk_alert_constant.g_yes
              AND i_flg_task_status = pk_inp_hidrics_constant.g_flg_task_status_f
        THEN
        
            --to the activate draft
            IF (l_epis_hidrics_flg_stat = pk_inp_hidrics_constant.g_epis_hidric_d)
            THEN
                l_epis_hidrics_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_r;
            END IF;
        
        ELSIF i_flg_task_status = pk_inp_hidrics_constant.g_flg_task_status_o
        
        THEN
            l_epis_hidrics_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_o;
        
        ELSIF l_edition = pk_alert_constant.g_yes
              AND i_flg_task_status = pk_inp_hidrics_constant.g_flg_task_status_d
        THEN
            l_epis_hidrics_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_d;
        ELSE
            l_epis_hidrics_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_r;
        END IF;
    
        IF i_episode IS NULL
           AND i_patient IS NULL
        THEN
            l_epis_hidrics_flg_stat := pk_inp_hidrics_constant.g_epis_hidric_pd;
        END IF;
    
        --
        IF l_found
           OR (i_episode IS NULL AND i_patient IS NULL)
        THEN
            IF i_flg_type <> g_create_hidrics_action_update
            -- INSERTING HIDRICS
            THEN
                --
                g_error := 'CALL CREATE_HIDRIC';
                pk_alertlog.log_debug(g_error);
                IF NOT create_hidric(i_lang             => i_lang,
                                     i_prof             => i_prof,
                                     i_episode          => i_episode,
                                     i_patient          => i_patient,
                                     i_dt_initial_str   => i_dt_initial_str,
                                     i_dt_end_str       => i_dt_end_str,
                                     i_dt_next_balance  => i_dt_next_balance,
                                     i_hid_interv       => i_hid_interv,
                                     i_interval_minutes => i_interval_minutes,
                                     i_notes            => i_notes,
                                     i_hid_type         => i_hid_type,
                                     i_unit_measure     => i_unit_measure,
                                     i_flg_task_status  => l_epis_hidrics_flg_stat,
                                     i_flg_restricted   => i_flg_restricted,
                                     i_max_intake       => i_max_intake,
                                     i_min_output       => i_min_output,
                                     o_id_epis_hidrics  => o_id_epis_hidrics,
                                     o_error            => o_error)
                THEN
                    RETURN FALSE;
                END IF;
                --
            ELSIF i_flg_type = g_create_hidrics_action_update
            -- UPDATING HIDRICS
            THEN
                --
                IF i_flg_task_status <> pk_inp_hidrics_constant.g_epis_hidric_d
                THEN
                    -- IF there is an previouse hidric registry active, it should be cancelled/inactivated
                    IF NOT inact_prev_hidric(i_lang           => i_lang,
                                             i_prof           => i_prof,
                                             i_episode        => i_episode,
                                             i_id_epis_hidric => i_epis_hidrics,
                                             i_notes          => NULL,
                                             i_hid_type       => i_hid_type,
                                             o_error          => o_error)
                    THEN
                        RETURN FALSE;
                    END IF;
                END IF;
            
                --
                g_error := 'CALL UPDATE_EPIS_HIDRICS';
                pk_alertlog.log_debug(g_error);
                IF NOT update_epis_hidrics(i_lang                  => i_lang,
                                           i_prof                  => i_prof,
                                           i_episode               => i_episode,
                                           i_epis_hidrics          => i_epis_hidrics,
                                           i_dt_initial_str        => i_dt_initial_str,
                                           i_dt_end_str            => i_dt_end_str,
                                           i_dt_next_balance       => i_dt_next_balance,
                                           i_hid_interv            => i_hid_interv,
                                           i_interval_minutes      => i_interval_minutes,
                                           i_notes                 => i_notes,
                                           i_hid_type              => i_hid_type,
                                           i_epis_hidrics_flg_stat => l_epis_hidrics_flg_stat,
                                           i_flg_restricted        => i_flg_restricted,
                                           i_max_intake            => i_max_intake,
                                           i_min_output            => i_min_output,
                                           o_id_epis_hidrics       => o_id_epis_hidrics,
                                           o_error                 => o_error)
                THEN
                    RETURN FALSE;
                END IF;
                --
                --When outdated there is no need to update balance
                IF l_epis_hidrics_flg_stat NOT IN
                   (pk_inp_hidrics_constant.g_epis_hidric_o, pk_inp_hidrics_constant.g_epis_hidric_pd)
                THEN
                    g_error := 'SEND TO HIST - HIDRICS_BALANCE i_where: id_epis_hidrics = ' || i_epis_hidrics;
                    pk_alertlog.log_debug(g_error);
                    set_epis_hid_bal_hist(i_where => 'id_epis_hidrics = ' || i_epis_hidrics);
                    --                    
                    g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD WITH ID_EPIS_HIDRICS ' || i_epis_hidrics;
                    pk_alertlog.log_debug(g_error);
                    l_rowids := table_varchar();
                    ts_epis_hidrics_balance.upd(flg_status_in          => l_epis_hidrics_flg_stat,
                                                id_prof_last_change_in => i_prof.id,
                                                dt_eh_balance_in       => g_sysdate_tstz,
                                                where_in               => ' id_epis_hidrics = ' || i_epis_hidrics,
                                                rows_out               => l_rowids);
                
                    --                    
                    g_error := 'GET EPIS_HIDRICS FIRST BALANCE';
                    pk_alertlog.log_debug(g_error);
                    SELECT a.id_epis_hidrics_balance,
                           (SELECT MIN(ehd.dt_execution_tstz)
                              FROM epis_hidrics_det ehd
                             WHERE ehd.id_epis_hidrics_balance = a.id_epis_hidrics_balance) dt_execution_tstz
                      INTO l_epis_hid_balance, l_dt_execution
                      FROM (SELECT ehb.id_epis_hidrics_balance, row_number() over(ORDER BY ehb.dt_open_tstz) line_number
                              FROM epis_hidrics_balance ehb
                             WHERE ehb.id_epis_hidrics = i_epis_hidrics) a
                     WHERE a.line_number = 1;
                
                    l_dt_open := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_initial_str, NULL);
                
                    IF pk_date_utils.compare_dates_tsz(i_prof, l_dt_execution, l_dt_open) = 'L'
                    THEN
                        g_error := 'TRYING TO SET BALANCE DT_OPEN TO A FUTURE DATE WITH EXECUTION BEFORE THAT. DT_EXEC: ' ||
                                   to_char(l_dt_execution) || '; DT_OPEN: ' || to_char(l_dt_open);
                        RAISE e_date_compare;
                    ELSE
                        g_error := 'UPDATE DT_OPEN OF FIRST BALANCE';
                        pk_alertlog.log_debug(g_error);
                        ts_epis_hidrics_balance.upd(id_epis_hidrics_balance_in => l_epis_hid_balance,
                                                    dt_eh_balance_in           => g_sysdate_tstz,
                                                    dt_open_tstz_in            => l_dt_open);
                    END IF;
                    --            
                    g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS ' || i_epis_hidrics;
                    pk_alertlog.log_debug(g_error);
                    t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
                END IF;
            END IF;
        
            --
            IF i_flg_task_status <> pk_inp_hidrics_constant.g_epis_hidric_d
            THEN
            
                SELECT ht.acronym
                  INTO l_ht_acronym
                  FROM epis_hidrics eh
                 INNER JOIN hidrics_type ht
                    ON (ht.id_hidrics_type = eh.id_hidrics_type)
                 WHERE eh.id_epis_hidrics = nvl(i_epis_hidrics, o_id_epis_hidrics);
            
                g_error := 'CALL TO PK_CPOE.SYNC_TASK';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                         i_prof                 => i_prof,
                                         i_episode              => i_episode,
                                         i_task_type            => CASE l_ht_acronym
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_h THEN
                                                                        pk_alert_constant.g_task_type_hidric_in_out
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_d THEN
                                                                        pk_alert_constant.g_task_type_hidric_out
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_r THEN
                                                                        pk_alert_constant.g_task_type_hidric_drain
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_i THEN
                                                                        pk_alert_constant.g_task_type_hidric_in
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_o THEN
                                                                        pk_alert_constant.g_task_type_hidric_out_group
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_all THEN
                                                                        pk_alert_constant.g_task_type_hidric_out_all
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_g THEN
                                                                        pk_alert_constant.g_task_type_hidric_irrigations
                                                                       ELSE
                                                                        NULL
                                                                   END,
                                         i_task_request         => o_id_epis_hidrics,
                                         i_task_start_timestamp => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                 i_prof      => i_prof,
                                                                                                 i_timestamp => i_dt_initial_str,
                                                                                                 i_timezone  => NULL),
                                         o_error                => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            END IF;
        
            IF l_flg_profile = pk_prof_utils.g_flg_profile_template_student
               AND l_edition = pk_alert_constant.g_no
            THEN
                l_sys_alert_event.id_sys_alert    := pk_alert_constant.g_alert_cpoe_draft;
                l_sys_alert_event.id_software     := i_prof.software;
                l_sys_alert_event.id_institution  := i_prof.institution;
                l_sys_alert_event.id_episode      := i_episode;
                l_sys_alert_event.id_patient      := i_patient;
                l_sys_alert_event.id_record       := i_episode;
                l_sys_alert_event.id_visit        := pk_visit.get_visit(i_episode => i_episode, o_error => o_error);
                l_sys_alert_event.dt_record       := current_timestamp;
                l_sys_alert_event.id_professional := pk_hand_off.get_episode_responsible(i_lang       => i_lang,
                                                                                         i_prof       => i_prof,
                                                                                         i_id_episode => i_episode,
                                                                                         o_error      => o_error);
            
                IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                        i_prof            => i_prof,
                                                        i_sys_alert_event => l_sys_alert_event,
                                                        o_error           => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
            END IF;
        
        END IF;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN e_date_compare THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              pk_message.get_message(i_lang, 'HIDRICS_M079'),
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_HIDRICS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_HIDRICS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END set_hidrics;

    /*******************************************************************************************************************************************
    * get_nr_occurs_by_type          Function that returns the nr of occurrences by ocurrence type for a given id_epis_hidrics
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_epis_hidrics           EPISDOE Hidric ID
    * @param i_id_epis_hid_balance    Epis hidrics balance
    * @param i_id_episode             Episode ID
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         List with the nr of occurcence ; Occurrence type descruption
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.5
    * @since                          13-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION get_nr_occurs_by_type
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_id_epis_hid_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        i_id_episode          IN episode.id_episode%TYPE
    ) RETURN table_varchar IS
        l_res table_varchar;
        l_err t_error_out;
    
        l_inst       institution.id_institution%TYPE;
        l_soft       software.id_software%TYPE;
        l_department department.id_department%TYPE;
        l_dept       dept.id_dept%TYPE;
        l_id_market  market.id_market%TYPE;
    
        l_epis_balances table_number;
    
        l_func_name VARCHAR2(24 CHAR) := 'GET_NR_OCCURS_BY_TYPE';
    BEGIN
        g_error := 'GET CONF VARS - OCCURENCE TYPE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => i_id_episode,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_o,
                             o_inst       => l_inst,
                             o_soft       => l_soft,
                             o_department => l_department,
                             o_dept       => l_dept,
                             o_id_market  => l_id_market,
                             o_error      => l_err))
        THEN
            RAISE e_error;
        END IF;
    
        g_error         := 'CALL get_prev_manual_balances';
        l_epis_balances := get_prev_manual_balances(i_lang                  => i_lang,
                                                    i_prof                  => i_prof,
                                                    i_epis_hidrics          => i_id_epis_hidrics,
                                                    i_epis_hidrics_balance  => i_id_epis_hid_balance,
                                                    i_flg_close_type        => pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut,
                                                    i_dt_close_balance_tstz => NULL);
    
        g_error := 'get_nr_occurs_by_type. i_id_epis_hidrics: ' || i_id_epis_hidrics || ' i_id_epis_hid_balance: ' ||
                   i_id_epis_hid_balance;
        pk_alertlog.log_debug(g_error);
    
        SELECT tb.total_times || ';' || tb.desc_type
          BULK COLLECT
          INTO l_res
          FROM (SELECT nvl(t.total_times, 0) total_times,
                       pk_translation.get_translation(i_lang, hot.code_hidrics_occurs_type) desc_type
                  FROM hidrics_occurs_type hot
                  LEFT JOIN (SELECT SUM(e.nr_times) total_times, hotr.id_hidrics_occurs_type
                              FROM epis_hidrics_det e
                              JOIN epis_hidrics_line ehl
                                ON ehl.id_epis_hidrics = e.id_epis_hidrics
                               AND ehl.id_epis_hidrics_line = e.id_epis_hidrics_line
                              JOIN hidrics h
                                ON h.id_hidrics = ehl.id_hidrics
                              LEFT JOIN hidrics_occurs_type_rel hotr
                                ON hotr.id_hidrics = h.id_hidrics
                             WHERE hotr.id_hidrics_occurs_type IS NOT NULL
                               AND e.id_epis_hidrics = i_id_epis_hidrics
                               AND e.flg_status <> pk_inp_hidrics_constant.g_epis_hid_det_status_c
                               AND e.id_epis_hidrics_balance IN
                                   (SELECT /*+opt_estimate (table t rows=0.000001)*/
                                     column_value
                                      FROM TABLE(l_epis_balances) t)
                               AND nvl(hotr.id_department, 0) = l_department
                               AND nvl(hotr.id_dept, 0) = l_dept
                               AND nvl(hotr.id_institution, 0) = l_inst
                               AND nvl(hotr.id_market, 0) = l_id_market
                             GROUP BY hotr.id_hidrics_occurs_type) t
                    ON t.id_hidrics_occurs_type = hot.id_hidrics_occurs_type
                 WHERE EXISTS (SELECT 1
                          FROM hidrics_occurs_type_rel hotr1
                         WHERE hotr1.id_hidrics_occurs_type = hot.id_hidrics_occurs_type
                           AND nvl(hotr1.id_department, 0) = l_department
                           AND nvl(hotr1.id_dept, 0) = l_dept
                           AND nvl(hotr1.id_institution, 0) = l_inst
                           AND nvl(hotr1.id_market, 0) = l_id_market)) tb
         ORDER BY tb.desc_type;
    
        RETURN l_res;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_NR_OCCURS_BY_TYPE',
                                              l_err);
            RETURN NULL;
    END get_nr_occurs_by_type;

    /********************************************************************************************
    * Returns Number of records to display in each page
    *
    * @param I_LANG                  Language ID for translations
    * @param I_PROF                  Professional vector of information (professional ID, institution ID, software ID)
    * @param O_NUM_RECORDS           number of records per page
    * @param O_ERROR                 If an error accurs, this parameter will have information about the error
    *
    * @return                         Returns TRUE if success, otherwise returns FALSE
    *
    * @author                        António Neto
    * @since                         17-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION get_num_page_records
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        o_num_records OUT PLS_INTEGER,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_num_records sys_config.value%TYPE;
        err_general_exception EXCEPTION;
    BEGIN
        g_error := 'CALL PK_SYSCONFIG.GET_CONFIG';
        IF NOT pk_sysconfig.get_config(pk_inp_hidrics_constant.g_num_records, i_prof, l_num_records)
        THEN
            RAISE err_general_exception;
        END IF;
    
        o_num_records := to_number(l_num_records);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_NUM_PAGE_RECORDS',
                                              o_error);
            o_num_records := 0;
            RETURN FALSE;
    END get_num_page_records;

    /********************************************************************************************
    * get_ult_result                 Get last result from Hidric
    *
    * @param I_FLG_STATUS            Hidric flag Status
    * @param I_MSG_HIDRICS_M002      Flag to begin
    * @param I_MSG_HIDRICS_M002      Flag ongoing
    *
    * @return                        Returns last result from Hidric
    *
    * @author                        António Neto
    * @since                         23-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION get_ult_result
    (
        i_flg_status       IN epis_hidrics.flg_status%TYPE,
        i_msg_hidrics_m002 IN sys_message.desc_message%TYPE,
        i_msg_hidrics_m003 IN sys_message.desc_message%TYPE
        
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN CASE i_flg_status
        
        WHEN pk_inp_hidrics_constant.g_epis_hidric_r THEN
        
        i_msg_hidrics_m002
        
        WHEN pk_inp_hidrics_constant.g_epis_hidric_e THEN
        
        i_msg_hidrics_m003
        
        ELSE
        
        NULL
        
        END;
    
    END get_ult_result;

    /********************************************************************************************
    * get_total_result               Get Balance total result from Hidric
    *
    * @param I_LANG                  Language ID for translations
    * @param I_PROF                  Professional vector of information (professional ID, institution ID, software ID)
    * @param I_FLG_STATUS            Hidric flag Status
    * @param I_ID_EPIS_HIDRICS       ID Hidric Episode
    * @param I_TOTAL_ADMIN           Hidric Balance Total Intake
    * @param I_TOTAL_Elim            Hidric Balance Total Output
    * @param I_DT_OPEN_TSTZ          Hidric Balance Open Date/Time
    * @param I_DT_CLOSE_TSTZ         Hidric Balance Close Date/Time
    *
    * @return                        Returns Balance total result from Hidric
    *
    * @author                        António Neto
    * @since                         23-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION get_total_result
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_flg_status      IN epis_hidrics.flg_status%TYPE,
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_total_admin     IN epis_hidrics_balance.total_admin%TYPE,
        i_total_elim      IN epis_hidrics_balance.total_elim%TYPE,
        i_dt_open_tstz    IN epis_hidrics_balance.dt_open_tstz%TYPE,
        i_dt_close_tstz   IN epis_hidrics_balance.dt_close_balance_tstz%TYPE
        
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN CASE
        
        WHEN i_flg_status IN(pk_inp_hidrics_constant.g_epis_hidric_e, pk_inp_hidrics_constant.g_epis_hidric_i) THEN
        
        (get_total_admin(i_lang, i_prof, i_id_epis_hidrics, i_total_admin, i_dt_open_tstz, i_dt_close_tstz)) - nvl(i_total_elim,
                                                                                                                   0)
        
        ELSE
        
        NULL
        
        END;
    
    END get_total_result;

    /********************************************************************************************
    * get_hidric_last_result         Gets Hidric Last Result
    *
    * @param I_LANG                  Language ID for translations
    * @param I_PROF                  Professional vector of information (professional ID, institution ID, software ID)
    * @param I_FLG_STATUS            Hidric flag Status
    * @param I_ID_EPIS_HIDRICS       ID Hidric Episode
    * @param I_TOTAL_ADMIN           Hidric Balance Total Intake
    * @param I_TOTAL_Elim            Hidric Balance Total Output
    * @param I_DT_OPEN_TSTZ          Hidric Balance Open Date/Time
    * @param I_DT_CLOSE_TSTZ         Hidric Balance Close Date/Time
    * @param I_UNIT_MEASURE          Hidric Unit Measure
    *
    * @return                        Returns the Hidric Last Resul
    *
    * @author                        António Neto
    * @since                         23-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION get_hidric_last_result
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_flg_status       IN epis_hidrics.flg_status%TYPE,
        i_id_epis_hidrics  IN epis_hidrics.id_epis_hidrics%TYPE,
        i_total_admin      IN epis_hidrics_balance.total_admin%TYPE,
        i_total_elim       IN epis_hidrics_balance.total_elim%TYPE,
        i_dt_open_tstz     IN epis_hidrics_balance.dt_open_tstz%TYPE,
        i_dt_close_tstz    IN epis_hidrics_balance.dt_close_balance_tstz%TYPE,
        i_msg_hidrics_m002 IN sys_message.desc_message%TYPE,
        i_msg_hidrics_m003 IN sys_message.desc_message%TYPE,
        i_unit_measure     IN pk_translation.t_desc_translation
    ) RETURN VARCHAR2 IS
        l_ult_result   VARCHAR2(4000) := TRIM(get_ult_result(i_flg_status, i_msg_hidrics_m002, i_msg_hidrics_m003));
        l_total_result VARCHAR2(4000) := TRIM(get_total_result(i_lang,
                                                               i_prof,
                                                               i_flg_status,
                                                               i_id_epis_hidrics,
                                                               i_total_admin,
                                                               i_total_elim,
                                                               i_dt_open_tstz,
                                                               i_dt_close_tstz));
    BEGIN
        IF nvl(l_total_result, 0) = 0
        THEN
            RETURN l_ult_result;
        ELSIF l_ult_result IS NULL
        THEN
            RETURN l_total_result || pk_inp_hidrics_constant.g_space || i_unit_measure;
        ELSE
            RETURN l_ult_result || pk_inp_hidrics_constant.g_enter || pk_inp_hidrics_constant.g_open_bracket || l_total_result || pk_inp_hidrics_constant.g_space || i_unit_measure || pk_inp_hidrics_constant.g_close_bracket;
        END IF;
    
    END get_hidric_last_result;

    /********************************************************************************************
    * Get_pdms_ways                  Gets Hidric ways
    *
    * @param I_LANG                  Language ID for translations
    * @param I_PROF                  Professional vector of information (professional ID, institution ID, software ID)
    * @param I_FLG_type              Hidric flag Type
    *
    * @return                        Returns the Hidric Last Resul
    *
    * @author                        Miguel Gomes
    * @since                         29-AGO-2013
    * @version                       2.6.3.9
    ********************************************************************************************/
    FUNCTION get_pdms_ways
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_flg_type    IN way.flg_type%TYPE,
        o_hidric_list OUT pk_types.cursor_type,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'get_pdms_ways Init';
        alertlog.pk_alertlog.log_info(g_error);
    
        OPEN o_hidric_list FOR
            SELECT w.id_way, w.flg_way_type, pk_translation.get_translation(i_lang, w.code_way) description
              FROM way w
             WHERE w.flg_available = pk_alert_constant.g_yes
               AND w.flg_type = i_flg_type;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PDMS_HIDRICS_WAYS',
                                              o_error);
            pk_types.open_my_cursor(o_hidric_list);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_pdms_ways;

    /********************************************************************************************
    * get_hidric_status              Gets Hidric Status
    *
    * @param I_LANG                  Language ID for translations
    * @param I_FLG_STATUS            Hidric flag Status
    *
    * @return                        Returns the Hidric Status
    *
    * @author                        António Neto
    * @since                         23-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION get_hidric_status
    (
        i_lang       IN language.id_language%TYPE,
        i_flg_status IN epis_hidrics.flg_status%TYPE
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN pk_sysdomain.get_domain(pk_inp_hidrics_constant.g_domain_eh_flg_status, i_flg_status, i_lang);
    
    END get_hidric_status;

    /********************************************************************************************
    * get_interval_desc              Get the interval description in format: X hours Y minutes,
    *                                given the interval in minutes
    *
    * @param i_interval_minutes      Interval in minutes
    * @param i_msg_hour              Hour message
    * @param i_msg_hours             Hours message
    * @param i_msg_minute            Minute message
    * @param i_msg_minutes           Minutes message
    *
    * @return                        Returns the conversion of Hidric to Date/Time
    *
    * @author                        Sofia Mendes
    * @since                         21-Mar-2011
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION get_interval_desc
    (
        i_lang             IN language.id_language%TYPE,
        i_interval_minutes IN hidrics_interval.interval_minutes%TYPE
    ) RETURN VARCHAR2 IS
        l_nr_hours NUMBER;
        l_nr_min   NUMBER := 0;
        l_desc     VARCHAR2(4000);
    BEGIN
        l_nr_hours := trunc(i_interval_minutes / 60);
        l_nr_min   := MOD(i_interval_minutes, 60);
    
        l_desc := pk_inp_util.get_format_interval(i_lang => i_lang, i_hours => l_nr_hours, i_minutes => l_nr_min);
    
        RETURN l_desc;
    
    END get_interval_desc;

    /********************************************************************************************
    * get_hidric_interval                   Gets Hidric Interval Description
    *
    * @param I_LANG                         Language ID for translations
    * @param i_interval_minutes             Interval Value (cames from 'Other' option)
    * @param I_MSG_HOUR                     Mask format one hour
    * @param I_MSG_HOURS                    Mask format more than one hour
    * @param i_msg_minute                   Mask format one minute
    * @param i_msg_minutes                  Mask format more than one minute
    * @param I_CODE_HIDRICS_INTERVAL        Code Interval Value
    *
    * @return                               Returns the Hidric Interval Description
    *
    * @author                               António Neto
    * @since                                23-Dec-2010
    * @version                              2.6.0.5
    ********************************************************************************************/
    FUNCTION get_hidric_interval
    (
        i_lang                  IN language.id_language%TYPE,
        i_interval_minutes      IN epis_hidrics.interval_minutes%TYPE,
        i_msg_hour              IN sys_message.desc_message%TYPE,
        i_msg_hours             IN sys_message.desc_message%TYPE,
        i_msg_minute            IN sys_message.desc_message%TYPE,
        i_msg_minutes           IN sys_message.desc_message%TYPE,
        i_code_hidrics_interval IN hidrics_interval.code_hidrics_interval%TYPE
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN CASE
        --
        WHEN i_interval_minutes IS NULL THEN
        --
        pk_translation.get_translation(i_lang, i_code_hidrics_interval)
        --
        ELSE
        --
        get_interval_desc(i_lang => i_lang, i_interval_minutes => i_interval_minutes) END;
    
    END get_hidric_interval;

    /********************************************************************************************
    * to_char_hidric_datetime         Convert Hidric Date/Time to varchar
    *
    * @param I_LANG                  Language ID for translations
    * @param I_PROF                  Professional vector of information (professional ID, institution ID, software ID)
    * @param I_DATETIME              Date Time to be converted
    *
    * @return                        Returns the conversion of Hidric Date/Time to varchar
    *
    * @author                        António Neto
    * @since                         23-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION to_char_hidric_datetime
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_datetime IN TIMESTAMP WITH LOCAL TIME ZONE
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN pk_date_utils.date_send_tsz(i_lang, i_datetime, i_prof);
    
    END to_char_hidric_datetime;

    /********************************************************************************************
    * to_datetime_hidric             Convert Hidric to Date/Time
    *
    * @param I_INTERVAL              Interval in string format
    *
    * @return                        Returns the conversion of Hidric to Date/Time
    *
    * @author                        António Neto
    * @since                         24-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION to_datetime_hidric(i_interval IN VARCHAR2) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
    BEGIN
        RETURN to_date(i_interval, pk_inp_hidrics_constant.g_hour_minute_format);
    
    END to_datetime_hidric;

    /********************************************************************************************
    * get_hidric_bal_rank            Get Hidric Balance Rank
    *
    * @param I_LANG                  Language ID for translations
    * @param I_FLG_STATUS            Hidric Balance flag Status
    *
    * @return                        Returns Hidric Balance Rank
    *
    * @author                        António Neto
    * @since                         24-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION get_hidric_bal_rank
    (
        i_lang       IN language.id_language%TYPE,
        i_flg_status IN epis_hidrics_balance.flg_status%TYPE
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN pk_sysdomain.get_rank(i_lang, pk_inp_hidrics_constant.g_domain_ehb_flg_status, i_flg_status);
    
    END get_hidric_bal_rank;

    /********************************************************************************************
    * get_desc_hidric_type           Return description of the intake and outake with software where it was requested (if not actual software)
    *
    * @param I_LANG                  Language ID for translations
    * @param I_PROF                  Professional vector of information (professional ID, institution ID, software ID)
    * @param I_LINST_ID_EPIS_TYPE    ID Episode Type to be compared
    * @param I_ID_EPIS_TYPE          ID Episode Type to be used
    * @param I_ID_EPIS_HIDRICS       ID Hidric Episode
    * @param I_FLG_TI_TYPE           Flag TI_LOG
    * @param I_CODE_HIDRICS_TYPE     Code Hidric Type
    *
    * @return                        Returns the description of hidric type
    *
    * @author                        António Neto
    * @since                         23-Dec-2010
    * @version                       2.6.0.5
    ********************************************************************************************/
    FUNCTION get_desc_hidric_type
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_linst_id_epis_type IN episode.id_epis_type%TYPE,
        i_epi_id_epis_type   IN episode.id_epis_type%TYPE,
        i_id_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_ti_type        IN hidrics_type.flg_ti_type%TYPE,
        i_code_hidrics_type  IN hidrics_type.code_hidrics_type%TYPE
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN
        --
        CASE i_linst_id_epis_type
        --
        WHEN nvl(t_ti_log.get_epis_type(i_lang,
                                        i_prof,
                                        i_epi_id_epis_type,
                                        pk_inp_hidrics_constant.g_epis_hidric_r,
                                        i_id_epis_hidrics,
                                        i_flg_ti_type),
                 i_epi_id_epis_type) THEN
        --
        pk_translation.get_translation(i_lang, i_code_hidrics_type)
        --
        ELSE
        --
        pk_translation.get_translation(i_lang, i_code_hidrics_type) || ' (' || pk_message.get_message(i_lang,
                                                                                                      profissional(i_prof.id,
                                                                                                                   i_prof.institution,
                                                                                                                   --
                                                                                                                   t_ti_log.get_epis_type_soft(i_lang,
                                                                                                                                               i_prof,
                                                                                                                                               i_epi_id_epis_type,
                                                                                                                                               pk_inp_hidrics_constant.g_epis_hidric_r,
                                                                                                                                               i_id_epis_hidrics,
                                                                                                                                               i_flg_ti_type)),
                                                                                                      pk_inp_hidrics_constant.g_image_decode) || ')'
        --
        END
        --
        ;
    
    END get_desc_hidric_type;

    /*******************************************************************************************************************************************
    * Get all hidrics associated with all episodes in current episode visit
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_SCOPE                  Scope ID (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_FLG_SCOPE              Scope type
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled
    * @param I_CRIT_TYPE              Flag that indicates if the filter time to consider all records or only during the executions
    * @param I_FLG_REPORT             Flag used to remove formatting
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_DRAFT              If it should return draft functions or not
    * @param I_SEARCH                 keyword to Search for
    * @param I_START_RECORD           Paging - initial record number
    * @param I_NUM_RECORDS            Paging - number of records to display
    * @param I_FILTER                 Filter by a group (dates, hidric type, etc.)
    * @param I_COLUMN_TO_ORDER        Column to be order
    * @param I_ORDER_BY               The way to be order, ascending (ASC) or descendig (DESC)
    * @param I_ID_EPIS_TYPE           Episode Type identifier
    * @param O_EPIS_HID               Cursor that returns hidrics
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    *
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_SCOPE              {*} 'E' Episode {*} 'V' Visit {*} 'P' Patient
    * @value I_CANCELLED              {*} 'Y' Yes {*} 'N' No
    * @value I_CRIT_TYPE              {*} 'A' All {*} 'E' Execution
    * @value I_FLG_REPORT             {*} 'Y' Yes {*} 'N' No
    * @value I_FLG_DRAFT              {*} 'Y' YES {*} 'N' NO
    * @value I_FILTER                 {*} '1' Hidric Type {*} '2' Hidric Initial Date/Time {*} '3' Hidric State {*} '0' All {*} 'NULL' All
    * @value I_COLUMN_TO_ORDER        {*} '1' Hidric Type {*} '2' Hidric Initial Date/Time {*} '3' Hidric State {*} '4' Hidric Interval Value {*} '5' Hidric End Date/Time {*} '6' Hidric Last Result {*} 'NULL' Balance Rank ASC and Hidric Creation Descending and ID Hidric Balance Episode Descending
    * @value I_ORDER_BY               {*} '1' Ascending Order {*} 'NULL' Ascending Order {*} '2' Descending Order
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/21
    *
    * @author                         Luís Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/19
    *
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          10-Nov-2011
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_int
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_scope           IN NUMBER,
        i_flg_scope       IN VARCHAR2,
        i_start_date      IN VARCHAR2,
        i_end_date        IN VARCHAR2,
        i_cancelled       IN VARCHAR2,
        i_crit_type       IN VARCHAR2,
        i_flg_report      IN VARCHAR2,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_draft       IN VARCHAR2,
        i_search          IN VARCHAR2,
        i_start_record    IN NUMBER,
        i_num_records     IN NUMBER,
        i_filter          IN NUMBER,
        i_column_to_order IN NUMBER,
        i_order_by        IN NUMBER,
        i_id_epis_type    IN episode.id_epis_type%TYPE,
        o_epis_hid        OUT pk_types.cursor_type,
        o_tbl_requests    OUT NOCOPY t_tbl_hidrics_request,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_msg_hidrics_m002 sys_message.desc_message%TYPE;
        l_msg_hidrics_m003 sys_message.desc_message%TYPE;
        l_msg_hidrics_t019 sys_message.desc_message%TYPE;
        l_msg_hidrics_t026 sys_message.desc_message%TYPE;
        l_msg_hidrics_t031 sys_message.desc_message%TYPE;
        l_msg_hidrics_t032 sys_message.desc_message%TYPE;
        l_msg_hidrics_t033 sys_message.desc_message%TYPE;
        l_msg_hidrics_t034 sys_message.desc_message%TYPE;
        l_msg_hidrics_t027 sys_message.desc_message%TYPE;
        l_msg_hidrics_t038 sys_message.desc_message%TYPE;
        l_msg_common_m008  sys_message.desc_message%TYPE;
        l_msg_max_intake   sys_message.desc_message%TYPE;
        l_msg_min_output   sys_message.desc_message%TYPE;
        l_msg_hour         sys_message.desc_message%TYPE;
        l_msg_hours        sys_message.desc_message%TYPE;
        l_msg_total_occurs sys_message.desc_message%TYPE;
        l_msg_minute       sys_message.desc_message%TYPE;
        l_msg_minutes      sys_message.desc_message%TYPE;
        --
        l_config_unit_mea   sys_config.value%TYPE;
        l_unit_measure_desc pk_translation.t_desc_translation;
        --
    
        l_search          VARCHAR2(4000 CHAR) := NULL;
        l_filter          PLS_INTEGER := pk_inp_hidrics_constant.g_filter_type_all;
        l_column_to_order PLS_INTEGER := pk_inp_hidrics_constant.g_columns_order_2;
        l_order_by        PLS_INTEGER := pk_inp_hidrics_constant.g_order_by_1;
        --
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient patient.id_patient%TYPE;
    
        e_invalid_argument EXCEPTION;
    
        l_start_date TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_end_date   TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
    BEGIN
        g_error := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE e_invalid_argument;
        END IF;
    
        --convert string to date format
        IF i_start_date IS NOT NULL
        THEN
            l_start_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_date, NULL);
        END IF;
        IF i_end_date IS NOT NULL
        THEN
            l_end_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_date, NULL);
        END IF;
    
        IF i_filter IS NOT NULL
        THEN
            l_filter := i_filter;
        END IF;
    
        IF i_search IS NOT NULL
        THEN
            l_search := pk_utils.remove_upper_accentuation(i_search);
        END IF;
    
        IF i_column_to_order IS NOT NULL
        THEN
            l_column_to_order := i_column_to_order;
        END IF;
    
        IF i_order_by IS NOT NULL
        THEN
            l_order_by := i_order_by;
        END IF;
    
        l_msg_hidrics_m002 := pk_message.get_message(i_lang, 'HIDRICS_M002');
        l_msg_hidrics_m003 := pk_message.get_message(i_lang, 'HIDRICS_M003');
        l_msg_hidrics_t019 := pk_message.get_message(i_lang, 'HIDRICS_T019');
        l_msg_hidrics_t026 := pk_message.get_message(i_lang, 'HIDRICS_T026');
        l_msg_hidrics_t031 := pk_message.get_message(i_lang, 'HIDRICS_T031');
        l_msg_hidrics_t032 := pk_message.get_message(i_lang, 'HIDRICS_T032');
        l_msg_hidrics_t033 := pk_message.get_message(i_lang, 'HIDRICS_T033');
        l_msg_hidrics_t034 := pk_message.get_message(i_lang, 'HIDRICS_T034');
        l_msg_hidrics_t027 := pk_message.get_message(i_lang, 'HIDRICS_T027');
        l_msg_hidrics_t038 := pk_message.get_message(i_lang, 'HIDRICS_T038');
        l_msg_common_m008  := pk_message.get_message(i_lang, 'COMMON_M008');
        l_msg_max_intake   := pk_message.get_message(i_lang, 'HIDRICS_M024');
        l_msg_min_output   := pk_message.get_message(i_lang, 'HIDRICS_M025');
        l_msg_total_occurs := pk_message.get_message(i_lang, 'HIDRICS_T096');
    
        l_config_unit_mea := pk_sysconfig.get_config(i_code_cf => 'HIDRICS_UNIT_MEAS', i_prof => i_prof);
    
        IF l_config_unit_mea IS NOT NULL
        THEN
            g_error := 'GET UNIT MEASURE DESCRIPTION';
            pk_alertlog.log_debug(g_error);
            SELECT pk_translation.get_translation(i_lang, um.code_unit_measure)
              INTO l_unit_measure_desc
              FROM unit_measure um
             WHERE um.id_unit_measure = to_number(l_config_unit_mea);
        END IF;
    
        g_error := 'GET records for requests grid';
        pk_alertlog.log_debug(g_error);
        SELECT t_rec_hidrics_request(sfinal.id_epis_hidrics,
                                     sfinal.flg_status_eh,
                                     sfinal.id_hidrics_type,
                                     sfinal.acronym,
                                     sfinal.id_epis_hidrics_balance,
                                     sfinal.flg_status_ehb,
                                     sfinal.dt_initial_tstz,
                                     sfinal.dt_end_tstz,
                                     sfinal.get_dt_next_balance,
                                     sfinal.interval_minutes,
                                     sfinal.flg_restricted,
                                     sfinal.max_intake,
                                     sfinal.min_output,
                                     sfinal.total_admin,
                                     sfinal.total_elim,
                                     sfinal.dt_open_tstz,
                                     sfinal.dt_close_balance_tstz,
                                     sfinal.id_epis_type,
                                     sfinal.flg_ti_type,
                                     sfinal.code_hidrics_type,
                                     sfinal.id_hidrics_interval,
                                     sfinal.code_hidrics_interval,
                                     sfinal.flg_type,
                                     sfinal.notes,
                                     sfinal.notes_cancel,
                                     sfinal.notes_inter,
                                     sfinal.dt_begin_tstz,
                                     sfinal.id_professional_eh,
                                     sfinal.id_professional_pr,
                                     sfinal.flg_check_extra_take,
                                     sfinal.id_episode)
          BULK COLLECT
          INTO o_tbl_requests
          FROM (SELECT sfinal_aux.*,
                       (SELECT get_dt_next_balance(i_lang, i_prof, sfinal_aux.id_epis_hidrics)
                          FROM dual) get_dt_next_balance
                  FROM (SELECT rownum rn, sorder.*
                          FROM (SELECT rownum * decode(l_order_by,
                                                       --
                                                       --Ascending Order
                                                       pk_inp_hidrics_constant.g_order_by_1,
                                                       pk_inp_hidrics_constant.g_order_by_asc_num,
                                                       --
                                                       --Descending Order
                                                       pk_inp_hidrics_constant.g_order_by_2,
                                                       pk_inp_hidrics_constant.g_order_by_desc_num) orderedcolumn,
                                       sint.*
                                  FROM (SELECT CASE l_column_to_order
                                               --
                                               --Order By Hidric State
                                                   WHEN pk_inp_hidrics_constant.g_columns_order_3 THEN
                                                    get_hidric_status(i_lang, eh.flg_status)
                                               --
                                               --Order By Hidric Initial Date/Time
                                                   WHEN pk_inp_hidrics_constant.g_columns_order_2 THEN
                                                    to_char_hidric_datetime(i_lang, i_prof, eh.dt_initial_tstz)
                                               --
                                               --Order By Hidric Type
                                                   WHEN pk_inp_hidrics_constant.g_columns_order_1 THEN
                                                    get_desc_hidric_type(i_lang,
                                                                         i_prof,
                                                                         nvl(i_id_epis_type, epi.id_epis_type),
                                                                         epi.id_epis_type,
                                                                         eh.id_epis_hidrics,
                                                                         ht.flg_ti_type,
                                                                         ht.code_hidrics_type)
                                               
                                               --
                                               --Order By Hidric Interval Value
                                                   WHEN pk_inp_hidrics_constant.g_columns_order_4 THEN
                                                    to_char(nvl2(eh.interval_minutes,
                                                                 eh.interval_minutes,
                                                                 hi.interval_minutes))
                                               --
                                               --Order By Hidric End Date/Time
                                                   WHEN pk_inp_hidrics_constant.g_columns_order_5 THEN
                                                    to_char_hidric_datetime(i_lang, i_prof, eh.dt_end_tstz)
                                               --
                                               --Order By Hidric Last Result
                                                   WHEN pk_inp_hidrics_constant.g_columns_order_6 THEN
                                                    nvl(get_ult_result(eh.flg_status, l_msg_hidrics_m002, l_msg_hidrics_m003),
                                                        get_total_result(i_lang,
                                                                         i_prof,
                                                                         eh.flg_status,
                                                                         eh.id_epis_hidrics,
                                                                         ehb.total_admin,
                                                                         ehb.total_elim,
                                                                         ehb.dt_open_tstz,
                                                                         ehb.dt_close_balance_tstz))
                                               
                                               END casewhen,
                                               eh.id_epis_hidrics,
                                               eh.flg_status flg_status_eh,
                                               ht.id_hidrics_type,
                                               ht.acronym,
                                               ehb.id_epis_hidrics_balance,
                                               ehb.flg_status flg_status_ehb,
                                               eh.dt_initial_tstz,
                                               eh.dt_end_tstz,
                                               eh.interval_minutes,
                                               eh.flg_restricted,
                                               eh.max_intake,
                                               eh.min_output,
                                               ehb.total_admin,
                                               ehb.total_elim,
                                               epi.id_epis_type,
                                               ht.flg_ti_type,
                                               ht.code_hidrics_type,
                                               hi.code_hidrics_interval,
                                               eh.id_hidrics_interval,
                                               hi.flg_type,
                                               ehb.dt_open_tstz,
                                               ehb.dt_close_balance_tstz,
                                               eh.notes,
                                               eh.notes_cancel,
                                               eh.notes_inter,
                                               epi.dt_begin_tstz,
                                               eh.id_professional id_professional_eh,
                                               prof_req.id_professional id_professional_pr,
                                               eh.id_episode,
                                               decode(eh.flg_status,
                                                      pk_inp_hidrics_constant.g_epis_hidric_o,
                                                      check_extra_take(i_lang, i_prof, eh.id_episode, eh.id_epis_hidrics)) flg_check_extra_take
                                          FROM epis_hidrics eh
                                         INNER JOIN episode epi
                                            ON (eh.id_episode = epi.id_episode AND eh.id_patient = epi.id_patient)
                                         INNER JOIN epis_hidrics_balance ehb
                                            ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
                                         INNER JOIN hidrics_type ht
                                            ON (eh.id_hidrics_type = ht.id_hidrics_type)
                                         INNER JOIN hidrics_interval hi
                                            ON (eh.id_hidrics_interval = hi.id_hidrics_interval)
                                         INNER JOIN professional prof_req
                                            ON (eh.id_professional = prof_req.id_professional)
                                          LEFT JOIN unit_measure um
                                            ON (ehb.id_unit_measure = um.id_unit_measure)
                                        
                                        --*****************************************************************************************
                                        --** WHEN CHANGING THE WHERE CLAUSE OR ANY CODE INSIDE THE FROM AND INNER JOIN STATEMENT **
                                        --** PLEASE REPRODUCE ANY CHANGES IN THE SAME CODE ON FUNCTION GET_EPIS_HIDRICS_COUNT    **
                                        --*****************************************************************************************
                                        
                                        --            
                                         WHERE eh.id_patient = l_id_patient
                                           AND epi.id_episode = nvl(l_id_episode, epi.id_episode)
                                           AND epi.id_visit = nvl(l_id_visit, epi.id_visit)
                                           AND (SELECT get_most_recent_ehb_id(eh.id_epis_hidrics)
                                                  FROM dual) = ehb.id_epis_hidrics_balance
                                           AND
                                              --
                                               (
                                               --Nothing defined for hidric search
                                                l_search IS NULL OR
                                               
                                               --Search for Hidric Type
                                                (CASE l_filter
                                                    WHEN pk_inp_hidrics_constant.g_filter_type_1 THEN
                                                     pk_utils.remove_upper_accentuation(get_desc_hidric_type(i_lang,
                                                                                                             i_prof,
                                                                                                             nvl(i_id_epis_type,
                                                                                                                 epi.id_epis_type),
                                                                                                             epi.id_epis_type,
                                                                                                             eh.id_epis_hidrics,
                                                                                                             ht.flg_ti_type,
                                                                                                             ht.code_hidrics_type))
                                                    WHEN pk_inp_hidrics_constant.g_filter_type_2 THEN
                                                     (SELECT pk_utils.remove_upper_accentuation(pk_date_utils.dt_chr_tsz(i_lang,
                                                                                                                         eh.dt_initial_tstz,
                                                                                                                         i_prof))
                                                        FROM dual)
                                                    WHEN pk_inp_hidrics_constant.g_filter_type_3 THEN
                                                     (SELECT pk_utils.remove_upper_accentuation(get_hidric_status(i_lang,
                                                                                                                  eh.flg_status))
                                                        FROM dual)
                                                    WHEN pk_inp_hidrics_constant.g_filter_type_all THEN
                                                     nvl(pk_utils.remove_upper_accentuation(get_desc_hidric_type(i_lang,
                                                                                                                 i_prof,
                                                                                                                 nvl(i_id_epis_type,
                                                                                                                     epi.id_epis_type),
                                                                                                                 epi.id_epis_type,
                                                                                                                 eh.id_epis_hidrics,
                                                                                                                 ht.flg_ti_type,
                                                                                                                 ht.code_hidrics_type)),
                                                         '') || ' ' ||
                                                    --
                                                     nvl(pk_utils.remove_upper_accentuation(get_desc_hidric_type(i_lang,
                                                                                                                 i_prof,
                                                                                                                 nvl(i_id_epis_type,
                                                                                                                     epi.id_epis_type),
                                                                                                                 epi.id_epis_type,
                                                                                                                 eh.id_epis_hidrics,
                                                                                                                 ht.flg_ti_type,
                                                                                                                 ht.code_hidrics_type)),
                                                         '') || ' ' ||
                                                    --
                                                     (SELECT nvl(pk_utils.remove_upper_accentuation(pk_date_utils.dt_chr_tsz(i_lang,
                                                                                                                             eh.dt_initial_tstz,
                                                                                                                             i_prof)),
                                                                 '')
                                                        FROM dual) || ' ' ||
                                                    --
                                                     nvl((SELECT pk_utils.remove_upper_accentuation(get_hidric_status(i_lang,
                                                                                                                     eh.flg_status))
                                                           FROM dual),
                                                         '')
                                                
                                                END LIKE '%' || l_search || '%'
                                                --
                                                )
                                               --
                                               )
                                              --
                                           AND (eh.id_epis_hidrics = i_epis_hidrics OR i_epis_hidrics IS NULL)
                                              --
                                           AND ((eh.flg_status NOT IN
                                               (pk_inp_hidrics_constant.g_flg_task_status_d,
                                                  pk_inp_hidrics_constant.g_epis_hidric_l) AND
                                               i_flg_draft = pk_alert_constant.g_no) OR
                                               (i_flg_draft = pk_alert_constant.g_yes AND
                                               eh.flg_status NOT IN (pk_inp_hidrics_constant.g_epis_hidric_l)))
                                              --
                                           AND (
                                               --not report gets all
                                                i_flg_report = pk_alert_constant.g_no OR
                                               --
                                                (
                                                --if report
                                                 i_flg_report = pk_alert_constant.g_yes
                                                --
                                                 AND
                                                --
                                                 (
                                                 --shows canceled hidrics or not whether flag i_cancelled
                                                  (i_cancelled = pk_alert_constant.g_no AND
                                                  eh.flg_status <> pk_inp_hidrics_constant.g_epis_hidric_c) OR
                                                  i_cancelled = pk_alert_constant.g_yes
                                                 --
                                                 )
                                                --
                                                 AND
                                                --
                                                 (
                                                 --shows hidrics or not whether flag i_crit_type and the dates (i_start_date and i_end_date)
                                                 --Shows all the hidrics where the req, exec, balance was performed in the period
                                                  (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_all_a AND
                                                  (eh.dt_initial_tstz BETWEEN nvl(l_start_date, eh.dt_initial_tstz) AND
                                                  nvl(l_end_date, eh.dt_initial_tstz)
                                                  --
                                                  OR (SELECT check_has_balance(eh.id_epis_hidrics,
                                                                                 l_start_date,
                                                                                 l_end_date,
                                                                                 i_cancelled,
                                                                                 i_flg_report)
                                                          FROM dual) = pk_alert_constant.g_yes
                                                  --
                                                  OR (SELECT check_has_executions(eh.id_epis_hidrics,
                                                                                    l_start_date,
                                                                                    l_end_date,
                                                                                    i_cancelled,
                                                                                    i_flg_report)
                                                          FROM dual) = pk_alert_constant.g_yes)
                                                  --
                                                  )
                                                 --
                                                  OR
                                                 --Shows the hidrics that where req in the period
                                                  (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_req_r AND
                                                  eh.dt_initial_tstz BETWEEN nvl(l_start_date, eh.dt_initial_tstz) AND
                                                  nvl(l_end_date, eh.dt_initial_tstz))
                                                 --
                                                  OR
                                                 --Shows the hidrics that where exec in the period
                                                  (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_exec_e AND
                                                  (SELECT check_has_executions(eh.id_epis_hidrics,
                                                                                l_start_date,
                                                                                l_end_date,
                                                                                i_cancelled,
                                                                                i_flg_report)
                                                      FROM dual) = pk_alert_constant.g_yes)
                                                 --
                                                  OR
                                                 --Shows the hidrics that where balance in the period
                                                  (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_bal_b AND
                                                  (SELECT check_has_balance(eh.id_epis_hidrics,
                                                                             l_start_date,
                                                                             l_end_date,
                                                                             i_cancelled,
                                                                             i_flg_report)
                                                      FROM dual) = pk_alert_constant.g_yes)
                                                 --
                                                 )
                                                --
                                                )
                                               --
                                               )
                                        --              
                                         ORDER BY nvl2(i_column_to_order, casewhen, NULL),
                                                  decode(eh.flg_status,
                                                         pk_inp_hidrics_constant.g_epis_hidric_o,
                                                         get_hidric_bal_rank(i_lang, eh.flg_status),
                                                         get_hidric_bal_rank(i_lang, ehb.flg_status)),
                                                  eh.dt_creation_tstz DESC,
                                                  ehb.id_epis_hidrics_balance DESC
                                        --NULLS LAST
                                        ) sint
                                 ORDER BY orderedcolumn) sorder
                         ORDER BY rn) sfinal_aux
                 WHERE i_num_records IS NULL
                    OR rn BETWEEN i_start_record + 1 AND (i_start_record + i_num_records)
                 ORDER BY rn) sfinal;
    
        g_error := 'GET DATA FROM tmp_epis_hidrics';
        OPEN o_epis_hid FOR
            SELECT /*+ OPT_ESTIMATE (TABLE sfinal ROWS=0.001)*/
             sfinal.id_epis_hidrics,
             sfinal.flg_status_eh status_epis_hid,
             sfinal.id_hidrics_type,
             sfinal.acronym hid_type,
             sfinal.id_epis_hidrics_balance,
             sfinal.flg_status_ehb status_epis_hid_bal,
             (SELECT pk_date_utils.date_send_tsz(i_lang, sfinal.dt_initial_tstz, i_prof)
                FROM dual) dt_initial,
             (SELECT pk_date_utils.dt_chr_tsz(i_lang, sfinal.dt_initial_tstz, i_prof)
                FROM dual) date_target_ini,
             (SELECT pk_date_utils.date_char_hour_tsz(i_lang,
                                                      sfinal.dt_initial_tstz,
                                                      i_prof.institution,
                                                      i_prof.software)
                FROM dual) hour_target_ini,
             (SELECT pk_date_utils.date_send_tsz(i_lang, sfinal.dt_end_tstz, i_prof)
                FROM dual) dt_end,
             (SELECT pk_date_utils.dt_chr_tsz(i_lang, sfinal.dt_end_tstz, i_prof)
                FROM dual) date_target_end,
             (SELECT pk_date_utils.date_char_hour_tsz(i_lang, sfinal.dt_end_tstz, i_prof.institution, i_prof.software)
                FROM dual) hour_target_end,
             -- new fields                   
             (SELECT pk_date_utils.date_send_tsz(i_lang, sfinal.dt_next_balance, i_prof)
                FROM dual) dt_next_balance,
             (SELECT pk_date_utils.dt_chr_tsz(i_lang, sfinal.dt_next_balance, i_prof)
                FROM dual) dt_target_next_balance,
             sfinal.interval_minutes,
             sfinal.flg_restricted,
             (SELECT pk_sysdomain.get_domain(pk_inp_hidrics_constant.g_domain_eh_flg_restrict,
                                             sfinal.flg_restricted,
                                             i_lang)
                FROM dual) desc_flg_restricted,
             sfinal.max_intake,
             sfinal.min_output,
             decode(sfinal.flg_restricted,
                    pk_alert_constant.g_yes,
                    (SELECT pk_inp_hidrics.get_intake_output_text(i_lang,
                                                                  i_prof,
                                                                  l_msg_max_intake,
                                                                  sfinal.max_intake,
                                                                  l_unit_measure_desc)
                       FROM dual),
                    '') desc_max_intake,
             decode(sfinal.flg_restricted,
                    pk_alert_constant.g_yes,
                    (SELECT pk_inp_hidrics.get_intake_output_text(i_lang,
                                                                  i_prof,
                                                                  l_msg_min_output,
                                                                  sfinal.min_output,
                                                                  l_unit_measure_desc)
                       FROM dual),
                    '') desc_min_output,
             (SELECT check_fluid_restrictions(i_lang,
                                              i_prof,
                                              sfinal.id_epis_hidrics,
                                              sfinal.max_intake,
                                              sfinal.min_output,
                                              NULL,
                                              sfinal.total_admin,
                                              sfinal.total_elim,
                                              sfinal.dt_open_tstz,
                                              sfinal.dt_close_balance_tstz)
                FROM dual) flg_restrict_warning,
             
             get_desc_hidric_type(i_lang,
                                  i_prof,
                                  nvl(i_id_epis_type, sfinal.id_epis_type),
                                  sfinal.id_epis_type,
                                  sfinal.id_epis_hidrics,
                                  sfinal.flg_ti_type,
                                  sfinal.code_hidrics_type) desc_hid_type,
             -- END
             (SELECT get_hidric_interval(i_lang,
                                         sfinal.interval_minutes,
                                         l_msg_hour,
                                         l_msg_hours,
                                         l_msg_minute,
                                         l_msg_minutes,
                                         sfinal.code_hidrics_interval)
                FROM dual) desc_hid_inter,
             sfinal.id_hidrics_interval,
             sfinal.flg_type interv_val_type,
             (SELECT get_ult_result(sfinal.flg_status_eh, l_msg_hidrics_m002, l_msg_hidrics_m003)
                FROM dual) ult_result,
             decode(sfinal.flg_status_ehb,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_inp_hidrics_constant.g_epis_hidric_i) flg_text,
             decode(sfinal.acronym,
                    pk_inp_hidrics_constant.g_hid_type_h,
                    l_msg_hidrics_t019,
                    pk_inp_hidrics_constant.g_hid_type_d,
                    l_msg_hidrics_t026,
                    l_msg_hidrics_t038) title_viewer,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    l_msg_hidrics_t031,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    l_msg_hidrics_t031,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    l_msg_hidrics_t031,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    l_msg_hidrics_t031,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    l_msg_hidrics_t031,
                    l_msg_hidrics_t031) title_tot_admin,
             get_total_from_auto_bal(i_lang,
                                     i_prof,
                                     sfinal.id_epis_hidrics,
                                     pk_inp_hidrics_constant.g_hidrics_flg_type_a) total_admin, ---viewer
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    l_msg_hidrics_t032,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    l_msg_hidrics_t032,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    l_msg_hidrics_t032,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    l_msg_hidrics_t032,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    l_msg_hidrics_t032,
                    l_msg_hidrics_t032) title_tot_elim,
             get_total_from_auto_bal(i_lang,
                                     i_prof,
                                     sfinal.id_epis_hidrics,
                                     pk_inp_hidrics_constant.g_hidrics_flg_type_e) total_elim,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    l_msg_hidrics_t033,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    l_msg_hidrics_t034,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    l_msg_hidrics_t034,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    l_msg_hidrics_t033,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    l_msg_hidrics_t034,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    l_msg_hidrics_t034) title_tot_result,
             get_tt_result_from_auto_bal(i_lang, i_prof, sfinal.flg_status_eh, sfinal.id_epis_hidrics) total_result, ---grelha
             decode(sfinal.acronym,
                    pk_inp_hidrics_constant.g_hid_type_d,
                    decode(sfinal.flg_status_eh,
                           pk_inp_hidrics_constant.g_epis_hidric_r,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_f,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_i,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_e,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_o,
                           l_msg_hidrics_t034,
                           l_msg_hidrics_t034),
                    pk_inp_hidrics_constant.g_hid_type_r,
                    decode(sfinal.flg_status_eh,
                           pk_inp_hidrics_constant.g_epis_hidric_r,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_f,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_i,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_e,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_o,
                           l_msg_hidrics_t034,
                           l_msg_hidrics_t034),
                    pk_inp_hidrics_constant.g_hid_type_all,
                    decode(sfinal.flg_status_eh,
                           pk_inp_hidrics_constant.g_epis_hidric_r,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_f,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_i,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_e,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_o,
                           l_msg_hidrics_t034,
                           l_msg_hidrics_t034)) title_diurese,
             l_unit_measure_desc desc_unit_measure,
             decode(sfinal.notes,
                    NULL,
                    decode(sfinal.notes_cancel,
                           NULL,
                           decode(sfinal.notes_inter,
                                  NULL,
                                  -- José rito 25-03-2008 WO10422: show "With notes" if execution notes exists
                                  decode((SELECT COUNT(e.notes)
                                           FROM epis_hidrics_det e
                                          WHERE e.id_epis_hidrics = sfinal.id_epis_hidrics),
                                         0,
                                         NULL,
                                         l_msg_common_m008),
                                  --
                                  l_msg_common_m008),
                           l_msg_common_m008),
                    l_msg_common_m008) title_notes,
             sfinal.notes desc_notes,
             (SELECT pk_date_utils.date_send_tsz(i_lang, sfinal.dt_begin_tstz, i_prof)
                FROM dual) dt_epis_begin,
             (SELECT pk_date_utils.date_send_tsz(i_lang,
                                                 (SELECT MAX(ehd.dt_execution_tstz)
                                                    FROM epis_hidrics_det ehd
                                                   WHERE ehd.id_epis_hidrics = sfinal.id_epis_hidrics),
                                                 i_prof)
                FROM dual) dt_last_reg,
             sfinal.id_professional_eh prof_req_id,
             (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, sfinal.id_professional_pr)
                FROM dual) prof_req_nick,
             get_epis_status_string(i_lang, i_prof, sfinal.id_epis_hidrics) desc_status_n,
             (SELECT get_hidric_bal_rank(i_lang, sfinal.flg_status_ehb)
                FROM dual) epis_hid_bal_rank,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    pk_alert_constant.g_no,
                    pk_alert_constant.g_no) flg_cancel,
             -- Check if start date can be editable:
             -- -> Request is a draft, or..
             -- -> Request is in status "requested", meaning that are no intake/output records.
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    pk_alert_constant.g_no,
                    pk_alert_constant.g_yes) flg_has_records,
             (SELECT pk_date_utils.date_send_tsz(i_lang,
                                                 (SELECT MAX(ehb.dt_close_balance_tstz)
                                                    FROM epis_hidrics_balance ehb
                                                   WHERE ehb.id_epis_hidrics = sfinal.id_epis_hidrics
                                                     AND ehb.flg_close_type =
                                                         pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut),
                                                 i_prof)
                FROM dual) dt_last_balance,
             pk_inp_hidrics.has_auto_balance(i_prof, sfinal.id_epis_hidrics) flg_auto_balance,
             l_msg_total_occurs title_tot_occurs,
             decode(sfinal.acronym,
                    pk_inp_hidrics_constant.g_hid_type_i,
                    NULL,
                    pk_inp_hidrics.get_nr_occurs_by_type(i_lang,
                                                         i_prof,
                                                         sfinal.id_epis_hidrics,
                                                         sfinal.id_epis_hidrics_balance,
                                                         sfinal.id_episode)) list_total_times,
             get_hidric_last_result(i_lang,
                                    i_prof,
                                    sfinal.flg_status_eh,
                                    sfinal.id_epis_hidrics,
                                    sfinal.total_admin,
                                    sfinal.total_elim,
                                    sfinal.dt_open_tstz,
                                    sfinal.dt_close_balance_tstz,
                                    l_msg_hidrics_m002,
                                    l_msg_hidrics_m003,
                                    l_unit_measure_desc) desc_last_result,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_alert_constant.g_yes) flg_ok_btn,
             pk_alert_constant.g_yes flg_detail_btn,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    sfinal.flg_check_extra_take,
                    pk_alert_constant.g_no) flg_actions_btn,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_alert_constant.g_no) flg_view_btn,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    sfinal.flg_check_extra_take,
                    pk_alert_constant.g_no) flg_results_create
              FROM (TABLE(o_tbl_requests)) sfinal
             WHERE sfinal.flg_status_eh <> pk_inp_hidrics_constant.g_epis_hidric_pd;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('--> ' || SQLCODE || ' - ' || SQLERRM);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_INT',
                                              o_error);
        
            pk_types.open_my_cursor(o_epis_hid);
            RETURN FALSE;
    END get_epis_hidrics_int;

    /*******************************************************************************************************************************************
    * get_epis_hidrics                Get all hidrics associated with all episodes in current episode visit
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_DRAFT              If it should return draft functions or not ('Y'- Yes; 'N'- No)
    * @param I_SEARCH                 keyword to Search for
    * @param I_START_RECORD           Paging - initial record number
    * @param I_NUM_RECORDS            Paging - number of records to display
    * @param I_FILTER                 Filter by a group (dates, hidric type, etc.)
    * @param I_COLUMN_TO_ORDER        Column to be order
    * @param I_ORDER_BY               The way to be order, ascending (ASC) or descendig (DESC)
    * @param O_EPIS_HID               Cursor that returns hidrics
    * @param o_group_totals           Cursor that returns the groups totals
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_DRAFT              {*} 'Y' YES {*} 'N' NO
    * @value I_FILTER                 1 - Hidric Type  2 - Hidric Initial Date/Time  3 - Hidric State  0|NULL - All
    * @value I_COLUMN_TO_ORDER        1 - Hidric Type  2 - Hidric Initial Date/Time  3 - Hidric State  4 - Hidric Interval Value  5 - Hidric End Date/Time  6 - Hidric Last Result  
    *                                 NULL - Balance Rank ASC and Hidric Creation Descending and ID Hidric Balance Episode Descending
    * @value I_ORDER_BY               1|NULL - Ascending Order  2 - Descending Order
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/21
    *
    * @author                         Luís Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/19
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_with_totals
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_episode         IN episode.id_episode%TYPE,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_draft       IN VARCHAR2,
        i_search          IN VARCHAR2,
        i_start_record    IN NUMBER,
        i_num_records     IN NUMBER,
        i_filter          IN NUMBER,
        i_column_to_order IN NUMBER,
        i_order_by        IN NUMBER,
        o_epis_hid        OUT pk_types.cursor_type,
        o_group_totals    OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        --
        l_visit        episode.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
        l_tbl_requests t_tbl_hidrics_request;
    BEGIN
    
        -- INPATIENT LMAIA 08-01-2009
        -- GET ID_EPISODE FROM CURRENT EPISODE
        g_error := 'GET info from Episode';
        SELECT epi.id_visit, epi.id_epis_type
          INTO l_visit, l_id_epis_type
          FROM episode epi
         WHERE epi.id_episode = i_episode;
    
        g_error := 'CALL GET_EPIS_HIDRICS_INT';
        IF NOT get_epis_hidrics_int(i_lang            => i_lang,
                                    i_prof            => i_prof,
                                    i_scope           => l_visit,
                                    i_flg_scope       => pk_alert_constant.g_scope_type_visit,
                                    i_start_date      => NULL,
                                    i_end_date        => NULL,
                                    i_cancelled       => pk_alert_constant.g_yes,
                                    i_crit_type       => pk_inp_hidrics_constant.g_hidric_crit_type_all_a,
                                    i_flg_report      => pk_alert_constant.g_no,
                                    i_epis_hidrics    => i_epis_hidrics,
                                    i_flg_draft       => i_flg_draft,
                                    i_search          => i_search,
                                    i_start_record    => i_start_record,
                                    i_num_records     => i_num_records,
                                    i_filter          => i_filter,
                                    i_column_to_order => i_column_to_order,
                                    i_order_by        => i_order_by,
                                    i_id_epis_type    => l_id_epis_type,
                                    o_epis_hid        => o_epis_hid,
                                    o_tbl_requests    => l_tbl_requests,
                                    o_error           => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        g_error := 'CALL get_groups_total';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_inp_hidrics_groups.get_groups_total(i_lang                => i_lang,
                                                      i_prof                => i_prof,
                                                      i_tbl_hidrics_request => l_tbl_requests,
                                                      o_group_totals        => o_group_totals,
                                                      o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_WITH_TOTALS',
                                              o_error);
        
            pk_types.open_my_cursor(o_epis_hid);
            pk_types.open_my_cursor(o_group_totals);
            RETURN FALSE;
    END get_epis_hidrics_with_totals;

    /*******************************************************************************************************************************************
    * get_epis_hidrics                Get all hidrics associated with all episodes in current episode visit
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_DRAFT              If it should return draft functions or not ('Y'- Yes; 'N'- No)
    * @param I_SEARCH                 keyword to Search for
    * @param I_START_RECORD           Paging - initial record number
    * @param I_NUM_RECORDS            Paging - number of records to display
    * @param I_FILTER                 Filter by a group (dates, hidric type, etc.)
    * @param I_COLUMN_TO_ORDER        Column to be order
    * @param I_ORDER_BY               The way to be order, ascending (ASC) or descendig (DESC)
    * @param O_EPIS_HID               Cursor that returns hidrics
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_DRAFT              {*} 'Y' YES {*} 'N' NO
    * @value I_FILTER                 1 - Hidric Type  2 - Hidric Initial Date/Time  3 - Hidric State  0|NULL - All
    * @value I_COLUMN_TO_ORDER        1 - Hidric Type  2 - Hidric Initial Date/Time  3 - Hidric State  4 - Hidric Interval Value  5 - Hidric End Date/Time  6 - Hidric Last Result  
    *                                 NULL - Balance Rank ASC and Hidric Creation Descending and ID Hidric Balance Episode Descending
    * @value I_ORDER_BY               1|NULL - Ascending Order  2 - Descending Order
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/21
    *
    * @author                         Luís Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/19
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_episode         IN episode.id_episode%TYPE,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_draft       IN VARCHAR2,
        i_search          IN VARCHAR2,
        i_start_record    IN NUMBER,
        i_num_records     IN NUMBER,
        i_filter          IN NUMBER,
        i_column_to_order IN NUMBER,
        i_order_by        IN NUMBER,
        o_epis_hid        OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        --
        l_visit        episode.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
        l_tbl_requests t_tbl_hidrics_request;
    BEGIN
    
        -- INPATIENT LMAIA 08-01-2009
        -- GET ID_EPISODE FROM CURRENT EPISODE
        g_error := 'GET info from Episode';
        SELECT epi.id_visit, epi.id_epis_type
          INTO l_visit, l_id_epis_type
          FROM episode epi
         WHERE epi.id_episode = i_episode;
    
        g_error := 'CALL GET_EPIS_HIDRICS_INT';
        IF NOT get_epis_hidrics_int(i_lang            => i_lang,
                                    i_prof            => i_prof,
                                    i_scope           => l_visit,
                                    i_flg_scope       => pk_alert_constant.g_scope_type_visit,
                                    i_start_date      => NULL,
                                    i_end_date        => NULL,
                                    i_cancelled       => pk_alert_constant.g_yes,
                                    i_crit_type       => pk_inp_hidrics_constant.g_hidric_crit_type_all_a,
                                    i_flg_report      => pk_alert_constant.g_no,
                                    i_epis_hidrics    => i_epis_hidrics,
                                    i_flg_draft       => i_flg_draft,
                                    i_search          => i_search,
                                    i_start_record    => i_start_record,
                                    i_num_records     => i_num_records,
                                    i_filter          => i_filter,
                                    i_column_to_order => i_column_to_order,
                                    i_order_by        => i_order_by,
                                    i_id_epis_type    => l_id_epis_type,
                                    o_epis_hid        => o_epis_hid,
                                    o_tbl_requests    => l_tbl_requests,
                                    o_error           => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS',
                                              o_error);
        
            pk_types.open_my_cursor(o_epis_hid);
            RETURN FALSE;
    END get_epis_hidrics;

    /*******************************************************************************************************************************************
    * get_epis_hidrics                Get all hidrics associated with all episodes in current episode visit
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_SEARCH                 keyword to Search for
    * @param I_START_RECORD           Paging - initial record number
    * @param I_NUM_RECORDS            Paging - number of records to display
    * @param I_FILTER                 Filter by a group (dates, hidric type, etc.)
    * @param I_COLUMN_TO_ORDER        Column to be order
    * @param I_ORDER_BY               The way to be order, ascending (ASC) or descendig (DESC)
    * @param O_EPIS_HID               Cursor that returns hidrics
    * @param o_group_totals           Cursor that returns the groups totals
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FILTER                 1 - Hidric Type  2 - Hidric Initial Date/Time  3 - Hidric State  0|NULL - All
    * @value I_COLUMN_TO_ORDER        1 - Hidric Type  2 - Hidric Initial Date/Time  3 - Hidric State  4 - Hidric Interval Value  5 - Hidric End Date/Time  6 - Hidric Last Result  
    *                                 NULL - Balance Rank ASC and Hidric Creation Descending and ID Hidric Balance Episode Descending
    * @value I_ORDER_BY               1|NULL - Ascending Order  2 - Descending Order
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/21
    *
    * @author                         Luís Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/19
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_episode         IN episode.id_episode%TYPE,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_search          IN VARCHAR2,
        i_start_record    IN NUMBER,
        i_num_records     IN NUMBER,
        i_filter          IN NUMBER,
        i_column_to_order IN NUMBER,
        i_order_by        IN NUMBER,
        o_epis_hid        OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN get_epis_hidrics(i_lang            => i_lang,
                                i_prof            => i_prof,
                                i_episode         => i_episode,
                                i_epis_hidrics    => i_epis_hidrics,
                                i_flg_draft       => pk_alert_constant.g_no,
                                i_search          => i_search,
                                i_start_record    => i_start_record,
                                i_num_records     => i_num_records,
                                i_filter          => i_filter,
                                i_column_to_order => i_column_to_order,
                                i_order_by        => i_order_by,
                                o_epis_hid        => o_epis_hid,
                                o_error           => o_error);
    END get_epis_hidrics;

    /*******************************************************************************************************************************************
    * Get all hidrics associated with all episodes in current episode visit
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_SCOPE                  Scope ID (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_FLG_SCOPE              Scope type
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled
    * @param I_CRIT_TYPE              Flag that indicates if the filter time to consider all records or only during the executions
    * @param I_FLG_REPORT             Flag used to remove formatting
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_DRAFT              If it should return draft functions or not
    * @param I_SEARCH                 keyword to Search for
    * @param I_START_RECORD           Paging - initial record number
    * @param I_NUM_RECORDS            Paging - number of records to display
    * @param I_FILTER                 Filter by a group (dates, hidric type, etc.)
    * @param I_COLUMN_TO_ORDER        Column to be order
    * @param I_ORDER_BY               The way to be order, ascending (ASC) or descendig (DESC)
    * @param I_ID_EPIS_TYPE           Episode Type identifier
    * @param O_EPIS_HID               Cursor that returns hidrics
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    *
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_SCOPE              {*} 'E' Episode {*} 'V' Visit {*} 'P' Patient
    * @value I_CANCELLED              {*} 'Y' Yes {*} 'N' No
    * @value I_CRIT_TYPE              {*} 'A' All {*} 'E' Execution
    * @value I_FLG_REPORT             {*} 'Y' Yes {*} 'N' No
    * @value I_FLG_DRAFT              {*} 'Y' YES {*} 'N' NO
    * @value I_FILTER                 {*} '1' Hidric Type {*} '2' Hidric Initial Date/Time {*} '3' Hidric State {*} '0' All {*} 'NULL' All
    * @value I_COLUMN_TO_ORDER        {*} '1' Hidric Type {*} '2' Hidric Initial Date/Time {*} '3' Hidric State {*} '4' Hidric Interval Value {*} '5' Hidric End Date/Time {*} '6' Hidric Last Result {*} 'NULL' Balance Rank ASC and Hidric Creation Descending and ID Hidric Balance Episode Descending
    * @value I_ORDER_BY               {*} '1' Ascending Order {*} 'NULL' Ascending Order {*} '2' Descending Order
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/21
    *
    * @author                         Luís Maia
    * @version                        2.5.0.7.3
    * @since                          2009/11/19
    *
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          10-Nov-2011
    *
    * @dependencies                   REPORTS
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_rep
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_scope           IN NUMBER,
        i_flg_scope       IN VARCHAR2,
        i_start_date      IN VARCHAR2,
        i_end_date        IN VARCHAR2,
        i_cancelled       IN VARCHAR2,
        i_crit_type       IN VARCHAR2,
        i_flg_report      IN VARCHAR2,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_draft       IN VARCHAR2,
        i_search          IN VARCHAR2,
        i_filter          IN NUMBER,
        i_column_to_order IN NUMBER,
        i_order_by        IN NUMBER,
        o_epis_hid        OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_tbl_requests t_tbl_hidrics_request;
    BEGIN
        g_error := 'CALL GET_EPIS_HIDRICS_INT';
        IF NOT get_epis_hidrics_int(i_lang            => i_lang,
                                    i_prof            => i_prof,
                                    i_scope           => i_scope,
                                    i_flg_scope       => i_flg_scope,
                                    i_start_date      => i_start_date,
                                    i_end_date        => i_end_date,
                                    i_cancelled       => i_cancelled,
                                    i_crit_type       => i_crit_type,
                                    i_flg_report      => i_flg_report,
                                    i_epis_hidrics    => i_epis_hidrics,
                                    i_flg_draft       => i_flg_draft,
                                    i_search          => i_search,
                                    i_start_record    => 0,
                                    i_num_records     => NULL,
                                    i_filter          => i_filter,
                                    i_column_to_order => i_column_to_order,
                                    i_order_by        => i_order_by,
                                    i_id_epis_type    => NULL,
                                    o_epis_hid        => o_epis_hid,
                                    o_tbl_requests    => l_tbl_requests,
                                    o_error           => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_REP',
                                              o_error);
        
            pk_types.open_my_cursor(o_epis_hid);
            RETURN FALSE;
    END get_epis_hidrics_rep;

    /*******************************************************************************************************************************************
    * Get number of all hidrics associated with all episodes in current episode visit
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_SCOPE                  Scope ID (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_FLG_SCOPE              Scope type
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled
    * @param I_CRIT_TYPE              Flag that indicates if the filter time to consider all records or only during the executions
    * @param I_FLG_REPORT             Flag used to remove formatting
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_DRAFT              If it should return draft functions or not ('Y'- Yes; 'N'- No)
    * @param I_SEARCH                 keyword to Search for
    * @param I_FILTER                 Filter by a group (dates, hidric type, etc.)
    * @param I_ID_EPIS_TYPE           Episode Type identifier
    * @param O_NUM_EPIS_HIDRICS       Returns the number of records for the search criteria
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_SCOPE              {*} 'E' Episode {*} 'V' Visit {*} 'P' Patient
    * @value I_CANCELLED              {*} 'Y' Yes {*} 'N' No
    * @value I_CRIT_TYPE              {*} 'A' All {*} 'E' Execution
    * @value I_FLG_REPORT             {*} 'Y' Yes {*} 'N' No
    * @value I_FLG_DRAFT              {*} 'Y' YES {*} 'N' NO
    * @value I_FILTER                 {*} '1' Hidric Type {*} '2' Hidric Initial Date/Time {*} '3' Hidric State {*} '0' All {*} 'NULL' All
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    *
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          10-Nov-2011
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_count_int
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_scope            IN NUMBER,
        i_flg_scope        IN VARCHAR2,
        i_start_date       IN VARCHAR2,
        i_end_date         IN VARCHAR2,
        i_cancelled        IN VARCHAR2,
        i_crit_type        IN VARCHAR2,
        i_flg_report       IN VARCHAR2,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_draft        IN VARCHAR2,
        i_search           IN VARCHAR2,
        i_filter           IN NUMBER,
        i_id_epis_type     IN episode.id_epis_type%TYPE,
        o_num_epis_hidrics OUT NUMBER,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_search VARCHAR2(4000 CHAR) := NULL;
        --
    
        l_filter     PLS_INTEGER := pk_inp_hidrics_constant.g_filter_type_all;
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient patient.id_patient%TYPE;
    
        e_invalid_argument EXCEPTION;
    
        l_start_date TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_end_date   TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
    BEGIN
        g_error := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE e_invalid_argument;
        END IF;
    
        --convert string to date format
        IF i_start_date IS NOT NULL
        THEN
            l_start_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_date, NULL);
        END IF;
        IF i_end_date IS NOT NULL
        THEN
            l_end_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_date, NULL);
        END IF;
    
        IF i_filter IS NOT NULL
        THEN
            l_filter := i_filter;
        END IF;
    
        IF i_search IS NOT NULL
        THEN
            l_search := pk_utils.remove_upper_accentuation(i_search);
        END IF;
    
        g_error := 'count number oh hidrics records';
        SELECT COUNT(1)
          INTO o_num_epis_hidrics
          FROM epis_hidrics eh
         INNER JOIN episode epi
            ON (eh.id_episode = epi.id_episode AND eh.id_patient = epi.id_patient)
         INNER JOIN epis_hidrics_balance ehb
            ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
         INNER JOIN hidrics_type ht
            ON (eh.id_hidrics_type = ht.id_hidrics_type)
         INNER JOIN hidrics_interval hi
            ON (eh.id_hidrics_interval = hi.id_hidrics_interval)
         INNER JOIN professional prof_req
            ON (eh.id_professional = prof_req.id_professional)
          LEFT JOIN unit_measure um
            ON (ehb.id_unit_measure = um.id_unit_measure)
        
        --*****************************************************************************************
        --** WHEN CHANGING THE WHERE CLAUSE OR ANY CODE INSIDE THE FROM AND INNER JOIN STATEMENT **
        --** PLEASE REPRODUCE ANY CHANGES IN THE SAME CODE ON FUNCTION GET_EPIS_HIDRICS          **
        --*****************************************************************************************
        
        --
        --*****************************************************************************************
        --** WHEN CHANGING THE WHERE CLAUSE OR ANY CODE INSIDE THE FROM AND INNER JOIN STATEMENT **
        --** PLEASE REPRODUCE ANY CHANGES IN THE SAME CODE ON FUNCTION GET_EPIS_HIDRICS_COUNT    **
        --*****************************************************************************************
        
        --            
         WHERE eh.id_patient = l_id_patient
           AND epi.id_episode = nvl(l_id_episode, epi.id_episode)
           AND epi.id_visit = nvl(l_id_visit, epi.id_visit)
           AND (SELECT get_most_recent_ehb_id(eh.id_epis_hidrics)
                  FROM dual) = ehb.id_epis_hidrics_balance
           AND
              --
               (
               --Nothing defined for hidric search
                l_search IS NULL OR
               
               --Search for Hidric Type
                (CASE l_filter
                    WHEN pk_inp_hidrics_constant.g_filter_type_1 THEN
                     pk_utils.remove_upper_accentuation(get_desc_hidric_type(i_lang,
                                                                             i_prof,
                                                                             nvl(i_id_epis_type, epi.id_epis_type),
                                                                             epi.id_epis_type,
                                                                             eh.id_epis_hidrics,
                                                                             ht.flg_ti_type,
                                                                             ht.code_hidrics_type))
                    WHEN pk_inp_hidrics_constant.g_filter_type_2 THEN
                     pk_utils.remove_upper_accentuation(pk_date_utils.dt_chr_tsz(i_lang, eh.dt_initial_tstz, i_prof))
                    WHEN pk_inp_hidrics_constant.g_filter_type_3 THEN
                     pk_utils.remove_upper_accentuation(get_hidric_status(i_lang, eh.flg_status))
                    WHEN pk_inp_hidrics_constant.g_filter_type_all THEN
                     nvl(pk_utils.remove_upper_accentuation(get_desc_hidric_type(i_lang,
                                                                                 i_prof,
                                                                                 nvl(i_id_epis_type, epi.id_epis_type),
                                                                                 epi.id_epis_type,
                                                                                 eh.id_epis_hidrics,
                                                                                 ht.flg_ti_type,
                                                                                 ht.code_hidrics_type)),
                         '') || ' ' ||
                    --
                     nvl(pk_utils.remove_upper_accentuation(get_desc_hidric_type(i_lang,
                                                                                 i_prof,
                                                                                 nvl(i_id_epis_type, epi.id_epis_type),
                                                                                 epi.id_epis_type,
                                                                                 eh.id_epis_hidrics,
                                                                                 ht.flg_ti_type,
                                                                                 ht.code_hidrics_type)),
                         '') || ' ' ||
                    --
                     nvl(pk_utils.remove_upper_accentuation(pk_date_utils.dt_chr_tsz(i_lang, eh.dt_initial_tstz, i_prof)),
                         '') || ' ' ||
                    --
                     nvl(pk_utils.remove_upper_accentuation(get_hidric_status(i_lang, eh.flg_status)), '')
                
                END LIKE '%' || l_search || '%'
                --
                )
               --
               )
              --
           AND (eh.id_epis_hidrics = i_epis_hidrics OR i_epis_hidrics IS NULL)
              --
           AND ((eh.flg_status NOT IN
               (pk_inp_hidrics_constant.g_flg_task_status_d, pk_inp_hidrics_constant.g_epis_hidric_l) AND
               i_flg_draft = pk_alert_constant.g_no) OR
               (i_flg_draft = pk_alert_constant.g_yes AND
               eh.flg_status NOT IN (pk_inp_hidrics_constant.g_epis_hidric_l)))
              --
           AND (
               --not report gets all
                i_flg_report = pk_alert_constant.g_no OR
               --
                (
                --if report
                 i_flg_report = pk_alert_constant.g_yes
                --
                 AND
                --
                 (
                 --shows canceled hidrics or not whether flag i_cancelled
                  (i_cancelled = pk_alert_constant.g_no AND eh.flg_status <> pk_inp_hidrics_constant.g_epis_hidric_c) OR
                  i_cancelled = pk_alert_constant.g_yes
                 --
                 )
                --
                 AND
                --
                 (
                 --shows hidrics or not whether flag i_crit_type and the dates (i_start_date and i_end_date)
                 --Shows all the hidrics where the req, exec, balance was performed in the period
                  (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_all_a AND
                  (eh.dt_initial_tstz BETWEEN nvl(l_start_date, eh.dt_initial_tstz) AND
                  nvl(l_end_date, eh.dt_initial_tstz)
                  --
                  OR (SELECT check_has_balance(eh.id_epis_hidrics, l_start_date, l_end_date, i_cancelled, i_flg_report)
                          FROM dual) = pk_alert_constant.g_yes
                  --
                  OR (SELECT check_has_executions(eh.id_epis_hidrics, l_start_date, l_end_date, i_cancelled, i_flg_report)
                          FROM dual) = pk_alert_constant.g_yes)
                  --
                  )
                 --
                  OR
                 --Shows the hidrics that where req in the period
                  (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_req_r AND
                  eh.dt_initial_tstz BETWEEN nvl(l_start_date, eh.dt_initial_tstz) AND
                  nvl(l_end_date, eh.dt_initial_tstz))
                 --
                  OR
                 --Shows the hidrics that where exec in the period
                  (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_exec_e AND
                  (SELECT check_has_executions(eh.id_epis_hidrics, l_start_date, l_end_date, i_cancelled, i_flg_report)
                      FROM dual) = pk_alert_constant.g_yes)
                 --
                  OR
                 --Shows the hidrics that where balance in the period
                  (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_bal_b AND
                  (SELECT check_has_balance(eh.id_epis_hidrics, l_start_date, l_end_date, i_cancelled, i_flg_report)
                      FROM dual) = pk_alert_constant.g_yes)
                 --
                 )
                --
                )
               --
               );
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_COUNT_INT',
                                              o_error);
        
            o_num_epis_hidrics := 0;
            RETURN FALSE;
    END get_epis_hidrics_count_int;

    /*******************************************************************************************************************************************
    * get_epis_hidrics_count          Get number of all hidrics associated with all episodes in current episode visit
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_DRAFT              If it should return draft functions or not ('Y'- Yes; 'N'- No)
    * @param I_SEARCH                 keyword to Search for
    * @param I_FILTER                 Filter by a group (dates, hidric type, etc.)
    * @param O_NUM_EPIS_HIDRICS       Returns the number of records for the search criteria
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_DRAFT              {*} 'Y' YES {*} 'N' NO
    * @value I_FILTER                 1 - Hidric Type  2 - Hidric Initial Date/Time  3 - Hidric State  0|NULL - All
    * 
    * @return                        Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         António Neto
    * @version                        2.6.0.5
    * @since                          16-Dec-2010
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_count
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_draft        IN VARCHAR2,
        i_search           IN VARCHAR2,
        i_filter           IN NUMBER,
        o_num_epis_hidrics OUT NUMBER,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_visit        episode.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
    BEGIN
    
        -- INPATIENT LMAIA 08-01-2009
        -- GET ID_EPISODE FROM CURRENT EPISODE
        g_error := 'GET info from Episode';
        SELECT epi.id_visit, epi.id_epis_type
          INTO l_visit, l_id_epis_type
          FROM episode epi
         WHERE epi.id_episode = i_episode;
    
        g_error := 'CALL GET_EPIS_HIDRICS_COUNT_INT';
        IF NOT get_epis_hidrics_count_int(i_lang             => i_lang,
                                          i_prof             => i_prof,
                                          i_scope            => l_visit,
                                          i_flg_scope        => pk_alert_constant.g_scope_type_visit,
                                          i_start_date       => NULL,
                                          i_end_date         => NULL,
                                          i_cancelled        => pk_alert_constant.g_yes,
                                          i_crit_type        => pk_inp_hidrics_constant.g_hidric_crit_type_all_a,
                                          i_flg_report       => pk_alert_constant.g_no,
                                          i_epis_hidrics     => i_epis_hidrics,
                                          i_flg_draft        => i_flg_draft,
                                          i_search           => i_search,
                                          i_filter           => i_filter,
                                          i_id_epis_type     => l_id_epis_type,
                                          o_num_epis_hidrics => o_num_epis_hidrics,
                                          o_error            => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_COUNT',
                                              o_error);
        
            o_num_epis_hidrics := 0;
            RETURN FALSE;
    END get_epis_hidrics_count;

    /*******************************************************************************************************************************************
    * get_epis_hidrics_count          Get number of all hidrics associated with all episodes in current episode visit
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_SEARCH                 keyword to Search for
    * @param I_FILTER                 Filter by a group (dates, hidric type, etc.)
    * @param O_NUM_EPIS_HIDRICS       Returns the number of records for the search criteria
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FILTER                 1 - Hidric Type  2 - Hidric Initial Date/Time  3 - Hidric State  0|NULL - All
    * 
    * @return                        Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         António Neto
    * @version                        2.6.0.5
    * @since                          16-Dec-2010
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_count
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_search           IN VARCHAR2,
        i_filter           IN NUMBER,
        o_num_epis_hidrics OUT NUMBER,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        RETURN get_epis_hidrics_count(i_lang             => i_lang,
                                      i_prof             => i_prof,
                                      i_episode          => i_episode,
                                      i_epis_hidrics     => i_epis_hidrics,
                                      i_flg_draft        => pk_alert_constant.g_no,
                                      i_search           => i_search,
                                      i_filter           => i_filter,
                                      o_num_epis_hidrics => o_num_epis_hidrics,
                                      o_error            => o_error);
    END get_epis_hidrics_count;

    /*******************************************************************************************************************************************
    * create_epis_hidrics_det         Get hidric detail information (AFTER 2.6.0.3 IT SHOULD ONLY BE USED IN REPORTS)
    *                                 To be removed when the new reports to the HIDRICS is created
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           ID_EPIS_HIDRICS identifier
    * @param I_EPISODE                ID_EPISODE identifier
    * @param O_EPIS_HID               Cursor that returns hidrics  
    * @param O_EPIS_HID_D             Cursor that returns hidrics detail
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Emilia Taborda
    * @version                        0.1
    * @since                          2006/11/21
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_reports
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        o_epis_hid     OUT pk_types.cursor_type,
        o_epis_hid_d   OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_visit     visit.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
    
    BEGIN
        g_error := 'Get Visit Identifier';
        SELECT e.id_visit, e.id_epis_type
          INTO l_id_visit, l_id_epis_type
          FROM episode e
         WHERE e.id_episode = i_episode;
    
        g_error := 'CALL GET_EPIS_HIDRICS_DET_REP';
        IF NOT get_epis_hidrics_det_rep(i_lang         => i_lang,
                                        i_prof         => i_prof,
                                        i_scope        => l_id_visit,
                                        i_flg_scope    => pk_alert_constant.g_scope_type_visit,
                                        i_start_date   => NULL,
                                        i_end_date     => NULL,
                                        i_cancelled    => pk_alert_constant.g_yes,
                                        i_crit_type    => pk_inp_hidrics_constant.g_hidric_crit_type_all_a,
                                        i_flg_report   => pk_alert_constant.g_no,
                                        i_epis_hidrics => i_epis_hidrics,
                                        i_id_epis_type => l_id_epis_type,
                                        o_epis_hid     => o_epis_hid,
                                        o_epis_hid_d   => o_epis_hid_d,
                                        o_error        => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_REPORTS',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid);
            pk_types.open_my_cursor(o_epis_hid_d);
            RETURN FALSE;
    END get_epis_hidrics_reports;

    /*******************************************************************************************************************************************
    * Get hidric detail information with timeframe ans scope
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_SCOPE                  Scope ID (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_FLG_SCOPE              Scope type
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled
    * @param I_CRIT_TYPE              Flag that indicates if the filter time to consider all records or only during the executions
    * @param I_FLG_REPORT             Flag used to remove formatting
    * @param I_EPIS_HIDRICS           Hidrics Episode identifier
    * @param I_ID_EPIS_TYPE           Episode Type identifier
    * @param O_EPIS_HID               Cursor that returns hidrics
    * @param O_EPIS_HID_D             Cursor that returns hidrics detail
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value I_FLG_SCOPE              {*} 'E' Episode {*} 'V' Visit {*} 'P' Patient
    * @value I_CANCELLED              {*} 'Y' Yes {*} 'N' No
    * @value I_CRIT_TYPE              {*} 'A' All {*} 'E' Execution
    * @value I_FLG_REPORT             {*} 'Y' Yes {*} 'N' No
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          11-Nov-2011
    *
    * @dependencies                   REPORTS
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_det_rep
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_scope        IN NUMBER,
        i_flg_scope    IN VARCHAR2,
        i_start_date   IN VARCHAR2,
        i_end_date     IN VARCHAR2,
        i_cancelled    IN VARCHAR2,
        i_crit_type    IN VARCHAR2,
        i_flg_report   IN VARCHAR2,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_id_epis_type IN episode.id_epis_type%TYPE,
        o_epis_hid     OUT pk_types.cursor_type,
        o_epis_hid_d   OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient patient.id_patient%TYPE;
    
        e_invalid_argument EXCEPTION;
    
        l_start_date TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_end_date   TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        --
    
        l_unit_meas_desc pk_translation.t_desc_translation;
    
        --
        l_has_balance    VARCHAR2(1 CHAR);
        l_has_executions VARCHAR2(1 CHAR);
    
    BEGIN
        g_error := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE e_invalid_argument;
        END IF;
    
        --convert string to date format
        IF i_start_date IS NOT NULL
        THEN
            l_start_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_date, NULL);
        END IF;
        IF i_end_date IS NOT NULL
        THEN
            l_end_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_date, NULL);
        END IF;
    
        l_unit_meas_desc := pk_translation.get_translation(i_lang      => i_lang,
                                                           i_code_mess => 'UNIT_MEASURE.CODE_UNIT_MEASURE.' ||
                                                                          pk_sysconfig.get_config(i_code_cf => 'HIDRICS_UNIT_MEAS',
                                                                                                  i_prof    => i_prof));
    
        g_error          := 'CHECK BALANCES';
        l_has_balance    := check_has_balance(i_id_epis_hidrics => i_epis_hidrics,
                                              i_start_date      => l_start_date,
                                              i_end_date        => l_end_date,
                                              i_cancelled       => i_cancelled,
                                              i_flg_report      => i_flg_report);
        g_error          := 'CHECK EXECUTIONS';
        l_has_executions := check_has_executions(i_id_epis_hidrics => i_epis_hidrics,
                                                 i_start_date      => l_start_date,
                                                 i_end_date        => l_end_date,
                                                 i_cancelled       => i_cancelled,
                                                 i_flg_report      => i_flg_report);
    
        g_error := 'GET CURSOR O_EPIS_HID';
        OPEN o_epis_hid FOR
            SELECT t.*,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_o, t.notes_epis_hid_canc) notes_epis_hid_exp_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_c, t.notes_epis_hid_canc) notes_epis_hid_canc_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_c, t.name_prof_cancel) name_prof_canc_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_c, t.prof_cancel_speciality) prof_canc_speciality_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_c, t.date_target_cancel) date_target_canc_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_c, t.hour_target_cancel) hour_target_canc_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_c, t.dt_target_cancel) dt_target_canc_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_o, t.name_prof_cancel) name_prof_exp_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_o, t.prof_cancel_speciality) prof_exp_speciality_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_o, t.date_target_cancel) date_target_exp_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_o, t.hour_target_cancel) hour_target_exp_rep,
                   decode(t.status_epis_hid, pk_inp_hidrics_constant.g_epis_hidric_o, t.dt_target_cancel) dt_target_exp_rep
              FROM (SELECT eh.id_epis_hidrics,
                           eh.flg_status status_epis_hid,
                           decode(nvl(i_id_epis_type, epi.id_epis_type),
                                  nvl(t_ti_log.get_epis_type(i_lang,
                                                             i_prof,
                                                             epi.id_epis_type,
                                                             pk_inp_hidrics_constant.g_epis_hidric_r,
                                                             eh.id_epis_hidrics,
                                                             ht.flg_ti_type),
                                      epi.id_epis_type),
                                  pk_translation.get_translation(i_lang, ht.code_hidrics_type),
                                  pk_translation.get_translation(i_lang, ht.code_hidrics_type) || ' (' ||
                                  pk_message.get_message(i_lang,
                                                         profissional(i_prof.id,
                                                                      i_prof.institution,
                                                                      t_ti_log.get_epis_type_soft(i_lang,
                                                                                                  i_prof,
                                                                                                  epi.id_epis_type,
                                                                                                  pk_inp_hidrics_constant.g_epis_hidric_r,
                                                                                                  eh.id_epis_hidrics,
                                                                                                  ht.flg_ti_type)),
                                                         'IMAGE_T009') || ')') desc_hid_type,
                           --
                           pk_translation.get_translation(i_lang, hi.code_hidrics_interval) desc_hid_inter,
                           pk_date_utils.date_char_tsz(i_lang, eh.dt_initial_tstz, i_prof.institution, i_prof.software) dt_target_ini,
                           pk_date_utils.date_char_tsz(i_lang, eh.dt_end_tstz, i_prof.institution, i_prof.software) dt_target_end,
                           pk_date_utils.date_char_tsz(i_lang, eh.dt_cancel_tstz, i_prof.institution, i_prof.software) dt_target_cancel,
                           pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) name_prof,
                           pk_prof_utils.get_spec_sign_by_visit(i_lang,
                                                                i_prof,
                                                                p.id_professional,
                                                                eh.dt_creation_tstz,
                                                                epi.id_visit) prof_speciality,
                           pk_date_utils.date_char_tsz(i_lang, eh.dt_creation_tstz, i_prof.institution, i_prof.software) dt_target_creat,
                           eh.dt_creation_tstz,
                           pk_prof_utils.get_name_signature(i_lang, i_prof, pc.id_professional) name_prof_cancel,
                           pk_prof_utils.get_name_signature(i_lang, i_prof, pi.id_professional) name_prof_inter,
                           pk_prof_utils.get_spec_signature(i_lang,
                                                            i_prof,
                                                            pi.id_professional,
                                                            eh.dt_cancel_tstz,
                                                            epi.id_episode) prof_inter_speciality,
                           pk_date_utils.dt_chr_tsz(i_lang, eh.dt_inter_tstz, i_prof) date_target_inter,
                           eh.dt_inter_tstz,
                           pk_date_utils.date_char_tsz(i_lang, eh.dt_inter_tstz, i_prof.institution, i_prof.software) dt_target_inter,
                           eh.notes notes_epis_hid,
                           eh.notes_cancel notes_epis_hid_canc,
                           eh.notes_inter notes_epis_hid_int,
                           pk_sysdomain.get_domain('EPIS_HIDRICS.FLG_RESTRICTED', eh.flg_restricted, i_lang) desc_restriction,
                           decode(eh.max_intake, NULL, NULL, eh.max_intake || ' ' || l_unit_meas_desc) max_intake,
                           decode(eh.min_output, NULL, NULL, eh.min_output || ' ' || l_unit_meas_desc) min_output,
                           
                           pk_sysdomain.get_domain('EPIS_HIDRICS.FLG_STATUS', eh.flg_status, i_lang) title_hidrics_status_rep,
                           pk_prof_utils.get_spec_signature(i_lang,
                                                            i_prof,
                                                            pc.id_professional,
                                                            eh.dt_cancel_tstz,
                                                            epi.id_episode) prof_cancel_speciality,
                           pk_date_utils.date_char_hour_tsz(i_lang,
                                                            eh.dt_cancel_tstz,
                                                            i_prof.institution,
                                                            i_prof.software) hour_target_cancel,
                           pk_date_utils.dt_chr_tsz(i_lang, eh.dt_cancel_tstz, i_prof) date_target_cancel
                    
                      FROM epis_hidrics eh
                     INNER JOIN episode epi
                        ON (eh.id_episode = epi.id_episode)
                     INNER JOIN hidrics_type ht
                        ON (eh.id_hidrics_type = ht.id_hidrics_type)
                     INNER JOIN hidrics_interval hi
                        ON (eh.id_hidrics_interval = hi.id_hidrics_interval)
                      LEFT JOIN professional p
                        ON (p.id_professional = eh.id_professional)
                      LEFT JOIN professional pc
                        ON (pc.id_professional = eh.id_prof_cancel)
                      LEFT JOIN professional pi
                        ON (pi.id_professional = eh.id_prof_inter)
                     WHERE epi.id_episode = nvl(l_id_episode, epi.id_episode)
                       AND epi.id_visit = nvl(l_id_visit, epi.id_visit)
                       AND epi.id_patient = l_id_patient
                       AND eh.id_epis_hidrics = i_epis_hidrics
                          --
                       AND (
                           --not report gets all
                            i_flg_report = pk_alert_constant.g_no OR
                           --
                            (
                            --if report
                             i_flg_report = pk_alert_constant.g_yes
                            --
                             AND
                            --
                             (
                             --shows canceled hidrics or not whether flag i_cancelled
                              (i_cancelled = pk_alert_constant.g_no AND
                              eh.flg_status <> pk_inp_hidrics_constant.g_epis_hidric_c) OR
                              i_cancelled = pk_alert_constant.g_yes
                             --
                             )
                            --
                             AND
                            --
                             (
                             --shows hidrics or not whether flag i_crit_type and the dates (i_start_date and i_end_date)
                             --Shows all the hidrics where the req, exec, balance was performed in the period
                              (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_all_a AND
                              (eh.dt_initial_tstz BETWEEN nvl(l_start_date, eh.dt_initial_tstz) AND
                              nvl(l_end_date, eh.dt_initial_tstz)
                              --
                              OR l_has_balance = pk_alert_constant.g_yes
                              --
                              OR l_has_executions = pk_alert_constant.g_yes)
                              --
                              )
                             --
                              OR
                             --Shows the hidrics that where req in the period
                              (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_req_r AND
                              eh.dt_initial_tstz BETWEEN nvl(l_start_date, eh.dt_initial_tstz) AND
                              nvl(l_end_date, eh.dt_initial_tstz))
                             --
                              OR
                             --Shows the hidrics that where exec in the period
                              (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_exec_e AND
                              l_has_executions = pk_alert_constant.g_yes)
                             --
                              OR
                             --Shows the hidrics that where balance in the period
                              (i_crit_type = pk_inp_hidrics_constant.g_hidric_crit_type_bal_b AND
                              l_has_balance = pk_alert_constant.g_yes)
                             --
                             )
                            --
                            )
                           --
                           )) t;
    
        g_error := 'GET CURSOR O_EPIS_HID_D';
        OPEN o_epis_hid_d FOR
            SELECT ehd.id_epis_hidrics_det,
                   ehd.id_epis_hidrics,
                   ehl.id_epis_hidrics_line,
                   ehb.id_epis_hidrics_balance,
                   pk_inp_hidrics.get_hidrics_desc(i_lang, i_prof, ehl.id_epis_hidrics_line) desc_hidrics_orig,
                   ehd.value_hidrics,
                   get_hidrics_um(i_lang, i_prof, i_epis_hidrics) desc_unit_meas,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) name_prof,
                   pk_prof_utils.get_spec_sign_by_visit(i_lang,
                                                        i_prof,
                                                        p.id_professional,
                                                        nvl(ehd.dt_execution_tstz, ehb.dt_register_tstz),
                                                        epi.id_visit) prof_speciality,
                   pk_date_utils.date_char_tsz(i_lang, ehd.dt_creation_tstz, i_prof.institution, i_prof.software) dt_target_det,
                   ehd.notes,
                   pk_date_utils.dt_chr_tsz(i_lang, ehd.dt_execution_tstz, i_prof) date_exec_det,
                   pk_date_utils.date_char_hour_tsz(i_lang, ehd.dt_execution_tstz, i_prof.institution, i_prof.software) hour_exec_det,
                   hid.flg_type flg_type_hid,
                   hid.id_hidrics,
                   ehd.dt_execution_tstz,
                   ehd.dt_creation_tstz,
                   pk_date_utils.date_char_tsz(i_lang, ehd.dt_creation_tstz, i_prof.institution, i_prof.software) date_creation_form,
                   -- new 2.6.0.3 fields
                   pk_inp_hidrics.get_hidrics_way(i_lang, i_prof, ehl.id_epis_hidrics_line) desc_way,
                   pk_inp_hidrics.get_table_val(pk_inp_hidrics.get_hidrics_location_grid(i_lang,
                                                                                         i_prof,
                                                                                         ehl.id_epis_hidrics_line),
                                                1) desc_location
              FROM epis_hidrics eh
             INNER JOIN episode epi
                ON epi.id_episode = eh.id_episode
             INNER JOIN epis_hidrics_balance ehb
                ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
             INNER JOIN epis_hidrics_det ehd
                ON (ehb.id_epis_hidrics_balance = ehd.id_epis_hidrics_balance)
             INNER JOIN epis_hidrics_line ehl
                ON (ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line)
             INNER JOIN hidrics hid
                ON (hid.id_hidrics = ehl.id_hidrics)
              LEFT JOIN professional p
                ON (p.id_professional = ehd.id_professional)
             WHERE epi.id_episode = nvl(l_id_episode, epi.id_episode)
               AND epi.id_visit = nvl(l_id_visit, epi.id_visit)
               AND epi.id_patient = l_id_patient
               AND eh.id_epis_hidrics = i_epis_hidrics
               AND (ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a OR
                   (ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_c AND
                   i_flg_report = pk_alert_constant.g_yes AND i_cancelled = pk_alert_constant.g_yes))
               AND nvl(ehd.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                   pk_inp_hidrics_constant.g_epis_hid_det_type_a
                  --
               AND (
                   --not report gets all
                    i_flg_report = pk_alert_constant.g_no OR
                   --
                    (
                    --if report
                     i_flg_report = pk_alert_constant.g_yes
                    --
                     AND
                    --shows hidrics or not whether flag i_crit_type and the dates (i_start_date and i_end_date)                     
                    --Shows the hidrics that where exec in the period
                     (i_crit_type IN (pk_inp_hidrics_constant.g_hidric_crit_type_exec_e,
                                      pk_inp_hidrics_constant.g_hidric_crit_type_all_a) AND
                     ehd.dt_execution_tstz BETWEEN nvl(l_start_date, ehd.dt_execution_tstz) AND
                     nvl(l_end_date, ehd.dt_execution_tstz))
                    --
                    )
                   --
                   )
            
            UNION ALL
            -- IV fluids
            SELECT /*+opt_estimate (table med_rep rows=0.0001)*/
             med_rep.id_fluid_det * -1 id_epis_hidrics_det,
             med_rep.id_epis_hidrics,
             med_rep.id_fluid * -1 id_epis_hidrics_line,
             ehb.id_epis_hidrics_balance,
             --NULL id_insert_det,
             med_rep.desc_fluid desc_hidrics_orig,
             med_rep.value_fluid value_hidrics,
             med_rep.desc_unit desc_unit_meas,
             pk_prof_utils.get_name_signature(i_lang, i_prof, med_rep.id_professional) name_prof,
             pk_prof_utils.get_spec_sign_by_visit(i_lang,
                                                  i_prof,
                                                  med_rep.id_professional,
                                                  med_rep.dt_execution,
                                                  med_rep.id_visit) prof_speciality,
             pk_date_utils.date_char_tsz(i_lang, med_rep.dt_execution, i_prof.institution, i_prof.software) dt_target_det,
             NULL notes,
             pk_date_utils.dt_chr_tsz(i_lang, med_rep.dt_execution, i_prof) date_exec_det,
             pk_date_utils.date_char_hour_tsz(i_lang, med_rep.dt_execution, i_prof.institution, i_prof.software) hour_exec_det,
             pk_inp_hidrics_constant.g_hidrics_flg_type_a flg_type_hid,
             (med_rep.id_fluid * -1) - 2 id_hidrics, --The "-2" is to avoid the fact this table already as "-1" and "-2" values
             med_rep.dt_execution dt_execution_tstz,
             med_rep.dt_execution dt_creation_tstz,
             pk_date_utils.date_char_tsz(i_lang, med_rep.dt_execution, i_prof.institution, i_prof.software) date_creation_form,
             -- new 2.6.0.3 fields
             med_rep.route desc_way,
             NULL          desc_location
              FROM TABLE(pk_inp_hidrics.get_fluid_balance_med_rep(i_lang,
                                                                  i_prof,
                                                                  i_flg_scope,
                                                                  i_scope,
                                                                  l_start_date,
                                                                  l_end_date,
                                                                  table_number(i_epis_hidrics))) med_rep
              JOIN epis_hidrics_balance ehb
                ON ehb.id_epis_hidrics = med_rep.id_epis_hidrics
             INNER JOIN epis_hidrics eh
                ON eh.id_epis_hidrics = med_rep.id_epis_hidrics
             WHERE eh.id_epis_hidrics = i_epis_hidrics
               AND med_rep.dt_execution BETWEEN ehb.dt_open_tstz AND nvl(ehb.dt_close_balance_tstz, current_timestamp)
                  
                  --
               AND (
                   --not report gets all
                    i_flg_report = pk_alert_constant.g_no OR
                   --
                    (
                    --if report
                     i_flg_report = pk_alert_constant.g_yes
                    --
                     AND
                    --
                     (
                     --shows canceled hidrics or not whether flag i_cancelled
                      (i_cancelled = pk_alert_constant.g_no AND eh.flg_status <> pk_inp_hidrics_constant.g_epis_hidric_c) OR
                      i_cancelled = pk_alert_constant.g_yes
                     --
                     )
                    --
                     AND
                    --shows hidrics or not whether flag i_crit_type and the dates (i_start_date and i_end_date)                     
                    --Shows the hidrics that where exec in the period
                     i_crit_type IN
                     (pk_inp_hidrics_constant.g_hidric_crit_type_exec_e, pk_inp_hidrics_constant.g_hidric_crit_type_all_a)
                    --
                    )
                   --
                   )
             ORDER BY dt_creation_tstz ASC;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_DET_REP',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid);
            pk_types.open_my_cursor(o_epis_hid_d);
            RETURN FALSE;
    END get_epis_hidrics_det_rep;

    /*******************************************************************************************************************************************
    * get_requests                     Get the intake and output requests;    
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           ID_EPIS_HIDRICS identifier    
    * @param I_FLG_SCOPE              Scope: P -patient; E- episode; V-visit; S-session
    * @param I_ID_EPISODE             Episode identifier; mandatory if i_flg_scope='E'
    * @param I_ID_PATIENT             Patient identifier; mandatory if i_flg_scope='P'
    * @param I_ID_VISIT               Visit identifier; mandatory if i_flg_scope='V'
    * @param I_FLG_REPORT_TYPE        Report type: C-complete; D-detailed    
    * @param I_START_DATE             Start date to be considered
    * @param I_END_DATE               End date to be considered
    * @param O_EPIS_HID               Cursor that returns hidrics      
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.5
    * @since                          23-Dec-2010
    *******************************************************************************************************************************************/
    FUNCTION get_requests
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_patient      IN patient.id_patient%TYPE,
        i_id_visit        IN visit.id_visit%TYPE,
        i_flg_report_type IN VARCHAR2,
        i_start_date      IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date        IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_epis_hid        OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_unit_meas_desc pk_translation.t_desc_translation;
        l_id_epis_type   episode.id_epis_type%TYPE;
        l_internal_error EXCEPTION;
    BEGIN
    
        l_unit_meas_desc := pk_translation.get_translation(i_lang      => i_lang,
                                                           i_code_mess => 'UNIT_MEASURE.CODE_UNIT_MEASURE.' ||
                                                                          pk_sysconfig.get_config(i_code_cf => 'HIDRICS_UNIT_MEAS',
                                                                                                  i_prof    => i_prof));
    
        g_error := 'pk_episode.get_epis_type. id_episode: ' || i_id_episode;
        pk_alertlog.log_debug(g_error);
        IF NOT pk_episode.get_epis_type(i_lang      => i_lang,
                                        i_id_epis   => i_id_episode,
                                        o_epis_type => l_id_epis_type,
                                        o_error     => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'GET CURSOR O_EPIS_HID';
        pk_alertlog.log_debug(g_error);
        OPEN o_epis_hid FOR
            SELECT eh.id_epis_hidrics,
                   eh.flg_status status_epis_hid,
                   decode(l_id_epis_type,
                          nvl(t_ti_log.get_epis_type(i_lang,
                                                     i_prof,
                                                     epi.id_epis_type,
                                                     pk_inp_hidrics_constant.g_epis_hidric_r,
                                                     eh.id_epis_hidrics,
                                                     ht.flg_ti_type),
                              epi.id_epis_type),
                          pk_translation.get_translation(i_lang, ht.code_hidrics_type),
                          pk_translation.get_translation(i_lang, ht.code_hidrics_type) || ' (' ||
                          pk_message.get_message(i_lang,
                                                 profissional(i_prof.id,
                                                              i_prof.institution,
                                                              t_ti_log.get_epis_type_soft(i_lang,
                                                                                          i_prof,
                                                                                          epi.id_epis_type,
                                                                                          pk_inp_hidrics_constant.g_epis_hidric_r,
                                                                                          eh.id_epis_hidrics,
                                                                                          ht.flg_ti_type)),
                                                 'IMAGE_T009') || ')') desc_hid_type,
                   --
                   pk_translation.get_translation(i_lang, hi.code_hidrics_interval) desc_hid_inter,
                   pk_date_utils.date_char_tsz(i_lang, eh.dt_initial_tstz, i_prof.institution, i_prof.software) dt_target_ini,
                   pk_date_utils.date_char_tsz(i_lang, eh.dt_end_tstz, i_prof.institution, i_prof.software) dt_target_end,
                   pk_date_utils.date_char_tsz(i_lang, eh.dt_cancel_tstz, i_prof.institution, i_prof.software) dt_target_cancel,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) name_prof,
                   pk_prof_utils.get_spec_sign_by_visit(i_lang,
                                                        i_prof,
                                                        p.id_professional,
                                                        eh.dt_creation_tstz,
                                                        epi.id_visit) prof_speciality,
                   pk_date_utils.date_char_tsz(i_lang, eh.dt_creation_tstz, i_prof.institution, i_prof.software) dt_target_creat,
                   eh.dt_creation_tstz,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, pc.id_professional) name_prof_cancel,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, pi.id_professional) name_prof_inter,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    pi.id_professional,
                                                    eh.dt_inter_tstz,
                                                    epi.id_episode) prof_inter_speciality,
                   pk_date_utils.dt_chr_tsz(i_lang, eh.dt_inter_tstz, i_prof) date_target_inter,
                   eh.dt_inter_tstz,
                   pk_date_utils.date_char_tsz(i_lang, eh.dt_inter_tstz, i_prof.institution, i_prof.software) dt_target_inter,
                   eh.notes notes_epis_hid,
                   eh.notes_cancel notes_epis_hid_canc,
                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, eh.id_cancel_reason) cancel_reason,
                   eh.notes_inter notes_epis_hid_int,
                   pk_sysdomain.get_domain('EPIS_HIDRICS.FLG_RESTRICTED', eh.flg_restricted, i_lang) desc_restriction,
                   decode(eh.max_intake, NULL, NULL, eh.max_intake || ' ' || l_unit_meas_desc) max_intake,
                   decode(eh.min_output, NULL, NULL, eh.min_output || ' ' || l_unit_meas_desc) min_output,
                   
                   pk_sysdomain.get_domain('EPIS_HIDRICS.FLG_STATUS', eh.flg_status, i_lang) title_hidrics_status_rep,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    pc.id_professional,
                                                    eh.dt_cancel_tstz,
                                                    epi.id_episode) prof_cancel_speciality,
                   pk_date_utils.date_char_tsz(i_lang, eh.dt_next_balance, i_prof.institution, i_prof.software) dt_next_balance
              FROM epis_hidrics eh
             INNER JOIN episode epi
                ON (eh.id_episode = epi.id_episode)
             INNER JOIN hidrics_type ht
                ON (eh.id_hidrics_type = ht.id_hidrics_type)
             INNER JOIN hidrics_interval hi
                ON (eh.id_hidrics_interval = hi.id_hidrics_interval)
              LEFT JOIN professional p
                ON (p.id_professional = eh.id_professional)
              LEFT JOIN professional pc
                ON (pc.id_professional = eh.id_prof_cancel)
              LEFT JOIN professional pi
                ON (pi.id_professional = eh.id_prof_inter)
             WHERE (i_epis_hidrics IS NULL OR eh.id_epis_hidrics = i_epis_hidrics)
               AND (i_id_visit IS NULL OR epi.id_visit = i_id_visit)
               AND (i_id_patient IS NULL OR eh.id_patient = i_id_patient)
               AND (i_id_episode IS NULL OR eh.id_episode = i_id_episode)
               AND ((i_flg_report_type = pk_inp_hidrics_constant.g_report_complete_c AND
                   eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_e,
                                       pk_inp_hidrics_constant.g_epis_hidric_f,
                                       pk_inp_hidrics_constant.g_epis_hidric_i,
                                       pk_inp_hidrics_constant.g_epis_hidric_r,
                                       pk_inp_hidrics_constant.g_epis_hidric_o)) OR
                   (i_flg_report_type = pk_inp_hidrics_constant.g_report_complete_d AND
                   eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_e,
                                       pk_inp_hidrics_constant.g_epis_hidric_f,
                                       pk_inp_hidrics_constant.g_epis_hidric_i,
                                       pk_inp_hidrics_constant.g_epis_hidric_r,
                                       pk_inp_hidrics_constant.g_epis_hidric_o,
                                       pk_inp_hidrics_constant.g_epis_hidric_c)))
               AND (i_start_date IS NULL OR eh.dt_epis_hidrics >= i_start_date)
               AND (i_end_date IS NULL OR eh.dt_epis_hidrics <= i_end_date);
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_types.open_my_cursor(o_epis_hid);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_REQUESTS',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid);
            RETURN FALSE;
    END get_requests;

    /*******************************************************************************************************************************************
    * Get the intake and output requests to PDMS API
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_FLG_SCOPE              Scope: P -patient; E- episode; V-visit; S-session
    * @param I_ID_EPISODE             Episode identifier; mandatory if i_flg_scope='E'
    * @param I_ID_PATIENT             Patient identifier; mandatory if i_flg_scope='P'
    * @param I_ID_VISIT               Visit identifier; mandatory if i_flg_scope='V'
    * @param I_START_DATE             Start date to be considered
    * @param I_END_DATE               End date to be considered
    * @param I_EPIS_HIDRICS_IDS       Array of Hidrics Episode Identifiers
    * @param I_SCOPE                  Identifier to be filtered: id_patient - i_flg_scope = 'P', id_visit - i_flg_scope = 'V', id_episode - i_flg_scope = 'E'
    * @param O_EPIS_HID               Cursor that returns hidrics      
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         António Neto
    * @version                        2.6.1.2
    * @since                          07-Jul-2011
    *******************************************************************************************************************************************/
    FUNCTION get_requests_pdms
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_flg_scope        IN VARCHAR2,
        i_id_episode       IN episode.id_episode%TYPE,
        i_id_patient       IN patient.id_patient%TYPE,
        i_id_visit         IN visit.id_visit%TYPE,
        i_start_date       IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date         IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_epis_hidrics_ids IN table_number,
        i_scope            IN patient.id_patient%TYPE,
        o_epis_hid         OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_epis_type episode.id_epis_type%TYPE;
        l_internal_error EXCEPTION;
    BEGIN
    
        g_error := 'pk_episode.get_epis_type. id_episode: ' || i_id_episode;
    
        IF NOT pk_episode.get_epis_type(i_lang      => i_lang,
                                        i_id_epis   => i_id_episode,
                                        o_epis_type => l_id_epis_type,
                                        o_error     => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'GET CURSOR O_EPIS_HID';
    
        OPEN o_epis_hid FOR
            SELECT t.id_epis_hidrics,
                   t.id_episode,
                   t.id_professional,
                   (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, t.id_professional)
                      FROM dual) name_prof,
                   t.flg_type flg_type_hid,
                   t.id_hidrics,
                   t.id_epis_hid_ftxt_fluid,
                   to_char(t.id_way) id_way,
                   to_char(t.id_epis_hid_ftxt_way) id_epis_hid_ftxt_way,
                   t.id_epis_hidrics_line,
                   get_hidrics_way(i_lang, i_prof, t.id_epis_hidrics_line) desc_way,
                   get_hidrics_location_desc(i_lang, i_prof, t.id_epis_hidrics_line) desc_location,
                   pk_inp_hidrics_constant.g_flg_hidrics_med_h flg_hidrics_med,
                   --fields to order
                   (SELECT pk_sysdomain.get_rank(i_lang, pk_inp_hidrics_constant.g_hidrics_flg_type, t.flg_type)
                      FROM dual) rank,
                   pk_inp_hidrics_constant.g_element_normal flg_total,
                   t.rank rank_hidrics,
                   get_hidrics_desc(i_lang, i_prof, t.id_epis_hidrics_line) desc_hidrics,
                   t.acronym hid_type_acronym,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, t.dt_initial_tstz, i_prof) dt_initial_tstz
              FROM TABLE(tf_get_epis_hid(i_id_patient       => i_id_patient,
                                         i_epis_hidrics_ids => i_epis_hidrics_ids,
                                         i_id_visit         => i_id_visit,
                                         i_id_episode       => i_id_episode,
                                         i_start_date       => i_start_date,
                                         i_end_date         => i_end_date)) t
            UNION ALL
            -- IV fluids
            SELECT /*+opt_estimate (table med_rep rows=1)*/
            DISTINCT med_rep.id_epis_hidrics,
                     med_rep.id_episode,
                     med_rep.id_professional,
                     (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, med_rep.id_professional)
                        FROM dual) name_prof,
                     
                     pk_inp_hidrics_constant.g_hidrics_flg_type_a flg_type,
                     
                     (med_rep.id_fluid * -1) - 2 id_hidrics, --The "-2" is to avoid the fact this table already as "-1" and "-2" values
                     NULL id_epis_hid_ftxt_fluid,
                     CASE
                          WHEN med_rep.id_route IS NOT NULL THEN
                           '-' || med_rep.id_route
                          ELSE
                           med_rep.id_route
                      END id_way,
                     CASE
                          WHEN med_rep.route_id IS NOT NULL THEN
                           '-' || med_rep.route_id
                          ELSE
                           med_rep.route_id
                      END id_epis_hid_ftxt_way,
                     NULL id_epis_hidrics_line,
                     
                     med_rep.route                               desc_way,
                     NULL                                        desc_location,
                     pk_inp_hidrics_constant.g_flg_hidrics_med_m flg_hidrics_med,
                     
                     --fields to order
                     (SELECT pk_sysdomain.get_rank(i_lang,
                                                   pk_inp_hidrics_constant.g_hidrics_flg_type,
                                                   pk_inp_hidrics_constant.g_hidrics_flg_type_a)
                        FROM dual) rank,
                     pk_inp_hidrics_constant.g_element_presc flg_total,
                     0 rank_hidrics,
                     med_rep.desc_fluid desc_hidrics,
                     NULL hid_type_acronym,
                     pk_date_utils.dt_chr_date_hour_tsz(i_lang, eh.dt_initial_tstz, i_prof) dt_initial_tstz
              FROM TABLE(get_fluid_balance_med_rep(i_lang,
                                                   i_prof,
                                                   i_flg_scope,
                                                   i_scope,
                                                   i_start_date,
                                                   i_end_date,
                                                   i_epis_hidrics_ids)) med_rep
              JOIN epis_hidrics_balance ehb
                ON ehb.id_epis_hidrics = med_rep.id_epis_hidrics
              LEFT JOIN epis_hidrics eh
                ON eh.id_epis_hidrics = ehb.id_epis_hidrics
             WHERE med_rep.dt_execution BETWEEN ehb.dt_open_tstz AND nvl(ehb.dt_close_balance_tstz, current_timestamp)
             ORDER BY dt_initial_tstz, rank, flg_total, rank_hidrics, desc_hidrics;
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_types.open_my_cursor(o_epis_hid);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_REQUESTS_PDMS',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid);
            RETURN FALSE;
    END get_requests_pdms;

    /*******************************************************************************************************************************************
    * get_balances                     Get the intake and output balances information;    
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           ID_EPIS_HIDRICS identifier    
    * @param   i_flg_scope            Scope: P -patient; E- episode; V-visit; S-session
    * @param   i_id_episode           Episode identifier; mandatory if i_flg_scope='E'
    * @param   i_id_patient           Patient identifier; mandatory if i_flg_scope='P'
    * @param   i_id_visit             Visit identifier; mandatory if i_flg_scope='V'
    * @param   i_flg_report_type      Report type: C-complete; D-detailed    
    * @param   i_start_date           Start date to be considered
    * @param   i_end_date             End date to be considered   
    * @param O_EPIS_HID               Cursor that returns hidrics      
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.5
    * @since                          12-Jan-2011
    *******************************************************************************************************************************************/
    FUNCTION get_balances
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_scope       IN VARCHAR2,
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_patient      IN patient.id_patient%TYPE,
        i_id_visit        IN visit.id_visit%TYPE,
        i_flg_report_type IN VARCHAR2,
        i_start_date      IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date        IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_epis_hid_b      OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'GET CURSOR O_EPIS_HID_B';
        OPEN o_epis_hid_b FOR
            SELECT eh.id_epis_hidrics,
                   ehb.id_epis_hidrics_balance,
                   ehb.total_admin,
                   ehb.total_elim,
                   pk_translation.get_translation(i_lang, um.code_unit_measure) desc_unit_meas,
                   pk_date_utils.get_elapsed_tsz(i_lang, ehb.dt_open_tstz, ehb.dt_close_balance_tstz) interval_val,
                   pk_date_utils.dt_chr_tsz(i_lang, ehb.dt_open_tstz, i_prof) date_target_open,
                   pk_date_utils.date_char_hour_tsz(i_lang, ehb.dt_open_tstz, i_prof.institution, i_prof.software) hour_target_open,
                   pk_date_utils.dt_chr_tsz(i_lang, ehb.dt_close_balance_tstz, i_prof) date_target_close,
                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                    ehb.dt_close_balance_tstz,
                                                    i_prof.institution,
                                                    i_prof.software) hour_target_close,
                   decode(ehb.total_times, NULL, NULL, 0, NULL, ehb.total_times) nr_total_times
              FROM epis_hidrics eh
              JOIN epis_hidrics_balance ehb
                ON eh.id_epis_hidrics = ehb.id_epis_hidrics
              JOIN episode epi
                ON epi.id_episode = eh.id_episode
              LEFT JOIN unit_measure um
                ON ehb.id_unit_measure = um.id_unit_measure
             WHERE (i_epis_hidrics IS NULL OR ehb.id_epis_hidrics = i_epis_hidrics)
               AND (i_id_visit IS NULL OR epi.id_visit = i_id_visit)
               AND (i_id_patient IS NULL OR eh.id_patient = i_id_patient)
               AND (i_id_episode IS NULL OR eh.id_episode = i_id_episode)
               AND ((i_flg_report_type = pk_inp_hidrics_constant.g_report_complete_c AND
                   ehb.flg_status IN (pk_inp_hidrics_constant.g_epis_hid_balance_r,
                                        pk_inp_hidrics_constant.g_epis_hid_balance_e,
                                        pk_inp_hidrics_constant.g_epis_hid_balance_i,
                                        pk_inp_hidrics_constant.g_epis_hid_balance_f)) OR
                   (i_flg_report_type = pk_inp_hidrics_constant.g_report_complete_d AND
                   eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r,
                                       pk_inp_hidrics_constant.g_epis_hidric_e,
                                       pk_inp_hidrics_constant.g_epis_hidric_i,
                                       pk_inp_hidrics_constant.g_epis_hidric_f,
                                       pk_inp_hidrics_constant.g_epis_hidric_o,
                                       pk_inp_hidrics_constant.g_epis_hidric_c)))
               AND (i_start_date IS NULL OR eh.dt_epis_hidrics >= i_start_date)
               AND (i_end_date IS NULL OR eh.dt_epis_hidrics <= i_end_date)
            
             ORDER BY ehb.dt_open_tstz DESC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_BALANCES',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid_b);
            RETURN FALSE;
    END get_balances;

    /*******************************************************************************************************************************************
    * get_takes_and_outputs           Get the epis_hidrics_det associated to an episode, visit or patient.    
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           ID_EPIS_HIDRICS identifier    
    * @param I_FLG_SCOPE              Scope: P -patient; E- episode; V-visit; S-session
    * @param I_ID_EPISODE             Episode identifier; mandatory if i_flg_scope='E'
    * @param I_ID_PATIENT             Patient identifier; mandatory if i_flg_scope='P'
    * @param I_ID_VISIT               Visit identifier; mandatory if i_flg_scope='V'
    * @param I_FLG_REPORT_TYPE        Report type: C-complete; D-detailed; P-PDMS all records except the cancelled ones
    * @param I_START_DATE             Start date to be considered
    * @param I_END_DATE               End date to be considered
    * @param I_SCOPE                  Identifier to be filtered: id_patient - i_flg_scope = 'P', id_visit - i_flg_scope = 'V', id_episode - i_flg_scope = 'E'
    * @param I_EPIS_HIDRICS_IDS       Array of Hidrics Episode Identifiers
    * @param O_EPIS_HID_DET           Cursor that returns hidrics      
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.5
    * @since                          23-Dec-2010
    *******************************************************************************************************************************************/
    FUNCTION get_takes_and_outputs
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_scope        IN VARCHAR2,
        i_id_episode       IN episode.id_episode%TYPE,
        i_id_patient       IN patient.id_patient%TYPE,
        i_id_visit         IN visit.id_visit%TYPE,
        i_flg_report_type  IN VARCHAR2,
        i_start_date       IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date         IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_scope            IN patient.id_patient%TYPE,
        i_epis_hidrics_ids IN table_number,
        o_epis_hid_det     OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_internal_error EXCEPTION;
        l_epis_hidrics_ids        table_number := NULL;
        l_hidrics_flg_type_desc_a VARCHAR2(4000 CHAR) := pk_sysdomain.get_domain(pk_inp_hidrics_constant.g_hidrics_flg_type,
                                                                                 pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                                                                                 i_lang);
    BEGIN
    
        IF i_epis_hidrics_ids IS NOT NULL
        THEN
            l_epis_hidrics_ids := i_epis_hidrics_ids;
        ELSIF i_epis_hidrics IS NOT NULL
        THEN
            l_epis_hidrics_ids := table_number(i_epis_hidrics);
        END IF;
    
        g_error := 'GET CURSOR O_EPIS_HID';
        pk_alertlog.log_debug(g_error);
        OPEN o_epis_hid_det FOR
            SELECT ehd.id_epis_hidrics_det,
                   ehd.id_epis_hidrics,
                   ehl.id_epis_hidrics_line,
                   to_char(ehl.id_way) id_way,
                   to_char(ehl.id_epis_hid_ftxt_way) id_epis_hid_ftxt_way,
                   ehl.id_epis_hid_ftxt_fluid,
                   ehb.id_epis_hidrics_balance,
                   pk_inp_hidrics.get_hidrics_desc(i_lang, i_prof, ehl.id_epis_hidrics_line) desc_hidrics_orig,
                   ehd.value_hidrics,
                   get_hidrics_um(i_lang, i_prof, eh.id_epis_hidrics) desc_unit_meas,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, p.id_professional) name_prof,
                   pk_prof_utils.get_spec_sign_by_visit(i_lang,
                                                        i_prof,
                                                        p.id_professional,
                                                        nvl(ehd.dt_execution_tstz, ehb.dt_register_tstz),
                                                        epi.id_visit) prof_speciality,
                   pk_date_utils.date_char_tsz(i_lang, ehd.dt_creation_tstz, i_prof.institution, i_prof.software) dt_target_det,
                   ehd.notes,
                   pk_date_utils.dt_chr_tsz(i_lang, ehd.dt_execution_tstz, i_prof) date_exec_det,
                   pk_date_utils.date_char_hour_tsz(i_lang, ehd.dt_execution_tstz, i_prof.institution, i_prof.software) hour_exec_det,
                   hid.flg_type flg_type_hid,
                   hid.id_hidrics,
                   --Due to a problem with middleware platform with timestamps fields we removed those fields AN (ALERT-56844)
                   pk_date_utils.date_char_tsz(i_lang, ehd.dt_creation_tstz, i_prof.institution, i_prof.software) date_creation_form,
                   -- new 2.6.0.3 fields
                   pk_inp_hidrics.get_hidrics_way(i_lang, i_prof, ehl.id_epis_hidrics_line) desc_way,
                   pk_inp_hidrics.get_table_val(pk_inp_hidrics.get_hidrics_location_grid(i_lang,
                                                                                         i_prof,
                                                                                         ehl.id_epis_hidrics_line),
                                                1) desc_location,
                   get_characts_descs(i_lang, i_prof, ehd.id_epis_hidrics_det) desc_characteristics,
                   ehd.flg_type,
                   ehd.nr_times,
                   get_device_desc(i_lang, i_prof, ehd.id_hidrics_device) desc_device,
                   ehd.id_professional,
                   ehb.flg_status,
                   pk_sysdomain.get_img(i_lang, pk_inp_hidrics_constant.g_domain_ehb_flg_status, ehb.flg_status) flg_status_icon,
                   pk_sysdomain.get_domain(pk_inp_hidrics_constant.g_hidrics_flg_type, hid.flg_type, i_lang) desc_type_hid,
                   pk_date_utils.date_char_tsz(i_lang, ehd.dt_execution_tstz, i_prof.institution, i_prof.software) date_exec_form,
                   pk_inp_hidrics_constant.g_flg_hidrics_med_h flg_hidrics_med,
                   ehl.id_hidrics_location,
                   pk_date_utils.date_send_tsz(i_lang, ehd.dt_execution_tstz, i_prof) date_exec_str,
                   pk_date_utils.date_send_tsz(i_lang, ehd.dt_creation_tstz, i_prof) date_creation_str,
                   ehlg.id_epis_hidrics_group
              FROM epis_hidrics eh
             INNER JOIN episode epi
                ON epi.id_episode = eh.id_episode
             INNER JOIN epis_hidrics_balance ehb
                ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
             INNER JOIN epis_hidrics_det ehd
                ON (ehb.id_epis_hidrics_balance = ehd.id_epis_hidrics_balance)
             INNER JOIN epis_hidrics_line ehl
                ON (ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line)
              LEFT JOIN epis_hd_line_group ehlg
                ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line
             INNER JOIN hidrics hid
                ON (hid.id_hidrics = ehl.id_hidrics)
              LEFT JOIN professional p
                ON (p.id_professional = ehd.id_professional)
             WHERE (nvl(ehd.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                   pk_inp_hidrics_constant.g_epis_hid_det_type_a OR
                   i_flg_report_type = pk_inp_hidrics_constant.g_report_complete_p)
               AND (l_epis_hidrics_ids IS NULL OR
                   eh.id_epis_hidrics IN (SELECT /*+opt_estimate (table t rows=0.0001)*/
                                            column_value
                                             FROM TABLE(l_epis_hidrics_ids) t))
               AND (i_id_visit IS NULL OR epi.id_visit = i_id_visit)
               AND (eh.id_patient = i_id_patient)
               AND (i_id_episode IS NULL OR eh.id_episode = i_id_episode)
               AND ((i_flg_report_type IN
                   (pk_inp_hidrics_constant.g_report_complete_c, pk_inp_hidrics_constant.g_report_complete_p) AND
                   ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a) OR
                   (i_flg_report_type = pk_inp_hidrics_constant.g_report_complete_d AND
                   ehd.flg_status IN
                   (pk_inp_hidrics_constant.g_epis_hid_det_status_a, pk_inp_hidrics_constant.g_epis_hid_det_status_c)))
               AND (i_start_date IS NULL OR ehd.dt_epis_hidrics_det >= i_start_date)
               AND (i_end_date IS NULL OR ehd.dt_epis_hidrics_det <= i_end_date)
               AND ((i_flg_report_type = pk_inp_hidrics_constant.g_report_complete_c AND
                   ehb.id_epis_hidrics_balance = get_balance_id(i_lang, i_prof, eh.id_epis_hidrics)) OR
                   (i_flg_report_type IN
                   (pk_inp_hidrics_constant.g_report_complete_d, pk_inp_hidrics_constant.g_report_complete_p)))
            
            UNION ALL
            -- IV fluids
            SELECT /*+opt_estimate (table med_rep rows=0.000001)*/
             med_rep.id_fluid_det * -1 id_epis_hidrics_det,
             med_rep.id_epis_hidrics,
             med_rep.id_fluid * -1 id_epis_hidrics_line,
             CASE
                 WHEN med_rep.id_route IS NOT NULL THEN
                  '-' || med_rep.id_route
                 ELSE
                  med_rep.id_route
             END id_way,
             CASE
                 WHEN med_rep.route_id IS NOT NULL THEN
                  '-' || med_rep.route_id
                 ELSE
                  med_rep.route_id
             END id_epis_hid_ftxt_way,
             NULL id_epis_hid_ftxt_fluid,
             ehb.id_epis_hidrics_balance,
             med_rep.desc_fluid desc_hidrics_orig,
             med_rep.value_fluid value_hidrics,
             med_rep.desc_unit desc_unit_meas,
             pk_prof_utils.get_name_signature(i_lang, i_prof, med_rep.id_professional) name_prof,
             pk_prof_utils.get_spec_sign_by_visit(i_lang,
                                                  i_prof,
                                                  med_rep.id_professional,
                                                  med_rep.dt_execution,
                                                  med_rep.id_visit) prof_speciality,
             pk_date_utils.date_char_tsz(i_lang, med_rep.dt_execution, i_prof.institution, i_prof.software) dt_target_det,
             NULL notes,
             pk_date_utils.dt_chr_tsz(i_lang, med_rep.dt_execution, i_prof) date_exec_det,
             pk_date_utils.date_char_hour_tsz(i_lang, med_rep.dt_execution, i_prof.institution, i_prof.software) hour_exec_det,
             pk_inp_hidrics_constant.g_hidrics_flg_type_a flg_type_hid,
             (med_rep.id_fluid * -1) - 2 id_hidrics, --The "-2" is to avoid the fact this table already as "-1" and "-2" values
             --Due to a problem with middleware platform with timestamps fields we removed those fields AN (ALERT-56844)
             pk_date_utils.date_char_tsz(i_lang, med_rep.dt_execution, i_prof.institution, i_prof.software) date_creation_form,
             -- new 2.6.0.3 fields
             med_rep.route desc_way,
             NULL desc_location,
             NULL desc_characteristics,
             pk_inp_hidrics_constant.g_epis_hid_det_type_a flg_type,
             NULL nr_times,
             NULL desc_device,
             med_rep.id_professional,
             ehb.flg_status,
             pk_sysdomain.get_img(i_lang, pk_inp_hidrics_constant.g_domain_ehb_flg_status, ehb.flg_status) flg_status_icon,
             l_hidrics_flg_type_desc_a desc_type_hid,
             pk_date_utils.date_char_tsz(i_lang, med_rep.dt_execution, i_prof.institution, i_prof.software) date_exec_form,
             pk_inp_hidrics_constant.g_flg_hidrics_med_m flg_hidrics_med,
             NULL id_hidrics_location,
             pk_date_utils.date_send_tsz(i_lang, med_rep.dt_execution, i_prof) date_exec_str,
             pk_date_utils.date_send_tsz(i_lang, med_rep.dt_execution, i_prof) date_creation_str,
             NULL id_epis_hidrics_group
              FROM TABLE(pk_inp_hidrics.get_fluid_balance_med_rep(i_lang,
                                                                  i_prof,
                                                                  i_flg_scope,
                                                                  i_scope,
                                                                  i_start_date,
                                                                  i_end_date,
                                                                  l_epis_hidrics_ids)) med_rep
              JOIN epis_hidrics_balance ehb
                ON ehb.id_epis_hidrics = med_rep.id_epis_hidrics
             WHERE med_rep.dt_execution BETWEEN ehb.dt_open_tstz AND nvl(ehb.dt_close_balance_tstz, current_timestamp)
             ORDER BY date_creation_str ASC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_types.open_my_cursor(o_epis_hid_det);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TAKES_AND_OUTPUTS',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid_det);
            RETURN FALSE;
    END get_takes_and_outputs;

    /*******************************************************************************************************************************************
    * get_epis_hidrics_reports         Get hidric detail information.
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           ID_EPIS_HIDRICS identifier    
    * @param   i_flg_scope            Scope: P -patient; E- episode; V-visit
    * @param   i_scope                id_patient if i_flg_scope = 'P'
    *                                 id_visit if i_flg_scope = 'V'
    *                                 id_episode if i_flg_scope = 'E'
    * @param   i_flg_report_type      Report type: C-complete; D-detailed    
    * @param   i_start_date           Start date to be considered
    * @param   i_end_date             End date to be considered   
    * @param   i_show_balances        Y-The balances info (o_epis_hid_b cursor) is returned. N-otherwise.
    * @param O_EPIS_HID               Cursor that returns the intake and output requets  
    * @param O_EPIS_HID_D             Cursor that returns hidrics detail (the takes of each request)
    * @param O_EPIS_HID_B             Cursor that returns hidrics balances
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        0.1
    * @since                          2006/11/21
    *
    * @dependencies: REPORTS, PDMS
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_reports
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_scope       IN VARCHAR2, -- P -patient; E- episode; V-visit        
        i_scope           IN patient.id_patient%TYPE,
        i_flg_report_type IN VARCHAR2, --C-complete; D-detailed
        i_start_date      IN VARCHAR2,
        i_end_date        IN VARCHAR2,
        i_show_balances   IN VARCHAR2,
        o_epis_hid        OUT pk_types.cursor_type,
        o_epis_hid_d      OUT pk_types.cursor_type,
        o_epis_hid_b      OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_start_date TIMESTAMP WITH TIME ZONE;
        l_end_date   TIMESTAMP WITH TIME ZONE;
        l_internal_error EXCEPTION;
    
        l_patient patient.id_patient%TYPE;
        l_visit   visit.id_visit%TYPE;
        l_episode episode.id_episode%TYPE;
    BEGIN
        g_error := 'ANALYSING SCOPE TYPE: i_flg_scope: ' || i_flg_scope || '; i_scope: ' || i_scope;
        pk_alertlog.log_debug(g_error);
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_patient,
                                              o_visit      => l_visit,
                                              o_episode    => l_episode,
                                              o_error      => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        -- Convert start date to timestamp
        g_error := 'CALL GET_STRING_TSTZ FOR l_dt_begin';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                             i_prof      => i_prof,
                                             i_timestamp => i_start_date,
                                             i_timezone  => NULL,
                                             o_timestamp => l_start_date,
                                             o_error     => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        -- Convert end date to timestamp
        g_error := 'CALL GET_STRING_TSTZ FOR l_dt_end';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                             i_prof      => i_prof,
                                             i_timestamp => i_end_date,
                                             i_timezone  => NULL,
                                             o_timestamp => l_end_date,
                                             o_error     => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'CALL get_requests. i_epis_hidrics: ' || i_epis_hidrics || '; i_flg_scope: ' || i_flg_scope ||
                   '; i_scope: ' || i_scope || '; l_start_date: ' || CAST(l_start_date AS VARCHAR2) || '; ' ||
                   '; l_end_date: ' || CAST(l_end_date AS VARCHAR2);
        pk_alertlog.log_debug(g_error);
        IF NOT get_requests(i_lang            => i_lang,
                            i_prof            => i_prof,
                            i_epis_hidrics    => i_epis_hidrics,
                            i_id_episode      => l_episode,
                            i_id_patient      => l_patient,
                            i_id_visit        => l_visit,
                            i_flg_report_type => i_flg_report_type,
                            i_start_date      => l_start_date,
                            i_end_date        => l_end_date,
                            o_epis_hid        => o_epis_hid,
                            o_error           => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'CALL get_takes_and_outputs.';
        pk_alertlog.log_debug(g_error);
        IF NOT get_takes_and_outputs(i_lang             => i_lang,
                                     i_prof             => i_prof,
                                     i_epis_hidrics     => i_epis_hidrics,
                                     i_flg_scope        => i_flg_scope,
                                     i_id_episode       => l_episode,
                                     i_id_patient       => l_patient,
                                     i_id_visit         => l_visit,
                                     i_flg_report_type  => i_flg_report_type,
                                     i_start_date       => l_start_date,
                                     i_end_date         => l_end_date,
                                     i_scope            => i_scope,
                                     i_epis_hidrics_ids => NULL,
                                     o_epis_hid_det     => o_epis_hid_d,
                                     o_error            => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF (i_show_balances = pk_alert_constant.g_yes)
        THEN
            g_error := 'CALL get_balances.';
            pk_alertlog.log_debug(g_error);
            IF NOT get_balances(i_lang            => i_lang,
                                i_prof            => i_prof,
                                i_epis_hidrics    => i_epis_hidrics,
                                i_flg_scope       => i_flg_scope,
                                i_id_episode      => l_episode,
                                i_id_patient      => l_patient,
                                i_id_visit        => l_visit,
                                i_flg_report_type => i_flg_report_type,
                                i_start_date      => i_start_date,
                                i_end_date        => i_end_date,
                                o_epis_hid_b      => o_epis_hid_b,
                                o_error           => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        ELSE
            pk_types.open_my_cursor(o_epis_hid_b);
        END IF;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_REPORTS',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid);
            pk_types.open_my_cursor(o_epis_hid_d);
            pk_types.open_my_cursor(o_epis_hid_b);
            RETURN FALSE;
    END get_epis_hidrics_reports;

    /********************************************************************************************
    * GET_EPIS_HID_ACTIONS                   Get available actions for a requested task
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_episode                 episode id
    * @param       i_epis_hidrics            epis_hidrics id
    * @param       o_status                  list of available actions for the task request
    * @param       o_error                   error message
    *
    * @return      boolean                   true on success, otherwise false
    *
    * @author                                Luï¿½Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/19
    ********************************************************************************************/
    FUNCTION get_epis_hid_actions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        o_status       OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_hidrics PLS_INTEGER;
    BEGIN
        -- See if this hidric is required or in execution
        g_error := 'GET EPIS_HIDRICS_DET COUNT';
        SELECT COUNT(1) num_hid
          INTO l_hidrics
          FROM epis_hidrics eh
         WHERE eh.id_episode = i_episode
           AND eh.id_epis_hidrics = i_epis_hidrics
           AND eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e);
    
        IF l_hidrics > 0
        THEN
            -- ...e, se existirem, devolve todos os estados possï¿½is,...
            g_error := 'GET CURSOR O_STATUS_1';
            --TODO
        
        ELSE
            -- ... senã¯ devolve todos os estados excepto 'Interromper'.
            g_error := 'GET CURSOR O_STATUS_2';
            --TODO
        
        END IF;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HID_ACTIONS',
                                              o_error);
            pk_types.open_my_cursor(o_status);
            RETURN FALSE;
    END get_epis_hid_actions;

    /*******************************************************************************************************************************************
    * Returns the hidrics interval description
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_HIDRICS_INTERVAL       Hidrics Interval identifier
    * @param I_INTERVAL_MINUTES       Interval in minutes
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Interval description
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.5
    * @since                          13-Jan-2011
    *
    * @author                         António Neto
    * @version                        2.6.1.6
    * @since                          20-Dec-2011
    *******************************************************************************************************************************************/
    FUNCTION get_hid_interval_desc_int
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_hidrics_interval IN hidrics_interval.id_hidrics_interval%TYPE,
        i_interval_minutes IN hidrics_interval.interval_minutes%TYPE
    ) RETURN VARCHAR2 IS
        l_hid_interval VARCHAR2(1000 CHAR);
    BEGIN
    
        g_error := 'GET interval desc';
        pk_alertlog.log_debug(g_error);
        SELECT decode(hi.flg_type,
                      pk_inp_hidrics_constant.g_hid_interval_type_o,
                      get_interval_desc(i_lang, i_interval_minutes),
                      pk_translation.get_translation(i_lang, hi.code_hidrics_interval))
          INTO l_hid_interval
          FROM hidrics_interval hi
         WHERE hi.id_hidrics_interval = i_hidrics_interval;
    
        RETURN l_hid_interval;
    END get_hid_interval_desc_int;

    /*******************************************************************************************************************************************
    * get_hidrics_interval       Returns the hidrics interval description
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HID               EPISDOE Hidric ID
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.5
    * @since                          13-Jan-2011
    *******************************************************************************************************************************************/
    FUNCTION get_hid_interval_desc
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_hidrics_interval IN hidrics_interval.id_hidrics_interval%TYPE,
        i_interval_minutes IN hidrics_interval.interval_minutes%TYPE,
        o_hid_interval     OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error        := 'CALL GET_HID_INTERVAL_DESC_INT';
        o_hid_interval := get_hid_interval_desc_int(i_lang             => i_lang,
                                                    i_prof             => i_prof,
                                                    i_hidrics_interval => i_hidrics_interval,
                                                    i_interval_minutes => i_interval_minutes);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HID_INTERVAL_DESC',
                                              o_error);
            RETURN FALSE;
    END get_hid_interval_desc;

    /********************************************************************************************
    * SET_REACTIVATE_HIDRIC                  Set an epis_positioning back to status after being canceled
    *
    * @param       i_lang                    language id
    * @param       i_prof                    professional information
    * @param       i_epis_hidric
    * @param       i_pos_status              epis_positioning id
    * @param       i_flg_status              new calceled status
    * @param       i_notes                   Status change notes
    * @param       o_error                   error information
    *   
    * @return      boolean                   true on success, otherwise false
    *
    * @author                                Luï¿½Maia                        
    * @version                               2.6.0.3                                    
    * @since                                 2010/May/23
    ********************************************************************************************/
    FUNCTION set_reactivate_hidric
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_status   IN epis_hidrics.flg_status%TYPE,
        i_flg_action   IN epis_hidrics.flg_action%TYPE,
        i_notes        IN epis_hidrics.notes%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_hidrics_balance_tc ts_epis_hidrics_balance.epis_hidrics_balance_tc;
        l_dt_end                  epis_hidrics.dt_end_tstz%TYPE;
        l_msg_text                sys_message.desc_message%TYPE;
        l_msg_title               sys_message.desc_message%TYPE;
        l_id_episode              epis_hidrics.id_episode%TYPE;
        l_id_hidrics_type         epis_hidrics.id_hidrics_type%TYPE;
        --
        l_rows_epis_hid_bal table_varchar;
        l_rowids            table_varchar;
        --
        CURSOR c_ehb IS
            SELECT *
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics = i_epis_hidrics
               AND ehb.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_c, pk_inp_hidrics_constant.g_epis_hidric_i);
    
        CURSOR c_epis_balance IS
            SELECT eb.id_epis_hidrics_balance
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics = i_epis_hidrics;
    
        l_icnp_interv EXCEPTION;
    BEGIN
        g_error := 'GET EPIS_HID JOB DATA';
        SELECT eh.dt_end_tstz, eh.id_episode, eh.id_hidrics_type
          INTO l_dt_end, l_id_episode, l_id_hidrics_type
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        g_error             := 'FETCH ROWTYPE EPIS_POSITIONING_PLAN';
        l_rows_epis_hid_bal := table_varchar();
    
        OPEN c_ehb;
        LOOP
            FETCH c_ehb BULK COLLECT
                INTO l_epis_hidrics_balance_tc LIMIT 1000;
            EXIT WHEN l_epis_hidrics_balance_tc.count = 0;
        
            FOR j IN 1 .. l_epis_hidrics_balance_tc.count
            LOOP
                l_epis_hidrics_balance_tc(j).flg_status := i_flg_status;
                l_epis_hidrics_balance_tc(j).id_prof_last_change := i_prof.id;
                l_epis_hidrics_balance_tc(j).dt_eh_balance := g_sysdate_tstz;
                l_epis_hidrics_balance_tc(j).dt_close_balance_tstz := NULL;
                --
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS_BALANCE ' || l_epis_hidrics_balance_tc(j).id_epis_hidrics_balance;
            
                pk_alertlog.log_debug(g_error);
                set_epis_hid_bal_hist(i_epis_hidrics_balance => l_epis_hidrics_balance_tc(j).id_epis_hidrics_balance);
            END LOOP;
            --        
            g_error  := 'UPDATE EPIS_HIDRICS_BALANCE WITH ID_EPIS_HIDRICS ' || i_epis_hidrics;
            l_rowids := table_varchar();
            ts_epis_hidrics_balance.upd(col_in            => l_epis_hidrics_balance_tc,
                                        ignore_if_null_in => FALSE,
                                        rows_out          => l_rowids);
        
            l_rows_epis_hid_bal := l_rows_epis_hid_bal MULTISET UNION l_rowids;
        END LOOP;
        CLOSE c_ehb;
    
        IF l_epis_hidrics_balance_tc.count > 0
        THEN
            g_error := 'PROCESS UPDATE';
            t_data_gov_mnt.process_update(i_lang,
                                          i_prof,
                                          'EPIS_HIDRICS_BALANCE',
                                          l_rows_epis_hid_bal,
                                          o_error,
                                          table_varchar('FLG_STATUS'));
        END IF;
        --
        g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || i_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        set_epis_hid_hist(i_epis_hidrics => i_epis_hidrics);
        --
        g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS = ' || i_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        l_rowids := table_varchar();
        ts_epis_hidrics.upd(id_epis_hidrics_in => i_epis_hidrics,
                            flg_status_in      => i_flg_status,
                            --
                            id_prof_cancel_in  => NULL,
                            id_prof_cancel_nin => FALSE,
                            notes_cancel_in    => NULL,
                            notes_cancel_nin   => FALSE,
                            dt_cancel_tstz_in  => NULL,
                            dt_cancel_tstz_nin => FALSE,
                            --
                            id_prof_inter_in  => NULL,
                            id_prof_inter_nin => FALSE,
                            notes_inter_in    => NULL,
                            notes_inter_nin   => FALSE,
                            dt_inter_tstz_in  => NULL,
                            dt_inter_tstz_nin => FALSE,
                            --
                            id_prof_last_change_in => i_prof.id,
                            dt_epis_hidrics_in     => g_sysdate_tstz,
                            flg_action_in          => i_flg_action,
                            rows_out               => l_rowids);
    
        --associate Integration of Therapeutic Attitudes (António Neto ALERT-164844)
        IF i_flg_status = pk_inp_hidrics_constant.g_epis_hidric_r
        THEN
            IF NOT create_assoc_icnp_interv(i_lang            => i_lang,
                                            i_prof            => i_prof,
                                            i_id_epis_hidrics => i_epis_hidrics,
                                            i_id_episode      => l_id_episode,
                                            i_id_hidrics_type => l_id_hidrics_type,
                                            o_error           => o_error)
            THEN
                RAISE l_icnp_interv;
            END IF;
        END IF;
    
        g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS ' || i_epis_hidrics;
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_HIDRICS',
                                      i_rowids       => l_rowids,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('FLG_STATUS',
                                                                      'ID_PROF_CANCEL',
                                                                      'NOTES_CANCEL',
                                                                      'DT_CANCEL_TSTZ',
                                                                      'ID_PROF_INTER',
                                                                      'NOTES_INTER',
                                                                      
                                                                      'DT_INTER_TSTZ'));
    
        g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
        alertlog.pk_alertlog.log_info(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => 'SET_REACTIVATE_HIDRIC');
        FOR r_balance IN c_epis_balance
        LOOP
            IF NOT check_restriction_alerts(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_episode      => NULL,
                                            i_epis_hidrics => i_epis_hidrics,
                                            i_epis_balance => r_balance.id_epis_hidrics_balance,
                                            i_max_intake   => NULL,
                                            i_min_output   => NULL,
                                            i_hidrics_type => NULL,
                                            i_flg_context  => pk_inp_hidrics_constant.g_context_end_balance,
                                            i_dt_execution => NULL,
                                            o_msg_title    => l_msg_title,
                                            o_msg_text     => l_msg_text,
                                            o_error        => o_error)
            THEN
                RAISE e_error;
            END IF;
        END LOOP;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_REACTIVATE_HIDRIC',
                                              o_error);
            RETURN FALSE;
    END set_reactivate_hidric;

    /**********************************************************************************************
    * SET_EPIS_HID_STATUS                    This function change Intake and Output status from:
    *                                             * Required to Interrupted
    *                                             * In execution to Interrupted
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_epis_hidrics                  epis_hidrics ID
    * @param i_epis_hid_bal                  epis_hidrics_balance ID
    * @param i_flg_status                    FLG_STATUS of this registry 
    * @param i_notes                         notes
    * @param I_FLG_TASK_STATUS               Type of task: D-Draft; F-Final
    * @param o_msg_error                     Message of error to display to user
    * @param o_error                         Error object
    *
    * @value I_FLG_TASK_STATUS               {*} 'C' Cancel {*} 'I' Interrupt
    * @value I_FLG_TASK_STATUS               {*} 'D' Draft {*} 'F' Final
    *
    * @return                                Success / fail
    *
    * @author                                Emilia Taborda
    * @version                               0.1
    * @since                                 2006/11/21
    *
    * @author                                Carlos Ferreira
    * @version                               0.2
    * @since                                 2007-03-21
    *
    * @author                                Luï¿½Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/17
    **********************************************************************************************/
    FUNCTION set_epis_hid_status
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hid_bal    IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        i_flg_status      IN epis_hidrics.flg_status%TYPE,
        i_notes           IN epis_hidrics.notes%TYPE,
        i_flg_task_status IN epis_hidrics.flg_status%TYPE DEFAULT g_flg_task_status_f,
        --i_flg_action      IN epis_hidrics.flg_action%TYPE,
        o_msg_error OUT VARCHAR2,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_flg_status      epis_hidrics.flg_status%TYPE;
        l_id_hidrics_type epis_hidrics.id_hidrics_type%TYPE;
        l_id_episode      epis_hidrics.id_episode%TYPE;
        l_epis_hid_bal    epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_episode         episode.id_episode%TYPE;
        --
        CURSOR c_epis_hid IS
            SELECT eh.flg_status, eh.id_hidrics_type, eh.id_episode
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = i_epis_hidrics
               AND eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r,
                                     pk_inp_hidrics_constant.g_epis_hidric_e,
                                     pk_inp_hidrics_constant.g_epis_hidric_d);
    
        CURSOR c_epis_hid_bal IS
            SELECT ehb.id_epis_hidrics_balance
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics = i_epis_hidrics
               AND ehb.id_epis_hidrics_balance = i_epis_hid_bal
               AND ehb.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r,
                                      pk_inp_hidrics_constant.g_epis_hidric_e,
                                      pk_inp_hidrics_constant.g_epis_hidric_d)
               AND NOT EXISTS (SELECT 0
                      FROM epis_hidrics_det ehd
                     WHERE ehd.id_epis_hidrics_balance = ehb.id_epis_hidrics_balance
                       AND ehd.id_epis_hidrics_balance = i_epis_hid_bal
                       AND ehd.id_epis_hidrics = i_epis_hidrics);
    
        CURSOR c_epis_hidrics IS
            SELECT id_episode
              FROM epis_hidrics
             WHERE id_epis_hidrics = i_epis_hidrics;
    
        l_found                  BOOLEAN;
        l_rowids                 table_varchar;
        l_eh_hidrics_flg_status  epis_hidrics.flg_status%TYPE;
        l_eh_hidrics_flg_action  epis_hidrics.flg_action%TYPE;
        l_ehb_hidrics_flg_status epis_hidrics_balance.flg_status%TYPE;
        l_flg_ti_type            hidrics_type.flg_ti_type%TYPE;
        l_ht_acronym             hidrics_type.acronym%TYPE;
        l_msg_title              sys_message.desc_message%TYPE;
        l_msg_text               sys_message.desc_message%TYPE;
        --
        l_id_prof_cancel      epis_hidrics.id_prof_cancel%TYPE := NULL;
        l_notes_cancel        epis_hidrics.notes_cancel%TYPE := '';
        l_dt_cancel           epis_hidrics.dt_cancel_tstz%TYPE := NULL;
        l_id_prof_inter       epis_hidrics.id_prof_inter%TYPE := NULL;
        l_notes_inter         epis_hidrics.notes_inter%TYPE := '';
        l_dt_inter            epis_hidrics.dt_inter_tstz%TYPE := NULL;
        l_hidric_type_acronym hidrics_type.acronym%TYPE;
        l_exists_other_task   VARCHAR2(1 CHAR);
        l_desc_task           pk_translation.t_desc_translation;
        --
        l_old_flg_status epis_hidrics.flg_status%TYPE;
        l_new_flg_status epis_hidrics.flg_status%TYPE;
        l_new_flg_action epis_hidrics.flg_action%TYPE;
        --
        t_ti_log_ins_exception EXCEPTION;
    
        l_icnp_interv EXCEPTION;
    BEGIN
        --
        -- Verify if the record is requested or undergoing
        g_error := 'OPEN C_EPIS_HID';
        OPEN c_epis_hid;
        FETCH c_epis_hid
            INTO l_flg_status, l_id_hidrics_type, l_id_episode;
        l_found := c_epis_hid%FOUND;
        CLOSE c_epis_hid;
        --
        IF l_found
        THEN
            IF i_flg_status <> pk_inp_hidrics_constant.g_epis_hidric_a
            THEN
                IF i_flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_c, pk_inp_hidrics_constant.g_epis_hidric_o)
                THEN
                    --
                    IF l_flg_status = pk_inp_hidrics_constant.g_epis_hidric_d
                    THEN
                        l_eh_hidrics_flg_status  := pk_inp_hidrics_constant.g_epis_hidric_l;
                        l_ehb_hidrics_flg_status := pk_inp_hidrics_constant.g_epis_hidric_l;
                        l_eh_hidrics_flg_action  := pk_inp_hidrics_constant.g_flg_action_l;
                        --
                    ELSE
                        -- Para cancelar uma requisiç£¯ bem como o respectivo balanç¯¬ s?rá °ossivé¬ se nã¯ existir planos associados 
                        ----- a esse balanç¯
                        g_error := 'OPEN C_EPIS_HID_BAL';
                        OPEN c_epis_hid_bal;
                        FETCH c_epis_hid_bal
                            INTO l_epis_hid_bal;
                        l_found := c_epis_hid_bal%FOUND;
                        CLOSE c_epis_hid_bal;
                        --
                        IF l_found
                           OR i_flg_status = pk_inp_hidrics_constant.g_epis_hidric_o
                        THEN
                            -- Balance without deatil => CANCEL
                            l_eh_hidrics_flg_status := CASE
                                                           WHEN i_flg_status = pk_inp_hidrics_constant.g_epis_hidric_o THEN
                                                            pk_inp_hidrics_constant.g_epis_hidric_o
                                                           ELSE
                                                            pk_inp_hidrics_constant.g_epis_hidric_c
                                                       END;
                            l_eh_hidrics_flg_action  := l_eh_hidrics_flg_status;
                            l_ehb_hidrics_flg_status := l_eh_hidrics_flg_status;
                            l_notes_cancel           := i_notes;
                            l_id_prof_cancel         := i_prof.id;
                            l_dt_cancel              := g_sysdate_tstz;
                        ELSE
                            -- Balance with detail => INTERRUPT, even though I_FLG_STATUS='C'
                            l_eh_hidrics_flg_status  := pk_inp_hidrics_constant.g_epis_hidric_i;
                            l_eh_hidrics_flg_action  := pk_inp_hidrics_constant.g_flg_action_i;
                            l_ehb_hidrics_flg_status := pk_inp_hidrics_constant.g_epis_hidric_i;
                            l_notes_inter            := i_notes;
                            l_id_prof_inter          := i_prof.id;
                            l_dt_inter               := g_sysdate_tstz;
                        END IF;
                    END IF;
                ELSE
                    -- INTERRUPT
                    l_eh_hidrics_flg_status  := pk_inp_hidrics_constant.g_epis_hidric_i;
                    l_eh_hidrics_flg_action  := pk_inp_hidrics_constant.g_flg_action_i;
                    l_ehb_hidrics_flg_status := pk_inp_hidrics_constant.g_epis_hidric_i;
                    l_notes_inter            := i_notes;
                    l_id_prof_inter          := i_prof.id;
                    l_dt_inter               := g_sysdate_tstz;
                END IF;
                --
                IF i_flg_status <> pk_inp_hidrics_constant.g_epis_hidric_o
                THEN
                    g_error := 'SEND TO HIST - HIDRICS_BALANCE id_epis_hidrics_balance = ' || i_epis_hid_bal;
                    pk_alertlog.log_debug(g_error);
                    set_epis_hid_bal_hist(i_epis_hidrics_balance => i_epis_hid_bal);
                    --                    
                    g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD WITH EPIS_HIDRICS_BAL = ' || i_epis_hid_bal;
                    pk_alertlog.log_debug(g_error);
                    l_rowids := table_varchar();
                    ts_epis_hidrics_balance.upd(id_epis_hidrics_balance_in => i_epis_hid_bal,
                                                flg_status_in              => l_ehb_hidrics_flg_status,
                                                dt_close_balance_tstz_in   => g_sysdate_tstz,
                                                id_prof_last_change_in     => i_prof.id,
                                                dt_eh_balance_in           => g_sysdate_tstz,
                                                rows_out                   => l_rowids);
                
                    g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS_BALANCE ' || i_epis_hid_bal;
                    pk_alertlog.log_debug(g_error);
                    t_data_gov_mnt.process_update(i_lang,
                                                  i_prof,
                                                  'EPIS_HIDRICS_BALANCE',
                                                  l_rowids,
                                                  o_error,
                                                  table_varchar('FLG_STATUS', 'DT_CLOSE_BALANCE_TSTZ'));
                
                END IF;
                -- 
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || i_epis_hidrics;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_hist(i_epis_hidrics => i_epis_hidrics);
                --
                g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS = ' || i_epis_hidrics;
                pk_alertlog.log_debug(g_error);
                l_rowids := table_varchar();
                ts_epis_hidrics.upd(id_epis_hidrics_in => i_epis_hidrics,
                                    flg_status_in      => l_eh_hidrics_flg_status,
                                    --
                                    id_prof_cancel_in => l_id_prof_cancel,
                                    notes_cancel_in   => l_notes_cancel,
                                    dt_cancel_tstz_in => l_dt_cancel,
                                    --
                                    id_prof_inter_in => l_id_prof_inter,
                                    notes_inter_in   => l_notes_inter,
                                    dt_inter_tstz_in => l_dt_inter,
                                    --
                                    id_prof_last_change_in => i_prof.id,
                                    dt_epis_hidrics_in     => g_sysdate_tstz,
                                    flg_action_in          => l_eh_hidrics_flg_action,
                                    rows_out               => l_rowids);
            
                g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS ' || i_epis_hidrics;
                pk_alertlog.log_debug(g_error);
                t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
            
                g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => 'SET_EPIS_HID_STATUS');
                IF NOT check_restriction_alerts(i_lang         => i_lang,
                                                i_prof         => i_prof,
                                                i_episode      => NULL,
                                                i_epis_hidrics => i_epis_hidrics,
                                                i_epis_balance => i_epis_hid_bal,
                                                i_max_intake   => NULL,
                                                i_min_output   => NULL,
                                                i_hidrics_type => NULL,
                                                i_flg_context  => pk_inp_hidrics_constant.g_context_end_balance,
                                                i_dt_execution => NULL,
                                                o_msg_title    => l_msg_title,
                                                o_msg_text     => l_msg_text,
                                                o_error        => o_error)
                THEN
                    RAISE e_error;
                END IF;
            
            END IF;
        
            --De or associate Integration of Therapeutic Attitudes (António Neto ALERT-164844)
            IF l_flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e)
               AND i_flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_i,
                                    pk_inp_hidrics_constant.g_epis_hidric_c,
                                    pk_inp_hidrics_constant.g_epis_hidric_f,
                                    pk_inp_hidrics_constant.g_epis_hidric_o)
            THEN
                IF NOT cancel_assoc_icnp_interv(i_lang            => i_lang,
                                                i_prof            => i_prof,
                                                i_id_epis_hidrics => i_epis_hidrics,
                                                o_error           => o_error)
                THEN
                    RAISE l_icnp_interv;
                END IF;
            ELSIF i_flg_status = pk_inp_hidrics_constant.g_epis_hidric_r
            THEN
                IF NOT create_assoc_icnp_interv(i_lang            => i_lang,
                                                i_prof            => i_prof,
                                                i_id_epis_hidrics => i_epis_hidrics,
                                                i_id_episode      => l_id_episode,
                                                i_id_hidrics_type => l_id_hidrics_type,
                                                o_error           => o_error)
                
                THEN
                    RAISE l_icnp_interv;
                END IF;
            END IF;
        END IF;
    
        -- IF tasks are reactivated
        IF i_flg_status = pk_inp_hidrics_constant.g_epis_hidric_a
        THEN
            g_error := 'GET L_NEW_FLG_STATUS';
            BEGIN
                SELECT eh.flg_status,
                       eh.id_episode,
                       ht.acronym,
                       pk_translation.get_translation(i_lang, ht.code_hidrics_type)
                  INTO l_old_flg_status, l_id_episode, l_hidric_type_acronym, l_desc_task
                  FROM epis_hidrics eh
                 INNER JOIN hidrics_type ht
                    ON (ht.id_hidrics_type = eh.id_hidrics_type)
                 WHERE eh.id_epis_hidrics = i_epis_hidrics;
            EXCEPTION
                WHEN no_data_found THEN
                    RETURN FALSE;
            END;
        
            IF l_old_flg_status = pk_inp_hidrics_constant.g_epis_hidric_c
            THEN
                l_new_flg_status := pk_inp_hidrics_constant.g_epis_hidric_r;
                l_new_flg_action := pk_inp_hidrics_constant.g_flg_action_r;
            ELSE
                l_new_flg_status := pk_inp_hidrics_constant.g_epis_hidric_e;
                l_new_flg_action := pk_inp_hidrics_constant.g_flg_action_e;
            END IF;
        
            IF NOT check_existing_hidrics_task(i_lang       => i_lang,
                                               i_prof       => i_prof,
                                               i_id_episode => l_id_episode,
                                               i_acronym    => l_hidric_type_acronym,
                                               o_exists     => l_exists_other_task,
                                               o_msg        => o_msg_error,
                                               o_error      => o_error)
            THEN
                RETURN FALSE;
            END IF;
        
            IF l_exists_other_task = pk_alert_constant.g_yes
            THEN
                NULL;
                o_msg_error := to_char(pk_utils.replaceclob(pk_message.get_message(i_lang, 'HIDRICS_T089'),
                                                            '@1',
                                                            l_desc_task));
                RETURN FALSE;
            ELSE
                g_error := 'CALL PK_INP_HIDRICS.SET_REACTIVATE_HIDRIC (i_flg_status=A AND new_status=' ||
                           l_new_flg_status || ')';
                IF NOT set_reactivate_hidric(i_lang         => i_lang,
                                             i_prof         => i_prof,
                                             i_epis_hidrics => i_epis_hidrics,
                                             i_flg_status   => l_new_flg_status,
                                             i_notes        => i_notes,
                                             i_flg_action   => l_new_flg_action,
                                             o_error        => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            END IF;
        END IF;
    
        --
        g_error := 'OPEN C_EPIS_HIDRICS';
        OPEN c_epis_hidrics;
        FETCH c_epis_hidrics
            INTO l_episode;
        CLOSE c_epis_hidrics;
        --
    
        -- INPATIENT LMAIA 16-01-2009
        IF l_episode IS NOT NULL
        THEN
            -- INPATIENT LMAIA 16-01-2009
            SELECT ht.flg_ti_type, ht.acronym
              INTO l_flg_ti_type, l_ht_acronym
              FROM epis_hidrics eh
              JOIN hidrics_type ht
                ON ht.id_hidrics_type = eh.id_hidrics_type
             WHERE eh.id_epis_hidrics = i_epis_hidrics;
        
            -- writting into the status log
            g_error := 'CALL TO T_TI_LOG.INS_LOG';
            pk_alertlog.log_debug(g_error);
            IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                     i_prof       => i_prof,
                                     i_id_episode => l_episode,
                                     i_flg_status => i_flg_status,
                                     i_id_record  => i_epis_hidrics,
                                     i_flg_type   => l_flg_ti_type,
                                     o_error      => o_error))
            THEN
                RAISE t_ti_log_ins_exception;
            END IF;
        END IF;
    
        --
        RETURN TRUE;
    
    EXCEPTION
    
        WHEN t_ti_log_ins_exception THEN
            DECLARE
                l_error_in      t_error_in := t_error_in();
                l_error_message VARCHAR2(4000) := pk_message.get_message(i_lang, 'COMMON_M001');
            BEGIN
                l_error_in.set_all(i_lang,
                                   'ERR_WRITTING_LOG',
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   'SET_EPIS_HID_STATUS');
                l_error_in.set_action(l_error_message, 'S');
                g_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_EPIS_HID_STATUS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_epis_hid_status;

    /**********************************************************************************************
    * SET_EPIS_HID_STATUS                    This function change Intake and Output status from:
    *                                             * Required to Interrupted
    *                                             * In execution to Interrupted
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_epis_hidrics                  epis_hidrics ID
    * @param i_flg_status                    FLG_STATUS of this registry 
    * @param i_notes                         notes
    * @param i_flg_reactivate                Y-reactivate mode-> only consider inactive ou cancelled registries
    * @param o_msg_error                     Message of error to display to user
    * @param o_error                         Error object
    *
    * @value I_FLG_TASK_STATUS               {*} 'C' Cancel {*} 'I' Interrupt
    * @value I_FLG_TASK_STATUS               {*} 'D' Draft {*} 'F' Final
    *
    * @return                                Success / fail
    *
    * @author                                Emilia Taborda
    * @version                               0.1
    * @since                                 2006/11/21
    *
    * @author                                Carlos Ferreira
    * @version                               0.2
    * @since                                 2007-03-21
    *
    * @author                                Luï¿½Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/17
    **********************************************************************************************/

    FUNCTION set_epis_hid_status
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_status      IN epis_hidrics.flg_status%TYPE,
        i_notes           IN epis_hidrics.notes%TYPE,
        i_flg_task_status IN epis_hidrics.flg_status%TYPE DEFAULT g_flg_task_status_f,
        i_flg_reactivate  IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        --i_flg_action      IN epis_hidrics.flg_action%TYPE,
        o_msg_error OUT VARCHAR2,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_hid_bal epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
    BEGIN
        --
        IF (i_flg_reactivate = pk_alert_constant.g_yes)
        THEN
            SELECT ehb.id_epis_hidrics_balance
              INTO l_epis_hid_bal
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics = i_epis_hidrics
               AND ehb.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_i, pk_inp_hidrics_constant.g_epis_hidric_c);
        ELSE
            SELECT ehb.id_epis_hidrics_balance
              INTO l_epis_hid_bal
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics = i_epis_hidrics
               AND ehb.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r,
                                      pk_inp_hidrics_constant.g_epis_hidric_e,
                                      pk_inp_hidrics_constant.g_epis_hidric_d,
                                      pk_inp_hidrics_constant.g_epis_hidric_i,
                                      pk_inp_hidrics_constant.g_epis_hidric_c);
        END IF;
    
        --
        g_error := 'CALL PK_INP_HIDRICS.SET_EPIS_HID_STATUS';
        pk_alertlog.log_debug(g_error);
        IF NOT set_epis_hid_status(i_lang            => i_lang,
                                   i_prof            => i_prof,
                                   i_epis_hidrics    => i_epis_hidrics,
                                   i_epis_hid_bal    => l_epis_hid_bal,
                                   i_flg_status      => i_flg_status,
                                   i_notes           => i_notes,
                                   i_flg_task_status => i_flg_task_status,
                                   --i_flg_action => i_flg_action,
                                   o_msg_error => o_msg_error,
                                   o_error     => o_error)
        THEN
            RETURN FALSE;
        END IF;
        --
        RETURN TRUE;
    END set_epis_hid_status;

    /**********************************************************************************************
    * set_dt_first_reg_balance   Sets the date of first execution in all hidrics det in the same balance
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_epis_hidrics                  epis_hidrics ID
    * @param i_epis_hid_bal                  epis_hidrics_balance ID
    
    * @param o_error                         Error object
    
    *
    * @return                                Success / fail
    *
    *
    * @author                                José Silva
    * @version                               2.6.0.3
    * @since                                 2010/06/10
    **********************************************************************************************/
    FUNCTION set_dt_first_reg_balance
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hid_bal IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dt_reg_bal epis_hidrics_det.dt_first_reg_balance%TYPE;
        l_aux_rows   table_varchar;
        l_aux_where  VARCHAR2(32000);
    BEGIN
        --
        g_error := 'GET DT FIRST RECORD';
        SELECT MIN(ed.dt_execution_tstz)
          INTO l_dt_reg_bal
          FROM epis_hidrics_det ed
         WHERE ed.id_epis_hidrics_balance = i_epis_hid_bal;
        --
        l_aux_where := 'id_epis_hidrics_balance = ' || i_epis_hid_bal ||
                       ' and dt_execution_tstz <> pk_date_utils.get_string_tstz(' || --
                       i_lang || ', ' || --
                       'profissional(' || i_prof.id || ', ' || i_prof.institution || ', ' || i_prof.software || '), ''' || --
                       pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_dt_reg_bal, i_prof => i_prof) ||
                       ''', NULL)';
    
        g_error := 'UPDATE REC WHERE: ' || l_aux_where;
        alertlog.pk_alertlog.log_info(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => 'SET_DT_FIRST_REG_BALANCE');
        ts_epis_hidrics_det.upd(dt_first_reg_balance_in  => l_dt_reg_bal,
                                dt_first_reg_balance_nin => FALSE,
                                id_prof_last_change_in   => i_prof.id,
                                where_in                 => l_aux_where,
                                rows_out                 => l_aux_rows);
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_DT_FIRST_REG_BALANCE',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_dt_first_reg_balance;

    /********************************************************************************************
    * CANCEL_HIDRIC_LIST                     Function responsable for cancel one hidric draft task
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_episode                 episode id 
    * @param       i_epis_hid_list           list of epis_hidrics ids
    * @param       o_cancelled_drafts        List of drafts that were already cancelled
    * @param       o_error                   error message
    *        
    * @return      boolean                   true on success, otherwise false
    * 
    * @author                                Luï¿½Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/19
    ********************************************************************************************/
    FUNCTION cancel_hidric_list
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_epis_hid_list    IN table_number,
        o_cancelled_drafts OUT table_number,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_msg_error sys_message.desc_message%TYPE;
        error_in_epis_hidric_reg EXCEPTION;
    
        l_flg_status       epis_hidrics.flg_status%TYPE := NULL;
        l_cancelled_drafts table_number := table_number();
    BEGIN
        --
        FOR i IN 1 .. i_epis_hid_list.count
        LOOP
        
            BEGIN
                g_error := 'VALIDATE THAT ID_EPIS_HIDRICS CORRENPONDS TO ID_EPISODE';
                pk_alertlog.log_debug(g_error);
                SELECT eh.flg_status
                  INTO l_flg_status
                  FROM epis_hidrics eh
                 WHERE eh.id_epis_hidrics = i_epis_hid_list(i)
                   AND eh.id_episode = i_episode;
            EXCEPTION
                WHEN no_data_found THEN
                    pk_alert_exceptions.process_error(i_lang,
                                                      'EPIS_HIDRICS_ERROR',
                                                      'CURRENT EPISODE DOES''T MATCH WITH CURRENT HIDRIC REGISTRY',
                                                      g_error,
                                                      g_package_owner,
                                                      g_package_name,
                                                      'CANCEL_HIDRIC_LIST',
                                                      o_error);
                    pk_utils.undo_changes;
                    pk_alert_exceptions.reset_error_state;
                    RETURN FALSE;
            END;
        
            IF (l_flg_status NOT IN (pk_inp_hidrics_constant.g_epis_hidric_l, pk_inp_hidrics_constant.g_epis_hidric_o))
            THEN
            
                g_error := 'CALL PK_INP_HIDRICS.SET_EPIS_HID_STATUS WITH ID_EPIS_HIDRIC = ' || i_epis_hid_list(i);
                pk_alertlog.log_debug(g_error);
                IF NOT set_epis_hid_status(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_epis_hidrics    => i_epis_hid_list(i),
                                           i_flg_status      => pk_inp_hidrics_constant.g_epis_hidric_c,
                                           i_notes           => NULL,
                                           i_flg_task_status => pk_inp_hidrics_constant.g_flg_task_status_d,
                                           o_msg_error       => l_msg_error,
                                           o_error           => o_error)
                THEN
                    RETURN FALSE;
                END IF;
                pk_alertlog.log_debug('RESULT FROM CALL TO PK_INP_HIDRICS.SET_EPIS_HID_STATUS: ' || l_msg_error);
            
            ELSE
                l_cancelled_drafts.extend(1);
                l_cancelled_drafts(l_cancelled_drafts.last) := i_epis_hid_list(i);
            
            END IF;
        END LOOP;
    
        o_cancelled_drafts := l_cancelled_drafts;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_HIDRIC_LIST',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END cancel_hidric_list;

    /********************************************************************************************
      * return the sum off all hidrics values (administration and elimination) for a determinate
      * interval date. 
      * Function to the Reports team.
      *
      * @param i_lang        Id language
    * @param i_prof        Id professional 
      * @param i_episode     ID episode
      
      * @param o_hidrics     cursor with the sum hidrics values (administration and elimination)
      *                      and result of (administration minus elimination)
      * @param o_error       error
      *
      *
      * @author              Filipe Silva
    * @version             2.5.0.6
      * @since               2009/09/01
         ********************************************************************************************/
    FUNCTION get_last_hidrics_report
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        o_hidrics OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_total_admin epis_hidrics_det.value_hidrics%TYPE;
        l_total_elim  epis_hidrics_det.value_hidrics%TYPE;
        l_value       sys_config.value%TYPE;
        l_day_hours   PLS_INTEGER := 24;
    BEGIN
    
        g_error := 'GET HIDRICS_REPORT_HAND_OFF config';
        pk_alertlog.log_debug(g_error);
        l_value := pk_sysconfig.get_config('HIDRICS_REPORT_HAND_OFF', i_prof);
    
        -- get the sum off all hidrics values (administration)
        g_error := 'GET THE SUM OFF ALL HIDRICS VALUES ADMINISTRATION';
        pk_alertlog.log_debug(g_error);
        SELECT SUM(ehd.value_hidrics)
          INTO l_total_admin
          FROM epis_hidrics_det ehd, epis_hidrics eh, hidrics h, epis_hidrics_line ehl
         WHERE h.id_hidrics = ehl.id_hidrics
           AND ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line
           AND ehd.id_epis_hidrics = eh.id_epis_hidrics
           AND eh.id_episode = i_episode
           AND h.flg_type = pk_inp_hidrics_constant.g_hidrics_flg_type_a --administration
           AND ehd.dt_execution_tstz >= current_timestamp - l_value / l_day_hours
           AND nvl(ehd.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
               pk_inp_hidrics_constant.g_epis_hid_det_type_a
           AND ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a;
    
        -- get the sum off all hidrics values (elimination)
        g_error := 'GET THE SUM OFF ALL HIDRICS VALUES ELIMINATION';
        pk_alertlog.log_debug(g_error);
        SELECT SUM(ehd.value_hidrics)
          INTO l_total_elim
          FROM epis_hidrics_det ehd, epis_hidrics eh, hidrics h, epis_hidrics_line ehl
         WHERE h.id_hidrics = ehl.id_hidrics
           AND ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line
           AND ehd.id_epis_hidrics = eh.id_epis_hidrics
           AND eh.id_episode = i_episode
           AND h.flg_type = pk_inp_hidrics_constant.g_hidrics_flg_type_e -- elimination
           AND ehd.dt_execution_tstz >= current_timestamp - l_value / l_day_hours
           AND nvl(ehd.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
               pk_inp_hidrics_constant.g_epis_hid_det_type_a
           AND ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a;
    
        g_error := 'OPEN O_HIDRICS CURSOR';
        pk_alertlog.log_debug(g_error);
        OPEN o_hidrics FOR
            SELECT l_total_admin AS total_admin, l_total_elim AS total_elim, (l_total_admin - l_total_elim) AS results
              FROM dual;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_LAST_HIDRICS_REPORT',
                                              o_error);
            pk_types.open_my_cursor(o_hidrics);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END;

    /***************************************************************************************************************
    * GET_EPIS_DT_BEGIN              Simple function to return an episode's start date. 
    *                                Used for validation of the beginning date of an intake/outtake balance.
    *  
    * @param      i_lang             language ID
    * @param      i_prof             ALERT profissional 
    * @param      i_episode          ID_EPISODE to check
    * @param      o_dt_begin         Date of the start of the provided episode
    * @param      o_error            If an error accurs, this parameter will have information about the error
    *
    *
    * @RETURN  TRUE or FALSE
    * 
    * @author  RicardoNunoAlmeida
    * @version 2.5.0.6.1
    * @since   06-10-2009
    ****************************************************************************************************/
    FUNCTION get_epis_dt_begin
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_episode  IN episode.id_episode%TYPE,
        o_dt_begin OUT VARCHAR2,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'GET EPIS BEGIN DATE';
        SELECT pk_date_utils.date_send_tsz(i_lang, e.dt_begin_tstz, i_prof)
          INTO o_dt_begin
          FROM episode e
         WHERE e.id_episode = i_episode;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_DT_BEGIN',
                                              o_error);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_epis_dt_begin;

    /************************************************************************************************************ 
    *  Actualize collumn hidrics in table GRID_TASK
    *
    * @param      i_lang           language ID
    * @param      i_prof           professional information
    * @param      i_patient        patient ID
    * @param      i_episode        episode ID
    * @param      i_task_request   array of task requests (if null, return all tasks as usual)
    * @param      i_filter_tstz    Date to filter only the records with "end dates" > i_filter_tstz
    * @param      i_filter_status  Array with task status to consider along with i_filter_tstz
    * @param      i_flg_report     Required in all get_task_list APIs
    * @param      o_grid           Cursor with all data
    * @param      o_error          error information
    *    
    * @author     Luï¿½Maia
    * @version    2.5.0.7
    * @since      2009/10/26
    *
    * @dependencies    This function was developed to Content team
    ***********************************************************************************************************/
    FUNCTION get_task_list
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_patient       IN patient.id_patient%TYPE,
        i_episode       IN episode.id_episode%TYPE,
        i_task_request  IN table_number,
        i_filter_tstz   IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_filter_status IN table_varchar,
        i_flg_report    IN VARCHAR2 DEFAULT 'N',
        i_dt_begin      IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_dt_end        IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_plan_list     OUT pk_types.cursor_type,
        o_grid          OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        --
        CURSOR c_inst IS
            SELECT epi.id_institution, epi.id_visit, epi.id_epis_type
              FROM episode epi
             WHERE epi.id_episode = i_episode;
        --
        l_inst         c_inst%ROWTYPE;
        l_epis_hidrics table_number;
        l_exception EXCEPTION;
    
        l_cancelled_task_filter_interval sys_config.value%TYPE := pk_sysconfig.get_config('CPOE_CANCELLED_TASK_FILTER_INTERVAL',
                                                                                          i_prof);
        l_cancelled_task_filter_tstz     TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
    
        l_cancelled_task_filter_tstz := current_timestamp -
                                        numtodsinterval(to_number(l_cancelled_task_filter_interval), 'DAY');
        --
        -- GET ID_VISIT FROM CURRENT EPISODE
        g_error := 'GET CURSOR - INSTITUTION, VISIT AND EPIS_TYPE';
        OPEN c_inst;
        FETCH c_inst
            INTO l_inst;
        CLOSE c_inst;
    
        -- GET ID_EPIS_HIDRICS DEPENDING OF PARAMETER i_task_request
        g_error := 'GET ID_EPIS_HIDRICS identifiers';
        IF (i_task_request IS NULL)
           OR (i_task_request.count = 0)
        THEN
            SELECT DISTINCT eh.id_epis_hidrics
              BULK COLLECT
              INTO l_epis_hidrics
              FROM epis_hidrics eh
             WHERE eh.id_episode IN (SELECT DISTINCT (epi.id_episode)
                                       FROM episode epi
                                      WHERE epi.id_visit = l_inst.id_visit);
        ELSE
            l_epis_hidrics := i_task_request;
        END IF;
    
        -- GET RESULT TO RETURN
        g_error := 'GET CURSOR O_GRID';
        OPEN o_grid FOR
            SELECT ht.id_hidrics_type task_type,
                   -- Return description of the intake and outake with software where it was requested (if not actual software)
                   decode(l_inst.id_epis_type,
                          nvl(t_ti_log.get_epis_type(i_lang,
                                                     i_prof,
                                                     epi.id_epis_type,
                                                     pk_inp_hidrics_constant.g_epis_hidric_r,
                                                     eh.id_epis_hidrics,
                                                     ht.flg_ti_type),
                              epi.id_epis_type),
                          pk_translation.get_translation(i_lang, ht.code_hidrics_type),
                          pk_translation.get_translation(i_lang, ht.code_hidrics_type) || ' (' ||
                          pk_message.get_message(i_lang,
                                                 profissional(i_prof.id,
                                                              i_prof.institution,
                                                              t_ti_log.get_epis_type_soft(i_lang,
                                                                                          i_prof,
                                                                                          epi.id_epis_type,
                                                                                          pk_inp_hidrics_constant.g_epis_hidric_r,
                                                                                          eh.id_epis_hidrics,
                                                                                          ht.flg_ti_type)),
                                                 'IMAGE_T009') || ')') task_description,
                   -- END
                   decode(eh.flg_status, pk_inp_hidrics_constant.g_epis_hidric_c, eh.id_prof_cancel, eh.id_professional) id_professional,
                   NULL icon_warning,
                   get_epis_status_string(i_lang, i_prof, eh.id_epis_hidrics) status_str,
                   eh.id_epis_hidrics id_request,
                   eh.dt_initial_tstz start_date_tstz,
                   eh.dt_end_tstz end_date_tstz,
                   nvl(eh.update_time, eh.dt_creation_tstz) creation_date_tstz,
                   eh.flg_status flg_status,
                   decode(eh.flg_status,
                          pk_inp_hidrics_constant.g_epis_hidric_c,
                          pk_alert_constant.g_no,
                          pk_inp_hidrics_constant.g_epis_hidric_i,
                          pk_alert_constant.g_no,
                          pk_inp_hidrics_constant.g_epis_hidric_f,
                          pk_alert_constant.g_no,
                          pk_inp_hidrics_constant.g_epis_hidric_e,
                          pk_alert_constant.g_yes,
                          pk_inp_hidrics_constant.g_epis_hidric_r,
                          pk_alert_constant.g_yes,
                          pk_inp_hidrics_constant.g_epis_hidric_d,
                          pk_alert_constant.g_yes,
                          pk_inp_hidrics_constant.g_epis_hidric_o,
                          pk_alert_constant.g_no,
                          pk_alert_constant.g_no) flg_cancel,
                   pk_alert_constant.g_no flg_conflict,
                   NULL id_task,
                   --New Fields for CPOE API in Reports
                   --ALERT-202996 (AN)
                   decode(i_flg_report,
                          pk_alert_constant.g_yes,
                          decode(l_inst.id_epis_type,
                                 nvl(t_ti_log.get_epis_type(i_lang,
                                                            i_prof,
                                                            epi.id_epis_type,
                                                            pk_inp_hidrics_constant.g_epis_hidric_r,
                                                            eh.id_epis_hidrics,
                                                            ht.flg_ti_type),
                                     epi.id_epis_type),
                                 pk_translation.get_translation(i_lang, ht.code_hidrics_type),
                                 pk_translation.get_translation(i_lang, ht.code_hidrics_type) || ' (' ||
                                 pk_message.get_message(i_lang,
                                                        profissional(i_prof.id,
                                                                     i_prof.institution,
                                                                     t_ti_log.get_epis_type_soft(i_lang,
                                                                                                 i_prof,
                                                                                                 epi.id_epis_type,
                                                                                                 pk_inp_hidrics_constant.g_epis_hidric_r,
                                                                                                 eh.id_epis_hidrics,
                                                                                                 ht.flg_ti_type)),
                                                        'IMAGE_T009') || ')')) task_title,
                   decode(i_flg_report,
                          pk_alert_constant.g_yes,
                          get_hid_interval_desc_int(i_lang, i_prof, hi.id_hidrics_interval, eh.interval_minutes)) task_instructions,
                   decode(i_flg_report,
                          pk_alert_constant.g_yes,
                          decode(coalesce(eh.notes_cancel, eh.notes_inter, eh.notes),
                                 NULL,
                                 NULL,
                                 decode(eh.flg_status,
                                        pk_inp_positioning.g_epis_posit_c,
                                        eh.notes_cancel,
                                        pk_inp_positioning.g_epis_posit_o,
                                        eh.notes_cancel,
                                        pk_inp_positioning.g_epis_posit_i,
                                        eh.notes_inter,
                                        eh.notes))) task_notes,
                   NULL drug_dose,
                   NULL drug_route,
                   NULL drug_take_in_case,
                   decode(i_flg_report,
                          pk_alert_constant.g_yes,
                          pk_sysdomain.get_domain('EPIS_HIDRICS.FLG_STATUS', eh.flg_status, i_lang)) task_status,
                   NULL AS instr_bg_color,
                   NULL AS instr_bg_alpha,
                   NULL AS task_icon,
                   pk_alert_constant.g_no AS flg_need_ack,
                   NULL AS edit_icon,
                   NULL AS action_desc,
                   NULL AS previous_status,
                   pk_alert_constant.g_task_inp_hidrics AS id_task_type_source,
                   NULL AS id_task_dependency,
                   decode(eh.flg_status,
                          pk_inp_hidrics_constant.g_epis_hidric_c,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_rep_cancel,
                   NULL flg_prn_conditional
              FROM epis_hidrics eh
             INNER JOIN episode epi
                ON (eh.id_episode = epi.id_episode)
             INNER JOIN epis_hidrics_balance ehb
                ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
             INNER JOIN hidrics_type ht
                ON (eh.id_hidrics_type = ht.id_hidrics_type)
             INNER JOIN hidrics_interval hi
                ON (eh.id_hidrics_interval = hi.id_hidrics_interval)
             INNER JOIN (SELECT t.id_epis_hidrics_balance max_balance, t.id_epis_hidrics
                           FROM (SELECT ehb1.id_epis_hidrics_balance,
                                        eh1.id_epis_hidrics,
                                        row_number() over(PARTITION BY eh1.id_epis_hidrics ORDER BY ehb1.dt_register_tstz DESC) rn
                                   FROM epis_hidrics_balance ehb1, epis_hidrics eh1
                                  WHERE eh1.id_epis_hidrics IN (SELECT /*+ OPT_ESTIMATE (TABLE ehid ROWS=0.0001)*/
                                                                 column_value
                                                                  FROM TABLE(l_epis_hidrics) ehid)
                                    AND eh1.id_epis_hidrics = ehb1.id_epis_hidrics) t
                          WHERE rn = 1) ehb2
                ON (ehb.id_epis_hidrics_balance = ehb2.max_balance)
             WHERE eh.id_epis_hidrics IN (SELECT /*+ OPT_ESTIMATE (TABLE ehi ROWS=0.0001)*/
                                           column_value
                                            FROM TABLE(l_epis_hidrics) ehi)
               AND eh.flg_status <> pk_inp_hidrics_constant.g_epis_hidric_l
                  --
               AND (eh.flg_status NOT IN (SELECT /*+ OPT_ESTIMATE (TABLE t ROWS=0.1)*/
                                           t.column_value
                                            FROM TABLE(i_filter_status) t) OR
                   ((i_filter_tstz < CASE
                       WHEN eh.flg_status = pk_inp_hidrics_constant.g_epis_hidric_i THEN
                        eh.dt_inter_tstz --
                       WHEN eh.flg_status = pk_inp_hidrics_constant.g_epis_hidric_f THEN
                        eh.dt_end_tstz --   
                       ELSE
                        eh.dt_initial_tstz
                   END) AND eh.flg_status NOT IN
                   (pk_inp_hidrics_constant.g_epis_hidric_c, pk_inp_hidrics_constant.g_epis_hidric_o)) OR
                   (l_cancelled_task_filter_tstz < eh.dt_cancel_tstz AND
                   eh.flg_status IN
                   (pk_inp_hidrics_constant.g_epis_hidric_c, pk_inp_hidrics_constant.g_epis_hidric_o)))
            
             ORDER BY pk_sysdomain.get_rank(i_lang, 'EPIS_HIDRICS_BALANCE.FLG_STATUS', ehb.flg_status),
                      ehb.id_epis_hidrics_balance DESC;
    
        IF i_flg_report = pk_alert_constant.g_yes
        THEN
        
            IF NOT get_order_plan_report(i_lang          => i_lang,
                                         i_prof          => i_prof,
                                         i_episode       => i_episode,
                                         i_task_request  => i_task_request,
                                         i_cpoe_dt_begin => i_dt_begin,
                                         i_cpoe_dt_end   => i_dt_end,
                                         o_plan_rep      => o_plan_list,
                                         o_error         => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END IF;
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TASK_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_grid);
            RETURN FALSE;
    END get_task_list;

    /********************************************************************************************
    * GET_TASK_ACTIONS                       get available actions for a requested task
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_episode                 episode id
    * @param       i_task_request            task request id (also used for drafts)
    * @param       o_actions_list            list of available actions for the task request
    * @param       o_error                   error message
    *
    * @return      boolean                   true on success, otherwise false
    *
    * @author                                Luï¿½Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/19
    ********************************************************************************************/
    FUNCTION get_task_actions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        o_actions_list OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_hid_status         epis_hidrics.flg_status%TYPE;
        l_flg_status_expired epis_hidrics.flg_status%TYPE;
    
        l_flg_edit CONSTANT action.to_state%TYPE := 'T';
        l_flg_exec CONSTANT action.to_state%TYPE := 'E';
        l_subject  CONSTANT action.subject%TYPE := 'INP_HIDRICS';
    
    BEGIN
        g_error := 'FETCH flg_status from epis_hidrics for id_episode = ' || i_episode || ' and id_epis_hidrics = ' ||
                   i_epis_hidrics;
        SELECT eh.flg_status
          INTO l_hid_status
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        g_error := 'check if status expired the professional is able to execute a last time';
        IF l_hid_status = pk_inp_hidrics_constant.g_epis_hidric_o
           AND check_extra_take(i_lang         => i_lang,
                                i_prof         => i_prof,
                                i_episode      => i_episode,
                                i_task_request => i_epis_hidrics) = pk_alert_constant.g_no
        THEN
            l_flg_status_expired := l_hid_status;
        END IF;
    
        g_error := 'CALL PK_ACTION.TF_GET_ACTIONS';
        OPEN o_actions_list FOR
            SELECT id_action,
                   id_parent,
                   level_nr l_level,
                   l_hid_status from_state,
                   to_state,
                   desc_action,
                   icon,
                   flg_default,
                   decode(l_hid_status,
                          pk_inp_hidrics_constant.g_epis_hidric_o,
                          decode(to_state,
                                 l_flg_exec,
                                 decode(l_flg_status_expired,
                                        NULL,
                                        pk_alert_constant.g_active,
                                        pk_alert_constant.g_inactive),
                                 pk_alert_constant.g_inactive),
                          act.flg_active) flg_status,
                   action internal_name
              FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, l_subject, l_hid_status)) act
            /*WHERE act.to_state <> l_flg_edit*/
            ;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TASK_ACTIONS',
                                              o_error);
            pk_types.open_cursor_if_closed(o_actions_list);
            RETURN FALSE;
    END get_task_actions;

    /**********************************************************************************************
    * SET_MATCH_HIDRICS                      This function make "match" of Intake and Output tasks between episodes
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_episode_temp                  Temporary episode
    * @param i_episode                       Episode identifier 
    * @param o_error                         Error object
    *
    * @return                                Success / fail
    *
    * @author                                Luï¿½Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/17
    **********************************************************************************************/
    FUNCTION set_match_hidrics
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode_temp IN episode.id_episode%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        i_patient      IN patient.id_patient%TYPE,
        i_patient_temp IN patient.id_patient%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_hid        epis_hidrics.id_epis_hidrics%TYPE;
        l_epis_hid_bal    epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_status          epis_hidrics.flg_status%TYPE;
        l_flg_task_status VARCHAR2(1 CHAR);
        l_msg_error       sys_message.desc_message%TYPE;
        --
        CURSOR c_epis_hid IS
            SELECT eh.id_epis_hidrics,
                   ehb.id_epis_hidrics_balance,
                   decode((SELECT COUNT(0)
                            FROM epis_hidrics_det ehd
                           WHERE ehd.id_epis_hidrics = eh.id_epis_hidrics
                             AND eh.flg_status IN
                                 (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e)),
                          0,
                          pk_inp_hidrics_constant.g_epis_hidric_c,
                          pk_inp_hidrics_constant.g_epis_hidric_i) status,
                   decode(eh.flg_status,
                          pk_inp_hidrics_constant.g_epis_hidric_d,
                          g_flg_task_status_d,
                          g_flg_task_status_f) epis_hid_flg_status
              FROM epis_hidrics eh
             INNER JOIN epis_hidrics_balance ehb
                ON (ehb.id_epis_hidrics = eh.id_epis_hidrics)
             WHERE eh.id_episode IN (i_episode_temp, i_episode)
               AND eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e)
                  -- Será efectuado o UPDATE qd existe mais do que um episódio com o estado R ou E
               AND EXISTS
             (SELECT COUNT(*)
                      FROM epis_hidrics eh1
                     WHERE eh1.id_episode IN (i_episode_temp, i_episode)
                       AND eh1.flg_status IN
                           (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e)
                     HAVING COUNT(*) > 1)
                  --Será £ancelado ou interrompido so episódio com menor data
               AND eh.dt_creation_tstz =
                   (SELECT MIN(eh2.dt_creation_tstz)
                      FROM epis_hidrics eh2
                     WHERE eh2.id_episode IN (i_episode_temp, i_episode)
                       AND eh2.flg_status IN
                           (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e))
               AND ehb.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e);
    
        l_rowids table_varchar;
    BEGIN
        --
        -- HIDRICS "match"
        -- It is only possible in each episode have only one active (required or in execution) Intake and Output registries, pode existir mais do que um epis? activo (requisitado ou em curso),
        -- desta forma torna se necessá²©o garantir que s?ista UM epis? nesse estado
        g_error := 'OPEN C_EPIS_HID';
        OPEN c_epis_hid;
        FETCH c_epis_hid
            INTO l_epis_hid, l_epis_hid_bal, l_status, l_flg_task_status;
        CLOSE c_epis_hid;
        --
        g_error := 'CALL PK_INP_HIDRICS.SET_EPIS_HID_STATUS_PROCESS';
        pk_alertlog.log_debug(g_error);
        --epis_hidrics_balance, epis_hidrics
        IF NOT set_epis_hid_status(i_lang            => i_lang,
                                   i_prof            => i_prof,
                                   i_epis_hidrics    => l_epis_hid,
                                   i_epis_hid_bal    => l_epis_hid_bal,
                                   i_flg_status      => l_status,
                                   i_notes           => NULL,
                                   i_flg_task_status => l_flg_task_status,
                                   o_msg_error       => l_msg_error,
                                   o_error           => o_error)
        THEN
            RETURN FALSE;
        END IF;
        pk_alertlog.log_debug('RESULT FROM CALL TO PK_INP_HIDRICS.SET_EPIS_HID_STATUS: ' || l_msg_error);
    
        --
        g_error := 'SEND TO HIST - EPIS_HIDRICS i_where: id_episode = ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        set_epis_hid_hist(i_where => 'id_episode = ' || i_episode_temp);
        --
        g_error := 'CALL TS_EPIS_HIDRICS_HIST.UPD WITH ID_EPISODE = ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        l_rowids := table_varchar();
        ts_epis_hidrics_hist.upd(id_episode_in          => i_episode,
                                 id_episode_nin         => FALSE,
                                 id_patient_in          => i_patient,
                                 id_patient_nin         => FALSE,
                                 id_prof_last_change_in => i_prof.id,
                                 dt_epis_hidrics_in     => g_sysdate_tstz,
                                 where_in               => 'id_episode = ' || i_episode_temp,
                                 rows_out               => l_rowids);
        --
        g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH ID_EPISODE = ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        l_rowids := table_varchar();
        ts_epis_hidrics.upd(id_episode_in          => i_episode,
                            id_episode_nin         => FALSE,
                            id_patient_in          => i_patient,
                            id_patient_nin         => FALSE,
                            id_prof_last_change_in => i_prof.id,
                            dt_epis_hidrics_in     => g_sysdate_tstz,
                            where_in               => 'id_episode = ' || i_episode_temp,
                            rows_out               => l_rowids);
    
        g_error := 'PROCESS UPDATE WITH ID_EPISODE ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error, table_varchar('ID_EPISODE'));
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_MATCH_HIDRICS',
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_match_hidrics;

    /********************************************************************************************
    * activates a set of draft tasks (task goes from draft to active workflow)
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_episode                 episode id 
    * @param       i_hidrics                 array of selected hidrics 
    * @param       o_error                   error message
    *
    * @return      boolean                   true on success, otherwise false
    *
    * @author                                Luï¿½Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/23
    ********************************************************************************************/
    FUNCTION activate_drafts
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_epis_hidrics  IN table_number,
        o_created_tasks OUT table_number,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_epis_hidrics epis_hidrics.id_epis_hidrics%TYPE;
        l_epis_hidric_row epis_hidrics%ROWTYPE;
    
        l_flg_show  VARCHAR2(1 CHAR);
        l_msg_title sys_message.desc_message%TYPE;
        l_msg       sys_message.desc_message%TYPE;
        --
        l_dt_next_balance epis_hidrics.dt_next_balance%TYPE;
        l_dt_end_tstz     epis_hidrics.dt_end_tstz%TYPE;
        l_minutes_str CONSTANT VARCHAR2(24 CHAR) := 'MINUTE';
    
        l_task_type       task_type.id_task_type%TYPE;
        l_ht_acronym      hidrics_type.acronym%TYPE;
        l_count_rel_tasks NUMBER(24);
        l_exception EXCEPTION;
        l_dt_end TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_draft          table_number;
        l_id_request_val epis_hidrics.id_epis_hidrics%TYPE;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        o_created_tasks := i_epis_hidrics;
    
        g_error := 'CALL TO PK_INP_HIDRICS.SET_HIDRICS';
        pk_alertlog.log_debug(g_error);
        FOR i IN 1 .. i_epis_hidrics.count
        LOOP
        
            SELECT eh.*
              INTO l_epis_hidric_row
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = i_epis_hidrics(i);
        
            g_error := 'Calculate the next Balance Date';
            SELECT pk_date_utils.add_to_ltstz(g_sysdate_tstz,
                                              nvl(hi.interval_minutes, l_epis_hidric_row.interval_minutes),
                                              l_minutes_str)
              INTO l_dt_next_balance
              FROM hidrics_interval hi
             WHERE hi.id_hidrics_interval = l_epis_hidric_row.id_hidrics_interval;
        
            g_error := 'Calculate the Hidric End Date';
            IF l_epis_hidric_row.dt_end_tstz IS NOT NULL
            THEN
                l_dt_end_tstz := pk_date_utils.add_to_ltstz(g_sysdate_tstz,
                                                            abs(pk_date_utils.get_elapsed_minutes_abs(l_epis_hidric_row.dt_initial_tstz) -
                                                                pk_date_utils.get_elapsed_minutes_abs(l_epis_hidric_row.dt_end_tstz)),
                                                            l_minutes_str);
            ELSE
                l_dt_end_tstz := NULL;
            END IF;
        
            SELECT ht.acronym
              INTO l_ht_acronym
              FROM epis_hidrics eh
             INNER JOIN hidrics_type ht
                ON (ht.id_hidrics_type = eh.id_hidrics_type)
             WHERE eh.id_epis_hidrics = l_epis_hidric_row.id_epis_hidrics;
        
            l_task_type := CASE l_ht_acronym
                               WHEN pk_inp_hidrics_constant.g_hid_type_h THEN
                                pk_alert_constant.g_task_type_hidric_in_out
                               WHEN pk_inp_hidrics_constant.g_hid_type_d THEN
                                pk_alert_constant.g_task_type_hidric_out
                               WHEN pk_inp_hidrics_constant.g_hid_type_r THEN
                                pk_alert_constant.g_task_type_hidric_drain
                               WHEN pk_inp_hidrics_constant.g_hid_type_i THEN
                                pk_alert_constant.g_task_type_hidric_in
                               WHEN pk_inp_hidrics_constant.g_hid_type_o THEN
                                pk_alert_constant.g_task_type_hidric_out_group
                               WHEN pk_inp_hidrics_constant.g_hid_type_all THEN
                                pk_alert_constant.g_task_type_hidric_out_all
                               WHEN pk_inp_hidrics_constant.g_hid_type_g THEN
                                pk_alert_constant.g_task_type_hidric_irrigations
                               ELSE
                                NULL
                           END;
            BEGIN
                SELECT a.id_task_orig
                  INTO l_count_rel_tasks
                  FROM cpoe_tasks_relation a
                 WHERE a.id_task_dest = l_epis_hidric_row.id_epis_hidrics
                   AND a.id_task_type = l_task_type
                   AND a.flg_type = 'AD';
            EXCEPTION
                WHEN no_data_found THEN
                    l_count_rel_tasks := 0;
            END;
        
            IF l_count_rel_tasks > 0
            THEN
                SELECT a.dt_end_tstz
                  INTO l_dt_end
                  FROM epis_hidrics a
                 WHERE a.id_epis_hidrics = l_count_rel_tasks;
            
            END IF;
        
            IF l_count_rel_tasks > 0
               AND (l_dt_end IS NULL OR l_dt_end > current_timestamp)
            THEN
            
                IF NOT pk_cpoe.sync_active_to_next(i_lang      => i_lang,
                                                   i_prof      => i_prof,
                                                   i_episode   => i_episode,
                                                   i_task_type => l_task_type,
                                                   i_request   => l_epis_hidric_row.id_epis_hidrics,
                                                   o_error     => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                l_draft := i_epis_hidrics;
            
                FOR i IN 1 .. l_draft.count
                LOOP
                    IF l_draft(i) = l_epis_hidric_row.id_epis_hidrics
                    THEN
                        SELECT a.id_task_orig
                          INTO l_id_request_val
                          FROM cpoe_tasks_relation a
                         WHERE a.id_task_dest = l_epis_hidric_row.id_epis_hidrics;
                        l_draft(i) := l_id_request_val;
                    END IF;
                END LOOP;
            
                IF NOT pk_inp_hidrics_pbl.cancel_draft(i_lang,
                                                       i_prof,
                                                       i_episode,
                                                       table_number(l_epis_hidric_row.id_epis_hidrics),
                                                       l_flg_show,
                                                       l_msg_title,
                                                       l_msg,
                                                       o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                o_created_tasks := l_draft;
            
            ELSE
            
                IF (l_epis_hidric_row.flg_status <> pk_inp_hidrics_constant.g_epis_hidric_l)
                THEN
                    IF NOT set_hidrics(i_lang             => i_lang,
                                       i_prof             => i_prof,
                                       i_episode          => i_episode,
                                       i_patient          => l_epis_hidric_row.id_patient,
                                       i_epis_hidrics     => i_epis_hidrics(i),
                                       i_dt_initial_str   => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                         i_prof => i_prof,
                                                                                         i_date => l_epis_hidric_row.dt_initial_tstz),
                                       i_dt_end_str       => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                         i_prof => i_prof,
                                                                                         i_date => l_dt_end_tstz),
                                       i_dt_next_balance  => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                         i_prof => i_prof,
                                                                                         i_date => l_dt_next_balance),
                                       i_hid_interv       => NULL,
                                       i_interval_minutes => l_epis_hidric_row.interval_minutes,
                                       i_notes            => l_epis_hidric_row.notes,
                                       i_hid_type         => l_epis_hidric_row.id_hidrics_type,
                                       i_unit_measure     => NULL,
                                       i_flg_type         => pk_inp_hidrics_constant.g_create_hidrics_action_u,
                                       i_flg_task_status  => pk_inp_hidrics_constant.g_flg_task_status_f,
                                       i_flg_restricted   => l_epis_hidric_row.flg_restricted,
                                       i_max_intake       => l_epis_hidric_row.max_intake,
                                       i_min_output       => l_epis_hidric_row.min_output,
                                       o_id_epis_hidrics  => l_id_epis_hidrics,
                                       o_flg_show         => l_flg_show,
                                       o_msg_title        => l_msg_title,
                                       o_msg              => l_msg,
                                       o_error            => o_error)
                    THEN
                        RETURN FALSE;
                    END IF;
                END IF;
            END IF;
        END LOOP;
        --
        RETURN TRUE;
    END activate_drafts;

    /********************************************************************************************
    * copy task to draft (from an existing active/inactive task)
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_episode                 episode id (current episode)
    * @param       i_epis_hidrics            epis hidrics id (used for active/inactive tasks)
    * @param       o_id_epis_hidrics         epis hidrics id
    * @param       o_error                   error message
    *
    * @return      boolean                   true on success, otherwise false
    *
    * @author                                Luï¿½Maia
    * @version                               2.5.0.7.3
    * @since                                 2009/11/23
    ********************************************************************************************/
    FUNCTION copy_to_draft
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_epis_hidrics         IN epis_hidrics.id_epis_hidrics%TYPE,
        i_task_start_timestamp IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_task_end_timestamp   IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_id_epis_hidrics      OUT epis_hidrics.id_epis_hidrics%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_hidric_row epis_hidrics%ROWTYPE;
        l_flg_show        VARCHAR2(1 CHAR);
        l_msg_title       sys_message.desc_message%TYPE;
        l_msg             sys_message.desc_message%TYPE;
        l_dt_initial      epis_hidrics.dt_initial_tstz%TYPE;
    BEGIN
        --
        SELECT eh.*
          INTO l_epis_hidric_row
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        IF i_task_start_timestamp IS NOT NULL
        THEN
            l_dt_initial := i_task_start_timestamp;
        ELSE
            l_dt_initial := l_epis_hidric_row.dt_initial_tstz;
        END IF;
    
        --
        g_error := 'CALL TO SET_HIDRICS';
        pk_alertlog.log_debug(g_error);
        IF NOT set_hidrics(i_lang             => i_lang,
                           i_prof             => i_prof,
                           i_episode          => i_episode,
                           i_patient          => l_epis_hidric_row.id_patient,
                           i_epis_hidrics     => NULL,
                           i_dt_initial_str   => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                             i_prof => i_prof,
                                                                             i_date => l_dt_initial),
                           i_dt_end_str       => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                             i_prof => i_prof,
                                                                             i_date => l_epis_hidric_row.dt_end_tstz),
                           i_dt_next_balance  => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                             i_prof => i_prof,
                                                                             i_date => l_epis_hidric_row.dt_next_balance),
                           i_hid_interv       => l_epis_hidric_row.id_hidrics_interval,
                           i_interval_minutes => l_epis_hidric_row.interval_minutes,
                           i_notes            => l_epis_hidric_row.notes,
                           i_hid_type         => l_epis_hidric_row.id_hidrics_type,
                           i_unit_measure     => NULL,
                           i_flg_type         => g_create_hidrics_action_new,
                           i_flg_task_status  => pk_inp_hidrics_constant.g_flg_task_status_d,
                           i_flg_restricted   => l_epis_hidric_row.flg_restricted,
                           i_max_intake       => l_epis_hidric_row.max_intake,
                           i_min_output       => l_epis_hidric_row.min_output,
                           o_id_epis_hidrics  => o_id_epis_hidrics,
                           o_flg_show         => l_flg_show,
                           o_msg_title        => l_msg_title,
                           o_msg              => l_msg,
                           o_error            => o_error)
        THEN
            RETURN FALSE;
        END IF;
        --
        RETURN TRUE;
    END copy_to_draft;

    /***************************************************************************************************************
    * GET_HIDRICS_REG              Returng the grid_task hidrics_reg associated to a visit
    *  
    * @param      i_lang             language ID
    * @param      i_prof             ALERT profissional 
    * @param      i_id_visit         Visit identifier   
    *
    *
    * @RETURN  grid_task.hidrics_reg%TYPE
    * 
    * @author  Sofia Mendes
    * @version 2.5.0.7.7
    * @since   18-02-2010
    ****************************************************************************************************/
    FUNCTION get_hidrics_reg
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_id_visit IN visit.id_visit%TYPE
    ) RETURN grid_task.hidrics_reg%TYPE IS
        l_hidrics_reg            grid_task.hidrics_reg%TYPE;
        l_id_episode             grid_task.id_episode%TYPE;
        l_oldest_id_episode      grid_task.id_episode%TYPE;
        l_error                  t_error_out;
        l_oldest_id_epis_hidrics epis_hidrics.id_epis_hidrics%TYPE;
    BEGIN
        BEGIN
            SELECT e.id_episode
              INTO l_id_episode
              FROM episode e
             WHERE e.id_visit = i_id_visit
               AND rownum = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_episode := NULL;
        END;
    
        IF l_id_episode IS NOT NULL
        THEN
        
            l_oldest_id_epis_hidrics := get_oldest_hid(l_id_episode);
        
            BEGIN
                SELECT eh.id_episode
                  INTO l_oldest_id_episode
                  FROM epis_hidrics eh
                 WHERE eh.id_epis_hidrics = l_oldest_id_epis_hidrics;
            EXCEPTION
                WHEN no_data_found THEN
                    l_oldest_id_episode := NULL;
            END;
        
            BEGIN
                SELECT gt.hidrics_reg
                  INTO l_hidrics_reg
                  FROM grid_task gt
                 WHERE gt.id_episode = l_oldest_id_episode;
            
            EXCEPTION
                WHEN no_data_found THEN
                    l_hidrics_reg := NULL;
            END;
        END IF;
    
        --
        RETURN l_hidrics_reg;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_REG',
                                              l_error);
        
            RETURN NULL;
    END get_hidrics_reg;

    /*******************************************************************************************************************************************
    * check_other_way         Get the ways with flg_way_type='O' (other option)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_id_way                 Wai ID
    * 
    * @return                         Y- the id_way corresponds to the 'Other' options; N-otherwise
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.3.5
    * @since                          15-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION check_other_way
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        i_id_way IN way.id_way%TYPE
    ) RETURN VARCHAR2 IS
        l_other VARCHAR2(1 CHAR);
    BEGIN
        BEGIN
            SELECT decode(hw.flg_way_type,
                          pk_inp_hidrics_constant.g_hid_way_type_o,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no)
              INTO l_other
              FROM way hw
             WHERE hw.id_way = i_id_way;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END;
        --
        RETURN l_other;
    END check_other_way;

    /*******************************************************************************************************************************************
    * check_other_hidric         Check if the device corresponds to the 'Other' option.
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_id_hidrics             Hidrics Id
    * 
    * @return                         Y- the id_way corresponds to the 'Other' options; N-otherwise
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.3.5
    * @since                          15-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION check_other_hidric
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_hidrics IN hidrics.id_hidrics%TYPE
    ) RETURN VARCHAR2 IS
        l_others VARCHAR2(1 CHAR);
    BEGIN
        BEGIN
            SELECT nvl(h.flg_free_txt, pk_alert_constant.g_no)
              INTO l_others
              FROM hidrics h
             WHERE h.id_hidrics = i_id_hidrics;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END;
        --
        RETURN l_others;
    END check_other_hidric;

    /*******************************************************************************************************************************************
    * check_other_device         Check if the device corresponds to the 'Other' option.
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_id_hidrics_device      Device Id
    * 
    * @return                         Y- the i_id_hidrics_device corresponds to the 'Other' options; N-otherwise
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.3.5
    * @since                          15-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION check_other_device
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_hidrics_device IN hidrics_device.id_hidrics_device%TYPE
    ) RETURN VARCHAR2 IS
        l_other VARCHAR2(1 CHAR);
    BEGIN
        BEGIN
            SELECT nvl(hd.flg_free_txt, pk_alert_constant.g_no)
              INTO l_other
              FROM hidrics_device hd
             WHERE hd.id_hidrics_device = i_id_hidrics_device;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END;
        --
        RETURN l_other;
    END check_other_device;

    /*******************************************************************************************************************************************
    * check_all_others         Check if the given way, hidric, device, location and characteristics were defined by the other option. 
    *                          If so thery are not returned in the output parameters
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_way                    Way Id
    * @param i_body_part              Body part ID
    * @param i_hidrics                hidrics id  
    * @param i_hidrics_charact        Characteristics ID    
    * @param i_flg_bodypart_freetext  Y- the body part id a free text. N-otherwise
    * @param i_device                 device id
    * @param o_way                    way id
    * @param o_body_part              body part id
    * @param o_hidrics                hidrics id
    * @param o_hidrics_charact        Characteristics id
    * @param o_device                 Device id
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.3.5
    * @since                          15-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION check_all_others
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_way                   IN way.id_way%TYPE DEFAULT NULL,
        i_body_part             IN hidrics_location.id_body_part%TYPE DEFAULT NULL,
        i_hidrics               IN hidrics.id_hidrics%TYPE DEFAULT NULL,
        i_hidrics_charact       IN table_number DEFAULT NULL,
        i_flg_bodypart_freetext IN VARCHAR2,
        i_device                IN hidrics_device.id_hidrics_device%TYPE DEFAULT NULL,
        o_way                   OUT way.id_way%TYPE,
        o_body_part             OUT hidrics_location.id_body_part%TYPE,
        o_hidrics               OUT hidrics.id_hidrics%TYPE,
        o_hidrics_charact       OUT table_number,
        o_device                OUT hidrics_device.id_hidrics_device%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        --check the other options
        -- should not be considered as filters       
        g_error := 'CALL check_other_way. id_way: ' || i_way;
        pk_alertlog.log_debug(g_error);
        IF (check_other_way(i_lang => i_lang, i_prof => i_prof, i_id_way => i_way) = pk_alert_constant.g_no)
        THEN
            o_way := i_way;
        END IF;
    
        g_error := 'CALL check_other_hidric. i_hidrics: ' || i_hidrics;
        pk_alertlog.log_debug(g_error);
        IF (check_other_hidric(i_lang => i_lang, i_prof => i_prof, i_id_hidrics => i_hidrics) = pk_alert_constant.g_no)
        THEN
            o_hidrics := i_hidrics;
        END IF;
    
        g_error := 'CALL check_other_device. i_device: ' || i_device;
        pk_alertlog.log_debug(g_error);
        IF (check_other_device(i_lang => i_lang, i_prof => i_prof, i_id_hidrics_device => i_device) =
           pk_alert_constant.g_no)
        THEN
            o_device := i_device;
        END IF;
    
        IF (i_hidrics_charact IS NOT NULL AND i_hidrics_charact.exists(1))
        THEN
            g_error := 'CALL pk_utils.remove_element. ';
            pk_alertlog.log_debug(g_error);
            o_hidrics_charact := pk_utils.remove_element(i_input => i_hidrics_charact, i_elem_to_remove => 0);
        END IF;
    
        IF (i_flg_bodypart_freetext = pk_alert_constant.g_no AND i_body_part IS NOT NULL)
        THEN
            o_body_part := i_body_part;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'CHECK_ALL_OTHERS',
                                              o_error    => o_error);
        
            RETURN FALSE;
    END check_all_others;

    /*******************************************************************************************************************************************
    * check_match_characts         Check if all the given characteristics are associated to the given way and hidrics.
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_hid_characts           Characteristics Ids    
    * @param i_id_way                 Way Id
    * @param i_id_hidrics             Hidrics Id
    * 
    * @return                         Y- the i_id_hidrics_device corresponds to the 'Other' options; N-otherwise
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.3.5
    * @since                          15-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION check_match_characts
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_hid_characts IN table_number,
        i_id_way       IN way.id_way%TYPE,
        i_id_hidrics   IN hidrics.id_hidrics%TYPE
    ) RETURN VARCHAR2 IS
        l_count PLS_INTEGER;
    BEGIN
        IF (i_id_hidrics IS NOT NULL)
        THEN
        
            BEGIN
                SELECT COUNT(1)
                  INTO l_count
                  FROM (SELECT DISTINCT h.id_hidrics_charact, h.id_way, h.id_hidrics
                          FROM hidrics_charact_rel h
                         WHERE h.id_hidrics_charact IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                         column_value
                                                          FROM TABLE(i_hid_characts) t1)
                           AND h.id_way = i_id_way
                           AND (h.id_hidrics = i_id_hidrics)) t;
            EXCEPTION
                WHEN no_data_found THEN
                    l_count := 0;
            END;
        
        ELSE
            BEGIN
                SELECT COUNT(1)
                  INTO l_count
                  FROM (SELECT DISTINCT h.id_hidrics_charact, h.id_way
                          FROM hidrics_charact_rel h
                         WHERE h.id_hidrics_charact IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                         column_value
                                                          FROM TABLE(i_hid_characts) t1)
                           AND h.id_way = i_id_way) t;
            EXCEPTION
                WHEN no_data_found THEN
                    l_count := 0;
            END;
        
        END IF;
    
        IF (l_count >= i_hid_characts.count)
        THEN
            RETURN pk_alert_constant.g_yes;
        ELSE
            RETURN pk_alert_constant.g_no;
        END IF;
    END check_match_characts;

    /*******************************************************************************************************************************************
    * get_ways         Get the ways and hidrics that match the inserted options.
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_id_hidrics_device      Hidrics device
    * @param i_id_hidrics             hidrics id
    * @param i_table_hidrics          hidrics id  
    * @param i_table_way              way id    
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.0.3.5
    * @since                          15-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION get_ways
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional,
        
        i_hid_flg_type     IN hidrics.flg_type%TYPE,
        i_way              IN way.id_way%TYPE DEFAULT NULL,
        i_body_part        IN hidrics_location.id_body_part%TYPE DEFAULT NULL,
        i_body_side        IN hidrics_location.id_body_side%TYPE DEFAULT NULL,
        i_hidrics          IN hidrics.id_hidrics%TYPE DEFAULT NULL,
        i_hidrics_characts IN table_number DEFAULT NULL,
        i_device           IN hidrics_device.id_hidrics_device%TYPE DEFAULT NULL,
        i_hidrics_type     IN hidrics_type.id_hidrics_type%TYPE,
        
        i_department_w  IN department.id_department%TYPE,
        i_dept_w        IN dept.id_dept%TYPE,
        i_institution_w IN institution.id_institution%TYPE,
        i_market_w      IN market.id_market%TYPE,
        
        i_department_h  IN department.id_department%TYPE,
        i_dept_h        IN dept.id_dept%TYPE,
        i_institution_h IN institution.id_institution%TYPE,
        i_software_h    IN software.id_software%TYPE,
        i_market_h      IN market.id_market%TYPE,
        
        i_department_l  IN department.id_department%TYPE,
        i_dept_l        IN dept.id_dept%TYPE,
        i_institution_l IN institution.id_institution%TYPE,
        i_market_l      IN market.id_market%TYPE,
        
        i_department_c  IN department.id_department%TYPE,
        i_dept_c        IN dept.id_dept%TYPE,
        i_institution_c IN institution.id_institution%TYPE,
        i_market_c      IN market.id_market%TYPE,
        
        i_department_d  IN department.id_department%TYPE,
        i_dept_d        IN dept.id_dept%TYPE,
        i_institution_d IN institution.id_institution%TYPE,
        i_market_d      IN market.id_market%TYPE,
        
        o_ways    OUT table_number,
        o_hidrics OUT table_number,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_ways    table_number;
        l_hidrics table_number;
    
        l_total_ways    table_table_number := table_table_number();
        l_total_hidrics table_table_number := table_table_number();
    BEGIN
        IF (i_way IS NOT NULL)
        THEN
            SELECT hwr.id_hidrics
              BULK COLLECT
              INTO l_hidrics
              FROM hidrics_way_rel hwr
             WHERE hwr.flg_available = pk_alert_constant.g_yes
               AND hwr.id_hidrics_type = i_hidrics_type
               AND hwr.id_department = i_department_w
               AND hwr.id_dept = i_dept_w
               AND hwr.id_institution = i_institution_w
               AND nvl(hwr.id_market, 0) = i_market_w
                  --AND (i_hidrics IS NULL OR hwr.id_hidrics = i_hidrics)
               AND hwr.id_way = i_way;
        
            --add_value(io_table => l_total_ways, i_value => l_ways);
            add_value(io_table => l_total_hidrics, i_value => l_hidrics);
        
        END IF;
    
        IF (i_device IS NOT NULL)
        THEN
            SELECT hdr.id_way, hdr.id_hidrics
              BULK COLLECT
              INTO l_ways, l_hidrics
              FROM hidrics_device_rel hdr
             WHERE hdr.id_hidrics_device = i_device
               AND hdr.flg_available = pk_alert_constant.g_yes
               AND hdr.id_department = i_department_d
               AND hdr.id_dept = i_dept_d
               AND nvl(hdr.id_market, 0) = i_market_d
               AND hdr.id_institution = i_institution_d
               AND (i_hidrics IS NULL OR hdr.id_hidrics = i_hidrics OR i_hidrics < 0)
               AND (i_way IS NULL OR hdr.id_way = i_way)
               AND EXISTS (SELECT 1
                      FROM hidrics_way_rel hwr
                     WHERE hwr.id_way = hdr.id_way
                       AND hwr.flg_available = pk_alert_constant.g_yes
                       AND hwr.id_hidrics_type = i_hidrics_type
                       AND hwr.id_department = i_department_w
                       AND hwr.id_dept = i_dept_w
                       AND hwr.id_institution = i_institution_w
                       AND nvl(hwr.id_market, 0) = i_market_w
                       AND (i_hidrics IS NULL OR hwr.id_hidrics = i_hidrics OR i_hidrics < 0)
                       AND hwr.id_hidrics = hdr.id_hidrics);
        
            add_value(io_table => l_total_ways, i_value => l_ways);
            add_value(io_table => l_total_hidrics, i_value => l_hidrics);
        END IF;
    
        IF (i_body_part IS NOT NULL)
        THEN
            SELECT hlr.id_way, hlr.id_hidrics
              BULK COLLECT
              INTO l_ways, l_hidrics
              FROM hidrics_location_rel hlr
              JOIN hidrics_location hl
                ON hl.id_hidrics_location = hlr.id_hidrics_location
             WHERE hl.flg_available = pk_alert_constant.g_yes
               AND hlr.flg_available = pk_alert_constant.g_yes
               AND hlr.id_institution = i_institution_l
               AND hlr.id_department = i_department_l
               AND hlr.id_dept = i_dept_l
               AND nvl(hlr.id_market, 0) = i_market_l
               AND hl.id_body_part = i_body_part
               AND EXISTS
             (SELECT 1
                      FROM hidrics_way_rel hwr
                     WHERE hwr.id_way = hlr.id_way
                       AND hwr.flg_available = pk_alert_constant.g_yes
                       AND hwr.id_hidrics_type = i_hidrics_type
                       AND hwr.id_department = i_department_w
                       AND hwr.id_dept = i_dept_w
                       AND hwr.id_institution = i_institution_w
                       AND nvl(hwr.id_market, 0) = i_market_w
                       AND (i_way IS NULL OR hlr.id_way = i_way)
                       AND hwr.id_hidrics = hlr.id_hidrics)
               AND (i_hidrics IS NULL OR EXISTS (SELECT 1
                                                   FROM hidrics_relation hr
                                                   JOIN hidrics h
                                                     ON h.id_hidrics = hr.id_hidrics
                                                  WHERE h.flg_available = pk_alert_constant.g_yes
                                                    AND h.flg_type = i_hid_flg_type
                                                    AND hr.flg_available = pk_alert_constant.g_yes
                                                    AND hr.flg_state = pk_alert_constant.g_active
                                                    AND hr.id_hidrics_type = i_hidrics_type
                                                    AND hr.id_software = i_software_h
                                                    AND hr.id_institution = i_institution_h
                                                    AND hr.id_department = i_department_h
                                                    AND hr.id_dept = i_dept_h
                                                    AND nvl(hr.id_market, 0) = i_market_h
                                                    AND h.id_hidrics = i_hidrics))
               AND (i_body_side IS NULL OR hl.id_body_side = i_body_side);
        
            add_value(io_table => l_total_ways, i_value => l_ways);
            add_value(io_table => l_total_hidrics, i_value => l_hidrics);
        END IF;
    
        IF (i_hidrics_characts IS NOT NULL AND i_hidrics_characts.exists(1))
        THEN
            SELECT hcr.id_way, hcr.id_hidrics
              BULK COLLECT
              INTO l_ways, l_hidrics
              FROM hidrics_charact_rel hcr
             WHERE hcr.flg_available = pk_alert_constant.g_yes
               AND hcr.id_department = i_department_c
               AND hcr.id_dept = i_dept_c
               AND nvl(hcr.id_market, 0) = i_market_c
               AND hcr.id_institution = i_institution_c
               AND (i_hidrics IS NULL OR hcr.id_hidrics = i_hidrics OR i_hidrics < 0)
               AND (i_way IS NULL OR hcr.id_way = i_way)
               AND hcr.id_hidrics_charact IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                               column_value
                                                FROM TABLE(i_hidrics_characts) t1)
               AND EXISTS (SELECT 1
                      FROM hidrics_way_rel hwr
                     WHERE hwr.id_way = hcr.id_way
                       AND hwr.flg_available = pk_alert_constant.g_yes
                       AND hwr.id_hidrics_type = i_hidrics_type
                       AND hwr.id_department = i_department_w
                       AND hwr.id_dept = i_dept_w
                       AND hwr.id_institution = i_institution_w
                       AND nvl(hwr.id_market, 0) = i_market_w
                       AND (i_hidrics IS NULL OR hwr.id_hidrics = i_hidrics OR i_hidrics < 0)
                       AND hwr.id_hidrics = hcr.id_hidrics)
               AND check_match_characts(i_lang,
                                        i_prof,
                                        i_hidrics_characts,
                                        hcr.id_way,
                                        CASE
                                            WHEN i_hidrics IS NULL THEN
                                             i_hidrics
                                            ELSE
                                             hcr.id_hidrics
                                        END) = pk_alert_constant.g_yes;
        
            add_value(io_table => l_total_ways, i_value => l_ways);
            add_value(io_table => l_total_hidrics, i_value => l_hidrics);
        END IF;
    
        IF (l_total_ways IS NOT NULL AND l_total_ways.exists(1))
        THEN
            FOR i IN 1 .. l_total_ways.count
            LOOP
                IF (i = 1 AND l_total_ways.exists(2))
                THEN
                    l_ways := l_total_ways(1) MULTISET INTERSECT l_total_ways(2);
                ELSIF (i = 1 AND NOT l_total_ways.exists(2))
                THEN
                    l_ways := l_total_ways(1);
                ELSIF (i > 2 AND l_total_ways.exists(i))
                THEN
                    l_ways := l_ways MULTISET INTERSECT l_total_ways(i);
                END IF;
            END LOOP;
        END IF;
    
        IF (l_total_hidrics IS NOT NULL AND l_total_hidrics.exists(1))
        THEN
            FOR i IN 1 .. l_total_hidrics.count
            LOOP
                IF (i = 1 AND l_total_hidrics.exists(2))
                THEN
                    l_hidrics := l_total_hidrics(1) MULTISET INTERSECT l_total_hidrics(2);
                ELSIF (i = 1 AND NOT l_total_hidrics.exists(2))
                THEN
                    l_hidrics := l_total_hidrics(1);
                ELSIF (i > 2 AND l_total_hidrics.exists(i))
                THEN
                    l_hidrics := l_hidrics MULTISET INTERSECT l_total_hidrics(i);
                
                END IF;
            END LOOP;
        END IF;
    
        o_ways    := l_ways;
        o_hidrics := l_hidrics;
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_WAYS',
                                              o_error    => o_error);
        
            RETURN FALSE;
    END get_ways;

    /**
    * Gets ways, locations, fluids ans characterization cursors used to fill multichoice lists
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_episode                   Episode Id
    * @param   i_epis_hid                  Epis hidrics id
    * @param   i_hid_flg_type              Hidrics flg_type (Administration or Elimination)
    * @param   i_hidrics_type              Hidrics type ID
    * @param   i_way                       Way id
    * @param   i_body_part                 Body part id
    * @param   i_body_side                 Body side id
    * @param   i_hidrics                   Hidric id
    * @param   i_hidrics_charact           Hidric charateristic id
    * @param   i_flg_bodypart_freetext     Y- the body part was defined by free text. N-otherwise
    * @param   i_old_hidrics               Id hidrics of the registry being edited.
    *                                      To be used in the editions only.
    * @param   i_flg_nr_times              Y - the nr of occurrences has been filled by the user; N - otherwise
    * @param   o_ways                      ways cursor
    * @param   o_locations                 locations cursor
    * @param   o_hidrics                   hidrics cursor
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   21-05-2010
    */
    FUNCTION get_multichoice_lists
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_episode               IN episode.id_episode%TYPE DEFAULT NULL,
        i_epis_hid              IN epis_hidrics.id_epis_hidrics%TYPE,
        i_hid_flg_type          IN hidrics.flg_type%TYPE,
        i_hidrics_type          IN hidrics_type.id_hidrics_type%TYPE DEFAULT NULL,
        i_way                   IN way.id_way%TYPE DEFAULT NULL,
        i_body_part             IN hidrics_location.id_body_part%TYPE DEFAULT NULL,
        i_body_side             IN hidrics_location.id_body_side%TYPE DEFAULT NULL,
        i_hidrics               IN hidrics.id_hidrics%TYPE DEFAULT NULL,
        i_hidrics_charact       IN table_number DEFAULT NULL,
        i_flg_bodypart_freetext IN VARCHAR2,
        i_device                IN hidrics_device.id_hidrics_device%TYPE DEFAULT NULL,
        i_old_hidrics           IN hidrics.id_hidrics%TYPE DEFAULT NULL,
        i_flg_nr_times          IN hidrics.flg_nr_times%TYPE DEFAULT NULL,
        o_ways                  OUT pk_types.cursor_type,
        o_body_parts            OUT pk_types.cursor_type,
        o_body_side             OUT pk_types.cursor_type,
        o_hidrics               OUT pk_types.cursor_type,
        o_hidrics_chars         OUT pk_types.cursor_type,
        o_hidrics_devices       OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_MULTICHOICE_LISTS';
        --
        l_inst_w       institution.id_institution%TYPE;
        l_soft_w       software.id_software%TYPE;
        l_department_w department.id_department%TYPE;
        l_dept_w       dept.id_dept%TYPE;
        l_id_market_w  market.id_market%TYPE;
    
        l_inst_h       institution.id_institution%TYPE;
        l_soft_h       software.id_software%TYPE;
        l_department_h department.id_department%TYPE;
        l_dept_h       dept.id_dept%TYPE;
        l_id_market_h  market.id_market%TYPE;
    
        l_inst_c       institution.id_institution%TYPE;
        l_soft_c       software.id_software%TYPE;
        l_department_c department.id_department%TYPE;
        l_dept_c       dept.id_dept%TYPE;
        l_id_market_c  market.id_market%TYPE;
    
        l_inst_d       institution.id_institution%TYPE;
        l_soft_d       software.id_software%TYPE;
        l_department_d department.id_department%TYPE;
        l_dept_d       dept.id_dept%TYPE;
        l_id_market_d  market.id_market%TYPE;
    
        l_inst_l       institution.id_institution%TYPE;
        l_soft_l       software.id_software%TYPE;
        l_department_l department.id_department%TYPE;
        l_dept_l       dept.id_dept%TYPE;
        l_id_market_l  market.id_market%TYPE;
    
        l_episode      episode.id_episode%TYPE := i_episode;
        l_hidrics_type hidrics_type.id_hidrics_type%TYPE := i_hidrics_type;
        l_pat_gender   patient.gender%TYPE;
        l_age          VARCHAR2(24 CHAR);
    
        l_id_patient patient.id_patient%TYPE;
        --
        l_msg_other sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                            i_code_mess => 'COMMON_M042');
    
        l_ways    table_number;
        l_hidrics table_number;
    
        l_has_ways    PLS_INTEGER;
        l_has_hidrics PLS_INTEGER;
    
        l_way_o             way.id_way%TYPE;
        l_body_part_o       body_part.id_body_part%TYPE;
        l_hidrics_o         hidrics.id_hidrics%TYPE;
        l_hidrics_charact_o table_number;
        l_device_o          hidrics_device.id_hidrics_device%TYPE;
    
        l_show_free_texts sys_config.value%TYPE;
    
        l_old_flg_nr_times hidrics.flg_nr_times%TYPE;
    BEGIN
        IF (i_hidrics_type IS NULL)
        THEN
            g_error := 'GET ID_EPIS AND ID_HID_TYPE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            SELECT eh.id_episode, eh.id_hidrics_type
              INTO l_episode, l_hidrics_type
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = i_epis_hid;
        END IF;
    
        g_error := 'CALL pk_episode.get_epis_patient. i_id_episode: ' || l_episode;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_id_patient := pk_episode.get_epis_patient(i_lang => i_lang, i_prof => i_prof, i_episode => l_episode);
    
        g_error := 'GET CONF VARS - WAYS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => l_episode,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_w,
                             o_inst       => l_inst_w,
                             o_soft       => l_soft_w,
                             o_department => l_department_w,
                             o_dept       => l_dept_w,
                             o_id_market  => l_id_market_w,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        g_error := 'GET CONF VARS - HIDRICS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => l_episode,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_h,
                             o_inst       => l_inst_h,
                             o_soft       => l_soft_h,
                             o_department => l_department_h,
                             o_dept       => l_dept_h,
                             o_id_market  => l_id_market_h,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        g_error := 'GET CONF VARS - LOCATIONS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => l_episode,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_l,
                             o_inst       => l_inst_l,
                             o_soft       => l_soft_l,
                             o_department => l_department_l,
                             o_dept       => l_dept_l,
                             o_id_market  => l_id_market_l,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        g_error := 'GET CONF VARS - CHARACTERIZATIONS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => l_episode,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_c,
                             o_inst       => l_inst_c,
                             o_soft       => l_soft_c,
                             o_department => l_department_c,
                             o_dept       => l_dept_c,
                             o_id_market  => l_id_market_c,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        g_error := 'GET CONF VARS - CHARACTERIZATIONS: DEVICES';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => l_episode,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_d,
                             o_inst       => l_inst_d,
                             o_soft       => l_soft_d,
                             o_department => l_department_d,
                             o_dept       => l_dept_d,
                             o_id_market  => l_id_market_d,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        --check the other options
        -- should not be considered as filters    
        g_error := 'CALL check_all_others';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_all_others(i_lang                  => i_lang,
                                i_prof                  => i_prof,
                                i_way                   => i_way,
                                i_body_part             => i_body_part,
                                i_hidrics               => i_hidrics,
                                i_hidrics_charact       => i_hidrics_charact,
                                i_flg_bodypart_freetext => i_flg_bodypart_freetext,
                                i_device                => i_device,
                                o_way                   => l_way_o,
                                o_body_part             => l_body_part_o,
                                o_hidrics               => l_hidrics_o,
                                o_hidrics_charact       => l_hidrics_charact_o,
                                o_device                => l_device_o,
                                o_error                 => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        g_error := 'CALL get_ways';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT get_ways(i_lang             => i_lang,
                        i_prof             => i_prof,
                        i_hid_flg_type     => i_hid_flg_type,
                        i_way              => l_way_o,
                        i_body_part        => l_body_part_o,
                        i_body_side        => i_body_side,
                        i_hidrics          => l_hidrics_o,
                        i_hidrics_characts => l_hidrics_charact_o,
                        
                        i_device        => l_device_o,
                        i_hidrics_type  => l_hidrics_type,
                        i_department_w  => l_department_w,
                        i_dept_w        => l_dept_w,
                        i_institution_w => l_inst_w,
                        i_market_w      => l_id_market_w,
                        
                        i_department_h  => l_department_h,
                        i_dept_h        => l_dept_h,
                        i_institution_h => l_inst_h,
                        i_software_h    => l_soft_h,
                        i_market_h      => l_id_market_h,
                        
                        i_department_l  => l_department_l,
                        i_dept_l        => l_dept_l,
                        i_institution_l => l_inst_l,
                        i_market_l      => l_id_market_l,
                        
                        i_department_c  => l_department_c,
                        i_dept_c        => l_dept_c,
                        i_institution_c => l_inst_c,
                        i_market_c      => l_id_market_c,
                        
                        i_department_d  => l_department_d,
                        i_dept_d        => l_dept_d,
                        i_institution_d => l_inst_d,
                        i_market_d      => l_id_market_d,
                        o_hidrics       => l_hidrics,
                        o_ways          => l_ways,
                        o_error         => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF (NOT l_hidrics_charact_o.exists(1))
        THEN
            l_hidrics_charact_o := NULL;
        END IF;
    
        l_has_ways := CASE
                          WHEN l_ways IS NOT NULL THEN
                           1
                          ELSE
                           0
                      END;
        l_has_hidrics := CASE
                             WHEN l_hidrics IS NOT NULL THEN
                              1
                             ELSE
                              0
                         END;
    
        g_error := 'GET CONFIG: HIDRICS_SHOW_FREE_TEXTS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_show_free_texts := pk_sysconfig.get_config(i_code_cf => 'HIDRICS_SHOW_FREE_TEXTS', i_prof => i_prof);
    
        g_error := 'GET WAYS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_ways FOR
            SELECT tbl.id_hidrics_way, tbl.desc_hidrics_way, tbl.flg_type
              FROM (SELECT tb.id_hidrics_way, tb.desc_hidrics_way, tb.flg_type
                      FROM (SELECT t.id_way id_hidrics_way, t.desc_hidrics_way, t.flg_type
                              FROM (SELECT t_int.id_way,
                                           pk_translation.get_translation(i_lang, t_int.code_way) desc_hidrics_way,
                                           t_int.flg_way_type flg_type
                                      FROM (SELECT DISTINCT hw.id_way, hw.code_way, hw.flg_way_type --, hwr.id_hidrics
                                              FROM way hw
                                              JOIN hidrics_way_rel hwr
                                                ON hwr.id_way = hw.id_way
                                             WHERE hw.flg_available = pk_alert_constant.g_yes
                                               AND hw.flg_way_type != pk_inp_hidrics_constant.g_hid_way_type_o
                                               AND hw.flg_type = i_hid_flg_type
                                               AND hwr.flg_available = pk_alert_constant.g_yes
                                               AND hwr.id_hidrics_type = l_hidrics_type
                                               AND nvl(hwr.id_department, 0) = l_department_w
                                               AND nvl(hwr.id_dept, 0) = l_dept_w
                                               AND nvl(hwr.id_institution, 0) = l_inst_w
                                               AND nvl(hwr.id_market, 0) = l_id_market_w
                                               AND (hwr.id_hidrics = i_hidrics OR i_hidrics IS NULL OR i_hidrics < 0)
                                               AND (((l_hidrics_o IS NULL) AND (l_body_part_o IS NULL) AND
                                                   (l_device_o IS NULL) AND (l_hidrics_charact_o IS NULL)) OR
                                                   ((l_has_ways = 0 OR
                                                   hw.id_way IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                                     column_value
                                                                      FROM TABLE(l_ways) t1))
                                                   
                                                   AND
                                                   (l_has_hidrics = 0 OR
                                                   hwr.id_hidrics IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                                          column_value
                                                                           FROM TABLE(l_hidrics) t1))))) t_int
                                    UNION ALL
                                    SELECT DISTINCT hdw.id_way     id_hidrics_way,
                                                    etxt.free_text desc_hidrics_way,
                                                    NULL           flg_type
                                      FROM epis_hidrics_det_ftxt etxt
                                      JOIN way hdw
                                        ON hdw.id_way = etxt.id_way
                                     WHERE etxt.id_patient = l_id_patient
                                       AND l_show_free_texts = pk_alert_constant.g_yes
                                       AND hdw.flg_type = i_hid_flg_type
                                       AND hdw.flg_way_type = pk_inp_hidrics_constant.g_hid_way_type_o) t
                             WHERE t.desc_hidrics_way IS NOT NULL
                             ORDER BY t.desc_hidrics_way) tb) tbl
            UNION ALL
            SELECT hw.id_way id_hidrics_way,
                   pk_translation.get_translation(i_lang, hw.code_way) desc_hidrics_way,
                   hw.flg_way_type flg_type
              FROM way hw
             WHERE hw.flg_way_type = pk_inp_hidrics_constant.g_hid_way_type_o
               AND hw.flg_type = i_hid_flg_type
               AND hw.flg_available = pk_alert_constant.g_yes;
    
        g_error := 'GET PATIENT GENDER';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT p.gender, nvl(p.age, trunc(months_between(SYSDATE, p.dt_birth) / 12)) age
          INTO l_pat_gender, l_age
          FROM episode e
          JOIN patient p
            ON p.id_patient = e.id_patient
         WHERE e.id_episode = l_episode;
    
        --in the edition of a line, if the old hidrics allows the nr of occurrences monitorization,
        --the list of hidrics available to the user change the hidrics should consider the hidrics that
        -- also allows the nr of occurrences monitorization, in order to prevent cases when, some executions were made 
        --in the line being edited registering the nr of occurrences and edition of the line turns that registries unusable.
        IF (i_old_hidrics IS NOT NULL)
        THEN
            SELECT decode(h.flg_nr_times, pk_alert_constant.g_yes, h.flg_nr_times, NULL)
              INTO l_old_flg_nr_times
              FROM hidrics h
             WHERE h.id_hidrics = i_old_hidrics;
        END IF;
    
        g_error := 'GET HIDRICS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_hidrics FOR
            SELECT *
              FROM (SELECT tint.id_hidrics,
                           tint.desc_hidrics,
                           tint.flg_type,
                           tint.flg_state,
                           tint.flg_free_txt,
                           tint.flg_nr_times
                      FROM (SELECT h.id_hidrics,
                                   pk_translation.get_translation(i_lang, h.code_hidrics) desc_hidrics,
                                   h.flg_type,
                                   hr.flg_state,
                                   h.flg_free_txt,
                                   h.flg_nr_times
                              FROM hidrics h
                              JOIN hidrics_relation hr
                                ON hr.id_hidrics = h.id_hidrics
                             WHERE h.flg_available = pk_alert_constant.g_yes
                               AND h.flg_type = i_hid_flg_type
                               AND h.flg_free_txt = pk_alert_constant.g_no
                               AND (l_pat_gender = h.flg_gender OR h.flg_gender IS NULL OR l_pat_gender IS NULL OR
                                   upper(l_pat_gender) IN ('N', 'I') OR upper(h.flg_gender) IN ('N', 'I'))
                               AND (l_age BETWEEN h.age_min AND h.age_max OR l_age IS NULL OR
                                   (h.age_min IS NULL AND h.age_max IS NULL) OR
                                   (h.age_min IS NOT NULL AND h.age_max IS NULL AND l_age >= h.age_min) OR
                                   (h.age_min IS NULL AND h.age_max IS NOT NULL AND l_age <= h.age_max))
                               AND hr.flg_available = pk_alert_constant.g_yes
                               AND hr.flg_state = pk_alert_constant.g_active
                               AND hr.id_hidrics_type = l_hidrics_type
                               AND nvl(hr.id_software, 0) = l_soft_h
                               AND nvl(hr.id_institution, 0) = l_inst_h
                               AND nvl(hr.id_department, 0) = l_department_h
                               AND nvl(hr.id_dept, 0) = l_dept_h
                               AND nvl(hr.id_market, 0) = l_id_market_h
                               AND (i_flg_nr_times IS NULL OR h.flg_nr_times = i_flg_nr_times OR i_flg_nr_times = 'N')
                               AND (l_old_flg_nr_times IS NULL OR h.flg_nr_times = l_old_flg_nr_times)
                               AND (((l_way_o IS NULL) AND (l_body_part_o IS NULL) AND (l_device_o IS NULL) AND
                                   (l_hidrics_charact_o IS NULL)) OR
                                   (l_has_hidrics = 0 OR
                                   hr.id_hidrics IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                        column_value
                                                         FROM TABLE(l_hidrics) t1)))) tint
                     WHERE tint.desc_hidrics IS NOT NULL
                    
                    UNION ALL
                    SELECT DISTINCT hid.id_hidrics           id_hidrics,
                                    etxt.free_text           desc_hidrics,
                                    NULL                     flg_type,
                                    NULL                     flg_state,
                                    pk_alert_constant.get_no flg_free_txt,
                                    hid.flg_nr_times         flg_nr_times
                      FROM epis_hidrics_det_ftxt etxt
                      JOIN hidrics hid
                        ON hid.id_hidrics = etxt.id_hidrics
                     WHERE etxt.id_patient = l_id_patient
                       AND hid.flg_type = i_hid_flg_type
                       AND l_show_free_texts = pk_alert_constant.g_yes
                       AND hid.flg_free_txt = pk_alert_constant.g_yes
                     ORDER BY desc_hidrics, flg_free_txt, flg_state ASC)
            UNION ALL
            SELECT h.id_hidrics,
                   pk_translation.get_translation(i_lang, h.code_hidrics) desc_hidrics,
                   h.flg_type,
                   NULL flg_state,
                   h.flg_free_txt,
                   h.flg_nr_times
              FROM hidrics h
             WHERE h.flg_free_txt = pk_alert_constant.g_yes
               AND h.flg_available = pk_alert_constant.g_yes
               AND h.flg_type = i_hid_flg_type;
    
        g_error := 'GET PARTS id_institution: ' || l_inst_l || ' id_department: ' || l_department_l || ' l_dept_l: ' ||
                   l_dept_l || ' l_id_market_l: ' || l_id_market_l || ' l_hidrics_o: ' || l_hidrics_o || ' l_device_o: ' ||
                   l_device_o || ' l_way_o : ' || l_way_o || ' l_has_ways: ' || l_has_ways || ' l_has_hidrics: ' ||
                   l_has_hidrics || ' l_hidrics_charact_o(1): ' || CASE
                       WHEN l_hidrics_charact_o.exists(1) THEN
                        l_hidrics_charact_o(1)
                   END;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_body_parts FOR
            SELECT *
              FROM (SELECT t.id_body_part, t.desc_body_part, pk_alert_constant.g_no flg_free_txt
                      FROM (SELECT t_int.id_body_part,
                                   pk_translation.get_translation(i_lang, t_int.code_body_part) desc_body_part
                              FROM (SELECT DISTINCT hl.id_body_part, bp.code_body_part
                                      FROM hidrics_location hl
                                      JOIN hidrics_location_rel hlr
                                        ON hlr.id_hidrics_location = hl.id_hidrics_location
                                      JOIN body_part bp
                                        ON bp.id_body_part = hl.id_body_part
                                       AND bp.flg_available = pk_alert_constant.g_yes
                                      JOIN way hw
                                        ON hw.id_way = hlr.id_way
                                     WHERE hl.flg_available = pk_alert_constant.g_yes
                                       AND hw.flg_type = i_hid_flg_type
                                       AND (hl.id_body_side = i_body_side OR (i_body_side IS NULL))
                                       AND hlr.flg_available = pk_alert_constant.g_yes
                                       AND /*nvl(*/
                                           hlr.id_institution /*, 0)*/
                                           = l_inst_l
                                       AND /* nvl(*/
                                           hlr.id_department /*, 0)*/
                                           = l_department_l
                                       AND /*nvl(*/
                                           hlr.id_dept /*, 0)*/
                                           = l_dept_l
                                       AND /*nvl(*/
                                           hlr.id_market /*, 0)*/
                                           = l_id_market_l
                                       AND (hlr.id_way = i_way OR i_way IS NULL OR i_way <= 0)
                                       AND (hlr.id_hidrics = i_hidrics OR i_hidrics IS NULL OR i_hidrics < 0)
                                       AND (((l_hidrics_o IS NULL) AND (l_device_o IS NULL) AND
                                           (l_hidrics_charact_o IS NULL) AND (l_way_o IS NULL)) OR
                                           ((l_has_ways = 0 OR
                                           hlr.id_way IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                              column_value
                                                               FROM TABLE(l_ways) t1))
                                           
                                           AND (l_has_hidrics = 0 OR
                                           hlr.id_hidrics IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                                      column_value
                                                                       FROM TABLE(l_hidrics) t1))))) t_int
                            UNION ALL
                            SELECT DISTINCT hlc.id_body_part, etxt.free_text desc_body_part
                              FROM epis_hidrics_det_ftxt etxt
                              JOIN hidrics_location hlc
                                ON hlc.id_hidrics_location = etxt.id_hidrics_location
                             WHERE etxt.id_patient = l_id_patient
                               AND l_show_free_texts = pk_alert_constant.g_yes
                               AND etxt.id_hidrics_location IS NOT NULL) t
                     ORDER BY desc_body_part)
            
            UNION ALL
            SELECT NULL id_body_part, l_msg_other desc_body_part, pk_alert_constant.g_yes flg_free_txt
              FROM dual;
    
        g_error := 'GET SIDES';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_body_side FOR
            SELECT t.id_body_side, pk_translation.get_translation(i_lang, t.code_body_side) desc_body_side
              FROM (SELECT DISTINCT hl.id_body_side, bs.code_body_side
                      FROM hidrics_location hl
                      JOIN hidrics_location_rel hlr
                        ON hlr.id_hidrics_location = hl.id_hidrics_location
                      JOIN body_side bs
                        ON bs.id_body_side = hl.id_body_side
                      JOIN way hw
                        ON hw.id_way = hlr.id_way
                     WHERE hl.flg_available = pk_alert_constant.g_yes
                       AND hw.flg_type = i_hid_flg_type
                       AND (hl.id_body_part = i_body_part OR
                           (i_body_part IS NULL AND i_flg_bodypart_freetext = pk_alert_constant.get_no) OR
                           (i_flg_bodypart_freetext = pk_alert_constant.get_yes AND hl.id_body_part IS NULL))
                       AND hlr.flg_available = pk_alert_constant.g_yes
                       AND /*nvl(*/
                           hlr.id_institution /*, 0)*/
                           = l_inst_l
                       AND /*nvl(*/
                           hlr.id_department /*, 0)*/
                           = l_department_l
                       AND /*nvl(*/
                           hlr.id_dept /*, 0)*/
                           = l_dept_l
                       AND /*nvl(*/
                           hlr.id_market /*, 0)*/
                           = l_id_market_l
                       AND (hlr.id_way = i_way OR i_way IS NULL OR i_way <= 0)
                       AND (hlr.id_hidrics = i_hidrics OR i_hidrics IS NULL OR i_hidrics < 0)
                          
                       AND (((l_hidrics_o IS NULL) AND (l_device_o IS NULL) AND (l_hidrics_charact_o IS NULL) AND
                           (l_way_o IS NULL)) OR
                           ((l_has_ways = 0 OR
                           hlr.id_way IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                              column_value
                                               FROM TABLE(l_ways) t1))
                           
                           AND (l_has_hidrics = 0 OR
                           hlr.id_hidrics IN (SELECT /*+opt_estimate(table,t2,scale_rows=0.0000001)*/
                                                      column_value
                                                       FROM TABLE(l_hidrics) t2))))) t
             ORDER BY desc_body_side;
    
        g_error := 'GET CHARACTERIZATIONS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_hidrics_chars FOR
            SELECT t.id_hidrics_charact, t.desc_hidrics_charact, t.flg_free_txt
              FROM (SELECT t_int.id_hidrics_charact,
                           pk_translation.get_translation(i_lang, t_int.code_hidrics_charact) desc_hidrics_charact,
                           pk_alert_constant.g_no flg_free_txt
                      FROM (SELECT DISTINCT hc.id_hidrics_charact, hc.code_hidrics_charact
                            
                              FROM hidrics_charact hc
                              JOIN hidrics_charact_rel hcr
                                ON hcr.id_hidrics_charact = hc.id_hidrics_charact
                              JOIN way hw
                                ON hw.id_way = hcr.id_way
                             WHERE hc.flg_available = pk_alert_constant.g_yes
                               AND hw.flg_type = i_hid_flg_type
                               AND hc.id_hidrics_charact != 0
                               AND hcr.flg_available = pk_alert_constant.g_yes
                               AND nvl(hcr.id_department, 0) = l_department_c
                               AND nvl(hcr.id_dept, 0) = l_dept_c
                               AND nvl(hcr.id_market, 0) = l_id_market_c
                               AND nvl(hcr.id_institution, 0) = l_inst_c
                               AND (hcr.id_hidrics = i_hidrics OR i_hidrics IS NULL OR i_hidrics < 0)
                               AND (hcr.id_way = i_way OR i_way IS NULL OR i_way <= 0)
                                  
                               AND (((l_hidrics_o IS NULL) AND (l_body_part_o IS NULL) AND (l_device_o IS NULL) AND
                                   (l_way_o IS NULL)) OR
                                   ((l_has_ways = 0 OR
                                   hcr.id_way IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                      column_value
                                                       FROM TABLE(l_ways) t1))
                                   
                                   AND (l_has_hidrics = 0 OR
                                   hcr.id_hidrics IN (SELECT /*+opt_estimate(table,t2,scale_rows=0.0000001)*/
                                                              column_value
                                                               FROM TABLE(l_hidrics) t2))))) t_int
                    
                    UNION ALL
                    SELECT DISTINCT etxt.id_hidrics_charact id_hidrics_charact,
                                    etxt.free_text          desc_hidrics_charact,
                                    pk_alert_constant.g_no  flg_free_txt
                      FROM epis_hidrics_det_ftxt etxt
                     WHERE etxt.id_patient = l_id_patient
                       AND l_show_free_texts = pk_alert_constant.g_yes
                       AND etxt.id_hidrics_charact IS NOT NULL
                     ORDER BY desc_hidrics_charact) t
            UNION ALL
            SELECT hc.id_hidrics_charact,
                   pk_translation.get_translation(i_lang, hc.code_hidrics_charact) desc_hidrics_charact,
                   pk_alert_constant.g_yes flg_free_txt
              FROM hidrics_charact hc
             WHERE hc.flg_available = pk_alert_constant.g_yes
               AND hc.id_hidrics_charact = 0;
    
        g_error := 'GET CHARACTERIZATIONS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_hidrics_devices FOR
            SELECT *
              FROM (SELECT t_int.id_hidrics_device,
                           pk_translation.get_translation(i_lang, t_int.code_hidrics_device) desc_hidrics_device,
                           pk_alert_constant.g_no flg_free_txt
                      FROM (SELECT DISTINCT hd.id_hidrics_device, hd.code_hidrics_device
                              FROM hidrics_device hd
                              JOIN hidrics_device_rel hdr
                                ON hdr.id_hidrics_device = hd.id_hidrics_device
                              JOIN way hw
                                ON hw.id_way = hdr.id_way
                             WHERE hd.flg_available = pk_alert_constant.g_yes
                               AND hw.flg_type = i_hid_flg_type
                               AND hd.id_hidrics_device != 0
                               AND hdr.flg_available = pk_alert_constant.g_yes
                               AND /*nvl(*/
                                   hdr.id_department /*, 0)*/
                                   = l_department_d
                               AND /*nvl(*/
                                   hdr.id_dept /*, 0)*/
                                   = l_dept_d
                               AND /* nvl(*/
                                   hdr.id_market /*, 0)*/
                                   = l_id_market_d
                               AND /*nvl(*/
                                   hdr.id_institution /*, 0)*/
                                   = l_inst_d
                               AND (hdr.id_hidrics = i_hidrics OR i_hidrics IS NULL OR i_hidrics < 0)
                               AND (hdr.id_way = i_way OR i_way IS NULL OR i_way <= 0)
                                  
                               AND (((l_hidrics_o IS NULL) AND (l_body_part_o IS NULL) AND (l_way_o IS NULL) AND
                                   (l_hidrics_charact_o IS NULL)) OR
                                   ((l_has_ways = 0 OR
                                   hdr.id_way IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                      column_value
                                                       FROM TABLE(l_ways) t1))
                                   
                                   AND (l_has_hidrics = 0 OR
                                   hdr.id_hidrics IN (SELECT /*+opt_estimate(table,t2,scale_rows=0.0000001)*/
                                                              column_value
                                                               FROM TABLE(l_hidrics) t2))))) t_int
                    
                    UNION ALL
                    
                    SELECT DISTINCT etxt.id_hidrics_device id_hidrics_charact,
                                    etxt.free_text         desc_hidrics_charact,
                                    pk_alert_constant.g_no flg_free_txt
                      FROM epis_hidrics_det_ftxt etxt
                     WHERE etxt.id_patient = l_id_patient
                       AND l_show_free_texts = pk_alert_constant.g_yes
                       AND etxt.id_hidrics_device IS NOT NULL
                     ORDER BY desc_hidrics_device)
            UNION ALL
            SELECT hd.id_hidrics_device,
                   pk_translation.get_translation(i_lang, hd.code_hidrics_device) desc_hidrics_device,
                   pk_alert_constant.g_yes flg_free_txt
              FROM hidrics_device hd
             WHERE hd.flg_available = pk_alert_constant.g_yes
               AND hd.id_hidrics_device = 0;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_body_parts);
            pk_types.open_my_cursor(o_body_side);
            pk_types.open_my_cursor(o_hidrics);
            pk_types.open_my_cursor(o_hidrics_chars);
            pk_types.open_my_cursor(o_ways);
            pk_types.open_my_cursor(o_hidrics_devices);
            RETURN FALSE;
    END get_multichoice_lists;

    /**
    * Checks if the current episode already has an intake/output task
    * of the same type, in progress.
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    * @param   i_id_episode   Episode ID
    * @param   i_acronym      Type of task being requested
    * @param   o_exists       Exists a task of the same type? (Y) Yes (N) No
    * @param   o_error        Error information
    *
    * @return  TRUE if successful, FALSE otherwise
    *
    * @author  JOSE.BRITO
    * @version 2.6
    * @since   25-05-2010
    */
    FUNCTION check_existing_hidrics_task
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE,
        i_acronym    IN hidrics_type.acronym%TYPE,
        o_exists     OUT VARCHAR2,
        o_msg        OUT VARCHAR2,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_task_count          NUMBER(6) := 0;
        l_exists_hidrics_task VARCHAR2(1 CHAR) := 'N';
    
        l_int_desc VARCHAR2(300 CHAR);
        l_dt_next  VARCHAR2(300 CHAR);
        l_dt_end   VARCHAR2(300 CHAR);
    
    BEGIN
    
        -- The following statements represent the cases that are not allowed to be requested:
        g_error := 'COUNTING EXISTING TASKS';
        pk_alertlog.log_debug(g_error);
        SELECT COUNT(*)
          INTO l_task_count
          FROM epis_hidrics eh
          JOIN hidrics_type ht
            ON ht.id_hidrics_type = eh.id_hidrics_type
         WHERE eh.id_episode = i_id_episode
           AND eh.flg_status IN ('E', 'R')
              -- 1) Tasks of the same type;
           AND ((i_acronym = 'H' AND ht.acronym IN ('I', 'H'))
               --user is requesting an intake task and already exists an intake and output task
               OR (i_acronym = 'I' AND ht.acronym IN ('I', 'H'))
               
               -- 2) Exists an intake/output task;
               --OR ht.acronym = 'H'
               -- 2.1) User is requesting an intake/output, but already exists another task (of any type) in progress;
               --OR (i_acronym = 'H' AND ht.acronym <> i_acronym)
               -- 3) Exists an output task of type "All", and user is requesting a subtype of output (diuresis/drainage), or vice-versa;
               OR (ht.acronym = 'A' AND i_acronym IN ('D', 'R')) OR (i_acronym = 'A' AND ht.acronym IN ('D', 'R')));
    
        -- If an invalid combination is detected, then the new request should not be allowed.
        IF l_task_count > 0
        THEN
            l_exists_hidrics_task := 'Y';
        
            SELECT get_hid_interval_desc_int(i_lang, i_prof, eh.id_hidrics_interval, eh.interval_minutes),
                   pk_date_utils.date_char_tsz(i_lang, eh.dt_next_balance, i_prof.institution, i_prof.software),
                   pk_date_utils.date_char_tsz(i_lang, eh.dt_end_tstz, i_prof.institution, i_prof.software)
              INTO l_int_desc, l_dt_next, l_dt_end
              FROM epis_hidrics eh
              JOIN hidrics_type ht
                ON ht.id_hidrics_type = eh.id_hidrics_type
              JOIN hidrics_interval hi
                ON hi.id_hidrics_interval = eh.id_hidrics_interval
             WHERE eh.id_episode = i_id_episode
               AND rownum = 1
               AND eh.flg_status IN ('E', 'R')
                  -- 1) Tasks of the same type;
               AND ((i_acronym = 'H' AND ht.acronym IN ('I', 'H'))
                   --user is requesting an intake task and already exists an intake and output task
                   OR (i_acronym = 'I' AND ht.acronym IN ('I', 'H'))
                   
                   -- 2) Exists an intake/output task;
                   --OR ht.acronym = 'H'
                   -- 2.1) User is requesting an intake/output, but already exists another task (of any type) in progress;
                   --OR (i_acronym = 'H' AND ht.acronym <> i_acronym)
                   -- 3) Exists an output task of type "All", and user is requesting a subtype of output (diuresis/drainage), or vice-versa;
                   OR (ht.acronym = 'A' AND i_acronym IN ('D', 'R')) OR (i_acronym = 'A' AND ht.acronym IN ('D', 'R')));
        
            o_msg := REPLACE(pk_message.get_message(i_lang, 'INP_HIDRICS_M001'), '@1', l_int_desc);
            o_msg := REPLACE(o_msg, '@2', l_dt_next);
            o_msg := REPLACE(o_msg, '@3', l_dt_end);
        END IF;
    
        o_exists := l_exists_hidrics_task;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'CHECK_EXISTING_HIDRICS_TASK',
                                              o_error    => o_error);
            RETURN FALSE;
    END check_existing_hidrics_task;

    /**
    * Checks if the current episode already has an intake/output task
    * of the same type, in progress.
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    * @param   i_epis_hids    Epis_hidrics ids
    * @param   o_exists       Exists a draft task of the same type? (Y) Yes (N) No
    * @param   o_exists_draft Exists a task of the same type? (Y) Yes (N) No
    * @param   o_error        Error information
    *
    * @return  TRUE if successful, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version 2.6
    * @since   27-07-2010
    */
    FUNCTION check_existing_hidrics_task
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hids    IN table_number,
        o_exists_draft OUT VARCHAR2,
        o_exists       OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200 CHAR) := 'CHECK_EXISTING_HIDRICS_TASK';
        --
        l_exists_hidrics_task       VARCHAR2(1 CHAR);
        l_exists_hidrics_draft_task VARCHAR2(1 CHAR);
        l_episode                   episode.id_episode%TYPE;
        l_acronym                   hidrics_type.acronym%TYPE;
        l_task_count                NUMBER(6) := 0;
    
    BEGIN
        FOR i IN i_epis_hids.first .. i_epis_hids.last
        LOOP
            g_error := 'GET ID_EPISODE';
            pk_alertlog.log_debug(g_error);
            SELECT eh.id_episode, ht.acronym
              INTO l_episode, l_acronym
              FROM epis_hidrics eh
              JOIN hidrics_type ht
                ON ht.id_hidrics_type = eh.id_hidrics_type
             WHERE eh.id_epis_hidrics = i_epis_hids(i);
        
            SELECT COUNT(*)
              INTO l_task_count
              FROM epis_hidrics eh
              JOIN hidrics_type ht
                ON ht.id_hidrics_type = eh.id_hidrics_type
             WHERE eh.id_episode = l_episode
               AND eh.flg_status = 'D'
               AND eh.id_epis_hidrics <> i_epis_hids(i)
               AND eh.id_epis_hidrics IN (SELECT /*+opt_estimate (table t rows=0.00001)*/
                                           t.column_value
                                            FROM TABLE(i_epis_hids) t)
                  -- 1) Tasks of the same type;
               AND (ht.acronym = l_acronym
                   -- 2) Exists an intake/output task;
                   OR ht.acronym = 'H'
                   -- 2.1) User is requesting an intake/output, but already exists another task (of any type) in progress;
                   OR (l_acronym = 'H' AND ht.acronym <> l_acronym)
                   -- 3) Exists an output task of type "All", and user is requesting a subtype of output (diuresis/drainage), or vice-versa;
                   OR (ht.acronym = 'A' AND l_acronym IN ('D', 'R')) OR (l_acronym = 'A' AND ht.acronym IN ('D', 'R')));
        
            -- If an invalid combination is detected, then the new request should not be allowed.
            IF l_task_count > 0
            THEN
                l_exists_hidrics_draft_task := 'Y';
            END IF;
        
            --IF no invalid combination in draft task is detected
            SELECT COUNT(*)
              INTO l_task_count
              FROM epis_hidrics eh
              JOIN hidrics_type ht
                ON ht.id_hidrics_type = eh.id_hidrics_type
             WHERE eh.id_episode = l_episode
               AND eh.flg_status IN ('E', 'R')
                  -- 1) Tasks of the same type;
               AND (ht.acronym = l_acronym
                   -- 2) Exists an intake/output task;
                   OR ht.acronym = 'H'
                   -- 2.1) User is requesting an intake/output, but already exists another task (of any type) in progress;
                   OR (l_acronym = 'H' AND ht.acronym <> l_acronym)
                   -- 3) Exists an output task of type "All", and user is requesting a subtype of output (diuresis/drainage), or vice-versa;
                   OR (ht.acronym = 'A' AND l_acronym IN ('D', 'R')) OR (l_acronym = 'A' AND ht.acronym IN ('D', 'R')));
        
            -- If an invalid combination is detected, then the new request should not be allowed.
            IF l_task_count > 0
            THEN
                l_exists_hidrics_task := 'Y';
            END IF;
        
        END LOOP;
    
        o_exists_draft := l_exists_hidrics_draft_task;
        o_exists       := l_exists_hidrics_task;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END check_existing_hidrics_task;

    /**
    * Gets hidrics description
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics_line         epis hidrics line id
    *
    * @return  Hidrics description
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   26-05-2010
    */
    FUNCTION get_hidrics_desc
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics_line     IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_dt_epis_hid_line_hist IN epis_hidrics_line_hist.dt_epis_hid_line_hist%TYPE DEFAULT NULL
    ) RETURN pk_translation.t_desc_translation IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_HIDRICS_DESC';
        --
        l_error    t_error_out;
        l_desc_hid table_varchar := table_varchar(NULL);
    BEGIN
        g_error := 'GET HIDRICS';
    
        SELECT coalesce(t.free_text, pk_translation.get_translation(i_lang, t.code_hidrics))
          BULK COLLECT
          INTO l_desc_hid
          FROM (SELECT ef.free_text, h.code_hidrics
                  FROM epis_hidrics_line ehl
                  JOIN hidrics h
                    ON h.id_hidrics = ehl.id_hidrics
                  LEFT JOIN epis_hidrics_det_ftxt ef
                    ON ef.id_hidrics = h.id_hidrics
                   AND ehl.id_epis_hid_ftxt_fluid = ef.id_epis_hidrics_det_ftxt
                 WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line
                   AND (i_dt_epis_hid_line_hist = g_sysdate_tstz OR i_dt_epis_hid_line_hist IS NULL)
                UNION ALL
                SELECT ef.free_text, h.code_hidrics
                  FROM epis_hidrics_line_hist ehl
                  LEFT JOIN epis_hidrics_det_ftxt ef
                    ON ef.id_epis_hidrics_det_ftxt = ehl.id_epis_hid_ftxt_fluid
                  JOIN hidrics h
                    ON h.id_hidrics = ehl.id_hidrics
                 WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line
                   AND ehl.dt_epis_hid_line_hist = i_dt_epis_hid_line_hist
                   AND i_dt_epis_hid_line_hist != g_sysdate_tstz
                   AND i_dt_epis_hid_line_hist IS NOT NULL) t;
    
        IF l_desc_hid.count > 0
        THEN
            RETURN l_desc_hid(l_desc_hid.first);
        ELSE
            RETURN NULL;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_hidrics_desc;

    /**
    * Gets device description
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_id_epis_hidrics_det       epis hidrics det id
    *
    * @return  Hidrics description
    *
    * @author  Sofia Mendes
    * @version v2.6.0.5
    * @since   14-Dez-2010
    */
    FUNCTION get_device_desc
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_epis_hidrics_det  IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        i_dt_epis_hid_det_hist IN epis_hidrics_det_hist.dt_epis_hidrics_det_hist%TYPE DEFAULT NULL
    ) RETURN pk_translation.t_desc_translation IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_DEVICE_DESC';
        --
        l_error    t_error_out;
        l_desc_dev table_varchar := table_varchar(NULL);
    BEGIN
        g_error := 'GET HIDRICS DEVICE DESC';
    
        SELECT coalesce(t.free_text, pk_translation.get_translation(i_lang, t.code_hidrics_device))
          BULK COLLECT
          INTO l_desc_dev
          FROM (SELECT ef.free_text, hd.code_hidrics_device
                  FROM epis_hidrics_det ehd
                  JOIN hidrics_device hd
                    ON hd.id_hidrics_device = ehd.id_hidrics_device
                  LEFT JOIN epis_hidrics_det_ftxt ef
                    ON ef.id_hidrics_device = hd.id_hidrics_device
                   AND ehd.id_epis_hid_ftxt_dev = ef.id_epis_hidrics_det_ftxt
                 WHERE ehd.id_epis_hidrics_det = i_id_epis_hidrics_det
                   AND (i_dt_epis_hid_det_hist = g_sysdate_tstz OR i_dt_epis_hid_det_hist IS NULL)
                UNION ALL
                SELECT ef.free_text, hd.code_hidrics_device
                  FROM epis_hidrics_det_hist ehd
                  JOIN hidrics_device hd
                    ON hd.id_hidrics_device = ehd.id_hidrics_device
                  LEFT JOIN epis_hidrics_det_ftxt ef
                    ON ef.id_epis_hidrics_det_ftxt = ehd.id_epis_hid_ftxt_dev
                 WHERE ehd.id_epis_hidrics_det = i_id_epis_hidrics_det
                   AND ehd.dt_epis_hidrics_det_hist = i_dt_epis_hid_det_hist
                   AND NOT (i_dt_epis_hid_det_hist = g_sysdate_tstz OR i_dt_epis_hid_det_hist IS NULL)) t;
    
        IF l_desc_dev.count > 0
        THEN
            RETURN l_desc_dev(l_desc_dev.first);
        ELSE
            RETURN NULL;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_device_desc;

    /**
    * Get hidric sign
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_hidrics                   hidrics id
    *
    * @return  Hidric sign (+, -, NULL)
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   26-05-2010
    */
    FUNCTION get_hidric_sign
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_hidrics IN hidrics.id_hidrics%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_PROP_LST';
        --
        l_return VARCHAR2(1 CHAR) := NULL;
    BEGIN
        g_error := 'GET HIDRICS TYPE AND RETURN SIGN';
        --O - Other return NULL
        --A - Administration return +
        --E - Elimination return -
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT decode(h.flg_type,
                      pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                      '+',
                      pk_inp_hidrics_constant.g_hidrics_flg_type_e,
                      '-',
                      NULL)
          INTO l_return
          FROM hidrics h
         WHERE h.id_hidrics = i_hidrics;
    
        RETURN l_return;
    END get_hidric_sign;

    /**
    * Gets epis hidrics proposed list
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   o_prop_hidrics              Proposed hidrics cursor
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   26-05-2010
    */
    FUNCTION get_epis_hidrics_prop_lst
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        o_prop_hidrics OUT pk_types.cursor_type,
        o_msg_prop     OUT sys_message.desc_message%TYPE,
        o_flg_show     OUT VARCHAR2,
        o_msg_title    OUT VARCHAR2,
        o_msg          OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_PROP_LST';
        --
        l_cfg_msg      sys_message.code_message%TYPE := 'HIDRICS_T060';
        l_epis_hid_bal epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
    BEGIN
        g_error := 'check_show_conflict_pop for id_epis_hidrics: ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_show_conflict_pop(i_lang                => i_lang,
                                       i_prof                => i_prof,
                                       i_epis_hidrics        => i_epis_hidrics,
                                       i_epis_hidrics_status => NULL,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg                 => o_msg,
                                       o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF (o_flg_show = pk_alert_constant.get_yes)
        THEN
            RETURN TRUE;
        END IF;
    
        g_error := 'GET PROPOSED MSG';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        o_msg_prop := pk_message.get_message(i_lang => i_lang, i_code_mess => l_cfg_msg);
    
        g_error := 'GET CURRENT BALANCE ID';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_epis_hid_bal := pk_inp_hidrics.get_balance_id(i_lang         => i_lang,
                                                        i_prof         => i_prof,
                                                        i_epis_hidrics => i_epis_hidrics,
                                                        i_dt_exec      => g_sysdate_tstz);
    
        g_error := 'GET EPIS_HIDRICS_PROP_LST';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_prop_hidrics FOR
            SELECT ehd.id_epis_hidrics_det,
                   ehl.id_hidrics,
                   pk_inp_hidrics.get_hidrics_desc(i_lang, i_prof, ehl.id_epis_hidrics_line) || ' (' ||
                   pk_inp_hidrics.get_hidrics_um(i_lang, i_prof, ehd.id_epis_hidrics) || ')' desc_hidrics_desc,
                   pk_inp_hidrics.get_hidrics_um(i_lang, i_prof, ehd.id_epis_hidrics) desc_unit_measure,
                   pk_inp_hidrics.get_hidric_sign(i_lang, i_prof, ehl.id_hidrics) value_hidrics_sign,
                   ehd.value_hidrics,
                   pk_date_utils.dt_chr_tsz(i_lang, ehd.dt_execution_tstz, i_prof) desc_date,
                   pk_date_utils.date_char_hour_tsz(i_lang, ehd.dt_execution_tstz, i_prof.institution, i_prof.software) desc_hour,
                   pk_date_utils.date_send_tsz(i_lang, ehd.dt_execution_tstz, i_prof) dt_execution_tstz
              FROM epis_hidrics_det ehd
              JOIN epis_hidrics_line ehl
                ON ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line
             WHERE ehd.id_epis_hidrics = i_epis_hidrics
               AND ehd.flg_type = pk_inp_hidrics_constant.g_epis_hid_det_type_p
               AND ehd.id_epis_hidrics_balance = l_epis_hid_bal
               AND ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_prop_hidrics);
            RETURN FALSE;
    END get_epis_hidrics_prop_lst;

    /**
    * Sets epis hidrics proposed to administered
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   i_prop_hidrics              Table with epis hidrics det id
    * @param   i_prop_hid_dt               Table with dates of execution
    * @param   i_prop_hid_val              Table with values
    * @param   i_flg_chg_bal_dt            Is to change the next balance data? Y - Yes; Otherwise N
    * @param   o_epis_hid_bal              New epis hidrics balance id
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   26-05-2010
    */
    FUNCTION set_epis_hidrics_prop_lst
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_hidrics   IN epis_hidrics.id_epis_hidrics%TYPE,
        i_prop_hidrics   IN table_number,
        i_prop_hid_dt    IN table_varchar,
        i_prop_hid_val   IN table_number,
        i_flg_chg_bal_dt IN VARCHAR2,
        o_epis_hid_bal   OUT epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_flg_show       OUT VARCHAR2,
        o_msg_title      OUT VARCHAR2,
        o_msg            OUT VARCHAR2,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'SET_EPIS_HIDRICS_PROP_LST';
        --
        l_id_balance epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_dt_open    epis_hidrics_balance.dt_open_tstz%TYPE;
        l_t_hidrics  table_number;
        l_id_hidrics hidrics.id_hidrics%TYPE;
        l_dt_exec    epis_hidrics_det.dt_execution_tstz%TYPE;
        --
        l_id_episode   episode.id_episode%TYPE;
        l_max_intake   epis_hidrics.max_intake%TYPE;
        l_min_output   epis_hidrics.min_output%TYPE;
        l_hidrics_type epis_hidrics.id_hidrics_type%TYPE;
        l_msg_text     sys_message.desc_message%TYPE;
        l_msg_title    sys_message.desc_message%TYPE;
        --
        l_future_prop_list table_number;
        --
        l_error_title   sys_message.desc_message%TYPE;
        l_error_message sys_message.desc_message%TYPE;
        l_desc_hidrics  pk_translation.t_desc_translation;
        l_common_error EXCEPTION;
        --
        i PLS_INTEGER;
    BEGIN
    
        g_error := 'check_show_conflict_pop for id_epis_hidrics: ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_show_conflict_pop(i_lang                => i_lang,
                                       i_prof                => i_prof,
                                       i_epis_hidrics        => i_epis_hidrics,
                                       i_epis_hidrics_status => NULL,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg                 => o_msg,
                                       o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF (o_flg_show = pk_alert_constant.get_yes)
        THEN
            RETURN TRUE;
        END IF;
    
        g_error := 'GET CURRENT BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_id_balance := get_balance_id(i_lang         => i_lang,
                                       i_prof         => i_prof,
                                       i_epis_hidrics => i_epis_hidrics,
                                       i_dt_exec      => g_sysdate_tstz);
    
        g_error := 'GET EPIS_HIDRICS DATA';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT eb.dt_open_tstz, eh.id_episode, eh.max_intake, eh.min_output, eh.id_hidrics_type
          INTO l_dt_open, l_id_episode, l_max_intake, l_min_output, l_hidrics_type
          FROM epis_hidrics_balance eb
          JOIN epis_hidrics eh
            ON eh.id_epis_hidrics = eb.id_epis_hidrics
         WHERE eb.id_epis_hidrics_balance = l_id_balance;
    
        g_error := 'GET FUTURE PROP VALUES LIST';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT ehd.id_epis_hidrics_det
          BULK COLLECT
          INTO l_future_prop_list
          FROM epis_hidrics_det ehd
         WHERE ehd.id_epis_hidrics = i_epis_hidrics
           AND ehd.flg_type = pk_inp_hidrics_constant.g_epis_hid_det_type_p
           AND ehd.id_epis_hidrics_balance = l_id_balance
           AND ehd.id_epis_hidrics_det NOT IN (SELECT /*+opt_estimate (table t rows=0.000001)*/
                                                column_value
                                                 FROM TABLE(i_prop_hidrics) t)
           AND ehd.dt_execution_tstz > g_sysdate_tstz;
    
        IF i_prop_hidrics IS NOT NULL
           AND i_prop_hidrics.count > 0
        THEN
            g_error := 'SET PROPOSED HIDRICS TO ';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            i := i_prop_hidrics.first;
        
            l_t_hidrics := table_number();
        
            g_error := 'LOOP PROP VALUES';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            <<proposed_hidrics>>
            WHILE i IS NOT NULL
            LOOP
            
                l_dt_exec := pk_date_utils.get_string_tstz(i_lang, i_prof, i_prop_hid_dt(i), NULL);
            
                IF l_dt_exec NOT BETWEEN l_dt_open AND g_sysdate_tstz
                THEN
                    l_error_title   := pk_message.get_message(i_lang, 'HIDRICS_T082');
                    l_error_message := pk_message.get_message(i_lang, 'HIDRICS_M032');
                    RAISE l_common_error;
                END IF;
            
                BEGIN
                    SELECT el.id_hidrics
                      INTO l_id_hidrics
                      FROM epis_hidrics_det ed
                      JOIN epis_hidrics_line el
                        ON el.id_epis_hidrics_line = ed.id_epis_hidrics_line
                      JOIN epis_hidrics_det ed2
                        ON ed2.id_epis_hidrics_line = el.id_epis_hidrics_line
                     WHERE ed.id_epis_hidrics_det = i_prop_hidrics(i)
                       AND ed2.dt_execution_tstz = l_dt_exec
                       AND ed2.id_epis_hidrics_det <> ed.id_epis_hidrics_det;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_id_hidrics := NULL;
                END;
            
                IF l_id_hidrics IS NULL
                THEN
                    g_error := 'SEND TO HIST ID_EPIS_HIDRICS_DET ' || i_prop_hidrics(i);
                    pk_alertlog.log_debug(g_error);
                    set_epis_hid_det_hist(i_epis_hidrics_det => i_prop_hidrics(i));
                    --
                    ts_epis_hidrics_det.upd(id_epis_hidrics_det_in => i_prop_hidrics(i),
                                            flg_type_in            => pk_inp_hidrics_constant.g_epis_hid_det_type_a,
                                            dt_execution_tstz_in   => l_dt_exec,
                                            value_hidrics_in       => i_prop_hid_val(i),
                                            id_prof_last_change_in => i_prof.id,
                                            dt_epis_hidrics_det_in => g_sysdate_tstz);
                
                    g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    IF NOT check_restriction_alerts(i_lang         => i_lang,
                                                    i_prof         => i_prof,
                                                    i_episode      => l_id_episode,
                                                    i_epis_hidrics => i_epis_hidrics,
                                                    i_epis_balance => l_id_balance,
                                                    i_max_intake   => l_max_intake,
                                                    i_min_output   => l_min_output,
                                                    i_hidrics_type => l_hidrics_type,
                                                    i_flg_context  => pk_inp_hidrics_constant.g_context_new_record,
                                                    i_dt_execution => l_dt_exec,
                                                    o_msg_title    => l_msg_title,
                                                    o_msg_text     => l_msg_text,
                                                    o_error        => o_error)
                    THEN
                        RAISE e_error;
                    END IF;
                
                ELSE
                    l_t_hidrics := l_t_hidrics MULTISET UNION DISTINCT table_number(l_id_hidrics);
                END IF;
            
                i := i_prop_hidrics.next(i);
            END LOOP proposed_hidrics;
        
            g_error := 'CHECK INVALID VALUES';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF l_t_hidrics.count > 0
            THEN
            
                l_error_title   := pk_message.get_message(i_lang, 'HIDRICS_T082');
                l_error_message := pk_message.get_message(i_lang, 'HIDRICS_M033') || chr(10);
            
                FOR j IN 1 .. l_t_hidrics.count
                LOOP
                    SELECT pk_translation.get_translation(i_lang, h.code_hidrics)
                      INTO l_desc_hidrics
                      FROM hidrics h
                     WHERE h.id_hidrics = l_t_hidrics(j);
                
                    l_error_message := l_error_message || chr(10) || '- ' || l_desc_hidrics;
                
                END LOOP;
            
                RAISE l_common_error;
            END IF;
        
            g_error := 'CALL TO SET_DT_FIRST_REG_BALANCE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF NOT set_dt_first_reg_balance(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_epis_hidrics => i_epis_hidrics,
                                            i_epis_hid_bal => l_id_balance,
                                            o_error        => o_error)
            THEN
                RAISE e_error;
            END IF;
        END IF;
    
        g_error := 'CALL TO PK_INP_HIDRICS.SET_BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT pk_inp_hidrics.set_balance(i_lang           => i_lang,
                                          i_prof           => i_prof,
                                          i_epis_hidrics   => i_epis_hidrics,
                                          i_flg_chg_bal_dt => i_flg_chg_bal_dt,
                                          o_epis_hid_bal   => o_epis_hid_bal,
                                          o_error          => o_error)
        THEN
            RAISE e_error;
        END IF;
    
        IF l_future_prop_list IS NOT NULL
           AND l_future_prop_list.count > 0
        THEN
            g_error := 'SEND TO HIST FUTURE PROP VALUES ID_EPIS_HIDRICS_DET IN (' ||
                       pk_utils.concat_table(l_future_prop_list, ',') || ')';
            pk_alertlog.log_debug(g_error);
            set_epis_hid_det_hist(i_where => 'id_epis_hidrics_det IN (' ||
                                             pk_utils.concat_table(l_future_prop_list, ',') || ')');
        
            g_error := 'UPDATE BALANCE OF FUTURE PROP VALUES. O_EPIS_HID_BAL: ' || o_epis_hid_bal;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            ts_epis_hidrics_det.upd(id_epis_hidrics_balance_in => o_epis_hid_bal,
                                    id_prof_last_change_in     => i_prof.id,
                                    dt_epis_hidrics_det_in     => g_sysdate_tstz,
                                    where_in                   => 'id_epis_hidrics_det IN (' ||
                                                                  pk_utils.concat_table(l_future_prop_list, ',') || ')');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_common_error THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   l_func_name,
                                   NULL,
                                   'U',
                                   l_error_title);
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_alert_exceptions.reset_error_state();
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_epis_hidrics_prop_lst;

    /**
    * Formats text for max. intake or min. output
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_label                     Text with label "Max. intake" or "Min. output"
    * @param   i_value                     Value of max. intake or min. output
    * @param   i_unit_measure_desc         Label for the unit
    *
    * @return  Formatted string
    *
    * @author  José rito
    * @version v2.6.0.3
    * @since   26-05-2010
    */
    FUNCTION get_intake_output_text
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_label             IN sys_message.desc_message%TYPE,
        i_value             IN NUMBER,
        i_unit_measure_desc IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(200 CHAR) := 'GET_INTAKE_OUTPUT_TEXT';
        l_full_text VARCHAR2(4000 CHAR) := '';
        l_error     t_error_out;
    BEGIN
        IF i_value IS NOT NULL
        THEN
            g_error := 'GET FULL TEXT';
            pk_alertlog.log_debug(g_error);
            l_full_text := i_label || ' ' || i_value || ' ' || i_unit_measure_desc;
        END IF;
    
        RETURN l_full_text;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN NULL;
    END get_intake_output_text;

    /*******************************************************************************************************************************************
    * get_hidrics_um_id               Get the unit measure that is used in this hidrics record
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * 
    * @return                         Unit measure ID
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/05/27
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_um_id
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics          IN epis_hidrics.id_epis_hidrics%TYPE,
        i_dt_epis_hbalance_hist IN epis_hbalance_hist.dt_epis_hbalance_hist%TYPE DEFAULT NULL
    ) RETURN NUMBER IS
    
        l_error           t_error_out;
        l_id_unit_measure unit_measure.id_unit_measure%TYPE;
        l_exception EXCEPTION;
    
        CURSOR c_epis_balance IS
            SELECT t.id_unit_measure
              FROM (SELECT ehb.id_unit_measure, ehb.dt_open_tstz
                      FROM epis_hidrics_balance ehb
                     WHERE ehb.id_epis_hidrics = i_epis_hidrics
                       AND i_dt_epis_hbalance_hist IS NULL
                    UNION ALL
                    SELECT ehbh.id_unit_measure, ehbh.dt_open_tstz
                      FROM epis_hbalance_hist ehbh
                     WHERE ehbh.id_epis_hidrics = i_epis_hidrics
                       AND ehbh.dt_epis_hbalance_hist =
                           (SELECT MAX(ehbh2.dt_epis_hbalance_hist)
                              FROM epis_hbalance_hist ehbh2
                             WHERE ehbh2.id_epis_hidrics = i_epis_hidrics
                               AND ehbh2.dt_epis_hbalance_hist <= i_dt_epis_hbalance_hist)) t
             ORDER BY t.dt_open_tstz DESC;
    BEGIN
    
        g_error := 'GET CURSOR C_EPIS_BALANCE';
        OPEN c_epis_balance;
        FETCH c_epis_balance
            INTO l_id_unit_measure;
        CLOSE c_epis_balance;
    
        IF l_id_unit_measure IS NULL
        THEN
            l_id_unit_measure := pk_sysconfig.get_config('HIDRICS_UNIT_MEAS', i_prof);
        END IF;
    
        IF l_id_unit_measure IS NULL
        THEN
            g_error := 'UNIT MEASURE NOT DEFINED';
            RAISE l_exception;
        END IF;
    
        --
        RETURN l_id_unit_measure;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_UM_ID',
                                              l_error);
            RETURN NULL;
    END get_hidrics_um_id;

    /*******************************************************************************************************************************************
    * get_hidrics_um                  Get the unit measure that is used in this hidrics record
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * 
    * @return                         Unit measure description
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/05/27
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_um
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics          IN epis_hidrics.id_epis_hidrics%TYPE,
        i_dt_epis_hbalance_hist IN epis_hbalance_hist.dt_epis_hbalance_hist%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
    
        l_error   t_error_out;
        l_desc_um pk_translation.t_desc_translation;
        l_exception EXCEPTION;
    
    BEGIN
    
        l_desc_um := pk_unit_measure.get_uom_abbreviation(i_lang,
                                                          i_prof,
                                                          get_hidrics_um_id(i_lang,
                                                                            i_prof,
                                                                            i_epis_hidrics,
                                                                            i_dt_epis_hbalance_hist));
    
        --
        RETURN l_desc_um;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_UM',
                                              l_error);
            RETURN NULL;
    END get_hidrics_um;

    /**
    * Gets the default unit measure used in intake and output amounts.
    *
    * @param   i_lang                Professional preferred language
    * @param   i_prof                Professional identification and its context (institution and software)
    * @param   o_unit_measure        Unit measure data
    * @param   o_error               Error information
    *
    * @return  TRUE if successful, FALSE otherwise
    *
    * @author  JOSE.BRITO
    * @version 2.6
    * @since   02-06-2010
    */
    FUNCTION get_hidrics_um
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        o_unit_measure OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name       VARCHAR2(200 CHAR) := 'GET_HIDRICS_UM';
        l_id_unit_measure unit_measure.id_unit_measure%TYPE;
    BEGIN
    
        l_id_unit_measure := pk_sysconfig.get_config('HIDRICS_UNIT_MEAS', i_prof);
    
        IF l_id_unit_measure IS NOT NULL
        THEN
            g_error := 'GET UNIT MEASURE DATA';
            pk_alertlog.log_debug(g_error);
            OPEN o_unit_measure FOR
                SELECT um.id_unit_measure,
                       pk_translation.get_translation(i_lang, um.code_unit_measure) desc_unit_measure
                  FROM unit_measure um
                 WHERE um.id_unit_measure = l_id_unit_measure;
        
        ELSE
            g_error := 'UNIT MEASURE NOT DEFINED';
            pk_alertlog.log_debug(g_error);
            pk_types.open_my_cursor(o_unit_measure);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_unit_measure);
            RETURN FALSE;
    END get_hidrics_um;

    FUNCTION get_hidrics_location_int
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics_line     IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_desc_body_part        IN VARCHAR2 DEFAULT '',
        i_desc_body_side        IN VARCHAR2 DEFAULT '',
        i_dt_epis_hid_line_hist IN epis_hidrics_line_hist.dt_epis_hid_line_hist%TYPE DEFAULT NULL,
        o_desc_body_part        OUT VARCHAR2,
        o_desc_body_side        OUT VARCHAR2,
        o_desc_location         OUT VARCHAR2,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        IF i_epis_hidrics_line IS NOT NULL
        THEN
            g_error := 'GET HIDRICS LOCATION_INT (' || --
                       'i_lang=' || i_lang || --
                       '; i_prof = profissional(' || i_prof.id || ',' || i_prof.institution || ',' || i_prof.software || ')' || --
                       '; i_epis_hidrics_line = ' || i_epis_hidrics_line || --
                       '; i_desc_body_part = ' || i_desc_body_part || --
                       '; i_desc_body_side = ' || i_desc_body_side || --
                       '; i_dt_epis_hid_line_hist = ' || i_dt_epis_hid_line_hist;
            BEGIN
                SELECT nvl(t.free_text, pk_translation.get_translation(i_lang, t.code_body_part)) ||
                       nvl2(t.id_body_side, ' (' || pk_translation.get_translation(i_lang, t.code_body_side) || ')', ''),
                       nvl(t.free_text, pk_translation.get_translation(i_lang, t.code_body_part)),
                       nvl2(t.id_body_side, pk_translation.get_translation(i_lang, t.code_body_side), '')
                  INTO o_desc_location, o_desc_body_part, o_desc_body_side
                  FROM (SELECT ef.free_text, bp.code_body_part, bs.id_body_side, bs.code_body_side
                          FROM epis_hidrics_line ehl
                          JOIN hidrics_location hl
                            ON hl.id_hidrics_location = ehl.id_hidrics_location
                          LEFT JOIN epis_hidrics_det_ftxt ef
                            ON hl.id_hidrics_location = ef.id_hidrics_location
                           AND ef.id_epis_hidrics_det_ftxt = ehl.id_epis_hid_ftxt_loc
                          LEFT JOIN body_part bp
                            ON hl.id_body_part = bp.id_body_part
                          LEFT JOIN body_side bs
                            ON hl.id_body_side = bs.id_body_side
                         WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line
                           AND (i_dt_epis_hid_line_hist = g_sysdate_tstz OR i_dt_epis_hid_line_hist IS NULL)
                        UNION ALL
                        SELECT efh.free_text, bp.code_body_part, bs.id_body_side, bs.code_body_side
                          FROM epis_hidrics_line_hist ehlh
                          LEFT JOIN epis_hidrics_det_ftxt efh
                            ON efh.id_epis_hidrics_det_ftxt = ehlh.id_epis_hid_ftxt_loc
                          JOIN hidrics_location hl
                            ON hl.id_hidrics_location = ehlh.id_hidrics_location
                          LEFT JOIN body_part bp
                            ON hl.id_body_part = bp.id_body_part
                          LEFT JOIN body_side bs
                            ON hl.id_body_side = bs.id_body_side
                         WHERE ehlh.id_epis_hidrics_line = i_epis_hidrics_line
                           AND i_dt_epis_hid_line_hist != g_sysdate_tstz
                           AND i_dt_epis_hid_line_hist IS NOT NULL
                           AND ehlh.dt_epis_hid_line_hist = i_dt_epis_hid_line_hist) t;
            EXCEPTION
                WHEN no_data_found THEN
                    o_desc_body_part := NULL;
                    o_desc_body_side := NULL;
                    o_desc_location  := NULL;
            END;
        ELSE
            IF i_desc_body_side IS NOT NULL
            THEN
                o_desc_location  := ' (' || i_desc_body_side || ')';
                o_desc_body_side := i_desc_body_side;
            END IF;
        
            o_desc_location  := i_desc_body_part || o_desc_location;
            o_desc_body_part := i_desc_body_part;
        END IF;
    
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_LOCATION_INT',
                                              o_error);
            RETURN FALSE;
    END get_hidrics_location_int;

    /*******************************************************************************************************************************************
    * get_hidrics_location            Get the location registered in this hidrics record
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS_LINE      EPIS_HIDRICS_LINE ID
    * 
    * @return                         Unit measure description
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/05/27
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_location
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics_line     IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_desc_body_part        IN VARCHAR2 DEFAULT '',
        i_desc_body_side        IN VARCHAR2 DEFAULT '',
        i_dt_epis_hid_line_hist IN epis_hidrics_line_hist.dt_epis_hid_line_hist%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
    
        l_error          t_error_out;
        l_desc_location  pk_translation.t_desc_translation;
        l_desc_body_part pk_translation.t_desc_translation;
        l_desc_body_side pk_translation.t_desc_translation;
    
    BEGIN
    
        IF NOT get_hidrics_location_int(i_lang                  => i_lang,
                                        i_prof                  => i_prof,
                                        i_epis_hidrics_line     => i_epis_hidrics_line,
                                        i_desc_body_part        => i_desc_body_part,
                                        i_desc_body_side        => i_desc_body_side,
                                        i_dt_epis_hid_line_hist => i_dt_epis_hid_line_hist,
                                        o_desc_body_part        => l_desc_body_part,
                                        o_desc_body_side        => l_desc_body_side,
                                        o_desc_location         => l_desc_location,
                                        o_error                 => l_error)
        THEN
            RAISE e_error;
        END IF;
    
        --
        RETURN l_desc_location;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_LOCATION',
                                              l_error);
            RETURN NULL;
    END get_hidrics_location;

    /*******************************************************************************************************************************************
    * get_hidrics_value               Get the location registered in this hidrics record
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_HIDRICS_VALUE          Registered value
    * @param I_HIDRICS_TYPE           Hidrics type (administration or elimination)
    * 
    * @return                         Formatted value
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/05/27
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_value
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_hidrics_value IN epis_hidrics_det.value_hidrics%TYPE,
        i_hidrics_type  IN hidrics.flg_type%TYPE
    ) RETURN VARCHAR2 IS
    
        l_error         t_error_out;
        l_desc_value    VARCHAR2(200 CHAR);
        l_hidrics_value VARCHAR2(30 CHAR) := pk_utils.number_to_char(i_prof, i_hidrics_value);
    
    BEGIN
    
        g_error := 'GET HIDRICS VALUE';
        IF i_hidrics_value IS NULL
        THEN
            l_desc_value := ' ';
        ELSIF (i_hidrics_value = 0 AND i_hidrics_type = pk_inp_hidrics_constant.g_hidrics_flg_type_a)
        THEN
            l_desc_value := l_hidrics_value;
        ELSIF (i_hidrics_type IS NULL AND i_hidrics_value > 0)
              OR i_hidrics_type = pk_inp_hidrics_constant.g_hidrics_flg_type_a
        THEN
            l_desc_value := '+' || l_hidrics_value;
        ELSIF i_hidrics_type IS NOT NULL
              AND i_hidrics_value <> 0
        THEN
            l_desc_value := '-' || l_hidrics_value;
        ELSE
            l_desc_value := l_hidrics_value;
        END IF;
    
        --
        RETURN l_desc_value;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_VALUE',
                                              l_error);
            RETURN NULL;
    END get_hidrics_value;

    /*******************************************************************************************************************************************
    * get_hidrics_total_balance  Get the total amount registered in the balance
    * 
    * @param I_LANG              Language ID for translations
    * @param I_PROF              Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS      Episode hidrics ID
    * @param I_HIDRICS_BALANCE   Balance ID
    * @param I_HIDRICS           Hidrics ID
    * @param I_HIDRICS_TYPE      Hidrics type ID
    * @param I_EPIS_HIDR_LINE    Hidrics line ID
    * @param I_DRUG_PRESC_DET    IV fluid prescription ID
    * @param I_DT_REG            Record date
    * @param I_FLG_REG_TYPE      Record type when counting total values: N - regular values, T - balance values
    * @param I_FLG_REAL_VALUE    Returns real value: Y - Yes, N - No
    * @param I_DT_INIT_BAL       Date where the current balance begins
    * @param i_epis_hidrics_group Epis hidrics group ID
    * @param i_dt_init_balance    Epis hidrics group ID
    * 
    * @return                         Formatted value
    *
    * @author                         José Silva
    * @version                        2.6.0.3
    * @since                          2010/05/27
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_total_balance
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_epis_hidrics       IN epis_hidrics.id_epis_hidrics%TYPE,
        i_hidrics_balance    IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        i_hidrics            IN hidrics.id_hidrics%TYPE,
        i_hidrics_type       IN hidrics.flg_type%TYPE,
        i_epis_hidr_line     IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_drug_presc_det     IN pk_api_pfh_in.r_presc.id_presc%TYPE,
        i_dt_reg             IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_reg_type       IN VARCHAR2,
        i_flg_real_value     IN VARCHAR2 DEFAULT 'N',
        i_epis_hidrics_group IN epis_hidrics_group.id_epis_hidrics_group%TYPE DEFAULT NULL,
        i_dt_init_balance    IN epis_hidrics_balance.dt_open_tstz%TYPE
    ) RETURN VARCHAR2 IS
    
        l_error        t_error_out;
        l_desc_balance VARCHAR2(200 CHAR);
    
        l_normal CONSTANT VARCHAR2(1 CHAR) := 'N';
        l_total  CONSTANT VARCHAR2(1 CHAR) := 'T';
    
        l_value epis_hidrics_det.value_hidrics%TYPE;
    
        l_import_iv_fluids sys_config.id_sys_config%TYPE;
    
        l_flg_close_type epis_hidrics_balance.flg_close_type%TYPE;
        l_prev_auto_bal  epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_epis_balances  table_number;
    
        CURSOR c_hidrics_det(epis_balance table_number) IS
            SELECT SUM(ed.value_hidrics)
              FROM epis_hidrics_det ed
              JOIN epis_hidrics_line ehl
                ON ehl.id_epis_hidrics_line = ed.id_epis_hidrics_line
              LEFT JOIN epis_hd_line_group ehlg
                ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line
             WHERE ed.id_epis_hidrics_balance IN (SELECT /*+opt_estimate (table t rows=0.000001)*/
                                                   column_value
                                                    FROM TABLE(epis_balance) t)
               AND ehl.id_epis_hidrics_line = i_epis_hidr_line
               AND nvl(ed.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                   pk_inp_hidrics_constant.g_epis_hid_det_type_a
               AND ed.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a
               AND (ehlg.id_epis_hidrics_group = i_epis_hidrics_group OR i_epis_hidrics_group IS NULL);
    
        CURSOR c_hidrics_med IS
            SELECT nvl(pk_api_pfh_clindoc_in.get_fluid_balance_med_tot(i_lang,
                                                                       i_prof,
                                                                       i_epis_hidrics,
                                                                       eb.dt_open_tstz,
                                                                       eb.dt_close_balance_tstz,
                                                                       i_drug_presc_det),
                       0)
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics_balance = i_hidrics_balance;
    
        --value of the cells of the intake or output totals
        CURSOR c_hidrics_det_total1 IS
            SELECT nvl(SUM(ed.value_hidrics), 0) + CASE
                        WHEN l_import_iv_fluids = pk_alert_constant.g_yes THEN
                         decode(i_hidrics_type,
                                pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                                nvl(pk_api_pfh_clindoc_in.get_fluid_balance_med_tot(i_lang,
                                                                                    i_prof,
                                                                                    i_epis_hidrics,
                                                                                    i_dt_reg,
                                                                                    i_dt_reg),
                                    0),
                                0)
                        ELSE
                         0
                    END
              FROM epis_hidrics_det ed
              JOIN epis_hidrics_line ehl
                ON ehl.id_epis_hidrics_line = ed.id_epis_hidrics_line
              LEFT JOIN epis_hd_line_group ehlg
                ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line
              JOIN hidrics h
                ON h.id_hidrics = ehl.id_hidrics
             WHERE ed.id_epis_hidrics = i_epis_hidrics
               AND ed.dt_execution_tstz = i_dt_reg
               AND h.flg_type = i_hidrics_type
               AND nvl(ed.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                   pk_inp_hidrics_constant.g_epis_hid_det_type_a
               AND ed.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a
               AND (ehlg.id_epis_hidrics_group = i_epis_hidrics_group OR i_epis_hidrics_group IS NULL);
    
        --value of the cells of the intake and output totals
        CURSOR c_hidrics_det_total2 IS
            SELECT nvl(SUM(a.value_h), 0) + CASE
                        WHEN l_import_iv_fluids = pk_alert_constant.g_yes THEN
                         nvl(pk_api_pfh_clindoc_in.get_fluid_balance_med_tot(i_lang,
                                                                             i_prof,
                                                                             i_epis_hidrics,
                                                                             i_dt_reg,
                                                                             i_dt_reg),
                             0)
                        ELSE
                         0
                    END
              FROM (SELECT decode(h.flg_type,
                                  pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                                  ed.value_hidrics,
                                  -ed.value_hidrics) value_h
                      FROM epis_hidrics_det ed
                      JOIN epis_hidrics_line ehl
                        ON ehl.id_epis_hidrics_line = ed.id_epis_hidrics_line
                      JOIN hidrics h
                        ON h.id_hidrics = ehl.id_hidrics
                     WHERE ed.id_epis_hidrics = i_epis_hidrics
                       AND ed.dt_execution_tstz = i_dt_reg
                       AND nvl(ed.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                           pk_inp_hidrics_constant.g_epis_hid_det_type_a
                       AND ed.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a) a;
    
        --group total balance cells
        CURSOR c_group_total IS
            SELECT nvl(SUM(a.value_h), 0)
              FROM (SELECT decode(h.flg_type,
                                  pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                                  ed.value_hidrics,
                                  -ed.value_hidrics) value_h
                      FROM epis_hidrics_det ed
                      JOIN epis_hidrics_line ehl
                        ON ehl.id_epis_hidrics_line = ed.id_epis_hidrics_line
                      LEFT JOIN epis_hd_line_group ehlg
                        ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line
                      JOIN hidrics h
                        ON h.id_hidrics = ehl.id_hidrics
                     WHERE ed.id_epis_hidrics = i_epis_hidrics
                       AND nvl(ed.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                           pk_inp_hidrics_constant.g_epis_hid_det_type_a
                       AND ed.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a
                       AND (ehlg.id_epis_hidrics_group = i_epis_hidrics_group OR i_epis_hidrics_group IS NULL)
                       AND (ed.dt_execution_tstz >= i_dt_init_balance OR i_dt_init_balance IS NULL)
                       AND (ed.dt_execution_tstz <= i_dt_reg OR i_dt_reg IS NULL)) a;
    
        --group column total
        CURSOR c_group_total_normal IS
            SELECT nvl(SUM(a.value_h), 0)
              FROM (SELECT decode(h.flg_type,
                                  pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                                  ed.value_hidrics,
                                  -ed.value_hidrics) value_h
                      FROM epis_hidrics_det ed
                      JOIN epis_hidrics_line ehl
                        ON ehl.id_epis_hidrics_line = ed.id_epis_hidrics_line
                      JOIN epis_hd_line_group ehlg
                        ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line
                      JOIN hidrics h
                        ON h.id_hidrics = ehl.id_hidrics
                     WHERE ed.id_epis_hidrics = i_epis_hidrics
                       AND ed.dt_execution_tstz = i_dt_reg
                       AND nvl(ed.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                           pk_inp_hidrics_constant.g_epis_hid_det_type_a
                       AND ed.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a
                       AND ehlg.id_epis_hidrics_group = i_epis_hidrics_group) a;
    
        CURSOR c_hidrics_det_max IS
            SELECT MAX(value_h)
              FROM (SELECT SUM(ed.value_hidrics) value_h, ed.dt_execution_tstz, ed.flg_type
                      FROM epis_hidrics_det ed
                      JOIN epis_hidrics_line ehl
                        ON ehl.id_epis_hidrics_line = ed.id_epis_hidrics_line
                      JOIN hidrics h
                        ON h.id_hidrics = ehl.id_hidrics
                      LEFT JOIN epis_hd_line_group ehlg
                        ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line
                     WHERE ed.id_epis_hidrics = i_epis_hidrics
                       AND nvl(ed.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                           pk_inp_hidrics_constant.g_epis_hid_det_type_a
                       AND ed.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a
                       AND (ehlg.id_epis_hidrics_group = i_epis_hidrics_group OR i_epis_hidrics_group IS NULL)
                     GROUP BY ed.dt_execution_tstz, ed.flg_type);
    
        CURSOR c_hidrics_total_balance IS
            SELECT decode(i_hidrics_type,
                           pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                           nvl(eb.total_admin, 0),
                           nvl(eb.total_elim, 0)) + CASE
                        WHEN l_import_iv_fluids = pk_alert_constant.g_yes THEN
                         decode(i_hidrics_type,
                                pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                                nvl(pk_api_pfh_clindoc_in.get_fluid_balance_med_tot(i_lang,
                                                                                    i_prof,
                                                                                    i_epis_hidrics,
                                                                                    eb.dt_open_tstz,
                                                                                    i_dt_reg),
                                    0),
                                0)
                        ELSE
                         0
                    END
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics = i_epis_hidrics
               AND eb.dt_close_balance_tstz = i_dt_reg;
    
        CURSOR c_hidrics_total IS
            SELECT nvl(eb.total_admin, 0) - nvl(eb.total_elim, 0) + CASE
                        WHEN l_import_iv_fluids = pk_alert_constant.g_yes THEN
                         nvl(pk_api_pfh_clindoc_in.get_fluid_balance_med_tot(i_lang,
                                                                             i_prof,
                                                                             i_epis_hidrics,
                                                                             eb.dt_open_tstz,
                                                                             i_dt_reg),
                             0)
                        ELSE
                         0
                    END
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics = i_epis_hidrics
               AND eb.dt_close_balance_tstz = i_dt_reg;
    
    BEGIN
    
        g_error := 'GET import_iv_fluids sys_config';
        pk_alertlog.log_debug(g_error);
        l_import_iv_fluids := pk_sysconfig.get_config(i_code_cf => pk_inp_hidrics_constant.g_import_iv_fluids,
                                                      i_prof    => i_prof);
    
        g_error := 'GET HIDRICS TOTAL BALANCE';
        IF i_drug_presc_det IS NOT NULL
           AND l_import_iv_fluids = pk_alert_constant.g_yes
        THEN
            OPEN c_hidrics_med;
            FETCH c_hidrics_med
                INTO l_value;
            CLOSE c_hidrics_med;
        ELSIF i_hidrics_balance IS NOT NULL
        THEN
            l_epis_balances := get_prev_manual_balances(i_lang                  => i_lang,
                                                        i_prof                  => i_prof,
                                                        i_epis_hidrics          => i_epis_hidrics,
                                                        i_epis_hidrics_balance  => i_hidrics_balance,
                                                        i_flg_close_type        => NULL,
                                                        i_dt_close_balance_tstz => NULL);
        
            OPEN c_hidrics_det(l_epis_balances);
            FETCH c_hidrics_det
                INTO l_value;
            CLOSE c_hidrics_det;
        ELSIF i_flg_reg_type = l_normal
        THEN
            IF i_epis_hidrics_group IS NULL
            THEN
                IF i_hidrics_type IS NOT NULL
                THEN
                    OPEN c_hidrics_det_total1;
                    FETCH c_hidrics_det_total1
                        INTO l_value;
                    CLOSE c_hidrics_det_total1;
                
                ELSE
                    OPEN c_hidrics_det_total2;
                    FETCH c_hidrics_det_total2
                        INTO l_value;
                    CLOSE c_hidrics_det_total2;
                END IF;
            ELSE
                OPEN c_group_total_normal;
                FETCH c_group_total_normal
                    INTO l_value;
                CLOSE c_group_total_normal;
            
            END IF;
        
        ELSIF i_flg_reg_type = l_total
        THEN
            IF i_epis_hidrics_group IS NULL
            THEN
                IF i_hidrics_type IS NOT NULL
                THEN
                    OPEN c_hidrics_total_balance;
                    FETCH c_hidrics_total_balance
                        INTO l_value;
                    CLOSE c_hidrics_total_balance;
                ELSE
                    OPEN c_hidrics_total;
                    FETCH c_hidrics_total
                        INTO l_value;
                    CLOSE c_hidrics_total;
                END IF;
            
            ELSE
                OPEN c_group_total;
                FETCH c_group_total
                    INTO l_value;
                CLOSE c_group_total;
            END IF;
        ELSIF i_flg_reg_type IS NULL
        THEN
            OPEN c_hidrics_det_max;
            FETCH c_hidrics_det_max
                INTO l_value;
            CLOSE c_hidrics_det_max;
        END IF;
        --
        g_error := 'FETCH TOTAL VALUE';
        IF i_flg_real_value = pk_alert_constant.g_no
        THEN
            l_desc_balance := get_hidrics_value(i_lang, i_prof, l_value, i_hidrics_type);
        ELSE
            l_desc_balance := l_value;
        END IF;
    
        --
        RETURN l_desc_balance;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_TOTAL_BALANCE',
                                              l_error);
            RETURN to_char(l_error.log_id);
    END get_hidrics_total_balance;

    /*******************************************************************************************************************************************
    * get_hidrics_total_times   Get the total nr of occurrences registered in the balance
    * 
    * @param I_LANG              Language ID for translations
    * @param I_PROF              Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS      Episode hidrics ID
    * @param I_HIDRICS_BALANCE   Balance ID
    * @param I_HIDRICS           Hidrics ID
    * @param I_HIDRICS_TYPE      Hidrics type ID
    * @param I_EPIS_HIDR_LINE    Hidrics line ID    
    * @param i_msg               Message to be used to format the value
    * 
    * @return                         Formatted value
    *
    * @author                         Sofia Mendes
    * @version                        2.6.0.3
    * @since                          15-Dec-2010
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_total_times
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_hidrics_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        i_epis_hidr_line  IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_msg             IN sys_message.desc_message%TYPE
    ) RETURN VARCHAR2 IS
        l_error t_error_out;
    
        l_value epis_hidrics_det.value_hidrics%TYPE;
        l_desc  VARCHAR2(200 CHAR);
    
        l_id_epis_hidrics epis_hidrics.id_epis_hidrics%TYPE;
        l_epis_balances   table_number;
    
        CURSOR c_hidrics_det(l_hidrics_balance table_number) IS
            SELECT SUM(ed.nr_times)
              FROM epis_hidrics_det ed
              JOIN epis_hidrics_line ehl
                ON ehl.id_epis_hidrics_line = ed.id_epis_hidrics_line
             WHERE ed.id_epis_hidrics_balance IN (SELECT /*+opt_estimate (table t rows=0.000001)*/
                                                   column_value
                                                    FROM TABLE(l_hidrics_balance) t)
               AND ehl.id_epis_hidrics_line = i_epis_hidr_line
               AND ed.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a;
    
    BEGIN
    
        g_error := 'GET HIDRICS TOTAL TIMES BALANCE';
        IF i_hidrics_balance IS NOT NULL
        THEN
            SELECT ehb.id_epis_hidrics
              INTO l_id_epis_hidrics
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics_balance = i_hidrics_balance;
        
            g_error         := 'CALL GET_PREV_MANUAL_BALANCES';
            l_epis_balances := get_prev_manual_balances(i_lang                  => i_lang,
                                                        i_prof                  => i_prof,
                                                        i_epis_hidrics          => l_id_epis_hidrics,
                                                        i_epis_hidrics_balance  => i_hidrics_balance,
                                                        i_flg_close_type        => NULL,
                                                        i_dt_close_balance_tstz => NULL);
        
            OPEN c_hidrics_det(l_epis_balances);
            FETCH c_hidrics_det
                INTO l_value;
            CLOSE c_hidrics_det;
        END IF;
    
        IF (l_value IS NOT NULL)
        THEN
            l_desc := REPLACE(i_msg, pk_inp_hidrics_constant.g_msg_replace_1, l_value);
        END IF;
        --
        RETURN l_desc;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_TOTAL_TIMES',
                                              l_error);
            RETURN to_char(l_error.log_id);
    END get_hidrics_total_times;

    /*******************************************************************************************************************************************
    * get_hidrics_total_properties  Get the properties for each value of the grid/graph
    * 
    * @param I_LANG              Language ID for translations
    * @param I_PROF              Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS      Episode hidrics ID
    * @param I_FLG_GRID_TYPE     Grid type: G - Graph, F - Flowsheet
    * @param I_FLG_TYPE          Hidrics type: A - administration, E - elimination
    * @param I_DT_REG            Record date
    * @param I_FLG_REG_TYPE      Record type when counting total values: N - regular values, T - balance values
    * @param I_DT_INIT           Date considered to be the start date for the graph
    * @param I_DT_INIT_BAL       Date where the current balance begins
    * @param i_max_intake        Maximum intake
    * @param i_min_output        Minimum output
    * @param i_epis_hidrics_group Epis hidrics group ID
    * @param i_flg_status         A-active; C-cancelled
    * 
    * @return                         Formatted value
    *
    * @author                         José Silva
    * @version                        2.6.0.3
    * @since                          2010/06/07
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_total_properties
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_epis_hidrics       IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_grid_type      IN VARCHAR2,
        i_flg_type           IN hidrics.flg_type%TYPE,
        i_dt_reg             IN epis_hidrics_balance.dt_close_balance_tstz%TYPE,
        i_flg_reg_type       IN VARCHAR2,
        i_dt_init            IN epis_hidrics.dt_initial_tstz%TYPE,
        i_dt_init_bal        IN epis_hidrics_det.dt_first_reg_balance%TYPE,
        i_max_intake         IN epis_hidrics.max_intake%TYPE,
        i_min_output         IN epis_hidrics.min_output%TYPE,
        i_hidrics_type       IN epis_hidrics.id_hidrics_type%TYPE,
        i_epis_hidrics_group IN epis_hidrics_group.id_epis_hidrics_group%TYPE DEFAULT NULL,
        i_flg_status         IN epis_hidrics_group.flg_status%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
    
        l_properties        VARCHAR2(4000);
        l_common_properties VARCHAR2(4000);
        l_real_value        VARCHAR2(200 CHAR);
        l_tooltip_info      VARCHAR2(200 CHAR);
        l_flg_warning       VARCHAR2(24 CHAR);
        l_flg_connected     VARCHAR2(24 CHAR);
    
        l_error t_error_out;
    
        l_flg_type hidrics.flg_type%TYPE;
    
    BEGIN
    
        l_flg_type := i_flg_type;
    
        -- Real value
        l_real_value := get_hidrics_total_balance(i_lang,
                                                  i_prof,
                                                  i_epis_hidrics,
                                                  NULL,
                                                  NULL,
                                                  l_flg_type,
                                                  NULL,
                                                  NULL,
                                                  i_dt_reg,
                                                  i_flg_reg_type,
                                                  pk_alert_constant.g_yes,
                                                  i_epis_hidrics_group,
                                                  i_dt_init_bal);
    
        -- Common properties:
        -- Hidrics type: (A)dministered/(P)roposed
        -- Record type: (N)ormal/(T)otal
        -- Record status: (A)ctive/(C)ancelled                    
        l_common_properties := pk_inp_hidrics_constant.g_epis_hid_det_type_a || pk_inp_hidrics_constant.g_separator ||
                               pk_inp_hidrics_constant.g_separator || pk_inp_hidrics_constant.g_separator ||
                               i_flg_reg_type || pk_inp_hidrics_constant.g_separator ||
                               nvl(i_flg_status, pk_alert_constant.g_active);
    
        IF l_real_value = 0
        THEN
            l_flg_type := NULL;
        END IF;
    
        IF i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_f
        THEN
            -- record date (serialized date)
            -- warning: Y - show value in red color, N - show value with regular style
            l_flg_warning := check_fluid_restrictions(i_lang,
                                                      i_prof,
                                                      i_epis_hidrics,
                                                      i_max_intake,
                                                      i_min_output,
                                                      i_flg_type,
                                                      l_real_value,
                                                      l_real_value,
                                                      i_dt_init_bal,
                                                      i_dt_reg,
                                                      i_flg_reg_type,
                                                      i_hidrics_type);
        
            l_properties := get_hidrics_value(i_lang, i_prof, l_real_value, l_flg_type) ||
                            pk_inp_hidrics_constant.g_separator ||
                            pk_date_utils.date_send_tsz(i_lang, i_dt_reg, i_prof) ||
                            pk_inp_hidrics_constant.g_separator || l_common_properties ||
                            pk_inp_hidrics_constant.g_separator || l_flg_warning;
        
        ELSIF i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_g
        THEN
            -- Extra properties:
            -- record date (in miliseconds)
            -- record real value
            -- tooltip information
            -- l_flg_connected: Y - this value is connected to the previous dot
        
            IF i_flg_type = pk_inp_hidrics_constant.g_hidrics_flg_type_e
            THEN
                l_properties := '|' || get_hidrics_value(i_lang, i_prof, l_real_value, l_flg_type) || ' ' ||
                                get_hidrics_um(i_lang, i_prof, i_epis_hidrics) || '|';
            ELSE
                l_properties := l_real_value || ' ' || get_hidrics_um(i_lang, i_prof, i_epis_hidrics);
            END IF;
        
            IF i_dt_init_bal IS NOT NULL
            THEN
                l_flg_connected := pk_alert_constant.g_yes;
            ELSE
                l_flg_connected := pk_alert_constant.g_no;
            END IF;
        
            l_tooltip_info := l_properties || chr(10) ||
                              pk_date_utils.date_char_tsz(i_lang, i_dt_reg, i_prof.institution, i_prof.software);
        
            l_properties := l_properties || pk_inp_hidrics_constant.g_separator ||
                            round(pk_date_utils.get_timestamp_diff(i_dt_reg, i_dt_init) *
                                  pk_inp_hidrics_constant.g_day_ms) || pk_inp_hidrics_constant.g_separator ||
                            l_common_properties || pk_inp_hidrics_constant.g_separator || l_real_value ||
                            pk_inp_hidrics_constant.g_separator || l_tooltip_info ||
                            pk_inp_hidrics_constant.g_separator || l_flg_connected;
        
        END IF;
    
        --
        RETURN l_properties || pk_inp_hidrics_constant.g_separator || pk_inp_hidrics_constant.g_separator;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_TOTAL_PROPERTIES',
                                              l_error);
            RETURN NULL;
    END get_hidrics_total_properties;

    /*******************************************************************************************************************************************
    * get_epis_hidrics_time_axis      Gets the time axis, both in the grid and in the graph
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_GRID_TYPE          Grid type: G - Graph, F - Flowsheet
    * @param I_FLG_INTERVAL           Interval type (used in the graph): H - Hour, I - interval
    * @param i_dt_begin               Begin date
    * @param i_dt_end                 End date
    * @param i_acronym                Hidrics type acronym
    * @param O_EPIS_HID_TIME          Grid/graph columns
    * @param O_EPIS_HID_HOUR          Graph scale (in hours)
    * @param O_MAX_SCALE              Maximum value used in the graph scale
    * @param O_DT_INIT                Date considered to be the start date for the graph
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/06/04
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_time_axis
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_epis_hidrics  IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_grid_type IN VARCHAR2,
        i_flg_interval  IN VARCHAR2,
        i_dt_begin      IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_dt_end        IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_acronym       IN hidrics_type.acronym%TYPE,
        o_epis_hid_time OUT pk_types.cursor_type,
        o_epis_hid_hour OUT pk_types.cursor_type,
        o_max_scale     OUT NUMBER,
        o_dt_init       OUT epis_hidrics.dt_initial_tstz%TYPE,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_desc_days      table_varchar;
        l_length_day     table_number;
        l_length_ms_day  table_number;
        l_ms_days        table_number;
        l_desc_hours     table_varchar;
        l_ms_hours       table_number;
        l_length_hour    table_number;
        l_length_ms_hour table_number;
    
        l_dt_close_balance epis_hidrics_balance.dt_close_balance_tstz%TYPE;
        l_dt_curr_balance  epis_hidrics_balance.dt_close_balance_tstz%TYPE;
    
        l_dt_init           epis_hidrics.dt_initial_tstz%TYPE;
        l_dt_end            epis_hidrics_det.dt_execution_tstz%TYPE;
        l_prev_day          epis_hidrics.dt_initial_tstz%TYPE;
        l_prev_interval_day epis_hidrics.dt_initial_tstz%TYPE;
        l_curr_day          epis_hidrics.dt_initial_tstz%TYPE;
        l_end_day           epis_hidrics_det.dt_execution_tstz%TYPE;
    
        l_years   NUMBER;
        l_months  NUMBER;
        l_days    NUMBER;
        l_hours   NUMBER;
        l_minutes NUMBER;
        l_seconds NUMBER;
    
        l_desc_total sys_message.desc_message%TYPE;
    
        l_count         NUMBER := 1;
        l_count2        NUMBER := 1;
        l_num_intervals NUMBER;
        l_interval      NUMBER;
        l_curr_interval NUMBER;
    
        l_dt_first_balance   epis_hidrics.dt_next_balance%TYPE;
        l_dt_next_balance    epis_hidrics.dt_next_balance%TYPE;
        l_dt_trunc_balance   epis_hidrics.dt_next_balance%TYPE;
        l_dt_trunc_balance_h epis_hidrics.dt_next_balance%TYPE;
        l_dt_trunc_balance_m epis_hidrics.dt_next_balance%TYPE;
    
        l_min_length  NUMBER;
        l_curr_length NUMBER;
        l_gap_max_value CONSTANT NUMBER := 1.5;
    
        l_fill_values BOOLEAN := FALSE;
    
        l_import_iv_fluids sys_config.id_sys_config%TYPE;
    
    BEGIN
    
        g_error := 'GET import_iv_fluids sys_config';
        pk_alertlog.log_debug(g_error);
        l_import_iv_fluids := pk_sysconfig.get_config(i_code_cf => pk_inp_hidrics_constant.g_import_iv_fluids,
                                                      i_prof    => i_prof);
    
        IF i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_f -- flowsheet
        THEN
        
            l_desc_total := pk_message.get_message(i_lang, 'HIDRICS_T076');
        
            g_error := 'GET CURSOR O_EPIS_HID_TIME';
            OPEN o_epis_hid_time FOR
                SELECT pk_date_utils.date_send_tsz(i_lang, a.dt_reg, i_prof) time_var,
                       pk_date_utils.date_daymonth_tsz(i_lang, a.dt_reg, i_prof.institution, i_prof.software) dt_day_month,
                       pk_date_utils.date_char_hour_tsz(i_lang, a.dt_reg, i_prof.institution, i_prof.software) hour_read,
                       pk_date_utils.date_year_tsz(i_lang, a.dt_reg, i_prof.institution, i_prof.software) dt_year_read,
                       a.flg_total,
                       a.label_total
                  FROM (SELECT DISTINCT ehd.dt_execution_tstz dt_reg,
                                        pk_inp_hidrics_constant.g_element_normal flg_total,
                                        '' label_total
                          FROM epis_hidrics_det ehd
                         WHERE ehd.id_epis_hidrics = i_epis_hidrics
                           AND (ehd.dt_execution_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                           AND (ehd.dt_execution_tstz < i_dt_end OR i_dt_end IS NULL)
                        UNION ALL
                        SELECT DISTINCT eb.dt_close_balance_tstz dt_reg,
                                        CASE
                                            WHEN eb.flg_close_type = pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut THEN
                                             pk_inp_hidrics_constant.g_element_total
                                            ELSE
                                             pk_inp_hidrics_constant.g_element_tot_manual
                                        END flg_total,
                                        CASE
                                            WHEN eb.flg_close_type = pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut THEN
                                             l_desc_total
                                            ELSE
                                             ''
                                        END label_total
                          FROM epis_hidrics_balance eb
                         WHERE eb.id_epis_hidrics = i_epis_hidrics
                           AND eb.dt_close_balance_tstz IS NOT NULL
                           AND (eb.dt_close_balance_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                           AND (eb.dt_close_balance_tstz <= i_dt_end OR i_dt_end IS NULL)
                        UNION
                        SELECT /*+opt_estimate(table,t_med,scale_rows=0.0001)*/
                         t_med.column_value dt_reg, pk_inp_hidrics_constant.g_element_normal flg_total, '' label_total
                          FROM TABLE(pk_api_pfh_clindoc_in.get_fluid_balance_med_dates(i_lang, i_prof, i_epis_hidrics)) t_med
                         WHERE l_import_iv_fluids = pk_alert_constant.g_yes
                           AND (t_med.column_value >= i_dt_begin OR i_dt_begin IS NULL)
                           AND (t_med.column_value <= i_dt_end OR i_dt_end IS NULL)
                              --only the Intake and Outupt and the intakes include the IV fluids
                           AND i_acronym IN (pk_inp_hidrics_constant.g_hid_type_h, pk_inp_hidrics_constant.g_hid_type_i)) a
                 ORDER BY a.dt_reg;
        
            pk_types.open_my_cursor(o_epis_hid_hour);
        
        ELSIF i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_g -- graph
        THEN
        
            l_desc_days      := table_varchar();
            l_length_day     := table_number();
            l_length_ms_day  := table_number();
            l_ms_days        := table_number();
            l_desc_hours     := table_varchar();
            l_ms_hours       := table_number();
            l_length_hour    := table_number();
            l_length_ms_hour := table_number();
        
            g_error := 'GET DT_INITIAL';
            SELECT pk_date_utils.trunc_insttimezone(i_prof.institution, i_prof.software, e.dt_initial_tstz, 'HH'),
                   (SELECT get_epis_hidrics_interval(i_lang,
                                                     i_prof,
                                                     nvl(e.interval_minutes, hi.interval_minutes),
                                                     i_flg_interval)
                      FROM dual),
                   e.dt_next_balance
              INTO l_dt_init, l_interval, l_dt_next_balance
              FROM epis_hidrics e
              JOIN hidrics_interval hi
                ON hi.id_hidrics_interval = e.id_hidrics_interval
             WHERE e.id_epis_hidrics = i_epis_hidrics;
        
            IF l_interval IS NULL
            THEN
                l_interval := 1;
            END IF;
        
            g_error := 'GET DT_END';
            SELECT pk_date_utils.add_to_ltstz(pk_date_utils.trunc_insttimezone(i_prof.institution,
                                                                               i_prof.software,
                                                                               nvl(dt_end, l_dt_init),
                                                                               'HH'),
                                              1,
                                              'HOUR')
              INTO l_dt_end
              FROM (SELECT MAX(ed.dt_execution_tstz) dt_end
                      FROM epis_hidrics_det ed
                     WHERE ed.id_epis_hidrics = i_epis_hidrics
                       AND ed.flg_status = pk_alert_constant.g_active);
        
            g_error   := 'LOOP DAYS';
            l_end_day := pk_date_utils.trunc_insttimezone(i_prof.institution, i_prof.software, l_dt_end);
        
            IF i_flg_interval = pk_inp_hidrics_constant.g_graph_hour -- hour
            THEN
                l_min_length  := 24;
                l_curr_length := 0;
            
                g_error     := 'CALL TO GET_HIDRICS_TOTAL_BALANCE';
                o_max_scale := nvl(((get_hidrics_total_balance(i_lang,
                                                               i_prof,
                                                               i_epis_hidrics,
                                                               NULL,
                                                               NULL,
                                                               NULL,
                                                               NULL,
                                                               NULL,
                                                               NULL,
                                                               NULL,
                                                               pk_alert_constant.g_yes,
                                                               NULL,
                                                               NULL)) * l_gap_max_value),
                                   1);
            
                g_error := 'GET DT_INIT';
                SELECT nvl(pk_date_utils.trunc_insttimezone(i_prof.institution,
                                                            i_prof.software,
                                                            MIN(ed.dt_execution_tstz),
                                                            'HH'),
                           l_dt_init)
                  INTO l_dt_init
                  FROM epis_hidrics_det ed
                 WHERE ed.id_epis_hidrics = i_epis_hidrics
                   AND ed.flg_status = pk_alert_constant.g_active;
            
                l_curr_day := pk_date_utils.trunc_insttimezone(i_prof.institution, i_prof.software, l_dt_init);
            
                LOOP
                
                    l_desc_days.extend;
                    l_desc_days(l_count) := pk_date_utils.date_chr_short_read_tsz(i_lang,
                                                                                  l_curr_day,
                                                                                  i_prof.institution,
                                                                                  i_prof.software);
                
                    l_ms_days.extend;
                    l_ms_days(l_count) := pk_date_utils.get_timestamp_diff(greatest(l_curr_day, l_dt_init), l_dt_init) *
                                          pk_inp_hidrics_constant.g_day_ms;
                
                    g_error := 'SET INTERVAL NUMBER';
                    IF l_curr_day < l_dt_init
                    THEN
                    
                        l_num_intervals := 24 - (pk_date_utils.get_timestamp_diff(l_dt_init, l_curr_day) * 24);
                        l_curr_day      := l_dt_init;
                    
                    ELSIF l_curr_day = l_end_day
                    THEN
                        l_num_intervals := pk_date_utils.get_timestamp_diff(l_dt_end, l_curr_day) * 24;
                    
                        IF l_curr_length + l_num_intervals < l_min_length
                        THEN
                            l_num_intervals := l_min_length - l_curr_length;
                        END IF;
                    
                    ELSIF l_fill_values = TRUE
                    THEN
                        l_num_intervals := l_min_length - l_curr_length;
                    ELSE
                        l_num_intervals := 24;
                    END IF;
                
                    g_error := 'SET LENGTH DAY';
                    l_length_day.extend;
                    l_length_day(l_count) := l_num_intervals;
                
                    l_length_ms_day.extend;
                    l_length_ms_day(l_count) := l_length_day(l_count) * pk_inp_hidrics_constant.g_hour_ms;
                
                    FOR i IN l_desc_hours.count + 1 .. l_desc_hours.count + l_num_intervals
                    LOOP
                        g_error := 'LOOP HOUR ' || i;
                    
                        l_desc_hours.extend;
                        l_ms_hours.extend;
                        l_length_hour.extend;
                        l_length_ms_hour.extend;
                    
                        IF NOT pk_date_utils.extract_from_tstz(i_lang      => i_lang,
                                                               i_prof      => i_prof,
                                                               i_timestamp => l_curr_day,
                                                               o_years     => l_years,
                                                               o_months    => l_months,
                                                               o_days      => l_days,
                                                               o_hours     => l_hours,
                                                               o_minutes   => l_minutes,
                                                               o_seconds   => l_seconds,
                                                               o_error     => o_error)
                        THEN
                            NULL;
                        END IF;
                        l_desc_hours(i) := lpad(l_hours, 2, '0');
                        l_ms_hours(i) := pk_date_utils.get_timestamp_diff(l_curr_day, l_dt_init) *
                                         pk_inp_hidrics_constant.g_day_ms;
                        l_length_hour(i) := l_interval;
                        l_length_ms_hour(i) := l_length_hour(i) * pk_inp_hidrics_constant.g_hour_ms;
                        l_curr_length := l_curr_length + l_interval;
                    
                        l_curr_day := pk_date_utils.add_to_ltstz(l_curr_day, l_interval, 'HOUR');
                    
                    END LOOP;
                
                    g_error := 'END LOOP DAY ' || l_count;
                    l_count := l_count + 1;
                    IF l_min_length > l_curr_length
                       AND l_curr_day >= l_dt_end
                    THEN
                        l_fill_values := TRUE;
                    END IF;
                
                    EXIT WHEN l_curr_day >= l_dt_end AND l_curr_length >= l_min_length;
                
                END LOOP;
            ELSIF i_flg_interval = pk_inp_hidrics_constant.g_graph_interval -- interval
            THEN
            
                l_min_length  := 7;
                l_curr_length := 0;
            
                g_error := 'GET SCALE MAX VALUE';
                SELECT nvl(greatest(MAX(get_total_admin(i_lang,
                                                        i_prof,
                                                        i_epis_hidrics,
                                                        total_admin,
                                                        eb.dt_open_tstz,
                                                        eb.dt_close_balance_tstz)),
                                    nvl(MAX(total_elim), 0)),
                           1) * l_gap_max_value
                  INTO o_max_scale
                  FROM epis_hidrics_balance eb
                 WHERE eb.id_epis_hidrics = i_epis_hidrics
                   AND eb.dt_close_balance_tstz IS NOT NULL;
            
                g_error := 'GET DATE BALANCE';
                SELECT MAX(e.dt_close_balance_tstz), MIN(e.dt_close_balance_tstz)
                  INTO l_dt_close_balance, l_dt_first_balance
                  FROM epis_hidrics_balance e
                 WHERE e.id_epis_hidrics = i_epis_hidrics
                   AND e.dt_close_balance_tstz IS NOT NULL;
            
                g_error := 'SET FIRST BALANCE';
                IF l_dt_first_balance < l_dt_next_balance
                THEN
                    l_dt_next_balance := l_dt_first_balance;
                END IF;
            
                l_dt_curr_balance := nvl(l_dt_next_balance, pk_date_utils.add_to_ltstz(l_dt_init, l_interval, 'HOUR'));
                l_dt_init         := pk_date_utils.add_to_ltstz(l_dt_curr_balance, -l_interval, 'HOUR');
                l_dt_curr_balance := l_dt_init;
            
                l_prev_day          := pk_date_utils.add_to_ltstz(l_dt_init, -l_interval, 'HOUR');
                l_prev_interval_day := l_dt_init;
                l_curr_day          := pk_date_utils.trunc_insttimezone(i_prof.institution, i_prof.software, l_prev_day);
            
                l_dt_end := greatest(nvl(l_dt_close_balance, l_dt_end), nvl(l_dt_end, l_dt_close_balance));
            
                g_error := 'START LOOP';
                LOOP
                
                    EXIT WHEN l_dt_curr_balance > l_dt_end AND l_curr_length >= l_min_length;
                
                    l_dt_trunc_balance   := pk_date_utils.trunc_insttimezone(i_prof.institution,
                                                                             i_prof.software,
                                                                             l_dt_curr_balance);
                    l_dt_trunc_balance_h := pk_date_utils.trunc_insttimezone(i_prof.institution,
                                                                             i_prof.software,
                                                                             l_dt_curr_balance,
                                                                             'HH');
                    l_dt_trunc_balance_m := pk_date_utils.trunc_insttimezone(i_prof.institution,
                                                                             i_prof.software,
                                                                             l_dt_curr_balance,
                                                                             'MI');
                
                    l_curr_interval := pk_date_utils.get_timestamp_diff(l_dt_curr_balance, l_prev_day) * 24;
                
                    g_error := 'SET HOUR ' || l_count2;
                    l_desc_hours.extend;
                    l_ms_hours.extend;
                    l_length_hour.extend;
                    l_length_ms_hour.extend;
                
                    IF NOT pk_date_utils.extract_from_tstz(i_lang      => i_lang,
                                                           i_prof      => i_prof,
                                                           i_timestamp => l_dt_curr_balance,
                                                           o_years     => l_years,
                                                           o_months    => l_months,
                                                           o_days      => l_days,
                                                           o_hours     => l_hours,
                                                           o_minutes   => l_minutes,
                                                           o_seconds   => l_seconds,
                                                           o_error     => o_error)
                    THEN
                        NULL;
                    END IF;
                    l_desc_hours(l_count2) := lpad(l_hours, 2, '0');
                
                    l_ms_hours(l_count2) := pk_date_utils.get_timestamp_diff(l_dt_curr_balance, l_dt_init) *
                                            pk_inp_hidrics_constant.g_day_ms;
                    l_length_hour(l_count2) := l_curr_interval / l_interval;
                    l_length_ms_hour(l_count2) := l_curr_interval * pk_inp_hidrics_constant.g_hour_ms;
                
                    l_curr_length := l_curr_length + l_length_hour(l_count2);
                
                    IF l_curr_day <= l_dt_trunc_balance
                    THEN
                    
                        LOOP
                        
                            g_error := 'LOOP DAY ' || l_count;
                            l_desc_days.extend;
                            l_desc_days(l_count) := pk_date_utils.date_chr_short_read_tsz(i_lang,
                                                                                          l_curr_day,
                                                                                          i_prof.institution,
                                                                                          i_prof.software);
                        
                            l_ms_days.extend;
                            l_ms_days(l_count) := pk_date_utils.get_timestamp_diff(greatest(l_curr_day, l_dt_init),
                                                                                   l_dt_init) *
                                                  pk_inp_hidrics_constant.g_day_ms;
                        
                            l_curr_day := pk_date_utils.add_to_ltstz(l_curr_day, 1);
                        
                            l_length_day.extend;
                            l_length_day(l_count) := pk_date_utils.get_timestamp_diff(l_curr_day, l_prev_interval_day) * 24;
                        
                            l_prev_interval_day := l_curr_day;
                        
                            l_length_ms_day.extend;
                            l_length_ms_day(l_count) := l_length_day(l_count) * pk_inp_hidrics_constant.g_hour_ms;
                            l_length_day(l_count) := l_length_day(l_count) / l_interval;
                        
                            l_count := l_count + 1;
                            EXIT WHEN l_dt_trunc_balance < l_curr_day;
                        
                        END LOOP;
                    END IF;
                
                    g_error           := 'END LOOP HOUR ' || l_count2;
                    l_prev_day        := l_dt_curr_balance;
                    l_dt_curr_balance := pk_date_utils.add_to_ltstz(l_prev_day, l_interval, 'HOUR');
                    l_count2          := l_count2 + 1;
                
                END LOOP;
            
                g_error            := 'FILL LAST DAY';
                l_dt_trunc_balance := pk_date_utils.trunc_insttimezone(i_prof.institution,
                                                                       i_prof.software,
                                                                       l_dt_curr_balance);
            
                l_prev_day := pk_date_utils.trunc_insttimezone(i_prof.institution, i_prof.software, l_prev_day);
            
                IF l_dt_trunc_balance >= l_prev_interval_day
                THEN
                    g_error := 'LOOP DAY ' || l_count;
                    l_desc_days.extend;
                    l_desc_days(l_count) := pk_date_utils.date_chr_short_read_tsz(i_lang,
                                                                                  l_dt_trunc_balance,
                                                                                  i_prof.institution,
                                                                                  i_prof.software);
                
                    l_ms_days.extend;
                    l_ms_days(l_count) := pk_date_utils.get_timestamp_diff(greatest(l_dt_trunc_balance, l_dt_init),
                                                                           l_dt_init) *
                                          pk_inp_hidrics_constant.g_day_ms;
                
                    l_length_day.extend;
                    l_length_day(l_count) := pk_date_utils.get_timestamp_diff(l_dt_trunc_balance, l_prev_day) * 24;
                
                    l_length_ms_day.extend;
                    l_length_ms_day(l_count) := l_length_day(l_count) * pk_inp_hidrics_constant.g_hour_ms;
                    l_length_day(l_count) := l_length_day(l_count) / l_interval;
                END IF;
            
            END IF;
        
            g_error := 'GET CURSOR O_EPIS_HID_TIME';
            OPEN o_epis_hid_time FOR
                SELECT a.column_value desc_day,
                       b.column_value length_day,
                       d.column_value length_ms_day,
                       c.column_value ms_day
                  FROM (SELECT column_value, rownum num
                          FROM TABLE(l_desc_days)) a,
                       (SELECT column_value, rownum num
                          FROM TABLE(l_length_day)) b,
                       (SELECT column_value, rownum num
                          FROM TABLE(l_ms_days)) c,
                       (SELECT column_value, rownum num
                          FROM TABLE(l_length_ms_day)) d
                 WHERE a.num = b.num
                   AND b.num = c.num
                   AND c.num = d.num
                 ORDER BY a.num;
        
            g_error := 'GET CURSOR O_EPIS_HID_TIME';
            OPEN o_epis_hid_hour FOR
                SELECT a.column_value desc_hour,
                       b.column_value ms_hour,
                       d.column_value length_ms_hour,
                       c.column_value length_hour
                  FROM (SELECT column_value, rownum num
                          FROM TABLE(l_desc_hours)) a,
                       (SELECT column_value, rownum num
                          FROM TABLE(l_ms_hours)) b,
                       (SELECT column_value, rownum num
                          FROM TABLE(l_length_hour)) c,
                       (SELECT column_value, rownum num
                          FROM TABLE(l_length_ms_hour)) d
                 WHERE a.num = b.num
                   AND b.num = c.num
                   AND c.num = d.num
                 ORDER BY a.num;
        
            o_dt_init := l_dt_init;
        
        END IF;
    
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_TIME_AXIS',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid_time);
            pk_types.open_my_cursor(o_epis_hid_hour);
            RETURN FALSE;
    END get_epis_hidrics_time_axis;

    /*******************************************************************************************************************************************
    * get_hidrics_graph_views         Get the hidrics views to be used in the graph
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param O_HIDRICS_VIEWS          Grid columns (one per date)
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/06/21
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_graph_views
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_epis_hidrics  IN epis_hidrics.id_epis_hidrics%TYPE,
        o_hidrics_views OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_GRID';
    
        l_domain_graph CONSTANT sys_domain.code_domain%TYPE := 'HIDRICS_GRAPH_VIEWS';
        l_interval epis_hidrics.interval_minutes%TYPE;
    
        l_num_interval_h CONSTANT NUMBER := 20;
        l_num_interval_i CONSTANT NUMBER := 7;
    
        l_length_day CONSTANT NUMBER := 24;
    
    BEGIN
    
        g_error := 'GET EPIS_HIDRICS INTERVAL';
        SELECT nvl(eh.interval_minutes, hi.interval_minutes)
          INTO l_interval
          FROM epis_hidrics eh
          JOIN hidrics_interval hi
            ON hi.id_hidrics_interval = eh.id_hidrics_interval
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        g_error := 'OPEN O_HIDRICS_VIEWS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_hidrics_views FOR
            SELECT decode(t.val, pk_inp_hidrics_constant.g_graph_hour, t.length_interval * l_length_day, NULL) length_major_interval,
                   t.*
              FROM (SELECT get_epis_hidrics_interval(i_lang, i_prof, l_interval, sys_d.val) *
                           pk_inp_hidrics_constant.g_hour_ms length_interval,
                           decode(sys_d.val,
                                  pk_inp_hidrics_constant.g_graph_hour,
                                  pk_alert_constant.g_yes,
                                  pk_alert_constant.g_no) flg_default,
                           decode(sys_d.val, pk_inp_hidrics_constant.g_graph_hour, l_num_interval_h, l_num_interval_i) num_intervals,
                           sys_d.*
                      FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang, i_prof, l_domain_graph, NULL)) sys_d) t;
    
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_hidrics_views);
            RETURN FALSE;
    END get_hidrics_graph_views;

    /*******************************************************************************************************************************************
    * get_epis_hidrics_grid_int          Get all hidric records associated episode hidrics ID (flowsheet or graph)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_GRID_TYPE          Grid type: G - Graph, F - Flowsheet
    * @param I_FLG_INTERVAL           Interval type (used in the graph): H - Hour, I - interval
    * @param I_FLG_CONTEXT            Context in which the grid was loaded (null if the grid was loaded through the deepnav):
                                           R - New intake/output record. 
                                           B - End of balance
    * @param i_dt_begin               Begin date
    * @param i_dt_end                 End date
    * @param O_EPIS_HID_TIME          Grid columns (one per date)
    * @param O_EPIS_HID_PAR           Lines or series of values (one per hidrics)
    * @param O_EPIS_HID_HOUR          Graph scale (in hours)
    * @param O_MAX_SCALE              Graph maximum and minimum values
    * @param O_LABEL_REF              Label to be placed
    * @param O_MSG_TEXT               Warning pop-up text (if applicable)
    * @param O_MSG_TITLE              Warning pop-up title (if applicable)
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         José Silva
    * @version                        2.6.0.3
    * @since                          2010/05/27
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_grid_int
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_epis_hidrics         IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_grid_type        IN VARCHAR2,
        i_flg_interval         IN VARCHAR2 DEFAULT NULL,
        i_flg_context          IN VARCHAR2 DEFAULT NULL,
        i_dt_begin             IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_dt_end               IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_epis_hidrics_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_epis_hid_time        OUT pk_types.cursor_type,
        o_epis_hid_par         OUT pk_types.cursor_type,
        o_epis_hid_hour        OUT pk_types.cursor_type,
        o_max_scale            OUT NUMBER,
        o_label_ref            OUT VARCHAR2,
        o_msg_text             OUT VARCHAR2,
        o_msg_title            OUT VARCHAR2,
        o_hidrics_type         OUT hidrics_type.id_hidrics_type%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_GRID';
    
        l_hidr_unit_measure pk_translation.t_desc_translation;
        l_code_message CONSTANT sys_message.code_message%TYPE := 'HIDRICS_TOTAL_TYPE';
        l_config_color CONSTANT sys_config.id_sys_config%TYPE := 'HIDRICS_GRAPH_COLOR';
        l_msg_max_intake        sys_message.desc_message%TYPE;
        l_msg_min_output        sys_message.desc_message%TYPE;
        l_max_intake            epis_hidrics.max_intake%TYPE;
        l_min_output            epis_hidrics.min_output%TYPE;
        l_desc_proposed         sys_domain.desc_val%TYPE;
        l_desc_canceled         sys_message.desc_message%TYPE;
        l_desc_nr_times         sys_message.desc_message%TYPE;
        l_desc_total_irrigation sys_message.desc_message%TYPE;
    
        l_dt_init          epis_hidrics.dt_initial_tstz%TYPE;
        l_flg_ready_only   VARCHAR2(1 CHAR);
        l_check_extra_take VARCHAR2(1 CHAR);
        l_eh_flg_status    epis_hidrics.flg_status%TYPE;
    
        l_common_error EXCEPTION;
        l_import_iv_fluids sys_config.id_sys_config%TYPE;
    
        l_acronym     hidrics_type.acronym%TYPE;
        l_colors      sys_config.value%TYPE;
        l_list_colors table_varchar := table_varchar();
    BEGIN
        g_error := 'GET import_iv_fluids sys_config';
        pk_alertlog.log_debug(g_error);
        l_import_iv_fluids := pk_sysconfig.get_config(i_code_cf => pk_inp_hidrics_constant.g_import_iv_fluids,
                                                      i_prof    => i_prof);
    
        g_graph_max_scale := 0;
    
        l_hidr_unit_measure     := get_hidrics_um(i_lang, i_prof, i_epis_hidrics);
        l_desc_proposed         := lower(pk_sysdomain.get_domain('EPIS_HIDRICS_DET.FLG_TYPE',
                                                                 pk_inp_hidrics_constant.g_epis_hid_det_type_p,
                                                                 i_lang));
        l_desc_canceled         := pk_message.get_message(i_lang, 'COMMON_M028');
        l_msg_max_intake        := pk_message.get_message(i_lang, 'HIDRICS_M024');
        l_msg_min_output        := pk_message.get_message(i_lang, 'HIDRICS_M025');
        l_desc_nr_times         := pk_message.get_message(i_lang, 'HIDRICS_M062');
        l_desc_total_irrigation := pk_message.get_message(i_lang, 'HIDRICS_T138');
    
        g_error := 'GET LABEL REF';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        o_label_ref := '0 ' || l_hidr_unit_measure;
    
        g_error := 'GET MAX AND MIN VALUES';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT e.max_intake,
               e.min_output,
               e.id_hidrics_type,
               (CASE
                    WHEN e.flg_status IN
                         (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e) THEN
                     pk_alert_constant.g_no
                    WHEN e.flg_status = pk_inp_hidrics_constant.g_epis_hidric_o
                         AND check_extra_take(i_lang, i_prof, i_episode, i_epis_hidrics) = pk_alert_constant.g_yes THEN
                     pk_alert_constant.g_no
                    ELSE
                     pk_alert_constant.g_yes
                END),
               e.flg_status
          INTO l_max_intake, l_min_output, o_hidrics_type, l_flg_ready_only, l_eh_flg_status
          FROM epis_hidrics e
         WHERE e.id_epis_hidrics = i_epis_hidrics;
    
        g_error := 'CALL get_hidric_type_acronym. hidrics_type: ' || o_hidrics_type;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_acronym := get_hidric_type_acronym(i_lang => i_lang, i_prof => i_prof, i_hidrics_type => o_hidrics_type);
    
        --if expired, check extra take
        IF l_eh_flg_status = pk_inp_hidrics_constant.g_epis_hidric_o
        THEN
            l_check_extra_take := check_extra_take(i_lang         => i_lang,
                                                   i_prof         => i_prof,
                                                   i_episode      => i_episode,
                                                   i_task_request => i_epis_hidrics);
            IF l_check_extra_take = pk_alert_constant.g_yes
            THEN
                l_flg_ready_only := pk_alert_constant.g_no;
            END IF;
        END IF;
    
        g_error := 'CHECK RESTRICTION ALERTS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF i_flg_context IS NOT NULL
        THEN
            IF NOT check_restriction_alerts(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_episode      => i_episode,
                                            i_epis_hidrics => i_epis_hidrics,
                                            i_epis_balance => NULL,
                                            i_max_intake   => l_max_intake,
                                            i_min_output   => l_min_output,
                                            i_hidrics_type => o_hidrics_type,
                                            i_flg_context  => i_flg_context,
                                            i_dt_execution => NULL,
                                            o_msg_title    => o_msg_title,
                                            o_msg_text     => o_msg_text,
                                            o_error        => o_error)
            THEN
                RAISE l_common_error;
            END IF;
        END IF;
    
        g_error := 'GET CURSOR O_EPIS_HID_TIME';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT get_epis_hidrics_time_axis(i_lang          => i_lang,
                                          i_prof          => i_prof,
                                          i_epis_hidrics  => i_epis_hidrics,
                                          i_flg_grid_type => i_flg_grid_type,
                                          i_flg_interval  => i_flg_interval,
                                          i_dt_begin      => i_dt_begin,
                                          i_dt_end        => i_dt_end,
                                          i_acronym       => l_acronym,
                                          o_epis_hid_time => o_epis_hid_time,
                                          o_epis_hid_hour => o_epis_hid_hour,
                                          o_max_scale     => o_max_scale,
                                          o_dt_init       => l_dt_init,
                                          o_error         => o_error)
        THEN
            RAISE l_common_error;
        END IF;
    
        --GET irrigation colors
        IF (i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_g)
        THEN
            l_colors      := pk_sysconfig.get_config(l_config_color || '_' ||
                                                     pk_inp_hidrics_constant.g_hidrics_irrigations_g,
                                                     i_prof);
            l_list_colors := pk_string_utils.str_split(i_list => l_colors, i_delim => '|');
        
        END IF;
    
        g_error := 'GET CURSOR O_EPIS_HID_PAR';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_epis_hid_par FOR
            SELECT id_hidrics,
                   id_epis_hidrics_line,
                   desc_hidrics,
                   flg_type,
                   pk_inp_hidrics_constant.g_element_normal flg_total,
                   decode(flg_status,
                          pk_inp_hidrics_constant.g_epis_hid_lin_status_c,
                          pk_alert_constant.g_no,
                          pk_alert_constant.g_yes) flg_edit,
                   CASE
                    --the irrigation groups should appear first
                        WHEN id_epis_hidrics_group IS NOT NULL THEN
                         (id_epis_hidrics_group * -1)
                        ELSE
                         (SELECT pk_sysdomain.get_rank(i_lang, 'HIDRICS.FLG_TYPE', flg_type)
                            FROM dual)
                    END rank,
                   CASE
                    --in the irrigation groups the intake should appear first
                        WHEN id_epis_hidrics_group IS NOT NULL
                             AND flg_type = pk_inp_hidrics_constant.g_hidrics_flg_type_a THEN
                         (rank * -1) - 1
                        ELSE
                         rank
                    END rank_hidrics,
                   id_way id_hidrics_way,
                   desc_way,
                   id_hidrics_location,
                   id_body_part,
                   id_body_side,
                   (SELECT pk_inp_hidrics.get_table_val(loc_descs, 1)
                      FROM dual) desc_location,
                   (SELECT pk_inp_hidrics.get_table_val(loc_descs, 2)
                      FROM dual) desc_body_part,
                   (SELECT pk_inp_hidrics.get_table_val(loc_descs, 3)
                      FROM dual) desc_body_side,
                   NULL graph_color,
                   flg_status,
                   decode(flg_type,
                          pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_future,
                   (SELECT get_epis_hidrics_grid_value(i_lang                 => i_lang,
                                                       i_prof                 => i_prof,
                                                       i_epis_hidrics         => i_epis_hidrics,
                                                       i_epis_hidrics_line    => hidr_rec.id_epis_hidrics_line,
                                                       i_hidrics              => hidr_rec.id_hidrics,
                                                       i_flg_type             => hidr_rec.flg_type,
                                                       i_hidr_unit_measure    => l_hidr_unit_measure,
                                                       i_desc_canceled        => l_desc_canceled,
                                                       i_desc_nr_times        => l_desc_nr_times,
                                                       i_desc_proposed        => l_desc_proposed,
                                                       i_dt_begin             => i_dt_begin,
                                                       i_dt_end               => i_dt_end,
                                                       i_epis_hidrics_balance => i_epis_hidrics_balance)
                      FROM dual) values_hidrics,
                   pk_alert_constant.g_yes flg_detail,
                   NULL flg_ready_only,
                   hidr_rec.flg_nr_times,
                   CASE
                        WHEN id_body_part IS NULL
                             AND id_body_side IS NULL
                             AND pk_inp_hidrics.get_table_val(loc_descs, 1) IS NOT NULL THEN
                         pk_alert_constant.g_yes
                        ELSE
                         pk_alert_constant.g_no
                    END flg_body_part_free_text,
                   CASE
                        WHEN id_epis_hidrics_group IS NOT NULL THEN
                         pk_alert_constant.g_yes
                        ELSE
                         pk_alert_constant.g_no
                    END flg_irrigation
              FROM (SELECT ehl.id_epis_hidrics_line,
                           ehl.flg_status,
                           h.id_hidrics,
                           h.flg_type,
                           h.rank,
                           (SELECT pk_inp_hidrics.get_hidrics_desc(i_lang, i_prof, ehl.id_epis_hidrics_line)
                              FROM dual) desc_hidrics,
                           ehl.id_way,
                           (SELECT pk_inp_hidrics.get_hidrics_way(i_lang, i_prof, ehl.id_epis_hidrics_line)
                              FROM dual) desc_way,
                           ehl.id_hidrics_location,
                           hl.id_body_part,
                           hl.id_body_side,
                           (SELECT pk_inp_hidrics.get_hidrics_location_grid(i_lang, i_prof, ehl.id_epis_hidrics_line)
                              FROM dual) loc_descs,
                           h.flg_nr_times,
                           ehlg.id_epis_hidrics_group
                      FROM epis_hidrics_line ehl
                     INNER JOIN hidrics h
                        ON (h.id_hidrics = ehl.id_hidrics)
                      LEFT JOIN hidrics_location hl
                        ON hl.id_hidrics_location = ehl.id_hidrics_location
                      LEFT JOIN epis_hd_line_group ehlg
                        ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line
                     WHERE ehl.id_epis_hidrics = i_epis_hidrics
                       AND i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_f) hidr_rec
            
            UNION ALL
            -- IV fluids
            SELECT /*+opt_estimate(table,a,scale_rows=0.000000001)*/
             (a.id_fluid * -1) - 2 id_hidrics,
             (a.id_fluid * -1) - 2 id_epis_hidrics_line,
             a.desc_fluid desc_hidrics,
             pk_inp_hidrics_constant.g_hidrics_flg_type_a flg_type,
             pk_inp_hidrics_constant.g_element_presc flg_total,
             pk_alert_constant.g_no flg_edit,
             (SELECT pk_sysdomain.get_rank(i_lang, 'HIDRICS.FLG_TYPE', pk_inp_hidrics_constant.g_hidrics_flg_type_a)
                FROM dual) rank,
             0 rank_hidrics,
             -1 id_hidrics_way,
             a.route desc_way,
             NULL id_hidrics_location,
             NULL id_body_part,
             NULL id_body_side,
             '' desc_location,
             NULL desc_body_part,
             NULL desc_body_side,
             NULL graph_color,
             pk_inp_hidrics_constant.g_epis_hid_lin_status_a flg_status,
             pk_alert_constant.g_no flg_future,
             a.takes_string values_hidrics,
             pk_alert_constant.g_no flg_detail,
             NULL flg_ready_only,
             NULL flg_nr_times,
             pk_alert_constant.g_no flg_body_part_free_text,
             pk_alert_constant.g_no flg_irrigation
              FROM TABLE(pk_inp_hidrics.get_fluid_balance_med(i_lang, i_prof, i_epis_hidrics)) a
             WHERE i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_f
                  --only the Intake and Outupt and the intakes include the IV fluids
               AND l_acronym IN (pk_inp_hidrics_constant.g_hid_type_h, pk_inp_hidrics_constant.g_hid_type_i)
            UNION ALL
            -- total intake/output
            SELECT -1 id_hidrics,
                   -1 id_epis_hidrics_line,
                   decode(t_total.flg_type,
                          pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                          (SELECT pk_inp_hidrics.get_intake_output_text(i_lang,
                                                                        i_prof,
                                                                        l_msg_max_intake,
                                                                        l_max_intake,
                                                                        l_hidr_unit_measure)
                             FROM dual),
                          pk_inp_hidrics_constant.g_hidrics_flg_type_e,
                          (SELECT pk_inp_hidrics.get_intake_output_text(i_lang,
                                                                        i_prof,
                                                                        l_msg_min_output,
                                                                        l_min_output,
                                                                        l_hidr_unit_measure)
                             FROM dual),
                          '') desc_hidrics,
                   pk_inp_hidrics_constant.g_element_total flg_type,
                   pk_inp_hidrics_constant.g_element_total flg_total,
                   pk_alert_constant.g_no flg_edit,
                   t_total.rank rank,
                   0 rank_hidrics,
                   NULL id_hidrics_way,
                   desc_h || ' (' || l_hidr_unit_measure || ')' desc_way,
                   NULL id_hidrics_location,
                   NULL id_body_part,
                   NULL id_body_side,
                   '' desc_location,
                   NULL desc_body_part,
                   NULL desc_body_side,
                   (SELECT pk_sysconfig.get_config(l_config_color || '_' || t_total.flg_type, i_prof)
                      FROM dual) graph_color,
                   pk_inp_hidrics_constant.g_epis_hid_lin_status_a flg_status,
                   pk_alert_constant.g_no flg_future,
                   CAST(MULTISET (SELECT get_hidrics_total_properties(i_lang,
                                                             i_prof,
                                                             i_epis_hidrics,
                                                             i_flg_grid_type,
                                                             t_total.flg_type,
                                                             a.dt_reg,
                                                             a.flg_reg_type,
                                                             l_dt_init,
                                                             a.dt_init_balance,
                                                             l_max_intake,
                                                             l_min_output,
                                                             o_hidrics_type)
                           FROM (SELECT DISTINCT ed2.dt_execution_tstz                    dt_reg,
                                                 ed2.dt_first_reg_balance                 dt_init_balance,
                                                 pk_inp_hidrics_constant.g_element_normal flg_reg_type
                                   FROM epis_hidrics_det ed2
                                  WHERE ed2.id_epis_hidrics = i_epis_hidrics
                                    AND nvl(i_flg_interval, pk_inp_hidrics_constant.g_graph_hour) <>
                                        pk_inp_hidrics_constant.g_graph_interval
                                    AND (ed2.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a AND
                                        nvl(ed2.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                                        pk_inp_hidrics_constant.g_epis_hid_det_type_a OR
                                        i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_f)
                                    AND (ed2.dt_execution_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                                    AND (ed2.dt_execution_tstz <= i_dt_end OR i_dt_end IS NULL)
                                 UNION ALL
                                 SELECT eb2.dt_close_balance_tstz               dt_reg,
                                        eb2.dt_open_tstz                        dt_init_balance,
                                        pk_inp_hidrics_constant.g_element_total flg_reg_type
                                   FROM epis_hidrics_balance eb2
                                  WHERE eb2.id_epis_hidrics = i_epis_hidrics
                                    AND eb2.dt_close_balance_tstz IS NOT NULL
                                    AND nvl(i_flg_interval, pk_inp_hidrics_constant.g_graph_interval) <>
                                        pk_inp_hidrics_constant.g_graph_hour
                                    AND (eb2.dt_close_balance_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                                    AND (eb2.dt_close_balance_tstz <= i_dt_end OR i_dt_end IS NULL)
                                 UNION
                                 -- iv fluids
                                 SELECT /*+opt_estimate(table,t,scale_rows=0.0001)*/
                                  column_value                             dt_reg,
                                  NULL                                     dt_init_balance,
                                  pk_inp_hidrics_constant.g_element_normal flg_reg_type
                                   FROM TABLE(pk_api_pfh_clindoc_in.get_fluid_balance_med_dates(i_lang,
                                                                                                i_prof,
                                                                                                i_epis_hidrics)) t
                                  WHERE nvl(i_flg_interval, pk_inp_hidrics_constant.g_graph_hour) <>
                                        pk_inp_hidrics_constant.g_graph_interval
                                    AND l_import_iv_fluids = pk_alert_constant.g_yes
                                    AND (t.column_value >= i_dt_begin OR i_dt_begin IS NULL)
                                    AND (t.column_value <= i_dt_end OR i_dt_end IS NULL)
                                       --only the Intake and Outupt and the intakes include the IV fluids
                                    AND l_acronym IN (pk_inp_hidrics_constant.g_hid_type_h,
                                                      pk_inp_hidrics_constant.g_hid_type_i)
                                  ORDER BY dt_reg) a) AS table_varchar) values_hidrics,
                   pk_alert_constant.g_no flg_detail,
                   l_flg_ready_only flg_ready_only,
                   NULL flg_nr_times,
                   pk_alert_constant.g_no flg_body_part_free_text,
                   pk_alert_constant.g_no flg_irrigation
              FROM (SELECT (SELECT pk_message.get_message(i_lang, l_code_message || '_' || hidr_rec.flg_type)
                              FROM dual) desc_h,
                           (SELECT pk_sysdomain.get_rank(i_lang, 'HIDRICS.FLG_TYPE', hidr_rec.flg_type)
                              FROM dual) rank,
                           hidr_rec.flg_type
                      FROM (SELECT DISTINCT h.flg_type
                              FROM epis_hidrics_line ehl
                             INNER JOIN hidrics h
                                ON h.id_hidrics = ehl.id_hidrics
                             WHERE ehl.id_epis_hidrics = i_epis_hidrics
                            
                            UNION
                            SELECT get_hidrics_type(i_lang, i_prof, o_hidrics_type) flg_type
                              FROM dual
                            
                            ) hidr_rec
                     WHERE hidr_rec.flg_type IS NOT NULL
                          --the irrigations that are not in an intake and output do not have total intake 
                          -- nor total output
                       AND l_acronym <> pk_inp_hidrics_constant.g_hidrics_irrigations_g) t_total
            
            UNION ALL
            -- total irrigations / groups
            SELECT -1 id_hidrics,
                   -1 id_epis_hidrics_line,
                   NULL desc_hidrics,
                   pk_inp_hidrics_constant.g_element_total flg_type,
                   pk_inp_hidrics_constant.g_element_total flg_total,
                   pk_alert_constant.g_no flg_edit,
                   (id_epis_hidrics_group * -1) rank,
                   0 rank_hidrics,
                   NULL id_hidrics_way,
                   l_desc_total_irrigation || ' (' || l_hidr_unit_measure || ')' || CASE
                       WHEN i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_g THEN
                        ': ' ||
                        pk_inp_hidrics_groups.get_hidrics_group_desc(i_lang                  => i_lang,
                                                                     i_prof                  => i_prof,
                                                                     i_id_epis_hidrics_group => t_total.id_epis_hidrics_group)
                       ELSE
                        NULL
                   END desc_way,
                   NULL id_hidrics_location,
                   NULL id_body_part,
                   NULL id_body_side,
                   '' desc_location,
                   NULL desc_body_part,
                   NULL desc_body_side,
                   (SELECT pk_inp_hidrics.get_table_val(l_list_colors, t_total.rn)
                      FROM dual) graph_color,
                   flg_status flg_status,
                   pk_alert_constant.g_no flg_future,
                   CAST(MULTISET (SELECT get_hidrics_total_properties(i_lang,
                                                             i_prof,
                                                             i_epis_hidrics,
                                                             i_flg_grid_type,
                                                             NULL,
                                                             a.dt_reg,
                                                             a.flg_reg_type,
                                                             l_dt_init,
                                                             a.dt_init_balance,
                                                             l_max_intake,
                                                             l_min_output,
                                                             o_hidrics_type,
                                                             id_epis_hidrics_group,
                                                             t_total.flg_status)
                           FROM (SELECT DISTINCT ed2.dt_execution_tstz                    dt_reg,
                                                 ed2.dt_first_reg_balance                 dt_init_balance,
                                                 pk_inp_hidrics_constant.g_element_normal flg_reg_type
                                   FROM epis_hidrics_det ed2
                                   JOIN epis_hidrics_line ehl
                                     ON ehl.id_epis_hidrics_line = ed2.id_epis_hidrics_line
                                   JOIN epis_hd_line_group ehlg
                                     ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line
                                  WHERE ed2.id_epis_hidrics = i_epis_hidrics
                                    AND nvl(i_flg_interval, pk_inp_hidrics_constant.g_graph_hour) <>
                                        pk_inp_hidrics_constant.g_graph_interval
                                    AND (ed2.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a AND
                                        nvl(ed2.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                                        pk_inp_hidrics_constant.g_epis_hid_det_type_a OR
                                        i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_f)
                                    AND (ed2.dt_execution_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                                    AND (ed2.dt_execution_tstz <= i_dt_end OR i_dt_end IS NULL)
                                 UNION ALL
                                 SELECT eb2.dt_close_balance_tstz               dt_reg,
                                        eb2.dt_open_tstz                        dt_init_balance,
                                        pk_inp_hidrics_constant.g_element_total flg_reg_type
                                   FROM epis_hidrics_balance eb2
                                  WHERE eb2.id_epis_hidrics = i_epis_hidrics
                                    AND eb2.dt_close_balance_tstz IS NOT NULL
                                    AND nvl(i_flg_interval, pk_inp_hidrics_constant.g_graph_interval) <>
                                        pk_inp_hidrics_constant.g_graph_hour
                                    AND (eb2.dt_close_balance_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                                    AND (eb2.dt_close_balance_tstz <= i_dt_end OR i_dt_end IS NULL)
                                 
                                  ORDER BY dt_reg) a) AS table_varchar) values_hidrics,
                   pk_alert_constant.g_no flg_detail,
                   l_flg_ready_only flg_ready_only,
                   NULL flg_nr_times,
                   pk_alert_constant.g_no flg_body_part_free_text,
                   pk_alert_constant.g_yes flg_irrigation
              FROM (SELECT t.id_epis_hidrics_group, t.flg_status, rownum rn
                      FROM (SELECT DISTINCT ehlg.id_epis_hidrics_group, ehg.flg_status
                              FROM epis_hd_line_group ehlg
                              JOIN epis_hidrics_line ehl
                                ON ehl.id_epis_hidrics_line = ehlg.id_epis_hidrics_line
                              JOIN epis_hidrics_group ehg
                                ON ehg.id_epis_hidrics_group = ehlg.id_epis_hidrics_group
                             WHERE ehl.id_epis_hidrics = i_epis_hidrics) t) t_total
            
            UNION ALL
            -- total intake and output. Total balance (Balance of administrations/eliminations)
            SELECT -2 id_hidrics,
                   -2 id_epis_hidrics_line,
                   '' desc_hidrics,
                   pk_inp_hidrics_constant.g_element_total flg_type,
                   pk_inp_hidrics_constant.g_element_tot_abs flg_total,
                   pk_alert_constant.g_no flg_edit,
                   100 rank,
                   0 rank_hidrics,
                   NULL id_hidrics_way,
                   (SELECT pk_message.get_message(i_lang, l_code_message) || ' (' || l_hidr_unit_measure || ')'
                      FROM dual) desc_way,
                   NULL id_hidrics_location,
                   NULL id_body_part,
                   NULL id_body_side,
                   '' desc_location,
                   NULL desc_body_part,
                   NULL desc_body_side,
                   (SELECT pk_sysconfig.get_config(l_config_color, i_prof)
                      FROM dual) graph_color,
                   pk_inp_hidrics_constant.g_epis_hid_lin_status_a flg_status,
                   pk_alert_constant.g_no flg_future,
                   CAST(MULTISET (SELECT get_hidrics_total_properties(i_lang,
                                                             i_prof,
                                                             i_epis_hidrics,
                                                             i_flg_grid_type,
                                                             NULL,
                                                             a.dt_reg,
                                                             a.flg_reg_type,
                                                             l_dt_init,
                                                             a.dt_init_balance,
                                                             NULL,
                                                             NULL,
                                                             o_hidrics_type)
                           FROM (SELECT DISTINCT ed2.dt_execution_tstz                    dt_reg,
                                                 ed2.dt_first_reg_balance                 dt_init_balance,
                                                 pk_inp_hidrics_constant.g_element_normal flg_reg_type
                                   FROM epis_hidrics_det ed2
                                  WHERE ed2.id_epis_hidrics = i_epis_hidrics
                                    AND nvl(i_flg_interval, pk_inp_hidrics_constant.g_graph_hour) <>
                                        pk_inp_hidrics_constant.g_graph_interval
                                    AND (ed2.dt_execution_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                                    AND (ed2.dt_execution_tstz < i_dt_end OR i_dt_end IS NULL)
                                 UNION ALL
                                 SELECT eb2.dt_close_balance_tstz               dt_reg,
                                        eb2.dt_open_tstz                        dt_init_balance,
                                        pk_inp_hidrics_constant.g_element_total flg_reg_type
                                   FROM epis_hidrics_balance eb2
                                  WHERE eb2.id_epis_hidrics = i_epis_hidrics
                                    AND eb2.dt_close_balance_tstz IS NOT NULL
                                    AND nvl(i_flg_interval, pk_inp_hidrics_constant.g_graph_interval) <>
                                        pk_inp_hidrics_constant.g_graph_hour
                                    AND (eb2.dt_close_balance_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                                    AND (eb2.dt_close_balance_tstz <= i_dt_end OR i_dt_end IS NULL)
                                 UNION
                                 -- iv fluids
                                 SELECT /*+opt_estimate(table,tiv,scale_rows=0.0001)*/
                                  column_value                             dt_reg,
                                  NULL                                     dt_init_balance,
                                  pk_inp_hidrics_constant.g_element_normal flg_reg_type
                                   FROM TABLE(pk_api_pfh_clindoc_in.get_fluid_balance_med_dates(i_lang,
                                                                                                i_prof,
                                                                                                i_epis_hidrics)) tiv
                                  WHERE l_import_iv_fluids = pk_alert_constant.g_yes
                                    AND (tiv.column_value >= i_dt_begin OR i_dt_begin IS NULL)
                                    AND (tiv.column_value < i_dt_end OR i_dt_end IS NULL)
                                       --only the Intake and Outupt and the intakes include the IV fluids
                                    AND l_acronym IN (pk_inp_hidrics_constant.g_hid_type_h,
                                                      pk_inp_hidrics_constant.g_hid_type_i)
                                  ORDER BY dt_reg) a) AS table_varchar) values_hidrics,
                   pk_alert_constant.g_no flg_detail,
                   l_flg_ready_only flg_ready_only,
                   NULL flg_nr_times,
                   pk_alert_constant.g_no flg_body_part_free_text,
                   pk_alert_constant.g_no flg_irrigation
              FROM dual
             WHERE l_acronym = pk_inp_hidrics_constant.g_hid_type_h
             ORDER BY rank, flg_total, rank_hidrics, desc_hidrics;
    
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid_time);
            pk_types.open_my_cursor(o_epis_hid_hour);
            pk_types.open_my_cursor(o_epis_hid_par);
            RETURN FALSE;
    END get_epis_hidrics_grid_int;

    /*******************************************************************************************************************************************
    * Given an epis_hidrics_balance id calculated the previous and the next balance.
    * To be returned to the flash in order to know the balance that should be loaded
    * when the user clicks in the next and previous arrows
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_epis_hidrics_balance   EPIS_HIDRICS balance to load in the grid
    * @param o_id_balance_prev        epis hidrics balance id
    * @param o_id_balance_next        epis hidrics balance id
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         Sofia Mendes
    * @version                        2.6.3.8
    * @since                          2013/09/04
    *******************************************************************************************************************************************/
    FUNCTION get_prev_and_next_balance
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_epis_hidrics         IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hidrics_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_id_balance_prev      OUT epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_id_balance_next      OUT epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(26 CHAR) := 'GET_PREV_AND_NEXT_BALANCE';
    
        l_internal_error EXCEPTION;
    
    BEGIN
        IF (i_epis_hidrics_balance IS NOT NULL)
        THEN
            g_error := 'get_prev_and_next_balance. i_epis_hidrics: ' || i_epis_hidrics || ' i_epis_hidrics_balance: ' ||
                       i_epis_hidrics_balance;
            pk_alertlog.log_debug(g_error);
            SELECT previous_bal, next_bal
              INTO o_id_balance_prev, o_id_balance_next
              FROM (SELECT lag(e.id_epis_hidrics_balance) over(ORDER BY e.dt_open_tstz) AS previous_bal,
                           lead(e.id_epis_hidrics_balance) over(ORDER BY e.dt_open_tstz) AS next_bal,
                           e.id_epis_hidrics_balance
                      FROM epis_hidrics_balance e
                     WHERE e.id_epis_hidrics = i_epis_hidrics) t
             WHERE t.id_epis_hidrics_balance = i_epis_hidrics_balance;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_prev_and_next_balance;

    /*******************************************************************************************************************************************
    * get_balance_dates          Get start and end date of the balance being shown in the grid,
    * or discovers the actual open balance if no epis_hidrics_balance is sent
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param io_epis_hidrics_balance   EPIS_HIDRICS balance to load in the grid
    * @param I_FLG_GRID_TYPE          Grid type: G - Graph, F - Flowsheet
    * @param o_balance_dt_begin       epis hidrics balance start date
    * @param o_balance_dt_end         epis hidrics balance end date
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         Sofia Mendes
    * @version                        2.6.3.8
    * @since                          2013/09/04
    *******************************************************************************************************************************************/
    FUNCTION get_balance_dates
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_flg_grid_type         IN VARCHAR2,
        i_epis_hidrics          IN epis_hidrics.id_epis_hidrics%TYPE,
        io_epis_hidrics_balance IN OUT epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_balance_dt_begin      OUT epis_hidrics_balance.dt_open_tstz%TYPE,
        o_balance_dt_end        OUT epis_hidrics_balance.dt_close_balance_tstz%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(17 CHAR) := 'GET_BALANCE_DATES';
    
        l_internal_error EXCEPTION;
    
    BEGIN
        IF (i_flg_grid_type = pk_inp_hidrics_constant.g_grid_type_f)
        THEN
            IF (io_epis_hidrics_balance IS NULL)
            THEN
                g_error := 'CALL get_most_recent_ehb_id. i_epis_hidrics: ' || i_epis_hidrics;
                pk_alertlog.log_debug(g_error);
                io_epis_hidrics_balance := get_most_recent_ehb_id(i_epis_hidrics => i_epis_hidrics);
            END IF;
        
            IF (io_epis_hidrics_balance IS NOT NULL)
            THEN
                BEGIN
                    g_error := 'Get min and max dates. i_epis_hidrics_balance: ' || io_epis_hidrics_balance;
                    pk_alertlog.log_debug(g_error);
                    SELECT ehb.dt_open_tstz, ehb.dt_close_balance_tstz
                      INTO o_balance_dt_begin, o_balance_dt_end
                      FROM epis_hidrics_balance ehb
                     WHERE ehb.id_epis_hidrics_balance = io_epis_hidrics_balance;
                EXCEPTION
                    WHEN no_data_found THEN
                        RAISE l_internal_error;
                END;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_balance_dates;

    /*******************************************************************************************************************************************
    * get_epis_hidrics_grid          Get all hidric records associated episode hidrics ID (flowsheet)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param i_epis_hidrics_balance   EPIS_HIDRICS balance to load in the grid
    * @param I_FLG_GRID_TYPE          Grid type: G - Graph, F - Flowsheet
    * @param I_FLG_INTERVAL           Interval type (used in the graph): H - Hour, I - interval
    * @param I_FLG_CONTEXT            Context in which the grid was loaded (null if the grid was loaded through the deepnav):
                                           R - New intake/output record. 
                                           B - End of balance
    * @param O_EPIS_HID_TIME          Grid columns (one per date)
    * @param O_EPIS_HID_PAR           Lines or series of values (one per hidrics)
    * @param O_EPIS_HID_HOUR          Graph scale (in hours)
    * @param o_id_balance_next        next id_epis_hidrics_balance
    * @param o_id_balance_before      previous id_epis_hidrics_balance
    * @param o_min_date               Minimun date to create columns in the grid
    * @param o_max_date               Maximun date to create columns in the grid
    * @param o_title                  Flowsheet title description
    * @param o_perf_balance           Y-It is possible to perform a balance. N-Otherwise
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         José Silva
    * @version                        2.6.0.3
    * @since                          2010/05/27
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_grid
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_epis_hidrics         IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hidrics_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        i_flg_grid_type        IN VARCHAR2,
        i_flg_interval         IN VARCHAR2 DEFAULT NULL,
        i_flg_context          IN VARCHAR2 DEFAULT NULL,
        o_epis_hid_time        OUT NOCOPY pk_types.cursor_type,
        o_epis_hid_par         OUT NOCOPY pk_types.cursor_type,
        o_epis_hid_hour        OUT NOCOPY pk_types.cursor_type,
        o_max_scale            OUT NOCOPY NUMBER,
        o_label_ref            OUT NOCOPY VARCHAR2,
        o_msg_text             OUT NOCOPY VARCHAR2,
        o_msg_title            OUT NOCOPY VARCHAR2,
        o_id_balance_next      OUT NOCOPY epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_id_balance_before    OUT NOCOPY epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_min_date             OUT NOCOPY VARCHAR2,
        o_max_date             OUT NOCOPY VARCHAR2,
        o_title                OUT NOCOPY VARCHAR2,
        o_perf_balance         OUT VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dt_begin TIMESTAMP WITH LOCAL TIME ZONE := NULL;
        l_dt_end   TIMESTAMP WITH LOCAL TIME ZONE := NULL;
    
        l_internal_error EXCEPTION;
        l_id_epis_hidrics_balance epis_hidrics_balance.id_epis_hidrics_balance%TYPE := i_epis_hidrics_balance;
        l_hidrics_type            hidrics_type.id_hidrics_type%TYPE;
    BEGIN
        g_error := 'CALL get_balance_dates. i_flg_grid_type: ' || i_flg_grid_type || ' i_epis_hidrics: ' ||
                   i_epis_hidrics || ' i_epis_hidrics_balance: ' || i_epis_hidrics_balance;
        pk_alertlog.log_debug(g_error);
        IF NOT get_balance_dates(i_lang                  => i_lang,
                                 i_prof                  => i_prof,
                                 i_flg_grid_type         => i_flg_grid_type,
                                 i_epis_hidrics          => i_epis_hidrics,
                                 io_epis_hidrics_balance => l_id_epis_hidrics_balance,
                                 o_balance_dt_begin      => l_dt_begin,
                                 o_balance_dt_end        => l_dt_end,
                                 o_error                 => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'CALL TO PK_INP_HIDRICS.GET_EPIS_HIDRICS_GRID';
        pk_alertlog.log_debug(g_error);
        IF NOT get_epis_hidrics_grid_int(i_lang                 => i_lang,
                                         i_prof                 => i_prof,
                                         i_episode              => i_episode,
                                         i_epis_hidrics         => i_epis_hidrics,
                                         i_epis_hidrics_balance => l_id_epis_hidrics_balance,
                                         i_flg_grid_type        => i_flg_grid_type,
                                         i_flg_interval         => i_flg_interval,
                                         i_dt_begin             => l_dt_begin,
                                         i_dt_end               => l_dt_end,
                                         i_flg_context          => i_flg_context,
                                         o_epis_hid_time        => o_epis_hid_time,
                                         o_epis_hid_par         => o_epis_hid_par,
                                         o_epis_hid_hour        => o_epis_hid_hour,
                                         o_max_scale            => o_max_scale,
                                         o_label_ref            => o_label_ref,
                                         o_msg_title            => o_msg_title,
                                         o_msg_text             => o_msg_text,
                                         o_hidrics_type         => l_hidrics_type,
                                         o_error                => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        g_error := 'CALL get_prev_and_next_balance. i_epis_hidrics_balance: ' || l_id_epis_hidrics_balance;
        pk_alertlog.log_debug(g_error);
        IF NOT get_prev_and_next_balance(i_lang                 => i_lang,
                                         i_prof                 => i_prof,
                                         i_epis_hidrics         => i_epis_hidrics,
                                         i_epis_hidrics_balance => l_id_epis_hidrics_balance,
                                         o_id_balance_prev      => o_id_balance_before,
                                         o_id_balance_next      => o_id_balance_next,
                                         o_error                => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        o_min_date := pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_dt_begin, i_prof => i_prof);
    
        o_max_date := pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_dt_end, i_prof => i_prof);
        --
        g_error := 'CALL get_flowsheet_desc';
        pk_alertlog.log_debug(g_error);
        IF NOT get_flowsheet_desc(i_lang         => i_lang,
                                  i_prof         => i_prof,
                                  i_hidrics_type => l_hidrics_type,
                                  i_dt_begin     => l_dt_begin,
                                  i_dt_end       => l_dt_end,
                                  o_desc         => o_title,
                                  o_error        => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF (o_id_balance_next IS NULL)
        THEN
            o_perf_balance := pk_inp_hidrics.is_to_perform_balance(i_lang, i_prof, i_epis_hidrics);
        ELSE
            o_perf_balance := pk_alert_constant.g_no;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'get_epis_hidrics_grid',
                                              o_error);
        
            RETURN FALSE;
    END get_epis_hidrics_grid;

    /*******************************************************************************************************************************************
    * Get the title description to the flowsheet screen.
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_hidrics_type           Hidrics type ID
    * @param i_dt_begin               Balance dt begin
    * @param i_dt_end                 Balance dt end
    * @param o_desc                   Flowsheet title description
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         Sofia Mendes
    * @version                        2.6.3.8
    * @since                          13/09/2013
    *******************************************************************************************************************************************/
    FUNCTION get_flowsheet_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_hidrics_type IN hidrics_type.id_hidrics_type%TYPE,
        i_dt_begin     IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_dt_end       IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_desc         OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(18 CHAR) := 'GET_FLOWSHEET_DESC';
        l_title      pk_translation.t_desc_translation;
        l_dt_begin   pk_translation.t_desc_translation;
        l_dt_end     pk_translation.t_desc_translation;
        l_desc_dates pk_translation.t_desc_translation;
    BEGIN
        g_error := 'GET hidrics type desc. ';
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT pk_translation.get_translation(i_lang, ht.code_hidrics_type)
          INTO l_title
          FROM hidrics_type ht
         WHERE ht.id_hidrics_type = i_hidrics_type;
    
        l_title := l_title || pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_M125');
        IF (i_dt_end IS NULL)
        THEN
            g_error := 'Current balance ';
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            --current balance
            o_desc := l_title || ' ' || pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_T137');
        ELSE
            --previous balance
            g_error := 'GET date begin desc';
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_dt_begin := pk_date_utils.dt_chr_date_hour_tsz(i_lang => i_lang, i_date => i_dt_begin, i_prof => i_prof);
        
            g_error := 'GET date end desc. ';
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_dt_end := pk_date_utils.dt_chr_date_hour_tsz(i_lang => i_lang, i_date => i_dt_end, i_prof => i_prof);
        
            g_error := 'Calculate final desc desc. ';
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_desc_dates := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_M126');
        
            l_desc_dates := REPLACE(l_desc_dates, '@1', l_dt_begin);
        
            o_desc := l_title || ' ' || REPLACE(l_desc_dates, '@2', l_dt_end);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_FLOWSHEET_DESC',
                                              o_error);
        
            RETURN FALSE;
    END get_flowsheet_desc;

    /*******************************************************************************************************************************************
    * get_epis_hidrics_grid          Get all hidric records associated episode hidrics ID (flowsheet or graph)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_FLG_GRID_TYPE          Grid type: G - Graph, F - Flowsheet
    * @param I_FLG_INTERVAL           Interval type (used in the graph): H - Hour, I - interval
    * @param I_FLG_CONTEXT            Context in which the grid was loaded (null if the grid was loaded through the deepnav):
                                           R - New intake/output record. 
                                           B - End of balance
    * @param i_dt_begin               Begin date
    * @param i_dt_end                 End date
    * @param O_EPIS_HID_TIME          Grid columns (one per date)
    * @param O_EPIS_HID_PAR           Lines or series of values (one per hidrics)
    * @param O_EPIS_HID_HOUR          Graph scale (in hours)
    * @param O_MAX_SCALE              Graph maximum and minimum values
    * @param O_LABEL_REF              Label to be placed
    * @param O_MSG_TEXT               Warning pop-up text (if applicable)
    * @param O_MSG_TITLE              Warning pop-up title (if applicable)
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         José Silva
    * @version                        2.6.0.3
    * @since                          2010/05/27
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_grid_value
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_epis_hidrics         IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hidrics_line    IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_hidrics              IN epis_hidrics_line.id_hidrics%TYPE,
        i_flg_type             IN hidrics.flg_type%TYPE,
        i_hidr_unit_measure    IN pk_translation.t_desc_translation,
        i_desc_canceled        IN pk_translation.t_desc_translation,
        i_desc_nr_times        IN pk_translation.t_desc_translation,
        i_desc_proposed        IN pk_translation.t_desc_translation,
        i_dt_begin             IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_dt_end               IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_epis_hidrics_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE
    ) RETURN table_varchar IS
    
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_GRID_VALUE';
    
        l_values table_varchar;
        l_error  t_error_out;
    
    BEGIN
    
        g_error := 'GET CURSOR O_EPIS_HID_PAR';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT CAST(MULTISET
                    (SELECT nvl2(id_epis_hidrics_line,
                                 (SELECT get_hidrics_value(i_lang, i_prof, a.value_hidrics, i_flg_type)
                                    FROM dual),
                                 (SELECT get_hidrics_total_balance(i_lang,
                                                                   i_prof,
                                                                   i_epis_hidrics,
                                                                   a.id_epis_hidrics_balance,
                                                                   i_hidrics,
                                                                   i_flg_type,
                                                                   i_epis_hidrics_line,
                                                                   NULL,
                                                                   NULL,
                                                                   NULL,
                                                                   pk_alert_constant.g_no,
                                                                   NULL,
                                                                   NULL)
                                    FROM dual)) || pk_inp_hidrics_constant.g_separator ||
                            pk_date_utils.date_send_tsz(i_lang, a.dt_reg, i_prof) || pk_inp_hidrics_constant.g_separator ||
                            nvl(a.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) ||
                            pk_inp_hidrics_constant.g_separator ||
                            decode(a.flg_type,
                                   pk_inp_hidrics_constant.g_epis_hid_det_type_p,
                                   i_desc_proposed,
                                   decode(a.nr_times,
                                          NULL,
                                          decode(a.id_epis_hidrics_det, --balance case (sum of all occurrences in the balance)
                                                 NULL,
                                                 (SELECT get_hidrics_total_times(i_lang,
                                                                                 i_prof,
                                                                                 a.id_epis_hidrics_balance,
                                                                                 i_epis_hidrics_line,
                                                                                 i_desc_nr_times)
                                                    FROM dual),
                                                 NULL),
                                          REPLACE(i_desc_nr_times, pk_inp_hidrics_constant.g_msg_replace_1, a.nr_times))) ||
                            pk_inp_hidrics_constant.g_separator || a.id_epis_hidrics_det ||
                            pk_inp_hidrics_constant.g_separator || a.flg_total || pk_inp_hidrics_constant.g_separator ||
                            a.flg_status || pk_inp_hidrics_constant.g_separator || pk_inp_hidrics_constant.g_separator ||
                            (SELECT get_flowsheet_tooltip(i_lang,
                                                           i_prof,
                                                           i_epis_hidrics,
                                                           a.id_epis_hidrics_det,
                                                           a.nr_times,
                                                           a.value_hidrics,
                                                           a.id_hidrics_device,
                                                           a.id_professional,
                                                           CASE
                                                               WHEN a.flg_type IS NULL THEN
                                                                pk_inp_hidrics_constant.g_hidrics_flg_type_e
                                                               ELSE
                                                                pk_inp_hidrics_constant.g_hidrics_flg_type_a
                                                           END)
                               FROM dual) || pk_inp_hidrics_constant.g_separator ||
                            decode(a.flg_status, pk_inp_hidrics_constant.g_epis_hidric_c, i_desc_canceled, NULL) ||
                            pk_inp_hidrics_constant.g_separator || i_hidr_unit_measure hidr_unit_measure
                       FROM (SELECT ed2.id_epis_hidrics_det,
                                    ed2.value_hidrics,
                                    NULL                                     id_epis_hidrics_balance,
                                    ed2.flg_type,
                                    ed2.dt_execution_tstz                    dt_reg,
                                    ed2.id_epis_hidrics_line,
                                    pk_inp_hidrics_constant.g_element_normal flg_total,
                                    ed2.flg_status,
                                    ed2.nr_times,
                                    ed2.id_hidrics_device,
                                    ed2.id_professional
                               FROM epis_hidrics_det ed2
                              WHERE ed2.id_epis_hidrics = i_epis_hidrics
                                AND (ed2.dt_execution_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                                AND (ed2.dt_execution_tstz < i_dt_end OR i_dt_end IS NULL)
                             
                             UNION ALL
                             SELECT NULL                                          id_epis_hidrics_det,
                                    NULL                                          value_hidrics,
                                    eb2.id_epis_hidrics_balance,
                                    pk_inp_hidrics_constant.g_epis_hid_det_type_a flg_type,
                                    eb2.dt_close_balance_tstz                     dt_reg,
                                    NULL                                          id_epis_hidrics_line,
                                    pk_inp_hidrics_constant.g_element_total       flg_total,
                                    pk_alert_constant.g_active                    flg_status,
                                    NULL                                          nr_times,
                                    NULL                                          id_hidrics_device,
                                    NULL                                          id_professional
                               FROM epis_hidrics_balance eb2
                              WHERE eb2.id_epis_hidrics = i_epis_hidrics
                                AND eb2.dt_close_balance_tstz IS NOT NULL
                                AND (eb2.dt_close_balance_tstz >= i_dt_begin OR i_dt_begin IS NULL)
                                AND (eb2.dt_close_balance_tstz <= i_dt_end OR i_dt_end IS NULL)
                              ORDER BY dt_reg) a
                      WHERE a.id_epis_hidrics_line = i_epis_hidrics_line
                         OR a.id_epis_hidrics_line IS NULL) AS table_varchar) values_hidrics
          INTO l_values
          FROM dual;
    
        --
        RETURN l_values;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_epis_hidrics_grid_value;

    /*******************************************************************************************************************************************
    * get_grid_new_column             Get the header for a new column inserted by the user
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param i_id_epis_hidrics_balance EPIS_HIDRICS balance ID
    * @param I_DT_EXEC                New date
    * @param O_EPIS_HID_TIME          New column
    * @param O_NEW_INDEX              Index where the date is positioned in the time array
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/06/04
    *******************************************************************************************************************************************/
    FUNCTION get_grid_new_column
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_epis_hidrics         IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hidrics_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        i_dt_exec              IN VARCHAR2,
        o_epis_hid_time        OUT pk_types.cursor_type,
        o_new_index            OUT NUMBER,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name VARCHAR2(30 CHAR) := 'GET_GRID_NEW_COLUMN';
    
        l_dt_exec      epis_hidrics_det.dt_execution_tstz%TYPE;
        l_dt_last_exec epis_hidrics_det.dt_execution_tstz%TYPE;
        l_dt_init      epis_hidrics.dt_initial_tstz%TYPE;
        l_acronym      hidrics_type.acronym%TYPE;
    
        l_error_title   sys_message.desc_message%TYPE;
        l_error_message sys_message.desc_message%TYPE;
        l_common_error EXCEPTION;
    
        l_import_iv_fluids sys_config.id_sys_config%TYPE;
        l_dt_begin         TIMESTAMP WITH LOCAL TIME ZONE := NULL;
        l_dt_end           TIMESTAMP WITH LOCAL TIME ZONE := NULL;
    
        l_internal_error EXCEPTION;
        l_id_epis_hidrics_balance epis_hidrics_balance.id_epis_hidrics_balance%TYPE := i_epis_hidrics_balance;
    
    BEGIN
        g_error := 'CALL get_balance_dates. i_epis_hidrics: ' || i_epis_hidrics || ' i_epis_hidrics_balance: ' ||
                   i_epis_hidrics_balance;
        pk_alertlog.log_debug(g_error);
        IF NOT get_balance_dates(i_lang                  => i_lang,
                                 i_prof                  => i_prof,
                                 i_flg_grid_type         => pk_inp_hidrics_constant.g_grid_type_f,
                                 i_epis_hidrics          => i_epis_hidrics,
                                 io_epis_hidrics_balance => l_id_epis_hidrics_balance,
                                 o_balance_dt_begin      => l_dt_begin,
                                 o_balance_dt_end        => l_dt_end,
                                 o_error                 => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'GET import_iv_fluids sys_config';
        pk_alertlog.log_debug(g_error);
        l_import_iv_fluids := pk_sysconfig.get_config(i_code_cf => pk_inp_hidrics_constant.g_import_iv_fluids,
                                                      i_prof    => i_prof);
    
        g_error := 'GET DT INITIAL AND ACRONYM';
        SELECT eh.dt_initial_tstz, ht.acronym
          INTO l_dt_init, l_acronym
          FROM epis_hidrics eh
          JOIN hidrics_type ht
            ON ht.id_hidrics_type = eh.id_hidrics_type
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        l_dt_exec := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_exec, NULL);
    
        g_error := 'VALIDATE DT_EXEC';
        IF l_dt_exec < l_dt_init
        THEN
            l_error_title   := pk_message.get_message(i_lang, 'HIDRICS_T082');
            l_error_message := pk_message.get_message(i_lang, 'HIDRICS_M043');
            RAISE l_common_error;
        END IF;
    
        g_error := 'GET CURSOR O_EPIS_HID_TIME';
        OPEN o_epis_hid_time FOR
            SELECT DISTINCT i_dt_exec time_var,
                            pk_date_utils.date_daymonth_tsz(i_lang, l_dt_exec, i_prof.institution, i_prof.software) dt_day_month,
                            pk_date_utils.date_char_hour_tsz(i_lang, l_dt_exec, i_prof.institution, i_prof.software) hour_read,
                            pk_date_utils.date_year_tsz(i_lang, l_dt_exec, i_prof.institution, i_prof.software) dt_year_read,
                            pk_inp_hidrics_constant.g_element_normal flg_total,
                            '' label_total
              FROM dual;
    
        g_error := 'GET DATE INDEX';
        SELECT COUNT(*), MAX(dt_reg)
          INTO o_new_index, l_dt_last_exec
          FROM (SELECT DISTINCT ehd.dt_execution_tstz dt_reg, pk_inp_hidrics_constant.g_element_normal flg_total
                  FROM epis_hidrics_det ehd
                 WHERE ehd.id_epis_hidrics = i_epis_hidrics
                   AND ehd.id_epis_hidrics_balance = l_id_epis_hidrics_balance
                UNION ALL
                SELECT DISTINCT eb.dt_close_balance_tstz dt_reg, pk_inp_hidrics_constant.g_element_total flg_total
                  FROM epis_hidrics_balance eb
                 WHERE eb.id_epis_hidrics = i_epis_hidrics
                   AND (eb.dt_close_balance_tstz >= l_dt_begin OR l_dt_begin IS NULL)
                   AND (eb.dt_close_balance_tstz <= l_dt_end OR l_dt_end IS NULL)
                   AND eb.dt_close_balance_tstz IS NOT NULL
                UNION
                SELECT /*+opt_estimate (table t_med rows=0.00001)*/
                 t_med.column_value dt_reg, pk_inp_hidrics_constant.g_element_normal flg_total
                  FROM TABLE(pk_api_pfh_clindoc_in.get_fluid_balance_med_dates(i_lang, i_prof, i_epis_hidrics)) t_med
                 WHERE l_import_iv_fluids = pk_alert_constant.g_yes
                   AND (t_med.column_value >= l_dt_begin OR l_dt_begin IS NULL)
                   AND (t_med.column_value <= l_dt_end OR l_dt_end IS NULL)) a
         WHERE a.dt_reg <= l_dt_exec;
    
        g_error := 'VALIDATE DT_EXEC 2';
        IF l_dt_last_exec = l_dt_exec
        THEN
            l_error_title   := pk_message.get_message(i_lang, 'HIDRICS_T082');
            l_error_message := pk_message.get_message(i_lang, 'HIDRICS_M045');
            RAISE l_common_error;
        END IF;
    
        g_error := 'VALIDATE DT_EXEC 3';
        IF l_dt_exec > current_timestamp
           AND l_acronym IN (pk_inp_hidrics_constant.g_hid_type_d,
                             pk_inp_hidrics_constant.g_hid_type_r,
                             pk_inp_hidrics_constant.g_hid_type_all)
        THEN
            l_error_title   := pk_message.get_message(i_lang, 'HIDRICS_T082');
            l_error_message := pk_message.get_message(i_lang, 'HIDRICS_M046');
            RAISE l_common_error;
        END IF;
    
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_common_error THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   l_func_name,
                                   NULL,
                                   'U',
                                   l_error_title);
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_alert_exceptions.reset_error_state();
                pk_types.open_my_cursor(o_epis_hid_time);
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid_time);
            RETURN FALSE;
    END get_grid_new_column;

    /**
    * Gets the messages required for the modal window warning changes to the next balance date.
    *
    * @param   i_lang                Professional preferred language
    * @param   i_prof                Professional identification and its context (institution and software)
    * @param   i_id_epis_hidrics     Intake/output task ID
    * @param   o_msg_title           Modal window title
    * @param   o_msg_body            Modal window body message
    * @param   o_msg_body_balance_dt Modal window body message with the date for next balance
    * @param   o_error               Error information
    *
    * @return  TRUE if successful, FALSE otherwise
    *
    * @author  JOSE.BRITO
    * @version 2.6
    * @since   31-05-2010
    */
    FUNCTION get_next_balance_message
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        o_msg_title           OUT sys_message.desc_message%TYPE,
        o_msg_body            OUT sys_message.desc_message%TYPE,
        o_msg_body_balance_dt OUT sys_message.desc_message%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200 CHAR) := 'GET_NEXT_BALANCE_MESSAGE';
        l_invalid_param EXCEPTION;
        l_dt_next_balance VARCHAR2(200 CHAR);
    BEGIN
    
        IF i_id_epis_hidrics IS NULL
        THEN
            g_error := 'NULL ID_EPIS_HIDRICS';
            pk_alertlog.log_debug(g_error);
            RAISE l_invalid_param;
        END IF;
    
        g_error := 'GET NEXT BALANCE DATE';
        pk_alertlog.log_debug(g_error);
        SELECT pk_date_utils.date_char_tsz(i_lang,
                                           get_dt_next_balance(i_lang, i_prof, eh.id_epis_hidrics),
                                           i_prof.institution,
                                           i_prof.software)
          INTO l_dt_next_balance
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_id_epis_hidrics;
    
        o_msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_T075');
        o_msg_body  := pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_M030');
    
        IF l_dt_next_balance IS NOT NULL
        THEN
            o_msg_body_balance_dt := REPLACE(pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_M031'),
                                             '@1',
                                             l_dt_next_balance);
        ELSE
            o_msg_body_balance_dt := '';
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_invalid_param THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => 'INVALID PARAM',
                                              i_sqlerrm  => g_error,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_next_balance_message;

    /**
    * Get epis_hidrics_balance for the given date
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   i_dt_exec                   Date of execution
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   27-05-2010
    */
    FUNCTION get_balance_id
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_dt_exec      IN epis_hidrics_det.dt_execution_tstz%TYPE DEFAULT current_timestamp
    ) RETURN epis_hidrics_balance.id_epis_hidrics_balance%TYPE IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_BALANCE_ID';
        --
        l_epis_hidrics_balance epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_dt_initials          epis_hidrics.dt_initial_tstz%TYPE;
        l_dt_exec              epis_hidrics_det.dt_execution_tstz%TYPE;
    BEGIN
    
        SELECT eh.dt_initial_tstz
          INTO l_dt_initials
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        IF (i_dt_exec < l_dt_initials)
        THEN
            l_dt_exec := l_dt_initials;
        ELSE
            l_dt_exec := i_dt_exec;
        END IF;
    
        BEGIN
            g_error := 'GET CURRENT ID_EPIS_HIDRICS_BAL. ID_EPIS_HIDRICS: ' || i_epis_hidrics || '; DT_EXEC: ' ||
                       pk_date_utils.date_send_tsz(i_lang, l_dt_exec, i_prof);
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            SELECT id_epis_hidrics_balance
              INTO l_epis_hidrics_balance
              FROM (SELECT ehb.id_epis_hidrics_balance,
                           row_number() over(ORDER BY decode(ehb.dt_close_balance_tstz, NULL, 1, 0), ehb.dt_close_balance_tstz ASC) line_number
                      FROM epis_hidrics_balance ehb
                     WHERE ehb.id_epis_hidrics = i_epis_hidrics
                       AND l_dt_exec BETWEEN nvl(ehb.dt_open_tstz, l_dt_initials) AND
                           nvl(ehb.dt_close_balance_tstz, l_dt_exec)
                       AND (l_dt_exec != ehb.dt_close_balance_tstz OR ehb.dt_close_balance_tstz IS NULL))
             WHERE line_number = 1;
        EXCEPTION
            WHEN no_data_found THEN
                RAISE g_epis_hid_balance_not_found;
        END;
    
        RETURN l_epis_hidrics_balance;
    END get_balance_id;

    /**
    * Get detail/history signature line
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_id_episode                Episode id
    * @param   i_date                      Date of the insertion/last change
    * @param   i_id_prof_last_change       Professional id that performed the insertion/ last change
    * @param   i_id_prof_last_change       Professional id that performed the insertion/ last change
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Sofia Mendes
    * @version v2.6.0.5
    * @since   14-Jan-2011
    */
    FUNCTION get_signature
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_date                IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_id_prof_last_change professional.id_professional%TYPE
    ) RETURN VARCHAR2 IS
        l_desc_signature sys_message.desc_message%TYPE;
        l_spec           VARCHAR2(200 CHAR);
        l_id_visit       episode.id_visit%TYPE;
    BEGIN
        l_desc_signature := pk_message.get_message(i_lang, i_prof, 'HIDRICS_M070');
    
        g_error := 'CALL pk_episode.get_id_visit. i_id_episode: ' || i_id_episode;
        pk_alertlog.log_debug(g_error);
        l_id_visit := pk_episode.get_id_visit(i_episode => i_id_episode);
    
        g_error := 'CALL pk_prof_utils.get_spec_sign_by_visit. i_id_prof_last_change: ' || i_id_prof_last_change ||
                   '; i_date: ' || CAST(i_date AS VARCHAR2) || '; id_visit: ' || l_id_visit;
        pk_alertlog.log_debug(g_error);
        l_spec := pk_prof_utils.get_spec_sign_by_visit(i_lang     => i_lang,
                                                       i_prof     => i_prof,
                                                       i_prof_id  => i_id_prof_last_change,
                                                       i_dt_reg   => i_date,
                                                       i_id_visit => l_id_visit);
    
        g_error := 'GET SIGNATURE';
        pk_alertlog.log_debug(g_error);
        RETURN l_desc_signature || ' ' || pk_date_utils.date_char_tsz(i_lang,
                                                                      i_date,
                                                                      i_prof.institution,
                                                                      i_prof.software) || '; ' --
        || pk_prof_utils.get_name_signature(i_lang => i_lang, i_prof => i_prof, i_prof_id => i_id_prof_last_change) || CASE WHEN l_spec IS NOT NULL THEN ' (' || l_spec || ')' END;
    
    END get_signature;

    /**
    * Get current epis_hidrics balance
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   27-05-2010
    */
    FUNCTION get_id_hid_location
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_body_part      IN hidrics_location.id_body_part%TYPE,
        i_body_side      IN hidrics_location.id_body_side%TYPE,
        i_body_part_ftxt IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL
    ) RETURN hidrics_location.id_hidrics_location%TYPE IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_ID_HID_LOCATION';
        --
        l_id_hid_loc hidrics_location.id_hidrics_location%TYPE;
    BEGIN
    
        IF (i_body_part IS NOT NULL OR i_body_side IS NOT NULL OR i_body_part_ftxt IS NOT NULL)
        THEN
            g_error := 'GET ID_HIDRICS_LOCATION';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            SELECT hl.id_hidrics_location
              INTO l_id_hid_loc
              FROM hidrics_location hl
             WHERE nvl(hl.id_body_part, -99) = nvl(i_body_part, -99)
               AND (nvl(hl.id_body_side, -99) = nvl(i_body_side, -99)) --or (i_body_side is null)
               AND hl.flg_available = pk_alert_constant.g_yes;
        
            IF (l_id_hid_loc IS NULL AND i_body_part_ftxt IS NOT NULL)
            THEN
                l_id_hid_loc := 0;
            END IF;
        END IF;
    
        RETURN l_id_hid_loc;
    EXCEPTION
        WHEN no_data_found THEN
            IF (i_body_part_ftxt IS NOT NULL)
            THEN
                l_id_hid_loc := 0;
            ELSE
                l_id_hid_loc := NULL;
            END IF;
            RETURN l_id_hid_loc;
    END get_id_hid_location;

    /**
    * Verifies if it's necessary to update the balance of id_epis_hidrics_det
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_data                      Epis hidrics det data
    * @param   o_epis_hid_det              Epis hidrics det id
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   27-05-2010
    */
    FUNCTION is_to_update_balance
    (
        i_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        i_flg_type         IN epis_hidrics_det.flg_type%TYPE DEFAULT NULL,
        i_value_hidrics    IN epis_hidrics_det.value_hidrics%TYPE DEFAULT NULL,
        i_flg_status       IN epis_hidrics_det.flg_status%TYPE DEFAULT NULL
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'UPDATE_BALANCE';
        --
        l_flg_type   epis_hidrics_det.flg_type%TYPE;
        l_val_hid    epis_hidrics_det.value_hidrics%TYPE;
        l_flg_status epis_hidrics_det.flg_status%TYPE;
    BEGIN
        g_error := 'GET CURRENT FLG_TYPE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT ehd.flg_type, ehd.value_hidrics, ehd.flg_status
          INTO l_flg_type, l_val_hid, l_flg_status
          FROM epis_hidrics_det ehd
         WHERE ehd.id_epis_hidrics_det = i_epis_hidrics_det;
    
        g_error := 'VERIFY IF IT''S NECESSARY UPDATE BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        RETURN(l_flg_type != nvl(i_flg_type, l_flg_type)) OR --
        (l_val_hid != nvl(i_value_hidrics, l_val_hid)) OR --
        (l_flg_status != nvl(i_flg_status, l_flg_status));
    END is_to_update_balance;

    /**
    * Gets free text id's
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)    
    * @param   i_way                       Way id
    * @param   i_way_ft                    Way free text
    * @param   i_loc                       Hidrics location id
    * @param   i_location_ft               Location free text
    * @param   i_hid                       Hidrics id
    * @param   i_hid_ft                    Hidrics free text
    * @param   i_device                    Device id
    * @param   i_device_ft                 Device free text
    * @param   i_hidrics_charact           Characteristics id
    * @param   i_charact_ft                Characteristics free text
    * @param   o_ft_way                    Way free text id
    * @param   o_ft_loc                    Location free text id
    * @param   o_ft_hid                    Hidrics free text id
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Sofia Mendes
    * @version v2.6.1.1
    * @since   15-Jun-2011
    */
    FUNCTION get_ft_ids
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_patient      IN patient.id_patient%TYPE,
        i_way             IN way.id_way%TYPE DEFAULT NULL,
        i_way_ft          IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_loc             IN hidrics_location.id_hidrics_location%TYPE DEFAULT NULL,
        i_location_ft     IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_hid             IN hidrics.id_hidrics%TYPE DEFAULT NULL,
        i_hid_ft          IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_device          IN epis_hidrics_det.id_hidrics_device%TYPE DEFAULT NULL,
        i_device_ft       IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_hidrics_charact IN hidrics_charact.id_hidrics_charact%TYPE DEFAULT NULL,
        i_charact_ft      IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        o_ft_way          OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_ft_loc          OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_ft_hid          OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_ft_device       OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_ft_charact      OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_FT_IDS';
    BEGIN
        g_error := 'GET ID_FT HID_WAY';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        IF (i_way IS NOT NULL AND i_way_ft IS NOT NULL)
        THEN
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  INTO o_ft_way
                  FROM epis_hidrics_det_ftxt ft
                 WHERE ft.id_way = i_way
                   AND ft.free_text = i_way_ft
                   AND ft.id_way IS NOT NULL
                   AND ft.id_hidrics_location IS NULL
                   AND ft.id_hidrics IS NULL
                   AND ft.id_hidrics_charact IS NULL
                   AND ft.id_hidrics_device IS NULL
                   AND ft.id_patient = i_id_patient
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_way := NULL;
            END;
        END IF;
    
        IF (i_hid IS NOT NULL AND i_hid_ft IS NOT NULL)
        THEN
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  INTO o_ft_hid
                  FROM epis_hidrics_det_ftxt ft
                 WHERE ft.id_hidrics = i_hid
                   AND ft.free_text = i_hid_ft
                   AND ft.id_way IS NULL
                   AND ft.id_hidrics_location IS NULL
                   AND ft.id_hidrics IS NOT NULL
                   AND ft.id_hidrics_charact IS NULL
                   AND ft.id_hidrics_device IS NULL
                   AND ft.id_patient = i_id_patient
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_hid := NULL;
            END;
        END IF;
    
        IF (i_loc IS NOT NULL AND i_location_ft IS NOT NULL)
        THEN
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  INTO o_ft_loc
                  FROM epis_hidrics_det_ftxt ft
                 WHERE ft.id_hidrics_location = i_loc
                   AND ft.free_text = i_location_ft
                   AND ft.id_way IS NULL
                   AND ft.id_hidrics_location IS NOT NULL
                   AND ft.id_hidrics IS NULL
                   AND ft.id_hidrics_charact IS NULL
                   AND ft.id_hidrics_device IS NULL
                   AND ft.id_patient = i_id_patient
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_loc := NULL;
            END;
        END IF;
    
        IF (i_device IS NOT NULL AND i_device_ft IS NOT NULL)
        THEN
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  INTO o_ft_device
                  FROM epis_hidrics_det_ftxt ft
                 WHERE ft.id_hidrics_device = i_device
                   AND ft.free_text = i_device_ft
                   AND ft.id_way IS NULL
                   AND ft.id_hidrics_location IS NULL
                   AND ft.id_hidrics IS NULL
                   AND ft.id_hidrics_charact IS NULL
                   AND ft.id_hidrics_device IS NOT NULL
                   AND ft.id_patient = i_id_patient
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_device := NULL;
            END;
        END IF;
    
        IF (i_hidrics_charact IS NOT NULL AND i_charact_ft IS NOT NULL)
        THEN
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  INTO o_ft_charact
                  FROM epis_hidrics_det_ftxt ft
                 WHERE ft.id_hidrics_charact = i_hidrics_charact
                   AND ft.free_text = i_charact_ft
                   AND ft.id_way IS NULL
                   AND ft.id_hidrics_location IS NULL
                   AND ft.id_hidrics IS NULL
                   AND ft.id_hidrics_charact IS NOT NULL
                   AND ft.id_hidrics_device IS NULL
                   AND ft.id_patient = i_id_patient
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_charact := NULL;
            END;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_ft_ids;

    /**
    * Gets free text id's
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics_line         Epis hidrics line id
    * @param   i_way                       Way id
    * @param   i_way_ft                    Way free text
    * @param   i_loc                       Hidrics location id
    * @param   i_location_ft               Location free text
    * @param   i_hid                       Hidrics id
    * @param   i_hid_ft                    Hidrics free text
    * @param   o_ft_way                    Way free text id
    * @param   o_ft_loc                    Location free text id
    * @param   o_ft_hid                    Hidrics free text id
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   01-07-2010
    */
    FUNCTION get_ft_ids
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_epis_hidrics      IN epis_hidrics_det.id_epis_hidrics%TYPE DEFAULT NULL,
        i_epis_hidrics_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE DEFAULT NULL,
        i_epis_hidrics_det  IN epis_hidrics_det.id_epis_hidrics_det%TYPE DEFAULT NULL,
        i_way               IN way.id_way%TYPE DEFAULT NULL,
        i_way_ft            IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_loc               IN hidrics_location.id_hidrics_location%TYPE DEFAULT NULL,
        i_location_ft       IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_hid               IN hidrics.id_hidrics%TYPE DEFAULT NULL,
        i_hid_ft            IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        o_ft_way            OUT table_number,
        o_ft_loc            OUT table_number,
        o_ft_hid            OUT table_number,
        o_ft_device         OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_FT_IDS';
    BEGIN
        g_error := 'GET ID_FT HID_WAY';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        IF (i_epis_hidrics_det IS NOT NULL)
        THEN
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  INTO o_ft_device
                  FROM epis_hidrics_det ehd
                  JOIN epis_hidrics_det_ftxt ft
                    ON ft.id_epis_hidrics_det_ftxt = ehd.id_epis_hid_ftxt_dev
                 WHERE ehd.id_epis_hidrics_det = i_epis_hidrics_det
                   AND ft.id_way IS NULL
                   AND ft.id_hidrics_location IS NULL
                   AND ft.id_hidrics IS NULL
                   AND ft.id_hidrics_charact IS NULL
                   AND ft.id_hidrics_device IS NOT NULL;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_device := NULL;
            END;
        END IF;
    
        IF i_epis_hidrics_line IS NULL
        THEN
            SELECT ft.id_epis_hidrics_det_ftxt
              BULK COLLECT
              INTO o_ft_way
              FROM epis_hidrics_line ehl
              JOIN epis_hidrics_det_ftxt ft
                ON ehl.id_epis_hid_ftxt_way = ft.id_epis_hidrics_det_ftxt
             WHERE ehl.id_epis_hidrics = i_epis_hidrics
               AND ft.id_way = i_way
               AND ft.id_hidrics_location IS NULL
               AND ft.id_hidrics IS NULL
               AND ft.id_hidrics_charact IS NULL
               AND ft.free_text = i_way_ft;
        ELSE
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  BULK COLLECT
                  INTO o_ft_way
                  FROM epis_hidrics_line ehl
                  JOIN epis_hidrics_det_ftxt ft
                    ON ehl.id_epis_hid_ftxt_way = ft.id_epis_hidrics_det_ftxt
                 WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line
                   AND ft.id_way = i_way
                   AND ft.id_hidrics_location IS NULL
                   AND ft.id_hidrics IS NULL
                   AND ft.id_hidrics_charact IS NULL;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_way := NULL;
            END;
        END IF;
    
        g_error := 'GET ID_FT LOC';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF i_epis_hidrics_line IS NULL
        THEN
            SELECT ft.id_epis_hidrics_det_ftxt
              BULK COLLECT
              INTO o_ft_loc
              FROM epis_hidrics_line ehl
              JOIN epis_hidrics_det_ftxt ft
                ON ehl.id_epis_hid_ftxt_loc = ft.id_epis_hidrics_det_ftxt
             WHERE ehl.id_epis_hidrics = i_epis_hidrics
               AND ft.id_way IS NULL
               AND ft.id_hidrics_location = i_loc
               AND ft.id_hidrics IS NULL
               AND ft.id_hidrics_charact IS NULL
               AND ft.free_text = i_location_ft;
        ELSE
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  BULK COLLECT
                  INTO o_ft_loc
                  FROM epis_hidrics_line ehl
                  JOIN epis_hidrics_det_ftxt ft
                    ON ehl.id_epis_hid_ftxt_loc = ft.id_epis_hidrics_det_ftxt
                 WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line
                   AND ft.id_way IS NULL
                   AND ft.id_hidrics_location IS NOT NULL
                   AND ft.id_hidrics IS NULL
                   AND ft.id_hidrics_charact IS NULL;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_loc := NULL;
            END;
        END IF;
    
        g_error := 'GET ID_FT HID';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF i_epis_hidrics_line IS NULL
        THEN
            SELECT ft.id_epis_hidrics_det_ftxt
              BULK COLLECT
              INTO o_ft_hid
              FROM epis_hidrics_line ehl
              JOIN epis_hidrics_det_ftxt ft
                ON ehl.id_epis_hid_ftxt_fluid = ft.id_epis_hidrics_det_ftxt
             WHERE ehl.id_epis_hidrics = i_epis_hidrics
               AND ft.id_way IS NULL
               AND ft.id_hidrics_location IS NULL
               AND ft.id_hidrics = i_hid
               AND ft.id_hidrics_charact IS NULL
               AND ft.free_text = i_hid_ft;
        ELSE
            BEGIN
                SELECT ft.id_epis_hidrics_det_ftxt
                  BULK COLLECT
                  INTO o_ft_hid
                  FROM epis_hidrics_line ehl
                  JOIN epis_hidrics_det_ftxt ft
                    ON ehl.id_epis_hid_ftxt_fluid = ft.id_epis_hidrics_det_ftxt
                 WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line
                   AND ft.id_way IS NULL
                   AND ft.id_hidrics_location IS NULL
                   AND ft.id_hidrics = i_hid
                   AND ft.id_hidrics_charact IS NULL;
            EXCEPTION
                WHEN no_data_found THEN
                    o_ft_hid := NULL;
            END;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_ft_ids;

    FUNCTION get_epis_hidrics_line_id
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics_det.id_epis_hidrics%TYPE DEFAULT NULL,
        i_way          IN way.id_way%TYPE DEFAULT NULL,
        i_way_ft       IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_loc          IN hidrics_location.id_hidrics_location%TYPE DEFAULT NULL,
        i_location_ft  IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_hid          IN hidrics.id_hidrics%TYPE DEFAULT NULL,
        i_hid_ft       IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL
    ) RETURN epis_hidrics_line.id_epis_hidrics_line%TYPE IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_LINE_ID';
        --
        l_epis_hid_line epis_hidrics_line.id_epis_hidrics_line%TYPE;
        l_ft_hid_way    table_number;
        l_ft_loc        table_number;
        l_ft_hid        table_number;
        l_ft_device     epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
        l_error         t_error_out;
    BEGIN
        g_error := 'GET FREE TEXT ID''s i_way: ' || i_way || ' i_way_ft: ' || i_way_ft || ' i_loc: ' || i_loc ||
                   ' i_location_ft: ' || i_location_ft || ' i_hid: ' || i_hid || ' i_hid_ft: ' || i_hid_ft;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT get_ft_ids(i_lang              => i_lang,
                          i_prof              => i_prof,
                          i_epis_hidrics      => i_epis_hidrics,
                          i_epis_hidrics_line => NULL,
                          i_way               => i_way,
                          i_way_ft            => i_way_ft,
                          i_loc               => i_loc,
                          i_location_ft       => i_location_ft,
                          i_hid               => i_hid,
                          i_hid_ft            => i_hid_ft,
                          o_ft_way            => l_ft_hid_way,
                          o_ft_loc            => l_ft_loc,
                          o_ft_hid            => l_ft_hid,
                          o_ft_device         => l_ft_device,
                          o_error             => l_error)
        THEN
            RAISE e_error;
        END IF;
    
        BEGIN
            g_error := 'GET ID_EPIS_HIDRICS_LINE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF (NOT l_ft_loc.exists(1))
            THEN
                g_error := 'l_ft_loc is null';
                pk_alertlog.log_debug(g_error);
                l_ft_loc := NULL;
            END IF;
        
            IF (NOT l_ft_hid.exists(1))
            THEN
                g_error := 'l_ft_hid is null';
                pk_alertlog.log_debug(g_error);
                l_ft_hid := NULL;
            END IF;
        
            IF (NOT l_ft_hid_way.exists(1))
            THEN
                g_error := 'l_ft_hid_way is null';
                pk_alertlog.log_debug(g_error);
                l_ft_hid_way := NULL;
            END IF;
        
            SELECT DISTINCT id_epis_hidrics_line
              INTO l_epis_hid_line
              FROM (
                    --there is a free text: way, fluid and/or location
                    SELECT ehl.id_epis_hidrics_line
                      FROM epis_hidrics_line ehl
                     WHERE ehl.id_epis_hidrics = i_epis_hidrics
                       AND ehl.id_way = i_way
                       AND nvl(ehl.id_hidrics_location, -99) =
                           nvl(decode(i_location_ft, NULL, decode(i_loc, NULL, NULL, i_loc), i_loc), -99)
                       AND ehl.id_hidrics = i_hid
                       AND ehl.flg_status = pk_inp_hidrics_constant.g_epis_hid_lin_status_a
                       AND NOT (l_ft_hid_way IS NULL AND l_ft_loc IS NULL AND l_ft_hid IS NULL)
                       AND ((l_ft_hid_way IS NULL AND ehl.id_epis_hid_ftxt_way IS NULL AND ehl.id_way = i_way) OR
                           (ehl.id_epis_hid_ftxt_way IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                           column_value
                                                            FROM TABLE(l_ft_hid_way) t1)))
                          
                       AND ((l_ft_hid IS NULL AND ehl.id_epis_hid_ftxt_fluid IS NULL AND ehl.id_hidrics = i_hid) OR
                           (ehl.id_epis_hid_ftxt_fluid IN (SELECT /*+opt_estimate(table,t3,scale_rows=0.0000001)*/
                                                             column_value
                                                              FROM TABLE(l_ft_hid) t3)))
                       AND ((l_ft_loc IS NULL AND ehl.id_epis_hid_ftxt_loc IS NULL AND
                           (ehl.id_hidrics_location = i_loc OR i_loc IS NULL)) OR
                           (ehl.id_epis_hid_ftxt_loc IN (SELECT /*+opt_estimate(table,t2,scale_rows=0.0000001)*/
                                                           column_value
                                                            FROM TABLE(l_ft_loc) t2)))
                    UNION
                    --there is not free text
                    SELECT ehl.id_epis_hidrics_line
                      FROM epis_hidrics_line ehl
                     WHERE ehl.id_epis_hidrics = i_epis_hidrics
                       AND ehl.id_way = i_way
                       AND nvl(ehl.id_hidrics_location, -99) =
                           nvl(decode(i_location_ft, NULL, decode(i_loc, NULL, NULL, i_loc), i_loc), -99)
                       AND ehl.id_hidrics = i_hid
                       AND l_ft_hid_way IS NULL
                       AND l_ft_loc IS NULL
                       AND l_ft_hid IS NULL
                       AND i_way NOT IN (SELECT a.id_way
                                           FROM way a
                                          WHERE a.flg_available = pk_alert_constant.g_yes
                                            AND a.flg_way_type = pk_inp_hidrics_constant.g_hid_way_type_o)
                       AND (nvl(i_loc, -99) != 0 OR i_location_ft IS NULL)
                       AND i_hid NOT IN (SELECT h.id_hidrics
                                           FROM hidrics h
                                          WHERE h.flg_available = pk_alert_constant.g_yes
                                            AND h.flg_free_txt = pk_alert_constant.g_yes));
        EXCEPTION
            WHEN no_data_found THEN
                l_epis_hid_line := NULL;
        END;
    
        RETURN l_epis_hid_line;
    END get_epis_hidrics_line_id;

    /**
    * Update the characterizations. To be used when it is edited a line.
    * If the existing characterizations are associated to the new selected option(way, hidrics)
    * the characterization remains active otherwise they are sent to history.
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hid_det              Epis_hidrics_det identifier    
    * @param   i_id_epis_hidrics           Epis_hidrics identifier
    * @param   i_id_way                    Way id
    * @param   i_id_hidrics                Hidrics id
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Sofia Mendes
    * @version v2.6.0.3
    * @since   10-Nov-2010
    */
    FUNCTION set_edit_characterization
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_epis_hid_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        i_epis_hid_line   IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_id_way          IN way.id_way%TYPE,
        i_id_hidrics      IN hidrics.id_hidrics%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'SET_EDIT_CHARACTERIZATION';
        --        
        l_inst               institution.id_institution%TYPE;
        l_soft               software.id_software%TYPE;
        l_department         department.id_department%TYPE;
        l_dept               dept.id_dept%TYPE;
        l_hid_char_avail     table_number;
        l_old_charact        table_number;
        l_characts_to_delete table_number;
        l_char_ids           VARCHAR2(4000 CHAR);
        l_aux_rows           table_varchar;
        l_id_market          market.id_market%TYPE;
    BEGIN
        g_error := 'GET CONF VARS - CHARACTERIZATIONS; i_id_episode: ' || i_id_episode;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => i_id_episode,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_c,
                             o_inst       => l_inst,
                             o_soft       => l_soft,
                             o_department => l_department,
                             o_dept       => l_dept,
                             o_id_market  => l_id_market,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        g_error := 'get all active characterizations of the epis_hidrics_Det: ' || i_id_epis_hid_det;
        pk_alertlog.log_debug(g_error);
        --get all active characterizations of the epis_hidrics_Det      
        SELECT ehdc.id_hidrics_charact
          BULK COLLECT
          INTO l_old_charact
          FROM epis_hidrics_det ehd
          JOIN epis_hidrics_det_charact ehdc
            ON ehdc.id_epis_hidrics_det = ehd.id_epis_hidrics_det
         WHERE ehd.id_epis_hidrics_det = i_id_epis_hid_det;
    
        g_error := 'get all characterizations for i_id_hidrics: ' || i_id_hidrics || ', i_id_way:' || i_id_hidrics ||
                   ', l_department: ' || l_department || ',l_dept: ' || l_dept || ', l_inst: ' || l_inst ||
                   ', id_market: ' || l_id_market;
        pk_alertlog.log_debug(g_error);
        -- get all the characterizations configured to the new selection that match the existing 
        -- characterizations associated to the epis_hidrics_det
        SELECT id_hidrics_charact
          BULK COLLECT
          INTO l_hid_char_avail
          FROM (SELECT DISTINCT hc.id_hidrics_charact
                  FROM hidrics_charact hc
                  JOIN hidrics_charact_rel hcr
                    ON hcr.id_hidrics_charact = hc.id_hidrics_charact
                 WHERE hc.flg_available = pk_alert_constant.g_yes
                   AND hc.id_hidrics_charact != 0
                   AND hcr.flg_available = pk_alert_constant.g_yes
                   AND hcr.id_department = l_department
                   AND hcr.id_dept = l_dept
                   AND hcr.id_market = l_id_market
                   AND hcr.id_institution = l_inst
                   AND (hcr.id_hidrics = i_id_hidrics OR i_id_hidrics < 0)
                   AND (hcr.id_way = i_id_way OR i_id_way = 0)
                UNION ALL
                SELECT 0 id_hidrics_charact
                  FROM dual) t
         WHERE t.id_hidrics_charact IN (SELECT /*+opt_estimate (table t rows=0.00001)*/
                                         column_value
                                          FROM TABLE(l_old_charact) t);
    
        IF l_hid_char_avail.count <> l_old_charact.count
        THEN
        
            SELECT column_value
              BULK COLLECT
              INTO l_characts_to_delete
              FROM (SELECT column_value
                    
                      FROM TABLE(l_old_charact)
                    MINUS
                    SELECT column_value
                      FROM TABLE(l_hid_char_avail));
        
            g_error := 'SEND TO HIST ID_EPIS_HIDRICS_DET: ' || i_id_epis_hid_det;
            pk_alertlog.log_debug(g_error);
            set_epis_hid_char_hist(i_epis_hidrics_det => i_id_epis_hid_det);
        
            FOR i IN 1 .. l_characts_to_delete.count
            LOOP
                l_char_ids := l_char_ids || CASE
                                  WHEN i > 1 THEN
                                   ','
                              END || l_characts_to_delete(i);
            END LOOP;
        
            IF (l_characts_to_delete IS NOT NULL AND l_characts_to_delete.exists(1))
            THEN
                g_error := 'DELETE ALL CHARACTERIZATIONS. ID_EPIS_HIDRICS_DET: ' || i_id_epis_hid_det;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                ts_epis_hidrics_det_charact.del_by(where_clause_in => 'ID_EPIS_HIDRICS_DET = ' || i_id_epis_hid_det ||
                                                                      ' AND ID_HIDRICS_CHARACT IN (' || l_char_ids || ')');
            
                g_error := 'UPDATE REC';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
            
                ts_epis_hidrics_det_charact.upd(dt_eh_det_charact_in => g_sysdate_tstz,
                                                where_in             => 'id_epis_hidrics_det = ' || i_id_epis_hid_det,
                                                rows_out             => l_aux_rows);
            
                FOR rec IN (SELECT ehc.id_epis_hid_collector
                              FROM epis_hid_collector ehc
                             WHERE ehc.id_epis_hidrics_line = i_epis_hid_line)
                LOOP
                
                    g_error := 'SEND TO HIST ID_EPIS_HID_COLLECTOR: ' || rec.id_epis_hid_collector;
                    pk_alertlog.log_debug(g_error);
                    set_epis_hid_col_hist(i_epis_hid_collector => rec.id_epis_hid_collector);
                END LOOP;
            
                g_error := 'SEND ts_epis_hid_collector for id_epis_hidrics_line: ' || i_epis_hid_line;
                pk_alertlog.log_debug(g_error);
                ts_epis_hid_collector.upd(dt_epis_hid_collector_in => g_sysdate_tstz,
                                          where_in                 => 'id_epis_hidrics_line = ' || i_epis_hid_line,
                                          rows_out                 => l_aux_rows);
            
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS_DET ' || i_id_epis_hid_det;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_det_hist(i_epis_hidrics_det => i_id_epis_hid_det);
                --                
                g_error := 'UPDATE REC';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                ts_epis_hidrics_det.upd(id_epis_hidrics_det_in => i_id_epis_hid_det,
                                        dt_epis_hidrics_det_in => g_sysdate_tstz,
                                        rows_out               => l_aux_rows);
            END IF;
        END IF;
    
        --if so, keep it
        --hotherwise send it to the history (set_characterization)
    
        RETURN TRUE;
    END set_edit_characterization;

    /*******************************************************************************************************************************************
    * SET_FREE_TEXT                   Inserts a new free text record (related to a way, fluid, body part, characteristic or device)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE that should be associated with current request
    * @param i_id_way                 Way Id
    * @param i_way_ft                 Way free text. 
    *                                 The i_way_id and i_way_ft should not be null if it desirable to create a new way free text
    * @param i_hidrics_location       Hidrics_location Id
    * @param i_location_ft            Body part free text. 
    *                                 The i_hidrics_location and i_location_ft should not be null if it desirable to create a new way free text
    * @param i_id_hidrics             Hidrics Id
    * @param i_hidrics_ft             Hidrics free text. 
    *                                 The i_id_hidrics and i_hidrics_ft should not be null if it desirable to create a new way free text
    * @param i_id_hidrics_device      Device Id
    * @param i_device_ft              Device free text. 
    *                                 The i_id_hidrics_device and i_device_ft should not be null if it desirable to create a new way free text
    * @param i_hidrics_charact        Characteristic Id
    * @param i_charact_ft             Characteristic free text. 
    *                                 The i_hidrics_charact and i_charact_ft should not be null if it desirable to create a new way free text    
    * @param o_ft_way                 Way created free text id (or free text id that had already been created)
    * @param o_ft_loc                 Body part created free text id (or free text id that had already been created)
    * @param o_ft_hid                 Fluid created free text id (or free text id that had already been created)
    * @param o_ft_device              Device created free text id (or free text id that had already been created)
    * @param o_ft_charact             Characteristic created free text id (or free text id that had already been created) 
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR    
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic erro "OTHERS"
    * 
    * @author                         Sofia Mendes
    * @version                        2.6.1.1
    * @since                          16-Jun-2011
    *******************************************************************************************************************************************/

    FUNCTION set_free_text
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_episode        IN episode.id_episode%TYPE,
        i_id_way            IN way.id_way%TYPE,
        i_way_ft            IN epis_hidrics_det_ftxt.free_text%TYPE,
        i_hidrics_location  IN hidrics_location.id_hidrics_location%TYPE,
        i_location_ft       IN epis_hidrics_det_ftxt.free_text%TYPE,
        i_id_hidrics        IN hidrics.id_hidrics%TYPE,
        i_hidrics_ft        IN epis_hidrics_det_ftxt.free_text%TYPE,
        i_id_hidrics_device IN hidrics_device.id_hidrics_device%TYPE,
        i_device_ft         IN epis_hidrics_det_ftxt.free_text%TYPE,
        i_hidrics_charact   IN hidrics_charact.id_hidrics_charact%TYPE,
        i_charact_ft        IN epis_hidrics_det_ftxt.free_text%TYPE,
        o_ft_way            OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_ft_loc            OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_ft_hid            OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_ft_device         OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_ft_charact        OUT epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'SET_FREE_TEXT';
        --            
        l_id_patient episode.id_patient%TYPE;
    BEGIN
        g_error := 'GET CUR FT ID''s';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        g_error := 'CALL pk_episode.get_epis_patient. id_episode: ' || i_id_episode;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_id_patient := pk_episode.get_epis_patient(i_lang => i_lang, i_prof => i_prof, i_episode => i_id_episode);
    
        IF NOT get_ft_ids(i_lang            => i_lang,
                          i_prof            => i_prof,
                          i_id_patient      => l_id_patient,
                          i_way             => i_id_way,
                          i_way_ft          => i_way_ft,
                          i_loc             => i_hidrics_location,
                          i_location_ft     => i_location_ft,
                          i_hid             => i_id_hidrics,
                          i_hid_ft          => i_hidrics_ft,
                          i_device          => i_id_hidrics_device,
                          i_device_ft       => i_device_ft,
                          i_hidrics_charact => i_hidrics_charact,
                          i_charact_ft      => i_charact_ft,
                          o_ft_way          => o_ft_way,
                          o_ft_loc          => o_ft_loc,
                          o_ft_hid          => o_ft_hid,
                          o_ft_device       => o_ft_device,
                          o_ft_charact      => o_ft_charact,
                          o_error           => o_error)
        THEN
            RAISE e_error;
        END IF;
    
        IF i_way_ft IS NOT NULL
           AND o_ft_way IS NULL
        THEN
            o_ft_way := ts_epis_hidrics_det_ftxt.next_key;
        
            g_error := 'INSERT HIDRICS WAY FREE TEXT';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            ts_epis_hidrics_det_ftxt.ins(id_epis_hidrics_det_ftxt_in => o_ft_way,
                                         id_way_in                   => i_id_way,
                                         free_text_in                => i_way_ft,
                                         id_prof_last_change_in      => i_prof.id,
                                         id_patient_in               => l_id_patient,
                                         dt_eh_det_ftxt_in           => g_sysdate_tstz);
        END IF;
    
        IF i_location_ft IS NOT NULL
           AND o_ft_loc IS NULL
        THEN
            o_ft_loc := ts_epis_hidrics_det_ftxt.next_key;
        
            g_error := 'INSERT LOCATION FREE TEXT';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            ts_epis_hidrics_det_ftxt.ins(id_epis_hidrics_det_ftxt_in => o_ft_loc,
                                         id_hidrics_location_in      => i_hidrics_location,
                                         free_text_in                => i_location_ft,
                                         id_prof_last_change_in      => i_prof.id,
                                         id_patient_in               => l_id_patient,
                                         dt_eh_det_ftxt_in           => g_sysdate_tstz);
        END IF;
    
        IF i_hidrics_ft IS NOT NULL
           AND o_ft_hid IS NULL
        THEN
            o_ft_hid := ts_epis_hidrics_det_ftxt.next_key;
        
            g_error := 'INSERT HIDRICS FREE TEXT';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            ts_epis_hidrics_det_ftxt.ins(id_epis_hidrics_det_ftxt_in => o_ft_hid,
                                         id_hidrics_in               => i_id_hidrics,
                                         free_text_in                => i_hidrics_ft,
                                         id_prof_last_change_in      => i_prof.id,
                                         id_patient_in               => l_id_patient,
                                         dt_eh_det_ftxt_in           => g_sysdate_tstz);
        END IF;
    
        IF i_device_ft IS NOT NULL
           AND o_ft_device IS NULL
        THEN
            o_ft_device := ts_epis_hidrics_det_ftxt.next_key;
        
            g_error := 'INSERT HIDRICS FREE TEXT';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            ts_epis_hidrics_det_ftxt.ins(id_epis_hidrics_det_ftxt_in => o_ft_device,
                                         id_hidrics_device_in        => i_id_hidrics_device,
                                         free_text_in                => i_device_ft,
                                         id_prof_last_change_in      => i_prof.id,
                                         id_patient_in               => l_id_patient,
                                         dt_eh_det_ftxt_in           => g_sysdate_tstz);
        END IF;
    
        IF i_charact_ft IS NOT NULL
           AND o_ft_charact IS NULL
        THEN
            o_ft_charact := ts_epis_hidrics_det_ftxt.next_key;
        
            g_error := 'INSERT HIDRICS CHARACT FREE TEXT';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            ts_epis_hidrics_det_ftxt.ins(id_epis_hidrics_det_ftxt_in => o_ft_charact,
                                         id_hidrics_charact_in       => i_hidrics_charact,
                                         free_text_in                => i_charact_ft,
                                         id_prof_last_change_in      => i_prof.id,
                                         id_patient_in               => l_id_patient,
                                         dt_eh_det_ftxt_in           => g_sysdate_tstz);
        
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'SET_FREE_TEXT',
                                              o_error    => o_error);
            RETURN FALSE;
        
    END set_free_text;

    /**
    * Add/Update detail information for a list of records (intakes and /or outputs)
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_data                      Epis hidrics det data
    * @param   o_epis_hid_det              Epis hidrics det id
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Sofia Mendes
    * @version v2.6.3.8
    * @since   09-09-2013
    */
    FUNCTION set_epis_hid_det_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_data         IN table_clob,
        o_epis_hid_det OUT table_number,
        o_flg_show     OUT VARCHAR2,
        o_msg_title    OUT VARCHAR2,
        o_msg          OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name         VARCHAR2(30 CHAR) := 'SET_EPIS_HIDRICS_DET';
        l_count             PLS_INTEGER;
        l_epis_hid_det      epis_hidrics_det.id_epis_hidrics_det%TYPE;
        l_epis_hidrics_line epis_hidrics_line.id_epis_hidrics_line%TYPE;
        l_epis_hidrics      epis_hidrics.id_epis_hidrics%TYPE;
    
        l_epis_hid_lines table_number;
    
    BEGIN
        IF (i_data IS NOT NULL AND i_data.exists(1))
        THEN
            l_count := i_data.count;
        
            o_epis_hid_det   := table_number();
            l_epis_hid_lines := table_number();
        
            FOR i IN 1 .. l_count
            LOOP
                g_error := 'CALL set_epis_hidrics_det';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                IF NOT set_epis_hidrics_det(i_lang              => i_lang,
                                            i_prof              => i_prof,
                                            i_data              => i_data(i),
                                            o_epis_hid_det      => l_epis_hid_det,
                                            o_epis_hidrics_line => l_epis_hidrics_line,
                                            o_epis_hidrics      => l_epis_hidrics,
                                            o_flg_show          => o_flg_show,
                                            o_msg_title         => o_msg_title,
                                            o_msg               => o_msg,
                                            o_error             => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                o_epis_hid_det.extend;
                o_epis_hid_det(o_epis_hid_det.last) := l_epis_hid_det;
            
                l_epis_hid_lines.extend;
                l_epis_hid_lines(l_epis_hid_lines.last) := l_epis_hidrics_line;
            END LOOP;
        
            IF (l_count > 1)
            THEN
                --irrigations saves the intake and the output at the same time
                g_error := 'CALL pk_inp_hidrics_groups.set_irrigations_group';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                IF NOT pk_inp_hidrics_groups.set_irrigation_group(i_lang                  => i_lang,
                                                                  i_prof                  => i_prof,
                                                                  i_epis_hidrics          => l_epis_hidrics,
                                                                  i_epis_hidrics_line     => l_epis_hid_lines,
                                                                  i_id_epis_hidrics_group => NULL,
                                                                  o_error                 => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_exception THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_epis_hid_det_list;

    /**
    * Add/Update detail information
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_data                      Epis hidrics det data
    * @param   o_epis_hid_det              Epis hidrics det id
    * @param   o_epis_hidrics_line         Epis hidrics line id
    * @param   o_epis_hidrics              Epis hidrics id
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   27-05-2010
    */
    FUNCTION set_epis_hidrics_det
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_data              IN CLOB,
        o_epis_hid_det      OUT epis_hidrics_det.id_epis_hidrics_det%TYPE,
        o_epis_hidrics_line OUT epis_hidrics_line.id_epis_hidrics_line%TYPE,
        o_epis_hidrics      OUT epis_hidrics.id_epis_hidrics%TYPE,
        o_flg_show          OUT VARCHAR2,
        o_msg_title         OUT VARCHAR2,
        o_msg               OUT VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'SET_EPIS_HIDRICS_DET';
        --
        l_epis_hid_det      rec_epis_hidrics_det;
        l_epis_h_bal        epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_hid_chars         tab_hidrics_charact;
        l_hidrics_location  hidrics_location.id_hidrics_location%TYPE;
        l_epis_hidrics_coll epis_hid_collector.id_epis_hid_collector%TYPE;
        l_id_episode        episode.id_episode%TYPE;
        --
        t_ti_log_ins_exception EXCEPTION;
        l_action_message sys_message.desc_message%TYPE;
        l_error_code     sys_message.code_message%TYPE;
        l_error_message  sys_message.desc_message%TYPE;
        l_invalid_status EXCEPTION;
        --
        e_error_dup_line        EXCEPTION;
        e_edit_characterization EXCEPTION;
        e_duplicated_value      EXCEPTION;
        e_free_text_error       EXCEPTION;
        --   
        PROCEDURE extract_ehd_from_xml
        (
            i_data      IN CLOB,
            o_eh_det    OUT rec_epis_hidrics_det,
            o_hid_chars OUT tab_hidrics_charact
        ) IS
            l_proc_name VARCHAR2(30 CHAR) := 'EXTRACT_EPIS_HIDRICS_DET';
        BEGIN
            g_error := 'EXTRACT EPIS_HIDRICS_DET FIELS: ' || i_data;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            SELECT a.id_epis_hidrics_det,
                   a.id_epis_hidrics_line,
                   a.id_epis_hidrics,
                   a.id_epis_hidrics_balance,
                   a.id_way,
                   a.way_ft,
                   a.id_body_part,
                   a.id_body_side,
                   a.location_ft,
                   a.id_hidrics,
                   a.hidrics_ft,
                   pk_date_utils.get_string_tstz(i_lang, i_prof, a.dt_record, NULL),
                   a.value_hidrics,
                   a.flg_type,
                   a.notes,
                   a.flg_level_control,
                   a.curr_level,
                   a.restart_level,
                   a.flg_edit_type,
                   a.nr_times,
                   a.id_hidrics_device,
                   a.device_ft
              INTO o_eh_det
              FROM xmltable('/INP' passing xmltype(i_data) --
                            columns -- 
                            "ID_EPIS_HIDRICS_DET" NUMBER(24) path 'EH_DET',
                            "ID_EPIS_HIDRICS_LINE" NUMBER(24) path 'EH_LIN',
                            "ID_EPIS_HIDRICS" NUMBER(24) path 'EH',
                            "ID_EPIS_HIDRICS_BALANCE" NUMBER(24) path 'EHB',
                            "ID_WAY" NUMBER(24) path 'HW',
                            "WAY_FT" VARCHAR2(1000 CHAR) path 'HW_FT',
                            "ID_BODY_PART" NUMBER(24) path 'BDY_PRT',
                            "ID_BODY_SIDE" NUMBER(24) path 'BDY_SD',
                            "LOCATION_FT" VARCHAR2(1000 CHAR) path 'LOC_FT',
                            "ID_HIDRICS" NUMBER(24) path 'HID',
                            "HIDRICS_FT" VARCHAR2(1000 CHAR) path 'HID_FT',
                            "DT_RECORD" VARCHAR2(24 CHAR) path 'DT',
                            "VALUE_HIDRICS" NUMBER(26, 2) path 'VAL',
                            "FLG_TYPE" VARCHAR2(1 CHAR) path 'FLG_TYP',
                            "NOTES" VARCHAR2(200 CHAR) path 'NOTES',
                            "FLG_LEVEL_CONTROL" VARCHAR2(1 CHAR) path 'LVL_CRL',
                            "CURR_LEVEL" NUMBER(24) path 'LVL',
                            "RESTART_LEVEL" VARCHAR2(1 CHAR) path 'RST',
                            "FLG_EDIT_TYPE" VARCHAR2(1 CHAR) path 'EDT_TYP',
                            "NR_TIMES" NUMBER(24) path 'NTIMES',
                            "ID_HIDRICS_DEVICE" NUMBER(24) path 'HDEV',
                            "DEVICE_FT" VARCHAR2(1000 CHAR) path 'HDEV_FT') a;
        
            g_error := 'EXTRACT HIDRICS_CHARACT TABLE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            SELECT a.id_hidrics_charact, a.hidrics_charact_ft
              BULK COLLECT
              INTO o_hid_chars
              FROM xmltable('/INP/HID_CHARS/HID_CHAR' passing xmltype(i_data) --
                            columns --
                            "ID_HIDRICS_CHARACT" NUMBER(24) path 'HC',
                            "HIDRICS_CHARACT_FT" VARCHAR2(1000 CHAR) path 'HC_FT') a;
        END extract_ehd_from_xml;
    
        PROCEDURE insert_into_ti_log IS
            l_proc_name VARCHAR2(30 CHAR) := 'INSERT_INTO_TI_LOG';
            --
            l_episode     epis_hidrics.id_episode%TYPE;
            l_flg_ti_type hidrics_type.flg_ti_type%TYPE;
            l_ht_acronym  hidrics_type.acronym%TYPE;
        BEGIN
            g_error := 'GET DATA';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            SELECT ht.flg_ti_type, ht.acronym, eh.id_episode
              INTO l_flg_ti_type, l_ht_acronym, l_episode
              FROM epis_hidrics eh
              JOIN hidrics_type ht
                ON ht.id_hidrics_type = eh.id_hidrics_type
             WHERE eh.id_epis_hidrics = l_epis_hid_det.id_epis_hidrics;
        
            g_error := 'CALL T_TI_LOG.INS_LOG';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            -- writting into the status log
            IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                     i_prof       => i_prof,
                                     i_id_episode => l_episode,
                                     i_flg_status => pk_inp_hidrics_constant.g_epis_hidric_e,
                                     i_id_record  => l_epis_hid_det.id_epis_hidrics,
                                     i_flg_type   => l_flg_ti_type,
                                     o_error      => o_error))
            THEN
                RAISE t_ti_log_ins_exception;
            END IF;
        END insert_into_ti_log;
    
        PROCEDURE initialize_epis_hidrics IS
            l_proc_name VARCHAR2(30 CHAR) := 'INITIALIZE_EPIS_HIDRICS';
            --
            l_char_eh     VARCHAR2(1 CHAR);
            l_found       BOOLEAN;
            l_dt_open     TIMESTAMP WITH LOCAL TIME ZONE;
            l_dt_exec     VARCHAR2(24 CHAR);
            l_dt_exec_str VARCHAR2(200 CHAR);
            l_dt_init     epis_hidrics.dt_initial_tstz%TYPE;
            l_rowids      table_varchar := table_varchar();
            l_rowids_b    table_varchar := table_varchar();
            CURSOR c_epis_hid_det IS
                SELECT 'X'
                  FROM epis_hidrics_det
                 WHERE id_epis_hidrics = l_epis_hid_det.id_epis_hidrics;
        
            CURSOR c_epis_hid IS
                SELECT eh.dt_initial_tstz
                  FROM epis_hidrics eh, hidrics_interval hi
                 WHERE eh.id_epis_hidrics = l_epis_hid_det.id_epis_hidrics
                   AND eh.id_hidrics_interval = hi.id_hidrics_interval;
        BEGIN
            g_error := 'OPEN C_EPIS_HID_DET';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            OPEN c_epis_hid_det;
            FETCH c_epis_hid_det
                INTO l_char_eh;
            l_found := c_epis_hid_det%FOUND;
            CLOSE c_epis_hid_det;
        
            IF NOT l_found
            THEN
                l_dt_exec     := pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                             i_date => l_epis_hid_det.dt_record,
                                                             i_prof => i_prof);
                l_dt_exec_str := 'pk_date_utils.get_string_tstz(' || i_lang || --
                                 ', profissional(' || i_prof.id || ', ' || i_prof.institution || ', ' ||
                                 i_prof.software || '), ''' || --
                                 l_dt_exec || ''', NULL)';
            
                g_error := 'OPEN C_EPIS_HID';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                OPEN c_epis_hid;
                FETCH c_epis_hid
                    INTO l_dt_init;
                CLOSE c_epis_hid;
            
                -- Compare dates to initialize first balance
                IF pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                   i_date1 => l_epis_hid_det.dt_record,
                                                   i_date2 => l_dt_init) = 'G'
                THEN
                    l_dt_open := nvl(l_dt_init, l_epis_hid_det.dt_record);
                ELSE
                    l_dt_open := nvl(l_epis_hid_det.dt_record, l_dt_init);
                END IF;
            
                -- 
                --
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS_BALANCE ' || l_epis_h_bal;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_bal_hist(i_epis_hidrics_balance => l_epis_h_bal);
                --
                g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD WITH ID_EPIS_HIDRICS(1) = ' ||
                           l_epis_hid_det.id_epis_hidrics;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
            
                ts_epis_hidrics_balance.upd(id_epis_hidrics_balance_in => l_epis_h_bal,
                                            flg_status_in              => pk_inp_hidrics_constant.g_epis_hid_balance_e,
                                            id_prof_last_change_in     => i_prof.id,
                                            dt_eh_balance_in           => g_sysdate_tstz,
                                            rows_out                   => l_rowids_b);
                --
                g_error := 'SEND TO HIST - EPIS_HIDRICS i_where: id_epis_hidrics = ' || l_epis_hid_det.id_epis_hidrics ||
                           ' AND ((' || l_dt_exec_str || ' < dt_initial_tstz) OR (flg_status = ''' ||
                           pk_inp_hidrics_constant.g_epis_hidric_r || '''))';
                pk_alertlog.log_debug(g_error);
                set_epis_hid_hist(i_where => 'id_epis_hidrics = ' || l_epis_hid_det.id_epis_hidrics || ' AND ((' ||
                                             l_dt_exec_str || ' < dt_initial_tstz) OR (flg_status = ''' ||
                                             pk_inp_hidrics_constant.g_epis_hidric_r || '''))');
                -- 
                g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS(1) = ' || l_epis_hid_det.id_epis_hidrics;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
            
                ts_epis_hidrics.upd(dt_initial_tstz_in     => l_dt_open,
                                    id_prof_last_change_in => i_prof.id,
                                    dt_epis_hidrics_in     => g_sysdate_tstz,
                                    where_in               => 'id_epis_hidrics = ' || l_epis_hid_det.id_epis_hidrics || -- 
                                                              ' AND ' || l_dt_exec_str || ' < dt_initial_tstz',
                                    rows_out               => l_rowids);
            
                g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS(2) = ' || l_epis_hid_det.id_epis_hidrics;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
            
                ts_epis_hidrics.upd(flg_status_in          => pk_inp_hidrics_constant.g_epis_hidric_e,
                                    flg_action_in          => pk_inp_hidrics_constant.g_epis_hidric_e,
                                    id_prof_last_change_in => i_prof.id,
                                    dt_epis_hidrics_in     => g_sysdate_tstz,
                                    where_in               => 'id_epis_hidrics = ' || l_epis_hid_det.id_epis_hidrics || --
                                                              ' AND flg_status = ''' ||
                                                              pk_inp_hidrics_constant.g_epis_hidric_r || '''',
                                    rows_out               => l_rowids);
            
                g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS(1) ' || l_epis_hid_det.id_epis_hidrics;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
            
                t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
                t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids_b, o_error);
            
                insert_into_ti_log;
            END IF;
        END initialize_epis_hidrics;
    
        PROCEDURE set_characterization(i_epis_hid_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE) IS
            l_proc_name VARCHAR2(30 CHAR) := 'INSERT_CHARACTERIZATION';
            --
            l_count_chars PLS_INTEGER;
            l_count_ehd   PLS_INTEGER;
            l_ft_way      epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
        
            l_ft_loc     epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_hid     epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_device  epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_charact epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
        BEGIN
            g_error := 'VERIFY IF IS TO SEND TO HIST ID_EPIS_HIDRICS_DET: ' || i_epis_hid_det;
            pk_alertlog.log_debug(g_error);
            SELECT COUNT(*)
              INTO l_count_ehd
              FROM epis_hidrics_det_charact ehd
             WHERE ehd.id_epis_hidrics_det = i_epis_hid_det;
        
            IF l_count_ehd > 0
            THEN
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS_DET: ' || i_epis_hid_det;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_char_hist(i_epis_hidrics_det => i_epis_hid_det);
            
                g_error := 'DELETE ALL CHARACTERIZATIONS. ID_EPIS_HIDRICS_DET: ' || i_epis_hid_det;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                ts_epis_hidrics_det_charact.del_by(where_clause_in => 'ID_EPIS_HIDRICS_DET = ' || i_epis_hid_det);
            END IF;
        
            g_error := 'INSERT CHARACTERIZATIONS DATA';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
        
            l_count_chars := l_hid_chars.first;
            <<insert_characterizations>>
            WHILE l_count_chars IS NOT NULL
            LOOP
                IF NOT set_free_text(i_lang              => i_lang,
                                     i_prof              => i_prof,
                                     i_id_episode        => l_id_episode,
                                     i_id_way            => NULL,
                                     i_way_ft            => NULL,
                                     i_hidrics_location  => NULL,
                                     i_location_ft       => NULL,
                                     i_id_hidrics        => NULL,
                                     i_hidrics_ft        => NULL,
                                     i_id_hidrics_device => NULL,
                                     i_device_ft         => NULL,
                                     i_hidrics_charact   => l_hid_chars(l_count_chars).id_hidrics_charact,
                                     i_charact_ft        => l_hid_chars(l_count_chars).hidrics_charact_ft,
                                     o_ft_way            => l_ft_way,
                                     o_ft_loc            => l_ft_loc,
                                     o_ft_hid            => l_ft_hid,
                                     o_ft_device         => l_ft_device,
                                     o_ft_charact        => l_ft_charact,
                                     o_error             => o_error)
                THEN
                    RAISE e_free_text_error;
                END IF;
            
                g_error := 'INSERT INTO EPIS_HIDRICS_DET_CHARACT';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                ts_epis_hidrics_det_charact.ins(id_epis_hidrics_det_in   => i_epis_hid_det,
                                                id_hidrics_charact_in    => l_hid_chars(l_count_chars).id_hidrics_charact,
                                                id_prof_last_change_in   => i_prof.id,
                                                dt_eh_det_charact_in     => g_sysdate_tstz,
                                                id_epis_hid_ftxt_char_in => l_ft_charact);
            
                l_count_chars := l_hid_chars.next(l_count_chars);
            END LOOP insert_characterizations;
        END set_characterization;
    
        FUNCTION set_epis_hid_line(i_epis_hid_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE DEFAULT NULL)
            RETURN epis_hidrics_line.id_epis_hidrics_line%TYPE IS
            l_func_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_LINE';
            --
            l_epis_hid_line     epis_hidrics_line.id_epis_hidrics_line%TYPE;
            l_tst_epis_hid_line epis_hidrics_line.id_epis_hidrics_line%TYPE;
            l_aux_rows          table_varchar;
            l_ft_way            epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_loc            epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_hid            epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_device         epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_charact        epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_internal_error EXCEPTION;
        BEGIN
            g_error := 'VERIFY IF ID_EPIS_HID_LINE EXISTS';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF i_epis_hid_line IS NULL
            THEN
                g_error := 'GET FREE TEXT ID''s';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                --when creating a new group it is necessary to create a new line
                l_epis_hid_line := get_epis_hidrics_line_id(i_lang         => i_lang,
                                                            i_prof         => i_prof,
                                                            i_epis_hidrics => l_epis_hid_det.id_epis_hidrics,
                                                            i_way          => l_epis_hid_det.id_way,
                                                            i_way_ft       => l_epis_hid_det.way_ft,
                                                            i_loc          => l_hidrics_location,
                                                            i_location_ft  => l_epis_hid_det.location_ft,
                                                            i_hid          => l_epis_hid_det.id_hidrics,
                                                            i_hid_ft       => l_epis_hid_det.hidrics_ft);
            
                g_error := 'l_epis_hid_line: ' || l_epis_hid_line;
                alertlog.pk_alertlog.log_debug(g_error);
            ELSE
                l_epis_hid_line := i_epis_hid_line;
            
                l_tst_epis_hid_line := get_epis_hidrics_line_id(i_lang         => i_lang,
                                                                i_prof         => i_prof,
                                                                i_epis_hidrics => l_epis_hid_det.id_epis_hidrics,
                                                                i_way          => l_epis_hid_det.id_way,
                                                                i_way_ft       => l_epis_hid_det.way_ft,
                                                                i_loc          => l_hidrics_location,
                                                                i_location_ft  => l_epis_hid_det.location_ft,
                                                                i_hid          => l_epis_hid_det.id_hidrics,
                                                                i_hid_ft       => l_epis_hid_det.hidrics_ft);
            
                IF l_tst_epis_hid_line IS NOT NULL
                   AND l_epis_hid_line != l_tst_epis_hid_line
                THEN
                    RAISE e_error_dup_line;
                END IF;
            END IF;
        
            IF l_epis_hid_line IS NULL
            THEN
                g_error := 'GET NEW ID';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                l_epis_hid_line := ts_epis_hidrics_line.next_key;
            
                --insert free texts: if thery are used and they were not created yet for the current patient
                g_error := 'CALL SET_FREE_TEXT';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                IF NOT set_free_text(i_lang              => i_lang,
                                     i_prof              => i_prof,
                                     i_id_episode        => l_id_episode,
                                     i_id_way            => l_epis_hid_det.id_way,
                                     i_way_ft            => l_epis_hid_det.way_ft,
                                     i_hidrics_location  => l_hidrics_location,
                                     i_location_ft       => l_epis_hid_det.location_ft,
                                     i_id_hidrics        => l_epis_hid_det.id_hidrics,
                                     i_hidrics_ft        => l_epis_hid_det.hidrics_ft,
                                     i_id_hidrics_device => NULL,
                                     i_device_ft         => NULL,
                                     i_hidrics_charact   => NULL,
                                     i_charact_ft        => NULL,
                                     o_ft_way            => l_ft_way,
                                     o_ft_loc            => l_ft_loc,
                                     o_ft_hid            => l_ft_hid,
                                     o_ft_device         => l_ft_device,
                                     o_ft_charact        => l_ft_charact,
                                     o_error             => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            
                g_error := 'INSERT REC';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                ts_epis_hidrics_line.ins(id_epis_hidrics_line_in   => l_epis_hid_line,
                                         id_epis_hidrics_in        => l_epis_hid_det.id_epis_hidrics,
                                         id_hidrics_in             => l_epis_hid_det.id_hidrics,
                                         id_way_in                 => l_epis_hid_det.id_way,
                                         id_hidrics_location_in    => l_hidrics_location,
                                         flg_status_in             => pk_inp_hidrics_constant.g_epis_hid_lin_status_a,
                                         dt_creation_in            => g_sysdate_tstz,
                                         id_prof_last_change_in    => i_prof.id,
                                         dt_epis_hidrics_line_in   => g_sysdate_tstz,
                                         flg_action_in             => pk_inp_hidrics_constant.g_flg_action_a,
                                         id_epis_hid_ftxt_way_in   => l_ft_way,
                                         id_epis_hid_ftxt_fluid_in => l_ft_hid,
                                         id_epis_hid_ftxt_loc_in   => l_ft_loc,
                                         rows_out                  => l_aux_rows);
            ELSIF l_epis_hid_det.flg_edit_type = g_ehd_edt_typ_l
            THEN
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS_LINE ' || l_epis_hid_line;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_line_hist(i_epis_hidrics_line => l_epis_hid_line);
            
                --insert free texts: if thery are used and they were not created yet for the current patient
                g_error := 'CALL SET_FREE_TEXT';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                IF NOT set_free_text(i_lang              => i_lang,
                                     i_prof              => i_prof,
                                     i_id_episode        => l_id_episode,
                                     i_id_way            => l_epis_hid_det.id_way,
                                     i_way_ft            => l_epis_hid_det.way_ft,
                                     i_hidrics_location  => l_hidrics_location,
                                     i_location_ft       => l_epis_hid_det.location_ft,
                                     i_id_hidrics        => l_epis_hid_det.id_hidrics,
                                     i_hidrics_ft        => l_epis_hid_det.hidrics_ft,
                                     i_id_hidrics_device => NULL,
                                     i_device_ft         => NULL,
                                     i_hidrics_charact   => NULL,
                                     i_charact_ft        => NULL,
                                     o_ft_way            => l_ft_way,
                                     o_ft_loc            => l_ft_loc,
                                     o_ft_hid            => l_ft_hid,
                                     o_ft_device         => l_ft_device,
                                     o_ft_charact        => l_ft_charact,
                                     o_error             => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
                --
                g_error := 'UPD REC';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                ts_epis_hidrics_line.upd(id_epis_hidrics_line_in    => l_epis_hid_line,
                                         id_epis_hidrics_in         => l_epis_hid_det.id_epis_hidrics,
                                         id_hidrics_in              => l_epis_hid_det.id_hidrics,
                                         id_way_in                  => l_epis_hid_det.id_way,
                                         id_hidrics_location_in     => l_hidrics_location,
                                         id_hidrics_location_nin    => FALSE,
                                         flg_status_in              => pk_inp_hidrics_constant.g_epis_hid_lin_status_a,
                                         dt_creation_in             => g_sysdate_tstz,
                                         id_prof_cancel_in          => NULL,
                                         id_prof_cancel_nin         => FALSE,
                                         id_cancel_reason_in        => NULL,
                                         id_cancel_reason_nin       => FALSE,
                                         notes_cancel_in            => NULL,
                                         notes_cancel_nin           => FALSE,
                                         dt_cancel_in               => NULL,
                                         dt_cancel_nin              => FALSE,
                                         id_prof_last_change_in     => i_prof.id,
                                         dt_epis_hidrics_line_in    => g_sysdate_tstz,
                                         flg_action_in              => pk_inp_hidrics_constant.g_flg_action_e,
                                         id_epis_hid_ftxt_way_in    => l_ft_way,
                                         id_epis_hid_ftxt_way_nin   => FALSE,
                                         id_epis_hid_ftxt_fluid_in  => l_ft_hid,
                                         id_epis_hid_ftxt_fluid_nin => FALSE,
                                         id_epis_hid_ftxt_loc_in    => l_ft_loc,
                                         id_epis_hid_ftxt_loc_nin   => FALSE,
                                         rows_out                   => l_aux_rows);
            
                --cancel the characteristics associated to the registries in this line
                --get all active characterizations of the epis_hidrics_Det
                --for each characterization check if it is configured for the new selected options: way, hidrics
                --if so, keep it
                --hotherwise send it to the history (set_characterization)
            
                FOR rec IN (SELECT ehd.id_epis_hidrics_det
                              FROM epis_hidrics_det ehd
                             WHERE ehd.id_epis_hidrics_line = i_epis_hid_line)
                LOOP
                
                    g_error := 'SEND TO HIST ID_EPIS_HIDRICS_LINE ' || l_epis_hid_line;
                    pk_alertlog.log_debug(g_error);
                    IF NOT set_edit_characterization(i_lang            => i_lang,
                                                     i_prof            => i_prof,
                                                     i_id_episode      => l_id_episode,
                                                     i_id_epis_hid_det => rec.id_epis_hidrics_det,
                                                     i_epis_hid_line   => i_epis_hid_line,
                                                     i_id_way          => l_epis_hid_det.id_way,
                                                     i_id_hidrics      => l_epis_hid_det.id_epis_hidrics,
                                                     o_error           => o_error)
                    THEN
                        RAISE e_edit_characterization;
                    END IF;
                
                END LOOP;
            END IF;
        
            RETURN l_epis_hid_line;
        END set_epis_hid_line;
    
        FUNCTION set_epis_hid_coll(i_epis_hid_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE)
            RETURN epis_hid_collector.id_epis_hid_collector%TYPE IS
            l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HID_COLL';
            --
            l_eh_det             epis_hidrics_det.id_epis_hidrics_det%TYPE;
            l_current_eh_coll_id epis_hid_collector.id_epis_hid_collector%TYPE := NULL;
            l_new_eh_coll_id     epis_hid_collector.id_epis_hid_collector%TYPE := NULL;
            l_ret_eh_coll_id     epis_hid_collector.id_epis_hid_collector%TYPE := NULL;
            l_epis_hid_line      epis_hid_collector.id_epis_hidrics_line%TYPE;
            l_flg_lvl_control    epis_hid_collector.flg_level_control%TYPE;
            l_hid_type           hidrics.flg_type%TYPE;
            l_dt_begin           epis_hid_collector.dt_begin%TYPE;
            l_dt_end             epis_hid_collector.dt_end%TYPE;
            l_curr_level         epis_hid_collector.curr_level%TYPE;
            l_zero_level CONSTANT PLS_INTEGER := 0;
            l_inserted_value BOOLEAN := FALSE;
        BEGIN
            g_error := 'GET HIDRICS TYPE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            SELECT h.flg_type
              INTO l_hid_type
              FROM hidrics h
             WHERE h.id_hidrics = l_epis_hid_det.id_hidrics;
        
            --Collector is only valid for outputs
            IF l_hid_type = pk_inp_hidrics_constant.g_hidrics_flg_type_e
               AND l_epis_hid_det.flg_level_control != pk_alert_constant.g_no
            THEN
                -- 1? record OR 1? record of current bag OR insert later date to all existing bags
                -- Change an existing value
                -- Cancel last value of a bag
                -- Cancel/change value (other than the last bag)
                BEGIN
                    -- 1? Record date is between a existing collector
                    SELECT ehc.id_epis_hid_collector, ehc.dt_begin, ehc.dt_end
                      INTO l_current_eh_coll_id, l_dt_begin, l_dt_end
                      FROM epis_hid_collector ehc
                     WHERE ehc.id_epis_hidrics_line = i_epis_hid_line
                       AND l_epis_hid_det.dt_record BETWEEN ehc.dt_begin AND nvl(ehc.dt_end, l_epis_hid_det.dt_record)
                       AND (l_epis_hid_det.dt_record != ehc.dt_end OR ehc.dt_end IS NULL);
                
                    l_new_eh_coll_id := l_current_eh_coll_id;
                
                    -- 2? flg_restart = 'Y' so: 
                    --    - update dt_end of collector
                    --    - insert a new one
                    IF l_epis_hid_det.restart_level = pk_alert_constant.g_yes
                    THEN
                        g_error := 'SEND TO HIST ID_EPIS_HID_COLLECTOR ' || l_current_eh_coll_id;
                        pk_alertlog.log_debug(g_error);
                        set_epis_hid_col_hist(i_epis_hid_collector => l_current_eh_coll_id);
                    
                        g_error := 'UPD CURRENT COLLECTOR BEFORE INSERTING NEW ONE. ID_EPIS_HID_COLLECTOR ' ||
                                   l_current_eh_coll_id;
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        --
                        --Set end date
                        IF l_dt_end IS NULL
                        THEN
                            SELECT MAX(e.dt_execution_tstz)
                              INTO l_dt_end
                              FROM epis_hidrics_det e
                             WHERE e.id_epis_hid_collector = l_current_eh_coll_id;
                        
                            IF l_epis_hid_det.dt_record > l_dt_end
                            THEN
                                l_dt_end := l_epis_hid_det.dt_record;
                            END IF;
                        END IF;
                        --
                        g_error := 'SEND TO HIST ID_EPIS_HID_COLLECTOR ' || l_current_eh_coll_id;
                        pk_alertlog.log_debug(g_error);
                        set_epis_hid_col_hist(i_epis_hid_collector => l_current_eh_coll_id);
                    
                        ts_epis_hid_collector.upd(id_epis_hid_collector_in => l_current_eh_coll_id,
                                                  dt_end_in                => l_dt_end,
                                                  flg_restart_in           => l_epis_hid_det.restart_level, --pk_alert_constant.g_no,
                                                  id_prof_in               => i_prof.id,
                                                  dt_epis_hid_collector_in => g_sysdate_tstz);
                    
                        l_dt_begin       := l_dt_end;
                        l_dt_end         := NULL;
                        l_new_eh_coll_id := NULL;
                    END IF;
                
                    g_error := 'GET EP_DET';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    BEGIN
                        SELECT ehd.id_epis_hidrics_det
                          INTO l_eh_det
                          FROM epis_hidrics_det ehd
                         WHERE ehd.id_epis_hidrics = l_epis_hid_det.id_epis_hidrics
                           AND ehd.id_epis_hidrics_line = i_epis_hid_line
                           AND ehd.dt_execution_tstz = l_epis_hid_det.dt_record;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_eh_det := NULL;
                    END;
                
                    BEGIN
                        g_error := 'CALCULATE CURRENT COLLECTOR LEVEL.';
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        SELECT nvl(SUM(ehd.value_hidrics), l_zero_level) + nvl(l_epis_hid_det.value_hidrics, 0)
                          INTO l_curr_level
                          FROM epis_hidrics_det ehd
                         WHERE ehd.id_epis_hid_collector = l_current_eh_coll_id
                           AND ehd.flg_status != pk_inp_hidrics_constant.g_epis_hid_det_status_c
                           AND (ehd.id_epis_hidrics_det != l_eh_det OR l_eh_det IS NULL);
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_curr_level := l_epis_hid_det.value_hidrics;
                    END;
                
                    g_error := 'SEND TO HIST ID_EPIS_HID_COLLECTOR ' || l_current_eh_coll_id;
                    pk_alertlog.log_debug(g_error);
                    set_epis_hid_col_hist(i_epis_hid_collector => l_current_eh_coll_id);
                
                    g_error := 'UPD CURRENT COLLECTOR LEVEL.';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    ts_epis_hid_collector.upd(id_epis_hid_collector_in => l_current_eh_coll_id,
                                              curr_level_in            => l_curr_level);
                EXCEPTION
                    WHEN no_data_found THEN
                        l_current_eh_coll_id := NULL;
                        l_new_eh_coll_id     := NULL;
                END;
            
                IF l_new_eh_coll_id IS NULL
                THEN
                    g_error := 'GET NEW ID';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    l_new_eh_coll_id := ts_epis_hid_collector.next_key;
                
                    IF l_current_eh_coll_id IS NULL
                    THEN
                        l_curr_level := l_epis_hid_det.value_hidrics;
                    ELSE
                        l_curr_level := l_zero_level;
                    END IF;
                
                    g_error := 'INSERT NEW COLLECTOR. NEW_ID: ' || l_new_eh_coll_id;
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    ts_epis_hid_collector.ins(id_epis_hid_collector_in => l_new_eh_coll_id,
                                              id_epis_hidrics_in       => l_epis_hid_det.id_epis_hidrics,
                                              id_epis_hidrics_line_in  => i_epis_hid_line,
                                              flg_level_control_in     => l_epis_hid_det.flg_level_control,
                                              dt_begin_in              => l_dt_begin,
                                              dt_end_in                => l_dt_end,
                                              curr_level_in            => l_curr_level,
                                              flg_restart_in           => pk_alert_constant.g_no,
                                              id_prof_in               => i_prof.id,
                                              dt_epis_hid_collector_in => g_sysdate_tstz);
                
                    l_inserted_value := TRUE;
                END IF;
            
                l_ret_eh_coll_id := nvl(l_current_eh_coll_id, l_new_eh_coll_id);
            
                g_error := 'GET COLLECTOR DATA. ID_EPIS_HID_COLLECTOR: ' || l_ret_eh_coll_id;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                SELECT ehc.dt_begin, ehc.dt_end, ehc.flg_level_control, ehc.id_epis_hidrics_line
                  INTO l_dt_begin, l_dt_end, l_flg_lvl_control, l_epis_hid_line
                  FROM epis_hid_collector ehc
                 WHERE ehc.id_epis_hid_collector = l_ret_eh_coll_id;
            
                IF l_flg_lvl_control = pk_alert_constant.g_yes
                   AND nvl(l_dt_begin, g_sysdate_tstz) = g_sysdate_tstz
                THEN
                    --3? When there is no collector for the execution date find corresponding dates for the new collector
                    SELECT l_epis_hid_det.dt_record dt_begin,
                           (SELECT MIN(ehc.dt_begin)
                              FROM epis_hid_collector ehc
                             WHERE ehc.id_epis_hidrics_line = l_epis_hid_line
                               AND ehc.dt_begin > l_epis_hid_det.dt_record) dt_end
                      INTO l_dt_begin, l_dt_end
                      FROM dual;
                END IF;
                --
            
                IF (l_inserted_value = FALSE)
                THEN
                    g_error := 'SEND TO HIST ID_EPIS_HID_COLLECTOR ' || l_ret_eh_coll_id;
                    pk_alertlog.log_debug(g_error);
                    set_epis_hid_col_hist(i_epis_hid_collector => l_ret_eh_coll_id);
                END IF;
            
                g_error := 'UPDATE COLLECTOR. ID_EPIS_HID_COLLECTOR: ' || l_ret_eh_coll_id;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                ts_epis_hid_collector.upd(id_epis_hid_collector_in => l_ret_eh_coll_id,
                                          dt_begin_in              => l_dt_begin,
                                          dt_end_in                => l_dt_end,
                                          id_prof_in               => i_prof.id,
                                          dt_epis_hid_collector_in => g_sysdate_tstz);
            END IF;
        
            RETURN l_ret_eh_coll_id;
        END set_epis_hid_coll;
    
        FUNCTION set_epis_hid_det
        (
            i_epis_hid_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
            i_epis_hid_det  IN epis_hidrics_det.id_epis_hidrics_det%TYPE DEFAULT NULL
        ) RETURN epis_hidrics_det.id_epis_hidrics_det%TYPE IS
            l_func_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_DET';
            --
            l_eh_det         epis_hidrics_det.id_epis_hidrics_det%TYPE;
            l_is_to_updt_bal BOOLEAN := FALSE;
            l_aux_rows       table_varchar;
            l_id_balance     epis_hidrics_det.id_epis_hidrics_balance%TYPE;
            l_msg_title      sys_message.desc_message%TYPE;
            l_msg_text       sys_message.desc_message%TYPE;
            --
            l_episode         epis_hidrics.id_episode%TYPE;
            l_flg_task_status epis_hidrics.flg_status%TYPE;
            --
            l_flg_line_status epis_hidrics_line.flg_status%TYPE;
            l_ft_way          epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
        
            l_ft_loc     epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_hid     epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_device  epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
            l_ft_charact epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE;
        BEGIN
            IF i_epis_hid_det IS NULL
            THEN
                g_error := 'VERIFY IF ID_EPIS_HID_DET EXISTS';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                BEGIN
                    SELECT ehd.id_epis_hidrics_det
                      INTO l_eh_det
                      FROM epis_hidrics_det ehd
                     WHERE ehd.id_epis_hidrics = l_epis_hid_det.id_epis_hidrics
                       AND ehd.id_epis_hidrics_line = i_epis_hid_line
                       AND ehd.dt_execution_tstz = l_epis_hid_det.dt_record;
                
                    IF (l_eh_det IS NOT NULL)
                    THEN
                        RAISE e_duplicated_value;
                    END IF;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_eh_det := NULL;
                END;
            
                --if it exists launch an error
            ELSE
                l_eh_det := i_epis_hid_det;
            END IF;
        
            IF l_eh_det IS NULL
            THEN
                l_eh_det         := ts_epis_hidrics_det.next_key;
                l_id_balance     := l_epis_h_bal;
                l_is_to_updt_bal := TRUE;
            
                --insert free texts: if thery are used and they were not created yet for the current patient
                g_error := 'CALL SET_FREE_TEXT';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                IF NOT set_free_text(i_lang              => i_lang,
                                     i_prof              => i_prof,
                                     i_id_episode        => l_id_episode,
                                     i_id_way            => NULL,
                                     i_way_ft            => NULL,
                                     i_hidrics_location  => NULL,
                                     i_location_ft       => NULL,
                                     i_id_hidrics        => NULL,
                                     i_hidrics_ft        => NULL,
                                     i_id_hidrics_device => l_epis_hid_det.id_hidrics_device,
                                     i_device_ft         => l_epis_hid_det.device_ft,
                                     i_hidrics_charact   => NULL,
                                     i_charact_ft        => NULL,
                                     o_ft_way            => l_ft_way,
                                     o_ft_loc            => l_ft_loc,
                                     o_ft_hid            => l_ft_hid,
                                     o_ft_device         => l_ft_device,
                                     o_ft_charact        => l_ft_charact,
                                     o_error             => o_error)
                THEN
                    RAISE e_free_text_error;
                END IF;
            
                g_error := 'INSERT REC';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                ts_epis_hidrics_det.ins(id_epis_hidrics_det_in     => l_eh_det,
                                        id_epis_hidrics_in         => l_epis_hid_det.id_epis_hidrics,
                                        id_epis_hidrics_line_in    => i_epis_hid_line,
                                        id_professional_in         => i_prof.id,
                                        value_hidrics_in           => l_epis_hid_det.value_hidrics,
                                        id_epis_hidrics_balance_in => l_id_balance,
                                        notes_in                   => l_epis_hid_det.notes,
                                        dt_creation_tstz_in        => g_sysdate_tstz,
                                        dt_execution_tstz_in       => l_epis_hid_det.dt_record,
                                        id_prof_line_in            => i_prof.id,
                                        dt_prof_line_in            => g_sysdate_tstz,
                                        flg_type_in                => l_epis_hid_det.flg_type,
                                        flg_status_in              => pk_inp_hidrics_constant.g_epis_hid_det_status_a,
                                        id_epis_hid_collector_in   => l_epis_hidrics_coll,
                                        id_prof_last_change_in     => i_prof.id,
                                        dt_epis_hidrics_det_in     => g_sysdate_tstz,
                                        nr_times_in                => l_epis_hid_det.nr_times,
                                        id_hidrics_device_in       => l_epis_hid_det.id_hidrics_device,
                                        flg_action_in              => pk_inp_hidrics_constant.g_flg_action_a,
                                        id_epis_hid_ftxt_dev_in    => l_ft_device,
                                        rows_out                   => l_aux_rows);
            ELSE
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS_DET ' || l_eh_det;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_det_hist(i_epis_hidrics_det => l_eh_det);
                --
                g_error := 'VERIFY IF IS TO UPDT BALANCE';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                l_is_to_updt_bal := is_to_update_balance(i_epis_hidrics_det => l_eh_det,
                                                         i_flg_type         => l_epis_hid_det.flg_type,
                                                         i_value_hidrics    => l_epis_hid_det.value_hidrics);
            
                g_error := 'GET BALANCE ID';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                l_id_balance := pk_inp_hidrics.get_balance_id(i_lang         => i_lang,
                                                              i_prof         => i_prof,
                                                              i_epis_hidrics => l_epis_hid_det.id_epis_hidrics,
                                                              i_dt_exec      => l_epis_hid_det.dt_record);
                --
                --insert free texts: if thery are used and they were not created yet for the current patient
                g_error := 'CALL SET_FREE_TEXT';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                IF NOT set_free_text(i_lang              => i_lang,
                                     i_prof              => i_prof,
                                     i_id_episode        => l_id_episode,
                                     i_id_way            => NULL,
                                     i_way_ft            => NULL,
                                     i_hidrics_location  => NULL,
                                     i_location_ft       => NULL,
                                     i_id_hidrics        => NULL,
                                     i_hidrics_ft        => NULL,
                                     i_id_hidrics_device => l_epis_hid_det.id_hidrics_device,
                                     i_device_ft         => l_epis_hid_det.device_ft,
                                     i_hidrics_charact   => NULL,
                                     i_charact_ft        => NULL,
                                     o_ft_way            => l_ft_way,
                                     o_ft_loc            => l_ft_loc,
                                     o_ft_hid            => l_ft_hid,
                                     o_ft_device         => l_ft_device,
                                     o_ft_charact        => l_ft_charact,
                                     o_error             => o_error)
                THEN
                    RAISE e_free_text_error;
                END IF;
                --                
                g_error := 'UPDATE REC';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                ts_epis_hidrics_det.upd(id_epis_hidrics_det_in   => l_eh_det,
                                        id_professional_in       => i_prof.id,
                                        value_hidrics_in         => l_epis_hid_det.value_hidrics,
                                        value_hidrics_nin        => FALSE,
                                        flg_type_in              => l_epis_hid_det.flg_type,
                                        dt_creation_tstz_in      => g_sysdate_tstz,
                                        dt_execution_tstz_in     => l_epis_hid_det.dt_record, --If dt_record is null means that the user hasn't changed the execution date
                                        notes_in                 => l_epis_hid_det.notes,
                                        notes_nin                => FALSE,
                                        flg_status_in            => pk_inp_hidrics_constant.g_epis_hid_det_status_a,
                                        id_prof_cancel_in        => NULL,
                                        id_prof_cancel_nin       => FALSE,
                                        id_cancel_reason_in      => NULL,
                                        id_cancel_reason_nin     => FALSE,
                                        notes_cancel_in          => NULL,
                                        notes_cancel_nin         => FALSE,
                                        dt_cancel_tstz_in        => NULL,
                                        dt_cancel_tstz_nin       => FALSE,
                                        id_prof_last_change_in   => i_prof.id,
                                        nr_times_nin             => FALSE,
                                        nr_times_in              => l_epis_hid_det.nr_times,
                                        flg_action_in            => pk_inp_hidrics_constant.g_flg_action_e,
                                        id_hidrics_device_nin    => FALSE,
                                        id_hidrics_device_in     => l_epis_hid_det.id_hidrics_device,
                                        dt_epis_hidrics_det_in   => g_sysdate_tstz,
                                        id_epis_hid_ftxt_dev_in  => l_ft_device,
                                        id_epis_hid_ftxt_dev_nin => FALSE,
                                        rows_out                 => l_aux_rows);
            END IF;
        
            g_error := 'GET CURRENT LINE STATUS';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            SELECT ehl.flg_status
              INTO l_flg_line_status
              FROM epis_hidrics_line ehl
             WHERE ehl.id_epis_hidrics_line = i_epis_hid_line;
        
            IF l_flg_line_status = pk_inp_hidrics_constant.g_epis_hid_lin_status_c
            THEN
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS_LINE ' || i_epis_hid_line;
                pk_alertlog.log_debug(g_error);
                set_epis_hid_line_hist(i_epis_hidrics_line => i_epis_hid_line);
                --
                g_error := 'RE-ACTIVATE LINE';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                ts_epis_hidrics_line.upd(id_epis_hidrics_line_in => i_epis_hid_line,
                                         flg_status_in           => pk_inp_hidrics_constant.g_epis_hid_lin_status_a,
                                         dt_creation_in          => g_sysdate_tstz,
                                         id_prof_cancel_in       => NULL,
                                         id_prof_cancel_nin      => FALSE,
                                         id_cancel_reason_in     => NULL,
                                         id_cancel_reason_nin    => FALSE,
                                         notes_cancel_in         => NULL,
                                         notes_cancel_nin        => FALSE,
                                         dt_cancel_in            => NULL,
                                         dt_cancel_nin           => FALSE,
                                         id_prof_last_change_in  => i_prof.id,
                                         flg_action_in           => pk_inp_hidrics_constant.g_flg_action_a,
                                         dt_epis_hidrics_line_in => g_sysdate_tstz);
            
                g_error := 'CALL pk_inp_hidrics_groups.reactive_group_line_assoc. i_epis_hid_line: ' || i_epis_hid_line;
                pk_alertlog.log_debug(g_error);
                IF NOT pk_inp_hidrics_groups.reactive_group_line_assoc(i_lang              => i_lang,
                                                                       i_prof              => i_prof,
                                                                       i_epis_hidrics_line => i_epis_hid_line,
                                                                       o_error             => o_error)
                THEN
                    RAISE e_error;
                END IF;
            END IF;
        
            IF l_is_to_updt_bal
            THEN
                g_error := 'CHANGES WERE MADE SO UPDATE BALANCE';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                IF NOT pk_inp_hidrics.set_balance(i_lang             => i_lang,
                                                  i_prof             => i_prof,
                                                  i_epis_hidrics     => l_epis_hid_det.id_epis_hidrics,
                                                  i_epis_hid_balance => l_id_balance,
                                                  i_dt_exec          => l_epis_hid_det.dt_record,
                                                  i_flg_just_cal     => pk_alert_constant.g_yes,
                                                  o_epis_hid_bal     => l_epis_h_bal,
                                                  o_error            => o_error)
                THEN
                    RAISE e_error;
                END IF;
            END IF;
        
            g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF NOT check_restriction_alerts(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_episode      => NULL,
                                            i_epis_hidrics => l_epis_hid_det.id_epis_hidrics,
                                            i_epis_balance => l_id_balance,
                                            i_max_intake   => NULL,
                                            i_min_output   => NULL,
                                            i_hidrics_type => NULL,
                                            i_flg_context  => pk_inp_hidrics_constant.g_context_new_record,
                                            i_dt_execution => l_epis_hid_det.dt_record,
                                            o_msg_title    => l_msg_title,
                                            o_msg_text     => l_msg_text,
                                            o_error        => o_error)
            THEN
                RAISE e_error;
            END IF;
        
            g_error := 'CALL TO SET_DT_FIRST_REG_BALANCE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF NOT set_dt_first_reg_balance(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_epis_hidrics => l_epis_hid_det.id_epis_hidrics,
                                            i_epis_hid_bal => l_id_balance,
                                            o_error        => o_error)
            THEN
                RAISE e_error;
            END IF;
        
            g_error := 'GET EPIS_HID DATA';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            SELECT eh.id_episode, eh.flg_status
              INTO l_episode, l_flg_task_status
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = l_epis_hid_det.id_epis_hidrics;
        
            RETURN l_eh_det;
        END set_epis_hid_det;
    
        PROCEDURE validate_dt_execution IS
            l_proc_name VARCHAR2(30 CHAR) := 'VALIDATE_DT_EXECUTION';
            --
            l_dt_init epis_hidrics.dt_initial_tstz%TYPE;
        BEGIN
            g_error := 'GET INITIAL DATE. ID_EPIS_HID: ' || l_epis_hid_det.id_epis_hidrics;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            SELECT eh.dt_initial_tstz
              INTO l_dt_init
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = l_epis_hid_det.id_epis_hidrics;
        
            IF pk_date_utils.compare_dates_tsz(i_prof, l_epis_hid_det.dt_record, l_dt_init) = 'L'
            THEN
                RAISE g_epis_hid_wrong_date;
            END IF;
        END validate_dt_execution;
    BEGIN
        g_error := 'CALL PK_UTILS.SET_NLS_NUMERIC_CHARACTERS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        pk_utils.set_nls_numeric_characters(i_prof => i_prof);
    
        g_error := 'EXTRACT XML DATA';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        extract_ehd_from_xml(i_data => i_data, o_eh_det => l_epis_hid_det, o_hid_chars => l_hid_chars);
    
        g_error := 'check_show_conflict_pop for id_epis_hidrics: ' || l_epis_hid_det.id_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_show_conflict_pop(i_lang                => i_lang,
                                       i_prof                => i_prof,
                                       i_epis_hidrics        => l_epis_hid_det.id_epis_hidrics,
                                       i_epis_hidrics_status => NULL,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg                 => o_msg,
                                       o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        o_epis_hidrics := l_epis_hid_det.id_epis_hidrics;
    
        SELECT eh.id_episode
          INTO l_id_episode
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = l_epis_hid_det.id_epis_hidrics;
    
        IF (o_flg_show = pk_alert_constant.get_yes)
        THEN
            RETURN TRUE;
        END IF;
    
        g_error := 'VALIDATE DT_EXECUTION';
        validate_dt_execution;
    
        g_error := 'GET HIDRICS_LOCATION';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_hidrics_location := get_id_hid_location(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_body_part      => l_epis_hid_det.id_body_part,
                                                  i_body_side      => l_epis_hid_det.id_body_side,
                                                  i_body_part_ftxt => l_epis_hid_det.location_ft);
    
        IF l_hidrics_location = 0
           AND l_epis_hid_det.location_ft IS NULL
        THEN
            l_hidrics_location := NULL;
        END IF;
    
        g_error := 'GET BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_epis_h_bal := CASE
                            WHEN l_epis_hid_det.id_epis_hidrics_balance IS NULL THEN
                             get_balance_id(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_epis_hidrics => l_epis_hid_det.id_epis_hidrics,
                                            i_dt_exec      => nvl(l_epis_hid_det.dt_record, g_sysdate_tstz))
                            ELSE
                             l_epis_hid_det.id_epis_hidrics_balance
                        END;
    
        IF l_epis_hid_det.id_epis_hidrics_det IS NULL
           AND l_epis_hid_det.flg_edit_type != g_ehd_edt_typ_l
        THEN
            g_error := 'INITIALIZE EPIS_HIDRICS';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            initialize_epis_hidrics;
        END IF;
    
        g_error := 'INSERT EPIS_HIDRICS_LINE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        o_epis_hidrics_line := set_epis_hid_line(i_epis_hid_line => l_epis_hid_det.id_epis_hidrics_line);
    
        g_error             := 'SET HIDRICS COLLECTOR';
        l_epis_hidrics_coll := set_epis_hid_coll(i_epis_hid_line => o_epis_hidrics_line);
    
        IF NOT (l_epis_hid_det.id_epis_hidrics_line IS NOT NULL AND l_epis_hid_det.flg_edit_type = g_ehd_edt_typ_l)
        THEN
            g_error        := 'INSERT EPIS_HIDRICS_DET';
            o_epis_hid_det := set_epis_hid_det(i_epis_hid_line => o_epis_hidrics_line,
                                               i_epis_hid_det  => l_epis_hid_det.id_epis_hidrics_det);
        END IF;
        --
        g_error := 'INSERT CHARACTERIZATION; ID_EPIS_HIDRICS_DET: ' || o_epis_hid_det;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        set_characterization(i_epis_hid_det => o_epis_hid_det);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN e_duplicated_value THEN
            pk_alert_exceptions.process_error(i_lang        => i_lang,
                                              i_sqlcode     => NULL,
                                              i_sqlerrm     => pk_message.get_message(i_lang      => i_lang,
                                                                                      i_prof      => i_prof,
                                                                                      i_code_mess => 'HIDRICS_M075'),
                                              i_message     => pk_message.get_message(i_lang      => i_lang,
                                                                                      i_prof      => i_prof,
                                                                                      i_code_mess => 'HIDRICS_M075'),
                                              i_owner       => g_package_owner,
                                              i_package     => g_package_name,
                                              i_function    => 'SET_DELIVERY',
                                              i_action_type => 'D',
                                              o_error       => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN t_ti_log_ins_exception THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
            BEGIN
                l_error_message := pk_message.get_message(i_lang, 'COMMON_M001');
            
                l_error_in.set_all(i_lang,
                                   'ERR_WRITTING_LOG',
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   'SET_EPIS_HIDRICS');
                --
                l_error_in.set_action(l_error_message, 'S');
                g_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        WHEN g_epis_hid_balance_not_found THEN
            l_action_message := pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_M029');
            l_error_code     := 'HIDRICS_T074';
            l_error_message  := pk_message.get_message(i_lang => i_lang, i_code_mess => l_error_code);
        
            pk_alert_exceptions.process_error(i_lang        => i_lang,
                                              i_sqlcode     => l_error_code,
                                              i_sqlerrm     => l_error_message,
                                              i_message     => g_error,
                                              i_owner       => g_package_owner,
                                              i_package     => g_package_name,
                                              i_function    => l_func_name,
                                              i_action_type => 'U',
                                              i_action_msg  => l_action_message,
                                              o_error       => o_error);
            RETURN FALSE;
        WHEN g_epis_hid_wrong_date THEN
            l_error_code    := 'HIDRICS_M043';
            l_error_message := pk_message.get_message(i_lang => i_lang, i_code_mess => l_error_code);
        
            pk_alert_exceptions.process_error(i_lang        => i_lang,
                                              i_sqlcode     => l_error_code,
                                              i_sqlerrm     => l_error_message,
                                              i_message     => g_error,
                                              i_owner       => g_package_owner,
                                              i_package     => g_package_name,
                                              i_function    => l_func_name,
                                              i_action_type => 'U',
                                              i_action_msg  => NULL,
                                              o_error       => o_error);
            RETURN FALSE;
        WHEN e_error_dup_line THEN
            l_error_code    := 'HIDRICS_M050';
            l_error_message := pk_message.get_message(i_lang => i_lang, i_code_mess => l_error_code);
        
            pk_alert_exceptions.process_error(i_lang        => i_lang,
                                              i_sqlcode     => l_error_code,
                                              i_sqlerrm     => l_error_message,
                                              i_message     => g_error,
                                              i_owner       => g_package_owner,
                                              i_package     => g_package_name,
                                              i_function    => l_func_name,
                                              i_action_type => 'U',
                                              i_action_msg  => NULL,
                                              o_error       => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_epis_hidrics_det;

    /*******************************************************************************************************************************************
    * Returns the hidrics type id given the acronym
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_acronym                hidrics type acronym
    * 
    * @return                         Returns hidrics type id
    *
    * @author                         Sofia Mendes
    * @version                        2.6.3.8
    * @since                          2013/09/05
    *******************************************************************************************************************************************/
    FUNCTION get_id_hidrics_type
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_acronym IN hidrics_type.acronym%TYPE
    ) RETURN hidrics_type.id_hidrics_type%TYPE IS
        l_id_hidrics_type hidrics_type.id_hidrics_type%TYPE;
    BEGIN
    
        g_error := 'GET id_hidrics_type. i_acronym: ' || i_acronym;
        pk_alertlog.log_debug(g_error);
        SELECT ht.id_hidrics_type
          INTO l_id_hidrics_type
          FROM hidrics_type ht
         WHERE ht.acronym = i_acronym;
    
        RETURN l_id_hidrics_type;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alertlog.log_debug('Error getting id_hidrics_type. ' || g_error);
        
            RETURN NULL;
    END get_id_hidrics_type;

    /*******************************************************************************************************************************************
    * get_flowsheet_actions           Get all actions for the flowsheet screen
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPISODE                ID_EPISODE identifier
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param O_ACTIONS_CREATE         Actions for the create button
    * @param O_CREATE_CHILDS          Child actions for the 'Fluid type' option in the create button
    * @param O_ACTIONS                Actions for the action button
    * @param O_VIEWS                  Actions for the views button
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    *
    * @author                         José ilva
    * @version                        2.6.0.3
    * @since                          2010/05/31
    *******************************************************************************************************************************************/
    FUNCTION get_flowsheet_actions
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_epis_hidrics   IN epis_hidrics.id_epis_hidrics%TYPE,
        o_actions_create OUT pk_types.cursor_type,
        o_create_childs  OUT pk_types.cursor_type,
        o_actions        OUT pk_types.cursor_type,
        o_views          OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_subject_create CONSTANT action.subject%TYPE := 'HIDRICS_CREATE_GRID';
        l_subject_action CONSTANT action.subject%TYPE := 'HIDRICS_ACTION_GRID';
        l_subject_view   CONSTANT action.subject%TYPE := 'HIDRICS_VIEW_GRID';
    
        l_hidrics_type hidrics_type.id_hidrics_type%TYPE;
    
    BEGIN
    
        g_error := 'GET CURSOR O_ACTIONS_CREATE';
        IF NOT pk_action.get_actions(i_lang       => i_lang,
                                     i_prof       => i_prof,
                                     i_subject    => l_subject_create,
                                     i_from_state => NULL,
                                     o_actions    => o_actions_create,
                                     o_error      => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        g_error := 'GET CURSOR O_ACTIONS';
        IF NOT pk_action.get_actions(i_lang       => i_lang,
                                     i_prof       => i_prof,
                                     i_subject    => l_subject_action,
                                     i_from_state => NULL,
                                     o_actions    => o_actions,
                                     o_error      => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        g_error := 'GET CURSOR O_VIEWS';
        IF NOT pk_action.get_actions(i_lang       => i_lang,
                                     i_prof       => i_prof,
                                     i_subject    => l_subject_view,
                                     i_from_state => NULL,
                                     o_actions    => o_views,
                                     o_error      => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        g_error := 'GET HIDRICS ACRONYM';
        SELECT eh.id_hidrics_type
          INTO l_hidrics_type
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        IF NOT get_flowsheet_actions(i_lang          => i_lang,
                                     i_prof          => i_prof,
                                     i_hidrics_type  => l_hidrics_type,
                                     o_create_childs => o_create_childs,
                                     o_error         => o_error)
        THEN
            RETURN FALSE;
        END IF;
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_FLOWSHEET_ACTIONS',
                                              o_error);
            pk_types.open_my_cursor(o_actions_create);
            pk_types.open_my_cursor(o_create_childs);
            pk_types.open_my_cursor(o_actions);
            pk_types.open_my_cursor(o_views);
            RETURN FALSE;
    END get_flowsheet_actions;

    /*******************************************************************************************************************************************
    * get_hidrics_way                 Get the way registered in this hidrics record
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_epis_hidrics_line       EPIS_HIDRICS LINE ID
    * 
    * @return                         way description
    *
    * @author                         Alexandre Santos
    * @version                        2.6.0.3
    * @since                          2010/06/01
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_way
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics_line     IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_dt_epis_hid_line_hist IN epis_hidrics_line_hist.dt_epis_hid_line_hist%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_HIDRICS_WAY';
        --
        l_error    t_error_out;
        l_desc_way table_varchar := table_varchar(NULL);
    BEGIN
        g_error := 'GET HIDRICS WAY';
    
        SELECT coalesce(t.free_text, pk_translation.get_translation(i_lang, t.code_way))
          BULK COLLECT
          INTO l_desc_way
          FROM (SELECT ef.free_text, hw.code_way
                  FROM epis_hidrics_line ehl
                  JOIN way hw
                    ON hw.id_way = ehl.id_way
                  LEFT JOIN epis_hidrics_det_ftxt ef
                    ON ef.id_way = hw.id_way
                   AND ef.id_epis_hidrics_det_ftxt = ehl.id_epis_hid_ftxt_way
                 WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line
                   AND (i_dt_epis_hid_line_hist = g_sysdate_tstz OR i_dt_epis_hid_line_hist IS NULL)
                UNION ALL
                SELECT efh.free_text, hw.code_way
                  FROM epis_hidrics_line_hist ehlh
                  LEFT JOIN epis_hidrics_det_ftxt efh
                    ON efh.id_epis_hidrics_det_ftxt = ehlh.id_epis_hid_ftxt_way
                  JOIN way hw
                    ON hw.id_way = ehlh.id_way
                 WHERE ehlh.id_epis_hidrics_line = i_epis_hidrics_line
                   AND ehlh.dt_epis_hid_line_hist = i_dt_epis_hid_line_hist
                   AND i_dt_epis_hid_line_hist != g_sysdate_tstz
                   AND i_dt_epis_hid_line_hist IS NOT NULL) t;
    
        IF l_desc_way.count > 0
        THEN
            RETURN l_desc_way(l_desc_way.first);
        ELSE
            RETURN NULL;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_hidrics_way;

    /**
    * get_hid_chars_ids               Get the characteristics ids in this hidrics record
    *
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS_DET       EPIS_HIDRICS ID
    * 
    * @return                         way description
    *
    * @author                         Alexandre Santos
    * @version                        2.6.0.3
    * @since                          2010/06/01
    *******************************************************************************************************************************************/
    FUNCTION get_hid_chars_ids
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE
    ) RETURN table_number IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_HID_CHARS_IDS';
        --
        l_error t_error_out;
        l_ids   table_number;
    BEGIN
        g_error := 'GET HIDRICS WAY';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT ehdc.id_hidrics_charact
          BULK COLLECT
          INTO l_ids
          FROM epis_hidrics_det ehd
          JOIN epis_hidrics_det_charact ehdc
            ON ehdc.id_epis_hidrics_det = ehd.id_epis_hidrics_det
         WHERE ehd.id_epis_hidrics_det = i_epis_hidrics_det;
    
        RETURN l_ids;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_hid_chars_ids;

    /**
    * get_hid_chars_descs             Get the characteristics descriptions in this hidrics record
    *
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS_DET       EPIS_HIDRICS ID
    * 
    * @return                         way description
    *
    * @author                         Alexandre Santos
    * @version                        2.6.0.3
    * @since                          2010/06/01
    *******************************************************************************************************************************************/
    FUNCTION get_hid_chars_descs
    (
        i_lang                     IN language.id_language%TYPE,
        i_prof                     IN profissional,
        i_epis_hidrics_det         IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        i_dt_epis_hidrics_det_hist IN epis_hidrics_det_hist.dt_epis_hidrics_det_hist%TYPE DEFAULT NULL
    ) RETURN table_varchar IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_HID_CHARS_DESCS';
        --
        l_error t_error_out;
        l_descs table_varchar;
    BEGIN
        g_error := 'GET HIDRICS CHARACT';
    
        SELECT coalesce(t.free_text, pk_translation.get_translation(i_lang, t.code_hidrics_charact))
          BULK COLLECT
          INTO l_descs
          FROM (SELECT ef.free_text, hc.code_hidrics_charact
                  FROM epis_hidrics_det ehd
                  JOIN epis_hidrics_det_charact ehdc
                    ON ehdc.id_epis_hidrics_det = ehd.id_epis_hidrics_det
                  JOIN hidrics_charact hc
                    ON hc.id_hidrics_charact = ehdc.id_hidrics_charact
                  LEFT JOIN epis_hidrics_det_ftxt ef
                    ON ef.id_epis_hidrics_det_ftxt = ehdc.id_epis_hid_ftxt_char
                   AND ef.id_hidrics_charact = ehdc.id_hidrics_charact
                 WHERE ehd.id_epis_hidrics_det = i_epis_hidrics_det
                   AND (i_dt_epis_hidrics_det_hist = g_sysdate_tstz OR i_dt_epis_hidrics_det_hist IS NULL)
                UNION ALL
                SELECT ef.free_text, hc.code_hidrics_charact
                  FROM epis_hidrics_det_hist ehd
                  JOIN epis_hd_char_hist ehdc
                    ON ehdc.id_epis_hidrics_det = ehd.id_epis_hidrics_det
                   AND ehdc.dt_eh_det_charact = ehd.dt_epis_hidrics_det
                  JOIN hidrics_charact hc
                    ON hc.id_hidrics_charact = ehdc.id_hidrics_charact
                  LEFT JOIN epis_hidrics_det_ftxt ef
                    ON ef.id_epis_hidrics_det_ftxt = ehdc.id_epis_hid_ftxt_char
                   AND ef.id_hidrics_charact = ehdc.id_hidrics_charact
                 WHERE ehd.id_epis_hidrics_det = i_epis_hidrics_det
                   AND ehd.dt_epis_hidrics_det_hist =
                       (SELECT MAX(ehd2.dt_epis_hidrics_det_hist)
                          FROM epis_hidrics_det_hist ehd2
                         WHERE ehd2.id_epis_hidrics_det = i_epis_hidrics_det
                           AND ehd2.dt_epis_hidrics_det_hist <= i_dt_epis_hidrics_det_hist)
                   AND NOT (i_dt_epis_hidrics_det_hist = g_sysdate_tstz OR i_dt_epis_hidrics_det_hist IS NULL)) t
         ORDER BY 1;
    
        RETURN l_descs;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_hid_chars_descs;

    /**
    * get_characts_descs             Get a description with all the characteristics descriptions
    *
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS_DET       EPIS_HIDRICS_DET ID
    * 
    * @return                         way description
    *
    * @author                         Sofia Mendes
    * @version                        2.6.0.3.5
    * @since                          15-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION get_characts_descs
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_CHARACTS_DESCS';
        --
        l_error       t_error_out;
        l_description VARCHAR2(5000);
        l_descs       table_varchar;
    BEGIN
        g_error := 'GET HIDRICS CHARACT DESC';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_descs := get_hid_chars_descs(i_lang => i_lang, i_prof => i_prof, i_epis_hidrics_det => i_epis_hidrics_det);
    
        IF (l_descs IS NOT NULL AND l_descs.exists(1))
        THEN
            FOR i IN 1 .. l_descs.count
            LOOP
                l_description := l_description || chr(10) || l_descs(i);
            END LOOP;
        END IF;
    
        RETURN l_description;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_characts_descs;

    /**
    * get_flowsheet_tooltip             Get a info to be shown in the flowsheet tooltip
    *
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS           EPIS_HIDRICS ID
    * @param I_EPIS_HIDRICS_DET       EPIS_HIDRICS_DET ID
    * @param i_nr_times               Nr of occurrences
    * @param i_value_hidrics          Quantity
    * @param i_hidrics_device         Device ID
    * @param i_professional           Professional ID
    * @param i_hidrics_type           Hidrics type: A-administration; E-elimination
    * @param i_value_srt              Dose value of the iv fluids
    * 
    * @return                         description
    *
    * @author                         Sofia Mendes
    * @version                        2.6.0.3.5
    * @since                          15-Dez-2010
    *******************************************************************************************************************************************/
    FUNCTION get_flowsheet_tooltip
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics     IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        i_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        i_nr_times         IN epis_hidrics_det.nr_times%TYPE,
        i_value_hidrics    IN epis_hidrics_det.value_hidrics%TYPE,
        i_hidrics_device   IN hidrics_device.id_hidrics_device%TYPE,
        i_professional     IN epis_hidrics_det.id_professional%TYPE,
        i_hidrics_type     IN hidrics.flg_type%TYPE,
        i_value_srt        IN VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_FLOWSHEET_TOOLTIP';
        --
        l_error       t_error_out;
        l_characts    VARCHAR2(4000 CHAR);
        l_description VARCHAR2(5000 CHAR);
    
        l_desc_charact   sys_message.desc_message%TYPE;
        l_desc_nr_occurs sys_message.desc_message%TYPE;
        l_desc_device    sys_message.desc_message%TYPE;
        l_desc_reg_by    sys_message.desc_message%TYPE;
        l_desc_value     sys_message.desc_message%TYPE;
    
    BEGIN
        g_error := 'GET HIDRICS CHARACT DESC';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_characts := get_characts_descs(i_lang => i_lang, i_prof => i_prof, i_epis_hidrics_det => i_epis_hidrics_det);
    
        IF (l_characts IS NOT NULL)
        THEN
            IF (i_hidrics_type = pk_inp_hidrics_constant.g_hidrics_flg_type_a)
            THEN
                l_desc_charact := pk_message.get_message(i_lang, 'HIDRICS_T065');
            ELSE
                l_desc_charact := pk_message.get_message(i_lang, 'HIDRICS_T094');
            END IF;
        
            l_description := pk_inp_hidrics_constant.g_open_bold || l_desc_charact || pk_inp_hidrics_constant.g_colon ||
                             pk_inp_hidrics_constant.g_close_bold || pk_inp_hidrics_constant.g_space ||
                             htf.escape_sc(l_characts);
        END IF;
    
        IF (i_nr_times IS NOT NULL)
        THEN
            l_desc_nr_occurs := pk_message.get_message(i_lang, 'HIDRICS_T097');
            l_description := CASE
                                 WHEN l_description IS NOT NULL THEN
                                  l_description || chr(10)
                             END || pk_inp_hidrics_constant.g_open_bold || l_desc_nr_occurs || pk_inp_hidrics_constant.g_colon ||
                             pk_inp_hidrics_constant.g_close_bold || pk_inp_hidrics_constant.g_space || to_char(i_nr_times);
        END IF;
    
        IF (i_value_hidrics IS NOT NULL OR i_value_srt IS NOT NULL)
        THEN
            l_desc_value  := pk_message.get_message(i_lang, 'HIDRICS_T066');
            l_description := CASE
                                 WHEN l_description IS NOT NULL THEN
                                  l_description || chr(10)
                             END || pk_inp_hidrics_constant.g_open_bold || l_desc_value || pk_inp_hidrics_constant.g_colon ||
                             pk_inp_hidrics_constant.g_close_bold || pk_inp_hidrics_constant.g_space ||
                             nvl(i_value_srt,
                                 to_char(i_value_hidrics) || ' ' ||
                                 get_hidrics_um(i_lang => i_lang, i_prof => i_prof, i_epis_hidrics => i_epis_hidrics));
        END IF;
    
        IF (i_hidrics_device IS NOT NULL)
        THEN
            l_desc_device := pk_message.get_message(i_lang, 'HIDRICS_T098');
            l_description := CASE
                                 WHEN l_description IS NOT NULL THEN
                                  l_description || chr(10)
                             END || pk_inp_hidrics_constant.g_open_bold || l_desc_device || pk_inp_hidrics_constant.g_colon ||
                             pk_inp_hidrics_constant.g_close_bold || pk_inp_hidrics_constant.g_space ||
                             get_device_desc(i_lang => i_lang, i_prof => i_prof, i_id_epis_hidrics_det => i_epis_hidrics_det);
        END IF;
    
        IF (i_professional IS NOT NULL)
        THEN
            l_desc_reg_by := pk_message.get_message(i_lang, 'HIDRICS_M065');
            l_description := CASE
                                 WHEN l_description IS NOT NULL THEN
                                  l_description || chr(10)
                             END || pk_inp_hidrics_constant.g_open_bold || l_desc_reg_by || pk_inp_hidrics_constant.g_colon ||
                             pk_inp_hidrics_constant.g_close_bold || pk_inp_hidrics_constant.g_space ||
                             htf.escape_sc(pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                            i_prof    => i_prof,
                                                                            i_prof_id => i_professional));
        END IF;
    
        RETURN REPLACE(l_description, pk_inp_hidrics_constant.g_separator, ';');
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_flowsheet_tooltip;

    /**
    * Get epis hidric detail data
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hid_det              Epis hidrics det id
    * @param   o_epis_hid_det              Epis hidrics detail cursor
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   01-06-2010
    */
    FUNCTION get_epis_hidrics_det
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hid_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        o_epis_hid_det OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_DET';
        --
    BEGIN
    
        g_error := 'GET DETAIL DATA FOR ID_EPIS_HIDRICS_DET: ' || i_epis_hid_det;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_epis_hid_det FOR
            SELECT ehd.id_epis_hidrics_det,
                   ehd.id_epis_hidrics,
                   ehd.id_epis_hidrics_line,
                   ehl.id_way id_hidrics_way,
                   (SELECT pk_inp_hidrics.get_hidrics_way(i_lang, i_prof, ehl.id_epis_hidrics_line)
                      FROM dual) desc_hid_way,
                   ehl.id_hidrics_location,
                   hl.id_body_part,
                   hl.id_body_side,
                   (SELECT pk_inp_hidrics.get_hidrics_location(i_lang, i_prof, ehl.id_epis_hidrics_line)
                      FROM dual) desc_location,
                   ehl.id_hidrics,
                   (SELECT pk_inp_hidrics.get_hidrics_desc(i_lang, i_prof, ehl.id_epis_hidrics_line)
                      FROM dual) desc_hidrics,
                   pk_inp_hidrics.get_hid_chars_ids(i_lang, i_prof, ehd.id_epis_hidrics_det) epis_hid_chars_ids,
                   pk_inp_hidrics.get_hid_chars_descs(i_lang, i_prof, ehd.id_epis_hidrics_det) epis_hid_chars_descs,
                   pk_date_utils.date_char_tsz(i_lang, ehd.dt_execution_tstz, i_prof.institution, i_prof.software) dt_executiton_char,
                   pk_date_utils.date_send_tsz(i_lang, ehd.dt_execution_tstz, i_prof) dt_executiton_send,
                   ehd.value_hidrics,
                   (SELECT pk_inp_hidrics.get_hidrics_um(i_lang, i_prof, ehd.id_epis_hidrics)
                      FROM dual) desc_unit_measure,
                   ehd.flg_type,
                   (SELECT pk_sysdomain.get_domain(g_cd_ehd_flg_type, ehd.flg_type, i_lang)
                      FROM dual) desc_flg_type,
                   ehd.notes,
                   ehc.flg_level_control,
                   (SELECT pk_sysdomain.get_domain(g_cd_ehc_flg_lvl_control, ehc.flg_level_control, i_lang)
                      FROM dual) desc_flg_lvl_control,
                   ehc.flg_restart,
                   (SELECT pk_sysdomain.get_domain(g_cd_ehc_flg_restart, ehc.flg_restart, i_lang)
                      FROM dual) desc_flg_restart,
                   ehc.curr_level,
                   decode(h.flg_type,
                          pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                          pk_alert_constant.g_no,
                          pk_inp_hidrics.is_coll_flg_lvlc_avail(ehd.id_epis_hid_collector)) flg_lvl_ctl_available,
                   decode(h.flg_type,
                          pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                          pk_alert_constant.g_no,
                          decode(pk_inp_hidrics.is_last_collector(ehc.id_epis_hidrics_line, ehc.id_epis_hid_collector),
                                 pk_alert_constant.g_yes,
                                 pk_inp_hidrics.is_coll_flg_rest_avail(ehd.id_epis_hidrics_line, ehd.dt_execution_tstz),
                                 pk_alert_constant.g_no)) flg_rest_available,
                   pk_inp_hidrics.is_last_collector(ehc.id_epis_hidrics_line, ehc.id_epis_hid_collector) flg_last_collector,
                   ehd.nr_times,
                   ehd.id_hidrics_device,
                   pk_inp_hidrics.get_device_desc(i_lang, i_prof, ehd.id_epis_hidrics_det) hidrics_device_desc,
                   h.flg_nr_times,
                   
                   CASE
                        WHEN (SELECT ehb.flg_status
                                FROM epis_hidrics_balance ehb
                               WHERE ehb.id_epis_hidrics_balance = ehd.id_epis_hidrics_balance) NOT IN
                             (pk_inp_hidrics_constant.g_epis_hid_balance_c,
                              pk_inp_hidrics_constant.g_epis_hid_balance_i,
                              pk_inp_hidrics_constant.g_epis_hid_balance_f) THEN
                         pk_alert_constant.g_yes
                        ELSE
                         pk_alert_constant.g_no
                    END flg_edit_type
              FROM epis_hidrics_det ehd
              JOIN epis_hidrics_line ehl
                ON ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line
              JOIN hidrics h
                ON h.id_hidrics = ehl.id_hidrics
              LEFT JOIN epis_hid_collector ehc
                ON ehc.id_epis_hid_collector = ehd.id_epis_hid_collector
              LEFT JOIN hidrics_location hl
                ON hl.id_hidrics_location = ehl.id_hidrics_location
             WHERE ehd.id_epis_hidrics_det = i_epis_hid_det;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_epis_hid_det);
            RETURN FALSE;
    END get_epis_hidrics_det;

    /**
    * Closes or recalculates the inputed balance and opens a new one (when applicable)
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   i_epis_hid_balance          Epis hidrics balance id (If null means current open balance)
    * @param   i_flg_chg_bal_dt            Is to change the next balance data? Y - Yes; N - No; NULL - Automatically calculated
    * @param   i_flg_just_cal              Is to just calculate the balance? Y - Yes; Otherwise N (In case of current balance, when value is 'Y' the balance will not be close)
    * @param   o_epis_hid_bal              New epis hidrics balance id
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   01-06-2010
    */

    FUNCTION set_balance
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hid_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE DEFAULT NULL,
        i_flg_chg_bal_dt   IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_dt_exec          IN epis_hidrics_det.dt_execution_tstz%TYPE DEFAULT NULL,
        i_flg_just_cal     IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        o_epis_hid_bal     OUT epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'SET_BALANCE';
        --
        l_epis_hid_balance epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_dt_close_balance epis_hidrics_balance.dt_close_balance_tstz%TYPE;
        l_flg_close        epis_hidrics_balance.flg_close_type%TYPE;
        l_dt_end           epis_hidrics.dt_end_tstz%TYPE;
        l_hid_interv       epis_hidrics.id_hidrics_interval%TYPE;
        l_flg_status       epis_hidrics.flg_status%TYPE;
        l_dt_end_ultr      VARCHAR2(200 CHAR);
        l_total_reads      PLS_INTEGER;
    
        l_rowids table_varchar;
    
        l_all_hid_balances table_number;
    
        t_ti_log_ins_exception EXCEPTION;
        l_icnp_interv          EXCEPTION;
    
        CURSOR c_epis_hid(l_epis_hid_bals table_number) IS
            SELECT eh.dt_end_tstz,
                   eh.id_hidrics_interval,
                   eh.flg_status,
                   (SELECT COUNT(*)
                      FROM epis_hidrics_det ehd
                      JOIN epis_hidrics_line ehl
                        ON ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line
                     WHERE ehd.id_epis_hidrics = eh.id_epis_hidrics
                       AND ehd.id_epis_hidrics_balance IN
                           (SELECT /*+opt_estimate (table t rows=0.0001)*/
                             column_value
                              FROM TABLE(l_epis_hid_bals) t)
                       AND ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a
                       AND (nvl(ehd.flg_type, pk_inp_hidrics_constant.g_epis_hid_det_type_a) =
                           pk_inp_hidrics_constant.g_epis_hid_det_type_a)
                       AND ehd.dt_execution_tstz <= nvl(i_dt_exec, g_sysdate_tstz)
                       AND ehl.flg_status = pk_inp_hidrics_constant.g_epis_hid_lin_status_a) total_reads
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = i_epis_hidrics;
        --
        PROCEDURE create_new_balance IS
            l_proc_name VARCHAR2(30 CHAR) := 'CREATE_NEW_BALANCE';
            --
            l_next_ehb     epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
            l_cfg_um       epis_hidrics_balance.id_unit_measure%TYPE;
            l_unit_measure epis_hidrics_balance.id_unit_measure%TYPE;
            l_episode      episode.id_episode%TYPE;
            l_hid_type     hidrics_type.id_hidrics_type%TYPE;
            l_flg_ti_type  hidrics_type.flg_ti_type%TYPE;
            l_ht_acronym   hidrics_type.acronym%TYPE;
            --
            l_total_a NUMBER(26, 2);
            l_total_e NUMBER(26, 2);
            l_times_a PLS_INTEGER;
            l_times_e PLS_INTEGER;
            l_rowids  table_varchar := table_varchar();
        
            l_dt_open_balance epis_hidrics_balance.dt_open_tstz%TYPE;
        
        BEGIN
            IF i_flg_just_cal = pk_alert_constant.g_no
            THEN
                g_error := 'GET PREV BALANCE UM';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                l_cfg_um := to_number(pk_sysconfig.get_config('HIDRICS_UNIT_MEAS', i_prof));
                SELECT nvl(ehb.id_unit_measure, l_cfg_um), eh.id_episode, eh.id_hidrics_type
                  INTO l_unit_measure, l_episode, l_hid_type
                  FROM epis_hidrics_balance ehb
                  JOIN epis_hidrics eh
                    ON eh.id_epis_hidrics = ehb.id_epis_hidrics
                 WHERE ehb.id_epis_hidrics_balance = l_epis_hid_balance;
            
                g_error := 'GET NEW BALANCE ID';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                l_next_ehb := ts_epis_hidrics_balance.next_key;
            
                --verify if there is a manual balance after last auto balance date
                --if there is, the new balance open date will be equal the manual balance close date + 1 second
                IF l_flg_close = pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut
                THEN
                    BEGIN
                        g_error := 'VERIFY IF THERE IS A MANUAL BALANCE AFTER LAST AUTO BALANCE DATE';
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_proc_name);
                    
                        SELECT t.dt_close_balance_tstz + (1 / 24 / 60 / 60)
                          INTO l_dt_open_balance
                          FROM (SELECT ehb.dt_close_balance_tstz,
                                       row_number() over(ORDER BY dt_close_balance_tstz DESC) rn
                                  FROM epis_hidrics_balance ehb
                                 WHERE ehb.id_epis_hidrics = i_epis_hidrics
                                   AND ehb.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_f
                                   AND ehb.flg_close_type <> pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut
                                   AND ehb.dt_close_balance_tstz >= l_dt_close_balance) t
                         WHERE t.rn = 1;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_dt_open_balance := NULL;
                    END;
                END IF;
            
                g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.INS WITH ID_EPIS_HIDRICS_BALANCE: ' || l_next_ehb;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                l_rowids := table_varchar();
                ts_epis_hidrics_balance.ins(id_epis_hidrics_balance_in => l_next_ehb,
                                            id_epis_hidrics_in         => i_epis_hidrics,
                                            id_prof_close_in           => NULL,
                                            flg_status_in              => pk_inp_hidrics_constant.g_epis_hid_balance_r,
                                            total_admin_in             => NULL,
                                            total_elim_in              => NULL,
                                            id_unit_measure_in         => l_unit_measure,
                                            dt_close_balance_tstz_in   => NULL,
                                            dt_open_tstz_in            => nvl(l_dt_open_balance, l_dt_close_balance),
                                            dt_register_tstz_in        => g_sysdate_tstz,
                                            id_prof_last_change_in     => i_prof.id,
                                            dt_eh_balance_in           => g_sysdate_tstz,
                                            rows_out                   => l_rowids);
            
                g_error := 'PROCESS INSERT WITH ID_EPIS_HIDRICS_BALANCE: ' || l_next_ehb;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
            
                g_error := 'UPD EPID_HID_DET WITH NEW ID_EPIS_BAL: ' || l_next_ehb;
                ts_epis_hidrics_det.upd(id_epis_hidrics_balance_in => l_next_ehb,
                                        where_in                   => 'id_epis_hidrics_balance = ' || l_epis_hid_balance || ' ' ||
                                                                      'and dt_execution_tstz > pk_date_utils.get_string_tstz(' ||
                                                                      i_lang || ', ' || 'profissional(' || i_prof.id || ', ' ||
                                                                      i_prof.institution || ', ' || i_prof.software ||
                                                                      '), ''' ||
                                                                      pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                  i_date => nvl(l_dt_open_balance,
                                                                                                                l_dt_close_balance),
                                                                                                  i_prof => i_prof) ||
                                                                      ''', NULL)');
            
                g_error := 'CALL TO GET_TOTAL_HIDRICS; ID_EPIS_HIDRICS_BALANCE: ' || l_next_ehb;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                IF NOT get_total_hidrics(i_lang          => i_lang,
                                         i_epis_hidrics  => i_epis_hidrics,
                                         i_epis_hid_bals => table_number(l_next_ehb),
                                         i_date          => NULL,
                                         o_total_admin   => l_total_a,
                                         o_total_elimin  => l_total_e,
                                         o_times_admin   => l_times_a,
                                         o_times_elimin  => l_times_e,
                                         o_error         => o_error)
                THEN
                    g_error := 'ERROR GET_TOTAL_HIDRICS; ID_EPIS_HIDRICS_BALANCE: ' || l_next_ehb;
                    RAISE e_error;
                END IF;
            
                IF l_total_a > 0
                   OR l_total_e > 0
                THEN
                    g_error := 'UPDATE TOTALS OF NEW BALANCE ID_EPIS_HIDRICS_BALANCE: ' || l_next_ehb;
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_proc_name);
                    ts_epis_hidrics_balance.upd(id_epis_hidrics_balance_in => l_next_ehb,
                                                flg_status_in              => pk_inp_hidrics_constant.g_epis_hid_balance_e,
                                                total_admin_in             => l_total_a,
                                                total_elim_in              => l_total_e,
                                                dt_eh_balance_in           => g_sysdate_tstz,
                                                rows_out                   => l_rowids);
                
                    t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
                END IF;
            
                g_error := 'GET FLGS ASSOCIATED WITH HIDRICS_TYPE INFORMATION TRANSFER BETWEEN EPISODES';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                SELECT ht.flg_ti_type, ht.acronym
                  INTO l_flg_ti_type, l_ht_acronym
                  FROM hidrics_type ht
                 WHERE ht.id_hidrics_type = l_hid_type;
            
                g_error := 'WRITTING INTO STATUS LOG';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                IF (NOT t_ti_log.ins_log(i_lang       => i_lang,
                                         i_prof       => i_prof,
                                         i_id_episode => l_episode,
                                         i_flg_status => pk_inp_hidrics_constant.g_epis_hidric_r,
                                         i_id_record  => i_epis_hidrics,
                                         i_flg_type   => l_flg_ti_type,
                                         o_error      => o_error))
                THEN
                    RAISE t_ti_log_ins_exception;
                END IF;
            
                g_error := 'CALL TO PK_CPOE.SYNC_TASK';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                         i_prof                 => i_prof,
                                         i_episode              => l_episode,
                                         i_task_type            => CASE l_ht_acronym
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_h THEN
                                                                        pk_alert_constant.g_task_type_hidric_in_out
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_d THEN
                                                                        pk_alert_constant.g_task_type_hidric_out
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_r THEN
                                                                        pk_alert_constant.g_task_type_hidric_drain
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_i THEN
                                                                        pk_alert_constant.g_task_type_hidric_in
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_o THEN
                                                                        pk_alert_constant.g_task_type_hidric_out_group
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_all THEN
                                                                        pk_alert_constant.g_task_type_hidric_out_all
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_g THEN
                                                                        pk_alert_constant.g_task_type_hidric_irrigations
                                                                       ELSE
                                                                        NULL
                                                                   END,
                                         i_task_request         => i_epis_hidrics,
                                         i_task_start_timestamp => l_dt_close_balance,
                                         o_error                => o_error)
                THEN
                    RAISE e_error;
                END IF;
            END IF;
            --Update o_epis_hid_bal with the id of the new balance
            o_epis_hid_bal := l_next_ehb;
        END create_new_balance;
    
        PROCEDURE update_hidrics_det
        (
            l_dt_begin_bal epis_hidrics_balance.dt_open_tstz%TYPE,
            l_dt_close_bal epis_hidrics_balance.dt_close_balance_tstz%TYPE
        ) IS
            l_proc_name VARCHAR2(30 CHAR) := 'RECALCULATE_BALANCE';
        
            --
            l_total_a NUMBER(26, 2);
            l_total_e NUMBER(26, 2);
            l_times_a PLS_INTEGER;
            l_times_e PLS_INTEGER;
        
            --
            l_epis_hid_det table_number;
            l_epis_hid_bal table_number;
        BEGIN
        
            SELECT ehd.id_epis_hidrics_det, ehd.id_epis_hidrics_balance
              BULK COLLECT
              INTO l_epis_hid_det, l_epis_hid_bal
              FROM epis_hidrics_det ehd
             WHERE ehd.id_epis_hidrics = i_epis_hidrics
               AND id_epis_hidrics_balance <> l_epis_hid_balance
               AND dt_execution_tstz BETWEEN l_dt_begin_bal AND l_dt_close_bal;
        
            IF l_epis_hid_det.count > 0
            THEN
                g_error := 'SEND TO HIST ID_EPIS_HIDRICS_DET IN (' || pk_utils.concat_table(l_epis_hid_det, ',') || ')';
                pk_alertlog.log_debug(g_error);
                set_epis_hid_det_hist(i_where => 'id_epis_hidrics_det IN (' ||
                                                 pk_utils.concat_table(l_epis_hid_det, ',') || ')');
            
                g_error := 'CALL TS_EPIS_HIDRICS_DET.UPD';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                l_rowids := table_varchar();
                ts_epis_hidrics_det.upd(id_epis_hidrics_balance_in => l_epis_hid_balance,
                                        where_in                   => 'id_epis_hidrics = ' || i_epis_hidrics ||
                                                                      ' AND id_epis_hidrics_balance <> ' ||
                                                                      l_epis_hid_balance ||
                                                                      ' AND id_epis_hidrics_det IN (' ||
                                                                      pk_utils.concat_table(l_epis_hid_det, ',') || ')',
                                        rows_out                   => l_rowids);
                t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS_DET', l_rowids, o_error);
            
                IF NOT get_total_hidrics(i_lang          => i_lang,
                                         i_epis_hidrics  => i_epis_hidrics,
                                         i_epis_hid_bals => table_number(l_epis_hid_bal(1)),
                                         i_date          => NULL,
                                         o_total_admin   => l_total_a,
                                         o_total_elimin  => l_total_e,
                                         o_times_admin   => l_times_a,
                                         o_times_elimin  => l_times_e,
                                         o_error         => o_error)
                THEN
                    g_error := 'ERROR GET_TOTAL_HIDRICS';
                    RAISE e_error;
                END IF;
            
                --
                g_error := 'SEND TO HIST - HIDRICS_BALANCE id_epis_hidrics_balance = ' || l_epis_hid_bal(1);
                pk_alertlog.log_debug(g_error);
                set_epis_hid_bal_hist(i_epis_hidrics_balance => l_epis_hid_bal(1));
                --                    
                g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
            
                l_rowids := table_varchar();
                ts_epis_hidrics_balance.upd(id_epis_hidrics_balance_in => l_epis_hid_bal(1),
                                            total_admin_in             => l_total_a,
                                            total_elim_in              => l_total_e,
                                            dt_register_tstz_in        => g_sysdate_tstz,
                                            id_prof_last_change_in     => i_prof.id,
                                            dt_eh_balance_in           => g_sysdate_tstz,
                                            total_times_in             => l_times_a + l_times_e,
                                            rows_out                   => l_rowids);
            
                g_error := 'PROCESS UPDATE FROM RECALCULATE_BALANCE WITH ID_EPIS_HIDRICS_BALANCE = ' ||
                           l_epis_hid_bal(1);
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
            END IF;
        
        END update_hidrics_det;
    
        PROCEDURE update_manual_balance_dates
        (
            l_id_manual_balance       epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
            l_dt_open_manual_balance  epis_hidrics_balance.dt_open_tstz%TYPE,
            l_dt_close_manual_balance epis_hidrics_balance.dt_open_tstz%TYPE
        ) IS
            l_proc_name VARCHAR2(30 CHAR) := 'UPDATE_MANUAL_BALANCE_DATES';
        BEGIN
            g_error := 'SEND TO HIST - HIDRICS_BALANCE id_epis_hidrics_balance = ' || l_id_manual_balance;
            pk_alertlog.log_debug(g_error);
            set_epis_hid_bal_hist(i_epis_hidrics_balance => l_id_manual_balance);
        
            g_error := 'UPDATE MANUAL DATES OF ID_EPIS_HIDRICS_BALANCE: ' || l_id_manual_balance;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            l_rowids := table_varchar();
            ts_epis_hidrics_balance.upd(id_epis_hidrics_balance_in => l_id_manual_balance,
                                        dt_open_tstz_in            => l_dt_open_manual_balance,
                                        dt_close_balance_tstz_in   => l_dt_close_manual_balance,
                                        rows_out                   => l_rowids);
            t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
        
        END update_manual_balance_dates;
    
        PROCEDURE calculate_balance IS
            l_proc_name VARCHAR2(30 CHAR) := 'CLOSE_BALANCE';
            --
            l_total_a NUMBER(26, 2);
            l_total_e NUMBER(26, 2);
            l_times_a PLS_INTEGER;
            l_times_e PLS_INTEGER;
            --
            l_msg_title  sys_message.desc_message%TYPE;
            l_msg_text   sys_message.desc_message%TYPE;
            l_flg_status epis_hidrics_balance.flg_status%TYPE;
        
            l_manual_hidrics_bals     table_number;
            l_manual_balance          epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
            l_last_auto_bal_dt_close  epis_hidrics_balance.dt_close_balance_tstz%TYPE;
            l_dt_open_balance         epis_hidrics_balance.dt_open_tstz%TYPE;
            l_dt_open_balance_manual  epis_hidrics_balance.dt_open_tstz%TYPE;
            l_dt_close_balance_manual epis_hidrics_balance.dt_close_balance_tstz%TYPE;
        BEGIN
            --if the balance is already closed means that we are recalculating the balance so the close date remains unchanged
            --otherwise the balance is going to be closed with the current_date
            g_error := 'GET DT_CLOSE_BALANCE;  ID_EPIS_HIDRICS_BALANCE: ' || l_epis_hid_balance;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            BEGIN
                --I'm adding 1 second to the close time to prevent that we have two columns with exactly the same time in the
                --flowsheet
                SELECT ehb.dt_open_tstz,
                       decode(eh.flg_status,
                              pk_inp_hidrics_constant.g_epis_hidric_o,
                              eh.dt_cancel_tstz,
                              nvl(ehb.dt_close_balance_tstz, nvl(i_dt_exec, g_sysdate_tstz) + (1 / 24 / 60 / 60))),
                       decode(ehb.flg_status,
                              pk_inp_hidrics_constant.g_epis_hid_balance_r,
                              pk_inp_hidrics_constant.g_epis_hid_balance_e,
                              ehb.flg_status)
                  INTO l_dt_open_balance, l_dt_close_balance, l_flg_status
                  FROM epis_hidrics_balance ehb
                 INNER JOIN epis_hidrics eh
                    ON ehb.id_epis_hidrics = eh.id_epis_hidrics
                 WHERE ehb.id_epis_hidrics_balance = l_epis_hid_balance;
            
            EXCEPTION
                WHEN no_data_found THEN
                    g_error := 'ERROR GET DT_CLOSE_BALANCE; ID_EPIS_HIDRICS_BALANCE: ' || l_epis_hid_balance;
                    RAISE e_error;
            END;
        
            IF l_flg_close = pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut
            THEN
                --when an auto balance must be calculate before an exist manual balance            
                IF l_dt_close_balance < l_dt_open_balance
                THEN
                
                    l_last_auto_bal_dt_close := get_last_auto_bal_dt_close(i_lang         => i_lang,
                                                                           i_prof         => i_prof,
                                                                           i_epis_hidrics => i_epis_hidrics);
                
                    IF l_last_auto_bal_dt_close IS NULL
                    THEN
                        --when there is no auto balance yet
                        --the auto balance open date will be equal the fisrt manual balance open date
                        --and the first manual balance open date will be equal the auto balance close date + 1 second
                        SELECT t.id_epis_hidrics_balance, t.dt_open_tstz, t.dt_close_balance_tstz
                          INTO l_manual_balance, l_dt_open_balance_manual, l_dt_close_balance_manual
                          FROM (SELECT id_epis_hidrics_balance,
                                       ehb.dt_open_tstz,
                                       ehb.dt_close_balance_tstz,
                                       row_number() over(ORDER BY dt_close_balance_tstz ASC) rn
                                  FROM epis_hidrics_balance ehb
                                 WHERE ehb.id_epis_hidrics = i_epis_hidrics
                                   AND ehb.id_epis_hidrics_balance <> l_epis_hid_balance
                                   AND ehb.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_f
                                   AND ehb.flg_close_type <> pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut
                                   AND ehb.dt_close_balance_tstz <=
                                       (SELECT dt_open_tstz
                                          FROM epis_hidrics_balance
                                         WHERE id_epis_hidrics_balance = l_epis_hid_balance)) t
                         WHERE t.rn = 1;
                    
                        l_dt_open_balance        := l_dt_open_balance_manual;
                        l_dt_open_balance_manual := l_dt_close_balance + (1 / 24 / 60 / 60);
                    
                        update_manual_balance_dates(l_manual_balance,
                                                    l_dt_open_balance_manual,
                                                    l_dt_close_balance_manual);
                    ELSE
                        l_dt_open_balance := l_last_auto_bal_dt_close + (1 / 24 / 60 / 60);
                    END IF;
                
                END IF;
            
                --update epis_hidrics_det if needed
                update_hidrics_det(l_dt_open_balance, l_dt_close_balance);
            
                g_error               := 'CALL GET_ALL_MANUAL_BALANCE';
                l_manual_hidrics_bals := get_prev_manual_balances(i_lang                  => i_lang,
                                                                  i_prof                  => i_prof,
                                                                  i_epis_hidrics          => i_epis_hidrics,
                                                                  i_epis_hidrics_balance  => l_epis_hid_balance,
                                                                  i_flg_close_type        => l_flg_close,
                                                                  i_dt_close_balance_tstz => l_dt_close_balance);
            
            ELSE
                IF i_flg_just_cal = pk_alert_constant.g_yes
                THEN
                    l_manual_hidrics_bals := get_prev_manual_balances(i_lang                  => i_lang,
                                                                      i_prof                  => i_prof,
                                                                      i_epis_hidrics          => i_epis_hidrics,
                                                                      i_epis_hidrics_balance  => l_epis_hid_balance,
                                                                      i_flg_close_type        => NULL,
                                                                      i_dt_close_balance_tstz => l_dt_close_balance);
                ELSE
                    l_manual_hidrics_bals := table_number(l_epis_hid_balance);
                END IF;
            END IF;
        
            g_error := 'GET_TOTAL_HIDRICS_BULK I_EPIS_HIDRICS: ' || i_epis_hidrics;
            IF NOT get_total_hidrics(i_lang          => i_lang,
                                     i_epis_hidrics  => i_epis_hidrics,
                                     i_epis_hid_bals => l_manual_hidrics_bals,
                                     i_date          => (CASE i_flg_just_cal
                                                            WHEN pk_alert_constant.g_no THEN
                                                             (CASE l_flg_status
                                                                 WHEN pk_inp_hidrics_constant.g_epis_hid_balance_r THEN
                                                                  l_dt_close_balance
                                                                 WHEN pk_inp_hidrics_constant.g_epis_hid_balance_e THEN
                                                                  l_dt_close_balance
                                                                 ELSE
                                                                  NULL
                                                             END)
                                                            ELSE
                                                             NULL
                                                        END),
                                     o_total_admin   => l_total_a,
                                     o_total_elimin  => l_total_e,
                                     o_times_admin   => l_times_a,
                                     o_times_elimin  => l_times_e,
                                     o_error         => o_error)
            THEN
                g_error := 'ERROR GET_TOTAL_HIDRICS';
                RAISE e_error;
            END IF;
        
            --
            g_error := 'SEND TO HIST - HIDRICS_BALANCE id_epis_hidrics_balance = ' || l_epis_hid_balance;
            pk_alertlog.log_debug(g_error);
            set_epis_hid_bal_hist(i_epis_hidrics_balance => l_epis_hid_balance);
            --                    
            g_error := 'CALL TS_EPIS_HIDRICS_BALANCE.UPD';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            l_rowids := table_varchar();
            IF i_flg_just_cal = pk_alert_constant.g_no
            THEN
                ts_epis_hidrics_balance.upd(id_epis_hidrics_balance_in => l_epis_hid_balance,
                                            dt_open_tstz_in            => l_dt_open_balance,
                                            dt_close_balance_tstz_in   => l_dt_close_balance,
                                            id_prof_close_in           => i_prof.id,
                                            flg_status_in              => pk_inp_hidrics_constant.g_epis_hidric_f,
                                            total_admin_in             => l_total_a,
                                            total_elim_in              => l_total_e,
                                            dt_register_tstz_in        => g_sysdate_tstz,
                                            id_prof_last_change_in     => i_prof.id,
                                            dt_eh_balance_in           => g_sysdate_tstz,
                                            flg_close_type_in          => l_flg_close,
                                            total_times_in             => l_times_a + l_times_e,
                                            rows_out                   => l_rowids);
            ELSE
                ts_epis_hidrics_balance.upd(id_epis_hidrics_balance_in => l_epis_hid_balance,
                                            flg_status_in              => (CASE l_flg_status
                                                                              WHEN
                                                                               pk_inp_hidrics_constant.g_epis_hid_balance_r THEN
                                                                               pk_inp_hidrics_constant.g_epis_hid_balance_e
                                                                              ELSE
                                                                               nvl(l_flg_status,
                                                                                   pk_inp_hidrics_constant.g_epis_hid_balance_e)
                                                                          END),
                                            total_admin_in             => l_total_a,
                                            total_elim_in              => l_total_e,
                                            dt_register_tstz_in        => g_sysdate_tstz,
                                            id_prof_last_change_in     => i_prof.id,
                                            dt_eh_balance_in           => g_sysdate_tstz,
                                            total_times_in             => l_times_a + l_times_e,
                                            rows_out                   => l_rowids);
            END IF;
        
            g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS_BALANCE(3) ' || l_epis_hid_balance;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
        
            g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => 'SET_EPIS_HID_STATUS');
            IF NOT check_restriction_alerts(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_episode      => NULL,
                                            i_epis_hidrics => i_epis_hidrics,
                                            i_epis_balance => l_epis_hid_balance,
                                            i_max_intake   => NULL,
                                            i_min_output   => NULL,
                                            i_hidrics_type => NULL,
                                            i_flg_context  => pk_inp_hidrics_constant.g_context_end_balance,
                                            i_dt_execution => nvl(i_dt_exec, g_sysdate_tstz),
                                            o_msg_title    => l_msg_title,
                                            o_msg_text     => l_msg_text,
                                            o_error        => o_error)
            THEN
                RAISE e_error;
            END IF;
        END calculate_balance;
    
    BEGIN
        g_error := 'GET EPIS_HID_BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_epis_hid_balance := nvl(i_epis_hid_balance,
                                  get_balance_id(i_lang         => i_lang,
                                                 i_prof         => i_prof,
                                                 i_epis_hidrics => i_epis_hidrics,
                                                 i_dt_exec      => nvl(i_dt_exec, g_sysdate_tstz)));
    
        g_error := 'DEFINE CLOSE TYPE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF i_flg_chg_bal_dt IS NULL
        THEN
            l_flg_close := pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut;
        ELSIF i_flg_chg_bal_dt = pk_alert_constant.g_yes
        THEN
            l_flg_close := pk_inp_hidrics_constant.g_epis_hid_bal_closed_man_b;
        ELSIF i_flg_chg_bal_dt = pk_alert_constant.g_no
        THEN
            l_flg_close := pk_inp_hidrics_constant.g_epis_hid_bal_closed_man_c;
        ELSE
            RAISE e_error;
        END IF;
    
        IF l_flg_close = pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut
        THEN
            l_all_hid_balances := get_prev_manual_balances(i_lang                  => i_lang,
                                                           i_prof                  => i_prof,
                                                           i_epis_hidrics          => i_epis_hidrics,
                                                           i_epis_hidrics_balance  => l_epis_hid_balance,
                                                           i_flg_close_type        => l_flg_close,
                                                           i_dt_close_balance_tstz => nvl(i_dt_exec, g_sysdate_tstz) +
                                                                                      (1 / 24 / 60 / 60));
        ELSE
            l_all_hid_balances := table_number(l_epis_hid_balance);
        END IF;
    
        g_error := 'OPEN C_EPIS_HID';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN c_epis_hid(l_all_hid_balances);
        FETCH c_epis_hid
            INTO l_dt_end, l_hid_interv, l_flg_status, l_total_reads;
        CLOSE c_epis_hid;
    
        IF l_total_reads > 0
           OR l_flg_status = pk_inp_hidrics_constant.g_epis_hidric_f
        THEN
            --if epis_hidrics isn't closed
            IF l_flg_status != pk_inp_hidrics_constant.g_epis_hidric_f
               AND i_flg_just_cal = pk_alert_constant.g_no
            THEN
                -- 1 - If dt_end of epis_hidrics was filled
                IF l_dt_end IS NOT NULL
                THEN
                    l_dt_end_ultr := pk_date_utils.get_timestamp_diff(l_dt_end, g_sysdate_tstz);
                
                    -- 1.a - verify if it was exceeded
                    IF (l_dt_end_ultr >= 0)
                    THEN
                        -- 1.a.1(wasn't exceeded) - close current balance and open a new one
                        g_error := 'CALCULATE AND CLOSE_BALANCE(1)';
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        calculate_balance;
                    
                        g_error := 'CREATE_NEW_BALANCE(1)';
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        create_new_balance;
                    ELSE
                        g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || i_epis_hidrics;
                        pk_alertlog.log_debug(g_error);
                        set_epis_hid_hist(i_epis_hidrics => i_epis_hidrics);
                        --
                        -- 1.a.2(was exceeded) - close epis_hidrics and close balance
                        g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH EPIS_HIDRICS(1) = ' || i_epis_hidrics;
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        l_rowids := table_varchar();
                        ts_epis_hidrics.upd(id_epis_hidrics_in     => i_epis_hidrics,
                                            flg_status_in          => pk_inp_hidrics_constant.g_epis_hidric_f,
                                            id_prof_last_change_in => i_prof.id,
                                            dt_epis_hidrics_in     => g_sysdate_tstz,
                                            flg_action_in          => pk_inp_hidrics_constant.g_flg_action_f,
                                            rows_out               => l_rowids);
                    
                        IF NOT cancel_assoc_icnp_interv(i_lang            => i_lang,
                                                        i_prof            => i_prof,
                                                        i_id_epis_hidrics => i_epis_hidrics,
                                                        o_error           => o_error)
                        THEN
                            RAISE l_icnp_interv;
                        END IF;
                    
                        g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS(1) ' || i_epis_hidrics;
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        t_data_gov_mnt.process_update(i_lang,
                                                      i_prof,
                                                      'EPIS_HIDRICS',
                                                      l_rowids,
                                                      o_error,
                                                      table_varchar('FLG_STATUS'));
                    
                        g_error := 'CALCULATE AND CLOSE_BALANCE(2)';
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_func_name);
                        calculate_balance;
                    END IF;
                ELSE
                    -- 2 - When dt_end is null close current balance and open a new one
                    g_error := 'CLOSE_BALANCE(3)';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    calculate_balance;
                
                    g_error := 'CREATE_NEW_BALANCE(2)';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    create_new_balance;
                END IF;
            ELSE
                --if it's closed then recalculate balance
                g_error := 'CLOSE_BALANCE(4)';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                calculate_balance;
            END IF;
        ELSIF i_flg_just_cal = pk_alert_constant.g_no
        THEN
            g_error := 'CALCULATE AND CLOSE_BALANCE(5)';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            calculate_balance;
        
            g_error := 'CREATE_NEW_BALANCE(3)';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            create_new_balance;
        ELSIF i_flg_just_cal = pk_alert_constant.g_yes
        THEN
            g_error := 'CALCULATE AND CLOSE_BALANCE(6)';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            calculate_balance;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN t_ti_log_ins_exception THEN
            DECLARE
                l_error_in      t_error_in := t_error_in();
                l_error_message sys_message.desc_message%TYPE;
            BEGIN
                l_error_message := pk_message.get_message(i_lang, 'COMMON_M001');
            
                l_error_in.set_all(i_lang,
                                   'ERR_WRITTING_LOG',
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   'SET_EPIS_HIDRICS');
                --
                l_error_in.set_action(l_error_message, 'S');
                g_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_utils.undo_changes;
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_balance;

    /**
    * Calculate and closes the current balance and finish epis_hidrics
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   01-06-2010
    */
    FUNCTION set_finish
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        o_flg_show     OUT VARCHAR2,
        o_msg_title    OUT VARCHAR2,
        o_msg          OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'SET_FINISH';
        --
        l_rowids       table_varchar;
        l_epis_hid_bal epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
    
        l_icnp_interv EXCEPTION;
    BEGIN
        g_error := 'check_show_conflict_pop for id_epis_hidrics: ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_show_conflict_pop(i_lang                => i_lang,
                                       i_prof                => i_prof,
                                       i_epis_hidrics        => i_epis_hidrics,
                                       i_epis_hidrics_status => NULL,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg                 => o_msg,
                                       o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF (o_flg_show = pk_alert_constant.get_yes)
        THEN
            RETURN TRUE;
        END IF;
    
        g_error := 'SEND TO HIST ID_EPIS_HIDRICS ' || i_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        set_epis_hid_hist(i_epis_hidrics => i_epis_hidrics);
        --
        g_error := 'CALL TS_EPIS_HIDRICS.UPD DT_END_TSTZ WITH EPIS_HIDRICS(1) = ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_rowids := table_varchar();
        ts_epis_hidrics.upd(id_epis_hidrics_in     => i_epis_hidrics,
                            dt_end_tstz_in         => g_sysdate_tstz,
                            flg_status_in          => pk_inp_hidrics_constant.g_epis_hidric_f,
                            id_prof_last_change_in => i_prof.id,
                            dt_epis_hidrics_in     => g_sysdate_tstz,
                            flg_action_in          => pk_inp_hidrics_constant.g_flg_action_f,
                            rows_out               => l_rowids);
    
        IF NOT cancel_assoc_icnp_interv(i_lang            => i_lang,
                                        i_prof            => i_prof,
                                        i_id_epis_hidrics => i_epis_hidrics,
                                        o_error           => o_error)
        THEN
            RAISE l_icnp_interv;
        END IF;
    
        g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS(1) ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error, table_varchar('DT_END_TSTZ'));
    
        g_error := 'CALL PK_INP_HIDRICS.SET_BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT pk_inp_hidrics.set_balance(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_epis_hidrics => i_epis_hidrics,
                                          o_epis_hid_bal => l_epis_hid_bal,
                                          o_error        => o_error)
        THEN
            RAISE e_error;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_finish;

    /********************************************************************************************
    * GET_ONGOING_TASKS_HIDRIC               Get all tasks available to cancel when a patient dies
    *
    * @param       i_lang                    language id
    * @param       i_prof                    professional information
    * @param       i_patient                 patient id
    *
    * @return       tf_tasks_list            table of tr_tasks_list
    *
    * @author                                Luï¿½Maia                        
    * @version                               2.6.0.3                                    
    * @since                                 2010/Jun/07
    ********************************************************************************************/
    FUNCTION get_ongoing_tasks_hidric
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_patient IN patient.id_patient%TYPE
    ) RETURN tf_tasks_list IS
        l_ongoing_tasks tf_tasks_list;
    
    BEGIN
    
        g_error := 'POPULATE l_ongoing_tasks';
        SELECT tr_tasks_list(hidrics.id_task, hidrics.desc_task, hidrics.epis_type, hidrics.dt_task)
          BULK COLLECT
          INTO l_ongoing_tasks
          FROM (SELECT eh.id_epis_hidrics id_task,
                       decode(epi.id_epis_type,
                              nvl(t_ti_log.get_epis_type(i_lang,
                                                         i_prof,
                                                         epi.id_epis_type,
                                                         pk_inp_hidrics_constant.g_epis_hidric_r,
                                                         eh.id_epis_hidrics,
                                                         ht.flg_ti_type),
                                  epi.id_epis_type),
                              pk_translation.get_translation(i_lang, ht.code_hidrics_type),
                              pk_translation.get_translation(i_lang, ht.code_hidrics_type) || ' (' ||
                              pk_message.get_message(i_lang,
                                                     profissional(i_prof.id,
                                                                  i_prof.institution,
                                                                  t_ti_log.get_epis_type_soft(i_lang,
                                                                                              i_prof,
                                                                                              epi.id_epis_type,
                                                                                              pk_inp_hidrics_constant.g_epis_hidric_r,
                                                                                              eh.id_epis_hidrics,
                                                                                              ht.flg_ti_type)),
                                                     'IMAGE_T009') || ')') desc_task,
                       pk_translation.get_translation(i_lang, et.code_epis_type) epis_type,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                          eh.dt_initial_tstz,
                                                          i_prof.institution,
                                                          i_prof.software) dt_task
                  FROM epis_hidrics eh
                 INNER JOIN episode epi
                    ON (eh.id_episode = epi.id_episode)
                 INNER JOIN epis_type et
                    ON (et.id_epis_type = epi.id_epis_type)
                 INNER JOIN epis_hidrics_balance ehb
                    ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
                 INNER JOIN hidrics_type ht
                    ON (eh.id_hidrics_type = ht.id_hidrics_type)
                --
                 WHERE epi.id_patient = i_patient
                   AND eh.flg_status IN
                       (pk_inp_hidrics_constant.g_epis_hidric_e, pk_inp_hidrics_constant.g_epis_hidric_r)
                   AND ehb.flg_status IN
                       (pk_inp_hidrics_constant.g_epis_hidric_e, pk_inp_hidrics_constant.g_epis_hidric_r)
                 ORDER BY eh.dt_creation_tstz DESC) hidrics;
    
        RETURN l_ongoing_tasks;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_ongoing_tasks_hidric;

    /**
    * Closes or recalculates the inputed balance and opens a new one (when applicable)
    * NOTE: Used only when creating a auto_balance do not use for other purposes
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   i_epis_hid_balance          Epis hidrics balance id (If null means current open balance)
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   01-06-2010
    */
    PROCEDURE set_balance IS
        l_proc_name VARCHAR2(30 CHAR) := 'SET_BALANCE';
        --
        l_aux_epis_hid_bal epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_error            t_error_out;
        l_freq_count       NUMBER;
        l_id_next_balh     epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_last_intk_dt     epis_hidrics_det.dt_execution_tstz%TYPE;
        --
        CURSOR c_epis_hidrics IS
            SELECT a.id_language,
                   profissional(a.id_prof, a.id_institution, a.id_software) i_prof,
                   a.id_epis_hidrics,
                   a.id_epis_hidrics_balance,
                   a.dt_next_balance,
                   numtodsinterval(pk_inp_hidrics.get_epis_hidrics_interval(a.id_language,
                                                                            profissional(a.id_prof,
                                                                                         a.id_institution,
                                                                                         a.id_software),
                                                                            a.interval_minutes,
                                                                            NULL),
                                   'HOUR') balance_interval,
                   pk_inp_hidrics.check_has_executions(i_id_epis_hidrics => a.id_epis_hidrics,
                                                       i_start_date      => a.dt_last_auto_balance,
                                                       i_end_date        => a.dt_next_balance,
                                                       i_cancelled       => pk_alert_constant.g_no,
                                                       i_flg_report      => NULL) has_executions
              FROM (SELECT pk_inp_hidrics.get_last_auto_bal_dt_close(t_int.id_language,
                                                                     profissional(t_int.id_prof,
                                                                                  t_int.id_institution,
                                                                                  t_int.id_software),
                                                                     t_int.id_epis_hidrics) dt_last_auto_balance,
                           t_int.*
                      FROM (SELECT eh.id_epis_hidrics,
                                   (SELECT ehb.id_epis_hidrics_balance
                                      FROM epis_hidrics_balance ehb
                                     WHERE ehb.id_epis_hidrics = eh.id_epis_hidrics
                                       AND ehb.dt_close_balance_tstz IS NULL) id_epis_hidrics_balance,
                                   pk_inp_hidrics.get_dt_next_balance(pp.id_language,
                                                                      profissional(eh.id_prof_last_change,
                                                                                   epis.id_institution,
                                                                                   ei.id_software),
                                                                      eh.id_epis_hidrics) dt_next_balance,
                                   nvl(eh.id_prof_last_change, eh.id_professional) id_prof,
                                   epis.id_institution,
                                   ei.id_software,
                                   nvl(pp.id_language,
                                       pk_utils.get_institution_language(epis.id_institution, ei.id_software)) id_language,
                                   nvl(eh.interval_minutes, hi.interval_minutes) interval_minutes
                              FROM epis_hidrics eh
                              JOIN hidrics_interval hi
                                ON hi.id_hidrics_interval = eh.id_hidrics_interval
                              JOIN episode epis
                                ON epis.id_episode = eh.id_episode
                              JOIN visit v
                                ON v.id_visit = epis.id_visit
                               AND v.flg_status = pk_visit.g_visit_active
                              JOIN epis_info ei
                                ON ei.id_episode = eh.id_episode
                              LEFT JOIN prof_soft_inst psi
                                ON psi.id_professional = nvl(eh.id_prof_last_change, eh.id_professional)
                               AND psi.id_institution = epis.id_institution
                               AND psi.id_software = ei.id_software
                              LEFT JOIN prof_preferences pp
                                ON pp.id_professional = psi.id_professional
                               AND pp.id_institution = psi.id_institution
                               AND pp.id_software = psi.id_software
                             WHERE eh.flg_status = pk_inp_hidrics_constant.g_epis_hidric_e
                               AND hi.flg_type != pk_inp_hidrics_constant.g_hid_interval_type_n -- Not applicable
                               AND (nvl(eh.dt_end_tstz, g_sysdate_tstz) + numtodsinterval(30, 'MINUTE')) > g_sysdate_tstz) t_int
                      JOIN epis_hidrics_balance ehb
                        ON t_int.id_epis_hidrics_balance = ehb.id_epis_hidrics_balance) a
             ORDER BY a.dt_next_balance;
        --
        r_epis_hidrics c_epis_hidrics%ROWTYPE;
        l_rowids       table_varchar;
    BEGIN
        g_error := 'START AUTO_BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
        -- set sysdate because jobs always run on the same session
        g_sysdate_tstz := current_timestamp;
        OPEN c_epis_hidrics;
        <<set_epis_hid_bal>>
        LOOP
            FETCH c_epis_hidrics
                INTO r_epis_hidrics;
            EXIT WHEN c_epis_hidrics%NOTFOUND;
        
            -- JIRA EMR-450 --
            BEGIN
                g_error := 'VERIFY FREQUENCE BALANCE ID_EPIS_HIDRICS = ' || r_epis_hidrics.id_epis_hidrics;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                BEGIN
                    SELECT MAX(d.dt_execution_tstz)
                      INTO l_last_intk_dt
                      FROM epis_hidrics_det d
                     WHERE id_epis_hidrics = r_epis_hidrics.id_epis_hidrics;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_last_intk_dt := to_timestamp(r_epis_hidrics.dt_next_balance);
                END;
            
                SELECT ceil(((extract(hour FROM(l_last_intk_dt - to_timestamp(r_epis_hidrics.dt_next_balance))) * 60) +
                            extract(minute FROM(l_last_intk_dt - to_timestamp(r_epis_hidrics.dt_next_balance)))) /
                            e.interval_minutes) freq
                  INTO l_freq_count
                  FROM epis_hidrics e
                 WHERE id_epis_hidrics = r_epis_hidrics.id_epis_hidrics
                   AND rownum = 1;
            
                IF l_freq_count IS NULL
                   OR l_freq_count < 2
                   OR r_epis_hidrics.dt_next_balance < (current_timestamp - 1)
                THEN
                    l_freq_count := 1;
                END IF;
            
            EXCEPTION
                WHEN OTHERS THEN
                    g_error := 'ERROR CALLING PK_INP_HIDRICS.SET_BALANCE(' || r_epis_hidrics.id_language || ', (' ||
                               r_epis_hidrics.i_prof.id || ', ' || r_epis_hidrics.i_prof.institution || ', ' ||
                               r_epis_hidrics.i_prof.software || '), ' || r_epis_hidrics.id_epis_hidrics || ', ' ||
                               r_epis_hidrics.id_epis_hidrics_balance || '); ORA_SQLCODE: ' || l_error.ora_sqlcode ||
                               '; ORA_SQLERRM: ' || l_error.ora_sqlerrm || '; ERR_DESC: ' || l_error.err_desc || ';';
                
                    pk_alert_exceptions.process_error(i_lang     => r_epis_hidrics.id_language,
                                                      i_sqlcode  => SQLCODE,
                                                      i_sqlerrm  => SQLERRM,
                                                      i_message  => g_error,
                                                      i_owner    => g_package_owner,
                                                      i_package  => g_package_name,
                                                      i_function => l_proc_name,
                                                      o_error    => l_error);
                
                    RAISE e_error;
            END;
        
            /* IF there interval is lower then schedule, re-execute episode to calculate new balances */
            FOR lf IN 1 .. l_freq_count
            LOOP
                IF lf > 1
                THEN
                    /* When not first execution, set new_balance_id and new balance date */
                
                    SELECT MAX(id_epis_hidrics_balance)
                      INTO l_id_next_balh
                      FROM epis_hidrics_balance
                     WHERE id_epis_hidrics = r_epis_hidrics.id_epis_hidrics
                       AND flg_status = 'E';
                
                    r_epis_hidrics.has_executions          := 'Y';
                    r_epis_hidrics.dt_next_balance         := nvl(r_epis_hidrics.dt_next_balance, g_sysdate_tstz) +
                                                              r_epis_hidrics.balance_interval;
                    r_epis_hidrics.id_epis_hidrics_balance := l_id_next_balh;
                
                END IF;
                -- JIRA EMR-450 END --
                g_error := 'VERIFY BALANCE ID_EPIS_HIDRICS = ' || r_epis_hidrics.id_epis_hidrics;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
            
                IF r_epis_hidrics.dt_next_balance <= g_sysdate_tstz
                   AND r_epis_hidrics.has_executions = pk_alert_constant.g_yes
                THEN
                    BEGIN
                        g_error := 'SET BALANCE WITH ID_EPIS_HIDRICS = ' || r_epis_hidrics.id_epis_hidrics;
                        alertlog.pk_alertlog.log_info(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_proc_name);
                        IF NOT pk_inp_hidrics.set_balance(i_lang             => r_epis_hidrics.id_language,
                                                          i_prof             => r_epis_hidrics.i_prof,
                                                          i_epis_hidrics     => r_epis_hidrics.id_epis_hidrics,
                                                          i_epis_hid_balance => r_epis_hidrics.id_epis_hidrics_balance,
                                                          i_dt_exec          => r_epis_hidrics.dt_next_balance,
                                                          i_flg_chg_bal_dt   => NULL,
                                                          o_epis_hid_bal     => l_aux_epis_hid_bal,
                                                          o_error            => l_error)
                        THEN
                            g_error := 'ERROR CALLING PK_INP_HIDRICS.SET_BALANCE(' || r_epis_hidrics.id_language ||
                                       ', (' || r_epis_hidrics.i_prof.id || ', ' || r_epis_hidrics.i_prof.institution || ', ' ||
                                       r_epis_hidrics.i_prof.software || '), ' || r_epis_hidrics.id_epis_hidrics || ', ' ||
                                       r_epis_hidrics.id_epis_hidrics_balance || '); ORA_SQLCODE: ' ||
                                       l_error.ora_sqlcode || '; ORA_SQLERRM: ' || l_error.ora_sqlerrm ||
                                       '; ERR_DESC: ' || l_error.err_desc || ';';
                            RAISE e_error;
                        END IF;
                        COMMIT;
                    EXCEPTION
                        WHEN OTHERS THEN
                            pk_alert_exceptions.process_error(i_lang     => r_epis_hidrics.id_language,
                                                              i_sqlcode  => SQLCODE,
                                                              i_sqlerrm  => SQLERRM,
                                                              i_message  => g_error,
                                                              i_owner    => g_package_owner,
                                                              i_package  => g_package_name,
                                                              i_function => l_proc_name,
                                                              o_error    => l_error);
                            pk_utils.undo_changes;
                    END;
                END IF;
            
                --UPDATE NEXT BALANCE DATE        
                IF r_epis_hidrics.dt_next_balance <= g_sysdate_tstz
                THEN
                    l_rowids := table_varchar();
                    g_error  := 'UPDATE NEXT DT BALANCE OF ID_EPIS_HIDRICS: ' || r_epis_hidrics.id_epis_hidrics ||
                                ' NEXT DATE: ' || to_char(nvl(r_epis_hidrics.dt_next_balance, g_sysdate_tstz) +
                                                          r_epis_hidrics.balance_interval);
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_proc_name);
                    ts_epis_hidrics.upd(id_epis_hidrics_in => r_epis_hidrics.id_epis_hidrics,
                                        dt_next_balance_in => nvl(r_epis_hidrics.dt_next_balance, g_sysdate_tstz) +
                                                              r_epis_hidrics.balance_interval,
                                        dt_epis_hidrics_in => g_sysdate_tstz,
                                        rows_out           => l_rowids);
                
                    g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS ' || r_epis_hidrics.id_epis_hidrics;
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_proc_name);
                
                    t_data_gov_mnt.process_update(r_epis_hidrics.id_language,
                                                  r_epis_hidrics.i_prof,
                                                  'EPIS_HIDRICS',
                                                  l_rowids,
                                                  l_error);
                
                    COMMIT;
                END IF;
            
            END LOOP; -- JIRA EMR-450 END --
        END LOOP set_epis_hid_bal;
        CLOSE c_epis_hidrics;
    END set_balance;

    /**
    * The purpose of this function is to give to flash the hidrics default values
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   o_dft_values                Cursor with all deft values
    * @param   o_error                     error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   08-06-2010
    */
    FUNCTION get_hidrics_dft_values
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        o_dft_values OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_HIDRICS_DFT_VALUES';
    BEGIN
        g_error := 'GET HIDRICS DEFAULT VALUES';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_dft_values FOR
            SELECT g_cfg_auto_balance "KEY", pk_sysconfig.get_config(g_cfg_auto_balance, i_prof) "VALUE"
              FROM dual;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_dft_values);
            RETURN FALSE;
    END get_hidrics_dft_values;

    /**
    * The purpose of this function is to give to flash the default interval and next balance date
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_episode                   Episode id
    * @param   i_dt_begin                  Start date
    * @param   o_dft_values                Cursor with all deft values
    * @param   o_error                     error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   08-06-2010
    */
    FUNCTION get_hidrics_dft_creation
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_episode    IN episode.id_episode%TYPE,
        i_dt_begin   IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp,
        o_dft_values OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_HIDRICS_DFT_CREATION';
        --
        l_inst       institution.id_institution%TYPE;
        l_soft       software.id_software%TYPE;
        l_department department.id_department%TYPE;
        l_dept       dept.id_dept%TYPE;
        l_id_market  market.id_market%TYPE;
        --
        g_date_format VARCHAR2(24 CHAR) := 'DD-MM-YYYY';
        g_hour_format VARCHAR2(24 CHAR) := 'HH24:MI';
    BEGIN
        g_error := 'GET CONF VARS - INTERVAL';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => i_episode,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_i,
                             o_inst       => l_inst,
                             o_soft       => l_soft,
                             o_department => l_department,
                             o_dept       => l_dept,
                             o_id_market  => l_id_market,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        g_error := 'GET HIDRICS DEFAULT VALUES';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_dft_values FOR
            SELECT hid.id_hidrics_interval,
                   pk_translation.get_translation(i_lang,
                                                  'HIDRICS_INTERVAL.CODE_HIDRICS_INTERVAL.' || hid.id_hidrics_interval) desc_hid_interval,
                   pk_date_utils.date_send_tsz(i_lang,
                                               nvl2(hid.dt_def_next_balance,
                                                    -- if  hid.dt_def_next_balance is not null
                                                    
                                                    decode(pk_date_utils.compare_dates_tsz(i_prof,
                                                                                           i_dt_begin,
                                                                                           to_date(to_char(i_dt_begin,
                                                                                                           g_date_format) || ' ' ||
                                                                                                   to_char(hid.dt_def_next_balance,
                                                                                                           g_hour_format),
                                                                                                   g_date_format || ' ' ||
                                                                                                   g_hour_format)),
                                                           'G',
                                                           -- if current date (start date) is later than hid.dt_def_next_balance
                                                           -- verify if start date + interval minutes is later than next day at hid.dt_def_next_balance
                                                           decode(pk_date_utils.compare_dates_tsz(i_prof,
                                                                                                  get_next_balance_date(i_lang             => i_lang,
                                                                                                                        i_prof             => i_prof,
                                                                                                                        i_date             => i_dt_begin,
                                                                                                                        i_interval_minutes => hi.interval_minutes),
                                                                                                  (to_date(to_char(i_dt_begin + 1,
                                                                                                                   g_date_format) || ' ' ||
                                                                                                           to_char(hid.dt_def_next_balance,
                                                                                                                   g_hour_format),
                                                                                                           g_date_format || ' ' ||
                                                                                                           g_hour_format))),
                                                                  'G',
                                                                  -- if yes use  next day at hid.dt_def_next_balance
                                                                  (to_date(to_char(i_dt_begin + 1, g_date_format) || ' ' ||
                                                                           to_char(hid.dt_def_next_balance, g_hour_format),
                                                                           g_date_format || ' ' || g_hour_format)),
                                                                  -- else use begin date + interval in minutes
                                                                  
                                                                  get_next_balance_date(i_lang             => i_lang,
                                                                                        i_prof             => i_prof,
                                                                                        i_date             => i_dt_begin,
                                                                                        i_interval_minutes => hi.interval_minutes)),
                                                           to_date(to_char(i_dt_begin, g_date_format) || ' ' ||
                                                                   to_char(hid.dt_def_next_balance, g_hour_format),
                                                                   g_date_format || ' ' || g_hour_format)),
                                                    get_next_balance_date(i_lang             => i_lang,
                                                                          i_prof             => i_prof,
                                                                          i_date             => i_dt_begin,
                                                                          i_interval_minutes => hi.interval_minutes)),
                                               i_prof) dt_def_next_balance
              FROM hidrics_configurations hid
              JOIN hidrics_interval hi
                ON hi.id_hidrics_interval = hid.id_hidrics_interval
             WHERE hi.flg_available = pk_alert_constant.g_yes
               AND hid.id_institution = l_inst
               AND hid.id_department = l_department
               AND hid.id_dept = l_dept
               AND hid.id_market = l_id_market;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_cfg_vars_not_defined THEN
            pk_types.open_my_cursor(o_dft_values);
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_dft_values);
            RETURN FALSE;
    END get_hidrics_dft_creation;

    /**
    * Cancels a epis_hidrics registry
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   i_cancel_reason             Reason for cancellation
    * @param   i_cancel_notes              Cancellation notes
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   10-06-2010
    */
    FUNCTION cancel_epis_hidrics
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_cancel_reason    IN epis_hidrics.id_cancel_reason%TYPE,
        i_cancel_notes     IN epis_hidrics.notes_cancel%TYPE,
        i_flg_status_force IN epis_hidrics.flg_status%TYPE DEFAULT NULL,
        o_flg_show         OUT VARCHAR2,
        o_msg_title        OUT VARCHAR2,
        o_msg              OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'CANCEL_EPIS_HIDRICS';
        --
        l_episode       episode.id_episode%TYPE;
        l_eh_new_status epis_hidrics_det.flg_status%TYPE;
        l_eh_status     epis_hidrics.flg_status%TYPE;
        l_ht_acronym    hidrics_type.acronym%TYPE;
    
        l_msg_title sys_message.desc_message%TYPE;
        l_msg_text  sys_message.desc_message%TYPE;
    
        l_rowids table_varchar;
    
        l_icnp_interv EXCEPTION;
    
        CURSOR c_epis_balance IS
            SELECT eb.id_epis_hidrics_balance
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics = i_epis_hidrics;
    BEGIN
        g_error := 'check_show_conflict_pop for id_epis_hidrics: ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_show_conflict_pop(i_lang                => i_lang,
                                       i_prof                => i_prof,
                                       i_epis_hidrics        => i_epis_hidrics,
                                       i_epis_hidrics_status => NULL,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg                 => o_msg,
                                       o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF (o_flg_show = pk_alert_constant.get_yes)
        THEN
            RETURN TRUE;
        END IF;
    
        g_error := 'VERIFY STATUS. ID_EPIS_HIDRICS: ' || i_epis_hidrics;
        SELECT eh.flg_status, eh.id_episode, ht.acronym
          INTO l_eh_status, l_episode, l_ht_acronym
          FROM epis_hidrics eh
          JOIN hidrics_type ht
            ON ht.id_hidrics_type = eh.id_hidrics_type
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        IF l_eh_status IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_l)
        THEN
            l_eh_new_status := pk_inp_hidrics_constant.g_epis_hidric_c;
        ELSIF l_eh_status = pk_inp_hidrics_constant.g_epis_hidric_e
        THEN
            l_eh_new_status := pk_inp_hidrics_constant.g_epis_hidric_i;
        ELSIF l_eh_status = pk_inp_hidrics_constant.g_epis_hidric_d
        THEN
            IF i_flg_status_force IS NOT NULL
            THEN
                l_eh_new_status := i_flg_status_force;
            ELSE
                l_eh_new_status := pk_inp_hidrics_constant.g_epis_hidric_l;
            END IF;
        ELSE
            g_error := 'TRYING TO CANCEL ID_EPIS_HIDRICS: ' || i_epis_hidrics || '; WITH STATUS: ' || l_eh_status;
            RAISE e_error;
        END IF;
    
        --
        g_error := 'SEND TO HIST - EPIS_HIDRICS_BALANCE i_where: id_epis_hidrics = ' || i_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        set_epis_hid_bal_hist(i_where => 'id_epis_hidrics = ' || i_epis_hidrics);
        --
        g_error := 'CANCEL ALL EPIS_HIDRICS_BALANCE''s ID_EPIS_HIDRICS: ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        ts_epis_hidrics_balance.upd(where_in                 => 'id_epis_hidrics = ' || i_epis_hidrics || --
                                                                ' AND flg_status in (''' ||
                                                                pk_inp_hidrics_constant.g_epis_hid_balance_r ||
                                                                ''', ''' ||
                                                                pk_inp_hidrics_constant.g_epis_hid_balance_e || ''')',
                                    flg_status_in            => (CASE l_eh_new_status
                                                                    WHEN pk_inp_hidrics_constant.g_epis_hidric_c THEN
                                                                     pk_inp_hidrics_constant.g_epis_hid_balance_c
                                                                    WHEN pk_inp_hidrics_constant.g_epis_hidric_l THEN
                                                                     pk_inp_hidrics_constant.g_epis_hid_balance_c
                                                                    ELSE
                                                                     pk_inp_hidrics_constant.g_epis_hid_balance_i
                                                                END),
                                    dt_close_balance_tstz_in => g_sysdate_tstz,
                                    id_prof_last_change_in   => i_prof.id,
                                    dt_eh_balance_in         => g_sysdate_tstz,
                                    rows_out                 => l_rowids);
    
        g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rowids, o_error);
        --    
        g_error := 'SEND TO HIST - EPIS_HIDRICS i_where: id_epis_hidrics = ' || i_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        set_epis_hid_hist(i_where => 'id_epis_hidrics = ' || i_epis_hidrics);
        --
        IF l_eh_new_status IN (pk_inp_hidrics_constant.g_epis_hidric_c, pk_inp_hidrics_constant.g_epis_hidric_l)
        THEN
            g_error := 'CANCEL EPIS_HIDRICS ID_EPIS_HIDRICS: ' || i_epis_hidrics;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            l_rowids := table_varchar();
            ts_epis_hidrics.upd(id_epis_hidrics_in     => i_epis_hidrics,
                                id_prof_cancel_in      => i_prof.id,
                                id_cancel_reason_in    => i_cancel_reason,
                                notes_cancel_in        => i_cancel_notes,
                                flg_status_in          => l_eh_new_status,
                                dt_cancel_tstz_in      => g_sysdate_tstz,
                                id_prof_last_change_in => i_prof.id,
                                flg_action_in          => l_eh_new_status,
                                dt_epis_hidrics_in     => g_sysdate_tstz,
                                rows_out               => l_rowids);
        
            g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS CANCEL ' || i_epis_hidrics;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            t_data_gov_mnt.process_update(i_lang,
                                          i_prof,
                                          'EPIS_HIDRICS',
                                          l_rowids,
                                          o_error,
                                          table_varchar('ID_PROF_CANCEL',
                                                        'ID_CANCEL_REASON',
                                                        'NOTES_CANCEL',
                                                        'FLG_STATUS',
                                                        'DT_CANCEL_TSTZ',
                                                        'ID_PROF_LAST_CHANGE',
                                                        'FLG_ACTION',
                                                        'DT_EPIS_HIDRICS'));
        
        ELSE
            g_error := 'INTER EPIS_HIDRICS ID_EPIS_HIDRICS: ' || i_epis_hidrics;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            ts_epis_hidrics.upd(id_epis_hidrics_in     => i_epis_hidrics,
                                id_prof_inter_in       => i_prof.id,
                                id_cancel_reason_in    => i_cancel_reason,
                                notes_inter_in         => i_cancel_notes,
                                flg_status_in          => l_eh_new_status,
                                dt_inter_tstz_in       => g_sysdate_tstz,
                                id_prof_last_change_in => i_prof.id,
                                flg_action_in          => l_eh_new_status,
                                dt_epis_hidrics_in     => g_sysdate_tstz,
                                rows_out               => l_rowids);
        
            g_error := 'PROCESS UPDATE WITH ID_EPIS_HIDRICS INTER ' || i_epis_hidrics;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            t_data_gov_mnt.process_update(i_lang,
                                          i_prof,
                                          'EPIS_HIDRICS',
                                          l_rowids,
                                          o_error,
                                          table_varchar('ID_PROF_INTER',
                                                        'ID_CANCEL_REASON',
                                                        'NOTES_INTER',
                                                        'FLG_STATUS',
                                                        'DT_INTER_TSTZ',
                                                        'ID_PROF_LAST_CHANGE',
                                                        'FLG_ACTION',
                                                        'DT_EPIS_HIDRICS'));
        END IF;
    
        IF l_eh_new_status IN (pk_inp_hidrics_constant.g_epis_hidric_c,
                               pk_inp_hidrics_constant.g_epis_hidric_i,
                               pk_inp_hidrics_constant.g_epis_hidric_o)
        THEN
            IF NOT cancel_assoc_icnp_interv(i_lang            => i_lang,
                                            i_prof            => i_prof,
                                            i_id_epis_hidrics => i_epis_hidrics,
                                            o_error           => o_error)
            THEN
                RAISE l_icnp_interv;
            END IF;
        END IF;
    
        g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
        FOR r_balance IN c_epis_balance
        LOOP
            IF NOT check_restriction_alerts(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_episode      => NULL,
                                            i_epis_hidrics => i_epis_hidrics,
                                            i_epis_balance => r_balance.id_epis_hidrics_balance,
                                            i_max_intake   => NULL,
                                            i_min_output   => NULL,
                                            i_hidrics_type => NULL,
                                            i_flg_context  => pk_inp_hidrics_constant.g_context_new_record,
                                            i_dt_execution => NULL,
                                            o_msg_title    => l_msg_title,
                                            o_msg_text     => l_msg_text,
                                            o_error        => o_error)
            THEN
                RAISE e_error;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END cancel_epis_hidrics;

    /**
    * Cancels a epis_hidrics_line registry
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics_line         Epis hidrics line id
    * @param   i_cancel_reason             Reason for cancellation
    * @param   i_cancel_notes              Cancellation notes
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   10-06-2010
    */
    FUNCTION cancel_epis_hidrics_line
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_epis_hidrics_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_cancel_reason     IN epis_hidrics.id_cancel_reason%TYPE,
        i_cancel_notes      IN epis_hidrics.notes_cancel%TYPE,
        o_flg_show          OUT VARCHAR2,
        o_msg_title         OUT VARCHAR2,
        o_msg               OUT VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'CANCEL_EPIS_HIDRICS_LINE';
        --
        l_tab_eh_det   table_number;
        l_tab_eh_bal   table_number;
        l_epis_hidrics epis_hidrics.id_epis_hidrics%TYPE;
        l_aux          epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_count        PLS_INTEGER;
        l_msg_title    sys_message.desc_message%TYPE;
        l_msg_text     sys_message.desc_message%TYPE;
    
        CURSOR c_epis_balance IS
            SELECT eb.id_epis_hidrics_balance
              FROM epis_hidrics_balance eb
             WHERE eb.id_epis_hidrics = l_epis_hidrics;
    
    BEGIN
        g_error := 'GET EPIS HIDRICS';
        SELECT ehl.id_epis_hidrics
          INTO l_epis_hidrics
          FROM epis_hidrics_line ehl
         WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line;
    
        g_error := 'check_show_conflict_pop for id_epis_hidrics: ' || l_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_show_conflict_pop(i_lang                => i_lang,
                                       i_prof                => i_prof,
                                       i_epis_hidrics        => l_epis_hidrics,
                                       i_epis_hidrics_status => NULL,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg                 => o_msg,
                                       o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF (o_flg_show = pk_alert_constant.get_yes)
        THEN
            RETURN TRUE;
        END IF;
    
        g_error := 'GET ALL EPIS_HID_DET OF LINE: ' || i_epis_hidrics_line;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT ehd.id_epis_hidrics_det, ehd.id_epis_hidrics_balance
          BULK COLLECT
          INTO l_tab_eh_det, l_tab_eh_bal
          FROM epis_hidrics_det ehd
         WHERE ehd.id_epis_hidrics_line = i_epis_hidrics_line
           AND ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a;
    
        g_error := 'SEND TO HIST ID_EPIS_HIDRICS_LINE ' || i_epis_hidrics_line;
        pk_alertlog.log_debug(g_error);
        set_epis_hid_line_hist(i_epis_hidrics_line => i_epis_hidrics_line);
        --
        g_error := 'CANCEL EPIS_HID_LINE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        ts_epis_hidrics_line.upd(id_epis_hidrics_line_in => i_epis_hidrics_line,
                                 flg_status_in           => pk_inp_hidrics_constant.g_epis_hid_lin_status_c,
                                 id_prof_cancel_in       => i_prof.id,
                                 id_prof_cancel_nin      => FALSE,
                                 id_cancel_reason_in     => i_cancel_reason,
                                 id_cancel_reason_nin    => FALSE,
                                 notes_cancel_in         => i_cancel_notes,
                                 notes_cancel_nin        => FALSE,
                                 dt_cancel_in            => g_sysdate_tstz,
                                 dt_cancel_nin           => FALSE,
                                 id_prof_last_change_in  => i_prof.id,
                                 flg_action_in           => pk_inp_hidrics_constant.g_flg_action_c,
                                 dt_epis_hidrics_line_in => g_sysdate_tstz);
    
        l_count := l_tab_eh_det.first;
        <<epis_hidrics_det_loop>>
        WHILE l_count IS NOT NULL
        LOOP
            g_error := 'SEND TO HIST ID_EPIS_HIDRICS_DET ' || l_tab_eh_det(l_count);
            pk_alertlog.log_debug(g_error);
            set_epis_hid_det_hist(i_epis_hidrics_det => l_tab_eh_det(l_count));
            --
            g_error := 'CANCEL EPIS_HIDRICS_DET ID_EPIS_HIDRICS_DET: ' || l_tab_eh_det(l_count);
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            ts_epis_hidrics_det.upd(id_epis_hidrics_det_in => l_tab_eh_det(l_count),
                                    id_prof_cancel_in      => i_prof.id,
                                    id_cancel_reason_in    => i_cancel_reason,
                                    notes_cancel_in        => i_cancel_notes,
                                    flg_status_in          => pk_inp_hidrics_constant.g_epis_hid_det_status_c,
                                    dt_cancel_tstz_in      => g_sysdate_tstz,
                                    id_prof_last_change_in => i_prof.id,
                                    flg_action_in          => pk_inp_hidrics_constant.g_flg_action_c,
                                    dt_epis_hidrics_det_in => g_sysdate_tstz);
        
            l_count := l_tab_eh_det.next(l_count);
        END LOOP epis_hidrics_det_loop;
    
        g_error := 'REMOVE DUPLICATED BALANCES';
        pk_alertlog.log_debug(g_error);
        l_tab_eh_bal := l_tab_eh_bal MULTISET UNION DISTINCT l_tab_eh_bal;
    
        l_count := l_tab_eh_bal.first;
        <<epis_hid_bal_loop>>
        WHILE l_count IS NOT NULL
        LOOP
            --
            g_error := 'SEND TO HIST ID_EPIS_HIDRICS_BALANCE ' || l_tab_eh_bal(l_count);
            pk_alertlog.log_debug(g_error);
            set_epis_hid_bal_hist(i_epis_hidrics_balance => l_tab_eh_bal(l_count));
            --
            g_error := 'UPDATE BALANCE ID_EPIS_GRID_BAL: ' || l_tab_eh_bal(l_count);
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF NOT pk_inp_hidrics.set_balance(i_lang             => i_lang,
                                              i_prof             => i_prof,
                                              i_epis_hidrics     => l_epis_hidrics,
                                              i_epis_hid_balance => l_tab_eh_bal(l_count),
                                              i_flg_just_cal     => pk_alert_constant.g_yes,
                                              o_epis_hid_bal     => l_aux,
                                              o_error            => o_error)
            THEN
                RAISE e_error;
            END IF;
        
            l_count := l_tab_eh_bal.next(l_count);
        END LOOP epis_hid_bal_loop;
    
        g_error := 'k_inp_hidrics_groups.cancel_group_line_association. i_epis_hidrics_line: ' || i_epis_hidrics_line;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT pk_inp_hidrics_groups.cancel_group_line_association(i_lang              => i_lang,
                                                                   i_prof              => i_prof,
                                                                   i_epis_hidrics_line => i_epis_hidrics_line,
                                                                   o_error             => o_error)
        THEN
            RAISE e_error;
        END IF;
    
        g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        FOR r_balance IN c_epis_balance
        LOOP
            IF NOT check_restriction_alerts(i_lang         => i_lang,
                                            i_prof         => i_prof,
                                            i_episode      => NULL,
                                            i_epis_hidrics => l_epis_hidrics,
                                            i_epis_balance => r_balance.id_epis_hidrics_balance,
                                            i_max_intake   => NULL,
                                            i_min_output   => NULL,
                                            i_hidrics_type => NULL,
                                            i_flg_context  => pk_inp_hidrics_constant.g_context_new_record,
                                            i_dt_execution => NULL,
                                            o_msg_title    => l_msg_title,
                                            o_msg_text     => l_msg_text,
                                            o_error        => o_error)
            THEN
                RAISE e_error;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END cancel_epis_hidrics_line;

    /**
    * Cancels a epis_hidrics_det registry
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics_det          Epis hidrics det id
    * @param   i_cancel_reason             Reason for cancellation
    * @param   i_cancel_notes              Cancellation notes
    * @param   o_flg_show                  Y- should be shown an error popup
    * @param   o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   10-06-2010
    */
    FUNCTION cancel_epis_hidrics_det
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        i_cancel_reason    IN epis_hidrics_det.id_cancel_reason%TYPE,
        i_cancel_notes     IN epis_hidrics_det.notes_cancel%TYPE,
        o_flg_show         OUT VARCHAR2,
        o_msg_title        OUT VARCHAR2,
        o_msg              OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'CANCEL_EPIS_HIDRICS_DET';
        --
        l_is_to_updt_bal   BOOLEAN;
        l_epis_hidrics     epis_hidrics_det.id_epis_hidrics%TYPE;
        l_epis_hidrics_bal epis_hidrics_det.id_epis_hidrics_balance%TYPE;
        l_aux              epis_hidrics_det.id_epis_hidrics_balance%TYPE;
        --
        l_epis_hid_det_coll epis_hidrics_det.id_epis_hid_collector%TYPE;
        l_value_hidrics     epis_hidrics_det.value_hidrics%TYPE;
        l_curr_level        epis_hid_collector.curr_level%TYPE;
        --
        l_msg_title sys_message.desc_message%TYPE;
        l_msg_text  sys_message.desc_message%TYPE;
    BEGIN
        g_error := 'GET BALANCE ID';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT ed.id_epis_hidrics_balance, ed.id_epis_hidrics
          INTO l_epis_hidrics_bal, l_epis_hidrics
          FROM epis_hidrics_det ed
         WHERE ed.id_epis_hidrics_det = i_epis_hidrics_det;
    
        g_error := 'check_show_conflict_pop for id_epis_hidrics: ' || l_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_show_conflict_pop(i_lang                => i_lang,
                                       i_prof                => i_prof,
                                       i_epis_hidrics        => l_epis_hidrics,
                                       i_epis_hidrics_status => NULL,
                                       o_flg_show            => o_flg_show,
                                       o_msg_title           => o_msg_title,
                                       o_msg                 => o_msg,
                                       o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF (o_flg_show = pk_alert_constant.get_yes)
        THEN
            RETURN TRUE;
        END IF;
    
        g_error := 'VERIFY IF IS TO UPDT BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_is_to_updt_bal := is_to_update_balance(i_epis_hidrics_det => i_epis_hidrics_det,
                                                 i_flg_status       => pk_inp_hidrics_constant.g_epis_hid_det_status_c);
    
        g_error := 'SEND TO HIST ID_EPIS_HIDRICS_DET ' || i_epis_hidrics_det;
        pk_alertlog.log_debug(g_error);
        set_epis_hid_det_hist(i_epis_hidrics_det => i_epis_hidrics_det);
        --
        g_error := 'CANCEL EPIS_HIDRICS_DET ID_EPIS_HIDRICS_DET: ' || i_epis_hidrics_det;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        ts_epis_hidrics_det.upd(id_epis_hidrics_det_in => i_epis_hidrics_det,
                                id_prof_cancel_in      => i_prof.id,
                                id_cancel_reason_in    => i_cancel_reason,
                                notes_cancel_in        => i_cancel_notes,
                                flg_status_in          => pk_inp_hidrics_constant.g_epis_hid_det_status_c,
                                dt_cancel_tstz_in      => g_sysdate_tstz,
                                id_prof_last_change_in => i_prof.id,
                                flg_action_in          => pk_inp_hidrics_constant.g_flg_action_c,
                                dt_epis_hidrics_det_in => g_sysdate_tstz);
    
        IF l_is_to_updt_bal
        THEN
            g_error := 'SEND TO HIST ID_EPIS_HIDRICS_BALANCE ' || l_epis_hidrics_bal;
            pk_alertlog.log_debug(g_error);
            set_epis_hid_bal_hist(i_epis_hidrics_balance => l_epis_hidrics_bal);
            --
            g_error := 'CHANGES WERE MADE, SO UPDATE BALANCE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF NOT pk_inp_hidrics.set_balance(i_lang             => i_lang,
                                              i_prof             => i_prof,
                                              i_epis_hidrics     => l_epis_hidrics,
                                              i_epis_hid_balance => l_epis_hidrics_bal,
                                              i_flg_just_cal     => pk_alert_constant.g_yes,
                                              o_epis_hid_bal     => l_aux,
                                              o_error            => o_error)
            THEN
                RAISE e_error;
            END IF;
        END IF;
    
        g_error := 'CALL TO CHECK_RESTRICTION_ALERTS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT check_restriction_alerts(i_lang         => i_lang,
                                        i_prof         => i_prof,
                                        i_episode      => NULL,
                                        i_epis_hidrics => l_epis_hidrics,
                                        i_epis_balance => l_epis_hidrics_bal,
                                        i_max_intake   => NULL,
                                        i_min_output   => NULL,
                                        i_hidrics_type => NULL,
                                        i_flg_context  => pk_inp_hidrics_constant.g_context_new_record,
                                        i_dt_execution => NULL,
                                        o_msg_title    => l_msg_title,
                                        o_msg_text     => l_msg_text,
                                        o_error        => o_error)
        THEN
            RAISE e_error;
        END IF;
    
        g_error := 'GET COLLECTOR';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT ehd.id_epis_hid_collector, ehd.value_hidrics, ehc.curr_level
          INTO l_epis_hid_det_coll, l_value_hidrics, l_curr_level
          FROM epis_hidrics_det ehd
          LEFT JOIN epis_hid_collector ehc
            ON ehc.id_epis_hid_collector = ehd.id_epis_hid_collector
         WHERE ehd.id_epis_hidrics_det = i_epis_hidrics_det;
    
        IF l_epis_hid_det_coll IS NOT NULL
        THEN
            g_error := 'SEND TO HIST ID_EPIS_HID_COLLECTOR ' || l_epis_hid_det_coll;
            pk_alertlog.log_debug(g_error);
            set_epis_hid_col_hist(i_epis_hid_collector => l_epis_hid_det_coll);
        
            l_curr_level := l_curr_level - l_value_hidrics;
        
            ts_epis_hid_collector.upd(id_epis_hid_collector_in => l_epis_hid_det_coll,
                                      curr_level_in            => l_curr_level,
                                      id_prof_in               => i_prof.id,
                                      dt_epis_hid_collector_in => g_sysdate_tstz);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END cancel_epis_hidrics_det;

    /**
    * Saves hidrics history
    *
    * @param   i_epis_hidrics              epis_hidrics id
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE set_epis_hid_hist
    (
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE DEFAULT NULL,
        i_where        IN VARCHAR2 DEFAULT NULL,
        i_flg_status   IN VARCHAR2 DEFAULT NULL
    ) IS
        l_proc_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_HIST';
        --
        l_sql               VARCHAR2(32767);
        l_tab_epis_hid_hist ts_epis_hidrics_hist.epis_hidrics_hist_tc;
        l_aux_tab           table_number;
    BEGIN
        g_error := 'GET EPIS_HIDRICS DATA. ID_EPIS_HIDRICS: ' || i_epis_hidrics || '; I_WHERE: ' || i_where ||
                   '; I_FLG_STATUS: ' || i_flg_status;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
        l_sql := '' || --
                 'SELECT e.id_epis_hidrics, ' || --
                 '       :g_sysdate_tstz, ' || --
                 '       e.id_hidrics_type, ' || --
                 '       e.id_professional, ' || --
                 '       e.id_episode, ' || --
                 '       e.id_hidrics_interval, ' || --                 
                 '       e.flg_status, ' || --
                 '       e.notes, ' || --
                 '       e.id_prof_cancel, ' || --
                 '       e.notes_cancel, ' || --
                 '       e.id_prof_inter, ' || --
                 '       e.notes_inter, ' || --                 
                 '       e.dt_creation_tstz, ' || --
                 '       e.dt_initial_tstz, ' || --
                 '       e.dt_end_tstz, ' || --
                 '       e.dt_cancel_tstz, ' || --
                 '       e.dt_inter_tstz, ' || --
                 '       e.flg_restricted, ' || --
                 '       e.max_intake, ' || --
                 '       e.min_output, ' || --                 
                 '       e.dt_next_balance, ' || --
                 '       e.id_patient, ' || --
                 '       e.id_cancel_reason, ' || --
                 '       NULL create_user, ' || --
                 '       NULL create_time, ' || --
                 '       NULL create_institution, ' || --
                 '       NULL update_user, ' || --
                 '       NULL update_time, ' || --
                 '       NULL update_institution, ' || --
                 '       e.id_prof_last_change, ' || --
                 '       e.dt_epis_hidrics, ' || --                                                   
                 '       e.interval_minutes, ' || --
                 '       e.flg_action ' || --                 
                 'FROM   epis_hidrics e ' || --
                 'WHERE  e.id_epis_hidrics NOT IN (SELECT column_value FROM TABLE(:g_epis_hid_hist)) AND e.flg_status !=''' ||
                 pk_inp_hidrics_constant.g_epis_hidric_pd || ''' ';
    
        IF i_epis_hidrics IS NOT NULL
        THEN
            l_sql := l_sql || 'AND e.id_epis_hidrics = ' || i_epis_hidrics || ' ';
        END IF;
    
        IF i_where IS NOT NULL
        THEN
            l_sql := l_sql || 'AND ' || i_where;
        END IF;
    
        EXECUTE IMMEDIATE l_sql BULK COLLECT
            INTO l_tab_epis_hid_hist
            USING g_sysdate_tstz, g_epis_hid_hist;
    
        IF l_tab_epis_hid_hist.count > 0
        THEN
            g_error := 'SAVE ID''s SENT TO HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            l_aux_tab := table_number();
            <<fill_aux_tab>>
            FOR i IN l_tab_epis_hid_hist.first .. l_tab_epis_hid_hist.last
            LOOP
                add_value(l_aux_tab, l_tab_epis_hid_hist(i).id_epis_hidrics);
            END LOOP fill_aux_tab;
        
            g_epis_hid_hist := g_epis_hid_hist MULTISET UNION DISTINCT l_aux_tab;
        
            g_error := 'SAVE HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            ts_epis_hidrics_hist.ins(rows_in => l_tab_epis_hid_hist);
        END IF;
    END set_epis_hid_hist;

    /**
    * Saves hidrics values history
    *
    * @param   i_epis_hidrics_det              epis_hidrics_det id
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE set_epis_hid_det_hist
    (
        i_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE DEFAULT NULL,
        i_where            IN VARCHAR2 DEFAULT NULL
    ) IS
        l_proc_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_DET_HIST';
        --
        l_sql                   VARCHAR2(32767);
        l_tab_epis_hid_det_hist ts_epis_hidrics_det_hist.epis_hidrics_det_hist_tc;
        l_aux_tab               table_number;
    BEGIN
        g_error := 'GET EPIS_HIDRICS_DET DATA. ID_EPIS_HIDRICS_DET: ' || i_epis_hidrics_det || '; I_WHERE: ' || i_where;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
        l_sql := '' || --
                 'SELECT e.id_epis_hidrics_det, ' || --
                 '       :g_sysdate_tstz, ' || --
                 '       e.id_epis_hidrics, ' || --
                 '       e.id_professional, ' || --
                 '       e.value_hidrics, ' || --
                 '       e.id_prof_cancel, ' || --                 
                 '       e.id_epis_hidrics_balance, ' || --
                 '       e.notes, ' || --
                 '       e.dt_creation_tstz, ' || --
                 '       e.dt_cancel_tstz, ' || --
                 '       e.dt_execution_tstz, ' || --
                 '       e.flg_type, ' || --
                 '      e.flg_status, ' || --
                 '       e.id_prof_line, ' || --
                 '       e.dt_prof_line, ' || --
                 '       e.id_epis_hidrics_line, ' || --
                 '       e.id_epis_hid_collector, ' || --
                 '       e.id_cancel_reason, ' || --
                 '       e.notes_cancel, ' || --
                 '       NULL create_user, ' || --
                 '       NULL create_time, ' || --
                 '       NULL create_institution, ' || --
                 '       NULL update_user, ' || --
                 '       NULL update_time, ' || --
                 '       NULL update_institution, ' || --
                 '       e.id_prof_last_change, ' || --
                 '       e.dt_epis_hidrics_det, ' || --                 
                 '       e.flg_action, ' || --
                 '       e.nr_times, ' || --
                 '       e.id_hidrics_device, ' || --                 
                 '       e.id_epis_hid_ftxt_dev ' || --
                 'FROM   epis_hidrics_det e ' || --
                 'WHERE  e.id_epis_hidrics_det NOT IN (SELECT column_value FROM TABLE(:g_epis_hid_det_hist)) ';
    
        IF i_epis_hidrics_det IS NOT NULL
        THEN
            l_sql := l_sql || 'AND e.id_epis_hidrics_det = ' || i_epis_hidrics_det || ' ';
        END IF;
    
        IF i_where IS NOT NULL
        THEN
            l_sql := l_sql || 'AND ' || i_where;
        END IF;
    
        EXECUTE IMMEDIATE l_sql BULK COLLECT
            INTO l_tab_epis_hid_det_hist
            USING g_sysdate_tstz, g_epis_hid_det_hist;
    
        IF l_tab_epis_hid_det_hist.count > 0
        THEN
            g_error := 'SAVE ID''s SENT TO HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            l_aux_tab := table_number();
            <<fill_aux_tab>>
            FOR i IN l_tab_epis_hid_det_hist.first .. l_tab_epis_hid_det_hist.last
            LOOP
                add_value(l_aux_tab, l_tab_epis_hid_det_hist(i).id_epis_hidrics_det);
            END LOOP fill_aux_tab;
        
            g_epis_hid_det_hist := g_epis_hid_det_hist MULTISET UNION DISTINCT l_aux_tab;
        
            g_error := 'SAVE HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            ts_epis_hidrics_det_hist.ins(rows_in => l_tab_epis_hid_det_hist);
        END IF;
    END set_epis_hid_det_hist;

    /**
    * Saves balance history
    *
    * @param   i_epis_hidrics_balance              epis_hidrics_balance id
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE set_epis_hid_bal_hist
    (
        i_epis_hidrics_balance IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE DEFAULT NULL,
        i_where                IN VARCHAR2 DEFAULT NULL
    ) IS
        l_proc_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_BAL_HIST';
        --
        l_sql                   VARCHAR2(32767);
        l_tab_epis_hid_bal_hist ts_epis_hbalance_hist.epis_hbalance_hist_tc;
        l_aux_tab               table_number;
    BEGIN
        g_error := 'GET EPIS_HIDRICS_BALANCE DATA. ID_EPIS_HIDRICS_BALANCE: ' || i_epis_hidrics_balance ||
                   '; I_WHERE: ' || i_where;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
        l_sql := '' || --
                 'SELECT e.id_epis_hidrics_balance, ' || --
                 '       :g_sysdate_tstz, ' || --
                 '       e.id_epis_hidrics, ' || --
                 '       e.id_prof_close, ' || --
                 '       e.flg_status, ' || --
                 '       e.total_admin, ' || --
                 '       e.total_elim, ' || --
                 '       e.id_unit_measure, ' || --
                 '       e.dt_prev_close_tstz, ' || --
                 '       e.dt_close_balance_tstz, ' || --
                 '       e.dt_open_tstz, ' || --
                 '       e.dt_register_tstz, ' || --
                 '       NULL create_user, ' || --
                 '       NULL create_time, ' || --
                 '       NULL create_institution, ' || --
                 '       NULL update_user, ' || --
                 '       NULL update_time, ' || --
                 '       NULL update_institution, ' || --
                 '       e.id_prof_last_change, ' || --
                 '       e.dt_eh_balance, ' || --
                 '       e.flg_close_type, ' || --
                 '       e.total_times ' || 'FROM   epis_hidrics_balance e ' || --
                 'WHERE  e.id_epis_hidrics_balance NOT IN (SELECT column_value FROM TABLE(:g_epis_hid_bal_hist)) ';
    
        IF i_epis_hidrics_balance IS NOT NULL
        THEN
            l_sql := l_sql || 'AND e.id_epis_hidrics_balance = ' || i_epis_hidrics_balance || ' ';
        END IF;
    
        IF i_where IS NOT NULL
        THEN
            l_sql := l_sql || 'AND ' || i_where;
        END IF;
    
        EXECUTE IMMEDIATE l_sql BULK COLLECT
            INTO l_tab_epis_hid_bal_hist
            USING g_sysdate_tstz, g_epis_hid_bal_hist;
    
        IF l_tab_epis_hid_bal_hist.count > 0
        THEN
            g_error := 'SAVE ID''s SENT TO HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            l_aux_tab := table_number();
            <<fill_aux_tab>>
            FOR i IN l_tab_epis_hid_bal_hist.first .. l_tab_epis_hid_bal_hist.last
            LOOP
                add_value(l_aux_tab, l_tab_epis_hid_bal_hist(i).id_epis_hidrics_balance);
            END LOOP fill_aux_tab;
        
            g_epis_hid_bal_hist := g_epis_hid_bal_hist MULTISET UNION DISTINCT l_aux_tab;
        
            g_error := 'SAVE HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            ts_epis_hbalance_hist.ins(rows_in => l_tab_epis_hid_bal_hist);
        END IF;
    END set_epis_hid_bal_hist;

    /**
    * Saves hidrics characteristics history for a given hidrics value
    *
    * @param   i_epis_hidrics_det              epis_hidrics_det id
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE set_epis_hid_char_hist(i_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE) IS
        l_proc_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_CHAR_HIST';
        --
        l_tab_epis_hd_char_hist ts_epis_hd_char_hist.epis_hd_char_hist_tc;
        l_aux_tab               table_number;
    BEGIN
        g_error := 'SEND FT CHARAT TO HIST. ID_EPIS_HIDRICS_DET: ' || i_epis_hidrics_det;
        set_epis_hid_det_hist(i_epis_hidrics_det => i_epis_hidrics_det);
    
        g_error := 'GET EPIS_HIDRICS_DET_CHARACT DATA. ID_EPIS_HIDRICS_DET: ' || i_epis_hidrics_det;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
        SELECT e.id_epis_hidrics_det,
               e.id_hidrics_charact,
               g_sysdate_tstz,
               NULL                  create_user,
               NULL                  create_time,
               NULL                  create_institution,
               NULL                  update_user,
               NULL                  update_time,
               NULL                  update_institution,
               e.id_prof_last_change,
               e.dt_eh_det_charact,
               e.                    id_epis_hid_ftxt_char
          BULK COLLECT
          INTO l_tab_epis_hd_char_hist
          FROM epis_hidrics_det_charact e
         WHERE e.id_epis_hidrics_det = i_epis_hidrics_det
           AND e.id_hidrics_charact NOT IN (SELECT /*+opt_estimate (table t rows=0.00001)*/
                                             column_value
                                              FROM TABLE(g_epis_hid_char_hist) t);
    
        IF l_tab_epis_hd_char_hist.count > 0
        THEN
        
            g_error := 'SAVE ID''s SENT TO HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            l_aux_tab := table_number();
            <<fill_aux_tab>>
            FOR i IN l_tab_epis_hd_char_hist.first .. l_tab_epis_hd_char_hist.last
            LOOP
                add_value(l_aux_tab, l_tab_epis_hd_char_hist(i).id_hidrics_charact);
            END LOOP fill_aux_tab;
        
            g_epis_hid_char_hist := g_epis_hid_char_hist MULTISET UNION DISTINCT l_aux_tab;
        
            g_error := 'SAVE EPIS_HD_CHAR_HIST ';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            ts_epis_hd_char_hist.ins(rows_in => l_tab_epis_hd_char_hist);
        END IF;
    END set_epis_hid_char_hist;

    /**
    * Saves hidrics line history
    *
    * @param   i_epis_hidrics_line              epis_hidrics_line id
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE set_epis_hid_line_hist
    (
        i_epis_hidrics_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE DEFAULT NULL,
        i_where             IN VARCHAR2 DEFAULT NULL
    ) IS
        l_proc_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_LINE_HIST';
        --
        l_sql                   VARCHAR2(32767);
        l_tab_epis_hd_line_hist ts_epis_hidrics_line_hist.epis_hidrics_line_hist_tc;
        l_aux_tab               table_number;
    BEGIN
        g_error := 'GET EPIS_HIDRICS_LINE DATA. ID_EPIS_HIDRICS_LINE: ' || i_epis_hidrics_line || '; I_WHERE: ' ||
                   i_where;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
        l_sql := '' || --
                 'SELECT e.id_epis_hidrics_line, ' || --
                 '       :g_sysdate_tstz, ' || --
                 '       e.id_epis_hidrics, ' || --
                 '       e.id_hidrics, ' || --
                 '       e.id_way, ' || --
                 '       e.id_hidrics_location, ' || --
                 '       e.flg_status, ' || --
                 '       e.dt_creation, ' || --
                 '       e.id_prof_cancel, ' || --
                 '       e.id_cancel_reason, ' || --
                 '       e.notes_cancel, ' || --
                 '       e.dt_cancel, ' || --
                 '       NULL create_user, ' || --
                 '       NULL create_time, ' || --
                 '       NULL create_institution, ' || --
                 '       NULL update_user, ' || --
                 '       NULL update_time, ' || --
                 '       NULL update_institution, ' || --
                 '       e.id_prof_last_change, ' || --
                 '       e.dt_epis_hidrics_line, ' || --
                 '       e.flg_action, ' || --
                 '       e.id_epis_hid_ftxt_way, ' || --
                 '       e.id_epis_hid_ftxt_fluid, ' || --
                 '       e.id_epis_hid_ftxt_loc ' || --                 
                 'FROM   epis_hidrics_line e ' || --
                 'WHERE  e.id_epis_hidrics_line NOT IN (SELECT column_value FROM TABLE(:g_epis_hid_line_hist)) ';
    
        IF i_epis_hidrics_line IS NOT NULL
        THEN
            l_sql := l_sql || 'AND e.id_epis_hidrics_line = ' || i_epis_hidrics_line || ' ';
        END IF;
    
        IF i_where IS NOT NULL
        THEN
            l_sql := l_sql || 'AND ' || i_where;
        END IF;
    
        EXECUTE IMMEDIATE l_sql BULK COLLECT
            INTO l_tab_epis_hd_line_hist
            USING g_sysdate_tstz, g_epis_hid_line_hist;
    
        IF l_tab_epis_hd_line_hist.count > 0
        THEN
            g_error := 'SAVE ID''s SENT TO HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            l_aux_tab := table_number();
            <<fill_aux_tab>>
            FOR i IN l_tab_epis_hd_line_hist.first .. l_tab_epis_hd_line_hist.last
            LOOP
                add_value(l_aux_tab, l_tab_epis_hd_line_hist(i).id_epis_hidrics_line);
            END LOOP fill_aux_tab;
        
            g_epis_hid_line_hist := g_epis_hid_line_hist MULTISET UNION DISTINCT l_aux_tab;
        
            g_error := 'SAVE HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            ts_epis_hidrics_line_hist.ins(rows_in => l_tab_epis_hd_line_hist);
        END IF;
    END set_epis_hid_line_hist;

    /**
    * Saves hidrics collector history.
    *
    * @param   i_epis_hidrics_line              epis_hidrics_line id. If i_epis_hidrics_line is not null saves all collectors of this line
    * @param   i_epis_hid_collector             epis_hid_collector id. If i_epis_hid_collector is not null saves only this collector
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE set_epis_hid_col_hist
    (
        i_epis_hidrics_line  IN epis_hidrics_line.id_epis_hidrics_line%TYPE DEFAULT NULL,
        i_epis_hid_collector IN epis_hid_collector.id_epis_hid_collector%TYPE DEFAULT NULL
    ) IS
        l_proc_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_COL_HIST';
        --
        l_tab_epis_hd_col_hist ts_epis_hcoll_hist.epis_hcoll_hist_tc;
        l_aux_tab              table_number;
    BEGIN
        IF i_epis_hidrics_line IS NOT NULL
           OR i_epis_hid_collector IS NOT NULL
        THEN
            g_error := 'GET EPIS_HID_COLLECTOR DATA. ID_EPIS_HIDRICS_LINE: ' || i_epis_hidrics_line ||
                       '; ID_EPIS_HID_COLLECTOR: ' || i_epis_hid_collector;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            SELECT e.id_epis_hid_collector,
                   g_sysdate_tstz,
                   e.id_epis_hidrics,
                   e.id_epis_hidrics_line,
                   e.flg_level_control,
                   e.dt_begin,
                   e.dt_end,
                   e.curr_level,
                   e.flg_restart,
                   e.id_prof,
                   e.dt_epis_hid_collector,
                   NULL                    create_user,
                   NULL                    create_time,
                   NULL                    create_institution,
                   NULL                    update_user,
                   NULL                    update_time,
                   NULL                    update_institution
              BULK COLLECT
              INTO l_tab_epis_hd_col_hist
              FROM epis_hid_collector e
             WHERE (e.id_epis_hidrics_line = i_epis_hidrics_line OR i_epis_hidrics_line IS NULL)
               AND (e.id_epis_hid_collector = i_epis_hid_collector OR i_epis_hid_collector IS NULL)
               AND e.id_epis_hid_collector NOT IN (SELECT /*+opt_estimate (table t rows=0.00001)*/
                                                    column_value
                                                     FROM TABLE(g_epis_hid_col_hist) t);
        
            IF l_tab_epis_hd_col_hist.count > 0
            THEN
                g_error := 'SAVE ID''s SENT TO HIST';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                l_aux_tab := table_number();
                <<fill_aux_tab>>
                FOR i IN l_tab_epis_hd_col_hist.first .. l_tab_epis_hd_col_hist.last
                LOOP
                    add_value(l_aux_tab, l_tab_epis_hd_col_hist(i).id_epis_hid_collector);
                END LOOP fill_aux_tab;
            
                g_epis_hid_col_hist := g_epis_hid_col_hist MULTISET UNION DISTINCT l_aux_tab;
            
                g_error := 'SAVE HIST';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_proc_name);
                ts_epis_hcoll_hist.ins(rows_in => l_tab_epis_hd_col_hist);
            END IF;
        END IF;
    END set_epis_hid_col_hist;

    /**
    * Saves hidrics free text history.
    *
    * @param   i_epis_hidrics_det_ftxt          epis_hidrics_det_ftxt id
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    PROCEDURE set_epis_hid_ftxt_hist
    (
        i_epis_hidrics_det_ftxt IN epis_hidrics_det_ftxt.id_epis_hidrics_det_ftxt%TYPE DEFAULT NULL,
        i_where                 IN VARCHAR2 DEFAULT NULL
    ) IS
        l_proc_name VARCHAR2(30 CHAR) := 'SET_EPIS_HID_FTXT_HIST';
        --
        l_sql                   VARCHAR2(32767);
        l_tab_epis_hd_ftxt_hist ts_epis_hd_ftxt_hist.epis_hd_ftxt_hist_tc;
        l_aux_tab               table_number;
    BEGIN
        g_error := 'GET EPIS_HID_COLLECTOR DATA. ID_EPIS_HIDRICS_DET_FTXT: ' || i_epis_hidrics_det_ftxt ||
                   '; I_WHERE: ' || i_where;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
        l_sql := '' || --
                 'SELECT e.id_epis_hidrics_det_ftxt, ' || --
                 '       :g_sysdate_tstz, ' || --                 
                 '       e.id_way, ' || --
                 '       e.id_hidrics_location, ' || --
                 '       e.id_hidrics, ' || --
                 '       e.id_hidrics_charact, ' || --
                 '       e.free_text, ' || --
                 '       NULL create_user, ' || --
                 '       NULL create_time, ' || --
                 '       NULL create_institution, ' || --
                 '       NULL update_user, ' || --
                 '       NULL update_time, ' || --
                 '       NULL update_institution, ' || --
                 '       e.id_prof_last_change, ' || --
                 '       e.dt_eh_det_ftxt, ' || --
                 '       e.id_hidrics_device, ' || --
                 '       e.id_patient ' || --
                 'FROM   epis_hidrics_det_ftxt e ' || --
                 'WHERE  e.id_epis_hidrics_det_ftxt NOT IN (SELECT column_value FROM TABLE(:g_epis_hid_ftxt_hist)) ';
    
        IF i_epis_hidrics_det_ftxt IS NOT NULL
        THEN
            l_sql := l_sql || 'AND e.id_epis_hidrics_det_ftxt = ' || i_epis_hidrics_det_ftxt || ' ';
        END IF;
    
        IF i_where IS NOT NULL
        THEN
            l_sql := l_sql || 'AND ' || i_where;
        END IF;
    
        EXECUTE IMMEDIATE l_sql BULK COLLECT
            INTO l_tab_epis_hd_ftxt_hist
            USING g_sysdate_tstz, g_epis_hid_ftxt_hist;
    
        IF l_tab_epis_hd_ftxt_hist.count > 0
        THEN
            g_error := 'SAVE ID''s SENT TO HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            l_aux_tab := table_number();
            <<fill_aux_tab>>
            FOR i IN l_tab_epis_hd_ftxt_hist.first .. l_tab_epis_hd_ftxt_hist.last
            LOOP
                add_value(l_aux_tab, l_tab_epis_hd_ftxt_hist(i).id_epis_hidrics_det_ftxt);
            END LOOP fill_aux_tab;
        
            g_epis_hid_ftxt_hist := g_epis_hid_ftxt_hist MULTISET UNION DISTINCT l_aux_tab;
        
            g_error := 'SAVE HIST';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_proc_name);
            ts_epis_hd_ftxt_hist.ins(rows_in => l_tab_epis_hd_ftxt_hist);
        END IF;
    END set_epis_hid_ftxt_hist;

    /**
    * Gets epis hidrics history data
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   i_flg_screen                D- detail screen; H- History screen
    * @param   o_hist                      History cursor
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    FUNCTION get_epis_hidrics_hist
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_screen   IN VARCHAR2,
        o_hist         OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_HIST';
        --
        TYPE tab_epis_hidrics_hist IS TABLE OF epis_hidrics_hist%ROWTYPE;
        l_tab_epis_hidrics_hist tab_epis_hidrics_hist;
        l_tab_hist              t_table_epis_hid_hist := t_table_epis_hid_hist();
        l_tbl_lables            table_varchar := table_varchar();
        l_tbl_values            table_varchar := table_varchar();
        l_tbl_types             table_varchar := table_varchar();
    
        l_desc_hid_type         sys_message.desc_message%TYPE;
        l_desc_status           sys_message.desc_message%TYPE;
        l_desc_new_status       sys_message.desc_message%TYPE;
        l_desc_start_date       sys_message.desc_message%TYPE;
        l_desc_interval         sys_message.desc_message%TYPE;
        l_desc_next_balance     sys_message.desc_message%TYPE;
        l_desc_end_date         sys_message.desc_message%TYPE;
        l_desc_flg_restrict     sys_message.desc_message%TYPE;
        l_desc_max_intake       sys_message.desc_message%TYPE;
        l_desc_min_output       sys_message.desc_message%TYPE;
        l_desc_notes            sys_message.desc_message%TYPE;
        l_desc_cancel_reason    sys_message.desc_message%TYPE;
        l_desc_notes_cancel     sys_message.desc_message%TYPE;
        l_desc_new_start_date   sys_message.desc_message%TYPE;
        l_desc_new_interval     sys_message.desc_message%TYPE;
        l_desc_new_next_balance sys_message.desc_message%TYPE;
        l_desc_new_end_date     sys_message.desc_message%TYPE;
        l_desc_new_flg_restrict sys_message.desc_message%TYPE;
        l_desc_new_max_intake   sys_message.desc_message%TYPE;
        l_desc_new_min_output   sys_message.desc_message%TYPE;
        l_desc_new_notes        sys_message.desc_message%TYPE;
        l_desc_inter_reason     sys_message.desc_message%TYPE;
        l_desc_inter_notes      sys_message.desc_message%TYPE;
        l_desc_del_info         sys_message.desc_message%TYPE;
        l_desc_no_changes       sys_message.desc_message%TYPE;
        l_desc_notes_expired    sys_message.desc_message%TYPE;
    
        l_prev_old_date VARCHAR2(4000);
        --   
    
        FUNCTION get_values
        (
            i_actual_row   IN epis_hidrics_hist%ROWTYPE,
            i_previous_row IN epis_hidrics_hist%ROWTYPE,
            o_tbl_labels   OUT table_varchar,
            o_tbl_values   OUT table_varchar,
            o_tbl_types    OUT table_varchar
        ) RETURN BOOLEAN IS
            l_unit_meas_desc  pk_translation.t_desc_translation;
            l_hid_interv      VARCHAR2(4000);
            l_has_differences BOOLEAN := FALSE;
        BEGIN
            o_tbl_labels := table_varchar();
            o_tbl_values := table_varchar();
            o_tbl_types  := table_varchar();
        
            IF i_actual_row.max_intake IS NOT NULL
               OR i_actual_row.min_output IS NOT NULL
               OR i_previous_row.max_intake IS NOT NULL
               OR i_previous_row.min_output IS NOT NULL
            THEN
                l_unit_meas_desc := pk_translation.get_translation(i_lang      => i_lang,
                                                                   i_code_mess => 'UNIT_MEASURE.CODE_UNIT_MEASURE.' ||
                                                                                  pk_sysconfig.get_config(i_code_cf => 'HIDRICS_UNIT_MEAS',
                                                                                                          i_prof    => i_prof));
            END IF;
        
            --title
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_ACTION',
                                                               i_val      => i_actual_row.flg_action,
                                                               i_lang     => i_lang),
                         io_table_2 => o_tbl_values,
                         i_value_2  => NULL,
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_title_t);
        
            IF i_actual_row.flg_status <> i_previous_row.flg_status
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_status,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_STATUS',
                                                                   i_val      => i_actual_row.flg_status,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --status          
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_status,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_STATUS',
                                                                   i_val      => i_previous_row.flg_status,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            END IF;
        
            IF i_actual_row.dt_initial_tstz <> i_previous_row.dt_initial_tstz
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_start_date,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang,
                                                                       i_actual_row.dt_initial_tstz,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --previous value
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_start_date,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang,
                                                                       i_previous_row.dt_initial_tstz,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            END IF;
        
            --i_row.id_hidrics_interval 
            IF i_actual_row.id_hidrics_interval <> i_previous_row.id_hidrics_interval
            THEN
                --new value           
                g_error := 'CALL get_hid_interval_desc: i_hidrics_interval: ' || i_actual_row.id_hidrics_interval ||
                           '; i_interval_minutes: ' || i_actual_row.interval_minutes;
                pk_alertlog.log_debug(g_error);
                IF NOT get_hid_interval_desc(i_lang             => i_lang,
                                             i_prof             => i_prof,
                                             i_hidrics_interval => i_actual_row.id_hidrics_interval,
                                             i_interval_minutes => i_actual_row.interval_minutes,
                                             o_hid_interval     => l_hid_interv,
                                             o_error            => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_interval,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_hid_interv,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --previous value                
                g_error := 'CALL get_hid_interval_desc: i_hidrics_interval: ' || i_previous_row.id_hidrics_interval ||
                           '; i_interval_minutes: ' || i_previous_row.interval_minutes;
                pk_alertlog.log_debug(g_error);
                IF NOT get_hid_interval_desc(i_lang             => i_lang,
                                             i_prof             => i_prof,
                                             i_hidrics_interval => i_previous_row.id_hidrics_interval,
                                             i_interval_minutes => i_previous_row.interval_minutes,
                                             o_hid_interval     => l_hid_interv,
                                             o_error            => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_interval,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_hid_interv,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            END IF;
        
            --dt_next_balance
            IF i_actual_row.dt_next_balance <> i_previous_row.dt_next_balance
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_next_balance,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang,
                                                                       i_actual_row.dt_next_balance,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --previous value
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_next_balance,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang,
                                                                       i_previous_row.dt_next_balance,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            END IF;
        
            --dt_end_tstz
            IF nvl(i_actual_row.dt_end_tstz, g_sysdate_tstz) <> nvl(i_previous_row.dt_end_tstz, g_sysdate_tstz)
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_end_date,
                             io_table_2 => o_tbl_values,
                             i_value_2  => nvl(pk_date_utils.date_char_tsz(i_lang,
                                                                           i_actual_row.dt_end_tstz,
                                                                           i_prof.institution,
                                                                           i_prof.software),
                                               l_desc_del_info),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --previous value
                l_prev_old_date := pk_date_utils.date_char_tsz(i_lang,
                                                               i_previous_row.dt_end_tstz,
                                                               i_prof.institution,
                                                               i_prof.software);
                IF (l_prev_old_date IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_end_date,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => l_prev_old_date,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --flg_restricted
            IF nvl(i_actual_row.flg_restricted, '-1') <> nvl(i_previous_row.flg_restricted, '-1')
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_flg_restrict,
                             io_table_2 => o_tbl_values,
                             i_value_2  => CASE
                                               WHEN i_actual_row.flg_restricted IS NULL THEN
                                                l_desc_del_info
                                               ELSE
                                                pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_RESTRICTED',
                                                                        i_val      => i_actual_row.flg_restricted,
                                                                        i_lang     => i_lang)
                                           END,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --previous value
                IF (i_previous_row.flg_restricted IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_flg_restrict,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_RESTRICTED',
                                                                       i_val      => i_previous_row.flg_restricted,
                                                                       i_lang     => i_lang),
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --max_intake
            IF nvl(i_actual_row.max_intake, -1) <> nvl(i_previous_row.max_intake, -1)
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_max_intake,
                             io_table_2 => o_tbl_values,
                             i_value_2  => CASE
                                               WHEN i_actual_row.max_intake IS NULL THEN
                                                l_desc_del_info
                                               ELSE
                                                i_actual_row.max_intake || ' ' || l_unit_meas_desc
                                           END,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --previous value
                IF (i_previous_row.max_intake IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_max_intake,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_previous_row.max_intake || ' ' || l_unit_meas_desc,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --min_output
            IF nvl(i_actual_row.min_output, -1) <> nvl(i_previous_row.min_output, -1)
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_min_output,
                             io_table_2 => o_tbl_values,
                             i_value_2  => CASE
                                               WHEN i_actual_row.min_output IS NULL THEN
                                                l_desc_del_info
                                               ELSE
                                                i_actual_row.min_output || ' ' || l_unit_meas_desc
                                           END,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --previous value
                IF (i_previous_row.min_output IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_min_output,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_previous_row.min_output || ' ' || l_unit_meas_desc,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --notes
            IF nvl(i_actual_row.notes, '-1') <> nvl(i_previous_row.notes, '-1')
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_notes,
                             io_table_2 => o_tbl_values,
                             i_value_2  => nvl(i_actual_row.notes, l_desc_del_info),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --previous value
                IF (i_previous_row.notes IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_notes,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_previous_row.notes,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            
            END IF;
        
            --Cancellation info
            IF i_actual_row.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_c,
                                           pk_inp_hidrics_constant.g_epis_hidric_i,
                                           pk_inp_hidrics_constant.g_epis_hidric_l,
                                           pk_inp_hidrics_constant.g_epis_hidric_o)
            THEN
                IF i_actual_row.id_cancel_reason IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => CASE
                                                   WHEN i_actual_row.flg_status = pk_inp_hidrics_constant.g_epis_hidric_i THEN
                                                    l_desc_inter_reason
                                                   ELSE
                                                    l_desc_cancel_reason
                                               END,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_cancel_reason.get_cancel_reason_desc(i_lang             => i_lang,
                                                                                       i_prof             => i_prof,
                                                                                       i_id_cancel_reason => i_actual_row.id_cancel_reason),
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                
                END IF;
            
                IF i_actual_row.notes_cancel IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => CASE
                                                   WHEN i_actual_row.flg_status = pk_inp_hidrics_constant.g_epis_hidric_o THEN
                                                    l_desc_notes_expired
                                                   ELSE
                                                    l_desc_notes_cancel
                                               END,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_actual_row.notes_cancel,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => CASE
                                                   WHEN i_actual_row.flg_status = pk_inp_hidrics_constant.g_epis_hidric_o THEN
                                                    pk_inp_hidrics_constant.g_new_content_n
                                                   ELSE
                                                    pk_inp_hidrics_constant.g_content_c
                                               END);
                
                END IF;
            
                IF i_actual_row.notes_inter IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_inter_notes,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_actual_row.notes_inter,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                
                END IF;
            END IF;
        
            IF (l_has_differences = FALSE)
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_no_changes,
                             io_table_2 => o_tbl_values,
                             i_value_2  => NULL,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --signature
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => NULL,
                         io_table_2 => o_tbl_values,
                         i_value_2  => get_signature(i_lang                => i_lang,
                                                     i_prof                => i_prof,
                                                     i_id_episode          => i_actual_row.id_episode,
                                                     i_date                => nvl(i_actual_row.dt_epis_hidrics,
                                                                                  i_actual_row.dt_creation_tstz),
                                                     i_id_prof_last_change => nvl(i_actual_row.id_prof_last_change,
                                                                                  i_actual_row.id_professional)),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_signature_s);
        
            RETURN TRUE;
        END get_values;
    
        FUNCTION get_first_values
        (
            i_actual_row IN epis_hidrics_hist%ROWTYPE,
            o_tbl_labels OUT table_varchar,
            o_tbl_values OUT table_varchar,
            o_tbl_types  OUT table_varchar
        ) RETURN BOOLEAN IS
            l_unit_meas_desc pk_translation.t_desc_translation;
            l_hid_interv     VARCHAR2(4000);
            --            
            l_code_hidrics_type hidrics_type.code_hidrics_type%TYPE;
        BEGIN
            o_tbl_labels := table_varchar();
            o_tbl_values := table_varchar();
            o_tbl_types  := table_varchar();
        
            IF i_actual_row.max_intake IS NOT NULL
               OR i_actual_row.min_output IS NOT NULL
            THEN
                l_unit_meas_desc := pk_translation.get_translation(i_lang      => i_lang,
                                                                   i_code_mess => 'UNIT_MEASURE.CODE_UNIT_MEASURE.' ||
                                                                                  pk_sysconfig.get_config(i_code_cf => 'HIDRICS_UNIT_MEAS',
                                                                                                          i_prof    => i_prof));
            END IF;
        
            --title
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_T104'),
                         io_table_2 => o_tbl_values,
                         i_value_2  => NULL,
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_title_t);
        
            --request type        
            g_error := 'GET code_hidrics_type. id_hidrics_type: ' || i_actual_row.id_hidrics_type;
            pk_alertlog.log_debug(g_error);
            SELECT ht.code_hidrics_type
              INTO l_code_hidrics_type
              FROM hidrics_type ht
             WHERE ht.id_hidrics_type = i_actual_row.id_hidrics_type;
        
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => l_desc_hid_type,
                         io_table_2 => o_tbl_values,
                         i_value_2  => pk_translation.get_translation(i_lang, l_code_hidrics_type),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_content_c);
        
            --status          
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => l_desc_status,
                         io_table_2 => o_tbl_values,
                         i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_STATUS',
                                                               i_val      => i_actual_row.flg_status,
                                                               i_lang     => i_lang),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_content_c);
        
            --inicial date
            IF (i_actual_row.dt_initial_tstz IS NOT NULL)
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_start_date,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang,
                                                                       i_actual_row.dt_initial_tstz,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --i_row.id_hidrics_interval         
            IF i_actual_row.id_hidrics_interval IS NOT NULL
            THEN
                g_error := 'CALL get_hid_interval_desc: i_hidrics_interval: ' || i_actual_row.id_hidrics_interval ||
                           '; i_interval_minutes: ' || i_actual_row.interval_minutes;
                pk_alertlog.log_debug(g_error);
                IF NOT get_hid_interval_desc(i_lang             => i_lang,
                                             i_prof             => i_prof,
                                             i_hidrics_interval => i_actual_row.id_hidrics_interval,
                                             i_interval_minutes => i_actual_row.interval_minutes,
                                             o_hid_interval     => l_hid_interv,
                                             o_error            => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_interval,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_hid_interv,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --i_row.dt_next_balance     
            IF i_actual_row.dt_next_balance IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_next_balance,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang,
                                                                       i_actual_row.dt_next_balance,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --i_row.dt_end_tstz         
            IF i_actual_row.dt_end_tstz IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_end_date,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang,
                                                                       i_actual_row.dt_end_tstz,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
            END IF;
        
            --i_row.flg_restricted      
            IF i_actual_row.flg_restricted IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_flg_restrict,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_RESTRICTED',
                                                                   i_val      => i_actual_row.flg_restricted,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
            END IF;
            --i_row.max_intake          
            IF i_actual_row.max_intake IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_max_intake,
                             io_table_2 => o_tbl_values,
                             i_value_2  => i_actual_row.max_intake || ' ' || l_unit_meas_desc,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
            END IF;
            --i_row.min_output          
            IF i_actual_row.min_output IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_min_output,
                             io_table_2 => o_tbl_values,
                             i_value_2  => i_actual_row.min_output || ' ' || l_unit_meas_desc,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
            END IF;
            --i_row.notes               
            IF i_actual_row.notes IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_notes,
                             io_table_2 => o_tbl_values,
                             i_value_2  => i_actual_row.notes,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --Cancellation info
            IF i_actual_row.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_c,
                                           pk_inp_hidrics_constant.g_epis_hidric_i,
                                           pk_inp_hidrics_constant.g_epis_hidric_o)
            THEN
                IF i_actual_row.id_cancel_reason IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => CASE
                                                   WHEN i_actual_row.flg_status = pk_inp_hidrics_constant.g_epis_hidric_i THEN
                                                    l_desc_inter_reason
                                                   ELSE
                                                    l_desc_cancel_reason
                                               END,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_cancel_reason.get_cancel_reason_desc(i_lang             => i_lang,
                                                                                       i_prof             => i_prof,
                                                                                       i_id_cancel_reason => i_actual_row.id_cancel_reason),
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                
                END IF;
            
                IF i_actual_row.notes_cancel IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => CASE
                                                   WHEN i_actual_row.flg_status = pk_inp_hidrics_constant.g_epis_hidric_o THEN
                                                    l_desc_notes_expired
                                                   ELSE
                                                    l_desc_notes_cancel
                                               END,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_actual_row.notes_cancel,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => CASE
                                                   WHEN i_actual_row.flg_status = pk_inp_hidrics_constant.g_epis_hidric_o THEN
                                                    pk_inp_hidrics_constant.g_new_content_n
                                                   ELSE
                                                    pk_inp_hidrics_constant.g_content_c
                                               END);
                
                END IF;
            
                IF i_actual_row.notes_inter IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_inter_notes,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_actual_row.notes_inter,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                
                END IF;
            END IF;
        
            --signature
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => NULL,
                         io_table_2 => o_tbl_values,
                         i_value_2  => get_signature(i_lang                => i_lang,
                                                     i_prof                => i_prof,
                                                     i_id_episode          => i_actual_row.id_episode,
                                                     i_date                => nvl(i_actual_row.dt_epis_hidrics,
                                                                                  i_actual_row.dt_creation_tstz),
                                                     i_id_prof_last_change => nvl(i_actual_row.id_prof_last_change,
                                                                                  i_actual_row.id_professional)),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_signature_s);
        
            RETURN TRUE;
        END get_first_values;
    
        FUNCTION get_info_labels RETURN table_varchar IS
            l_table table_varchar := table_varchar();
        BEGIN
            --RECORD_STATE            
            add_value(io_table => l_table, i_value => 'RECORD_STATE_TO_FORMAT');
            --RECORD ACTION
            add_value(io_table => l_table, i_value => 'RECORD_ACTION');
        
            RETURN l_table;
        END get_info_labels;
    
        FUNCTION get_info_values(i_row IN epis_hidrics_hist%ROWTYPE) RETURN table_varchar IS
            l_table table_varchar := table_varchar();
        BEGIN
            --RECORD_STATE                        
            add_value(io_table => l_table,
                      i_value  => CASE
                                      WHEN i_row.flg_status IN
                                           (pk_inp_hidrics_constant.g_epis_hidric_i, pk_inp_hidrics_constant.g_epis_hidric_c) THEN
                                       pk_inp_hidrics_constant.g_epis_hidric_c
                                      ELSE
                                       pk_inp_hidrics_constant.g_epis_hidric_a
                                  END);
            --RECORD ACTION
            add_value(io_table => l_table, i_value => i_row.flg_action);
        
            RETURN l_table;
        END get_info_values;
    
    BEGIN
        --get all labels
    
        l_desc_hid_type      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_M071');
        l_desc_status        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T115');
        l_desc_start_date    := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T008');
        l_desc_interval      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T009');
        l_desc_next_balance  := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T051');
        l_desc_end_date      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T010');
        l_desc_flg_restrict  := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T054');
        l_desc_max_intake    := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T052');
        l_desc_min_output    := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T053');
        l_desc_notes         := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T018');
        l_desc_cancel_reason := pk_message.get_message(i_lang, i_prof, 'COMMON_M072');
        l_desc_notes_cancel  := pk_message.get_message(i_lang, i_prof, 'COMMON_M073');
        l_desc_inter_reason  := pk_message.get_message(i_lang, i_prof, 'HIDRICS_M053');
        l_desc_inter_notes   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_M054');
        l_desc_notes_expired := pk_message.get_message(i_lang, i_prof, 'HIDRICS_M077');
    
        IF (i_flg_screen = pk_inp_hidrics_constant.g_hist_screen_h)
        THEN
            l_desc_new_start_date   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T105');
            l_desc_new_interval     := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T106');
            l_desc_new_next_balance := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T107');
            l_desc_new_end_date     := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T108');
            l_desc_new_flg_restrict := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T109');
            l_desc_new_max_intake   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T110');
            l_desc_new_min_output   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T111');
            l_desc_new_notes        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T112');
            l_desc_new_status       := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T116');
            l_desc_del_info         := pk_message.get_message(i_lang, i_prof, pk_inp_hidrics_constant.g_sm_detail_empty);
            l_desc_no_changes       := pk_message.get_message(i_lang, i_prof, pk_inp_hidrics_constant.g_sm_no_changes);
        END IF;
    
        g_error := 'GET HIST ID_EPIS_HIDRICS: ' || i_epis_hidrics;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT t.*
          BULK COLLECT
          INTO l_tab_epis_hidrics_hist
          FROM (SELECT ehh.*
                  FROM epis_hidrics_hist ehh
                 WHERE ehh.id_epis_hidrics = i_epis_hidrics
                   AND (i_flg_screen = pk_inp_hidrics_constant.g_hist_screen_h)
                UNION ALL
                SELECT eh.id_epis_hidrics,
                       g_sysdate_tstz dt_epis_hidrics_hist,
                       eh.id_hidrics_type,
                       eh.id_professional,
                       eh.id_episode,
                       eh.id_hidrics_interval,
                       eh.flg_status,
                       eh.notes,
                       eh.id_prof_cancel,
                       eh.notes_cancel,
                       eh.id_prof_inter,
                       eh.notes_inter,
                       eh.dt_creation_tstz,
                       eh.dt_initial_tstz,
                       eh.dt_end_tstz,
                       eh.dt_cancel_tstz,
                       eh.dt_inter_tstz,
                       eh.flg_restricted,
                       eh.max_intake,
                       eh.min_output,
                       eh.dt_next_balance,
                       eh.id_patient,
                       eh.id_cancel_reason,
                       eh.create_user,
                       eh.create_time,
                       eh.create_institution,
                       eh.update_user,
                       eh.update_time,
                       eh.update_institution,
                       eh.id_prof_last_change,
                       eh.dt_epis_hidrics,
                       eh.interval_minutes,
                       eh.flg_action
                  FROM epis_hidrics eh
                 WHERE eh.id_epis_hidrics = i_epis_hidrics) t
         ORDER BY t.dt_epis_hidrics DESC;
    
        g_error := 'tab_epis_hidrics_hist ' || l_tab_epis_hidrics_hist.count;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF l_tab_epis_hidrics_hist.count != 0
        THEN
            FOR i IN l_tab_epis_hidrics_hist.first .. l_tab_epis_hidrics_hist.last
            LOOP
                IF (i = l_tab_epis_hidrics_hist.count)
                THEN
                    IF NOT get_first_values(i_actual_row => l_tab_epis_hidrics_hist(l_tab_epis_hidrics_hist.count),
                                            o_tbl_labels => l_tbl_lables,
                                            o_tbl_values => l_tbl_values,
                                            o_tbl_types  => l_tbl_types)
                    THEN
                        RETURN FALSE;
                    END IF;
                ELSE
                    IF NOT get_values(i_actual_row   => l_tab_epis_hidrics_hist(i),
                                      i_previous_row => l_tab_epis_hidrics_hist(i + 1),
                                      o_tbl_labels   => l_tbl_lables,
                                      o_tbl_values   => l_tbl_values,
                                      o_tbl_types    => l_tbl_types)
                    THEN
                        RETURN FALSE;
                    END IF;
                END IF;
            
                l_tab_hist.extend;
                l_tab_hist(l_tab_hist.count) := t_rec_epis_hid_hist(id_history      => l_tab_epis_hidrics_hist(i).id_epis_hidrics,
                                                                    dt_history      => l_tab_epis_hidrics_hist(i).dt_epis_hidrics_hist,
                                                                    tbl_labels      => l_tbl_lables,
                                                                    tbl_values      => l_tbl_values,
                                                                    tbl_types       => l_tbl_types,
                                                                    tbl_info_labels => get_info_labels(),
                                                                    tbl_info_values => get_info_values(l_tab_epis_hidrics_hist(i)));
            
            END LOOP;
        END IF;
    
        g_error := 'OPEN O_HIST';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_hist FOR
            SELECT t.id_history      id_epis_hidrics,
                   t.dt_history      dt_epis_hidrics_hist,
                   t.tbl_labels      right_labels,
                   t.tbl_values      right_values,
                   t.tbl_types       types,
                   t.tbl_info_labels info_labels,
                   t.tbl_info_values info_values
              FROM TABLE(l_tab_hist) t;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_hist);
            RETURN FALSE;
    END get_epis_hidrics_hist;

    /**
    * Gets epis hidrics line history data
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics_line         Epis hidrics line id
    * @param   i_flg_screen                D- detail screen; H- History screen
    * @param   o_line_hist                 Line History cursor
    * @param   o_execs_hist                Executions History cursor
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    FUNCTION get_epis_hidrics_line_hist
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_epis_hidrics_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_flg_screen        IN VARCHAR2,
        o_line_hist         OUT pk_types.cursor_type,
        o_execs_hist        OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_HIST';
        --
        TYPE tab_eh_line_hist IS TABLE OF epis_hidrics_line_hist%ROWTYPE;
        l_tab_eh_line_hist tab_eh_line_hist;
        l_tab_hist         t_table_epis_hid_hist := t_table_epis_hid_hist();
        l_is_first_line    BOOLEAN := TRUE;
    
        l_desc_way           sys_message.desc_message%TYPE;
        l_desc_location      sys_message.desc_message%TYPE;
        l_desc_intake        sys_message.desc_message%TYPE;
        l_desc_output        sys_message.desc_message%TYPE;
        l_desc_cancel_reason sys_message.desc_message%TYPE;
        l_desc_cancel_notes  sys_message.desc_message%TYPE;
        l_desc_status        sys_message.desc_message%TYPE;
    
        l_desc_new_way      sys_message.desc_message%TYPE;
        l_desc_new_location sys_message.desc_message%TYPE;
        l_desc_new_intake   sys_message.desc_message%TYPE;
        l_desc_new_output   sys_message.desc_message%TYPE;
        l_desc_new_status   sys_message.desc_message%TYPE;
        l_desc_no_changes   sys_message.desc_message%TYPE;
        l_desc_del_info     sys_message.desc_message%TYPE;
    
        l_location epis_hidrics_det_ftxt.free_text%TYPE;
    
        l_tbl_lables table_varchar := table_varchar();
        l_tbl_values table_varchar := table_varchar();
        l_tbl_types  table_varchar := table_varchar();
    
        l_id_episode episode.id_episode%TYPE;
    
        l_id_epis_hidrics table_number := table_number();
        --
        FUNCTION get_first_values
        (
            i_actual_row IN epis_hidrics_line_hist%ROWTYPE,
            o_tbl_labels OUT table_varchar,
            o_tbl_values OUT table_varchar,
            o_tbl_types  OUT table_varchar
        ) RETURN BOOLEAN IS
            l_hid_flg_type hidrics.flg_type%TYPE;
        BEGIN
            o_tbl_labels := table_varchar();
            o_tbl_values := table_varchar();
            o_tbl_types  := table_varchar();
        
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_T129'),
                         io_table_2 => o_tbl_values,
                         i_value_2  => NULL,
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_title_t);
        
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => l_desc_status,
                         io_table_2 => o_tbl_values,
                         i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS_LINE.FLG_STATUS',
                                                               i_val      => i_actual_row.flg_status,
                                                               i_lang     => i_lang),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_content_c);
        
            --i_row.id_hidrics_way     
            IF i_actual_row.id_way IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_way,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_inp_hidrics.get_hidrics_way(i_lang                  => i_lang,
                                                                          i_prof                  => i_prof,
                                                                          i_epis_hidrics_line     => i_actual_row.id_epis_hidrics_line,
                                                                          i_dt_epis_hid_line_hist => i_actual_row.dt_epis_hid_line_hist),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
            END IF;
        
            --Location : the location is not a mandatory field
            l_location := pk_inp_hidrics.get_hidrics_location(i_lang                  => i_lang,
                                                              i_prof                  => i_prof,
                                                              i_epis_hidrics_line     => i_actual_row.id_epis_hidrics_line,
                                                              i_dt_epis_hid_line_hist => i_actual_row.dt_epis_hid_line_hist);
        
            IF l_location IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_location,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_location,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
            END IF;
        
            --i_row.id_hidrics
            IF i_actual_row.id_hidrics IS NOT NULL
            THEN
                IF NOT get_line_hidrics_type(i_lang              => i_lang,
                                             i_prof              => i_prof,
                                             i_epis_hidrics_line => i_actual_row.id_epis_hidrics_line,
                                             o_hid_flg_type      => l_hid_flg_type,
                                             o_error             => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => CASE
                                               WHEN l_hid_flg_type = pk_inp_hidrics_constant.g_hidrics_flg_type_a THEN
                                                l_desc_intake
                                               ELSE
                                                l_desc_output
                                           END,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_inp_hidrics.get_hidrics_desc(i_lang                  => i_lang,
                                                                           i_prof                  => i_prof,
                                                                           i_epis_hidrics_line     => i_actual_row.id_epis_hidrics_line,
                                                                           i_dt_epis_hid_line_hist => i_actual_row.dt_epis_hid_line_hist),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --Cancellation info
            IF i_actual_row.flg_status = pk_inp_hidrics_constant.g_epis_hid_lin_status_c
            THEN
                IF i_actual_row.id_cancel_reason IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_cancel_reason,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_cancel_reason.get_cancel_reason_desc(i_lang             => i_lang,
                                                                                       i_prof             => i_prof,
                                                                                       i_id_cancel_reason => i_actual_row.id_cancel_reason),
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                
                END IF;
            
                IF i_actual_row.notes_cancel IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_cancel_notes,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_actual_row.notes_cancel,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            END IF;
        
            --signature
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => NULL,
                         io_table_2 => o_tbl_values,
                         i_value_2  => get_signature(i_lang                => i_lang,
                                                     i_prof                => i_prof,
                                                     i_id_episode          => l_id_episode,
                                                     i_date                => nvl(i_actual_row.dt_epis_hidrics_line,
                                                                                  i_actual_row.dt_creation),
                                                     i_id_prof_last_change => i_actual_row.id_prof_last_change),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_signature_s);
        
            RETURN TRUE;
        END get_first_values;
    
        FUNCTION get_values
        (
            i_actual_row   IN epis_hidrics_line_hist%ROWTYPE,
            i_previous_row IN epis_hidrics_line_hist%ROWTYPE,
            o_tbl_labels   OUT table_varchar,
            o_tbl_values   OUT table_varchar,
            o_tbl_types    OUT table_varchar
        ) RETURN BOOLEAN IS
            l_location_prev     epis_hidrics_det_ftxt.free_text%TYPE;
            l_location_act      epis_hidrics_det_ftxt.free_text%TYPE;
            l_hid_flg_type_prev hidrics.flg_type%TYPE;
            l_hid_flg_type_act  hidrics.flg_type%TYPE;
            l_hid_prev          pk_translation.t_desc_translation;
            l_hid_act           pk_translation.t_desc_translation;
        
            l_way_prev        pk_translation.t_desc_translation;
            l_way_act         pk_translation.t_desc_translation;
            l_has_differences BOOLEAN := FALSE;
        BEGIN
            o_tbl_labels := table_varchar();
            o_tbl_values := table_varchar();
            o_tbl_types  := table_varchar();
        
            --title
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS_LINE.FLG_ACTION',
                                                               i_val      => i_actual_row.flg_action,
                                                               i_lang     => i_lang),
                         io_table_2 => o_tbl_values,
                         i_value_2  => NULL,
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_title_t);
        
            --status
            IF i_actual_row.flg_status <> i_previous_row.flg_status
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_status,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_STATUS',
                                                                   i_val      => i_actual_row.flg_status,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                --status          
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_status,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS.FLG_STATUS',
                                                                   i_val      => i_previous_row.flg_status,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            
            END IF;
        
            l_way_prev := pk_inp_hidrics.get_hidrics_way(i_lang                  => i_lang,
                                                         i_prof                  => i_prof,
                                                         i_epis_hidrics_line     => i_previous_row.id_epis_hidrics_line,
                                                         i_dt_epis_hid_line_hist => i_previous_row.dt_epis_hid_line_hist);
        
            l_way_act := pk_inp_hidrics.get_hidrics_way(i_lang                  => i_lang,
                                                        i_prof                  => i_prof,
                                                        i_epis_hidrics_line     => i_actual_row.id_epis_hidrics_line,
                                                        i_dt_epis_hid_line_hist => i_actual_row.dt_epis_hid_line_hist);
        
            --i_row.id_hidrics_way     
            IF nvl(l_way_prev, '-1') <> nvl(l_way_act, '-1')
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_way,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_way_act,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_way,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_way_prev,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            
            END IF;
        
            --Location : the location is not a mandatory field
            l_location_prev := pk_inp_hidrics.get_hidrics_location(i_lang                  => i_lang,
                                                                   i_prof                  => i_prof,
                                                                   i_epis_hidrics_line     => i_previous_row.id_epis_hidrics_line,
                                                                   i_dt_epis_hid_line_hist => i_previous_row.dt_epis_hid_line_hist);
        
            l_location_act := pk_inp_hidrics.get_hidrics_location(i_lang                  => i_lang,
                                                                  i_prof                  => i_prof,
                                                                  i_epis_hidrics_line     => i_actual_row.id_epis_hidrics_line,
                                                                  i_dt_epis_hid_line_hist => i_actual_row.dt_epis_hid_line_hist);
        
            IF nvl(l_location_prev, '-1') <> nvl(l_location_act, '-1')
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_location,
                             io_table_2 => o_tbl_values,
                             i_value_2  => nvl(l_location_act, l_desc_del_info),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                IF (l_location_prev IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_location,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => l_location_prev,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            
            END IF;
        
            l_hid_prev := pk_inp_hidrics.get_hidrics_desc(i_lang                  => i_lang,
                                                          i_prof                  => i_prof,
                                                          i_epis_hidrics_line     => i_previous_row.id_epis_hidrics_line,
                                                          i_dt_epis_hid_line_hist => i_previous_row.dt_epis_hid_line_hist);
        
            l_hid_act := pk_inp_hidrics.get_hidrics_desc(i_lang                  => i_lang,
                                                         i_prof                  => i_prof,
                                                         i_epis_hidrics_line     => i_actual_row.id_epis_hidrics_line,
                                                         i_dt_epis_hid_line_hist => i_actual_row.dt_epis_hid_line_hist);
        
            --i_row.id_hidrics
            IF nvl(l_hid_prev, '-1') <> nvl(l_hid_act, '-1')
            THEN
                g_error := 'CALL get_line_hidrics_type. i_epis_hidrics_line: ' || i_actual_row.id_epis_hidrics_line;
                pk_alertlog.log_debug(g_error);
                IF NOT get_line_hidrics_type(i_lang              => i_lang,
                                             i_prof              => i_prof,
                                             i_epis_hidrics_line => i_actual_row.id_epis_hidrics_line,
                                             o_hid_flg_type      => l_hid_flg_type_act,
                                             o_error             => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => CASE
                                               WHEN l_hid_flg_type_act = pk_inp_hidrics_constant.g_hidrics_flg_type_a THEN
                                                l_desc_new_intake
                                               ELSE
                                                l_desc_new_output
                                           END,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_hid_act,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                g_error := 'CALL get_line_hidrics_type. i_epis_hidrics_line: ' || i_previous_row.id_epis_hidrics_line;
                pk_alertlog.log_debug(g_error);
                IF NOT get_line_hidrics_type(i_lang              => i_lang,
                                             i_prof              => i_prof,
                                             i_epis_hidrics_line => i_previous_row.id_epis_hidrics_line,
                                             o_hid_flg_type      => l_hid_flg_type_prev,
                                             o_error             => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => CASE
                                               WHEN l_hid_flg_type_prev = pk_inp_hidrics_constant.g_hidrics_flg_type_a THEN
                                                l_desc_intake
                                               ELSE
                                                l_desc_output
                                           END,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_hid_prev,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            
            END IF;
        
            IF (l_has_differences = FALSE)
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_no_changes,
                             io_table_2 => o_tbl_values,
                             i_value_2  => NULL,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --signature
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => NULL,
                         io_table_2 => o_tbl_values,
                         i_value_2  => get_signature(i_lang                => i_lang,
                                                     i_prof                => i_prof,
                                                     i_id_episode          => l_id_episode,
                                                     i_date                => nvl(i_actual_row.dt_epis_hidrics_line,
                                                                                  i_actual_row.dt_creation),
                                                     i_id_prof_last_change => i_actual_row.id_prof_last_change),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_signature_s);
        
            RETURN TRUE;
        END get_values;
    
        FUNCTION get_info_labels RETURN table_varchar IS
            l_table table_varchar := table_varchar();
        BEGIN
            --RECORD_STATE
            add_value(io_table => l_table, i_value => 'RECORD_STATE_TO_FORMAT');
            --RECORD ACTION
            add_value(io_table => l_table, i_value => 'RECORD_ACTION');
        
            RETURN l_table;
        END get_info_labels;
    
        FUNCTION get_info_values(i_row IN epis_hidrics_line_hist%ROWTYPE) RETURN table_varchar IS
            --
            l_table table_varchar := table_varchar();
        BEGIN
            --RECORD_STATE
            add_value(io_table => l_table,
                      i_value  => CASE
                                      WHEN i_row.flg_status = pk_inp_hidrics_constant.g_epis_hid_lin_status_c THEN
                                       pk_inp_hidrics_constant.g_epis_hid_lin_status_c
                                      ELSE
                                       pk_inp_hidrics_constant.g_epis_hid_lin_status_a
                                  END);
            --RECORD ACTION
            add_value(io_table => l_table, i_value => i_row.flg_action);
        
            RETURN l_table;
        END get_info_values;
    BEGIN
        l_desc_way           := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T062');
        l_desc_location      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T063');
        l_desc_intake        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T064');
        l_desc_output        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T092');
        l_desc_cancel_reason := pk_message.get_message(i_lang, i_prof, 'COMMON_M072');
        l_desc_cancel_notes  := pk_message.get_message(i_lang, i_prof, 'COMMON_M073');
        l_desc_status        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T115');
    
        IF (i_flg_screen = pk_inp_hidrics_constant.g_hist_screen_h)
        THEN
            l_desc_new_way      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T113');
            l_desc_new_location := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T114');
            l_desc_new_intake   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T117');
            l_desc_new_output   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T118');
            l_desc_new_status   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T116');
            l_desc_no_changes   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_M072');
            l_desc_del_info     := pk_message.get_message(i_lang, i_prof, pk_inp_hidrics_constant.g_sm_detail_empty);
            l_desc_no_changes   := pk_message.get_message(i_lang, i_prof, pk_inp_hidrics_constant.g_sm_no_changes);
        END IF;
    
        g_error := 'GET HIST ID_EPIS_HIDRICS_LINE: ' || i_epis_hidrics_line;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT t.*
          BULK COLLECT
          INTO l_tab_eh_line_hist
          FROM (SELECT ehlh.*
                  FROM epis_hidrics_line_hist ehlh
                 WHERE ehlh.id_epis_hidrics_line = i_epis_hidrics_line
                   AND (i_flg_screen = pk_inp_hidrics_constant.g_hist_screen_h)
                UNION ALL
                SELECT ehl.id_epis_hidrics_line,
                       g_sysdate_tstz dt_epis_hid_line_hist,
                       ehl.id_epis_hidrics,
                       ehl.id_hidrics,
                       ehl.id_way,
                       ehl.id_hidrics_location,
                       ehl.flg_status,
                       ehl.dt_creation,
                       ehl.id_prof_cancel,
                       ehl.id_cancel_reason,
                       ehl.notes_cancel,
                       ehl.dt_cancel,
                       ehl.create_user,
                       ehl.create_time,
                       ehl.create_institution,
                       ehl.update_user,
                       ehl.update_time,
                       ehl.update_institution,
                       ehl.id_prof_last_change,
                       ehl.dt_epis_hidrics_line,
                       ehl.flg_action,
                       ehl.id_epis_hid_ftxt_way,
                       ehl.id_epis_hid_ftxt_fluid,
                       ehl.id_epis_hid_ftxt_loc
                  FROM epis_hidrics_line ehl
                 WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line) t
         ORDER BY t.dt_epis_hid_line_hist DESC;
    
        g_error := 'tab_epis_hidrics_line_hist: ' || l_tab_eh_line_hist.count;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF l_tab_eh_line_hist.count != 0
        THEN
            l_is_first_line := TRUE;
            FOR i IN l_tab_eh_line_hist.first .. l_tab_eh_line_hist.last
            LOOP
                IF (l_is_first_line = TRUE)
                THEN
                
                    g_error := 'CALL get_epis_hid_episode';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    IF NOT get_epis_hid_episode(i_lang            => i_lang,
                                                i_prof            => i_prof,
                                                i_id_epis_hidrics => l_tab_eh_line_hist(i).id_epis_hidrics,
                                                o_id_episode      => l_id_episode,
                                                o_error           => o_error)
                    THEN
                        RETURN FALSE;
                    END IF;
                END IF;
            
                IF (i = l_tab_eh_line_hist.count)
                THEN
                    IF NOT get_first_values(i_actual_row => l_tab_eh_line_hist(l_tab_eh_line_hist.count),
                                            o_tbl_labels => l_tbl_lables,
                                            o_tbl_values => l_tbl_values,
                                            o_tbl_types  => l_tbl_types)
                    THEN
                        RETURN FALSE;
                    END IF;
                ELSE
                
                    IF NOT get_values(i_actual_row   => l_tab_eh_line_hist(i),
                                      i_previous_row => l_tab_eh_line_hist(i + 1),
                                      o_tbl_labels   => l_tbl_lables,
                                      o_tbl_values   => l_tbl_values,
                                      o_tbl_types    => l_tbl_types)
                    THEN
                        RETURN FALSE;
                    END IF;
                END IF;
            
                l_tab_hist.extend;
                l_tab_hist(l_tab_hist.count) := t_rec_epis_hid_hist(id_history      => l_tab_eh_line_hist(i).id_epis_hidrics_line,
                                                                    dt_history      => l_tab_eh_line_hist(i).dt_epis_hid_line_hist,
                                                                    tbl_labels      => l_tbl_lables,
                                                                    tbl_values      => l_tbl_values,
                                                                    tbl_types       => l_tbl_types,
                                                                    tbl_info_labels => get_info_labels(),
                                                                    tbl_info_values => get_info_values(l_tab_eh_line_hist(i)));
            
                l_is_first_line := FALSE;
            END LOOP;
        END IF;
    
        g_error := 'OPEN O_HIST';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_line_hist FOR
            SELECT t.id_history      id_epis_hidrics_line,
                   t.dt_history      dt_epis_hid_line_hist,
                   t.tbl_labels      right_labels,
                   t.tbl_values      right_values,
                   t.tbl_types       types,
                   t.tbl_info_labels info_labels,
                   t.tbl_info_values info_values
              FROM TABLE(l_tab_hist) t;
    
        IF (i_flg_screen = pk_inp_hidrics_constant.g_detail_screen_d)
        THEN
            --get the executions associated to the line
            g_error := 'GET executions. i_epis_hidrics_line: ' || i_epis_hidrics_line;
            pk_alertlog.log_debug(g_error);
            SELECT e.id_epis_hidrics_det
              BULK COLLECT
              INTO l_id_epis_hidrics
              FROM epis_hidrics_det e
             WHERE e.id_epis_hidrics_line = i_epis_hidrics_line;
        
            g_error := 'CALL get_epis_hidrics_res_hist.';
            pk_alertlog.log_debug(g_error);
            IF NOT get_epis_hidrics_res_hist(i_lang             => i_lang,
                                             i_prof             => i_prof,
                                             i_epis_hidrics_det => l_id_epis_hidrics,
                                             i_flg_screen       => pk_inp_hidrics_constant.g_detail_line_screen_l,
                                             o_hist             => o_execs_hist,
                                             o_error            => o_error)
            THEN
                RETURN FALSE;
            END IF;
        ELSE
            pk_types.open_my_cursor(o_execs_hist);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_line_hist);
            pk_types.open_my_cursor(o_execs_hist);
            RETURN FALSE;
    END get_epis_hidrics_line_hist;

    /**
    * Get the characteristics associated to an execution (epis_hidrics_det)
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_id_epis_hid_det           Epis_hidrics_det identifier    
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Sofia Mendes
    * @version v2.6.0.5
    * @since   14-Jan-2011
    */
    FUNCTION get_characteristics
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_epis_hid_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        o_characts        OUT table_number,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_CHARACTERISTICS';
    BEGIN
    
        g_error := 'get all active characterizations of the epis_hidrics_Det: ' || i_id_epis_hid_det;
        pk_alertlog.log_debug(g_error);
        --get all active characterizations of the epis_hidrics_Det      
        SELECT ehdc.id_hidrics_charact
          BULK COLLECT
          INTO o_characts
          FROM epis_hidrics_det ehd
          JOIN epis_hidrics_det_charact ehdc
            ON ehdc.id_epis_hidrics_det = ehd.id_epis_hidrics_det
         WHERE ehd.id_epis_hidrics_det = i_id_epis_hid_det
         ORDER BY ehdc.id_hidrics_charact;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_characteristics;

    /********************************************************************************************
    * Get the collector data: control level, flg_restart and current level.
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_id_epis_hid_collector   Collector Id     
    * @param       i_dt_epis_hid_collector   Collector date 
    * @param       o_level_control           Indicates if the collector level should be monitored
    * @param       o_curr_level              Current level
    * @param       o_flg_restart             Indicates if the collector should be restarted
    * @param       o_error                   error message
    *        
    * @return      boolean                   true on success, otherwise false
    * 
    * @author                               Sofia Mendes
    * @version                               2.6.0.5
    * @since                                 14-Jan-2011
    ********************************************************************************************/
    FUNCTION get_collector_data
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_epis_hid_collector IN epis_hid_collector.id_epis_hid_collector%TYPE,
        i_dt_epis_hid_collector IN epis_hid_collector.dt_epis_hid_collector%TYPE,
        o_level_control         OUT epis_hid_collector.flg_level_control%TYPE,
        o_curr_level            OUT epis_hid_collector.curr_level%TYPE,
        o_flg_restart           OUT epis_hid_collector.flg_restart%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        BEGIN
            g_error := 'GET COLLECTOR DATA. i_id_epis_hid_collector: ' || i_id_epis_hid_collector ||
                       '; i_dt_epis_hid_collector: ' || CAST(i_dt_epis_hid_collector AS VARCHAR2);
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => 'GET_COLLECTOR_DATA');
            SELECT t.flg_level_control, t.curr_level, t.flg_restart
              INTO o_level_control, o_curr_level, o_flg_restart
              FROM (SELECT ehc.flg_level_control, ehc.curr_level, ehc.flg_restart
                      FROM epis_hid_collector ehc
                     WHERE ehc.id_epis_hid_collector = i_id_epis_hid_collector
                       AND ehc.dt_epis_hid_collector = i_dt_epis_hid_collector
                    UNION ALL
                    SELECT ehch.flg_level_control, ehch.curr_level, ehch.flg_restart
                      FROM epis_hcoll_hist ehch
                     WHERE ehch.id_epis_hid_collector = i_id_epis_hid_collector
                       AND ehch.dt_epis_hid_collector = i_dt_epis_hid_collector) t;
        EXCEPTION
            WHEN no_data_found THEN
                o_level_control := NULL;
                o_curr_level    := NULL;
                o_flg_restart   := NULL;
        END;
        --
        RETURN TRUE;
    END get_collector_data;

    /**
    * Gets epis hidrics result history data
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics_det          Table number with the Epis hidrics det ids
    * @param   i_flg_screen                D- detail screen; H- History screen
    * @param   o_hist                      History cursor
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   11-06-2010
    */
    FUNCTION get_epis_hidrics_res_hist
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics_det IN table_number,
        i_flg_screen       IN VARCHAR2,
        o_hist             OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_RES_HIST';
        --
        TYPE tab_eh_det_hist IS TABLE OF epis_hidrics_det_hist%ROWTYPE;
        l_tab_eh_det_hist tab_eh_det_hist;
        l_tab_hist        t_table_epis_hid_hist := t_table_epis_hid_hist();
        --
        l_hid_chars_delim CONSTANT VARCHAR2(24 CHAR) := '; ';
        --
        l_is_first_line BOOLEAN := TRUE;
        l_hid_way       epis_hidrics_det_ftxt.free_text%TYPE;
        l_hid_loc       epis_hidrics_det_ftxt.free_text%TYPE;
        l_hid           epis_hidrics_det_ftxt.free_text%TYPE;
        l_hid_type      hidrics.flg_type%TYPE;
        l_eh_um         pk_translation.t_desc_translation;
        --   
        l_desc_way           sys_message.desc_message%TYPE;
        l_desc_location      sys_message.desc_message%TYPE;
        l_desc_intake        sys_message.desc_message%TYPE;
        l_desc_output        sys_message.desc_message%TYPE;
        l_desc_characts      sys_message.desc_message%TYPE;
        l_desc_date          sys_message.desc_message%TYPE;
        l_desc_quant         sys_message.desc_message%TYPE;
        l_desc_type          sys_message.desc_message%TYPE;
        l_desc_notes         sys_message.desc_message%TYPE;
        l_desc_device_coll   sys_message.desc_message%TYPE;
        l_desc_level_control sys_message.desc_message%TYPE;
        l_desc_actual_level  sys_message.desc_message%TYPE;
        l_desc_restart       sys_message.desc_message%TYPE;
        l_desc_cancel_reason sys_message.desc_message%TYPE;
        l_desc_cancel_notes  sys_message.desc_message%TYPE;
    
        l_desc_new_characts     sys_message.desc_message%TYPE;
        l_desc_new_date         sys_message.desc_message%TYPE;
        l_desc_new_quant        sys_message.desc_message%TYPE;
        l_desc_new_type         sys_message.desc_message%TYPE;
        l_desc_new_notes        sys_message.desc_message%TYPE;
        l_desc_new_actual_level sys_message.desc_message%TYPE;
        l_desc_new_restart      sys_message.desc_message%TYPE;
        l_desc_status           sys_message.desc_message%TYPE;
        l_desc_new_status       sys_message.desc_message%TYPE;
        l_desc_nr_times         sys_message.desc_message%TYPE;
        l_desc_new_nr_times     sys_message.desc_message%TYPE;
        l_desc_device           sys_message.desc_message%TYPE;
        l_desc_new_device       sys_message.desc_message%TYPE;
        l_desc_del_info         sys_message.desc_message%TYPE;
        l_desc_no_changes       sys_message.desc_message%TYPE;
    
        l_tbl_lables table_varchar := table_varchar();
        l_tbl_values table_varchar := table_varchar();
        l_tbl_types  table_varchar := table_varchar();
        l_id_episode episode.id_episode%TYPE;
        l_index      PLS_INTEGER;
    
        FUNCTION get_first_values
        (
            i_actual_row IN epis_hidrics_det_hist%ROWTYPE,
            o_tbl_labels OUT table_varchar,
            o_tbl_values OUT table_varchar,
            o_tbl_types  OUT table_varchar
        ) RETURN BOOLEAN IS
            l_level_control epis_hid_collector.flg_level_control%TYPE;
            l_curr_level    epis_hid_collector.curr_level%TYPE;
            l_flg_restart   epis_hid_collector.flg_restart%TYPE;
            l_hid_chars     VARCHAR2(32767 CHAR);
            l_code_message  sys_message.code_message%TYPE;
        BEGIN
            o_tbl_labels := table_varchar();
            o_tbl_values := table_varchar();
            o_tbl_types  := table_varchar();
        
            IF (i_flg_screen = pk_inp_hidrics_constant.g_detail_line_screen_l)
            THEN
                l_code_message := 'HIDRICS_T131';
            ELSE
                l_code_message := 'HIDRICS_T129';
            END IF;
        
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_message),
                         io_table_2 => o_tbl_values,
                         i_value_2  => NULL,
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_title_t);
        
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => l_desc_status,
                         io_table_2 => o_tbl_values,
                         i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS_DET.FLG_STATUS',
                                                               i_val      => i_actual_row.flg_status,
                                                               i_lang     => i_lang),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_content_c);
        
            --l_hid_way  
            IF (i_flg_screen <> pk_inp_hidrics_constant.g_detail_line_screen_l)
            THEN
                IF l_hid_way IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_way,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => l_hid_way,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
                --l_hid_loc 
                IF l_hid_loc IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_location,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => l_hid_loc,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
                --l_hid
                IF l_hid IS NOT NULL
                THEN
                
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => CASE
                                                   WHEN i_actual_row.flg_type IS NOT NULL THEN
                                                    l_desc_intake
                                                   ELSE
                                                    l_desc_output
                                               END,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => l_hid,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_hid_chars := pk_utils.concat_table(pk_inp_hidrics.get_hid_chars_descs(i_lang                     => i_lang,
                                                                                        i_prof                     => i_prof,
                                                                                        i_epis_hidrics_det         => i_actual_row.id_epis_hidrics_det,
                                                                                        i_dt_epis_hidrics_det_hist => i_actual_row.dt_epis_hidrics_det_hist),
                                                     l_hid_chars_delim);
            END IF;
        
            --l_hid_chars
            IF l_hid_chars IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_characts,
                             io_table_2 => o_tbl_values,
                             i_value_2  => l_hid_chars,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --i_actual_row.nr_times
            IF i_actual_row.nr_times IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_nr_times,
                             io_table_2 => o_tbl_values,
                             i_value_2  => i_actual_row.nr_times,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --i_row.value_hidrics
            IF i_actual_row.value_hidrics IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_quant,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_utils.number_to_char(i_prof, i_actual_row.value_hidrics) || l_eh_um,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --id_hidrics_device
            IF i_actual_row.id_hidrics_device IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_device,
                             io_table_2 => o_tbl_values,
                             i_value_2  => CASE
                                               WHEN i_actual_row.id_hidrics_device IS NULL THEN
                                                pk_inp_hidrics_constant.g_detail_empty
                                               ELSE
                                                pk_inp_hidrics.get_device_desc(i_lang,
                                                                               i_prof,
                                                                               i_actual_row.id_epis_hidrics_det,
                                                                               i_actual_row.dt_epis_hidrics_det_hist)
                                           END,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --i_row.flg_type
            IF i_actual_row.flg_type IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_type,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => g_cd_ehd_flg_type,
                                                                   i_val      => i_actual_row.flg_type,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --Collector device
            IF l_hid_type = pk_inp_hidrics_constant.g_hidrics_flg_type_e
            THEN
                IF NOT get_collector_data(i_lang                  => i_lang,
                                          i_prof                  => i_prof,
                                          i_id_epis_hid_collector => i_actual_row.id_epis_hid_collector,
                                          i_dt_epis_hid_collector => i_actual_row.dt_epis_hidrics_det,
                                          o_level_control         => l_level_control,
                                          o_curr_level            => l_curr_level,
                                          o_flg_restart           => l_flg_restart,
                                          o_error                 => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                IF l_level_control IS NOT NULL
                   OR l_curr_level IS NOT NULL
                   OR l_flg_restart IS NOT NULL
                THEN
                    --Collector device label hasn't a value                    
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_device_coll,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => NULL,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                IF l_level_control IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_level_control,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_sysdomain.get_domain(i_code_dom => g_cd_ehc_flg_lvl_control,
                                                                       i_val      => l_level_control,
                                                                       i_lang     => i_lang),
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_sc);
                
                END IF;
                IF l_curr_level IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_actual_level,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_utils.number_to_char(i_prof, l_curr_level) || l_eh_um,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_sc);
                END IF;
                IF l_flg_restart IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_restart,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_sysdomain.get_domain(i_code_dom => g_cd_ehc_flg_restart,
                                                                       i_val      => l_flg_restart,
                                                                       i_lang     => i_lang),
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_sc);
                END IF;
            END IF;
        
            --i_row.notes
            IF i_actual_row.notes IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_notes,
                             io_table_2 => o_tbl_values,
                             i_value_2  => i_actual_row.notes,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
            END IF;
        
            --i_row.dt_execution_tstz
            IF i_actual_row.dt_execution_tstz IS NOT NULL
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_date,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                                       i_date => i_actual_row.dt_execution_tstz,
                                                                       i_inst => i_prof.institution,
                                                                       i_soft => i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --Cancellation info
            IF i_actual_row.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_c
            THEN
                IF i_actual_row.id_cancel_reason IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_cancel_reason,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_cancel_reason.get_cancel_reason_desc(i_lang             => i_lang,
                                                                                       i_prof             => i_prof,
                                                                                       i_id_cancel_reason => i_actual_row.id_cancel_reason),
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                
                END IF;
            
                IF i_actual_row.notes_cancel IS NOT NULL
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_cancel_notes,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_actual_row.notes_cancel,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            END IF;
        
            --signature
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => NULL,
                         io_table_2 => o_tbl_values,
                         i_value_2  => get_signature(i_lang                => i_lang,
                                                     i_prof                => i_prof,
                                                     i_id_episode          => l_id_episode,
                                                     i_date                => nvl(i_actual_row.dt_epis_hidrics_det,
                                                                                  i_actual_row.dt_creation_tstz),
                                                     i_id_prof_last_change => nvl(i_actual_row.id_prof_last_change,
                                                                                  i_actual_row.id_professional)),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_signature_s);
        
            RETURN TRUE;
        END get_first_values;
    
        FUNCTION get_values
        (
            i_actual_row   IN epis_hidrics_det_hist%ROWTYPE,
            i_previous_row IN epis_hidrics_det_hist%ROWTYPE,
            o_tbl_labels   OUT table_varchar,
            o_tbl_values   OUT table_varchar,
            o_tbl_types    OUT table_varchar
        ) RETURN BOOLEAN IS
            l_level_control_prev epis_hid_collector.flg_level_control%TYPE;
            l_curr_level_prev    epis_hid_collector.curr_level%TYPE;
            l_flg_restart_prev   epis_hid_collector.flg_restart%TYPE;
        
            l_level_control_act epis_hid_collector.flg_level_control%TYPE;
            l_curr_level_act    epis_hid_collector.curr_level%TYPE;
            l_flg_restart_act   epis_hid_collector.flg_restart%TYPE;
            l_hid_chars_prev    VARCHAR2(32767 CHAR);
            l_hid_chars_act     VARCHAR2(32767 CHAR);
        
            l_dev_prev pk_translation.t_desc_translation;
            l_dev_act  pk_translation.t_desc_translation;
        
            l_has_differences BOOLEAN := FALSE;
        BEGIN
            o_tbl_labels := table_varchar();
            o_tbl_values := table_varchar();
            o_tbl_types  := table_varchar();
        
            --title
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS_DET.FLG_ACTION',
                                                               i_val      => i_actual_row.flg_action,
                                                               i_lang     => i_lang),
                         io_table_2 => o_tbl_values,
                         i_value_2  => NULL,
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_title_t);
        
            -- flg_status            
            IF i_actual_row.flg_status <> i_previous_row.flg_status
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_status,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS_DET.FLG_STATUS',
                                                                   i_val      => i_actual_row.flg_status,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_status,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => 'EPIS_HIDRICS_DET.FLG_STATUS',
                                                                   i_val      => i_previous_row.flg_status,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            END IF;
        
            l_hid_chars_prev := pk_utils.concat_table(pk_inp_hidrics.get_hid_chars_descs(i_lang                     => i_lang,
                                                                                         i_prof                     => i_prof,
                                                                                         i_epis_hidrics_det         => i_previous_row.id_epis_hidrics_det,
                                                                                         i_dt_epis_hidrics_det_hist => i_previous_row.dt_epis_hidrics_det_hist),
                                                      l_hid_chars_delim);
        
            l_hid_chars_act := pk_utils.concat_table(pk_inp_hidrics.get_hid_chars_descs(i_lang                     => i_lang,
                                                                                        i_prof                     => i_prof,
                                                                                        i_epis_hidrics_det         => i_actual_row.id_epis_hidrics_det,
                                                                                        i_dt_epis_hidrics_det_hist => i_actual_row.dt_epis_hidrics_det_hist),
                                                     l_hid_chars_delim);
            --l_hid_chars
            IF nvl(l_hid_chars_prev, '-1') <> nvl(l_hid_chars_act, '-1')
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_characts,
                             io_table_2 => o_tbl_values,
                             i_value_2  => nvl(l_hid_chars_act, l_desc_del_info),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                IF (l_hid_chars_prev IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_characts,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => l_hid_chars_prev,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --i_row.nr_times
            IF nvl(i_actual_row.nr_times, -1) <> nvl(i_previous_row.nr_times, -1)
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_nr_times,
                             io_table_2 => o_tbl_values,
                             i_value_2  => nvl(to_char(i_actual_row.nr_times), l_desc_del_info),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                IF (i_previous_row.nr_times IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_nr_times,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => to_char(i_previous_row.nr_times),
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --i_row.value_hidrics
            IF nvl(i_actual_row.value_hidrics, -1) <> nvl(i_previous_row.value_hidrics, -1)
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_quant,
                             io_table_2 => o_tbl_values,
                             i_value_2  => CASE
                                               WHEN i_actual_row.value_hidrics IS NULL THEN
                                                l_desc_del_info
                                               ELSE
                                                pk_utils.number_to_char(i_prof, i_actual_row.value_hidrics) || l_eh_um
                                           END,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                IF (i_previous_row.value_hidrics IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_quant,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => pk_utils.number_to_char(i_prof, i_previous_row.value_hidrics) || l_eh_um,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --id_hidrics_device
            l_dev_prev := pk_inp_hidrics.get_device_desc(i_lang,
                                                         i_prof,
                                                         i_previous_row.id_epis_hidrics_det,
                                                         i_previous_row.dt_epis_hidrics_det_hist);
            l_dev_act  := pk_inp_hidrics.get_device_desc(i_lang,
                                                         i_prof,
                                                         i_actual_row.id_epis_hidrics_det,
                                                         i_actual_row.dt_epis_hidrics_det_hist);
        
            IF nvl(l_dev_prev, '-1') <> nvl(l_dev_act, '-1')
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_device,
                             io_table_2 => o_tbl_values,
                             i_value_2  => CASE
                                               WHEN i_actual_row.id_hidrics_device IS NULL THEN
                                                l_desc_del_info
                                               ELSE
                                                l_dev_act
                                           END,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                IF (i_previous_row.id_hidrics_device IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_device,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => l_dev_prev,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --flg_type
            IF i_actual_row.flg_type <> i_previous_row.flg_type
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_type,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => g_cd_ehd_flg_type,
                                                                   i_val      => i_actual_row.flg_type,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_type,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_sysdomain.get_domain(i_code_dom => g_cd_ehd_flg_type,
                                                                   i_val      => i_previous_row.flg_type,
                                                                   i_lang     => i_lang),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            END IF;
        
            --Collector device
            IF l_hid_type = pk_inp_hidrics_constant.g_hidrics_flg_type_e
            THEN
            
                IF NOT get_collector_data(i_lang                  => i_lang,
                                          i_prof                  => i_prof,
                                          i_id_epis_hid_collector => i_previous_row.id_epis_hid_collector,
                                          i_dt_epis_hid_collector => i_previous_row.dt_epis_hidrics_det,
                                          o_level_control         => l_level_control_prev,
                                          o_curr_level            => l_curr_level_prev,
                                          o_flg_restart           => l_flg_restart_prev,
                                          o_error                 => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                IF NOT get_collector_data(i_lang                  => i_lang,
                                          i_prof                  => i_prof,
                                          i_id_epis_hid_collector => i_actual_row.id_epis_hid_collector,
                                          i_dt_epis_hid_collector => i_actual_row.dt_epis_hidrics_det,
                                          o_level_control         => l_level_control_act,
                                          o_curr_level            => l_curr_level_act,
                                          o_flg_restart           => l_flg_restart_act,
                                          o_error                 => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                IF (l_level_control_prev <> l_level_control_act AND l_level_control_act IS NOT NULL AND
                   l_level_control_prev IS NOT NULL)
                   OR (l_curr_level_prev <> l_curr_level_act AND l_curr_level_act IS NOT NULL AND
                   l_curr_level_prev IS NOT NULL)
                   OR (l_flg_restart_prev <> l_flg_restart_act AND l_flg_restart_act IS NOT NULL AND
                   l_flg_restart_prev IS NOT NULL)
                THEN
                    --title: Collector device
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_device_coll,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => NULL,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                
                    --LEVEL CONTROL
                    IF (l_level_control_prev <> l_level_control_act)
                    THEN
                        add_3_values(io_table_1 => o_tbl_labels,
                                     i_value_1  => l_desc_level_control,
                                     io_table_2 => o_tbl_values,
                                     i_value_2  => pk_sysdomain.get_domain(i_code_dom => g_cd_ehc_flg_lvl_control,
                                                                           i_val      => l_level_control_act,
                                                                           i_lang     => i_lang),
                                     io_table_3 => o_tbl_types,
                                     i_value_3  => pk_inp_hidrics_constant.g_content_sc);
                    END IF;
                
                    --new collector field values
                    --new ACTUAL LEVEL
                    IF (nvl(l_curr_level_prev, -1) <> nvl(l_curr_level_act, -1))
                    THEN
                        IF (l_curr_level_prev IS NOT NULL)
                        THEN
                            add_3_values(io_table_1 => o_tbl_labels,
                                         i_value_1  => l_desc_new_actual_level,
                                         io_table_2 => o_tbl_values,
                                         i_value_2  => pk_utils.number_to_char(i_prof, l_curr_level_act) || l_eh_um,
                                         io_table_3 => o_tbl_types,
                                         i_value_3  => pk_inp_hidrics_constant.g_new_content_nsc);
                        END IF;
                    
                        --old actual level value
                        add_3_values(io_table_1 => o_tbl_labels,
                                     i_value_1  => nvl(l_desc_actual_level, pk_inp_hidrics_constant.g_detail_empty),
                                     io_table_2 => o_tbl_values,
                                     i_value_2  => pk_utils.number_to_char(i_prof, l_curr_level_prev) || l_eh_um,
                                     io_table_3 => o_tbl_types,
                                     i_value_3  => pk_inp_hidrics_constant.g_content_sc);
                    END IF;
                
                    --new RESTART
                    IF (l_flg_restart_act <> l_flg_restart_prev)
                    THEN
                        add_3_values(io_table_1 => o_tbl_labels,
                                     i_value_1  => l_desc_new_restart,
                                     io_table_2 => o_tbl_values,
                                     i_value_2  => pk_sysdomain.get_domain(i_code_dom => g_cd_ehc_flg_restart,
                                                                           i_val      => l_flg_restart_act,
                                                                           i_lang     => i_lang),
                                     io_table_3 => o_tbl_types,
                                     i_value_3  => pk_inp_hidrics_constant.g_new_content_nsc);
                    
                        add_3_values(io_table_1 => o_tbl_labels,
                                     i_value_1  => l_desc_restart,
                                     io_table_2 => o_tbl_values,
                                     i_value_2  => pk_sysdomain.get_domain(i_code_dom => g_cd_ehc_flg_restart,
                                                                           i_val      => l_flg_restart_prev,
                                                                           i_lang     => i_lang),
                                     io_table_3 => o_tbl_types,
                                     i_value_3  => pk_inp_hidrics_constant.g_content_sc);
                    END IF;
                
                    l_has_differences := TRUE;
                END IF;
            END IF;
        
            --i_row.notes
            IF nvl(i_previous_row.notes, '-1') <> nvl(i_actual_row.notes, '-1')
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_notes,
                             io_table_2 => o_tbl_values,
                             i_value_2  => nvl(i_actual_row.notes, l_desc_del_info),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                IF (i_previous_row.notes IS NOT NULL)
                THEN
                    add_3_values(io_table_1 => o_tbl_labels,
                                 i_value_1  => l_desc_notes,
                                 io_table_2 => o_tbl_values,
                                 i_value_2  => i_previous_row.notes,
                                 io_table_3 => o_tbl_types,
                                 i_value_3  => pk_inp_hidrics_constant.g_content_c);
                END IF;
            
                l_has_differences := TRUE;
            END IF;
        
            --i_row.dt_execution_tstz
            IF i_actual_row.dt_execution_tstz <> i_previous_row.dt_execution_tstz
            THEN
                --new value           
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_new_date,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                                       i_date => i_actual_row.dt_execution_tstz,
                                                                       i_inst => i_prof.institution,
                                                                       i_soft => i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_new_content_n);
            
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_date,
                             io_table_2 => o_tbl_values,
                             i_value_2  => pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                                       i_date => i_previous_row.dt_execution_tstz,
                                                                       i_inst => i_prof.institution,
                                                                       i_soft => i_prof.software),
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            
                l_has_differences := TRUE;
            END IF;
        
            IF (l_has_differences = FALSE)
            THEN
                add_3_values(io_table_1 => o_tbl_labels,
                             i_value_1  => l_desc_no_changes,
                             io_table_2 => o_tbl_values,
                             i_value_2  => NULL,
                             io_table_3 => o_tbl_types,
                             i_value_3  => pk_inp_hidrics_constant.g_content_c);
            END IF;
        
            --signature
            add_3_values(io_table_1 => o_tbl_labels,
                         i_value_1  => NULL,
                         io_table_2 => o_tbl_values,
                         i_value_2  => get_signature(i_lang                => i_lang,
                                                     i_prof                => i_prof,
                                                     i_id_episode          => l_id_episode,
                                                     i_date                => nvl(i_actual_row.dt_epis_hidrics_det,
                                                                                  i_actual_row.dt_creation_tstz),
                                                     i_id_prof_last_change => nvl(i_actual_row.id_prof_last_change,
                                                                                  i_actual_row.id_professional)),
                         io_table_3 => o_tbl_types,
                         i_value_3  => pk_inp_hidrics_constant.g_signature_s);
        
            RETURN TRUE;
        END get_values;
    
        FUNCTION get_info_labels RETURN table_varchar IS
            l_table table_varchar := table_varchar();
        BEGIN
            --RECORD_STATE
            add_value(io_table => l_table, i_value => 'RECORD_STATE_TO_FORMAT');
            --RECORD ACTION
            add_value(io_table => l_table, i_value => 'RECORD_ACTION');
        
            RETURN l_table;
        END get_info_labels;
    
        FUNCTION get_info_values(i_row IN epis_hidrics_det_hist%ROWTYPE) RETURN table_varchar IS
            l_table table_varchar := table_varchar();
        BEGIN
            --RECORD_STATE
            add_value(io_table => l_table,
                      i_value  => CASE
                                      WHEN i_row.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_c THEN
                                       pk_inp_hidrics_constant.g_epis_hid_det_status_c
                                      ELSE
                                       pk_inp_hidrics_constant.g_epis_hid_det_status_a
                                  END);
        
            --RECORD ACTION
            add_value(io_table => l_table, i_value => i_row.flg_action);
        
            RETURN l_table;
        END get_info_values;
    BEGIN
        l_desc_way           := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T062');
        l_desc_location      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T063');
        l_desc_intake        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T064');
        l_desc_output        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T092');
        l_desc_characts      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T065');
        l_desc_date          := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T014');
        l_desc_quant         := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T066');
        l_desc_type          := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T067');
        l_desc_notes         := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T018');
        l_desc_device_coll   := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T069');
        l_desc_level_control := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T070');
        l_desc_actual_level  := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T071');
        l_desc_restart       := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T072');
        l_desc_cancel_reason := pk_message.get_message(i_lang, i_prof, 'COMMON_M072');
        l_desc_cancel_notes  := pk_message.get_message(i_lang, i_prof, 'COMMON_M073');
        l_desc_status        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T115');
        l_desc_nr_times      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T097');
        l_desc_device        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T098');
    
        IF (i_flg_screen = pk_inp_hidrics_constant.g_hist_screen_h)
        THEN
            l_desc_new_characts     := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T119');
            l_desc_new_date         := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T120');
            l_desc_new_quant        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T121');
            l_desc_new_type         := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T122');
            l_desc_new_notes        := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T112');
            l_desc_new_actual_level := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T123');
            l_desc_new_restart      := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T124');
            l_desc_new_status       := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T116');
            l_desc_new_nr_times     := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T097');
            l_desc_new_device       := pk_message.get_message(i_lang, i_prof, 'HIDRICS_T132');
            l_desc_del_info         := pk_message.get_message(i_lang, i_prof, pk_inp_hidrics_constant.g_sm_detail_empty);
            l_desc_no_changes       := pk_message.get_message(i_lang, i_prof, pk_inp_hidrics_constant.g_sm_no_changes);
        END IF;
    
        g_error := 'GET HIST ID_EPIS_HIDRICS_DET ';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT t.*
          BULK COLLECT
          INTO l_tab_eh_det_hist
          FROM (SELECT ehdh.*
                  FROM epis_hidrics_det_hist ehdh
                 WHERE ehdh.id_epis_hidrics_det IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                     column_value
                                                      FROM TABLE(i_epis_hidrics_det) t1)
                   AND i_flg_screen = pk_inp_hidrics_constant.g_hist_screen_h
                UNION ALL
                SELECT e.id_epis_hidrics_det,
                       g_sysdate_tstz dt_epis_hidrics_det_hist,
                       e.id_epis_hidrics,
                       e.id_professional,
                       e.value_hidrics,
                       e.id_prof_cancel,
                       e.id_epis_hidrics_balance,
                       e.notes,
                       e.dt_creation_tstz,
                       e.dt_cancel_tstz,
                       e.dt_execution_tstz,
                       e.flg_type,
                       e.flg_status,
                       e.id_prof_line,
                       e.dt_prof_line,
                       e.id_epis_hidrics_line,
                       e.id_epis_hid_collector,
                       e.id_cancel_reason,
                       e.notes_cancel,
                       e.create_user,
                       e.create_time,
                       e.create_institution,
                       e.update_user,
                       e.update_time,
                       e.update_institution,
                       e.id_prof_last_change,
                       e.dt_epis_hidrics_det,
                       e.flg_action,
                       e.nr_times,
                       e.id_hidrics_device,
                       e.id_epis_hid_ftxt_dev
                  FROM epis_hidrics_det e
                 WHERE e.id_epis_hidrics_det IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001)*/
                                                  column_value
                                                   FROM TABLE(i_epis_hidrics_det) t1)
                   AND (i_flg_screen IN
                       (pk_inp_hidrics_constant.g_detail_screen_d, pk_inp_hidrics_constant.g_hist_screen_h) OR
                       e.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a)) t
         ORDER BY t.dt_epis_hidrics_det_hist DESC, t.dt_execution_tstz DESC;
    
        g_error := 'tab_epis_hidrics_det_hist: ' || l_tab_eh_det_hist.count;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF l_tab_eh_det_hist.count != 0
        THEN
            l_is_first_line := TRUE;
        
            FOR i IN l_tab_eh_det_hist.first .. l_tab_eh_det_hist.last
            LOOP
                IF l_is_first_line
                THEN
                    g_error := 'CALL get_epis_hid_episode';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    IF NOT get_epis_hid_episode(i_lang            => i_lang,
                                                i_prof            => i_prof,
                                                i_id_epis_hidrics => l_tab_eh_det_hist(i).id_epis_hidrics,
                                                o_id_episode      => l_id_episode,
                                                o_error           => o_error)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                    g_error := 'GET LINE INFO - UNIT MEAS';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    l_eh_um := pk_inp_hidrics.get_hidrics_um(i_lang                  => i_lang,
                                                             i_prof                  => i_prof,
                                                             i_epis_hidrics          => l_tab_eh_det_hist(i).id_epis_hidrics,
                                                             i_dt_epis_hbalance_hist => l_tab_eh_det_hist(i).dt_epis_hidrics_det_hist);
                
                    IF l_eh_um IS NOT NULL
                    THEN
                        l_eh_um := ' ' || l_eh_um;
                    END IF;
                
                    g_error := 'GET LINE INFO - WAY';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    l_hid_way := pk_inp_hidrics.get_hidrics_way(i_lang                  => i_lang,
                                                                i_prof                  => i_prof,
                                                                i_epis_hidrics_line     => l_tab_eh_det_hist(i).id_epis_hidrics_line,
                                                                i_dt_epis_hid_line_hist => l_tab_eh_det_hist(i).dt_epis_hidrics_det_hist);
                    g_error   := 'GET LINE INFO - LOC';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    l_hid_loc := pk_inp_hidrics.get_hidrics_location(i_lang                  => i_lang,
                                                                     i_prof                  => i_prof,
                                                                     i_epis_hidrics_line     => l_tab_eh_det_hist(i).id_epis_hidrics_line,
                                                                     i_dt_epis_hid_line_hist => l_tab_eh_det_hist(i).dt_epis_hidrics_det_hist);
                    g_error   := 'GET LINE INFO - HID';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    l_hid := pk_inp_hidrics.get_hidrics_desc(i_lang                  => i_lang,
                                                             i_prof                  => i_prof,
                                                             i_epis_hidrics_line     => l_tab_eh_det_hist(i).id_epis_hidrics_line,
                                                             i_dt_epis_hid_line_hist => l_tab_eh_det_hist(i).dt_epis_hidrics_det_hist);
                
                    g_error := 'GET LINE INFO - HID_TYPE';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    SELECT h.flg_type
                      INTO l_hid_type
                      FROM epis_hidrics_line ehl
                      JOIN hidrics h
                        ON h.id_hidrics = ehl.id_hidrics
                     WHERE ehl.id_epis_hidrics_line = l_tab_eh_det_hist(i).id_epis_hidrics_line;
                END IF;
            
                IF (i = l_tab_eh_det_hist.count OR i_flg_screen = pk_inp_hidrics_constant.g_detail_line_screen_l)
                THEN
                    IF (i_flg_screen = pk_inp_hidrics_constant.g_detail_line_screen_l)
                    THEN
                        l_index := i;
                    ELSE
                    
                        l_index := l_tab_eh_det_hist.count;
                    END IF;
                
                    IF NOT get_first_values(i_actual_row => l_tab_eh_det_hist(l_index),
                                            o_tbl_labels => l_tbl_lables,
                                            o_tbl_values => l_tbl_values,
                                            o_tbl_types  => l_tbl_types)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                ELSE
                    IF NOT get_values(i_actual_row   => l_tab_eh_det_hist(i),
                                      i_previous_row => l_tab_eh_det_hist(i + 1),
                                      o_tbl_labels   => l_tbl_lables,
                                      o_tbl_values   => l_tbl_values,
                                      o_tbl_types    => l_tbl_types)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                END IF;
            
                l_tab_hist.extend;
                l_tab_hist(l_tab_hist.count) := t_rec_epis_hid_hist(id_history      => l_tab_eh_det_hist(i).id_epis_hidrics_det,
                                                                    dt_history      => l_tab_eh_det_hist(i).dt_epis_hidrics_det_hist,
                                                                    tbl_labels      => l_tbl_lables,
                                                                    tbl_values      => l_tbl_values,
                                                                    tbl_types       => l_tbl_types,
                                                                    tbl_info_labels => get_info_labels(),
                                                                    tbl_info_values => get_info_values(l_tab_eh_det_hist(i)));
            
            END LOOP;
        END IF;
    
        g_error := 'OPEN O_HIST';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_hist FOR
            SELECT t.id_history      id_epis_hidrics_det,
                   t.dt_history      dt_epis_hidrics_det_hist,
                   t.tbl_labels      right_labels,
                   t.tbl_values      right_values,
                   t.tbl_types       types,
                   t.tbl_info_labels info_labels,
                   t.tbl_info_values info_values
              FROM TABLE(l_tab_hist) t;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_hist);
            RETURN FALSE;
    END get_epis_hidrics_res_hist;

    /**
    * Gets collector data
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics_line         Epis hidrics line id
    * @param   i_epis_hidrics              Epis hidrics id
    * @param   i_hid_way                   Hidrics way id
    * @param   i_hid_way_ft                Hidrics way free text
    * @param   i_bdy_part                  Body part id
    * @param   i_bdy_side                  Body side id
    * @param   i_location_ft               Location free text
    * @param   i_hid                       Hidrics id
    * @param   i_hid_ft                    Hidrics free text
    * @param   i_dt_execution              Execution date
    * @param   o_collector                 Collector cursor
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   17-06-2010
    */
    FUNCTION get_collector
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_epis_hidrics_line IN epis_hidrics_det.id_epis_hidrics_line%TYPE DEFAULT NULL,
        i_epis_hidrics      IN epis_hidrics.id_epis_hidrics%TYPE DEFAULT NULL,
        i_hid_way           IN way.id_way%TYPE DEFAULT NULL,
        i_hid_way_ft        IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_bdy_part          IN hidrics_location.id_body_part%TYPE DEFAULT NULL,
        i_bdy_side          IN hidrics_location.id_body_side%TYPE DEFAULT NULL,
        i_location_ft       IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_hid               IN hidrics.id_hidrics%TYPE DEFAULT NULL,
        i_hid_ft            IN epis_hidrics_det_ftxt.free_text%TYPE DEFAULT NULL,
        i_dt_execution      IN epis_hidrics_det.dt_execution_tstz%TYPE,
        o_collector         OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_RES_HIST';
        --
        l_epis_hidrics_line  epis_hidrics_det.id_epis_hidrics_line%TYPE;
        l_hid                hidrics.id_hidrics%TYPE;
        l_hid_flg_type       hidrics.flg_type%TYPE;
        l_epis_hid_collector epis_hidrics_det.id_epis_hid_collector%TYPE;
        l_curr_level         epis_hid_collector.curr_level%TYPE;
        l_hidrics_location   hidrics_location.id_hidrics_location%TYPE;
        l_collector          pk_types.cursor_type;
        l_last_collector     VARCHAR2(1 CHAR);
        --
        l_flg_level_control epis_hid_collector.flg_level_control%TYPE;
        l_flg_restart       epis_hid_collector.flg_restart%TYPE;
        --
        PROCEDURE set_default(i_flg_restart_avail VARCHAR2) IS
            l_func_name VARCHAR2(30 CHAR) := 'SET_DEFAULT';
        BEGIN
            g_error := 'OPEN O_COLLECTOR';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            OPEN l_collector FOR
                SELECT a.flg_lvl_ctl_available,
                       a.flg_rest_available,
                       pk_alert_constant.g_yes flg_lvl_control,
                       pk_sysdomain.get_domain(g_cd_ehc_flg_lvl_control, pk_alert_constant.g_yes, i_lang) desc_flg_lvl_control,
                       pk_alert_constant.g_no flg_restart,
                       pk_sysdomain.get_domain(g_cd_ehc_flg_restart, pk_alert_constant.g_no, i_lang) desc_flg_restart,
                       a.curr_level,
                       a.flg_last_collector
                  FROM (SELECT decode(l_hid_flg_type,
                                      pk_inp_hidrics_constant.g_hidrics_flg_type_e,
                                      pk_alert_constant.g_yes,
                                      pk_alert_constant.g_no) flg_lvl_ctl_available,
                               decode(l_hid_flg_type,
                                      pk_inp_hidrics_constant.g_hidrics_flg_type_e,
                                      i_flg_restart_avail,
                                      pk_alert_constant.g_no) flg_rest_available,
                               NULL curr_level,
                               NULL flg_last_collector
                          FROM dual) a;
        END set_default;
    BEGIN
        g_error := 'GET HIDRICS_LOCATION';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_hidrics_location := get_id_hid_location(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_body_part      => i_bdy_part,
                                                  i_body_side      => i_bdy_side,
                                                  i_body_part_ftxt => i_location_ft);
    
        IF i_epis_hidrics_line IS NULL
        THEN
            BEGIN
                g_error := 'GET FREE TEXT ID''s';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                l_epis_hidrics_line := get_epis_hidrics_line_id(i_lang         => i_lang,
                                                                i_prof         => i_prof,
                                                                i_epis_hidrics => i_epis_hidrics,
                                                                i_way          => i_hid_way,
                                                                i_way_ft       => i_hid_way_ft,
                                                                i_loc          => l_hidrics_location,
                                                                i_location_ft  => i_location_ft,
                                                                i_hid          => i_hid,
                                                                i_hid_ft       => i_hid_ft);
            EXCEPTION
                WHEN no_data_found THEN
                    l_epis_hidrics_line := NULL;
            END;
        ELSE
            l_epis_hidrics_line := i_epis_hidrics_line;
        END IF;
    
        BEGIN
            g_error := 'GET ID_HIDRICS';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            IF i_hid IS NOT NULL
            THEN
                l_hid := i_hid;
            ELSE
                SELECT ehl.id_hidrics
                  INTO l_hid
                  FROM epis_hidrics_line ehl
                 WHERE ehl.id_epis_hidrics_line = l_epis_hidrics_line;
            END IF;
        
            g_error := 'GET HIDRICS.FLG_TYPE. ID_HIDRICS: ' || l_hid;
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            SELECT h.flg_type
              INTO l_hid_flg_type
              FROM hidrics h
             WHERE h.id_hidrics = l_hid;
        EXCEPTION
            WHEN no_data_found THEN
                l_hid_flg_type := NULL;
        END;
    
        IF l_epis_hidrics_line IS NULL
        THEN
            g_error := 'SET DEFAULT 1';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            set_default(i_flg_restart_avail => pk_alert_constant.g_yes);
            o_collector := l_collector;
        ELSE
            BEGIN
                g_error := 'GET COLLECTOR. ID_EPIS_HIDRICS_LINE: ' || l_epis_hidrics_line || '; DT_EXECUTION: ' ||
                           i_dt_execution;
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                SELECT ehc.id_epis_hid_collector,
                       ehc.curr_level,
                       pk_inp_hidrics.is_last_collector(ehc.id_epis_hidrics_line, ehc.id_epis_hid_collector) flg_last_collector,
                       ehc.flg_level_control,
                       ehc.flg_restart
                  INTO l_epis_hid_collector, l_curr_level, l_last_collector, l_flg_level_control, l_flg_restart
                  FROM epis_hid_collector ehc
                 WHERE ehc.id_epis_hidrics_line = l_epis_hidrics_line
                   AND i_dt_execution BETWEEN ehc.dt_begin AND nvl(ehc.dt_end, i_dt_execution)
                   AND (i_dt_execution != ehc.dt_end OR ehc.dt_end IS NULL);
            
                g_error := 'OPEN O_COLLECTOR';
                alertlog.pk_alertlog.log_info(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_func_name);
                OPEN o_collector FOR
                    SELECT a.flg_lvl_ctl_available,
                           a.flg_rest_available,
                           l_flg_level_control flg_lvl_control,
                           pk_sysdomain.get_domain(g_cd_ehc_flg_lvl_control, l_flg_level_control, i_lang) desc_flg_lvl_control,
                           l_flg_restart flg_restart,
                           pk_sysdomain.get_domain(g_cd_ehc_flg_restart, l_flg_restart, i_lang) desc_flg_restart,
                           a.curr_level,
                           a.flg_last_collector
                      FROM (SELECT decode(l_hid_flg_type,
                                          pk_inp_hidrics_constant.g_hidrics_flg_type_e,
                                          pk_inp_hidrics.is_coll_flg_lvlc_avail(l_epis_hid_collector),
                                          pk_alert_constant.g_no) flg_lvl_ctl_available,
                                   decode(l_hid_flg_type,
                                          pk_inp_hidrics_constant.g_hidrics_flg_type_e,
                                          decode(l_last_collector,
                                                 pk_alert_constant.g_yes,
                                                 pk_inp_hidrics.is_coll_flg_rest_avail(l_epis_hidrics_line, i_dt_execution),
                                                 pk_alert_constant.g_no),
                                          pk_alert_constant.g_no) flg_rest_available,
                                   l_curr_level curr_level,
                                   l_last_collector flg_last_collector
                              FROM dual) a;
            EXCEPTION
                WHEN no_data_found THEN
                    g_error := 'SET DEFAULT 2';
                    alertlog.pk_alertlog.log_info(text            => g_error,
                                                  object_name     => g_package_name,
                                                  sub_object_name => l_func_name);
                    set_default(i_flg_restart_avail => pk_alert_constant.g_no);
                    o_collector := l_collector;
            END;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_collector);
            RETURN FALSE;
    END get_collector;

    /**
    * Is the flag level control of collector available
    *
    * @param   i_epis_hid_collector       Epis hidrics collector id
    *
    * @return  'Y' if is available, 'N' otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   17-06-2010
    */
    FUNCTION is_coll_flg_lvlc_avail(i_epis_hid_collector IN epis_hidrics_det.id_epis_hid_collector%TYPE) RETURN VARCHAR2 IS
        l_ret VARCHAR2(1 CHAR);
    BEGIN
        IF i_epis_hid_collector IS NULL
        THEN
            l_ret := pk_alert_constant.g_yes;
        ELSE
            l_ret := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_ret;
    END is_coll_flg_lvlc_avail;

    /**
    * Is the flag restart of collector available
    *
    * @param   i_epis_hid_line       Epis hidrics line id
    * @param   i_dt_execution        Execution date
    *
    * @return  'Y' if is available, 'N' otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   17-06-2010
    */
    FUNCTION is_coll_flg_rest_avail
    (
        i_epis_hid_line IN epis_hidrics_det.id_epis_hidrics_line%TYPE,
        i_dt_execution  IN epis_hidrics_det.dt_execution_tstz%TYPE
    ) RETURN VARCHAR2 IS
        l_count PLS_INTEGER;
        l_ret   VARCHAR2(1 CHAR);
    BEGIN
        SELECT COUNT(*)
          INTO l_count
          FROM epis_hidrics_det ehd
         WHERE ehd.id_epis_hid_collector IN
               (SELECT ehc.id_epis_hid_collector
                  FROM epis_hid_collector ehc
                 WHERE (ehc.dt_begin >= i_dt_execution OR
                       i_dt_execution BETWEEN ehc.dt_begin AND nvl(ehc.dt_end, g_sysdate_tstz))
                   AND ehc.id_epis_hidrics_line = i_epis_hid_line)
           AND ehd.dt_execution_tstz > i_dt_execution;
    
        IF l_count = 0
        THEN
            l_ret := pk_alert_constant.g_yes;
        ELSE
            l_ret := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_ret;
    END is_coll_flg_rest_avail;

    /**
    * Verifies if epis_hidrics has auto_balance
    *
    * @param   i_prof                Professional vector of information (professional ID, institution ID, software ID)
    * @param   i_epis_hidrics        Epis hidrics id
    *
    * @return  'Y' if it has auto_balance, 'N' otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   28-06-2010
    */
    FUNCTION has_auto_balance
    (
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(30 CHAR) := 'IS_COLL_FLG_REST_AVAIL';
        --
        l_hi_flg_type  hidrics_interval.flg_type%TYPE;
        l_auto_balance VARCHAR2(1 CHAR);
        l_ret          VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    BEGIN
        g_error := 'GET CFG (' || g_cfg_auto_balance || ')';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_auto_balance := pk_sysconfig.get_config(g_cfg_auto_balance, i_prof);
    
        IF l_auto_balance = pk_alert_constant.g_yes
        THEN
            g_error := 'GET HID_INTERVAL FLG_TYPE';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            SELECT hi.flg_type
              INTO l_hi_flg_type
              FROM epis_hidrics eh
              JOIN hidrics_interval hi
                ON hi.id_hidrics_interval = eh.id_hidrics_interval
             WHERE eh.id_epis_hidrics = i_epis_hidrics;
        
            IF l_hi_flg_type = pk_inp_hidrics_constant.g_hid_interval_type_n
            THEN
                l_ret := pk_alert_constant.g_no;
            ELSE
                l_ret := pk_alert_constant.g_yes;
            END IF;
        ELSE
            l_ret := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_ret;
    END has_auto_balance;

    /**
    * Verifies if the collector is the last collector
    *
    * @param   i_epis_hid_line             Epis hidrics line id
    * @param   i_epis_hid_collector        Epis hidrics collector id
    *
    * @return  'Y' if it has auto_balance, 'N' otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   01-07-2010
    */
    FUNCTION is_last_collector
    (
        i_epis_hid_line      IN epis_hid_collector.id_epis_hidrics_line%TYPE,
        i_epis_hid_collector IN epis_hid_collector.id_epis_hid_collector%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(30 CHAR) := 'IS_COLL_FLG_REST_AVAIL';
        --
        l_ret VARCHAR2(1 CHAR);
    BEGIN
        g_error := 'VERIFY IF IS LAST COLLECTOR';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT decode(i_epis_hid_collector, a.id_epis_hid_collector, pk_alert_constant.g_yes, pk_alert_constant.g_no)
          INTO l_ret
          FROM (SELECT ehc.id_epis_hid_collector,
                       row_number() over(ORDER BY decode(ehc.dt_end, NULL, 0, 1), ehc.dt_end DESC) line_number
                  FROM epis_hid_collector ehc
                 WHERE ehc.id_epis_hidrics_line = i_epis_hid_line
                   AND ehc.dt_begin = (SELECT MAX(ehc2.dt_begin)
                                         FROM epis_hid_collector ehc2
                                        WHERE ehc2.id_epis_hidrics_line = i_epis_hid_line)) a
         WHERE a.line_number = 1;
    
        RETURN l_ret;
    EXCEPTION
        WHEN no_data_found THEN
            g_error := 'NO COLLECTOR FOUND';
            alertlog.pk_alertlog.log_info(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
            RETURN NULL;
    END is_last_collector;

    /**********************************************************************************************
    * SET_MATCH_PAT_HIDRICS                  This function updates id_patient of tabel epis_hidrics
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_patient                       Patient
    * @param i_patient_temp                  Temporary patient 
    * @param o_error                         Error object
    *
    * @return                                Success / fail
    *
    * @author                                Alexandre Santos
    * @version                               2.6.0.3
    * @since                                 2010/07/03
    **********************************************************************************************/
    FUNCTION set_match_pat_hidrics
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_patient      IN patient.id_patient%TYPE,
        i_patient_temp IN patient.id_patient%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'SET_MATCH_PAT_HIDRICS';
        l_rowids    table_varchar := table_varchar();
    BEGIN
        g_error := 'SEND TO HIST - EPIS_HIDRICS i_where: id_patient = ' || i_patient_temp;
        pk_alertlog.log_debug(g_error);
        set_epis_hid_hist(i_where => 'id_patient = ' || i_patient_temp);
        --
        g_error := 'CALL TS_EPIS_HIDRICS_HIST.UPD WITH id_patient = ' || i_patient_temp;
        pk_alertlog.log_debug(g_error);
        ts_epis_hidrics_hist.upd(id_patient_in          => i_patient,
                                 id_patient_nin         => FALSE,
                                 id_prof_last_change_in => i_prof.id,
                                 dt_epis_hidrics_in     => g_sysdate_tstz,
                                 where_in               => 'id_patient = ' || i_patient_temp);
        --
        g_error := 'CALL TS_EPIS_HIDRICS.UPD WITH id_patient = ' || i_patient_temp;
        pk_alertlog.log_debug(g_error);
        ts_epis_hidrics.upd(id_patient_in          => i_patient,
                            id_patient_nin         => FALSE,
                            id_prof_last_change_in => i_prof.id,
                            dt_epis_hidrics_in     => g_sysdate_tstz,
                            where_in               => 'id_patient = ' || i_patient_temp,
                            rows_out               => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang, i_prof, 'EPIS_HIDRICS', l_rowids, o_error);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END set_match_pat_hidrics;

    /**
    * Get next balance date
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    *
    * @return  epis_hidrics next balance date
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   05-07-2010
    */
    FUNCTION get_dt_next_balance
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN epis_hidrics.dt_next_balance%TYPE IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_DT_NEXT_BALANCE';
        --
        l_dt_next_balance        epis_hidrics.dt_next_balance%TYPE;
        l_dt_ed_next_bal         epis_hidrics.dt_next_balance%TYPE;
        l_total_bal              PLS_INTEGER;
        l_previous_flg_close_bal epis_hidrics_balance.flg_close_type%TYPE;
        l_dt_open_tstz           epis_hidrics_balance.dt_open_tstz%TYPE;
        l_dt_open_tstz2          epis_hidrics_balance.dt_open_tstz%TYPE;
    
        l_sysdate TIMESTAMP(6) WITH LOCAL TIME ZONE;
    BEGIN
        l_sysdate := current_timestamp;
        --get_last balance
        BEGIN
            SELECT dt_open_tstz
              INTO l_dt_open_tstz2
              FROM (SELECT ehb2.dt_open_tstz,
                           row_number() over(PARTITION BY ehb2.id_epis_hidrics ORDER BY ehb2.dt_open_tstz DESC) rn
                      FROM epis_hidrics_balance ehb2
                     WHERE ehb2.id_epis_hidrics = i_epis_hidrics
                       AND ehb2.dt_open_tstz <= g_sysdate_tstz
                       AND ehb2.dt_open_tstz IS NOT NULL
                       AND ehb2.dt_close_balance_tstz IS NOT NULL
                       AND ehb2.flg_close_type = pk_inp_hidrics_constant.g_epis_hid_bal_closed_man_c)
             WHERE rn = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_dt_open_tstz2 := NULL;
        END;
    
        -- o balanço anterior foi fechado manual sem update da data de balanço
        BEGIN
            SELECT ehb.dt_open_tstz
              INTO l_dt_open_tstz
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics = i_epis_hidrics
               AND ehb.dt_open_tstz =
                   (SELECT MIN(ehb2.dt_open_tstz)
                      FROM epis_hidrics_balance ehb2
                     WHERE ehb2.id_epis_hidrics = ehb.id_epis_hidrics
                       AND ehb2.dt_open_tstz <= g_sysdate_tstz
                       AND ehb2.dt_close_balance_tstz IS NOT NULL
                       AND ehb2.flg_close_type = pk_inp_hidrics_constant.g_epis_hid_bal_closed_man_c
                          --valor minimo de C depois do ultimo B ou A
                          --valor minimo de C depois do ultimo B ou A
                       AND NOT EXISTS (SELECT 1
                              FROM epis_hidrics_balance ehb3
                             WHERE ehb3.id_epis_hidrics = ehb2.id_epis_hidrics
                               AND ehb3.dt_open_tstz > ehb2.dt_open_tstz
                               AND ehb3.flg_close_type IN
                                   (pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut,
                                    pk_inp_hidrics_constant.g_epis_hid_bal_closed_man_b)));
        EXCEPTION
            WHEN no_data_found THEN
                l_dt_open_tstz := NULL;
        END;
    
        IF l_dt_open_tstz IS NULL
        THEN
            BEGIN
                --o balanço anterior não foi um balanço manual, ou foi um balanço manual 
                --com alteração da data de próximo balanço para a data actual
                SELECT ehb.dt_open_tstz
                  INTO l_dt_open_tstz
                  FROM epis_hidrics_balance ehb
                 WHERE ehb.id_epis_hidrics = i_epis_hidrics
                   AND ehb.dt_open_tstz = (SELECT MAX(ehb2.dt_open_tstz)
                                             FROM epis_hidrics_balance ehb2
                                            WHERE ehb2.id_epis_hidrics = ehb.id_epis_hidrics
                                              AND ehb2.dt_open_tstz <= g_sysdate_tstz)
                   AND ehb.dt_close_balance_tstz IS NULL;
            EXCEPTION
                WHEN no_data_found THEN
                    l_dt_open_tstz := NULL;
            END;
        END IF;
    
        BEGIN
            SELECT ehb.flg_close_type
              INTO l_previous_flg_close_bal
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics = i_epis_hidrics
               AND ehb.dt_open_tstz = l_dt_open_tstz2;
        EXCEPTION
            WHEN no_data_found THEN
                l_previous_flg_close_bal := NULL;
        END;
    
        SELECT COUNT(1)
          INTO l_total_bal
          FROM epis_hidrics_balance ehb
         WHERE ehb.id_epis_hidrics = i_epis_hidrics
              --AND ehb.dt_close_balance_tstz > eh.dt_next_balance
           AND ehb.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_f;
    
        g_error := 'GET NEXT BALANCE DATE';
        --alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT nvl(l_dt_open_tstz, l_sysdate) +
               numtodsinterval(pk_inp_hidrics.get_epis_hidrics_interval(i_lang,
                                                                        i_prof,
                                                                        nvl(eh.interval_minutes, hi.interval_minutes),
                                                                        NULL),
                               'HOUR'),
               nvl(eh.dt_next_balance,
                   (nvl(l_dt_open_tstz, l_sysdate) +
                   numtodsinterval(pk_inp_hidrics.get_epis_hidrics_interval(i_lang,
                                                                             i_prof,
                                                                             nvl(eh.interval_minutes, hi.interval_minutes),
                                                                             NULL),
                                    'HOUR')))
          INTO l_dt_next_balance, l_dt_ed_next_bal
          FROM epis_hidrics eh
          JOIN hidrics_interval hi
            ON hi.id_hidrics_interval = eh.id_hidrics_interval
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        IF (((l_dt_ed_next_bal > l_dt_next_balance OR l_dt_ed_next_bal > g_sysdate_tstz) AND
           ( -- it is possible to perform manual balances even though the initial balance start date is not reached
            (l_previous_flg_close_bal NOT IN (pk_inp_hidrics_constant.g_epis_hid_bal_closed_man_b) OR
            l_previous_flg_close_bal IS NULL))
           
           ) OR l_total_bal = 0)
        
        THEN
            l_dt_next_balance := l_dt_ed_next_bal;
        END IF;
    
        RETURN l_dt_next_balance;
    END get_dt_next_balance;

    /**
    * Get next balance date
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics id
    *
    * @return  epis_hidrics next balance date
    *
    * @author  Alexandre Santos
    * @version v2.6.0.3
    * @since   05-07-2010
    */
    FUNCTION get_dt_next_balance
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        o_dt_next_balance OUT epis_hidrics.dt_next_balance%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_EPIS_HIDRICS_RES_HIST';
    BEGIN
        g_error := 'CALL TO GET_DT_NEXT_BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        o_dt_next_balance := pk_inp_hidrics.get_dt_next_balance(i_lang         => i_lang,
                                                                i_prof         => i_prof,
                                                                i_epis_hidrics => i_epis_hidrics);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_dt_next_balance;

    /*******************************************************************************************************************************************
    * get_hidrics_location            Get the location registered in this hidrics record
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_EPIS_HIDRICS_LINE      EPIS_HIDRICS_LINE ID
    * 
    * @return                         table_varchar with position 0 - description of location
    *                                                             1 - description of body_part
    *                                                             2 - description of body_side
    *
    * @author                         Alexandre Santos
    * @version                        2.6.0.3
    * @since                          2010/07/06
    *******************************************************************************************************************************************/
    FUNCTION get_hidrics_location_grid
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_epis_hidrics_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE
    ) RETURN table_varchar IS
        l_error t_error_out;
    
        l_desc_location  pk_translation.t_desc_translation;
        l_desc_body_part pk_translation.t_desc_translation;
        l_desc_body_side pk_translation.t_desc_translation;
    BEGIN
    
        IF NOT get_hidrics_location_int(i_lang              => i_lang,
                                        i_prof              => i_prof,
                                        i_epis_hidrics_line => i_epis_hidrics_line,
                                        o_desc_body_part    => l_desc_body_part,
                                        o_desc_body_side    => l_desc_body_side,
                                        o_desc_location     => l_desc_location,
                                        o_error             => l_error)
        THEN
            RAISE e_error;
        END IF;
    
        --
        RETURN table_varchar(l_desc_location, l_desc_body_part, l_desc_body_side);
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_LOCATION_GRID',
                                              l_error);
            RETURN NULL;
    END get_hidrics_location_grid;

    FUNCTION get_table_val
    (
        i_table IN table_varchar,
        i_index IN NUMBER
    ) RETURN VARCHAR2 IS
    BEGIN
        IF i_table IS NULL
           OR i_table.count < i_index
        THEN
            RETURN NULL;
        ELSE
            RETURN i_table(i_index);
        END IF;
    END get_table_val;

    FUNCTION get_job_next_date(i_date IN TIMESTAMP WITH LOCAL TIME ZONE) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
        l_date TIMESTAMP WITH TIME ZONE;
    BEGIN
        SELECT to_timestamp(to_char(decode(a.hr, 24, i_date + 1, i_date), 'YYYY-MM-DD ') || decode(a.hr, 24, 0, a.hr) || ':' || a.mn,
                            'YYYY-MM-DD HH24:MI') dt_next_run
          INTO l_date
          FROM (SELECT to_number(to_char(i_date, 'HH24')) + t.inc_hour hr, decode(t.inc_hour, 0, 30, 0) mn
                  FROM (SELECT CASE
                                    WHEN to_number(to_char(i_date, 'MI')) BETWEEN 0 AND 29 THEN
                                     0
                                    ELSE
                                     1
                                END inc_hour
                          FROM dual) t) a;
    
        RETURN l_date;
    END get_job_next_date;

    FUNCTION is_to_perform_balance
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN VARCHAR2 IS
        l_ret              VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_epis_hid_balance epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_total_a          PLS_INTEGER;
        l_total_e          PLS_INTEGER;
        l_times_admin      PLS_INTEGER;
        l_times_elimin     PLS_INTEGER;
        l_error            t_error_out;
    BEGIN
        g_error := 'GET EPIS_HID_BALANCE';
        alertlog.pk_alertlog.log_info(text => g_error);
        l_epis_hid_balance := pk_inp_hidrics.get_balance_id(i_lang         => i_lang,
                                                            i_prof         => i_prof,
                                                            i_epis_hidrics => i_epis_hidrics,
                                                            i_dt_exec      => g_sysdate_tstz);
    
        g_error := 'CALL TO GET_TOTAL_HIDRICS; ID_EPIS_HIDRICS_BALANCE: ' || l_epis_hid_balance;
        alertlog.pk_alertlog.log_info(text => g_error);
        IF NOT get_total_hidrics(i_lang          => i_lang,
                                 i_epis_hidrics  => i_epis_hidrics,
                                 i_epis_hid_bals => table_number(l_epis_hid_balance),
                                 i_date          => NULL,
                                 o_total_admin   => l_total_a,
                                 o_total_elimin  => l_total_e,
                                 o_times_admin   => l_times_admin,
                                 o_times_elimin  => l_times_elimin,
                                 o_error         => l_error)
        THEN
            g_error := 'ERROR GET_TOTAL_HIDRICS; ID_EPIS_HIDRICS_BALANCE: ' || l_epis_hid_balance;
            RAISE e_error;
        END IF;
    
        IF l_total_a > 0
           OR l_total_e > 0
           OR l_times_admin > 0
           OR l_times_elimin > 0
        THEN
            l_ret := pk_alert_constant.g_yes;
        END IF;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_constant.g_no;
    END is_to_perform_balance;

    /********************************************************************************************
    * get tasks status based in their requests
    *
    * @param       i_lang                 language id    
    * @param       i_prof                 professional structure
    * @param       i_episode              episode id
    * @param       i_task_request         array of requests that identifies the tasks
    * @param       o_task_status          cursor with all requested task status
    * @param       o_error                error structure for exception handling
    *
    * @return      boolean                true on success, otherwise false
    *
    * @author     Sofia Mendes
    * @version    2.5.1.x
    * @since      02-Sep-2010
    *
    * @dependencies    This function was developed to Content team
    ********************************************************************************************/
    FUNCTION get_task_status
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_task_status  OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_visit     episode.id_visit%TYPE;
        l_epis_hidrics table_number;
    BEGIN
        -- GET ID_VISIT: the hidrics are associated to the visit              
        g_error := 'CALL pk_episode.get_id_visit with id_episode: ' || i_episode;
        pk_alertlog.log_debug(g_error);
        l_id_visit := pk_episode.get_id_visit(i_episode => i_episode);
    
        -- GET ID_EPIS_HIDRICS DEPENDING OF PARAMETER i_task_request
        g_error := 'GET ID_EPIS_HIDRICS identifiers';
        IF (i_task_request IS NULL)
           OR (i_task_request.count = 0)
        THEN
            SELECT DISTINCT eh.id_epis_hidrics
              BULK COLLECT
              INTO l_epis_hidrics
              FROM epis_hidrics eh
             WHERE eh.id_episode IN (SELECT DISTINCT (epi.id_episode)
                                       FROM episode epi
                                      WHERE epi.id_visit = l_id_visit);
        ELSE
            l_epis_hidrics := i_task_request;
        END IF;
    
        -- GET RESULT TO RETURN
        g_error := 'GET CURSOR O_GRID';
        OPEN o_task_status FOR
            SELECT ht.id_hidrics_type id_task_type, eh.id_epis_hidrics id_task_request, eh.flg_status flg_status
              FROM epis_hidrics eh
             INNER JOIN episode epi
                ON (eh.id_episode = epi.id_episode)
             INNER JOIN epis_hidrics_balance ehb
                ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
             INNER JOIN hidrics_type ht
                ON (eh.id_hidrics_type = ht.id_hidrics_type)
             INNER JOIN (SELECT t.id_epis_hidrics_balance max_balance, t.id_epis_hidrics
                           FROM (SELECT ehb1.id_epis_hidrics_balance,
                                        eh1.id_epis_hidrics,
                                        row_number() over(PARTITION BY eh1.id_epis_hidrics ORDER BY ehb1.dt_register_tstz DESC) rn
                                   FROM epis_hidrics_balance ehb1, epis_hidrics eh1
                                  WHERE eh1.id_epis_hidrics IN (SELECT /*+opt_estimate (table t rows=0.00001)*/
                                                                 column_value
                                                                  FROM TABLE(l_epis_hidrics) t)
                                    AND eh1.id_epis_hidrics = ehb1.id_epis_hidrics) t
                          WHERE rn = 1) ehb2
                ON (ehb.id_epis_hidrics_balance = ehb2.max_balance)
             WHERE eh.id_epis_hidrics IN (SELECT /*+opt_estimate (table t rows=0.00001)*/
                                           column_value
                                            FROM TABLE(l_epis_hidrics) t)
               AND eh.flg_status <> pk_inp_hidrics_constant.g_epis_hidric_l;
        --
        RETURN TRUE;
        --
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TASK_STATUS',
                                              o_error);
            pk_types.open_my_cursor(o_task_status);
            RETURN FALSE;
    END get_task_status;

    /********************************************************************************************
    * get_epis_hidrics_descs                      Get the descriptions to be shown in the error popups.
    * To be used in the CPOE functions when different users are performing conflicting actions.
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_episode                 episode id 
    * @param       i_epis_hidrics            list of epis hidrics
    * @param       i_code_msg                Code Message to be used
    * @param       o_flg_show                  Y- should be shown an error popup
    * @param       o_msg_title                 Title to be shown in the popup if the o_flg_show = 'Y'
    * @param       o_msg                       Message to be shown in the popup if the o_flg_show = 'Y'
    * @param       o_error                   error message
    *        
    * @return      boolean                   true on success, otherwise false
    * 
    * @author                               Sofia Mendes
    * @version                               2.6.0.3.4
    * @since                                 08-Nov-2010
    ********************************************************************************************/
    FUNCTION get_epis_hidrics_descs
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_epis_hidrics IN table_number,
        i_code_msg     IN VARCHAR2,
        o_flg_show     OUT VARCHAR2,
        o_msg_title    OUT VARCHAR2,
        o_msg          OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_inst IS
            SELECT epi.id_institution, epi.id_epis_type
              FROM episode epi
             WHERE epi.id_episode = i_episode;
    
        l_inst c_inst%ROWTYPE;
    
        l_msg sys_message.desc_message%TYPE;
        l_ind PLS_INTEGER := 0;
    
    BEGIN
    
        IF (i_epis_hidrics IS NOT NULL AND i_epis_hidrics.exists(1))
        THEN
            g_error := 'GET CURSOR - INSTITUTION AND EPIS_TYPE';
            OPEN c_inst;
            FETCH c_inst
                INTO l_inst;
            CLOSE c_inst;
        
            FOR rec IN (SELECT decode(l_inst.id_epis_type,
                                      nvl(t_ti_log.get_epis_type(i_lang,
                                                                 i_prof,
                                                                 epi.id_epis_type,
                                                                 pk_inp_hidrics_constant.g_epis_hidric_r,
                                                                 eh.id_epis_hidrics,
                                                                 ht.flg_ti_type),
                                          epi.id_epis_type),
                                      pk_translation.get_translation(i_lang, ht.code_hidrics_type),
                                      pk_translation.get_translation(i_lang, ht.code_hidrics_type) || ' (' ||
                                      pk_message.get_message(i_lang,
                                                             profissional(i_prof.id,
                                                                          i_prof.institution,
                                                                          t_ti_log.get_epis_type_soft(i_lang,
                                                                                                      i_prof,
                                                                                                      epi.id_epis_type,
                                                                                                      pk_inp_hidrics_constant.g_epis_hidric_r,
                                                                                                      eh.id_epis_hidrics,
                                                                                                      ht.flg_ti_type)),
                                                             'IMAGE_T009') || ')') task_description,
                               
                               pk_prof_utils.get_name_signature(i_lang, i_prof, eh.id_professional) AS prof,
                               pk_date_utils.date_char_tsz(i_lang,
                                                           eh.dt_creation_tstz,
                                                           i_prof.institution,
                                                           i_prof.software) dt_creation
                          FROM epis_hidrics eh
                         INNER JOIN episode epi
                            ON (eh.id_episode = epi.id_episode)
                         INNER JOIN epis_hidrics_balance ehb
                            ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
                         INNER JOIN hidrics_type ht
                            ON (eh.id_hidrics_type = ht.id_hidrics_type)
                         WHERE eh.id_epis_hidrics IN (SELECT /*+opt_estimate (table t rows=0.00001)*/
                                                       column_value
                                                        FROM TABLE(i_epis_hidrics) t)
                        
                         ORDER BY pk_sysdomain.get_rank(i_lang, 'EPIS_HIDRICS_BALANCE.FLG_STATUS', ehb.flg_status),
                                  ehb.id_epis_hidrics_balance DESC)
            LOOP
                l_msg := l_msg || CASE
                             WHEN l_ind = 0 THEN
                              ''
                             ELSE
                              chr(10)
                         END || rec.task_description || '; ' || rec.prof || '; ' || rec.dt_creation;
                l_ind := l_ind + 1;
            END LOOP;
        
            o_flg_show  := pk_alert_constant.get_yes;
            o_msg_title := pk_message.get_message(i_lang => i_lang, i_prof => i_prof, i_code_mess => 'COMMON_T001');
            o_msg       := REPLACE(pk_message.get_message(i_lang => i_lang, i_prof => i_prof, i_code_mess => i_code_msg),
                                   '@1',
                                   l_msg);
        END IF;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_EPIS_HIDRICS_DESCS',
                                              o_error    => o_error);
            RETURN FALSE;
    END get_epis_hidrics_descs;

    /********************************************************************************************
    * Get the hidrics type of the hidrics of one line.
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_id_epis_hidrics_line    Epis hidrics line id     
    * @param       o_hidrics_flg_type        Hidrics flg type
    * @param       o_error                   error message
    *        
    * @return      boolean                   true on success, otherwise false
    * 
    * @author                               Sofia Mendes
    * @version                               2.6.0.5
    * @since                                 14-Jan-2011
    ********************************************************************************************/
    FUNCTION get_hidrics_type
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_epis_hidrics_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        o_hidrics_flg_type     OUT hidrics.flg_type%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'GET HIDRICS TYPE. i_id_epis_hidrics_line: ' || i_id_epis_hidrics_line;
        SELECT h.flg_type
          INTO o_hidrics_flg_type
          FROM epis_hidrics_line ehl
          JOIN hidrics h
            ON h.id_hidrics = ehl.id_hidrics
         WHERE ehl.id_epis_hidrics_line = i_id_epis_hidrics_line;
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_HIDRICS_TYPE',
                                              o_error    => o_error);
            RETURN FALSE;
        
    END get_hidrics_type;

    /********************************************************************************************
    * Get the episode associated to an epis_hidrics.
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_id_epis_hidrics         Epis hidrics  id     
    * @param       o_id_episode              episode id
    * @param       o_error                   error message
    *        
    * @return      boolean                   true on success, otherwise false
    * 
    * @author                               Sofia Mendes
    * @version                               2.6.0.5
    * @since                                 17-Jan-2011
    ********************************************************************************************/
    FUNCTION get_epis_hid_episode
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        o_id_episode      OUT episode.id_episode%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'GET id episode. i_id_epis_hidrics: ' || i_id_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        SELECT e.id_episode
          INTO o_id_episode
          FROM epis_hidrics e
         WHERE e.id_epis_hidrics = i_id_epis_hidrics;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_EPIS_HID_EPISODE',
                                              o_error    => o_error);
            RETURN FALSE;
    END get_epis_hid_episode;

    /********************************************************************************************
    * Get the hidrics flg_type (administration, elimination) associated to a line.
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_epis_hidrics_line       Epis hidrics line id     
    * @param       o_hid_flg_type            hidrics flg type
    * @param       o_error                   error message
    *        
    * @return      boolean                   true on success, otherwise false
    * 
    * @author                               Sofia Mendes
    * @version                               2.6.0.5
    * @since                                 17-Jan-2011
    ********************************************************************************************/
    FUNCTION get_line_hidrics_type
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_epis_hidrics_line IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        o_hid_flg_type      OUT hidrics.flg_type%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30 CHAR) := 'GET_LINE_HIDRICS_TYPE';
    BEGIN
        g_error := 'GET hidrics flg_type. i_epis_hidrics_line: ' || i_epis_hidrics_line;
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT h.flg_type
          INTO o_hid_flg_type
          FROM epis_hidrics_line e
          JOIN hidrics h
            ON h.id_hidrics = e.id_hidrics
         WHERE e.id_epis_hidrics_line = i_epis_hidrics_line;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_LINE_HIDRICS_TYPE',
                                              o_error    => o_error);
            RETURN FALSE;
    END get_line_hidrics_type;

    /********************************************************************************************
    * Checks if the i_prof.id is the professional that requested the intake/output or if he is a professional
    * that changed the request.
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_id_balance              Balance id        
    *        
    * @return      pls_integer              1-The i_prof is the requesting profesional
    *                                       0-otherwise
    * 
    * @author                               Sofia Mendes
    * @version                               2.6.1
    * @since                                 18-Apr-2011
    ********************************************************************************************/
    FUNCTION check_prof_requested
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_balance IN epis_hidrics_balance.id_epis_hidrics%TYPE
    ) RETURN PLS_INTEGER IS
        l_id_epis_hidrics epis_hidrics.id_epis_hidrics%TYPE;
        l_res             PLS_INTEGER := 0;
        l_error           t_error_out;
    BEGIN
        g_error := 'GET id_epis_hidrics. id_epis_hidrics_balance: ' || i_id_balance;
        pk_alertlog.log_debug(g_error);
        SELECT ehb.id_epis_hidrics
          INTO l_id_epis_hidrics
          FROM epis_hidrics_balance ehb
         WHERE ehb.id_epis_hidrics_balance = i_id_balance;
    
        g_error := 'GET request professionals. l_id_epis_hidrics: ' || l_id_epis_hidrics;
        pk_alertlog.log_debug(g_error);
        BEGIN
            SELECT COUNT(1)
              INTO l_res
              FROM (SELECT eh.id_professional
                      FROM epis_hidrics eh
                     WHERE eh.id_epis_hidrics = l_id_epis_hidrics
                       AND eh.id_professional = i_prof.id
                    
                    UNION ALL
                    SELECT eh.id_professional
                      FROM epis_hidrics_hist eh
                     WHERE eh.id_epis_hidrics = l_id_epis_hidrics
                       AND eh.id_professional = i_prof.id);
        EXCEPTION
            WHEN no_data_found THEN
                l_res := 0;
        END;
    
        --
        IF (l_res > 0)
        THEN
            l_res := 1;
        END IF;
    
        RETURN l_res;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'CHECK_PROF_REQUESTED',
                                              o_error    => l_error);
            RETURN l_res;
    END check_prof_requested;

    /*******************************************************************************************************************************************
    * Gets the hidrics list and executions to feed the PDMS screen based in a timeline 
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_FLG_SCOPE              Flag Type of Scope: P - Patient; E - episode; V - Visit
    * @param I_SCOPE                  Identifier to be filtered: id_patient - i_flg_scope = 'P', id_visit - i_flg_scope = 'V', id_episode - i_flg_scope = 'E'
    * @param I_START_DATE             Start date to be considered
    * @param I_END_DATE               End date to be considered
    * @param O_HIDRICS                Cursor that returns the intake and output requests that have executions (inputs or outputs)
    * @param O_HIDRICS_VALUE          Cursor that returns hidrics detail (the takes of each request)
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    * 
    * @raises                         PL/SQL generic error "OTHERS"
    * 
    * @author                         António Neto
    * @version                        2.6.1.2
    * @since                          07-Jul-2011
    *
    * @dependencies                   PDMS (when changing icons or when adding new icons, notify PDMS to add on Flex)
    *******************************************************************************************************************************************/
    FUNCTION get_epis_hidrics_pdms
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_flg_scope     IN VARCHAR2,
        i_scope         IN patient.id_patient%TYPE,
        i_start_date    IN VARCHAR2,
        i_end_date      IN VARCHAR2,
        o_hidrics       OUT pk_types.cursor_type,
        o_hidrics_value OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_hidrics_ids table_number;
    
        l_start_date_dt TIMESTAMP WITH TIME ZONE;
        l_end_date_dt   TIMESTAMP WITH TIME ZONE;
        l_internal_error EXCEPTION;
    
        l_id_patient patient.id_patient%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_episode episode.id_episode%TYPE;
    BEGIN
        --Initialize the scope vars
        g_error := 'ANALYSING SCOPE TYPE: i_flg_scope: ' || i_flg_scope || '; i_scope: ' || i_scope;
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        -- Convert start date to timestamp
        g_error := 'CALL GET_STRING_TSTZ FOR l_start_date_dt';
        IF NOT pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                             i_prof      => i_prof,
                                             i_timestamp => i_start_date,
                                             i_timezone  => NULL,
                                             o_timestamp => l_start_date_dt,
                                             o_error     => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        -- Convert end date to timestamp
        g_error := 'CALL GET_STRING_TSTZ FOR l_end_date_dt';
        IF NOT pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                             i_prof      => i_prof,
                                             i_timestamp => i_end_date,
                                             i_timezone  => NULL,
                                             o_timestamp => l_end_date_dt,
                                             o_error     => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        --Get ID's for the scope and for dates interval
        l_epis_hidrics_ids := tf_get_epis_hidrics_ids(i_id_patient => l_id_patient,
                                                      i_id_visit   => l_id_visit,
                                                      i_id_episode => l_id_episode,
                                                      i_start_date => l_start_date_dt,
                                                      i_end_date   => l_end_date_dt);
    
        --Get Intake/Output Requests
        g_error := 'CALL get_requests_pdms. i_flg_scope: ' || i_flg_scope || '; i_scope: ' || i_scope ||
                   '; l_start_date_dt: ' || CAST(l_start_date_dt AS VARCHAR2) || '; ' || '; l_end_date_dt: ' ||
                   CAST(l_end_date_dt AS VARCHAR2);
    
        IF NOT get_requests_pdms(i_lang             => i_lang,
                                 i_prof             => i_prof,
                                 i_flg_scope        => i_flg_scope,
                                 i_id_episode       => l_id_episode,
                                 i_id_patient       => l_id_patient,
                                 i_id_visit         => l_id_visit,
                                 i_start_date       => NULL,
                                 i_end_date         => NULL,
                                 i_epis_hidrics_ids => l_epis_hidrics_ids,
                                 i_scope            => i_scope,
                                 o_epis_hid         => o_hidrics,
                                 o_error            => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        --Get Intake/Output executions
        g_error := 'CALL get_takes_and_outputs.';
    
        IF NOT get_takes_and_outputs_pdms(i_lang             => i_lang,
                                          i_prof             => i_prof,
                                          i_epis_hidrics     => NULL,
                                          i_flg_scope        => i_flg_scope,
                                          i_id_episode       => l_id_episode,
                                          i_id_patient       => l_id_patient,
                                          i_id_visit         => l_id_visit,
                                          i_start_date       => l_start_date_dt,
                                          i_end_date         => l_end_date_dt,
                                          i_scope            => i_scope,
                                          i_epis_hidrics_ids => l_epis_hidrics_ids,
                                          o_epis_hid_det     => o_hidrics_value,
                                          o_error            => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_PDMS',
                                              o_error);
            pk_types.open_my_cursor(o_hidrics);
            pk_types.open_my_cursor(o_hidrics_value);
            RETURN FALSE;
    END get_epis_hidrics_pdms;

    FUNCTION get_fluid_balance_takes_string
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_dose               IN VARCHAR2,
        i_dt_take            IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_id_drug_presc_plan IN pk_api_pfh_in.r_presc_plan.id_presc_plan%TYPE,
        i_flg_total          IN VARCHAR2,
        i_unit_measure_desc  IN VARCHAR2,
        i_id_prof_exec       IN professional.id_professional%TYPE
    ) RETURN VARCHAR2 IS
        l_r                      VARCHAR2(4000);
        o_drug_administer_detail pk_types.cursor_type;
    BEGIN
    
        IF (i_dose IS NOT NULL AND i_dose != '0')
        THEN
            l_r := '+' || i_dose;
        
        END IF;
        l_r := l_r || pk_inp_hidrics_constant.g_separator || pk_date_utils.date_send_tsz(i_lang, i_dt_take, i_prof) ||
               pk_inp_hidrics_constant.g_separator || pk_inp_hidrics_constant.g_epis_hid_det_type_a ||
               pk_inp_hidrics_constant.g_separator || pk_inp_hidrics_constant.g_separator || i_id_drug_presc_plan ||
               pk_inp_hidrics_constant.g_separator || i_flg_total || pk_inp_hidrics_constant.g_separator ||
               pk_alert_constant.g_active || pk_inp_hidrics_constant.g_separator || pk_inp_hidrics_constant.g_separator || CASE
                   WHEN (i_dose IS NOT NULL AND i_dose != '0') THEN
                    pk_inp_hidrics.get_flowsheet_tooltip(i_lang             => i_lang,
                                                         i_prof             => i_prof,
                                                         i_epis_hidrics     => NULL,
                                                         i_epis_hidrics_det => NULL,
                                                         i_nr_times         => NULL,
                                                         i_value_hidrics    => NULL,
                                                         i_hidrics_device   => NULL,
                                                         i_professional     => i_id_prof_exec,
                                                         i_value_srt        => i_dose || ' ' || i_unit_measure_desc)
               END || pk_inp_hidrics_constant.g_separator;
        RETURN l_r;
    
    END get_fluid_balance_takes_string;

    /********************************************************************************************
    * Get IV fluids to an hidrics balance
    *
    * @param i_lang                   The language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_id_episode             the episode ID
    * @param i_filter_date            Filter date
    * @param o_pat_medication_list    Medication info 
    * @param o_error                  Error message
    *                        
    * @return                         true or false on success or error
    *
    * @author  Filipe Silva
    * @since   2011-09-26
    *
    ********************************************************************************************/
    FUNCTION get_fluid_balance_med
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN tf_fluid_balance_med IS
    
        l_fluid_balance_med  tf_fluid_balance_med;
        l_drug_prescriptions table_number;
    
        l_dt_initial_tstz epis_hidrics.dt_initial_tstz%TYPE;
        l_dt_end_tstz     epis_hidrics.dt_end_tstz%TYPE;
        l_id_episode      epis_hidrics.id_episode%TYPE;
    
        l_id_unit_measure unit_measure.id_unit_measure%TYPE;
    
        l_import_iv_fluids sys_config.id_sys_config%TYPE;
    
    BEGIN
        g_error := 'GET import_iv_fluids sys_config';
        pk_alertlog.log_debug(g_error);
        l_import_iv_fluids := pk_sysconfig.get_config(i_code_cf => pk_inp_hidrics_constant.g_import_iv_fluids,
                                                      i_prof    => i_prof);
    
        IF (l_import_iv_fluids = pk_alert_constant.g_yes)
        THEN
        
            l_id_unit_measure := pk_inp_hidrics.get_hidrics_um_id(i_lang, i_prof, i_id_epis_hidrics, NULL);
        
            SELECT eh.id_episode, eh.dt_initial_tstz, coalesce(eh.dt_end_tstz, eh.dt_inter_tstz, current_timestamp)
              INTO l_id_episode, l_dt_initial_tstz, l_dt_end_tstz
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = i_id_epis_hidrics;
        
            SELECT /*+opt_estimate (table med rows=1)*/
             med.id_presc
              BULK COLLECT
              INTO l_drug_prescriptions
              FROM TABLE(pk_api_pfh_clindoc_in.get_list_fluid_balance_basic(i_lang     => i_lang,
                                                                            i_prof     => i_prof,
                                                                            i_id_visit => pk_episode.get_id_visit(l_id_episode),
                                                                            i_dt_begin => l_dt_initial_tstz,
                                                                            i_dt_end   => l_dt_end_tstz)) med
              JOIN epis_hidrics eh
                ON med.id_episode_adm = eh.id_episode
             WHERE eh.id_epis_hidrics = i_id_epis_hidrics;
        
            WITH fluid_balance_tbl AS
             (SELECT /*+ materialize */
               id_presc,
               dt_execution_task,
               id_prof_writes,
               pk_rt_med_pfh.calc_administered_volume(i_id_presc           => id_presc,
                                                      i_id_presc_plan      => id_presc_plan,
                                                      i_id_presc_plan_task => id_presc_plan_task) qty,
               pk_rt_med_pfh.get_unit_measure_desc(i_lang, i_prof, id_unit_measure) id_unit_desc,
               pk_rt_med_pfh.get_route_desc(i_lang, i_prof, id_route, id_route_supplier, NULL) id_route_desc,
               pk_rt_med_pfh.get_prod_desc_by_presc(i_lang, i_prof, id_presc) g_id_presc_mci_desc_long
                FROM TABLE(pk_api_pfh_clindoc_in.get_list_fluid_balance_basic(i_lang     => i_lang,
                                                                              i_prof     => i_prof,
                                                                              i_id_visit => pk_episode.get_id_visit(l_id_episode),
                                                                              i_dt_begin => l_dt_initial_tstz,
                                                                              i_dt_end   => l_dt_end_tstz,
                                                                              i_id_presc => l_drug_prescriptions)))
            
            SELECT tr_fluid_balance_med(a.id_presc,
                                        a.description,
                                        a.id_unit_measure,
                                        a.unit_measure_description,
                                        a.string_take)
              BULK COLLECT
              INTO l_fluid_balance_med
              FROM (SELECT /*+ opt_estimate(table presc rows=1) */
                     presc.id_presc,
                     presc.g_id_presc_mci_desc_long || ' (' ||
                     pk_unit_measure.get_uom_abbreviation(i_lang, i_prof, l_id_unit_measure) || ')' description,
                     l_id_unit_measure id_unit_measure,
                     presc.id_route_desc unit_measure_description,
                     CAST(MULTISET
                          (SELECT get_fluid_balance_takes_string(i_lang,
                                                                 i_prof,
                                                                 nvl2(a.id_presc,
                                                                      to_char(a.dosage_exec),
                                                                      pk_inp_hidrics.get_hidrics_total_balance(i_lang,
                                                                                                               i_prof,
                                                                                                               i_id_epis_hidrics,
                                                                                                               a.id_epis_hidrics_balance,
                                                                                                               NULL,
                                                                                                               NULL,
                                                                                                               NULL,
                                                                                                               presc.id_presc,
                                                                                                               NULL,
                                                                                                               NULL,
                                                                                                               pk_alert_constant.g_yes,
                                                                                                               NULL,
                                                                                                               NULL)),
                                                                 a.dt_reg,
                                                                 a.id_drug_presc_plan,
                                                                 a.flg_total,
                                                                 a.unit_measure_desc,
                                                                 id_prof_exec)
                           
                             FROM (SELECT /*+ opt_estimate(table med rows=1) */
                                    SUM(med.qty) dosage_exec,
                                    med.id_unit_desc unit_measure_desc,
                                    pk_date_utils.trunc_insttimezone(i_prof.institution,
                                                                     i_prof.software,
                                                                     med.dt_execution_task,
                                                                     'MI') dt_reg,
                                    -1 id_drug_presc_plan,
                                    NULL id_epis_hidrics_balance,
                                    pk_inp_hidrics_constant.g_element_normal flg_total,
                                    med.id_presc,
                                    med.id_prof_writes id_prof_exec
                                     FROM fluid_balance_tbl med
                                    GROUP BY med.id_unit_desc, med.dt_execution_task, med.id_presc, med.id_prof_writes
                                   UNION ALL
                                   
                                   SELECT NULL                                    dosage_exec,
                                          NULL                                    unit_measure_desc,
                                          eb2.dt_close_balance_tstz               dt_reg,
                                          NULL                                    id_drug_presc_plan,
                                          eb2.id_epis_hidrics_balance,
                                          pk_inp_hidrics_constant.g_element_total flg_total,
                                          NULL                                    id_presc,
                                          NULL                                    id_prof_exec
                                     FROM epis_hidrics_balance eb2
                                    WHERE eb2.id_epis_hidrics = i_id_epis_hidrics
                                      AND eb2.dt_close_balance_tstz IS NOT NULL
                                    ORDER BY dt_reg) a
                            WHERE nvl(a.id_presc, presc.id_presc) = presc.id_presc
                              AND (a.flg_total = pk_inp_hidrics_constant.g_element_total OR
                                   a.dt_reg BETWEEN l_dt_initial_tstz AND l_dt_end_tstz)) AS table_varchar) AS string_take,
                     row_number() over(ORDER BY presc.id_presc) row_number
                      FROM (SELECT /*+ opt_estimate(table t_int rows=1 ) */
                            DISTINCT t_int.id_presc, t_int.id_route_desc, t_int.g_id_presc_mci_desc_long
                              FROM fluid_balance_tbl t_int) presc) a;
        
        END IF;
    
        RETURN l_fluid_balance_med;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN tf_fluid_balance_med();
    END get_fluid_balance_med;

    /*******************************************************************************************************************************************
    * Get IV Fluids for Hidrics timeline    
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_FLG_SCOPE              Scope: P -patient; E- episode; V-visit; S-session
    * @param I_SCOPE                  Identifier to be filtered: id_patient - i_flg_scope = 'P', id_visit - i_flg_scope = 'V', id_episode - i_flg_scope = 'E'
    * @param I_START_DATE             Start date to be considered
    * @param I_END_DATE               End date to be considered
    * @param I_EPIS_HIDRICS_IDS       Array of Hidrics Episode Identifiers
    * 
    * @return                         Returns an array type of all fluids beteween the date interval and for the Identifiers of Hidrics Episodes
    * 
    * @author                         Filipe Silva
    * @version                        2.6.1.2
    * @since                          27-September-2011
    * @Notes                         Merge the logic in pk_api_drug.get_fluid_balance_med_rep and pk_api_tr_med.get_fluid_balance_med_rep
    *******************************************************************************************************************************************/
    FUNCTION get_fluid_balance_med_rep
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_flg_scope        IN VARCHAR2,
        i_scope            IN NUMBER,
        i_start_date       IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date         IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_epis_hidrics_ids IN table_number
    ) RETURN tf_fluid_balance_med_rep IS
    
        l_fluid_balance_med tf_fluid_balance_med_rep := tf_fluid_balance_med_rep();
        l_id_patient        patient.id_patient%TYPE;
        l_id_visit          visit.id_visit%TYPE;
        l_id_episode        episode.id_episode%TYPE;
        o_error             t_error_out;
    
        l_import_iv_fluids sys_config.id_sys_config%TYPE;
    
    BEGIN
    
        g_error := 'GET import_iv_fluids sys_config';
    
        l_import_iv_fluids := pk_sysconfig.get_config(i_code_cf => pk_inp_hidrics_constant.g_import_iv_fluids,
                                                      i_prof    => i_prof);
    
        IF (l_import_iv_fluids = pk_alert_constant.g_yes)
        THEN
            g_error := 'GET SCOPE VARS FOR GET_FLUID_BALANCE_MED_REP';
            IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_scope      => i_scope,
                                                  i_scope_type => i_flg_scope,
                                                  o_patient    => l_id_patient,
                                                  o_visit      => l_id_visit,
                                                  o_episode    => l_id_episode,
                                                  o_error      => o_error)
            THEN
                pk_alertlog.log_error('Error in: ' || g_error);
            END IF;
        
            WITH fluid_balance AS
             (SELECT id_presc,
                     id_presc_plan,
                     id_route_desc,
                     g_id_presc_mci_desc_long,
                     dt_execution_task,
                     id_episode_adm,
                     id_prof_writes,
                     qty,
                     id_unit AS id_unit_measure,
                     id_route
                FROM TABLE(pk_api_pfh_clindoc_in.get_list_fluid_balance(i_lang       => i_lang,
                                                                        i_prof       => i_prof,
                                                                        i_id_visit   => l_id_visit,
                                                                        i_id_unit    => NULL,
                                                                        i_dt_begin   => i_start_date,
                                                                        i_dt_end     => i_end_date,
                                                                        i_id_patient => l_id_patient)) med),
            reg_hidrics AS
             (SELECT t.id_epis_hidrics, t.id_episode, t.id_visit
                FROM TABLE(tf_get_reg_hidrics(i_id_patient       => l_id_patient,
                                              i_epis_hidrics_ids => i_epis_hidrics_ids,
                                              i_id_visit         => l_id_visit,
                                              i_id_episode       => l_id_episode)) t)
            
            SELECT /*+opt_estimate (table reg_hidrics rows=1)*/
             tr_fluid_balance_med_rep(eh.id_epis_hidrics,
                                      eh.id_episode,
                                      eh.id_visit,
                                      NULL,
                                      fb.id_presc_plan,
                                      fb.id_presc,
                                      fb.g_id_presc_mci_desc_long,
                                      pk_unit_measure.get_uom_abbreviation(i_lang, i_prof, fb.id_unit_measure),
                                      fb.id_unit_measure,
                                      fb.id_route_desc,
                                      fb.qty,
                                      fb.id_prof_writes,
                                      pk_date_utils.trunc_insttimezone(i_prof.institution,
                                                                       i_prof.software,
                                                                       fb.dt_execution_task,
                                                                       'MI'),
                                      id_route,
                                      id_route)
              BULK COLLECT
              INTO l_fluid_balance_med
              FROM fluid_balance fb
             INNER JOIN reg_hidrics eh
                ON eh.id_episode = fb.id_episode_adm
             WHERE fb.id_unit_measure =
                   (SELECT pk_inp_hidrics.get_hidrics_um_id(i_lang, i_prof, eh.id_epis_hidrics, NULL)
                      FROM dual)
               AND ((i_start_date IS NULL AND i_end_date IS NULL) OR
                   fb.dt_execution_task BETWEEN i_start_date AND i_end_date);
        END IF;
    
        RETURN l_fluid_balance_med;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN tf_fluid_balance_med_rep();
    END get_fluid_balance_med_rep;

    /**
    * Expire tasks action (task will change its state to expired)
    *
    * @param       i_lang                    preferred language id for this professional
    * @param       i_prof                    professional id structure
    * @param       i_episode                 episode id
    * @param       i_task_requests           array of task request ids to expire
    * @param       o_error                   error message structure
    *
    * @return                                true on success, false otherwise
    * 
    * @author                                António Neto
    * @version                               2.5.1.8
    * @since                                 13-Sep-2011
    */
    FUNCTION expire_task
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_task_requests IN table_number,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        co_function_name CONSTANT VARCHAR2(30 CHAR) := 'EXPIRE_TASK';
    
        l_expired_note sys_message.desc_message%TYPE;
    
        l_flg_status epis_hidrics.flg_status%TYPE;
        l_num_tasks  PLS_INTEGER;
        l_msg_error  VARCHAR2(4000 CHAR);
        error_in_epis_hidric_reg EXCEPTION;
    BEGIN
        -- Sanity check
        IF i_task_requests IS NULL
           OR i_episode IS NULL
        THEN
            g_error := 'Invalid input arguments';
            pk_alertlog.log_warn(text => g_error, object_name => g_package_name, sub_object_name => co_function_name);
            RETURN TRUE;
        END IF;
    
        -- Text to include as cancellation note: "This patient's prescription (CPOE) has expired."
        l_expired_note := pk_message.get_message(i_lang, 'CPOE_M014');
    
        g_sysdate_tstz := current_timestamp;
    
        l_num_tasks := i_task_requests.count;
        --
        FOR i IN 1 .. l_num_tasks
        LOOP
            g_error := 'VALIDATE THAT ID_EPIS_HIDRICS CORRENPONDS TO ID_EPISODE';
            pk_alertlog.log_debug(g_error);
            BEGIN
                SELECT decode(eh.flg_status,
                              pk_inp_hidrics_constant.g_epis_hidric_d,
                              g_flg_task_status_d,
                              g_flg_task_status_f)
                  INTO l_flg_status
                  FROM epis_hidrics eh
                 WHERE eh.id_epis_hidrics = i_task_requests(i)
                   AND eh.id_episode = i_episode
                   AND eh.flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_r,
                                         pk_inp_hidrics_constant.g_epis_hidric_e,
                                         pk_inp_hidrics_constant.g_epis_hidric_d);
            
            EXCEPTION
                WHEN no_data_found THEN
                    l_flg_status := NULL;
            END;
        
            IF l_flg_status IS NOT NULL
            THEN
                BEGIN
                    g_error := 'CALL PK_INP_HIDRICS.SET_EPIS_HID_STATUS WITH ID_EPIS_HIDRIC = ' || i_task_requests(i);
                    pk_alertlog.log_debug(g_error);
                    IF NOT set_epis_hid_status(i_lang            => i_lang,
                                          i_prof            => i_prof,
                                          i_epis_hidrics    => i_task_requests(i),
                                          i_flg_status      => CASE
                                                                   WHEN l_flg_status = g_flg_task_status_d THEN
                                                                    pk_inp_hidrics_constant.g_epis_hidric_l
                                                                   ELSE
                                                                    pk_inp_hidrics_constant.g_epis_hidric_o
                                                               END,
                                          i_notes           => l_expired_note,
                                          i_flg_task_status => l_flg_status,
                                          o_msg_error       => l_msg_error,
                                          o_error           => o_error)
                    THEN
                        RAISE error_in_epis_hidric_reg;
                    END IF;
                EXCEPTION
                    WHEN OTHERS THEN
                        RAISE error_in_epis_hidric_reg;
                END;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => co_function_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END expire_task;

    /**********************************************************************************************
    * Check the possibility to be recorded in the system an execution after the task was expired.
    * It was defined that it should be possible to record in the system the last execution made after the task expiration.
    * It should not be possible to record more than one excecution after the task was expired. 
    *
    * @param       i_lang                    Professional preferred language
    * @param       i_prof                    Professional identification and its context (institution and software)
    * @param       i_episode                 Episode ID
    * @param       i_task_request            Task request ID (ID_EPIS_HIDRICS)
    * @param       o_error                   Error information
    *
    * @return                                'Y' An execution is allowed. 'N' No execution is allowed (or the task has not expired).
    *
    * @author                                António Neto
    * @version                               2.5.1.8
    * @since                                 13-Sep-2011
    **********************************************************************************************/
    FUNCTION check_extra_take
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN cpoe_process_task.id_task_request%TYPE
    ) RETURN VARCHAR IS
        co_function_name CONSTANT VARCHAR2(30 CHAR) := 'CHECK_EXTRA_TAKE';
        l_error                   t_error_out;
        l_execution_allowed       VARCHAR2(1 CHAR);
        l_status                  epis_hidrics.flg_status%TYPE;
        l_dt_expire               epis_hidrics.dt_cancel_tstz%TYPE;
        l_post_expired_executions NUMBER;
    
    BEGIN
    
        -- Check if the task has expired
        g_error := 'Get status';
        SELECT eh.flg_status, eh.dt_cancel_tstz
          INTO l_status, l_dt_expire
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_task_request;
    
        -- By default assumes the execution is not allowed
        l_execution_allowed := pk_alert_constant.g_no;
    
        -- Hidrics expired 
        IF l_status = pk_inp_hidrics_constant.g_epis_hidric_o
        THEN
        
            -- Check if already exists one execution after the task was expired
            g_error := 'Counting post-expired executions';
            SELECT COUNT(*)
              INTO l_post_expired_executions
              FROM epis_hidrics_det ehd
             WHERE ehd.id_epis_hidrics = i_task_request
               AND ehd.id_prof_cancel IS NULL
               AND trunc(ehd.dt_creation_tstz, 'MI') >= trunc(l_dt_expire, 'MI');
        
            -- If there is not one execution after the task has been expired, then execution is allowed
            IF l_post_expired_executions = 0
            THEN
                l_execution_allowed := pk_alert_constant.g_yes;
            END IF;
        
        END IF;
    
        RETURN l_execution_allowed;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => co_function_name,
                                              o_error    => l_error);
            RAISE;
    END check_extra_take;

    /**********************************************************************************************
    * Returns the "expired hidric" timestamp for a hidric's detail ID
    *
    * @param       i_lang                    Professional preferred language
    * @param       i_prof                    Professional identification and its context (institution and software)
    * @param       i_id_epis_hidrics         Hidric's detail ID
    *
    * @return                                Timestamp of an expired hidric, NULL otherwise.
    *
    * @author                                António Neto
    * @version                               2.5.1.8
    * @since                                 13-Sep-2011
    **********************************************************************************************/
    FUNCTION get_expired_timestamp
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN cpoe_process.dt_cpoe_expired%TYPE IS
        co_function_name CONSTANT VARCHAR2(30 CHAR) := 'GET_EXPIRATION_DATE';
        l_timestamp cpoe_process.dt_cpoe_expired%TYPE;
        l_error     t_error_out;
    BEGIN
        -- When a Hidric is expired DT_CANCEL_TSTZ represents the expiration timestamp 
        SELECT eh.dt_cancel_tstz
          INTO l_timestamp
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_id_epis_hidrics
           AND eh.flg_status = pk_inp_hidrics_constant.g_epis_hidric_o;
    
        RETURN l_timestamp;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => co_function_name,
                                              o_error    => l_error);
            RETURN NULL;
    END get_expired_timestamp;

    /*******************************************************************************************************************************************
    * Checks if there is balances for a hidric episode within a range of dates
    * 
    * @param I_ID_EPIS_HIDRICS        HIDRICS EPISODE ID
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled
    * @param I_FLG_REPORT             Flag used to remove formatting
    * 
    * @return                         Returns 'Y' for existing balances otherwise 'N' is returned
    * 
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          10-Nov-2011
    *******************************************************************************************************************************************/
    FUNCTION check_has_balance
    (
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_start_date      IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date        IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_cancelled       IN VARCHAR2,
        i_flg_report      IN VARCHAR2
    ) RETURN VARCHAR2 IS
    
        l_has_balances VARCHAR2(1 CHAR);
    BEGIN
    
        SELECT decode(COUNT(*), 0, pk_alert_constant.g_no, pk_alert_constant.g_yes)
          INTO l_has_balances
          FROM epis_hidrics_balance ehb
         WHERE ehb.id_epis_hidrics = i_id_epis_hidrics
           AND ehb.dt_close_balance_tstz IS NOT NULL
           AND ehb.dt_open_tstz IS NOT NULL
           AND ehb.dt_close_balance_tstz BETWEEN nvl(i_start_date, ehb.dt_close_balance_tstz) AND
               nvl(i_end_date, ehb.dt_close_balance_tstz)
           AND (ehb.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_f OR
               (i_flg_report = pk_alert_constant.g_yes AND i_cancelled = pk_alert_constant.g_yes AND
               ehb.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_c));
    
        RETURN l_has_balances;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_constant.g_no;
    END check_has_balance;

    /*******************************************************************************************************************************************
    * Checks if there is executions for a hidric episode within a range of dates
    * 
    * @param I_ID_EPIS_HIDRICS        HIDRICS EPISODE ID
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled
    * @param I_FLG_REPORT             Flag used to remove formatting
    * 
    * @return                         Returns 'Y' for existing executions otherwise 'N' is returned
    * 
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          10-Nov-2011
    *******************************************************************************************************************************************/
    FUNCTION check_has_executions
    (
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_start_date      IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date        IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_cancelled       IN VARCHAR2,
        i_flg_report      IN VARCHAR2
    ) RETURN VARCHAR2 IS
    
        l_has_executions VARCHAR2(1 CHAR);
    BEGIN
    
        SELECT decode(COUNT(*), 0, pk_alert_constant.g_no, pk_alert_constant.g_yes)
          INTO l_has_executions
          FROM epis_hidrics_det ehd
         WHERE ehd.id_epis_hidrics = i_id_epis_hidrics
           AND ehd.dt_execution_tstz IS NOT NULL
           AND ehd.dt_execution_tstz BETWEEN nvl(i_start_date, ehd.dt_execution_tstz) AND
               nvl(i_end_date, ehd.dt_execution_tstz)
           AND (ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a OR
               (i_flg_report = pk_alert_constant.g_yes AND i_cancelled = pk_alert_constant.g_yes AND
               ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_c));
    
        RETURN l_has_executions;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_constant.g_no;
    END check_has_executions;

    /****************************************************************************************************************
    * Returns if it's possible to create/edit/cancel results and perform balance, it also returns the Execution Date
    *
    * @param       I_LANG                    Professional preferred language
    * @param       I_PROF                    Professional identification and its context (institution and software)
    * @param       I_ID_EPIS_HIDRICS         Hidric's Identifier
    * @param       O_FLG_RESULTS_CREATE      Flag gives permission to create/edit/cancel results and perform balance
    * @param       O_DT_EXEC_STR             Execution/Perform Balance Date
    * @param       O_ERROR                   Error information
    *
    * @value       I_LANG                   {*} '1' PT {*} '2' EN {*} '3' ES {*} '4' NL {*} '5' IT {*} '6' FR {*} '11' PT-BR
    * @value       O_FLG_RESULTS_CREATE     {*} 'Y' Yes {*} 'N' No
    *
    * @return                                true on success, false otherwise
    *
    * @author                                António Neto
    * @version                               2.6.1.5
    * @since                                 08-Nov-2011
    ****************************************************************************************************************/
    FUNCTION get_create_results_perm
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_epis_hidrics    IN epis_hidrics.id_epis_hidrics%TYPE,
        o_flg_results_create OUT VARCHAR2,
        o_dt_exec_str        OUT VARCHAR2,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'Fill variables O_FLG_RESULTS_CREATE and O_DT_EXEC_STR for i_id_epis_hidrics: ' || i_id_epis_hidrics;
        SELECT t.flg_results_create,
               pk_date_utils.get_timestamp_str(i_lang,
                                               i_prof,
                                               decode(t.flg_status,
                                                      pk_inp_hidrics_constant.g_epis_hidric_o,
                                                      decode(t.dt_end_tstz,
                                                             NULL,
                                                             trunc(t.dt_cancel_tstz, 'MI'),
                                                             least(t.dt_end_tstz, trunc(t.dt_cancel_tstz, 'MI'))),
                                                      decode(t.dt_next_expiration,
                                                             NULL,
                                                             t.dt_end_tstz,
                                                             least(t.dt_end_tstz, t.dt_next_expiration))),
                                               NULL)
          INTO o_flg_results_create, o_dt_exec_str
          FROM (SELECT decode(eh.flg_status,
                              pk_inp_hidrics_constant.g_epis_hidric_c,
                              pk_alert_constant.g_no,
                              pk_inp_hidrics_constant.g_epis_hidric_i,
                              pk_alert_constant.g_no,
                              pk_inp_hidrics_constant.g_epis_hidric_f,
                              pk_alert_constant.g_no,
                              pk_inp_hidrics_constant.g_epis_hidric_e,
                              pk_alert_constant.g_yes,
                              pk_inp_hidrics_constant.g_epis_hidric_r,
                              pk_alert_constant.g_yes,
                              pk_inp_hidrics_constant.g_epis_hidric_d,
                              pk_alert_constant.g_yes,
                              pk_inp_hidrics_constant.g_epis_hidric_o,
                              check_extra_take(i_lang, i_prof, eh.id_episode, eh.id_epis_hidrics),
                              pk_alert_constant.g_no) flg_results_create,
                       eh.flg_status,
                       eh.dt_end_tstz,
                       eh.dt_cancel_tstz,
                       decode(eh.flg_status,
                              pk_inp_hidrics_constant.g_epis_hidric_o,
                              NULL,
                              get_cpoe_end_date_by_task(i_lang, i_prof, i_id_epis_hidrics, ht.acronym)) dt_next_expiration
                
                  FROM epis_hidrics eh
                 INNER JOIN hidrics_type ht
                    ON eh.id_hidrics_type = ht.id_hidrics_type
                 WHERE eh.id_epis_hidrics = i_id_epis_hidrics) t;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_CREATE_RESULTS_PERM',
                                              o_error    => o_error);
            RETURN FALSE;
    END get_create_results_perm;

    /********************************************************************************************
    * get cpoe end date timestamp for a given task type/request
    *
    * @param       I_LANG                    preferred language id for this professional
    * @param       I_PROF                    professional id structure
    * @param       I_ID_EPIS_HIDRICS         Hidrics Episode Identifier
    * @param       I_ACRONYM                 Acronym for the Hidric Type
    *
    * @return      DATE/TIME                 Returns the next expiration date  
    * 
    * @author                                António Neto
    * @version                               2.6.1.5
    * @since                                 10-NOV-2011
    ********************************************************************************************/
    FUNCTION get_cpoe_end_date_by_task
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_acronym         IN hidrics_type.acronym%TYPE
    ) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
        l_error         t_error_out;
        l_dt_expiration TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
    BEGIN
    
        g_error := 'CALL TO PK_CPOE.GET_CPOE_END_DATE_BY_TASK';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_cpoe.get_cpoe_end_date_by_task(i_lang         => i_lang,
                                                 i_prof         => i_prof,
                                                 i_task_type    => CASE i_acronym
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_h THEN
                                                                        pk_alert_constant.g_task_type_hidric_in_out
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_d THEN
                                                                        pk_alert_constant.g_task_type_hidric_out
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_r THEN
                                                                        pk_alert_constant.g_task_type_hidric_drain
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_i THEN
                                                                        pk_alert_constant.g_task_type_hidric_in
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_o THEN
                                                                        pk_alert_constant.g_task_type_hidric_out_group
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_all THEN
                                                                        pk_alert_constant.g_task_type_hidric_out_all
                                                                       WHEN pk_inp_hidrics_constant.g_hid_type_g THEN
                                                                        pk_alert_constant.g_task_type_hidric_irrigations
                                                                       ELSE
                                                                        NULL
                                                                   END,
                                                 i_task_request => i_id_epis_hidrics,
                                                 o_end_date     => l_dt_expiration,
                                                 o_error        => l_error)
        THEN
            RETURN NULL;
        END IF;
    
        RETURN l_dt_expiration;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_CPOE_END_DATE_BY_TASK',
                                              l_error);
            RETURN NULL;
    END get_cpoe_end_date_by_task;

    FUNCTION get_epis_hidrics_sp_value(i_id_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE) RETURN NUMBER IS
        tbl_id             table_number;
        l_epis_hidrics_val NUMBER;
    BEGIN
        SELECT ehd.value_hidrics
          BULK COLLECT
          INTO tbl_id
          FROM epis_hidrics_det ehd
         WHERE ehd.id_epis_hidrics_det = i_id_epis_hidrics_det;
    
        IF tbl_id.count > 0
        THEN
            l_epis_hidrics_val := tbl_id(1);
        ELSE
            l_epis_hidrics_val := NULL;
        END IF;
        RETURN l_epis_hidrics_val;
    
    END get_epis_hidrics_sp_value;

    FUNCTION get_epis_hidrics_sp_desc
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE
    ) RETURN VARCHAR2 IS
    
        l_epis_hidrics_val VARCHAR2(4000);
        tbl_id             table_number;
    BEGIN
        SELECT ehd.id_epis_hidrics_line
          BULK COLLECT
          INTO tbl_id
          FROM epis_hidrics_det ehd
         WHERE ehd.id_epis_hidrics_det = i_id_epis_hidrics_det;
    
        IF tbl_id.count > 0
        THEN
            l_epis_hidrics_val := pk_inp_hidrics.get_hidrics_desc(i_lang              => i_lang,
                                                                  i_prof              => i_prof,
                                                                  i_epis_hidrics_line => tbl_id(1));
        
        ELSE
            l_epis_hidrics_val := NULL;
        END IF;
        RETURN l_epis_hidrics_val;
    END get_epis_hidrics_sp_desc;
    FUNCTION get_epis_hidrics_sp_nroftime
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_hidrics_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE
    ) RETURN VARCHAR2 IS
    
        l_epis_hidrics_val VARCHAR2(4000);
        tbl_id             table_number;
    BEGIN
        SELECT ehd.nr_times
          BULK COLLECT
          INTO tbl_id
          FROM epis_hidrics_det ehd
         WHERE ehd.id_epis_hidrics_det = i_id_epis_hidrics_det;
    
        IF tbl_id.count > 0
        THEN
            l_epis_hidrics_val := tbl_id(1);
        ELSE
            l_epis_hidrics_val := NULL;
        END IF;
        RETURN l_epis_hidrics_val;
    
    END get_epis_hidrics_sp_nroftime;

    /**
    * Get intake and output task description.
    *
    * @param i_lang         language identifier
    * @param i_prof         logged professional structure
    * @param i_epis_hidrics intake and output record identifier
    * @param i_epis_type    current episode type identifier
    *
    * @return               intake and output task description
    *
    * @author               Pedro Carneiro
    * @version               2.6.2
    * @since                2012/05/14
    */
    FUNCTION get_task_desc
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics          IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_type             IN episode.id_epis_type%TYPE := NULL,
        i_flg_description       IN pn_dblock_ttp_mkt.flg_description%TYPE DEFAULT NULL,
        i_description_condition IN pn_dblock_ttp_mkt.description_condition%TYPE DEFAULT NULL
    ) RETURN CLOB IS
        l_ret                   CLOB;
        l_buf                   VARCHAR2(1000 CHAR);
        l_epis_hidrics_value    VARCHAR2(1000 CHAR);
        l_epis_hidrics_desc     VARCHAR2(1000 CHAR);
        l_epis_hidrics_nroftime VARCHAR2(1000 CHAR);
        l_um_desc               pk_translation.t_desc_translation;
        l_max_intake            pk_translation.t_desc_translation;
        l_min_output            pk_translation.t_desc_translation;
        l_msg_max_in            sys_message.desc_message%TYPE;
        l_msg_min_out           sys_message.desc_message%TYPE;
        l_interval              pk_translation.t_desc_translation;
        l_hidric_desc_type      VARCHAR2(1000 CHAR);
        l_hidric_status         VARCHAR2(1000 CHAR);
        l_id_epis_hidrics_det   table_number;
    
        CURSOR c_hidrics IS
            SELECT eh.flg_status,
                   eh.dt_creation_tstz,
                   eh.dt_initial_tstz,
                   eh.flg_restricted,
                   eh.max_intake,
                   eh.min_output,
                   eh.interval_minutes,
                   ht.acronym,
                   e.id_epis_type,
                   ht.flg_ti_type,
                   ht.code_hidrics_type,
                   hi.code_hidrics_interval
              FROM epis_hidrics eh
              JOIN episode e
                ON eh.id_episode = e.id_episode
              JOIN hidrics_type ht
                ON eh.id_hidrics_type = ht.id_hidrics_type
              JOIN hidrics_interval hi
                ON eh.id_hidrics_interval = hi.id_hidrics_interval
             WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        r_hidrics c_hidrics%ROWTYPE;
    BEGIN
        IF i_epis_hidrics IS NULL
        THEN
            l_ret := NULL;
        ELSE
            dbms_lob.createtemporary(l_ret, TRUE);
        
            OPEN c_hidrics;
            FETCH c_hidrics
                INTO r_hidrics;
            CLOSE c_hidrics;
        
            l_hidric_desc_type := get_desc_hidric_type(i_lang               => i_lang,
                                                       i_prof               => i_prof,
                                                       i_linst_id_epis_type => nvl(i_epis_type, r_hidrics.id_epis_type),
                                                       i_epi_id_epis_type   => r_hidrics.id_epis_type,
                                                       i_id_epis_hidrics    => i_epis_hidrics,
                                                       i_flg_ti_type        => r_hidrics.flg_ti_type,
                                                       i_code_hidrics_type  => r_hidrics.code_hidrics_type);
            l_hidric_status    := get_hidric_status(i_lang => i_lang, i_flg_status => r_hidrics.flg_status);
        
            -- Input / output ongoing - Condition
            IF (i_flg_description = pk_prog_notes_constants.g_flg_description_c AND
               r_hidrics.flg_status = pk_inp_hidrics_constant.g_epis_hidric_e AND
               (r_hidrics.acronym IN (pk_inp_hidrics_constant.g_hid_type_o, pk_inp_hidrics_constant.g_hid_type_i)))
            THEN
                -- task description follows the following format:
                -- <request_type>: <status> - <start_date> ([<restriction>/]<interval>) <register_date>
                l_buf := l_hidric_desc_type || pk_inp_hidrics_constant.g_colon || pk_inp_hidrics_constant.g_space;
                dbms_lob.writeappend(l_ret, length(l_buf), l_buf);
            
                SELECT ehl.id_epis_hidrics_det
                  BULK COLLECT
                  INTO l_id_epis_hidrics_det
                  FROM epis_hidrics_det ehl
                 WHERE ehl.id_epis_hidrics = i_epis_hidrics
                 ORDER BY ehl.dt_creation_tstz ASC;
            
                IF l_id_epis_hidrics_det.count > 0
                THEN
                    FOR i IN 1 .. l_id_epis_hidrics_det.last
                    LOOP
                        -- quantity in mL   
                        l_epis_hidrics_value := get_epis_hidrics_sp_value(l_id_epis_hidrics_det(i));
                    
                        IF l_epis_hidrics_value IS NOT NULL
                        THEN
                            IF i = 1
                            THEN
                                l_buf := l_epis_hidrics_value || 'mL';
                            ELSE
                                l_buf := pk_inp_hidrics_constant.g_comma || pk_inp_hidrics_constant.g_space ||
                                         l_epis_hidrics_value || 'mL';
                            
                            END IF;
                            dbms_lob.writeappend(l_ret, length(l_buf), l_buf);
                        END IF;
                        -- hidrics desc
                        l_epis_hidrics_desc := get_epis_hidrics_sp_desc(i_lang                => i_lang,
                                                                        i_prof                => i_prof,
                                                                        i_id_epis_hidrics_det => l_id_epis_hidrics_det(i));
                    
                        IF l_epis_hidrics_desc IS NOT NULL
                        THEN
                            l_buf := pk_inp_hidrics_constant.g_space || pk_inp_hidrics_constant.g_right_slash ||
                                     pk_inp_hidrics_constant.g_space || l_epis_hidrics_desc;
                            dbms_lob.writeappend(l_ret, length(l_buf), l_buf);
                        END IF;
                    
                        l_epis_hidrics_nroftime := get_epis_hidrics_sp_nroftime(i_lang                => i_lang,
                                                                                i_prof                => i_prof,
                                                                                i_id_epis_hidrics_det => l_id_epis_hidrics_det(i));
                        IF l_epis_hidrics_nroftime IS NOT NULL
                        THEN
                            l_buf := pk_inp_hidrics_constant.g_space || pk_inp_hidrics_constant.g_hifen ||
                                     pk_inp_hidrics_constant.g_space || l_epis_hidrics_nroftime || 'x';
                            dbms_lob.writeappend(l_ret, length(l_buf), l_buf);
                        END IF;
                    END LOOP;
                END IF;
            ELSE
                -- task description follows the following format:
                -- <request_type>, <status> - <start_date> ([<restriction>/]<interval>) <register_date>
            
                l_buf := l_hidric_desc_type || pk_inp_hidrics_constant.g_comma || pk_inp_hidrics_constant.g_space ||
                         l_hidric_status;
                l_buf := l_buf || pk_inp_hidrics_constant.g_space || pk_inp_hidrics_constant.g_hifen ||
                         pk_inp_hidrics_constant.g_space ||
                         pk_date_utils.dt_chr_date_hour_tsz(i_lang => i_lang,
                                                            i_date => r_hidrics.dt_initial_tstz,
                                                            i_prof => i_prof);
                dbms_lob.writeappend(l_ret, length(l_buf), l_buf);
            
                l_interval := get_hidric_interval(i_lang                  => i_lang,
                                                  i_interval_minutes      => r_hidrics.interval_minutes,
                                                  i_msg_hour              => NULL,
                                                  i_msg_hours             => NULL,
                                                  i_msg_minute            => NULL,
                                                  i_msg_minutes           => NULL,
                                                  i_code_hidrics_interval => r_hidrics.code_hidrics_interval);
            
                IF r_hidrics.flg_restricted = pk_alert_constant.g_yes
                THEN
                    l_um_desc     := get_hidrics_um(i_lang         => i_lang,
                                                    i_prof         => i_prof,
                                                    i_epis_hidrics => i_epis_hidrics);
                    l_msg_max_in  := pk_message.get_message(i_lang      => i_lang,
                                                            i_prof      => i_prof,
                                                            i_code_mess => 'HIDRICS_M024');
                    l_msg_min_out := pk_message.get_message(i_lang      => i_lang,
                                                            i_prof      => i_prof,
                                                            i_code_mess => 'HIDRICS_M025');
                    l_max_intake  := get_intake_output_text(i_lang              => i_lang,
                                                            i_prof              => i_prof,
                                                            i_label             => l_msg_max_in,
                                                            i_value             => r_hidrics.max_intake,
                                                            i_unit_measure_desc => l_um_desc);
                    l_min_output  := get_intake_output_text(i_lang              => i_lang,
                                                            i_prof              => i_prof,
                                                            i_label             => l_msg_min_out,
                                                            i_value             => r_hidrics.min_output,
                                                            i_unit_measure_desc => l_um_desc);
                    IF l_max_intake IS NOT NULL
                    THEN
                        l_max_intake := l_max_intake || pk_inp_hidrics_constant.g_right_slash || l_interval;
                    END IF;
                    IF l_min_output IS NOT NULL
                    THEN
                        l_min_output := l_min_output || pk_inp_hidrics_constant.g_right_slash || l_interval;
                    END IF;
                
                    l_buf := pk_inp_hidrics_constant.g_comma || pk_inp_hidrics_constant.g_space ||
                             pk_message.get_message(i_lang => i_lang, i_code_mess => 'HIDRICS_T054') ||
                             pk_inp_hidrics_constant.g_space || pk_inp_hidrics_constant.g_open_bracket ||
                             pk_string_utils.concat_if_exists(i_str1 => l_max_intake,
                                                              i_str2 => l_min_output,
                                                              i_sep  => pk_inp_hidrics_constant.g_semicolon ||
                                                                        pk_inp_hidrics_constant.g_space) ||
                             pk_inp_hidrics_constant.g_close_bracket;
                ELSE
                    l_buf := pk_inp_hidrics_constant.g_space || pk_inp_hidrics_constant.g_open_bracket || l_interval ||
                             pk_inp_hidrics_constant.g_close_bracket;
                END IF;
            
                l_buf := l_buf || pk_inp_hidrics_constant.g_comma || pk_inp_hidrics_constant.g_space ||
                         pk_date_utils.dt_chr_date_hour_tsz(i_lang => i_lang,
                                                            i_date => r_hidrics.dt_creation_tstz,
                                                            i_prof => i_prof);
                dbms_lob.writeappend(l_ret, length(l_buf), l_buf);
            END IF;
        END IF;
    
        RETURN l_ret;
    END get_task_desc;

    /**
    * Get intake and output hidrics type based on the acronym.
    *
    * @param i_lang         language identifier
    * @param i_prof         logged professional structure
    * @param i_acronym      hidrics type acronym
    *
    * @return               Hidrics type Identifier
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                2012/05/14
    */
    FUNCTION get_hidric_type
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_acronym IN hidrics_type.acronym%TYPE
    ) RETURN hidrics_type.id_hidrics_type%TYPE IS
        l_id_hidrics_type hidrics_type.id_hidrics_type%TYPE;
        l_error           t_error_out;
    BEGIN
        g_error := 'get_hidric_type. i_acronym: ' || i_acronym;
        pk_alertlog.log_debug(g_error);
        SELECT ht.id_hidrics_type
          INTO l_id_hidrics_type
          FROM hidrics_type ht
         WHERE ht.acronym = i_acronym
           AND ht.flg_available = pk_alert_constant.g_yes;
    
        RETURN l_id_hidrics_type;
    
    EXCEPTION
        WHEN no_data_found THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              'No hidrics type found. i_acronym: ' || i_acronym,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRIC_TYPE',
                                              l_error);
            RETURN NULL;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRIC_TYPE',
                                              l_error);
            RETURN NULL;
    END get_hidric_type;

    /**
    * Get hidrics type acronym based on the hidrics type id.
    *
    * @param i_lang         language identifier
    * @param i_prof         logged professional structure
    * @param i_hidrics_type hidrics type id
    *
    * @return               Hidrics type Identifier
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                2012/05/18
    */
    FUNCTION get_hidric_type_acronym
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_hidrics_type IN hidrics_type.id_hidrics_type%TYPE
    ) RETURN hidrics_type.acronym%TYPE IS
        l_acronym hidrics_type.acronym%TYPE;
        l_error   t_error_out;
    BEGIN
        g_error := 'get_hidric_type_acronym. i_hidrics_type: ' || i_hidrics_type;
        pk_alertlog.log_debug(g_error);
        SELECT ht.acronym
          INTO l_acronym
          FROM hidrics_type ht
         WHERE ht.id_hidrics_type = i_hidrics_type
           AND ht.flg_available = pk_alert_constant.g_yes;
    
        RETURN l_acronym;
    
    EXCEPTION
        WHEN no_data_found THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              'No hidrics type acronym found. i_hidrics_type: ' || i_hidrics_type,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRIC_TYPE_ACRONYM',
                                              l_error);
            RETURN NULL;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRIC_TYPE_ACRONYM',
                                              l_error);
            RETURN NULL;
    END get_hidric_type_acronym;

    /**
    * Returns the most recent ehb id for the same problem
    *
    * @param i_epis_hidrics epis_hidrics ID
    *
    * @return                number with the ehb id 
    *
    * @author                  Paulo Teixeira
    * @since                   2012-08-14
    * @version                 v2.6.2
    */
    FUNCTION get_most_recent_ehb_id(i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE) RETURN NUMBER IS
        l_id_epis_hidrics_balance epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
    BEGIN
        SELECT t.id_epis_hidrics_balance
          INTO l_id_epis_hidrics_balance
          FROM (SELECT ehb.id_epis_hidrics_balance,
                       row_number() over(PARTITION BY ehb.id_epis_hidrics ORDER BY decode(ehb.dt_close_balance_tstz, NULL, g_sysdate_tstz + 1, ehb.dt_close_balance_tstz) DESC) rn
                  FROM epis_hidrics_balance ehb
                 WHERE ehb.id_epis_hidrics = i_epis_hidrics) t
         WHERE rn = pk_inp_hidrics_constant.g_last_hidrics_balance;
    
        RETURN l_id_epis_hidrics_balance;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_most_recent_ehb_id;
    ----------

    FUNCTION get_multichoice_lists_pdms
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_hid_flg_type IN hidrics.flg_type%TYPE,
        i_hidrics_type IN hidrics_type.id_hidrics_type%TYPE DEFAULT NULL,
        i_way          IN way.id_way%TYPE DEFAULT NULL,
        o_ways         OUT pk_types.cursor_type,
        o_hidrics      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name    VARCHAR2(30 CHAR) := 'get_multichoice_lists_pdms';
        l_inst_w       institution.id_institution%TYPE;
        l_soft_w       software.id_software%TYPE;
        l_department_w department.id_department%TYPE;
        l_dept_w       dept.id_dept%TYPE;
        l_id_market_w  market.id_market%TYPE;
        l_inst_h       institution.id_institution%TYPE;
        l_soft_h       software.id_software%TYPE;
        l_department_h department.id_department%TYPE;
        l_dept_h       dept.id_dept%TYPE;
        l_id_market_h  market.id_market%TYPE;
    BEGIN
    
        g_error := 'GET CONF VARS - WAYS';
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => NULL,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_w,
                             o_inst       => l_inst_w,
                             o_soft       => l_soft_w,
                             o_department => l_department_w,
                             o_dept       => l_dept_w,
                             o_id_market  => l_id_market_w,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        g_error := 'GET o_ways';
        OPEN o_ways FOR
            SELECT tbl.id_hidrics_way, tbl.desc_hidrics_way, tbl.flg_type
              FROM (SELECT tb.id_hidrics_way, tb.desc_hidrics_way, tb.flg_type
                      FROM (SELECT DISTINCT t.id_way id_hidrics_way, t.desc_hidrics_way, t.flg_type
                              FROM (SELECT hw.id_way,
                                           pk_translation.get_translation(i_lang, hw.code_way) desc_hidrics_way,
                                           hw.flg_way_type flg_type,
                                           hwr.id_hidrics
                                      FROM way hw
                                    
                                      JOIN hidrics_way_rel hwr
                                        ON hwr.id_way = hw.id_way
                                       AND hwr.flg_available = pk_alert_constant.g_yes
                                       AND hwr.id_hidrics_type = i_hidrics_type
                                       AND nvl(hwr.id_institution, 0) = l_inst_w
                                       AND nvl(hwr.id_market, 0) = l_id_market_w
                                    
                                     WHERE hw.flg_available = pk_alert_constant.g_yes
                                       AND hw.flg_way_type != pk_inp_hidrics_constant.g_hid_way_type_o
                                       AND hw.flg_type = i_hid_flg_type) t
                             WHERE t.desc_hidrics_way IS NOT NULL
                             ORDER BY t.desc_hidrics_way) tb) tbl
            UNION ALL
            SELECT hw.id_way id_hidrics_way,
                   pk_translation.get_translation(i_lang, hw.code_way) desc_hidrics_way,
                   hw.flg_way_type flg_type
              FROM way hw
             WHERE hw.flg_way_type = pk_inp_hidrics_constant.g_hid_way_type_o
               AND hw.flg_type = i_hid_flg_type
               AND hw.flg_available = pk_alert_constant.g_yes;
    
        g_error := 'GET CONF VARS - HIDRICS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT (get_cfg_vars(i_lang       => i_lang,
                             i_prof       => i_prof,
                             i_episode    => NULL,
                             i_cfg_type   => pk_inp_hidrics_constant.g_cfg_var_h,
                             o_inst       => l_inst_h,
                             o_soft       => l_soft_h,
                             o_department => l_department_h,
                             o_dept       => l_dept_h,
                             o_id_market  => l_id_market_h,
                             o_error      => o_error))
        THEN
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            RAISE e_error;
        END IF;
    
        g_error := 'GET HIDRICS';
        alertlog.pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_hidrics FOR
            SELECT *
              FROM (SELECT tint.id_hidrics,
                           tint.desc_hidrics,
                           tint.flg_type,
                           tint.flg_state,
                           tint.flg_free_txt,
                           tint.flg_nr_times
                      FROM (SELECT h.id_hidrics,
                                   pk_translation.get_translation(i_lang, h.code_hidrics) desc_hidrics,
                                   h.flg_type,
                                   hr.flg_state,
                                   h.flg_free_txt,
                                   h.flg_nr_times
                              FROM hidrics h
                            
                              JOIN hidrics_relation hr
                                ON hr.id_hidrics = h.id_hidrics
                               AND hr.flg_available = pk_alert_constant.g_yes
                               AND hr.flg_state = pk_alert_constant.g_active
                               AND hr.id_hidrics_type = i_hidrics_type
                               AND nvl(hr.id_software, 0) = l_soft_h
                               AND nvl(hr.id_institution, 0) = l_inst_h
                               AND nvl(hr.id_market, 0) = l_id_market_h
                            
                              JOIN hidrics_way_rel hwr
                                ON hwr.id_hidrics = h.id_hidrics
                               AND hwr.flg_available = pk_alert_constant.g_yes
                               AND hwr.id_hidrics_type = hr.id_hidrics_type
                               AND nvl(hwr.id_institution, 0) = l_inst_w
                               AND nvl(hwr.id_market, 0) = l_id_market_w
                            
                              JOIN way hw
                                ON hw.id_way = hwr.id_way
                               AND hw.flg_available = pk_alert_constant.g_yes
                               AND hw.flg_way_type != pk_inp_hidrics_constant.g_hid_way_type_o
                               AND hw.flg_type = i_hid_flg_type
                               AND hw.id_way = i_way
                            
                             WHERE h.flg_available = pk_alert_constant.g_yes
                               AND h.flg_type = i_hid_flg_type
                               AND h.flg_free_txt = pk_alert_constant.g_no) tint
                     WHERE tint.desc_hidrics IS NOT NULL)
            UNION ALL
            SELECT h.id_hidrics,
                   pk_translation.get_translation(i_lang, h.code_hidrics) desc_hidrics,
                   h.flg_type,
                   NULL flg_state,
                   h.flg_free_txt,
                   h.flg_nr_times
              FROM hidrics h
             WHERE h.flg_free_txt = pk_alert_constant.g_yes
               AND h.flg_available = pk_alert_constant.g_yes
               AND h.flg_type = i_hid_flg_type;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_hidrics);
            pk_types.open_my_cursor(o_ways);
            RETURN FALSE;
    END get_multichoice_lists_pdms;
    /*******************************************************************************************************************************************
    * get_flowsheet_actions           Get all actions for the flowsheet screen
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param i_hidrics_type           Hidrics type ID
    * @param O_CREATE_CHILDS          Child actions for the 'Fluid type' option in the create button
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    *
    * @author                         José Silva
    * @version                        2.6.0.3
    * @since                          2010/05/31
    *******************************************************************************************************************************************/
    FUNCTION get_flowsheet_actions
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_hidrics_type  IN hidrics_type.id_hidrics_type%TYPE,
        o_create_childs OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_subject_create CONSTANT action.subject%TYPE := 'HIDRICS_CREATE_GRID';
        l_hidric_acronym hidrics_type.acronym%TYPE;
        l_parent         action.id_action%TYPE;
        l_tab_hid_types  table_varchar := table_varchar();
        l_state_create_parent CONSTANT action.to_state%TYPE := 'C';
        l_show_irrigation sys_config.value%TYPE;
    
    BEGIN
    
        g_error           := 'GET SYSCONFIG INP_HIDRICS_SHOW_IRRIGATION_OPTION';
        l_show_irrigation := pk_sysconfig.get_config(i_code_cf   => 'INP_HIDRICS_SHOW_IRRIGATION_OPTION',
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software);
    
        g_error := 'GET HIDRICS ACRONYM';
        SELECT ht.acronym
          INTO l_hidric_acronym
          FROM hidrics_type ht
         WHERE ht.id_hidrics_type = i_hidrics_type;
    
        g_error := 'GET HIDRIC TYPES';
        IF l_hidric_acronym IN (pk_inp_hidrics_constant.g_hid_type_h, pk_inp_hidrics_constant.g_epis_hid_balance_i)
        THEN
            l_tab_hid_types.extend;
            l_tab_hid_types(l_tab_hid_types.count) := pk_inp_hidrics_constant.g_hidrics_flg_type_a;
        END IF;
    
        IF l_hidric_acronym IN (pk_inp_hidrics_constant.g_hid_type_h,
                                pk_inp_hidrics_constant.g_hid_type_d,
                                pk_inp_hidrics_constant.g_hid_type_r,
                                pk_inp_hidrics_constant.g_hid_type_all)
        THEN
            l_tab_hid_types.extend;
            l_tab_hid_types(l_tab_hid_types.count) := pk_inp_hidrics_constant.g_hidrics_flg_type_e;
        
        END IF;
    
        IF l_hidric_acronym = pk_inp_hidrics_constant.g_hid_type_g
        THEN
            l_tab_hid_types.extend;
            l_tab_hid_types(l_tab_hid_types.count) := pk_inp_hidrics_constant.g_hidrics_irrigations_g;
        END IF;
    
        IF l_hidric_acronym = pk_inp_hidrics_constant.g_hid_type_h
           AND l_show_irrigation = pk_alert_constant.get_yes
        THEN
            l_tab_hid_types.extend;
            l_tab_hid_types(l_tab_hid_types.count) := pk_inp_hidrics_constant.g_hidrics_irrigations_g;
        END IF;
    
        g_error := 'GET ID_PARENT';
        SELECT id_action
          INTO l_parent
          FROM action a
         WHERE a.subject = l_subject_create
           AND a.to_state = l_state_create_parent;
    
        g_error := 'GET CURSOR O_CREATE_CHILDS';
        OPEN o_create_childs FOR
            SELECT /*+opt_estimate (table t rows=0.00001)*/
             t.column_value to_state,
             l_parent id_parent,
             pk_sysdomain.get_domain('HIDRICS.FLG_TYPE', t.column_value, i_lang) desc_action,
             CASE
                  WHEN t.column_value = pk_inp_hidrics_constant.g_hid_type_g THEN
                   get_id_hidrics_type(i_lang => i_lang, i_prof => i_prof, i_acronym => t.column_value)
                  ELSE
                   NULL
              END hidrics_type_child
              FROM TABLE(l_tab_hid_types) t
             ORDER BY rownum;
    
        --
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_FLOWSHEET_ACTIONS',
                                              o_error);
            pk_types.open_my_cursor(o_create_childs);
            RETURN FALSE;
    END get_flowsheet_actions;
    ---

    FUNCTION get_epis_status_string
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_epis_hid IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN VARCHAR2 IS
        l_return              grid_task.hidrics_reg%TYPE;
        l_icon_type           VARCHAR2(24 CHAR);
        l_flg_status          epis_hidrics.flg_status%TYPE;
        l_id_hidrics_interval epis_hidrics.id_hidrics_interval%TYPE;
        l_dt_initial          epis_hidrics.dt_initial_tstz%TYPE;
        l_dt_begin_tstz       epis_hidrics.dt_next_balance%TYPE;
        l_shortcut            sys_shortcut.id_sys_shortcut%TYPE;
        l_error_out           t_error_out;
        l_hidrics_reg         grid_task.hidrics_reg%TYPE;
        l_server_date         VARCHAR2(200);
        l_code_flg_status     VARCHAR2(200 CHAR);
        l_flg_status_hd       epis_hidrics.flg_status%TYPE;
        l_icon                VARCHAR2(200 CHAR);
        l_value_date          VARCHAR2(200);
        l_aux                 VARCHAR2(200);
    BEGIN
        SELECT t.flg_status, t.id_hidrics_interval, t.dt_initial, t.dt_begin_tstz, t.flg_status_hd
          INTO l_flg_status, l_id_hidrics_interval, l_dt_initial, l_dt_begin_tstz, l_flg_status_hd
          FROM (SELECT decode(eh.flg_status, pk_inp_hidrics_constant.g_epis_hidric_o, eh.flg_status, ehb.flg_status) flg_status,
                       eh.id_hidrics_interval,
                       eh.dt_initial_tstz dt_initial,
                       eh.flg_status flg_status_hd,
                       decode(ehb.flg_status,
                              pk_inp_hidrics_constant.g_epis_hidric_r,
                              nvl2(ehb.dt_open_tstz,
                                   get_dt_next_balance(i_lang, i_prof, eh.id_epis_hidrics),
                                   eh.dt_initial_tstz),
                              pk_inp_hidrics_constant.g_epis_hidric_e,
                              get_dt_next_balance(i_lang, i_prof, eh.id_epis_hidrics)) dt_begin_tstz,
                       row_number() over(ORDER BY ehb.dt_eh_balance DESC NULLS LAST) rn
                  FROM epis_hidrics eh
                  JOIN epis_hidrics_balance ehb
                    ON eh.id_epis_hidrics = ehb.id_epis_hidrics
                 WHERE eh.id_epis_hidrics = i_epis_hid) t
         WHERE t.rn = 1;
    
        IF NOT pk_access.get_id_shortcut(i_lang        => i_lang,
                                         i_prof        => i_prof,
                                         i_intern_name => pk_alert_constant.g_shortcut_hidrics_inten,
                                         o_id_shortcut => l_shortcut,
                                         o_error       => l_error_out)
        THEN
            l_shortcut := NULL;
        END IF;
    
        l_code_flg_status := CASE
                                 WHEN l_flg_status_hd = pk_inp_hidrics_constant.g_epis_hidric_o THEN
                                  'EPIS_HIDRICS.FLG_STATUS'
                                 ELSE
                                  'EPIS_HIDRICS_BALANCE.FLG_STATUS'
                             END;
        l_value_date      := NULL;
        l_icon            := NULL;
        IF l_flg_status_hd NOT IN (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e)
        THEN
            l_icon       := pk_sysdomain.get_img(i_lang, l_code_flg_status, l_flg_status_hd);
            l_value_date := NULL;
        ELSIF l_dt_initial > current_timestamp
        THEN
            l_icon       := pk_sysdomain.get_img(i_lang, l_code_flg_status, pk_inp_hidrics_constant.g_epis_hidric_r);
            l_value_date := pk_date_utils.to_char_insttimezone(i_prof,
                                                               l_dt_initial,
                                                               pk_alert_constant.g_dt_yyyymmddhh24miss_tzr);
        ELSIF l_dt_initial <= current_timestamp
        THEN
            l_icon       := pk_sysdomain.get_img(i_lang, l_code_flg_status, pk_inp_hidrics_constant.g_epis_hidric_e);
            l_value_date := pk_date_utils.to_char_insttimezone(i_prof,
                                                               l_dt_begin_tstz,
                                                               pk_alert_constant.g_dt_yyyymmddhh24miss_tzr);
        ELSE
            l_icon       := NULL;
            l_value_date := NULL;
        END IF;
    
        IF l_flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_c,
                            pk_inp_hidrics_constant.g_epis_hidric_f,
                            pk_inp_hidrics_constant.g_epis_hidric_d,
                            pk_inp_hidrics_constant.g_epis_hidric_o,
                            pk_inp_hidrics_constant.g_epis_hidric_i)
        THEN
            l_icon_type := 'I';
        ELSIF l_id_hidrics_interval = -1
        THEN
            l_icon_type := 'I';
        ELSE
            l_icon_type := 'DI';
        END IF;
    
        g_error := 'CALL PK_UTILS.GET_STATUS_STRING_IMMEDIATE';
        pk_utils.build_status_string(i_display_type => l_icon_type,
                                     i_value_date   => l_value_date,
                                     i_shortcut     => l_shortcut,
                                     i_value_icon   => l_icon,
                                     o_status_str   => l_hidrics_reg,
                                     o_status_msg   => l_aux,
                                     o_status_icon  => l_aux,
                                     o_status_flg   => l_aux);
    
        l_hidrics_reg := REPLACE(l_hidrics_reg, pk_alert_constant.g_status_rpl_chr_icon, l_icon);
    
        l_server_date := pk_date_utils.to_char_insttimezone(i_prof,
                                                            current_timestamp,
                                                            pk_alert_constant.g_dt_yyyymmddhh24miss_tzr);
    
        l_hidrics_reg := REPLACE(l_hidrics_reg, pk_alert_constant.g_status_rpl_chr_dt_server, l_server_date) || '|';
    
        l_return := pk_grid.convert_grid_task_dates_to_str(i_lang, i_prof, l_hidrics_reg);
    
        RETURN l_return;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_epis_status_string;

    /**
    * Get the last auto balance ID and DT_OPEN_TSTZ
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics ID
    * @param   o_id_epis_hidrics_balance   Last id_epis_hidrics_balance 
    * @param   o_dt_open_tstz              Last dt_open_tstz
    * @param   o_dt_close_balance_tstz     Last dt_open_tstz
    * @param   o_error                     error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Vanessa Barsottelli
    * @version v2.6.5
    * @since   07-04-2016
    */
    FUNCTION get_last_auto_balance_data
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_epis_hidrics            IN epis_hidrics.id_epis_hidrics%TYPE,
        o_id_epis_hidrics_balance OUT epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        o_dt_open_tstz            OUT epis_hidrics_balance.dt_open_tstz%TYPE,
        o_dt_close_balance_tstz   OUT epis_hidrics_balance.dt_close_balance_tstz%TYPE,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'GET LAST AUTO BALANCE ID AND DT_OPEN_TSTZ';
        BEGIN
            SELECT id_epis_hidrics_balance, dt_open_tstz, dt_close_balance_tstz
              INTO o_id_epis_hidrics_balance, o_dt_open_tstz, o_dt_close_balance_tstz
              FROM (SELECT ehb.id_epis_hidrics_balance,
                           ehb.dt_open_tstz,
                           ehb.dt_close_balance_tstz,
                           row_number() over(PARTITION BY ehb.id_epis_hidrics ORDER BY ehb.dt_open_tstz DESC) rn
                      FROM epis_hidrics_balance ehb
                     WHERE ehb.id_epis_hidrics = i_epis_hidrics
                       AND ehb.dt_open_tstz <= g_sysdate_tstz
                       AND ehb.dt_open_tstz IS NOT NULL
                       AND ehb.dt_close_balance_tstz IS NOT NULL
                       AND ehb.flg_close_type = pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut)
             WHERE rn = 1;
        EXCEPTION
            WHEN no_data_found THEN
                o_id_epis_hidrics_balance := NULL;
                o_dt_open_tstz            := NULL;
                o_dt_close_balance_tstz   := NULL;
        END;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_LAST_AUTO_BALANCE_DATA',
                                              o_error);
        
            RETURN FALSE;
    END get_last_auto_balance_data;

    /**
    * Return the last auto balance dt_close_balance_tstz
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics ID
    *
    * @return  dt_close_balance_tstz
    *
    * @author  Vanessa Barsottelli
    * @version v2.6.5
    * @since   07-04-2016
    */
    FUNCTION get_last_auto_bal_dt_close
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN epis_hidrics_balance.dt_close_balance_tstz%TYPE IS
        l_last_auto_bal_id       epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_last_auto_bal_dt_open  epis_hidrics_balance.dt_open_tstz%TYPE;
        l_last_auto_bal_dt_close epis_hidrics_balance.dt_close_balance_tstz%TYPE;
        l_error                  t_error_out;
    BEGIN
        g_error := 'CALL GET_LAST_AUTO_BALANCE_DATA';
        IF NOT get_last_auto_balance_data(i_lang                    => i_lang,
                                          i_prof                    => i_prof,
                                          i_epis_hidrics            => i_epis_hidrics,
                                          o_id_epis_hidrics_balance => l_last_auto_bal_id,
                                          o_dt_open_tstz            => l_last_auto_bal_dt_open,
                                          o_dt_close_balance_tstz   => l_last_auto_bal_dt_close,
                                          o_error                   => l_error)
        THEN
            l_last_auto_bal_dt_close := NULL;
        END IF;
    
        RETURN l_last_auto_bal_dt_close;
    END get_last_auto_bal_dt_close;

    /**
    * Get an array of manual id_epis_hidrics_balance from the last auto balance
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_hidrics              Epis hidrics ID
    * @param   i_epis_hidrics_balance      Epis hidrics balance ID
    * @param   i_flg_close_type            Flag of close type
    * @param   i_dt_close_balance_tstz     Close balance date
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Vanessa Barsottelli
    * @version v2.6.5
    * @since   07-04-2016
    */
    FUNCTION get_prev_manual_balances
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics          IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hidrics_balance  IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE,
        i_flg_close_type        IN epis_hidrics_balance.flg_close_type%TYPE DEFAULT NULL,
        i_dt_close_balance_tstz IN epis_hidrics_balance.dt_close_balance_tstz%TYPE DEFAULT NULL
    ) RETURN table_number IS
        l_error t_error_out;
    
        l_epis_hid_balances table_number;
    
        l_flg_close_type epis_hidrics_balance.flg_close_type%TYPE := i_flg_close_type;
        l_prev_auto_bal  epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
    BEGIN
    
        IF l_flg_close_type IS NULL
        THEN
            g_error := 'GET BALANCE FLG_CLOSE_TYPE';
            SELECT ehb.flg_close_type
              INTO l_flg_close_type
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics_balance = i_epis_hidrics_balance;
        END IF;
    
        IF l_flg_close_type = pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut
        THEN
            g_error         := 'GET PREVIOUS BALANCE';
            l_prev_auto_bal := get_prev_auto_balance(i_lang, i_prof, i_epis_hidrics, i_epis_hidrics_balance);
        
            IF l_prev_auto_bal IS NOT NULL
            THEN
                g_error := 'GET ALL MANUAL BALANCES BETWEEN THE LAST AUTO BALANCE AND THIS ONE';
                SELECT id_epis_hidrics_balance
                  BULK COLLECT
                  INTO l_epis_hid_balances
                  FROM epis_hidrics_balance ehb
                 WHERE ehb.id_epis_hidrics = i_epis_hidrics
                   AND ehb.id_epis_hidrics_balance NOT IN (l_prev_auto_bal, i_epis_hidrics_balance)
                   AND ehb.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_f
                   AND ehb.dt_open_tstz >= (SELECT dt_open_tstz
                                              FROM epis_hidrics_balance
                                             WHERE id_epis_hidrics_balance = l_prev_auto_bal)
                   AND ehb.dt_close_balance_tstz <=
                       nvl(i_dt_close_balance_tstz,
                           (SELECT dt_close_balance_tstz
                              FROM epis_hidrics_balance
                             WHERE id_epis_hidrics_balance = i_epis_hidrics_balance));
            ELSE
                g_error := 'GET ALL MANUAL BALANCES BEFORE THIS ONE';
                SELECT id_epis_hidrics_balance
                  BULK COLLECT
                  INTO l_epis_hid_balances
                  FROM epis_hidrics_balance ehb
                 WHERE ehb.id_epis_hidrics = i_epis_hidrics
                   AND ehb.id_epis_hidrics_balance <> i_epis_hidrics_balance
                   AND ehb.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_f
                   AND ehb.dt_close_balance_tstz <=
                       nvl(i_dt_close_balance_tstz,
                           (SELECT dt_open_tstz
                              FROM epis_hidrics_balance
                             WHERE id_epis_hidrics_balance = i_epis_hidrics_balance));
            
            END IF;
        
            l_epis_hid_balances.extend();
            l_epis_hid_balances(l_epis_hid_balances.last) := i_epis_hidrics_balance;
        
        ELSE
            l_epis_hid_balances := table_number(i_epis_hidrics_balance);
        END IF;
    
        RETURN l_epis_hid_balances;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PREV_MANUAL_BALANCES',
                                              l_error);
            RETURN NULL;
    END get_prev_manual_balances;

    FUNCTION get_total_from_auto_bal
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_type     IN hidrics.flg_type%TYPE
    ) RETURN NUMBER IS
        l_last_auto_bal_id       epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_last_auto_bal_dt       epis_hidrics_balance.dt_open_tstz%TYPE;
        l_last_auto_bal_dt_close epis_hidrics_balance.dt_close_balance_tstz%TYPE;
        l_error                  t_error_out;
        l_total_hidrics          NUMBER(26, 2);
        l_total                  NUMBER(26, 2);
    BEGIN
    
        g_error := 'CALL GET_LAST_AUTO_BALANCE_DATA';
        IF NOT get_last_auto_balance_data(i_lang                    => i_lang,
                                          i_prof                    => i_prof,
                                          i_epis_hidrics            => i_epis_hidrics,
                                          o_id_epis_hidrics_balance => l_last_auto_bal_id,
                                          o_dt_open_tstz            => l_last_auto_bal_dt,
                                          o_dt_close_balance_tstz   => l_last_auto_bal_dt_close,
                                          o_error                   => l_error)
        THEN
            l_total := 0;
        END IF;
    
        --There is no auto balance yet
        IF l_last_auto_bal_id IS NULL
        THEN
            l_last_auto_bal_id := get_most_recent_ehb_id(i_epis_hidrics => i_epis_hidrics);
        
            SELECT ehb.dt_open_tstz, ehb.dt_close_balance_tstz
              INTO l_last_auto_bal_dt, l_last_auto_bal_dt_close
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics_balance = l_last_auto_bal_id;
        END IF;
    
        BEGIN
            SELECT nvl(SUM(ehd.value_hidrics), 0)
              INTO l_total_hidrics
              FROM epis_hidrics_det ehd
              JOIN epis_hidrics_line ehl
                ON ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line
              JOIN hidrics hid
                ON hid.id_hidrics = ehl.id_hidrics
             WHERE ehd.id_epis_hidrics = i_epis_hidrics
               AND hid.flg_type = i_flg_type
               AND ehd.flg_status = pk_inp_hidrics_constant.g_epis_hid_det_status_a;
        EXCEPTION
            WHEN no_data_found THEN
                l_total_hidrics := 0;
        END;
    
        IF i_flg_type = pk_inp_hidrics_constant.g_hidrics_flg_type_a
        THEN
            l_total := get_total_admin(i_lang,
                                       i_prof,
                                       i_epis_hidrics,
                                       l_total_hidrics,
                                       l_last_auto_bal_dt,
                                       l_last_auto_bal_dt_close);
        ELSE
            l_total := l_total_hidrics;
        END IF;
    
        RETURN l_total;
    
    EXCEPTION
        WHEN OTHERS THEN
            l_total := 0;
        
    END get_total_from_auto_bal;

    FUNCTION get_tt_result_from_auto_bal
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_flg_status      IN epis_hidrics.flg_status%TYPE,
        i_id_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN VARCHAR2 IS
        l_total VARCHAR2(4000 CHAR);
    BEGIN
    
        IF i_flg_status IN (pk_inp_hidrics_constant.g_epis_hidric_f,
                            pk_inp_hidrics_constant.g_epis_hidric_e,
                            pk_inp_hidrics_constant.g_epis_hidric_i)
        THEN
            l_total := pk_utils.number_to_char(i_prof,
                                               (get_total_from_auto_bal(i_lang,
                                                                        i_prof,
                                                                        i_id_epis_hidrics,
                                                                        pk_inp_hidrics_constant.g_hidrics_flg_type_a)) -
                                               (get_total_from_auto_bal(i_lang,
                                                                        i_prof,
                                                                        i_id_epis_hidrics,
                                                                        pk_inp_hidrics_constant.g_hidrics_flg_type_e)));
        END IF;
    
        RETURN l_total;
    END get_tt_result_from_auto_bal;

    FUNCTION get_prev_auto_balance
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_epis_hidrics_bal IN epis_hidrics_balance.id_epis_hidrics_balance%TYPE
    ) RETURN NUMBER IS
        l_epis_hidrics_bal epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
    BEGIN
    
        IF i_epis_hidrics IS NOT NULL
           AND i_epis_hidrics_bal IS NOT NULL
        THEN
            BEGIN
                SELECT id_epis_hidrics_balance
                  INTO l_epis_hidrics_bal
                  FROM (SELECT id_epis_hidrics_balance, row_number() over(ORDER BY dt_close_balance_tstz DESC) rn
                          FROM epis_hidrics_balance ehb
                         WHERE ehb.id_epis_hidrics = i_epis_hidrics
                           AND ehb.id_epis_hidrics_balance <> i_epis_hidrics_bal
                           AND ehb.flg_close_type = pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut
                           AND ehb.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_f
                           AND ehb.dt_close_balance_tstz <=
                               (SELECT dt_open_tstz
                                  FROM epis_hidrics_balance
                                 WHERE id_epis_hidrics_balance = i_epis_hidrics_bal))
                 WHERE rn = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_epis_hidrics_bal := NULL;
            END;
        END IF;
    
        RETURN l_epis_hidrics_bal;
    
    END get_prev_auto_balance;

    FUNCTION get_hidrics_task_title
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_task_request     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_task_request_det IN epis_hidrics_det.id_epis_hidrics_det%TYPE,
        o_task_desc        OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        SELECT pk_translation.get_translation(i_lang, ht.code_hidrics_type)
          INTO o_task_desc
          FROM epis_hidrics eh
         INNER JOIN hidrics_type ht
            ON (eh.id_hidrics_type = ht.id_hidrics_type)
         WHERE id_epis_hidrics = i_task_request;
        RETURN TRUE;
    END get_hidrics_task_title;

    FUNCTION get_hidric_status
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_task_request  IN epis_hidrics.id_epis_hidrics%TYPE,
        o_flg_status    OUT VARCHAR2,
        o_status_string OUT VARCHAR2,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        o_status_string := get_epis_status_string(i_lang => i_lang, i_prof => i_prof, i_epis_hid => i_task_request);
        o_flg_status    := NULL;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
        
    END get_hidric_status;

    FUNCTION set_hidrics_request_task
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_task_request    IN table_number,
        i_hd_task_type    IN hidrics_type.id_hidrics_type%TYPE,
        i_prof_order      IN table_number,
        i_dt_order        IN table_varchar,
        i_order_type      IN table_number,
        o_hidrics_req     OUT table_number,
        o_hidrics_req_det OUT table_table_number,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_epis_hidrics IS
            SELECT eh.*
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics IN (SELECT /*+opt_estimate(table t rows=1)*/
                                           *
                                            FROM TABLE(i_task_request) t);
    
        TYPE t_epis_hidrics IS TABLE OF c_epis_hidrics%ROWTYPE;
        t_tbl_epis_hidrics t_epis_hidrics;
    
        CURSOR c_epis_hidrics_balance(i_epis_hidrics epis_hidrics.id_epis_hidrics%TYPE) IS
            SELECT ehb.*
              FROM epis_hidrics_balance ehb
             WHERE ehb.id_epis_hidrics = i_epis_hidrics;
    
        TYPE t_epis_hidrics_balance IS TABLE OF c_epis_hidrics_balance%ROWTYPE;
        t_tbl_epis_hidrics_bal t_epis_hidrics_balance;
    
        l_epis_hidrics epis_hidrics.id_epis_hidrics%TYPE;
    
        o_flg_show   VARCHAR2(20 CHAR);
        o_msg_title  VARCHAR2(2000 CHAR);
        o_msg        VARCHAR2(2000 CHAR);
        o_dft_values pk_types.cursor_type;
    
        id_hidrics_interval NUMBER;
        desc_hid_interval   VARCHAR2(2000 CHAR);
        dt_def_next_balance VARCHAR2(2000 CHAR);
    
        g_exception EXCEPTION;
    
    BEGIN
        OPEN c_epis_hidrics;
        FETCH c_epis_hidrics BULK COLLECT
            INTO t_tbl_epis_hidrics;
        CLOSE c_epis_hidrics;
    
        FOR i IN 1 .. t_tbl_epis_hidrics.count
        LOOP
        
            OPEN c_epis_hidrics_balance(t_tbl_epis_hidrics(i).id_epis_hidrics);
            FETCH c_epis_hidrics_balance BULK COLLECT
                INTO t_tbl_epis_hidrics_bal;
            CLOSE c_epis_hidrics_balance;
        
            IF t_tbl_epis_hidrics(i).dt_next_balance IS NULL
            THEN
            
                IF NOT get_hidrics_dft_creation(i_lang       => i_lang,
                                                i_prof       => i_prof,
                                                i_episode    => t_tbl_epis_hidrics(i).id_episode,
                                                o_dft_values => o_dft_values,
                                                o_error      => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                LOOP
                    FETCH o_dft_values
                        INTO id_hidrics_interval, desc_hid_interval, dt_def_next_balance;
                    EXIT WHEN o_dft_values%NOTFOUND;
                END LOOP;
            
            END IF;
        
            IF NOT set_hidrics(i_lang         => i_lang,
                               i_prof         => i_prof,
                               i_episode      => t_tbl_epis_hidrics(i).id_episode,
                               i_patient      => t_tbl_epis_hidrics(i).id_patient,
                               i_epis_hidrics => NULL, --
                               --i_dt_initial_str   => pk_date_utils.get_timestamp_str(i_lang, i_prof, current_timestamp, NULL),
                               i_dt_initial_str   => nvl(pk_date_utils.get_timestamp_str(i_lang,
                                                                                         i_prof,
                                                                                         t_tbl_epis_hidrics(i).dt_initial_tstz,
                                                                                         NULL),
                                                         pk_date_utils.get_timestamp_str(i_lang,
                                                                                         i_prof,
                                                                                         current_timestamp,
                                                                                         NULL)),
                               i_dt_end_str       => t_tbl_epis_hidrics(i).dt_end_tstz,
                               i_dt_next_balance  => nvl(pk_date_utils.get_timestamp_str(i_lang,
                                                                                         i_prof,
                                                                                         t_tbl_epis_hidrics(i).dt_next_balance,
                                                                                         NULL),
                                                         dt_def_next_balance), --o_dft_values(1).dt_def_next_balance,
                               i_hid_interv       => t_tbl_epis_hidrics(i).id_hidrics_interval,
                               i_interval_minutes => t_tbl_epis_hidrics(i).interval_minutes,
                               i_notes            => t_tbl_epis_hidrics(i).notes,
                               i_hid_type         => i_hd_task_type,
                               i_unit_measure     => t_tbl_epis_hidrics_bal(i).id_unit_measure,
                               i_flg_type         => g_create_hidrics_action_new,
                               i_flg_task_status  => pk_inp_hidrics_constant.g_epis_hidric_r,
                               i_flg_restricted   => t_tbl_epis_hidrics(i).flg_restricted,
                               i_max_intake       => t_tbl_epis_hidrics(i).max_intake,
                               i_min_output       => t_tbl_epis_hidrics(i).min_output,
                               o_id_epis_hidrics  => l_epis_hidrics,
                               o_flg_show         => o_flg_show,
                               o_msg_title        => o_msg_title,
                               o_msg              => o_msg,
                               o_error            => o_error)
            THEN
                RETURN FALSE;
            END IF;
        
        END LOOP;
    
        o_hidrics_req     := table_number(l_epis_hidrics);
        o_hidrics_req_det := table_table_number(table_number(l_epis_hidrics));
    
        g_error := 'CALL PK_PROCEDURES_EXTERNAL.SET_PROCEDURE_DELETE_TASK';
        IF NOT set_hidric_delete_task(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_task_request => i_task_request,
                                      o_error        => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_HIDRICS_REQUEST_TASK',
                                              o_error);
            RETURN FALSE;
        
    END set_hidrics_request_task;

    FUNCTION set_hidric_copy_task
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_patient      IN patient.id_patient%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN epis_hidrics.id_epis_hidrics%TYPE,
        o_epis_hidrics OUT epis_hidrics.id_epis_hidrics%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_epis_hidrics         epis_hidrics%ROWTYPE;
        l_epis_hidrics_balance epis_hidrics_balance%ROWTYPE;
    
        l_rows_out     table_varchar := table_varchar();
        l_rows_bal_out table_varchar := table_varchar();
    
    BEGIN
    
        SELECT eh.*
          INTO l_epis_hidrics
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_task_request;
    
        l_epis_hidrics.id_epis_hidrics := ts_epis_hidrics.next_key();
    
        SELECT ehb.*
          INTO l_epis_hidrics_balance
          FROM epis_hidrics_balance ehb
         WHERE ehb.id_epis_hidrics = i_task_request;
    
        l_epis_hidrics_balance.id_epis_hidrics_balance := ts_epis_hidrics_balance.next_key();
        l_epis_hidrics_balance.id_epis_hidrics         := l_epis_hidrics.id_epis_hidrics;
        l_epis_hidrics.dt_initial_tstz                 := current_timestamp;
    
        IF (i_patient IS NOT NULL AND i_episode IS NOT NULL)
        THEN
            l_epis_hidrics.id_episode := i_episode;
            l_epis_hidrics.id_patient := i_patient;
        END IF;
    
        g_error := 'INSERT EPIS_HIDRICS';
        ts_epis_hidrics.ins(rec_in => l_epis_hidrics, gen_pky_in => FALSE, rows_out => l_rows_out);
        t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_HIDRICS', l_rows_out, o_error);
    
        g_error := 'INSERT EPIS_HIDRICS_BALANCE';
        ts_epis_hidrics_balance.ins(rec_in => l_epis_hidrics_balance, gen_pky_in => FALSE, rows_out => l_rows_bal_out);
        t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_HIDRICS_BALANCE', l_rows_bal_out, o_error);
    
        o_epis_hidrics := l_epis_hidrics.id_epis_hidrics;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_HIDRICS_COPY_TASK',
                                              o_error);
        
    END set_hidric_copy_task;

    FUNCTION set_hidric_delete_task
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_task_request IN table_number,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        FOR i IN 1 .. i_task_request.count
        LOOP
            DELETE epis_hidrics_balance
             WHERE id_epis_hidrics = i_task_request(i);
        
            DELETE epis_hbalance_hist
             WHERE id_epis_hidrics = i_task_request(i);
        
            DELETE epis_hidrics
             WHERE id_epis_hidrics = i_task_request(i);
        
        END LOOP;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_HIDRIC_DELETE_TASK',
                                              o_error);
            RETURN FALSE;
        
    END set_hidric_delete_task;

    FUNCTION get_hidric_date_limits
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_task_request IN table_number,
        o_list         OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'OPEN O_LIST';
        OPEN o_list FOR
            SELECT eh.id_epis_hidrics, eh.dt_initial_tstz, NULL dt_end
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics IN (SELECT /*+opt_estimate(table t rows=1)*/
                                           *
                                            FROM TABLE(i_task_request) t);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_DATE_LIMITS',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_hidric_date_limits;

    FUNCTION get_epis_hidrics_task
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        o_epis_hid     OUT NOCOPY pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_msg_hidrics_m002 sys_message.desc_message%TYPE;
        l_msg_hidrics_m003 sys_message.desc_message%TYPE;
        l_msg_hidrics_t019 sys_message.desc_message%TYPE;
        l_msg_hidrics_t026 sys_message.desc_message%TYPE;
        l_msg_hidrics_t031 sys_message.desc_message%TYPE;
        l_msg_hidrics_t032 sys_message.desc_message%TYPE;
        l_msg_hidrics_t033 sys_message.desc_message%TYPE;
        l_msg_hidrics_t034 sys_message.desc_message%TYPE;
        l_msg_hidrics_t027 sys_message.desc_message%TYPE;
        l_msg_hidrics_t038 sys_message.desc_message%TYPE;
        l_msg_common_m008  sys_message.desc_message%TYPE;
        l_msg_max_intake   sys_message.desc_message%TYPE;
        l_msg_min_output   sys_message.desc_message%TYPE;
        l_msg_hour         sys_message.desc_message%TYPE;
        l_msg_hours        sys_message.desc_message%TYPE;
        l_msg_total_occurs sys_message.desc_message%TYPE;
        l_msg_minute       sys_message.desc_message%TYPE;
        l_msg_minutes      sys_message.desc_message%TYPE;
        --
        l_config_unit_mea   sys_config.value%TYPE;
        l_unit_measure_desc pk_translation.t_desc_translation;
        --
    
        l_search          VARCHAR2(4000 CHAR) := NULL;
        l_filter          PLS_INTEGER := pk_inp_hidrics_constant.g_filter_type_all;
        l_column_to_order PLS_INTEGER := pk_inp_hidrics_constant.g_columns_order_2;
        l_order_by        PLS_INTEGER := pk_inp_hidrics_constant.g_order_by_1;
        --
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient patient.id_patient%TYPE;
    
        e_invalid_argument EXCEPTION;
    
        l_start_date TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_end_date   TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
    
        o_tbl_requests t_tbl_hidrics_request;
    
    BEGIN
        l_msg_hidrics_m002 := pk_message.get_message(i_lang, 'HIDRICS_M002');
        l_msg_hidrics_m003 := pk_message.get_message(i_lang, 'HIDRICS_M003');
        l_msg_hidrics_t019 := pk_message.get_message(i_lang, 'HIDRICS_T019');
        l_msg_hidrics_t026 := pk_message.get_message(i_lang, 'HIDRICS_T026');
        l_msg_hidrics_t031 := pk_message.get_message(i_lang, 'HIDRICS_T031');
        l_msg_hidrics_t032 := pk_message.get_message(i_lang, 'HIDRICS_T032');
        l_msg_hidrics_t033 := pk_message.get_message(i_lang, 'HIDRICS_T033');
        l_msg_hidrics_t034 := pk_message.get_message(i_lang, 'HIDRICS_T034');
        l_msg_hidrics_t027 := pk_message.get_message(i_lang, 'HIDRICS_T027');
        l_msg_hidrics_t038 := pk_message.get_message(i_lang, 'HIDRICS_T038');
        l_msg_common_m008  := pk_message.get_message(i_lang, 'COMMON_M008');
        l_msg_max_intake   := pk_message.get_message(i_lang, 'HIDRICS_M024');
        l_msg_min_output   := pk_message.get_message(i_lang, 'HIDRICS_M025');
        l_msg_total_occurs := pk_message.get_message(i_lang, 'HIDRICS_T096');
    
        l_config_unit_mea := pk_sysconfig.get_config(i_code_cf => 'HIDRICS_UNIT_MEAS', i_prof => i_prof);
    
        IF l_config_unit_mea IS NOT NULL
        THEN
            g_error := 'GET UNIT MEASURE DESCRIPTION';
            pk_alertlog.log_debug(g_error);
            SELECT pk_translation.get_translation(i_lang, um.code_unit_measure)
              INTO l_unit_measure_desc
              FROM unit_measure um
             WHERE um.id_unit_measure = to_number(l_config_unit_mea);
        END IF;
    
        g_error := 'GET records for requests grid';
        pk_alertlog.log_debug(g_error);
        SELECT t_rec_hidrics_request(sfinal.id_epis_hidrics,
                                     sfinal.flg_status_eh,
                                     sfinal.id_hidrics_type,
                                     sfinal.acronym,
                                     sfinal.id_epis_hidrics_balance,
                                     sfinal.flg_status_ehb,
                                     sfinal.dt_initial_tstz,
                                     sfinal.dt_end_tstz,
                                     sfinal.get_dt_next_balance,
                                     sfinal.interval_minutes,
                                     sfinal.flg_restricted,
                                     sfinal.max_intake,
                                     sfinal.min_output,
                                     sfinal.total_admin,
                                     sfinal.total_elim,
                                     sfinal.dt_open_tstz,
                                     sfinal.dt_close_balance_tstz,
                                     sfinal.id_epis_type,
                                     sfinal.flg_ti_type,
                                     sfinal.code_hidrics_type,
                                     sfinal.id_hidrics_interval,
                                     sfinal.code_hidrics_interval,
                                     sfinal.flg_type,
                                     sfinal.notes,
                                     sfinal.notes_cancel,
                                     sfinal.notes_inter,
                                     sfinal.dt_begin_tstz,
                                     sfinal.id_professional_eh,
                                     sfinal.id_professional_pr,
                                     sfinal.flg_check_extra_take,
                                     sfinal.id_episode)
          BULK COLLECT
          INTO o_tbl_requests
          FROM (SELECT sfinal_aux.*
                  FROM (SELECT eh.id_epis_hidrics,
                               eh.flg_status flg_status_eh,
                               ht.id_hidrics_type,
                               ht.acronym,
                               (SELECT get_dt_next_balance(i_lang, i_prof, eh.id_epis_hidrics)
                                  FROM dual) get_dt_next_balance,
                               ehb.id_epis_hidrics_balance,
                               ehb.flg_status flg_status_ehb,
                               eh.dt_initial_tstz,
                               eh.dt_end_tstz,
                               eh.interval_minutes,
                               eh.flg_restricted,
                               eh.max_intake,
                               eh.min_output,
                               ehb.total_admin,
                               ehb.total_elim,
                               ht.flg_ti_type,
                               ht.code_hidrics_type,
                               hi.code_hidrics_interval,
                               eh.id_hidrics_interval,
                               hi.flg_type,
                               ehb.dt_open_tstz,
                               ehb.dt_close_balance_tstz,
                               eh.notes,
                               eh.notes_cancel,
                               eh.notes_inter,
                               NULL AS id_epis_type,
                               NULL AS dt_begin_tstz,
                               NULL AS id_professional_pr,
                               eh.id_professional id_professional_eh,
                               eh.id_episode,
                               decode(eh.flg_status,
                                      pk_inp_hidrics_constant.g_epis_hidric_o,
                                      check_extra_take(i_lang, i_prof, eh.id_episode, eh.id_epis_hidrics)) flg_check_extra_take
                          FROM epis_hidrics eh
                         INNER JOIN epis_hidrics_balance ehb
                            ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
                         INNER JOIN hidrics_type ht
                            ON (eh.id_hidrics_type = ht.id_hidrics_type)
                         INNER JOIN hidrics_interval hi
                            ON (eh.id_hidrics_interval = hi.id_hidrics_interval)
                          LEFT JOIN unit_measure um
                            ON (ehb.id_unit_measure = um.id_unit_measure)
                        
                        --*****************************************************************************************
                        --** WHEN CHANGING THE WHERE CLAUSE OR ANY CODE INSIDE THE FROM AND INNER JOIN STATEMENT **
                        --** PLEASE REPRODUCE ANY CHANGES IN THE SAME CODE ON FUNCTION GET_EPIS_HIDRICS_COUNT    **
                        --*****************************************************************************************
                        
                        --            
                         WHERE eh.id_epis_hidrics = i_epis_hidrics) sfinal_aux) sfinal;
    
        g_error := 'GET DATA FROM tmp_epis_hidrics';
        OPEN o_epis_hid FOR
            SELECT /*+ OPT_ESTIMATE (TABLE sfinal ROWS=0.001)*/
             sfinal.id_epis_hidrics,
             sfinal.flg_status_eh status_epis_hid,
             sfinal.id_hidrics_type,
             sfinal.acronym hid_type,
             sfinal.id_epis_hidrics_balance,
             sfinal.flg_status_ehb status_epis_hid_bal,
             (SELECT pk_date_utils.date_send_tsz(i_lang, sfinal.dt_initial_tstz, i_prof)
                FROM dual) dt_initial,
             (SELECT pk_date_utils.dt_chr_tsz(i_lang, sfinal.dt_initial_tstz, i_prof)
                FROM dual) date_target_ini,
             (SELECT pk_date_utils.date_char_hour_tsz(i_lang,
                                                      sfinal.dt_initial_tstz,
                                                      i_prof.institution,
                                                      i_prof.software)
                FROM dual) hour_target_ini,
             (SELECT pk_date_utils.date_send_tsz(i_lang, sfinal.dt_end_tstz, i_prof)
                FROM dual) dt_end,
             (SELECT pk_date_utils.dt_chr_tsz(i_lang, sfinal.dt_end_tstz, i_prof)
                FROM dual) date_target_end,
             (SELECT pk_date_utils.date_char_hour_tsz(i_lang, sfinal.dt_end_tstz, i_prof.institution, i_prof.software)
                FROM dual) hour_target_end,
             -- new fields         
             sfinal.dt_next_balance,
             (SELECT pk_date_utils.date_send_tsz(i_lang, sfinal.dt_next_balance, i_prof)
                FROM dual) dt_next_balance,
             (SELECT pk_date_utils.dt_chr_tsz(i_lang, sfinal.dt_next_balance, i_prof)
                FROM dual) dt_target_next_balance,
             sfinal.interval_minutes,
             sfinal.flg_restricted,
             (SELECT pk_sysdomain.get_domain(pk_inp_hidrics_constant.g_domain_eh_flg_restrict,
                                             sfinal.flg_restricted,
                                             i_lang)
                FROM dual) desc_flg_restricted,
             sfinal.max_intake,
             sfinal.min_output,
             decode(sfinal.flg_restricted,
                    pk_alert_constant.g_yes,
                    (SELECT pk_inp_hidrics.get_intake_output_text(i_lang,
                                                                  i_prof,
                                                                  l_msg_max_intake,
                                                                  sfinal.max_intake,
                                                                  l_unit_measure_desc)
                       FROM dual),
                    '') desc_max_intake,
             decode(sfinal.flg_restricted,
                    pk_alert_constant.g_yes,
                    (SELECT pk_inp_hidrics.get_intake_output_text(i_lang,
                                                                  i_prof,
                                                                  l_msg_min_output,
                                                                  sfinal.min_output,
                                                                  l_unit_measure_desc)
                       FROM dual),
                    '') desc_min_output,
             (SELECT check_fluid_restrictions(i_lang,
                                              i_prof,
                                              sfinal.id_epis_hidrics,
                                              sfinal.max_intake,
                                              sfinal.min_output,
                                              NULL,
                                              sfinal.total_admin,
                                              sfinal.total_elim,
                                              sfinal.dt_open_tstz,
                                              sfinal.dt_close_balance_tstz)
                FROM dual) flg_restrict_warning,
             
             NULL desc_hid_type,
             -- END
             (SELECT get_hidric_interval(i_lang,
                                         sfinal.interval_minutes,
                                         l_msg_hour,
                                         l_msg_hours,
                                         l_msg_minute,
                                         l_msg_minutes,
                                         sfinal.code_hidrics_interval)
                FROM dual) desc_hid_inter,
             sfinal.id_hidrics_interval,
             sfinal.flg_type interv_val_type,
             (SELECT get_ult_result(sfinal.flg_status_eh, l_msg_hidrics_m002, l_msg_hidrics_m003)
                FROM dual) ult_result,
             decode(sfinal.flg_status_ehb,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_inp_hidrics_constant.g_epis_hidric_i) flg_text,
             decode(sfinal.acronym,
                    pk_inp_hidrics_constant.g_hid_type_h,
                    l_msg_hidrics_t019,
                    pk_inp_hidrics_constant.g_hid_type_d,
                    l_msg_hidrics_t026,
                    l_msg_hidrics_t038) title_viewer,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    l_msg_hidrics_t031,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    l_msg_hidrics_t031,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    l_msg_hidrics_t031,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    l_msg_hidrics_t031,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    l_msg_hidrics_t031,
                    l_msg_hidrics_t031) title_tot_admin,
             get_total_from_auto_bal(i_lang,
                                     i_prof,
                                     sfinal.id_epis_hidrics,
                                     pk_inp_hidrics_constant.g_hidrics_flg_type_a) total_admin, ---viewer
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    l_msg_hidrics_t032,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    l_msg_hidrics_t032,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    l_msg_hidrics_t032,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    l_msg_hidrics_t032,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    l_msg_hidrics_t032,
                    l_msg_hidrics_t032) title_tot_elim,
             get_total_from_auto_bal(i_lang,
                                     i_prof,
                                     sfinal.id_epis_hidrics,
                                     pk_inp_hidrics_constant.g_hidrics_flg_type_e) total_elim,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    l_msg_hidrics_t033,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    l_msg_hidrics_t034,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    l_msg_hidrics_t034,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    l_msg_hidrics_t033,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    l_msg_hidrics_t034,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    l_msg_hidrics_t034) title_tot_result,
             get_tt_result_from_auto_bal(i_lang, i_prof, sfinal.flg_status_eh, sfinal.id_epis_hidrics) total_result, ---grelha
             decode(sfinal.acronym,
                    pk_inp_hidrics_constant.g_hid_type_d,
                    decode(sfinal.flg_status_eh,
                           pk_inp_hidrics_constant.g_epis_hidric_r,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_f,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_i,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_e,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_o,
                           l_msg_hidrics_t034,
                           l_msg_hidrics_t034),
                    pk_inp_hidrics_constant.g_hid_type_r,
                    decode(sfinal.flg_status_eh,
                           pk_inp_hidrics_constant.g_epis_hidric_r,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_f,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_i,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_e,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_o,
                           l_msg_hidrics_t034,
                           l_msg_hidrics_t034),
                    pk_inp_hidrics_constant.g_hid_type_all,
                    decode(sfinal.flg_status_eh,
                           pk_inp_hidrics_constant.g_epis_hidric_r,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_f,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_i,
                           l_msg_hidrics_t034,
                           pk_inp_hidrics_constant.g_epis_hidric_e,
                           l_msg_hidrics_t027,
                           pk_inp_hidrics_constant.g_epis_hidric_o,
                           l_msg_hidrics_t034,
                           l_msg_hidrics_t034)) title_diurese,
             l_unit_measure_desc desc_unit_measure,
             decode(sfinal.notes,
                    NULL,
                    decode(sfinal.notes_cancel,
                           NULL,
                           decode(sfinal.notes_inter,
                                  NULL,
                                  -- José rito 25-03-2008 WO10422: show "With notes" if execution notes exists
                                  decode((SELECT COUNT(e.notes)
                                           FROM epis_hidrics_det e
                                          WHERE e.id_epis_hidrics = sfinal.id_epis_hidrics),
                                         0,
                                         NULL,
                                         l_msg_common_m008),
                                  --
                                  l_msg_common_m008),
                           l_msg_common_m008),
                    l_msg_common_m008) title_notes,
             sfinal.notes desc_notes,
             (SELECT pk_date_utils.date_send_tsz(i_lang, sfinal.dt_begin_tstz, i_prof)
                FROM dual) dt_epis_begin,
             (SELECT pk_date_utils.date_send_tsz(i_lang,
                                                 (SELECT MAX(ehd.dt_execution_tstz)
                                                    FROM epis_hidrics_det ehd
                                                   WHERE ehd.id_epis_hidrics = sfinal.id_epis_hidrics),
                                                 i_prof)
                FROM dual) dt_last_reg,
             sfinal.id_professional_eh prof_req_id,
             (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, sfinal.id_professional_pr)
                FROM dual) prof_req_nick,
             get_epis_status_string(i_lang, i_prof, sfinal.id_epis_hidrics) desc_status_n,
             (SELECT get_hidric_bal_rank(i_lang, sfinal.flg_status_ehb)
                FROM dual) epis_hid_bal_rank,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    pk_alert_constant.g_no,
                    pk_alert_constant.g_no) flg_cancel,
             -- Check if start date can be editable:
             -- -> Request is a draft, or..
             -- -> Request is in status "requested", meaning that are no intake/output records.
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    pk_alert_constant.g_no,
                    pk_alert_constant.g_yes) flg_has_records,
             (SELECT pk_date_utils.date_send_tsz(i_lang,
                                                 (SELECT MAX(ehb.dt_close_balance_tstz)
                                                    FROM epis_hidrics_balance ehb
                                                   WHERE ehb.id_epis_hidrics = sfinal.id_epis_hidrics
                                                     AND ehb.flg_close_type =
                                                         pk_inp_hidrics_constant.g_epis_hid_bal_closed_aut),
                                                 i_prof)
                FROM dual) dt_last_balance,
             pk_inp_hidrics.has_auto_balance(i_prof, sfinal.id_epis_hidrics) flg_auto_balance,
             l_msg_total_occurs title_tot_occurs,
             decode(sfinal.acronym,
                    pk_inp_hidrics_constant.g_hid_type_i,
                    NULL,
                    pk_inp_hidrics.get_nr_occurs_by_type(i_lang,
                                                         i_prof,
                                                         sfinal.id_epis_hidrics,
                                                         sfinal.id_epis_hidrics_balance,
                                                         sfinal.id_episode)) list_total_times,
             NULL desc_last_result,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_alert_constant.g_yes) flg_ok_btn,
             pk_alert_constant.g_yes flg_detail_btn,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    sfinal.flg_check_extra_take,
                    pk_alert_constant.g_no) flg_actions_btn,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_alert_constant.g_no) flg_view_btn,
             decode(sfinal.flg_status_eh,
                    pk_inp_hidrics_constant.g_epis_hidric_c,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_i,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_f,
                    pk_alert_constant.g_no,
                    pk_inp_hidrics_constant.g_epis_hidric_e,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_r,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_d,
                    pk_alert_constant.g_yes,
                    pk_inp_hidrics_constant.g_epis_hidric_o,
                    sfinal.flg_check_extra_take,
                    pk_alert_constant.g_no) flg_results_create
              FROM (TABLE(o_tbl_requests)) sfinal;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('--> ' || SQLCODE || ' - ' || SQLERRM);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EPIS_HIDRICS_INT',
                                              o_error);
        
            pk_types.open_my_cursor(o_epis_hid);
            RETURN FALSE;
    END get_epis_hidrics_task;

    FUNCTION check_hidrics_cancel
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN epis_hidrics.id_epis_hidrics%TYPE,
        o_flg_cancel   OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        SELECT decode(flg_status,
                      pk_inp_hidrics_constant.g_epis_hidric_c,
                      pk_alert_constant.g_no,
                      pk_inp_hidrics_constant.g_epis_hidric_i,
                      pk_alert_constant.g_no,
                      pk_inp_hidrics_constant.g_epis_hidric_f,
                      pk_alert_constant.g_no,
                      pk_inp_hidrics_constant.g_epis_hidric_e,
                      pk_alert_constant.g_yes,
                      pk_inp_hidrics_constant.g_epis_hidric_r,
                      pk_alert_constant.g_yes,
                      pk_inp_hidrics_constant.g_epis_hidric_d,
                      pk_alert_constant.g_yes,
                      pk_inp_hidrics_constant.g_epis_hidric_o,
                      pk_alert_constant.g_no,
                      pk_alert_constant.g_no)
          INTO o_flg_cancel
          FROM epis_hidrics
         WHERE id_epis_hidrics = i_task_request;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CHECK_PROCEDURE_CANCEL',
                                              o_error);
            RETURN FALSE;
    END check_hidrics_cancel;

    FUNCTION get_io_last_auto_balance
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        o_value   OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_total                  VARCHAR2(4000 CHAR);
        l_id_epis_hidrics        epis_hidrics.id_epis_hidrics%TYPE;
        l_last_auto_bal_id       epis_hidrics_balance.id_epis_hidrics_balance%TYPE;
        l_last_auto_bal_dt       epis_hidrics_balance.dt_open_tstz%TYPE;
        l_last_auto_bal_dt_close epis_hidrics_balance.dt_close_balance_tstz%TYPE;
    
        l_total_admin  NUMBER(24);
        l_total_elimin NUMBER(24);
        l_times_admin  NUMBER(24);
        l_times_elimin NUMBER(24);
    
        l_io_total VARCHAR(30 CHAR);
    
        l_config_unit_mea   sys_config.value%TYPE;
        l_unit_measure_desc pk_translation.t_desc_translation;
    
        l_exception EXCEPTION;
    BEGIN
    
        BEGIN
            SELECT eh.id_epis_hidrics
              INTO l_id_epis_hidrics
              FROM epis_hidrics eh
             WHERE eh.id_episode = i_episode
               AND eh.id_hidrics_type = pk_inp_hidrics_constant.g_hidric_type_in_out
               AND eh.flg_status = pk_inp_hidrics_constant.g_epis_hid_balance_e;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_epis_hidrics := NULL;
        END;
    
        IF l_id_epis_hidrics IS NOT NULL
        THEN
            g_error := 'CALL GET_LAST_AUTO_BALANCE_DATA';
            IF NOT get_last_auto_balance_data(i_lang                    => i_lang,
                                              i_prof                    => i_prof,
                                              i_epis_hidrics            => l_id_epis_hidrics,
                                              o_id_epis_hidrics_balance => l_last_auto_bal_id,
                                              o_dt_open_tstz            => l_last_auto_bal_dt,
                                              o_dt_close_balance_tstz   => l_last_auto_bal_dt_close,
                                              o_error                   => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            IF l_last_auto_bal_id IS NOT NULL
            THEN
                IF NOT get_total_hidrics(i_lang          => i_lang,
                                         i_epis_hidrics  => l_id_epis_hidrics,
                                         i_epis_hid_bals => table_number(l_last_auto_bal_id),
                                         i_date          => NULL,
                                         o_total_admin   => l_total_admin,
                                         o_total_elimin  => l_total_elimin,
                                         o_times_admin   => l_times_admin,
                                         o_times_elimin  => l_times_elimin,
                                         o_error         => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                l_io_total := pk_utils.number_to_char(i_prof,
                                                      get_total_result(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_flg_status      => pk_inp_hidrics_constant.g_epis_hid_balance_e,
                                                                       i_id_epis_hidrics => l_last_auto_bal_id,
                                                                       i_total_admin     => l_total_admin,
                                                                       i_total_elim      => l_total_elimin,
                                                                       i_dt_open_tstz    => l_last_auto_bal_dt,
                                                                       i_dt_close_tstz   => l_last_auto_bal_dt_close));
            
                l_config_unit_mea := pk_sysconfig.get_config(i_code_cf => 'HIDRICS_UNIT_MEAS', i_prof => i_prof);
            
                IF l_config_unit_mea IS NOT NULL
                THEN
                    g_error := 'GET UNIT MEASURE DESCRIPTION';
                    pk_alertlog.log_debug(g_error);
                    SELECT pk_translation.get_translation(i_lang, um.code_unit_measure)
                      INTO l_unit_measure_desc
                      FROM unit_measure um
                     WHERE um.id_unit_measure = to_number(l_config_unit_mea);
                END IF;
            
                OPEN o_value FOR
                    SELECT upper(pk_translation.get_translation(i_lang, ht.code_hidrics_type)) || ' ' ||
                           pk_message.get_message(i_lang, 'HIDRICS_T076') || ':' title,
                           l_io_total || l_unit_measure_desc VALUE
                      FROM hidrics_type ht
                     WHERE ht.id_hidrics_type = pk_inp_hidrics_constant.g_hidric_type_in_out;
            
            ELSE
                pk_types.open_my_cursor(o_value);
            END IF;
        ELSE
            pk_types.open_my_cursor(o_value);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_IO_LAST_AUTO_BALANCE',
                                              o_error);
            pk_types.open_my_cursor(o_value);
            RETURN FALSE;
    END get_io_last_auto_balance;

    FUNCTION inactivate_hidrics_tasks
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_inst        IN institution.id_institution%TYPE,
        i_ids_exclude IN OUT table_number,
        o_has_error   OUT BOOLEAN,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_cancel_cfg sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'INACTIVATE_CANCEL_REASON',
                                                                      i_prof    => i_prof);
    
        l_descontinued_cfg sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'INACTIVATE_DISCONTINUED_REASON',
                                                                            i_prof    => i_prof);
    
        l_tbl_config t_tbl_config_table := pk_core_config.get_values_by_mkt_inst_sw(i_lang => NULL,
                                                                                    i_prof => profissional(0, i_inst, 0),
                                                                                    i_area => 'HIDRICS_INACTIVATE');
    
        l_cancel_id cancel_reason.id_cancel_reason%TYPE := pk_cancel_reason.get_id_by_content(i_lang,
                                                                                              i_prof,
                                                                                              l_cancel_cfg);
    
        l_descontinued_id cancel_reason.id_cancel_reason%TYPE := pk_cancel_reason.get_id_by_content(i_lang,
                                                                                                    i_prof,
                                                                                                    l_descontinued_cfg);
    
        l_max_rows sys_config.value%TYPE := pk_sysconfig.get_config(i_prof    => i_prof,
                                                                    i_code_cf => 'INACTIVATE_TASKS_MAX_NUMBER_ROWS');
    
        l_hidrics_req    table_number;
        l_initial_status table_varchar;
        l_final_status   table_varchar;
    
        l_msg       VARCHAR2(1000 CHAR);
        l_flg_show  VARCHAR2(2 CHAR);
        l_msg_title VARCHAR2(200 CHAR);
    
        l_error t_error_out;
        g_other_exception EXCEPTION;
    
        l_tbl_error_ids table_number := table_number();
    
        --The cursor will not fetch the records for the ids (id_comm_order_req) sent in i_ids_exclude        
        CURSOR c_hidrics_req(ids_exclude IN table_number) IS
            SELECT t.id_epis_hidrics, t.field_01 flg_initial_status, t.field_04 flg_final_status
              FROM (SELECT eh.id_epis_hidrics, cfg.field_01, cfg.field_04, e.dt_end_tstz, cfg.field_02, cfg.field_03
                      FROM epis_hidrics eh
                     INNER JOIN episode e
                        ON e.id_episode = eh.id_episode
                      LEFT JOIN (SELECT id_prev_episode, id_visit
                                  FROM episode
                                 WHERE id_episode IS NULL
                                UNION
                                SELECT id_prev_episode, id_visit
                                  FROM episode
                                 WHERE flg_status = pk_alert_constant.g_inactive) prev_e
                        ON prev_e.id_prev_episode = e.id_episode
                       AND e.id_visit = prev_e.id_visit
                     INNER JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                 *
                                  FROM TABLE(l_tbl_config) t) cfg
                        ON cfg.field_01 = eh.flg_status
                      LEFT JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                 t.column_value
                                  FROM TABLE(i_ids_exclude) t) t_ids
                        ON t_ids.column_value = eh.id_epis_hidrics
                     WHERE e.id_institution = i_inst
                       AND e.dt_end_tstz IS NOT NULL
                       AND rownum > 0
                       AND t_ids.column_value IS NULL) t
             WHERE pk_date_utils.trunc_insttimezone(i_prof,
                                                    pk_date_utils.add_to_ltstz(t.dt_end_tstz, t.field_02, t.field_03)) <=
                   pk_date_utils.trunc_insttimezone(i_prof, current_timestamp)
               AND rownum <= l_max_rows;
    
    BEGIN
    
        o_has_error := FALSE;
    
        OPEN c_hidrics_req(i_ids_exclude);
        FETCH c_hidrics_req BULK COLLECT
            INTO l_hidrics_req, l_initial_status, l_final_status;
        CLOSE c_hidrics_req;
    
        IF l_hidrics_req.count > 0
        THEN
            FOR i IN 1 .. l_hidrics_req.count
            LOOP
                IF l_final_status(i) IN
                   (pk_inp_hidrics_constant.g_epis_hidric_c, pk_inp_hidrics_constant.g_epis_hidric_i)
                THEN
                    SAVEPOINT init_cancel;
                    IF NOT pk_inp_hidrics.cancel_epis_hidrics(i_lang             => i_lang,
                                                         i_prof             => i_prof,
                                                         i_epis_hidrics     => l_hidrics_req(i),
                                                         i_cancel_reason    => CASE
                                                                                   WHEN l_final_status(i) =
                                                                                        pk_inp_hidrics_constant.g_epis_hidric_c THEN
                                                                                    l_cancel_id
                                                                                   ELSE
                                                                                    l_descontinued_id
                                                                               END,
                                                         i_cancel_notes     => NULL,
                                                         i_flg_status_force => CASE
                                                                                   WHEN l_initial_status(i) =
                                                                                        pk_inp_hidrics_constant.g_epis_hidric_d THEN
                                                                                    l_final_status(i)
                                                                                   ELSE
                                                                                    NULL
                                                                               END,
                                                         o_flg_show         => l_flg_show,
                                                         o_msg_title        => l_msg_title,
                                                         o_msg              => l_msg,
                                                         o_error            => l_error)
                    THEN
                        ROLLBACK TO init_cancel;
                    
                        --If, for the given id_epis_hidrics, an error is generated, o_has_error is set as TRUE,
                        --this way, the loop cicle may continue, but the system will know that at least one error has happened
                        o_has_error := TRUE;
                    
                        --A log for the id_epis_hidrics that raised the error must be generated 
                        pk_alert_exceptions.reset_error_state;
                        g_error := 'ERROR CALLING PK_INP_HIDRICS.CANCEL_EPIS_HIDRICS FOR RECORD ' || l_hidrics_req(i);
                        pk_alert_exceptions.process_error(i_lang,
                                                          SQLCODE,
                                                          SQLERRM,
                                                          g_error,
                                                          'ALERT',
                                                          g_package_name,
                                                          'INACTIVATE_HIDRICS_TASKS',
                                                          o_error);
                    
                        --The array for the ids (id_epis_hidrics) that raised the error is incremented
                        l_tbl_error_ids.extend();
                        l_tbl_error_ids(l_tbl_error_ids.count) := l_hidrics_req(i);
                    
                        CONTINUE;
                    END IF;
                ELSE
                    SAVEPOINT init_cancel;
                    IF NOT pk_inp_hidrics.set_epis_hid_status(i_lang            => i_lang,
                                                              i_prof            => i_prof,
                                                              i_epis_hidrics    => l_hidrics_req(i),
                                                              i_flg_status      => l_final_status(i),
                                                              i_notes           => NULL,
                                                              i_flg_task_status => l_final_status(i),
                                                              i_flg_reactivate  => pk_alert_constant.g_no,
                                                              o_msg_error       => l_msg_title,
                                                              o_error           => l_error)
                    THEN
                        ROLLBACK TO init_cancel;
                    
                        --If, for the given id_epis_hidrics, an error is generated, o_has_error is set as TRUE,
                        --this way, the loop cicle may continue, but the system will know that at least one error has happened
                        o_has_error := TRUE;
                    
                        --A log for the id_epis_hidrics that raised the error must be generated 
                        pk_alert_exceptions.reset_error_state;
                        g_error := 'ERROR CALLING PK_INP_HIDRICS.CANCEL_EPIS_HIDRICS FOR RECORD ' || l_hidrics_req(i);
                        pk_alert_exceptions.process_error(i_lang,
                                                          SQLCODE,
                                                          SQLERRM,
                                                          g_error,
                                                          'ALERT',
                                                          g_package_name,
                                                          'INACTIVATE_HIDRICS_TASKS',
                                                          o_error);
                    
                        --The array for the ids (id_epis_hidrics) that raised the error is incremented
                        l_tbl_error_ids.extend();
                        l_tbl_error_ids(l_tbl_error_ids.count) := l_hidrics_req(i);
                    
                        CONTINUE;
                    END IF;
                END IF;
            END LOOP;
        
            --When the number of error ids match the max number of rows that can be processed for each call,
            --it means that no id_epis_hidrics has been inactivated.
            --The next time the Job would be executed, the cursor would fetch the same set fetched on the previous call,
            --and therefore, from this point on, no more records would be inactivated.
            IF l_tbl_error_ids.count = l_max_rows
            THEN
                FOR i IN l_tbl_error_ids.first .. l_tbl_error_ids.last
                LOOP
                    --i_ids_exclude is an IN OUT parameter, and is incremented with the ids (id_epis_hidrics) that could not
                    --be inactivated with the current call of the function
                    i_ids_exclude.extend();
                    i_ids_exclude(i_ids_exclude.count) := l_tbl_error_ids(i);
                END LOOP;
            
                --Since no inactivations were performed with the current call, a new call to this function is performed,
                --however, this time, the array i_ids_exclude will include a list of ids that cannot be fetched by the cursor
                --on the next call. The recursion will be perfomed until at least one record is inactivated, or the cursor
                --has no more records to fetch.
                --Note: i_ids_exclude is incremented and is an IN OUT parameter, therefore, 
                --it will hold all the ids that were not inactivated from ALL calls.            
                IF NOT pk_inp_hidrics.inactivate_hidrics_tasks(i_lang        => i_lang,
                                                               i_prof        => i_prof,
                                                               i_inst        => i_inst,
                                                               i_ids_exclude => i_ids_exclude,
                                                               o_has_error   => o_has_error,
                                                               o_error       => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'INACTIVATE_HIDRICS_TASKS',
                                              l_error);
            RETURN FALSE;
    END inactivate_hidrics_tasks;

    FUNCTION tf_get_epis_hidrics_ids
    (
        i_id_patient IN epis_hidrics.id_patient%TYPE DEFAULT NULL,
        i_id_visit   IN episode.id_visit%TYPE DEFAULT NULL,
        i_id_episode IN episode.id_episode%TYPE DEFAULT NULL,
        i_start_date IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_end_date   IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL
    ) RETURN table_number IS
        l_out_rec        table_number := table_number(NULL);
        l_sql_header     VARCHAR2(1000 CHAR);
        l_sql_inner      VARCHAR2(1000 CHAR);
        l_sql_footer     VARCHAR2(1000 CHAR);
        l_sql_stmt       CLOB;
        l_curid          INTEGER;
        l_ret            INTEGER;
        l_cursor         pk_types.cursor_type;
        l_db_object_name VARCHAR2(30 CHAR) := 'TF_GET_EPIS_HIDRICS_IDS';
    
    BEGIN
        l_curid := dbms_sql.open_cursor;
    
        l_sql_header := 'SELECT DISTINCT eh.id_epis_hidrics          
          FROM epis_hidrics eh
         INNER JOIN episode epi
            ON epi.id_episode = eh.id_episode
         INNER JOIN epis_hidrics_balance ehb
            ON (eh.id_epis_hidrics = ehb.id_epis_hidrics)
         INNER JOIN epis_hidrics_det ehd
            ON (ehb.id_epis_hidrics_balance = ehd.id_epis_hidrics_balance)
         INNER JOIN epis_hidrics_line ehl
            ON (ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line)
         INNER JOIN hidrics hid
            ON (hid.id_hidrics = ehl.id_hidrics)
         WHERE nvl(ehd.flg_type, ''' || pk_inp_hidrics_constant.g_epis_hid_det_type_a ||
                        ''') IN
               (''' || pk_inp_hidrics_constant.g_epis_hid_det_type_a || ''' , ''' ||
                        pk_inp_hidrics_constant.g_epis_hid_det_type_p || ''')
           AND (ehd.flg_status = ''' || pk_inp_hidrics_constant.g_epis_hid_det_status_a || ''')
           AND (eh.flg_status IN (''' || pk_inp_hidrics_constant.g_epis_hidric_e || ''',
                                  ''' || pk_inp_hidrics_constant.g_epis_hidric_f || ''',
                                  ''' || pk_inp_hidrics_constant.g_epis_hidric_i || ''',
                                  ''' || pk_inp_hidrics_constant.g_epis_hidric_r || ''',
                                  ''' || pk_inp_hidrics_constant.g_epis_hidric_o ||
                        '''))      
               ';
    
        --i_id_patient
        IF i_id_patient IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.id_patient = :i_id_patient';
        END IF;
    
        --i_id_visit
        IF i_id_visit IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND epi.id_visit = :i_id_visit ';
        END IF;
    
        --i_id_episode
        IF i_id_episode IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.id_episode = :i_id_episode ';
        END IF;
    
        --i_start_date
        IF i_start_date IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND ehd.dt_epis_hidrics_det >= :i_start_date ';
        END IF;
    
        --i_end_date
        IF i_end_date IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND ehd.dt_epis_hidrics_det <= :i_end_date ';
        END IF;
    
        --l_sql_footer := l_sql_footer || ' AND p.id_status != ' || pk_presc_constant.g_presc_temp_edit_status || ' )';
    
        l_sql_stmt := to_clob(l_sql_header || l_sql_inner || l_sql_footer);
        --dbms_output.put_line(dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        pk_alertlog.log_debug(object_name     => g_package_name,
                              sub_object_name => l_db_object_name,
                              text            => dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        dbms_sql.parse(l_curid, l_sql_stmt, dbms_sql.native);
    
        IF i_id_patient IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_patient', i_id_patient);
        END IF;
    
        IF i_id_visit IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_visit', i_id_visit);
        END IF;
    
        IF i_id_episode IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_episode', i_id_episode);
        END IF;
    
        IF i_start_date IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_start_date', i_start_date);
        END IF;
    
        IF i_end_date IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_end_date', i_end_date);
        END IF;
    
        l_ret := dbms_sql.execute(l_curid);
    
        l_cursor := dbms_sql.to_refcursor(l_curid);
    
        FETCH l_cursor BULK COLLECT
            INTO l_out_rec;
    
        RETURN l_out_rec;
    END tf_get_epis_hidrics_ids;

    FUNCTION tf_get_epis_hid
    (
        i_id_patient       IN patient.id_patient%TYPE,
        i_epis_hidrics_ids IN table_number DEFAULT NULL,
        i_id_visit         IN episode.id_visit%TYPE DEFAULT NULL,
        i_id_episode       IN episode.id_episode%TYPE DEFAULT NULL,
        i_start_date       IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_end_date         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL
    ) RETURN table_t_epis_hid IS
        l_out_rec        table_t_epis_hid := table_t_epis_hid(NULL);
        l_sql_header     VARCHAR2(2000 CHAR);
        l_sql_inner      VARCHAR2(1000 CHAR);
        l_sql_footer     VARCHAR2(1000 CHAR);
        l_sql_stmt       CLOB;
        l_curid          INTEGER;
        l_ret            INTEGER;
        l_cursor         pk_types.cursor_type;
        l_db_object_name VARCHAR2(30 CHAR) := 'TF_GET_EPIS_HID';
    
    BEGIN
        l_curid := dbms_sql.open_cursor;
    
        l_sql_header := 'SELECT t_epis_hid(id_epis_hidrics,id_episode,id_professional,flg_type,id_hidrics,id_epis_hid_ftxt_fluid,
id_way,id_epis_hid_ftxt_way,id_epis_hidrics_line,rank,acronym,dt_initial_tstz) from (SELECT DISTINCT eh.id_epis_hidrics,epi.id_episode,
eh.id_professional, h.flg_type,h.id_hidrics,ehl.id_epis_hid_ftxt_fluid,ehl.id_way,ehl.id_epis_hid_ftxt_way,ehl.id_epis_hidrics_line,
h.rank,ht.acronym,eh.dt_initial_tstz
  FROM epis_hidrics eh INNER JOIN episode epi ON (eh.id_episode = epi.id_episode)
 INNER JOIN hidrics_type ht ON (eh.id_hidrics_type = ht.id_hidrics_type)
 INNER JOIN hidrics_interval hi ON (eh.id_hidrics_interval = hi.id_hidrics_interval)
 INNER JOIN epis_hidrics_det ehd ON (eh.id_epis_hidrics = ehd.id_epis_hidrics)
 INNER JOIN epis_hidrics_line ehl ON (ehd.id_epis_hidrics_line = ehl.id_epis_hidrics_line)
 INNER JOIN hidrics h ON (ehl.id_hidrics = h.id_hidrics)
  LEFT JOIN professional p ON (p.id_professional = eh.id_professional)
  LEFT JOIN professional pc ON (pc.id_professional = eh.id_prof_cancel)
  LEFT JOIN professional pi ON (pi.id_professional = eh.id_prof_inter)
 WHERE eh.id_patient = :i_id_patient ';
    
        l_sql_inner := l_sql_inner || '
   AND (eh.flg_status IN (''' || pk_inp_hidrics_constant.g_epis_hidric_e || ''',
                                  ''' || pk_inp_hidrics_constant.g_epis_hidric_f || ''',
                                  ''' || pk_inp_hidrics_constant.g_epis_hidric_i || ''',
                                  ''' || pk_inp_hidrics_constant.g_epis_hidric_r || ''',
                                  ''' || pk_inp_hidrics_constant.g_epis_hidric_o || ''')) ';
    
        --i_epis_hidrics_ids
        IF i_epis_hidrics_ids IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.id_epis_hidrics IN (SELECT /*+ opt_estimate(table t rows=1) */
column_value FROM TABLE(:i_epis_hidrics_ids) t)';
        END IF;
    
        --i_id_visit
        IF i_id_visit IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND epi.id_visit = :i_id_visit ';
        END IF;
    
        --i_id_episode
        IF i_id_episode IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.id_episode = :i_id_episode ';
        END IF;
    
        --i_start_date
        IF i_start_date IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.dt_epis_hidrics >= :i_start_date ';
        END IF;
    
        --i_end_date
        IF i_end_date IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.dt_epis_hidrics >= <= :i_end_date ';
        END IF;
    
        l_sql_footer := l_sql_footer || ' )';
    
        l_sql_stmt := to_clob(l_sql_header || l_sql_inner || l_sql_footer);
        --dbms_output.put_line(dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        pk_alertlog.log_debug(object_name     => g_package_name,
                              sub_object_name => l_db_object_name,
                              text            => dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        dbms_sql.parse(l_curid, l_sql_stmt, dbms_sql.native);
    
        dbms_sql.bind_variable(l_curid, 'i_id_patient', i_id_patient);
    
        IF i_epis_hidrics_ids IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_epis_hidrics_ids', i_epis_hidrics_ids);
        END IF;
    
        IF i_id_visit IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_visit', i_id_visit);
        END IF;
    
        IF i_id_episode IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_episode', i_id_episode);
        END IF;
    
        IF i_start_date IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_start_date', i_start_date);
        END IF;
    
        IF i_end_date IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_end_date', i_end_date);
        END IF;
    
        l_ret := dbms_sql.execute(l_curid);
    
        l_cursor := dbms_sql.to_refcursor(l_curid);
    
        FETCH l_cursor BULK COLLECT
            INTO l_out_rec;
    
        RETURN l_out_rec;
    END tf_get_epis_hid;

    FUNCTION tf_get_reg_hidrics
    (
        i_id_patient       IN epis_hidrics.id_patient%TYPE DEFAULT NULL,
        i_epis_hidrics_ids IN table_number DEFAULT NULL,
        i_id_visit         IN episode.id_visit%TYPE DEFAULT NULL,
        i_id_episode       IN episode.id_episode%TYPE DEFAULT NULL
    ) RETURN table_t_reg_hidrics IS
        l_out_rec        table_t_reg_hidrics := table_t_reg_hidrics(NULL);
        l_sql_header     VARCHAR2(1000 CHAR);
        l_sql_inner      VARCHAR2(1000 CHAR);
        l_sql_footer     VARCHAR2(1000 CHAR);
        l_sql_stmt       CLOB;
        l_curid          INTEGER;
        l_ret            INTEGER;
        l_cursor         pk_types.cursor_type;
        l_db_object_name VARCHAR2(30 CHAR) := 'TF_GET_REG_HIDRICS';
    
    BEGIN
        l_curid := dbms_sql.open_cursor;
    
        l_sql_header := 'SELECT t_reg_hidrics(id_epis_hidrics,id_episode,id_visit) from (select
id_epis_hidrics, e2.id_episode, e2.id_visit FROM epis_hidrics eh JOIN episode e
ON (eh.id_episode = e.id_episode) JOIN episode e2 ON (e2.id_visit = e.id_visit)
 WHERE e.id_patient = :i_id_patient ';
    
        --i_epis_hidrics_ids
        IF i_epis_hidrics_ids IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.id_epis_hidrics IN (SELECT /*+ opt_estimate(table t rows=1) */
column_value FROM TABLE(:i_epis_hidrics_ids) t)';
        END IF;
    
        --i_id_visit
        IF i_id_visit IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND e.id_visit = :i_id_visit ';
        END IF;
    
        --i_id_episode
        IF i_id_episode IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND e.id_episode = :i_id_episode ';
        END IF;
    
        l_sql_footer := l_sql_footer || ' )';
    
        l_sql_stmt := to_clob(l_sql_header || l_sql_inner || l_sql_footer);
        --dbms_output.put_line(dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        pk_alertlog.log_debug(object_name     => g_package_name,
                              sub_object_name => l_db_object_name,
                              text            => dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        dbms_sql.parse(l_curid, l_sql_stmt, dbms_sql.native);
    
        dbms_sql.bind_variable(l_curid, 'i_id_patient', i_id_patient);
    
        IF i_epis_hidrics_ids IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_epis_hidrics_ids', i_epis_hidrics_ids);
        END IF;
    
        IF i_id_visit IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_visit', i_id_visit);
        END IF;
    
        IF i_id_episode IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_episode', i_id_episode);
        END IF;
    
        l_ret := dbms_sql.execute(l_curid);
    
        l_cursor := dbms_sql.to_refcursor(l_curid);
    
        FETCH l_cursor BULK COLLECT
            INTO l_out_rec;
    
        RETURN l_out_rec;
    END tf_get_reg_hidrics;

    FUNCTION tf_get_epis_hid_det
    (
        i_id_patient       IN epis_hidrics.id_patient%TYPE,
        i_epis_hidrics_ids IN table_number DEFAULT NULL,
        i_id_visit         IN episode.id_visit%TYPE DEFAULT NULL,
        i_id_episode       IN episode.id_episode%TYPE DEFAULT NULL,
        i_start_date       IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_end_date         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL
    ) RETURN table_t_epis_hid_det IS
        l_out_rec        table_t_epis_hid_det := table_t_epis_hid_det(NULL);
        l_sql_header     VARCHAR2(2000 CHAR);
        l_sql_inner      VARCHAR2(1000 CHAR);
        l_sql_footer     VARCHAR2(1000 CHAR);
        l_sql_stmt       CLOB;
        l_curid          INTEGER;
        l_ret            INTEGER;
        l_cursor         pk_types.cursor_type;
        l_db_object_name VARCHAR2(30 CHAR) := 'TF_GET_EPIS_HID_DET';
    
    BEGIN
        l_curid := dbms_sql.open_cursor;
    
        l_sql_header := 'SELECT t_epis_hid_det(id_epis_hidrics_det,id_epis_hidrics,id_epis_hidrics_line,id_way,id_epis_hid_ftxt_way,id_epis_hid_ftxt_fluid,value_hidrics,
id_professional_p,flg_type_hid,id_hidrics,flg_type_ehd,nr_times,id_professional_ehd,flg_status,dt_execution_tstz,dt_creation_tstz,id_epis_hidrics_group) FROM (SELECT ehd.id_epis_hidrics_det,
ehd.id_epis_hidrics,ehl.id_epis_hidrics_line,ehl.id_way,ehl.id_epis_hid_ftxt_way,ehl.id_epis_hid_ftxt_fluid,ehd.value_hidrics,
p.id_professional id_professional_p,hid.flg_type flg_type_hid,hid.id_hidrics,ehd.flg_type flg_type_ehd,ehd.nr_times,
ehd.id_professional id_professional_ehd,ehb.flg_status,ehd.dt_execution_tstz,ehd.dt_creation_tstz,ehlg.id_epis_hidrics_group
FROM epis_hidrics eh INNER JOIN episode epi ON epi.id_episode = eh.id_episode INNER JOIN epis_hidrics_balance ehb
ON (eh.id_epis_hidrics = ehb.id_epis_hidrics) INNER JOIN epis_hidrics_det ehd ON (ehb.id_epis_hidrics_balance = ehd.id_epis_hidrics_balance)
INNER JOIN epis_hidrics_line ehl ON (ehl.id_epis_hidrics_line = ehd.id_epis_hidrics_line) LEFT JOIN epis_hd_line_group ehlg
ON ehlg.id_epis_hidrics_line = ehl.id_epis_hidrics_line INNER JOIN hidrics hid ON (hid.id_hidrics = ehl.id_hidrics)
LEFT JOIN professional p ON (p.id_professional = ehd.id_professional)
WHERE eh.id_patient = :i_id_patient ';
    
        l_sql_inner := 'AND nvl(ehd.flg_type, ''' || pk_inp_hidrics_constant.g_epis_hid_det_type_a || ''') = ''' ||
                       pk_inp_hidrics_constant.g_epis_hid_det_type_a || ''' 
               ';
    
        --i_epis_hidrics_ids
        IF i_epis_hidrics_ids IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.id_epis_hidrics IN (SELECT /*+ opt_estimate(table t rows=1) */
column_value FROM TABLE(:i_epis_hidrics_ids) t)';
        END IF;
    
        --i_id_visit
        IF i_id_visit IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND epi.id_visit = :i_id_visit ';
        END IF;
    
        --i_id_episode
        IF i_id_episode IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND eh.id_episode = :i_id_episode ';
        END IF;
    
        --i_start_date
        IF i_start_date IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND ehd.dt_epis_hidrics_det >= :i_start_date ';
        END IF;
    
        --i_end_date
        IF i_end_date IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND ehd.dt_epis_hidrics_det <= :i_end_date ';
        END IF;
    
        l_sql_footer := l_sql_footer || ' )';
    
        l_sql_stmt := to_clob(l_sql_header || l_sql_inner || l_sql_footer);
        --dbms_output.put_line(dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        pk_alertlog.log_debug(object_name     => g_package_name,
                              sub_object_name => l_db_object_name,
                              text            => dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        dbms_sql.parse(l_curid, l_sql_stmt, dbms_sql.native);
    
        dbms_sql.bind_variable(l_curid, 'i_id_patient', i_id_patient);
    
        IF i_epis_hidrics_ids IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_epis_hidrics_ids', i_epis_hidrics_ids);
        END IF;
    
        IF i_id_visit IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_visit', i_id_visit);
        END IF;
    
        IF i_id_episode IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_episode', i_id_episode);
        END IF;
    
        IF i_start_date IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_start_date', i_start_date);
        END IF;
    
        IF i_end_date IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_end_date', i_end_date);
        END IF;
    
        l_ret := dbms_sql.execute(l_curid);
    
        l_cursor := dbms_sql.to_refcursor(l_curid);
    
        FETCH l_cursor BULK COLLECT
            INTO l_out_rec;
    
        RETURN l_out_rec;
    END tf_get_epis_hid_det;

    FUNCTION get_takes_and_outputs_pdms
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_hidrics     IN epis_hidrics.id_epis_hidrics%TYPE,
        i_flg_scope        IN VARCHAR2,
        i_id_episode       IN episode.id_episode%TYPE,
        i_id_patient       IN patient.id_patient%TYPE,
        i_id_visit         IN visit.id_visit%TYPE,
        i_start_date       IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date         IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_scope            IN patient.id_patient%TYPE,
        i_epis_hidrics_ids IN table_number,
        o_epis_hid_det     OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_internal_error EXCEPTION;
        l_epis_hidrics_ids        table_number := NULL;
        l_hidrics_flg_type_desc_a VARCHAR2(4000 CHAR) := pk_sysdomain.get_domain(pk_inp_hidrics_constant.g_hidrics_flg_type,
                                                                                 pk_inp_hidrics_constant.g_hidrics_flg_type_a,
                                                                                 i_lang);
    BEGIN
    
        IF i_epis_hidrics_ids IS NOT NULL
        THEN
            l_epis_hidrics_ids := i_epis_hidrics_ids;
        ELSIF i_epis_hidrics IS NOT NULL
        THEN
            l_epis_hidrics_ids := table_number(i_epis_hidrics);
        END IF;
    
        g_error := 'GET CURSOR O_EPIS_HID';
    
        OPEN o_epis_hid_det FOR
            SELECT t.id_epis_hidrics_det,
                   t.id_epis_hidrics,
                   t.id_epis_hidrics_line,
                   to_char(t.id_way) id_way,
                   to_char(t.id_epis_hid_ftxt_way) id_epis_hid_ftxt_way,
                   t.id_epis_hid_ftxt_fluid,
                   t.value_hidrics,
                   get_hidrics_um(i_lang, i_prof, t.id_epis_hidrics) desc_unit_meas,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, t.id_professional_p) name_prof,
                   t.flg_type_hid flg_type_hid,
                   t.id_hidrics,
                   get_hidrics_way(i_lang, i_prof, t.id_epis_hidrics_line) desc_way,
                   get_hidrics_location_desc(i_lang, i_prof, t.id_epis_hidrics_line) desc_location,
                   t.flg_type_ehd flg_type,
                   t.nr_times,
                   t.id_professional_ehd id_professional,
                   t.flg_status,
                   (SELECT pk_sysdomain.get_img(i_lang, pk_inp_hidrics_constant.g_domain_ehb_flg_status, t.flg_status)
                      FROM dual) flg_status_icon,
                   pk_inp_hidrics_constant.g_flg_hidrics_med_h flg_hidrics_med,
                   (SELECT pk_date_utils.date_send_tsz(i_lang, t.dt_execution_tstz, i_prof)
                      FROM dual) date_exec_str,
                   (SELECT pk_date_utils.date_send_tsz(i_lang, t.dt_creation_tstz, i_prof)
                      FROM dual) date_creation_str,
                   t.id_epis_hidrics_group
              FROM TABLE(tf_get_epis_hid_det(i_id_patient       => i_id_patient,
                                             i_epis_hidrics_ids => l_epis_hidrics_ids,
                                             i_id_visit         => i_id_visit,
                                             i_id_episode       => i_id_episode,
                                             i_start_date       => i_start_date,
                                             i_end_date         => i_end_date)) t
            
            UNION ALL
            -- IV fluids
            SELECT /*+opt_estimate (table med_rep rows=1)*/
             med_rep.id_fluid_det * -1 id_epis_hidrics_det,
             med_rep.id_epis_hidrics,
             med_rep.id_fluid * -1 id_epis_hidrics_line,
             CASE
                  WHEN med_rep.id_route IS NOT NULL THEN
                   '-' || med_rep.id_route
                  ELSE
                   med_rep.id_route
              END id_way,
             CASE
                  WHEN med_rep.route_id IS NOT NULL THEN
                   '-' || med_rep.route_id
                  ELSE
                   med_rep.route_id
              END id_epis_hid_ftxt_way,
             NULL id_epis_hid_ftxt_fluid,
             med_rep.value_fluid value_hidrics,
             med_rep.desc_unit desc_unit_meas,
             (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, med_rep.id_professional)
                FROM dual) name_prof,
             pk_inp_hidrics_constant.g_hidrics_flg_type_a flg_type_hid,
             (med_rep.id_fluid * -1) - 2 id_hidrics, --The "-2" is to avoid the fact this table already as "-1" and "-2" values
             med_rep.route desc_way,
             NULL desc_location,
             pk_inp_hidrics_constant.g_epis_hid_det_type_a flg_type,
             NULL nr_times,
             med_rep.id_professional,
             ehb.flg_status,
             (SELECT pk_sysdomain.get_img(i_lang, pk_inp_hidrics_constant.g_domain_ehb_flg_status, ehb.flg_status)
                FROM dual) flg_status_icon,
             pk_inp_hidrics_constant.g_flg_hidrics_med_m flg_hidrics_med,
             (SELECT pk_date_utils.date_send_tsz(i_lang, med_rep.dt_execution, i_prof)
                FROM dual) date_exec_str,
             (SELECT pk_date_utils.date_send_tsz(i_lang, med_rep.dt_execution, i_prof)
                FROM dual) date_creation_str,
             NULL id_epis_hidrics_group
              FROM TABLE(get_fluid_balance_med_rep(i_lang,
                                                   i_prof,
                                                   i_flg_scope,
                                                   i_scope,
                                                   i_start_date,
                                                   i_end_date,
                                                   l_epis_hidrics_ids)) med_rep
              JOIN epis_hidrics_balance ehb
                ON ehb.id_epis_hidrics = med_rep.id_epis_hidrics
             WHERE med_rep.dt_execution BETWEEN ehb.dt_open_tstz AND nvl(ehb.dt_close_balance_tstz, current_timestamp)
             ORDER BY date_creation_str ASC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_types.open_my_cursor(o_epis_hid_det);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TAKES_AND_OUTPUTS_PDMS',
                                              o_error);
            pk_types.open_my_cursor(o_epis_hid_det);
            RETURN FALSE;
    END get_takes_and_outputs_pdms;

    FUNCTION get_hidrics_location_desc
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_epis_hidrics_line     IN epis_hidrics_line.id_epis_hidrics_line%TYPE,
        i_dt_epis_hid_line_hist IN epis_hidrics_line_hist.dt_epis_hid_line_hist%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
    
        l_error         t_error_out;
        l_desc_location table_varchar := table_varchar(NULL);
    
    BEGIN
    
        SELECT coalesce(t.free_text, pk_translation.get_translation(i_lang, t.code_body_part)) ||
               nvl2(t.id_body_side, ' (' || pk_translation.get_translation(i_lang, t.code_body_side) || ')', '')
          BULK COLLECT
          INTO l_desc_location
          FROM (SELECT ef.free_text, bp.code_body_part, bs.id_body_side, bs.code_body_side
                  FROM epis_hidrics_line ehl
                  JOIN hidrics_location hl
                    ON hl.id_hidrics_location = ehl.id_hidrics_location
                  LEFT JOIN epis_hidrics_det_ftxt ef
                    ON hl.id_hidrics_location = ef.id_hidrics_location
                   AND ef.id_epis_hidrics_det_ftxt = ehl.id_epis_hid_ftxt_loc
                  LEFT JOIN body_part bp
                    ON hl.id_body_part = bp.id_body_part
                  LEFT JOIN body_side bs
                    ON hl.id_body_side = bs.id_body_side
                 WHERE ehl.id_epis_hidrics_line = i_epis_hidrics_line
                   AND (i_dt_epis_hid_line_hist = g_sysdate_tstz OR i_dt_epis_hid_line_hist IS NULL)
                UNION ALL
                SELECT efh.free_text, bp.code_body_part, bs.id_body_side, bs.code_body_side
                  FROM epis_hidrics_line_hist ehlh
                  LEFT JOIN epis_hidrics_det_ftxt efh
                    ON efh.id_epis_hidrics_det_ftxt = ehlh.id_epis_hid_ftxt_loc
                  JOIN hidrics_location hl
                    ON hl.id_hidrics_location = ehlh.id_hidrics_location
                  LEFT JOIN body_part bp
                    ON hl.id_body_part = bp.id_body_part
                  LEFT JOIN body_side bs
                    ON hl.id_body_side = bs.id_body_side
                 WHERE ehlh.id_epis_hidrics_line = i_epis_hidrics_line
                   AND i_dt_epis_hid_line_hist != g_sysdate_tstz
                   AND i_dt_epis_hid_line_hist IS NOT NULL
                   AND ehlh.dt_epis_hid_line_hist = i_dt_epis_hid_line_hist) t;
    
        IF l_desc_location.count > 0
        THEN
            RETURN l_desc_location(l_desc_location.first);
        ELSE
            RETURN NULL;
        END IF;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_HIDRICS_LOCATION_DESC',
                                              l_error);
            RETURN NULL;
    END get_hidrics_location_desc;

    FUNCTION get_order_plan_report
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_task_request  IN table_number,
        i_cpoe_dt_begin IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_cpoe_dt_end   IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_plan_rep      OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_cp_begin      TIMESTAMP WITH LOCAL TIME ZONE;
        l_cp_end        TIMESTAMP WITH LOCAL TIME ZONE;
        l_tbl_hidrics   table_number;
        l_flg_status_eh epis_hidrics.flg_status%TYPE;
        l_count_det     NUMBER(24);
    
        l_tbl_rec_exec_static t_tbl_cpoe_execution := t_tbl_cpoe_execution();
        l_tbl_rec_exec_final  t_tbl_cpoe_execution := t_tbl_cpoe_execution();
        l_last_date           monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_interval            monitorization.interval%TYPE;
        l_calc_last_date      monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_dt_init             epis_hidrics.dt_initial_tstz%TYPE;
        l_dt_end              epis_hidrics.dt_end_tstz%TYPE;
    
        l_error t_error_out;
    BEGIN
    
        IF i_cpoe_dt_begin IS NULL
        THEN
            IF NOT pk_episode.get_epis_dt_begin_tstz(i_lang          => i_lang,
                                                     i_prof          => i_prof,
                                                     i_id_episode    => i_episode,
                                                     o_dt_begin_tstz => l_cp_begin,
                                                     o_error         => o_error)
            THEN
                l_cp_begin := current_timestamp;
            END IF;
        ELSE
            l_cp_begin := i_cpoe_dt_begin;
        END IF;
    
        IF i_cpoe_dt_end IS NULL
        THEN
            l_cp_end := nvl(pk_date_utils.add_days_to_tstz(i_timestamp => i_cpoe_dt_begin, i_days => 1),
                            current_timestamp);
        ELSE
            --l_cp_end :=  pk_date_utils.add_days_to_tstz(i_timestamp => i_cpoe_dt_end, i_days => 1);
            l_cp_end := i_cpoe_dt_end;
        END IF;
    
        SELECT a.id_epis_hidrics
          BULK COLLECT
          INTO l_tbl_hidrics
          FROM epis_hidrics a
         WHERE a.id_episode = i_episode
           AND a.flg_status NOT IN ('C', 'D');
    
        FOR i IN 1 .. l_tbl_hidrics.count
        LOOP
            BEGIN
                SELECT t_rec_cpoe_execution(id_task_type    => NULL,
                                            id_prescription => t.id_epis_hidric,
                                            planned_date    => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                           i_date => t.dt_plan,
                                                                                           i_prof => i_prof),
                                            exec_date       => CASE
                                                                   WHEN t.dt_exec IS NULL THEN
                                                                    NULL
                                                                   ELSE
                                                                    pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => t.dt_exec, i_prof => i_prof)
                                                               END,
                                            exec_notes      => CASE
                                                                   WHEN t.notes = 0 THEN
                                                                    NULL
                                                                   ELSE
                                                                    t.notes || ' mL'
                                                               END,
                                            out_of_period   => t.out_of_period)
                  BULK COLLECT
                  INTO l_tbl_rec_exec_static
                  FROM (SELECT l_tbl_hidrics(i) id_epis_hidric,
                               ehb.dt_open_tstz dt_plan,
                               ehb.dt_close_balance_tstz dt_exec,
                               (nvl(ehb.total_admin, 0) - nvl(ehb.total_elim, 0)) notes,
                               'N' out_of_period
                          FROM epis_hidrics eh
                         INNER JOIN epis_hidrics_balance ehb
                            ON ehb.id_epis_hidrics = eh.id_epis_hidrics
                         WHERE eh.id_epis_hidrics = l_tbl_hidrics(i)
                           AND ehb.dt_open_tstz BETWEEN l_cp_begin AND l_cp_end
                           AND eh.id_hidrics_interval != -1
                        UNION ALL
                        SELECT l_tbl_hidrics(i) id_epis_hidric,
                               ehb.dt_open_tstz dt_plan,
                               ehb.dt_close_balance_tstz dt_exec,
                               (nvl(ehb.total_admin, 0) - nvl(ehb.total_elim, 0)) notes,
                               'N' out_of_period
                          FROM epis_hidrics eh
                         INNER JOIN epis_hidrics_balance ehb
                            ON ehb.id_epis_hidrics = eh.id_epis_hidrics
                         WHERE eh.id_epis_hidrics = l_tbl_hidrics(i)
                           AND ehb.dt_open_tstz BETWEEN l_cp_begin AND l_cp_end
                           AND eh.id_hidrics_interval = -1
                           AND eh.interval_minutes IS NULL
                        UNION ALL
                        SELECT l_tbl_hidrics(i) id_epis_hidric,
                               ehb.dt_open_tstz dt_plan,
                               ehb.dt_close_balance_tstz dt_exec,
                               (nvl(ehb.total_admin, 0) - nvl(ehb.total_elim, 0)) notes,
                               'Y' out_of_period
                          FROM epis_hidrics eh
                         INNER JOIN epis_hidrics_balance ehb
                            ON ehb.id_epis_hidrics = eh.id_epis_hidrics
                         WHERE eh.id_epis_hidrics = l_tbl_hidrics(i)
                           AND ehb.dt_open_tstz < l_cp_begin
                           AND eh.id_hidrics_interval != -1) t;
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
        
            BEGIN
            
                SELECT DISTINCT eh.dt_next_balance
                  INTO l_last_date
                  FROM epis_hidrics eh
                 WHERE eh.id_epis_hidrics = l_tbl_hidrics(i);
            EXCEPTION
                WHEN OTHERS THEN
                    l_last_date := NULL;
            END;
        
            SELECT eh.flg_status
              INTO l_flg_status_eh
              FROM epis_hidrics eh
             WHERE eh.id_epis_hidrics = l_tbl_hidrics(i);
        
            IF l_flg_status_eh != pk_inp_hidrics_constant.g_epis_hidric_i
            THEN
                IF l_last_date IS NOT NULL
                   AND l_last_date <= l_cp_end
                THEN
                
                    SELECT nvl(m.interval_minutes, hi.interval_minutes), m.dt_end_tstz
                      INTO l_interval, l_dt_end
                      FROM epis_hidrics m
                     INNER JOIN hidrics_interval hi
                        ON hi.id_hidrics_interval = m.id_hidrics_interval
                     WHERE m.id_epis_hidrics = l_tbl_hidrics(i);
                
                    l_calc_last_date := l_last_date;
                
                    WHILE l_calc_last_date < l_cp_end
                          AND (l_calc_last_date <= l_dt_end OR l_dt_end IS NULL)
                          AND l_interval IS NOT NULL
                    LOOP
                    
                        IF l_calc_last_date >= l_cp_begin
                        THEN
                            l_tbl_rec_exec_static.extend;
                            l_tbl_rec_exec_static(l_tbl_rec_exec_static.count) := t_rec_cpoe_execution(id_task_type    => NULL,
                                                                                                       id_prescription => l_tbl_hidrics(i),
                                                                                                       planned_date    => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                                                      i_date => l_calc_last_date,
                                                                                                                                                      i_prof => i_prof),
                                                                                                       exec_date       => NULL,
                                                                                                       exec_notes      => NULL,
                                                                                                       out_of_period   => pk_alert_constant.g_no);
                        END IF;
                        l_calc_last_date := l_calc_last_date + numtodsinterval(nvl(l_interval, 0), 'MINUTE');
                    
                    END LOOP;
                
                END IF;
            END IF;
        
            l_tbl_rec_exec_final := l_tbl_rec_exec_final MULTISET UNION l_tbl_rec_exec_static;
        END LOOP;
    
        OPEN o_plan_rep FOR
            SELECT t.id_prescription, t.planned_date, t.exec_date, t.exec_notes, t.out_of_period
              FROM TABLE(l_tbl_rec_exec_final) t
             ORDER BY t.planned_date;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'INACTIVATE_MONITORZTN_TASKS',
                                              l_error);
            pk_types.open_my_cursor(o_plan_rep);
            RETURN FALSE;
        
    END get_order_plan_report;

    FUNCTION get_epis_hidrics_type
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE
    ) RETURN epis_hidrics.id_hidrics_type%TYPE AS
        l_id epis_hidrics.id_hidrics_type%TYPE;
    BEGIN
    
        SELECT eh.id_hidrics_type
          INTO l_id
          FROM epis_hidrics eh
         WHERE eh.id_epis_hidrics = i_epis_hidrics;
    
        RETURN l_id;
    
    END get_epis_hidrics_type;

BEGIN

    -- Log initialization.
    pk_alertlog.who_am_i(g_package_owner, g_package_name);
    pk_alertlog.log_init(g_package_name);
    --
    g_sysdate_tstz := current_timestamp;
    --
    g_epis_hid_hist      := table_number();
    g_epis_hid_det_hist  := table_number();
    g_epis_hid_bal_hist  := table_number();
    g_epis_hid_char_hist := table_number();
    g_epis_hid_line_hist := table_number();
    g_epis_hid_col_hist  := table_number();
    g_epis_hid_ftxt_hist := table_number();
END pk_inp_hidrics;
/
