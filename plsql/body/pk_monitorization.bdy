CREATE OR REPLACE PACKAGE BODY pk_monitorization AS

    --
    -- PRIVATE SUBTYPES
    -- 

    SUBTYPE obj_name IS VARCHAR2(32 CHAR);
    SUBTYPE debug_msg IS VARCHAR2(200 CHAR);

    --
    -- PRIVATE CONSTANTS
    -- 

    -- Package info
    c_package_owner CONSTANT obj_name := 'ALERT';
    c_package_name  CONSTANT obj_name := pk_alertlog.who_am_i();

    --

    c_domain_monit_time        CONSTANT sys_domain.code_domain%TYPE := 'MONITORIZATION.FLG_TIME';
    c_flg_doctor               CONSTANT category.flg_type%TYPE := 'D';
    c_planned_date             CONSTANT sys_config.value%TYPE := 'PLANNED_DATE';
    c_id_sys_alert_vital_sign  CONSTANT sys_alert.id_sys_alert%TYPE := 11;
    c_id_sys_alert_vs_pcontext CONSTANT sys_alert.id_sys_alert%TYPE := 43;
    c_action_monitorization    CONSTANT action.subject%TYPE := 'MONITORIZATION';

    --
    -- FUNCTIONS
    -- 

    /**********************************************************************************************
    * Checks if monitorization was executed at least once
    * @param        i_id_monitorization     Monitorization Episode Identifier
    
    * @return                               TRUE or FALSE
    *                        
    * @author                               Nuno Alves
    * @version                              2.6.5.0.1
    * @since                                06-05-2015
    **********************************************************************************************/
    FUNCTION check_monit_has_execs(i_id_monitorization IN monitorization.id_monitorization%TYPE) RETURN BOOLEAN IS
        l_count NUMBER;
    BEGIN
        SELECT COUNT(1)
          INTO l_count
          FROM monitorization m
          JOIN monitorization_vs mvs
            ON m.id_monitorization = mvs.id_monitorization
          JOIN monitorization_vs_plan mvsp
            ON mvs.id_monitorization_vs = mvsp.id_monitorization_vs
         WHERE m.id_monitorization = i_id_monitorization
           AND mvsp.flg_status = g_monit_vs_plan_final;
    
        RETURN l_count > 0;
    END check_monit_has_execs;

    /**********************************************************************************************
    * set co-sign feature
    *
    * @param      i_lang                   preferred language id for this professional
    * @param      i_prof                   professional type
    * @param      io_monit                 monitorization type
    * @param      o_error                  error message
    *
    * @return     boolean                  true on success, otherwise false
    *
    * @author                              Filipe Machado
    * @version                             2.5.0.7.3
    * @since                               2009/11/18
    **********************************************************************************************/
    FUNCTION set_cosign
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN OUT monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(32 CHAR) := 'SET_COSIGN';
        --
        l_debug_msg            debug_msg;
        l_id_co_sign           co_sign.id_co_sign%TYPE;
        l_id_co_sign_hist      co_sign_hist.id_co_sign_hist%TYPE;
        l_flg_prof_need_cosign VARCHAR2(1 CHAR);
        l_rowsid               table_varchar := table_varchar();
        --
        l_exception EXCEPTION;
        --
        --Code based on Filipe Machado function with the same name
        FUNCTION check_cosign
        (
            i_lang                   IN language.id_language%TYPE,
            i_prof                   IN profissional,
            i_episode                IN episode.id_episode%TYPE,
            i_id_monitorization      IN monitorization.id_monitorization%TYPE,
            i_flg_status             IN monitorization.flg_status%TYPE,
            i_cosign_def_action_type IN VARCHAR2,
            o_flg_prof_need_cosign   OUT VARCHAR2,
            o_error                  OUT t_error_out
        ) RETURN BOOLEAN IS
        BEGIN
            -- check whether the task needs of confirmation through co-sign or not
            IF NOT pk_co_sign_api.check_prof_needs_cosign(i_lang                   => i_lang,
                                                          i_prof                   => i_prof,
                                                          i_episode                => i_episode,
                                                          i_task_type              => pk_alert_constant.g_task_monitoring,
                                                          i_cosign_def_action_type => i_cosign_def_action_type,
                                                          o_flg_prof_need_cosign   => o_flg_prof_need_cosign,
                                                          o_error                  => o_error)
            THEN
                pk_alert_exceptions.reset_error_state;
                RETURN FALSE;
            END IF;
        
            -- insert on the status log
            IF NOT t_ti_log.ins_log(i_lang       => i_lang,
                                    i_prof       => i_prof,
                                    i_id_episode => i_episode,
                                    i_flg_status => i_flg_status,
                                    i_id_record  => i_id_monitorization,
                                    i_flg_type   => pk_alert_constant.g_ti_type_mn,
                                    o_error      => o_error)
            THEN
                pk_alert_exceptions.reset_error_state;
                RETURN FALSE;
            END IF;
        
            RETURN TRUE;
        END check_cosign;
    BEGIN
        l_debug_msg := 'CALL CHECK_COSIGN';
        pk_alertlog.log_debug(text => l_debug_msg, object_name => c_package_name, sub_object_name => l_func_name);
        IF NOT check_cosign(i_lang                   => i_lang,
                       i_prof                   => i_prof,
                       i_episode                => io_monit.id_epis,
                       i_id_monitorization      => io_monit.id_monit,
                       i_flg_status             => io_monit.flg_status,
                       i_cosign_def_action_type => CASE
                                                       WHEN io_monit.flg_monitorization_action IN
                                                            (pk_monitorization.g_order_action, pk_monitorization.g_draft_action) THEN
                                                        pk_co_sign_api.g_cosign_action_def_add
                                                       WHEN io_monit.flg_monitorization_action = pk_monitorization.g_cancel_action THEN
                                                        pk_co_sign_api.g_cosign_action_def_cancel
                                                       ELSE
                                                        pk_co_sign_api.g_cosign_action_def_add
                                                   END,
                       o_flg_prof_need_cosign   => l_flg_prof_need_cosign,
                       o_error                  => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        CASE
            WHEN io_monit.flg_monitorization_action = pk_monitorization.g_order_action
                 AND l_flg_prof_need_cosign = pk_alert_constant.g_yes THEN
                l_debug_msg := 'CALL PK_CO_SIGN_API.SET_PENDING_CO_SIGN_TASK';
                pk_alertlog.log_debug(text            => l_debug_msg,
                                      object_name     => c_package_name,
                                      sub_object_name => l_func_name);
                IF NOT pk_co_sign_api.set_pending_co_sign_task(i_lang                   => i_lang,
                                                               i_prof                   => i_prof,
                                                               i_episode                => io_monit.id_epis,
                                                               i_id_task_type           => pk_alert_constant.g_task_monitoring,
                                                               i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_add,
                                                               i_id_task                => io_monit.id_monit,
                                                               i_id_task_group          => io_monit.id_monit,
                                                               i_id_order_type          => io_monit.id_order_type,
                                                               i_id_prof_created        => i_prof.id,
                                                               i_id_prof_ordered_by     => io_monit.id_prof_order,
                                                               i_dt_created             => current_timestamp,
                                                               i_dt_ordered_by          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                         i_prof,
                                                                                                                         io_monit.dt_order_str,
                                                                                                                         NULL),
                                                               o_id_co_sign             => l_id_co_sign,
                                                               o_id_co_sign_hist        => l_id_co_sign_hist,
                                                               o_error                  => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                l_debug_msg := 'CALL TS_MONITORIZATION.UPD';
                pk_alertlog.log_debug(text            => l_debug_msg,
                                      object_name     => c_package_name,
                                      sub_object_name => l_func_name);
                ts_monitorization.upd(id_monitorization_in => io_monit.id_monit,
                                      id_co_sign_order_in  => l_id_co_sign,
                                      rows_out             => l_rowsid);
                l_debug_msg := 'CALL t_data_gov_mnt.process_update';
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'MONITORIZATION',
                                              i_rowids     => l_rowsid,
                                              o_error      => o_error);
                io_monit.id_co_sign_order := l_id_co_sign;
            WHEN io_monit.flg_monitorization_action = pk_monitorization.g_cancel_action THEN
                IF l_flg_prof_need_cosign = pk_alert_constant.g_no
                   AND io_monit.id_co_sign_order IS NOT NULL
                   AND NOT check_monit_has_execs(io_monit.id_monit)
                THEN
                    --This means that the professional doesn't need co_sign to cancel the monitorization 
                    -- and the monitorization has not been executed yet
                    l_debug_msg := 'CALL TO PK_CO_SIGN_API.SET_TASK_OUTDATED - ID_CO_SIGN:' ||
                                   io_monit.id_co_sign_order;
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                    IF NOT pk_co_sign_api.set_task_outdated(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_episode         => io_monit.id_epis,
                                                            i_id_co_sign      => io_monit.id_co_sign_order,
                                                            i_dt_update       => current_timestamp,
                                                            o_id_co_sign_hist => l_id_co_sign_hist,
                                                            o_error           => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                ELSIF l_flg_prof_need_cosign = pk_alert_constant.g_yes
                THEN
                    -- Professional needs co_sign to cancel the monitorization
                    l_debug_msg := 'CALL PK_CO_SIGN_API.SET_PENDING_CO_SIGN_TASK';
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                
                    IF NOT pk_co_sign_api.set_pending_co_sign_task(i_lang                   => i_lang,
                                                                   i_prof                   => i_prof,
                                                                   i_episode                => io_monit.id_epis,
                                                                   i_id_task_type           => pk_alert_constant.g_task_monitoring,
                                                                   i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_cancel,
                                                                   i_id_task                => io_monit.id_monit,
                                                                   i_id_task_group          => io_monit.id_monit,
                                                                   i_id_order_type          => io_monit.id_order_type,
                                                                   i_id_prof_created        => i_prof.id,
                                                                   i_id_prof_ordered_by     => io_monit.id_prof_order,
                                                                   i_dt_created             => current_timestamp,
                                                                   i_dt_ordered_by          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                             i_prof,
                                                                                                                             io_monit.dt_order_str,
                                                                                                                             NULL),
                                                                   o_id_co_sign             => l_id_co_sign,
                                                                   o_id_co_sign_hist        => l_id_co_sign_hist,
                                                                   o_error                  => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    -- Check if monit has not been executed yet
                    IF io_monit.id_co_sign_order IS NOT NULL
                       AND NOT check_monit_has_execs(io_monit.id_monit)
                    THEN
                        l_debug_msg := 'CALL PK_CO_SIGN_API.SET_TASK_OUTDATED - ID_CO_SIGN:' ||
                                       io_monit.id_co_sign_order;
                        pk_alertlog.log_debug(text            => l_debug_msg,
                                              object_name     => c_package_name,
                                              sub_object_name => l_func_name);
                        IF NOT pk_co_sign_api.set_task_outdated(i_lang            => i_lang,
                                                                i_prof            => i_prof,
                                                                i_episode         => io_monit.id_epis,
                                                                i_id_co_sign      => io_monit.id_co_sign_order,
                                                                i_dt_update       => current_timestamp,
                                                                o_id_co_sign_hist => l_id_co_sign_hist,
                                                                o_error           => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    END IF;
                
                    l_debug_msg := 'CALL TS_MONITORIZATION.UPD';
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                    ts_monitorization.upd(id_monitorization_in => io_monit.id_monit,
                                          id_co_sign_cancel_in => l_id_co_sign,
                                          rows_out             => l_rowsid);
                    l_debug_msg := 'CALL t_data_gov_mnt.process_update';
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'MONITORIZATION',
                                                  i_rowids     => l_rowsid,
                                                  o_error      => o_error);
                    io_monit.id_co_sign_cancel := l_id_co_sign;
                END IF;
            WHEN (io_monit.flg_monitorization_action = pk_monitorization.g_draft_action OR
                 io_monit.flg_monitorization_action = pk_monitorization.g_activate_draft_action)
                 AND l_flg_prof_need_cosign = pk_alert_constant.g_yes THEN
            
                IF io_monit.flg_monitorization_action = pk_monitorization.g_activate_draft_action
                THEN
                    IF NOT pk_co_sign_api.set_task_pending(i_lang            => i_lang,
                                                           i_prof            => i_prof,
                                                           i_episode         => io_monit.id_epis,
                                                           i_id_co_sign      => io_monit.id_co_sign_order,
                                                           i_dt_update       => current_timestamp,
                                                           o_id_co_sign_hist => l_id_co_sign_hist,
                                                           o_error           => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                ELSE
                
                    l_debug_msg := 'CALL PK_CO_SIGN_API.SET_DRAFT_CO_SIGN_TASK';
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                    IF NOT pk_co_sign_api.set_draft_co_sign_task(i_lang               => i_lang,
                                                                 i_prof               => i_prof,
                                                                 i_episode            => io_monit.id_epis,
                                                                 i_id_co_sign         => io_monit.id_co_sign_order,
                                                                 i_id_task_type       => pk_alert_constant.g_task_monitoring,
                                                                 i_id_task            => io_monit.id_monit,
                                                                 i_id_task_group      => io_monit.id_monit,
                                                                 i_id_order_type      => io_monit.id_order_type,
                                                                 i_id_prof_created    => io_monit.id_prof,
                                                                 i_id_prof_ordered_by => io_monit.id_prof_order,
                                                                 i_dt_created         => current_timestamp,
                                                                 i_dt_ordered_by      => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                       i_prof,
                                                                                                                       io_monit.dt_order_str,
                                                                                                                       NULL),
                                                                 o_id_co_sign         => l_id_co_sign,
                                                                 o_id_co_sign_hist    => l_id_co_sign_hist,
                                                                 o_error              => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    l_debug_msg := 'CALL TS_MONITORIZATION.UPD';
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                    l_debug_msg := 'CALL TS_MONITORIZATION.UPD';
                    ts_monitorization.upd(id_monitorization_in => io_monit.id_monit,
                                          id_co_sign_order_in  => l_id_co_sign,
                                          rows_out             => l_rowsid);
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'MONITORIZATION',
                                                  i_rowids     => l_rowsid,
                                                  o_error      => o_error);
                    io_monit.id_co_sign_order := l_id_co_sign;
                END IF;
            ELSE
                NULL;
        END CASE;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_debug_msg,
                                              c_package_owner,
                                              c_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_cosign;

    /**********************************************************************************************
    * retrieves the id visit and id episode type for a determined episode
    *
    * @param    i_lang                   preferred language id for this professional
    * @param    i_id_episode             episode id
    * @param    o_id_visit               visit id for this episode
    * @param    o_id_epis_type           episode type id concerning this episode
    * @param    o_error OUT              error message
    *
    * @return                         true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/17
    **********************************************************************************************/
    FUNCTION get_visit
    (
        i_lang         IN language.id_language%TYPE,
        i_id_episode   IN episode.id_episode%TYPE,
        o_id_visit     OUT visit.id_visit%TYPE,
        o_id_epis_type OUT epis_type.id_epis_type%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        -- GET VISIT
        SELECT id_visit, id_epis_type
          INTO o_id_visit, o_id_epis_type
          FROM episode
         WHERE id_episode = i_id_episode;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_VISIT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_visit;

    /**********************************************************************************************
    * get TIMESTAMP date
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_date                   date (VARCHAR2)
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.5
    * @since                                2009/12/09
    **********************************************************************************************/
    FUNCTION get_tstz_date
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional,
        i_date IN VARCHAR2
    ) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
    BEGIN
        RETURN pk_date_utils.get_string_tstz(i_lang, i_prof, i_date, NULL);
    END get_tstz_date;

    /**********************************************************************************************
    * create monitorization
    *
    * @param  i_lang                  preferred language id for this professional
    * @param  i_prof                  professional type
    * @param  io_monit                monitorization type
    * @param  o_error                 error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/17
    **********************************************************************************************/
    FUNCTION create_monitor
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        next_id_m    monitorization.id_monitorization%TYPE;
        l_id_patient patient.id_patient%TYPE;
        l_rowids     table_varchar;
    
    BEGIN
        -- Monitorization Request
        ts_monitorization.ins(id_monitorization_out     => next_id_m,
                              dt_monitorization_tstz_in => l_sysdate_tstz,
                              id_episode_in             => io_monit.id_epis,
                              id_professional_in        => i_prof.id,
                              dt_begin_tstz_in          => get_tstz_date(i_lang, i_prof, io_monit.dt_begin_final_str),
                              flg_time_in               => io_monit.flg_time,
                              dt_end_tstz_in            => get_tstz_date(i_lang, i_prof, io_monit.dt_end_str),
                              interval_in               => io_monit.interval_final,
                              flg_status_in             => io_monit.flg_status,
                              rows_out                  => l_rowids);
    
        io_monit.id_monit := next_id_m;
    
        BEGIN
            SELECT e.id_patient
              INTO l_id_patient
              FROM episode e
             WHERE e.id_episode = io_monit.id_epis;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END;
    
        pk_translation.insert_translation_trs(i_lang              => i_lang,
                                              i_code              => g_trs_monit_notes || next_id_m,
                                              i_desc              => io_monit.notes,
                                              i_module            => 'MONITORIZATION',
                                              i_episode           => io_monit.id_epis,
                                              i_patient           => l_id_patient,
                                              i_professional      => i_prof.id,
                                              i_dt_record         => l_sysdate_tstz,
                                              i_flg_record_format => 'F',
                                              i_task_type         => pk_alert_constant.g_task_monitoring);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    END create_monitor;

    /**********************************************************************************************
    * get the position of hour separator or 0 if does not exit
    *
    * @param           symbol                   VARCHAR2
    *
    * @return          number                   position of the character ':'
    *
    * @author                                   Filipe Machado
    * @version                                  2.5.0.7.3
    * @since                                    2009/11/17
    **********************************************************************************************/
    FUNCTION interval_has_hour_symbol(symbol VARCHAR2) RETURN NUMBER AS
    BEGIN
        RETURN instr(symbol, ':');
    END interval_has_hour_symbol;

    --

    FUNCTION create_alert_vital_sign
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_monitorization IN monitorization.id_monitorization%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message         debug_msg;
        l_alert_expire_vs VARCHAR2(10);
    
        CURSOR c_get_data IS
            SELECT t.id_episode,
                   m.id_monitorization_vs id_reg,
                   MIN(decode(t.flg_time,
                              pk_alert_constant.g_flg_time_n,
                              NULL,
                              decode(mvp.flg_status,
                                     pk_alert_constant.g_monitor_vs_fini,
                                     NULL,
                                     pk_alert_constant.g_monitor_vs_canc,
                                     NULL,
                                     
                                     mvp.dt_plan_tstz
                                     
                                     ))) dt_req_tstz
              FROM monitorization_vs m, monitorization t, monitorization_vs_plan mvp, episode e, visit v, epis_info ei
             WHERE m.flg_status IN (pk_alert_constant.g_monitor_vs_exec, pk_alert_constant.g_monitor_vs_pend)
               AND t.id_monitorization = m.id_monitorization
               AND (t.flg_time = pk_alert_constant.g_flg_time_e AND
                   (nvl((SELECT CAST(pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL),
                                                                      t.dt_begin_tstz) AS TIMESTAMP WITH LOCAL TIME ZONE)
                           FROM dual),
                         (SELECT CAST(pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL),
                                                                       t.dt_monitorization_tstz) AS TIMESTAMP WITH LOCAL TIME ZONE)
                            FROM dual)) BETWEEN
                   pk_date_utils.add_days_to_tstz(pk_date_utils.trunc_insttimezone(profissional(NULL,
                                                                                                  v.id_institution,
                                                                                                  NULL),
                                                                                     l_sysdate_tstz,
                                                                                     NULL),
                                                    -l_alert_expire_vs) AND
                   
                   (SELECT CAST(pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL),
                                                                   l_sysdate_tstz) AS TIMESTAMP WITH LOCAL TIME ZONE)
                        FROM dual))
                   
                   OR
                   (t.flg_time = pk_alert_constant.g_flg_time_b AND
                   pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL),
                                                      mvp.dt_plan_tstz,
                                                      NULL) =
                   pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL), l_sysdate_tstz, NULL)))
                  
               AND t.flg_status IN (pk_alert_constant.g_monitor_vs_exec, pk_alert_constant.g_monitor_vs_pend)
               AND e.id_episode = t.id_episode
               AND e.flg_status IN (pk_alert_constant.g_epis_status_active, pk_alert_constant.g_epis_status_pendent)
               AND v.id_visit = e.id_visit
               AND mvp.id_monitorization_vs = m.id_monitorization_vs
               AND mvp.flg_status IN (pk_alert_constant.g_monitor_vs_exec, pk_alert_constant.g_monitor_vs_pend)
               AND ei.id_episode = e.id_episode
               AND m.id_monitorization = i_monitorization
             GROUP BY t.id_episode,
                      m.id_monitorization_vs,
                      v.id_institution,
                      pk_sysconfig.get_config('ALERT_VITAL_SIGN_TIMEOUT', v.id_institution, ei.id_software),
                      e.id_clinical_service;
    
    BEGIN
    
        l_alert_expire_vs := pk_sysconfig.get_config('ALERT_EXPIRE_VS', i_prof.institution, i_prof.software);
    
        IF pk_alerts.is_event_version(c_id_sys_alert_vital_sign)
        THEN
        
            --Insere/actualiza os alertas que ainda se verificam
            l_message := 'INSERT NEW ALERTS - VITAL_SIGN';
            FOR c IN c_get_data
            LOOP
                IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_sys_alert           => c_id_sys_alert_vital_sign,
                                                        i_id_episode          => c.id_episode,
                                                        i_id_record           => c.id_reg,
                                                        i_dt_record           => nvl(c.dt_req_tstz, l_sysdate_tstz),
                                                        i_id_professional     => i_prof.id,
                                                        i_id_room             => NULL,
                                                        i_id_clinical_service => NULL,
                                                        i_flg_type_dest       => 'C',
                                                        i_replace1            => NULL,
                                                        o_error               => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            END LOOP;
        END IF;
    
        IF pk_alerts.is_event_version(c_id_sys_alert_vs_pcontext)
        THEN
            --Insere/actualiza os alertas que ainda se verificam
            l_message := 'INSERT NEW ALERTS - VITAL_SIGN';
            FOR c IN c_get_data
            LOOP
                IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_sys_alert           => c_id_sys_alert_vs_pcontext,
                                                        i_id_episode          => c.id_episode,
                                                        i_id_record           => c.id_reg,
                                                        i_dt_record           => nvl(c.dt_req_tstz, l_sysdate_tstz),
                                                        i_id_professional     => i_prof.id,
                                                        i_id_room             => NULL,
                                                        i_id_clinical_service => NULL,
                                                        i_flg_type_dest       => 'C',
                                                        i_replace1            => NULL,
                                                        o_error               => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            END LOOP;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CREATE_ALERT_VITAL_SIGN',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END create_alert_vital_sign;

    /******************************************************************************
       OBJECTIVO:   Chama a função create_monitor_req com o valor do parâmetro commit_data a YES
       PARAMETROS:  Entrada:  I_LANG - Língua registada como preferência do profissional
                  I_EPISODE - ID do Episódio
                      I_PROF - Profissional que regista a requisição da leitura dos sinais vitais
                  I_DT_BEGIN - Data a partir da qual é pedida a leitura
                  I_INTERVAL - Intervalo de tempo entre leituras
                  I_DT_END - Data até à qual é pedida a leitura dos SV
                  I_NOTES - Notas da requisição
                  I_FLG_TIME - Realização: E - neste episódio;
                                   N - próximo episódio;
                               B - entre episódios
                  I_ID_VS - Array de IDs de sinais vitais
                  I_NOTES_DETAIL - Array de notas de detalhe de requisição de leituras
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           como é retornada em PK_LOGIN.GET_PROF_PREF
                    i_prof_order - id do profissional que pediu a requisição
                    i_dt_order_str - momento em que a ordem foi pedida
                    i_order_type - tipo de ordem (telefone, verbal, etc)
              Saida:   O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      ALTERAÇÕES: CRS 2005/07/27
                 LG 2007/07/29 Added input vars i_prof_order, i_dt_order, i_order_type
      NOTAS: Se é requisitado p/ fora do episódio, cria agendamento, para facilitar a
           pesquisa pela grelha
    *********************************************************************************/
    FUNCTION create_monitor_req
    (
        i_lang          IN language.id_language%TYPE,
        i_episode       IN monitorization.id_episode%TYPE,
        i_prof          IN profissional,
        i_dt_begin_str  IN VARCHAR2,
        i_interval      IN VARCHAR2,
        i_dt_end_str    IN VARCHAR2,
        i_notes         IN CLOB,
        i_flg_time      IN monitorization.flg_time%TYPE,
        i_id_vs         IN table_number,
        i_notes_detail  IN table_varchar,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_prof_order    IN monitorization_vs.id_prof_order%TYPE := NULL,
        i_dt_order_str  IN VARCHAR2 := NULL,
        i_order_type    IN monitorization_vs.id_order_type%TYPE := NULL,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_monitorization monitorization.id_monitorization%TYPE;
    
    BEGIN
    
        RETURN create_monitor_req(i_lang              => i_lang,
                                  i_episode           => i_episode,
                                  i_prof              => i_prof,
                                  i_dt_begin_str      => i_dt_begin_str,
                                  i_interval          => i_interval,
                                  i_dt_end_str        => i_dt_end_str,
                                  i_notes             => i_notes,
                                  i_flg_time          => i_flg_time,
                                  i_id_vs             => i_id_vs,
                                  i_notes_detail      => i_notes_detail,
                                  i_prof_cat_type     => i_prof_cat_type,
                                  i_prof_order        => i_prof_order,
                                  i_dt_order_str      => i_dt_order_str,
                                  i_order_type        => i_order_type,
                                  i_commit_data       => pk_alert_constant.g_yes,
                                  o_id_monitorization => l_id_monitorization,
                                  o_error             => o_error);
    END create_monitor_req;

    /**********************************************************************************************
    * validate the boundaries among date begin, date end and current date of the monitorization
    *
    * @param   i_lang                   preferred language id for this professional
    * @param   io_monit                 monitorization type
    * @param   signal                   signal between boundaries {
    *                                                               'lt' less than, 
    *                                                               'eq' equal,
    *                                                               'dd' day is different,
    *                                                               'gt' greater than
    *                                                             }
    * @value   signal                   {*} 'lt' less than 
    *                                   {*} 'eq' equal
    *                                   {*} 'dd' day is different
    *                                   {*} 'gt' greater than
    *                                   
    *
    * @param   o_error                  error message
    *
    * @return  boolean                  true on success, otherwise false
    *
    * @author                           Filipe Machado
    * @version                          2.5.0.7.3
    * @since                            2009/11/17
    **********************************************************************************************/
    FUNCTION validate_boundaries
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN monit,
        signal   IN VARCHAR2,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        dt_begin_tstz TIMESTAMP WITH LOCAL TIME ZONE;
        dt_end_tstz   TIMESTAMP WITH LOCAL TIME ZONE;
        l_prof        profissional;
    
    BEGIN
        dt_begin_tstz := get_tstz_date(i_lang => i_lang, i_prof => i_prof, i_date => io_monit.dt_begin_str);
        dt_end_tstz   := get_tstz_date(i_lang => i_lang, i_prof => i_prof, i_date => io_monit.dt_end_str);
    
        l_prof := profissional(io_monit.id_prof, io_monit.id_inst, io_monit.id_soft);
    
        CASE signal
            WHEN 'lt' THEN
                RETURN(pk_date_utils.trunc_insttimezone(l_prof, dt_begin_tstz, NULL) <
                       pk_date_utils.trunc_insttimezone(l_prof, l_sysdate_tstz, 'SS'));
            WHEN 'eq' THEN
                RETURN(pk_date_utils.trunc_insttimezone(l_prof, dt_begin_tstz, NULL) =
                       pk_date_utils.trunc_insttimezone(l_prof, l_sysdate_tstz, NULL));
            WHEN 'dd' THEN
                RETURN((pk_date_utils.trunc_insttimezone(i_prof, dt_begin_tstz, 'DD') !=
                       pk_date_utils.trunc_insttimezone(i_prof, l_sysdate_tstz, 'DD')) OR
                       (pk_date_utils.trunc_insttimezone(i_prof, dt_end_tstz, 'DD') !=
                       pk_date_utils.trunc_insttimezone(i_prof, l_sysdate_tstz, 'DD')));
            WHEN 'gt' THEN
                RETURN(pk_date_utils.trunc_insttimezone(l_prof, dt_begin_tstz, 'SS') >
                       pk_date_utils.trunc_insttimezone(l_prof, l_sysdate_tstz, 'SS'));
            ELSE
                RETURN FALSE;
        END CASE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'VALIDATE_BOUNDARIES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END validate_boundaries;

    /**********************************************************************************************
    * get VARCHAR2 date
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_date                   date ( TIMESTAMP   WITH LOCAL TIME ZONE)
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.5
    * @since                                2009/12/09
    **********************************************************************************************/
    FUNCTION get_str_date
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional,
        i_date IN TIMESTAMP WITH LOCAL TIME ZONE
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN pk_date_utils.get_timestamp_str(i_lang, i_prof, i_date, NULL);
    END get_str_date;

    /**********************************************************************************************
    * manage the dates parameters
    *
    * @param     i_lang                   preferred language id for this professional
    * @param     i_prof                   id for this professional
    * @param     io_monit                 monitorization type                                                       
    *
    * @return    boolean                  true on success, otherwise false
    *
    * @author                             Filipe Machado
    * @version                            2.5.1
    * @since                              16-Jul-2010
    * @reason                             ALERT-110918   
    **********************************************************************************************/

    FUNCTION manage_dates
    (
        i_lang   language.id_language%TYPE,
        i_prof   profissional,
        io_monit IN OUT NOCOPY monit
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    BEGIN
    
        io_monit.dt_begin_final_str := nvl(io_monit.dt_begin_str,
                                           get_str_date(i_lang => i_lang, i_prof => i_prof, i_date => l_sysdate_tstz));
    
        IF io_monit.dt_end_str IS NOT NULL
           AND
          
           (pk_date_utils.trunc_insttimezone(i_prof,
                                             get_tstz_date(i_lang => i_lang,
                                                           i_prof => i_prof,
                                                           i_date => io_monit.dt_end_str),
                                             'SS') < pk_date_utils.trunc_insttimezone(i_prof, l_sysdate_tstz, 'SS'))
        THEN
            io_monit.dt_end_str := get_str_date(i_lang => i_lang, i_prof => i_prof, i_date => l_sysdate_tstz);
        END IF;
    
        RETURN TRUE;
    
    END manage_dates;

    /**********************************************************************************************
    * Initialize the flags of the monitorization
    *
    * @param     i_lang                   preferred language id for this professional
    * @param     io_monit                 monitorization type                                                       
    * @param     o_error                  error message
    *
    * @return    boolean                  true on success, otherwise false
    *
    * @author                             Filipe Machado
    * @version                            2.5.0.7.3
    * @since                              2009/11/17
    **********************************************************************************************/
    FUNCTION set_init
    (
        i_lang   language.id_language%TYPE,
        i_prof   profissional,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        CASE io_monit.flg_time
            WHEN pk_alert_constant.g_flg_time_n THEN
                io_monit.flg_status         := pk_alert_constant.g_monitor_vs_pend;
                io_monit.flg_status_det     := io_monit.flg_status;
                io_monit.dt_begin_final_str := NULL;
            
            WHEN pk_alert_constant.g_flg_time_b THEN
            
                IF validate_boundaries(i_lang, i_prof, io_monit, 'gt', o_error)
                THEN
                    io_monit.flg_status         := pk_alert_constant.g_monitor_vs_pend;
                    io_monit.flg_status_det     := io_monit.flg_status;
                    io_monit.dt_begin_final_str := io_monit.dt_begin_str;
                ELSE
                    io_monit.flg_status     := pk_alert_constant.g_monitor_vs_exec;
                    io_monit.flg_status_det := io_monit.flg_status;
                
                    IF NOT manage_dates(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                END IF;
            
            WHEN pk_alert_constant.g_flg_time_e THEN
            
                IF validate_boundaries(i_lang, i_prof, io_monit, 'gt', o_error)
                THEN
                    io_monit.flg_status         := pk_alert_constant.g_monitor_vs_pend;
                    io_monit.flg_status_det     := io_monit.flg_status;
                    io_monit.dt_begin_final_str := io_monit.dt_begin_str;
                ELSE
                    io_monit.flg_status     := pk_alert_constant.g_monitor_vs_exec;
                    io_monit.flg_status_det := io_monit.flg_status;
                
                    IF NOT manage_dates(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                END IF;
        END CASE;
    
        --io_monit.id_prof_order := nvl(io_monit.id_prof_order, i_prof.id);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'set_init',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END set_init;
    /**********************************************************************************************
    * validate interval
    *
    * @param i_lang                   preferred language id for this professional
    * @param io_monit                 monitorization type
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/17
    **********************************************************************************************/
    FUNCTION validate_interval
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        l_excep_interval      EXCEPTION;
        l_excep_interval_hour EXCEPTION;
        l_error_in           t_error_in := t_error_in();
        l_ret                BOOLEAN;
        l_monit_interval_max sys_config.value%TYPE;
    
    BEGIN
    
        IF io_monit.interval_final IS NOT NULL
        THEN
            RETURN TRUE;
        END IF;
    
        l_message := 'VALIDATE_INTERVAL - BETWEEN EPISODE OR CURRENT EPISODE AND INTERVAL NOT DEFINED';
        pk_alertlog.log_debug(l_message);
        IF io_monit.flg_time IN (pk_alert_constant.g_flg_time_b, pk_alert_constant.g_flg_time_e)
           AND io_monit.interval IS NULL
        THEN
            RAISE l_excep_interval;
        END IF;
    
        -- Is it being also done this validation on the flash side (multichoice), isn't?
        l_message := 'GET INTERVAL MAX OF MONITORIZATIONS';
        pk_alertlog.log_debug(l_message);
        l_monit_interval_max := pk_sysconfig.get_config(i_code_cf => 'MONITORIZATION_INTERVAL_MAX', i_prof => i_prof);
        --put the value in seconds  (the sysconfig is defined in hours)
        l_monit_interval_max := nvl(to_number(l_monit_interval_max), 0) * 60;
    
        --check if the interval is biggest to the interval defined in sysconfig
        --this is also validated by flash (keypad)    
        IF io_monit.flg_time = pk_alert_constant.g_flg_time_e
           AND to_number(io_monit.interval) > l_monit_interval_max
        THEN
            RAISE l_excep_interval_hour;
        END IF;
    
        io_monit.interval_final := NULL;
        IF io_monit.interval IS NOT NULL
        THEN
            io_monit.interval_final := to_number(nvl(io_monit.interval, 0));
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_excep_interval THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M010',
                               pk_message.get_message(i_lang, 'MONITOR_M006'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'VALIDATE_INTERVAL',
                               pk_message.get_message(i_lang, 'MONITOR_M006'),
                               'U');
            l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
            RETURN l_ret;
        
        WHEN l_excep_interval_hour THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M010',
                               pk_message.get_message(i_lang, 'MONITOR_M008'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'VALIDATE_INTERVAL',
                               pk_message.get_message(i_lang, 'MONITOR_M008'),
                               'U');
            l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
            RETURN l_ret;
    END validate_interval;

    /**********************************************************************************************
    * validate the request of the monitorization
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       io_monit                 monitorization type
    * @param       o_error                  error message
    *
    * @return      boolean                  true = no conflicts, false = has conflits
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/17
    **********************************************************************************************/
    FUNCTION validate_monitor_req
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message      debug_msg;
        l_req_next_day BOOLEAN;
        l_excep_ddb_dif_dda EXCEPTION;
        l_excep_interval    EXCEPTION;
        l_error_in      t_error_in := t_error_in();
        l_ret           BOOLEAN := FALSE;
        l_dt_begin_tstz TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
    
        io_monit.id_prof := nvl(io_monit.id_prof, i_prof.id);
        io_monit.id_inst := nvl(io_monit.id_inst, i_prof.institution);
        io_monit.id_soft := nvl(io_monit.id_soft, i_prof.software);
    
        -- if date order is not defined yet
        IF (io_monit.dt_order_str IS NULL)
        THEN
            -- the sysdate is assigned
            io_monit.dt_order_str := pk_date_utils.get_timestamp_str(i_lang      => i_lang,
                                                                     i_prof      => i_prof,
                                                                     i_timestamp => l_sysdate_tstz,
                                                                     i_timezone  => NULL);
        END IF;
    
        CASE io_monit.flg_time
        
            WHEN pk_alert_constant.g_flg_time_n THEN
                -- next episode
                l_ret := set_init(i_lang, i_prof, io_monit, o_error);
            
            WHEN pk_alert_constant.g_flg_time_b THEN
                -- between episodes
                l_ret := set_init(i_lang, i_prof, io_monit, o_error);
            
            WHEN pk_alert_constant.g_flg_time_e THEN
                -- current episode
                l_req_next_day  := (pk_sysconfig.get_config('REQ_NEXT_DAY', i_prof) = pk_alert_constant.g_no);
                l_dt_begin_tstz := pk_date_utils.get_string_tstz(i_lang, i_prof, io_monit.dt_begin_str, NULL);
            
                IF l_req_next_day
                   AND (l_dt_begin_tstz > current_timestamp)
                THEN
                    -- Isn't this validated from flash side?
                    IF validate_boundaries(i_lang, i_prof, io_monit, 'dd', o_error)
                    THEN
                        RAISE l_excep_ddb_dif_dda;
                    END IF;
                END IF;
            
                l_ret := set_init(i_lang, i_prof, io_monit, o_error);
            
            ELSE
                RETURN TRUE;
            
        END CASE;
    
        IF io_monit.interval_final IS NULL
        THEN
            l_message := 'validate_monitor_req - between episode or current episode and interval not defined';
            IF (io_monit.flg_time IN (pk_alert_constant.g_flg_time_b, pk_alert_constant.g_flg_time_e) AND
               io_monit.interval IS NULL)
               OR (NOT validate_interval(i_lang, i_prof, io_monit, o_error))
            THEN
                RAISE l_excep_interval;
            END IF;
        END IF;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN l_excep_ddb_dif_dda THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M009',
                               pk_message.get_message(i_lang, 'MONITOR_M009'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'VALIDATE_MONITOR_REQ',
                               pk_message.get_message(i_lang, 'MONITOR_M009'),
                               'U');
        
            l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
        
            RETURN l_ret;
        
        WHEN OTHERS THEN
            RETURN FALSE;
        
    END validate_monitor_req;

    /******************************************************************************
       OBJECTIVO: Obter a info a mostrar no ecrã intermédio de registo de nova
              req. de monitorização
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                             I_ID_MONITOR_VS - ID de monitorização
                             I_ID_VS - Array de IDs de sinais vitais
                    Saida:   O_MONITOR -  lista de requisições
                 O_ERROR - erro
    
      CRIAÇÃO: CRS 2005/07/28
      NOTAS:
    *********************************************************************************/
    FUNCTION get_aux_monitor
    (
        i_lang          IN language.id_language%TYPE,
        i_id_monitor_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_prof          IN profissional,
        i_dt_first_read IN VARCHAR2,
        o_monitor       OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        c_function_name CONSTANT obj_name := 'GET_AUX_MONITOR';
        l_dbg_msg debug_msg;
    
        l_monitor_start_date_type sys_config.value%TYPE;
        l_msg_na                  sys_message.desc_message%TYPE;
        l_msg_title_sv            sys_message.desc_message%TYPE;
    
        l_dt_first_read TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
        l_dbg_msg := 'get sys config';
        pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => c_function_name);
        l_monitor_start_date_type := nvl(s1 => pk_sysconfig.get_config(i_code_cf   => 'MONITOR_START_DATE',
                                                                       i_prof_inst => i_prof.institution,
                                                                       i_prof_soft => i_prof.software),
                                         s2 => 'PLANNED_DATE');
    
        l_dbg_msg := 'get sys messages';
        pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => c_function_name);
        l_msg_na       := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_M018');
        l_msg_title_sv := pk_message.get_message(i_lang => i_lang, i_code_mess => 'MONITOR_M005');
    
        l_dbg_msg := 'get sys messages';
        pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => c_function_name);
        l_dt_first_read := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                         i_prof      => i_prof,
                                                         i_timestamp => i_dt_first_read,
                                                         i_timezone  => NULL);
    
        l_dbg_msg := 'get cursor';
        pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => c_function_name);
        OPEN o_monitor FOR
            SELECT DISTINCT decode(sign(extract(DAY FROM(decode(l_monitor_start_date_type,
                                                            c_planned_date,
                                                            mea.dt_plan,
                                                            l_dt_first_read) +
                                                     numtodsinterval(nvl(mea.interval, 0), 'SECOND') -
                                                     nvl(mea.dt_end,
                                                         decode(l_monitor_start_date_type,
                                                                c_planned_date,
                                                                mea.dt_plan,
                                                                l_dt_first_read) + numtodsinterval(1, 'DAY') +
                                                         numtodsinterval(nvl(mea.interval, 0), 'SECOND'))))),
                                   1,
                                   l_msg_na,
                                   pk_date_utils.date_char_tsz(i_lang,
                                                               decode(l_monitor_start_date_type,
                                                                      c_planned_date,
                                                                      mea.dt_plan,
                                                                      l_dt_first_read) +
                                                               numtodsinterval(nvl(mea.interval, 0), 'SECOND'),
                                                               i_prof.institution,
                                                               i_prof.software)) AS dt_plan,
                            decode(sign(extract(DAY FROM(decode(l_monitor_start_date_type,
                                                            c_planned_date,
                                                            mea.dt_plan,
                                                            l_dt_first_read) +
                                                     numtodsinterval(nvl(mea.interval, 0), 'SECOND') -
                                                     nvl(mea.dt_end,
                                                         decode(l_monitor_start_date_type,
                                                                c_planned_date,
                                                                mea.dt_plan,
                                                                l_dt_first_read) + numtodsinterval(1, 'DAY') +
                                                         numtodsinterval(nvl(mea.interval, 0), 'SECOND'))))),
                                   1,
                                   l_msg_na,
                                   pk_date_utils.date_send_tsz(i_lang,
                                                               decode(l_monitor_start_date_type,
                                                                      c_planned_date,
                                                                      mea.dt_plan,
                                                                      l_dt_first_read) +
                                                               numtodsinterval(nvl(mea.interval, 0), 'SECOND'),
                                                               i_prof)) AS date_plan,
                            pk_vital_sign.get_vs_desc(i_lang, mea.id_vital_sign) AS desc_vital_sign,
                            l_msg_title_sv AS title_sv,
                            decode(sign(extract(DAY
                                                FROM(l_dt_first_read + numtodsinterval(nvl(mea.interval, 0), 'SECOND') -
                                                     nvl(mea.dt_end,
                                                         l_dt_first_read + numtodsinterval(1, 'DAY') +
                                                         numtodsinterval(nvl(mea.interval, 0), 'SECOND'))))),
                                   1,
                                   pk_alert_constant.g_no,
                                   pk_alert_constant.g_yes) AS flg_edit,
                            pk_date_utils.date_send_tsz(i_lang, nvl(mvsp.start_time, mea.dt_monitorization), i_prof) AS dt_val,
                            pk_date_utils.date_send_tsz(i_lang, mea.dt_begin, i_prof) AS dt_start_req,
                            pk_date_utils.date_send_tsz(i_lang, mea.dt_end, i_prof) AS dt_end_req
              FROM monitorizations_ea mea
             INNER JOIN monitorization_vs_plan mvsp
                ON mea.id_monitorization_vs_plan = mvsp.id_monitorization_vs_plan
             WHERE mea.id_monitorization_vs = i_id_monitor_vs
               AND mea.flg_status_plan NOT IN
                   (pk_alert_constant.g_monitor_vs_fini, pk_alert_constant.g_monitor_vs_canc);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => l_dbg_msg,
                                              i_owner    => c_package_owner,
                                              i_package  => c_package_name,
                                              i_function => c_function_name,
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(i_cursor => o_monitor);
            RETURN FALSE;
        
    END get_aux_monitor;

    /******************************************************************************
       OBJECTIVO:   Obtém todos os parâmetros que devolvem o estado de uma requisição de uma monitorização.  
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                             I_PROF - ID do profissional
                             I_ID_MONITORIZATION - ID da monitorização
                    Saida:   O_FLG_STATUS - Estado da requisição
                             O_DESC_STAT - Formato de apresentação do estado
                             O_FLG_TEXT - Texto a apresentar no estado
                             O_COLOR_STATUS - Cor do estado
                             O_FLG_FINISHED - Indica se a requisição da monitorização já está num estado final
                             O_FLG_CANCELED - Indica se a requisição da monitorização foi cancelada
                             O_ERROR - Mensagem erro
    
      CRIAÇÃO: Tiago Silva 2008/05/28
      NOTAS:
    *********************************************************************************/
    FUNCTION get_monitor_req_status
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        o_flg_status        OUT monitorization.flg_status%TYPE,
        o_status_string     OUT VARCHAR2,
        o_flg_finished      OUT VARCHAR2,
        o_flg_canceled      OUT VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
    BEGIN
        l_message := 'GET REQUEST STATUS';
        SELECT flg_status, status_string, flg_finished, flg_canceled
          INTO o_flg_status, o_status_string, o_flg_finished, o_flg_canceled
          FROM (SELECT mea.flg_status,
                       pk_utils.get_status_string(i_lang,
                                                  i_prof,
                                                  mea.status_str,
                                                  mea.status_msg,
                                                  mea.status_icon,
                                                  mea.status_flg) status_string,
                       decode(mea.flg_status,
                              pk_alert_constant.g_monitor_vs_fini,
                              pk_alert_constant.g_yes,
                              pk_alert_constant.g_no) AS flg_finished,
                       decode(mea.flg_status,
                              pk_alert_constant.g_monitor_vs_canc,
                              pk_alert_constant.g_yes,
                              pk_alert_constant.g_no) AS flg_canceled
                  FROM monitorizations_ea mea
                 WHERE mea.id_monitorization = i_id_monitorization
                 ORDER BY decode(mea.flg_status_det, pk_alert_constant.g_monitor_vs_canc, 2, 1))
         WHERE rownum = 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_REQ_STATUS',
                                              o_error);
            RETURN FALSE;
    END get_monitor_req_status;

    /**********************************************************************************************
    * It indicates whether a vital_sign has measurements or not
    *
    * @param i_lang                  Language ID
    * @param i_prof                  Professional
    * @param i_monitoring_vs         Monitorization vital sign ID
    *                        
    * @author                        Filipe Machado
    * @version                       v2.6.1.1
    * @since                         28-Jun-2011
    **********************************************************************************************/

    FUNCTION vs_has_measurements
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_monitoring_vs IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret VARCHAR2(1 CHAR);
    BEGIN
    
        SELECT CASE COUNT(1)
                   WHEN 0 THEN
                    pk_alert_constant.get_no()
                   ELSE
                    pk_alert_constant.get_yes()
               END CASE
          INTO l_ret
          FROM monitorizations_ea mea
         INNER JOIN episode e
            ON mea.id_episode = e.id_episode
         INNER JOIN monitorization_vs_plan mvsp
            ON mvsp.id_monitorization_vs = mea.id_monitorization_vs
         WHERE mea.id_monitorization_vs = i_monitoring_vs
           AND mea.flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_draft)
           AND e.flg_status != pk_alert_constant.g_epis_status_cancel
           AND mvsp.flg_status = pk_alert_constant.g_monitor_vs_fini;
    
        RETURN l_ret;
    
    END vs_has_measurements;

    /******************************************************************************
       OBJECTIVO:   Obter requisições de monitorização de sinais vitais num episódio
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                             I_EPISODE - ID do episódio
                    Saida:   O_MONITOR -  lista de requisições
                             O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      ALTERAÇÕES: CRS 2005/06/06
              CRS 2005/07/27
              CMF 27-05-2008 ORIENTAR CONSULTA PARA A VISITA
      NOTAS:
    *********************************************************************************/
    FUNCTION get_monitor_req
    (
        i_lang    IN language.id_language%TYPE,
        i_episode IN episode.id_episode%TYPE,
        i_prof    IN profissional,
        o_monitor OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
        l_id_epis_type episode.id_epis_type%TYPE;
        l_id_visit     visit.id_visit%TYPE;
    
        err_get_monitor_req EXCEPTION;
    BEGIN
        l_message := 'GET VISIT';
        SELECT id_visit, id_epis_type
          INTO l_id_visit, l_id_epis_type
          FROM episode
         WHERE id_episode = i_episode;
    
        l_message := 'CALL GET_MONITOR_REQ';
        IF NOT get_monitor_req(i_lang         => i_lang,
                               i_prof         => i_prof,
                               i_scope        => l_id_visit,
                               i_flg_scope    => pk_alert_constant.g_scope_type_visit,
                               i_start_date   => NULL,
                               i_end_date     => NULL,
                               i_cancelled    => pk_alert_constant.g_yes,
                               i_crit_type    => g_monit_crit_type_all_a,
                               i_flg_report   => pk_alert_constant.g_no,
                               i_id_epis_type => l_id_epis_type,
                               o_monitor      => o_monitor,
                               o_error        => o_error)
        THEN
            RAISE err_get_monitor_req;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_REQ',
                                              o_error);
            RETURN FALSE;
    END get_monitor_req;

    /*******************************************************************************************************************************************
    * Get requests monitoring of vital signs in an episode (Guided for consultation visit)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_SCOPE                  Scope ID (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_FLG_SCOPE              Flag Scope (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled ('Y' - Yes, 'N' - No)
    * @param I_CRIT_TYPE              Flag that indicates if the filter time to consider all records or only during the executions ('A' - All, 'E' - Executions, ...)
    * @param I_FLG_REPORT             Flag used to remove formatting ('Y' - Yes, 'N' - No)
    * @param I_ID_EPIS_TYPE           Type of episode
    * @param O_MONITOR                Cursor that returns monitorizations
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_FLG_SCOPE              {*} 'E' Episode {*} 'V' Visit {*} 'P' Patient'
    * @value I_CANCELLED              {*} 'Y' YES {*} 'N' NO
    * @value I_CRIT_TYPE              {*} 'A' All {*} 'R' Requisitions {*} 'E' Executions
    * @value I_FLG_REPORT             {*} 'Y' YES {*} 'N' NO
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    *
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          07-Nov-2011
    *******************************************************************************************************************************************/
    FUNCTION get_monitor_req
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_scope        IN NUMBER,
        i_flg_scope    IN VARCHAR2,
        i_start_date   IN VARCHAR2,
        i_end_date     IN VARCHAR2,
        i_cancelled    IN VARCHAR2,
        i_crit_type    IN VARCHAR2,
        i_flg_report   IN VARCHAR2,
        i_id_epis_type IN episode.id_epis_type%TYPE,
        i_flg_status   IN table_varchar DEFAULT NULL,
        o_monitor      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message  debug_msg;
        l_timezone timezone_region.timezone_region%TYPE;
    
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient patient.id_patient%TYPE;
    
        e_invalid_argument EXCEPTION;
    
        l_start_date TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_end_date   TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
    
        l_flg_status_count NUMBER;
        l_tbl_status       table_varchar;
    
    BEGIN
    
        IF i_flg_status IS NOT NULL
        THEN
            IF i_flg_status.count = 0
            THEN
                l_flg_status_count := 0;
                l_tbl_status       := table_varchar();
            ELSE
                l_tbl_status := i_flg_status;
            END IF;
        ELSE
            l_flg_status_count := 0;
            l_tbl_status       := table_varchar();
        END IF;
    
        l_message := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE e_invalid_argument;
        END IF;
    
        --convert string to date format
        IF i_start_date IS NOT NULL
        THEN
            l_start_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_date, NULL);
        END IF;
        IF i_end_date IS NOT NULL
        THEN
            l_end_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_date, NULL);
        END IF;
    
        IF NOT pk_date_utils.get_timezone(i_lang     => i_lang,
                                          i_prof     => i_prof,
                                          i_timezone => NULL,
                                          o_timezone => l_timezone,
                                          o_error    => o_error)
        THEN
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        END IF;
    
        l_message := 'GET CURSOR';
        OPEN o_monitor FOR
            SELECT t.*,
                   pk_utils.get_status_string(i_lang, i_prof, t.status_str, t.status_msg, t.status_icon, t.status_flg) status_string
              FROM (SELECT DISTINCT mea.id_vital_sign,
                                    mea.id_monitorization,
                                    mea.num_monit,
                                    mea.id_monitorization_vs,
                                    mea.flg_status_det,
                                    mea.flg_status,
                                    mea.flg_time,
                                    pk_vital_sign.get_vs_desc(i_lang, mea.id_vital_sign) ||
                                    decode(nvl(i_id_epis_type, epi.id_epis_type),
                                           nvl(t_ti_log.get_epis_type(i_lang,
                                                                      i_prof,
                                                                      epi.id_epis_type,
                                                                      mea.flg_status,
                                                                      mea.id_monitorization,
                                                                      pk_alert_constant.g_ti_type_mn),
                                               epi.id_epis_type),
                                           '',
                                           ' - (' || pk_message.get_message(i_lang,
                                                                            profissional(i_prof.id,
                                                                                         i_prof.institution,
                                                                                         t_ti_log.get_epis_type_soft(i_lang,
                                                                                                                     i_prof,
                                                                                                                     epi.id_epis_type,
                                                                                                                     mea.flg_status,
                                                                                                                     mea.id_monitorization,
                                                                                                                     pk_alert_constant.g_ti_type_mn)),
                                                                            'IMAGE_T009') || ')') desc_vital_sign,
                                    decode(mea.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           decode(mea.flg_status_plan,
                                                  pk_alert_constant.g_monitor_vs_fini,
                                                  NULL,
                                                  pk_alert_constant.g_monitor_vs_canc,
                                                  NULL,
                                                  pk_date_utils.dt_chr_tsz(i_lang,
                                                                           mea.dt_plan,
                                                                           i_prof.institution,
                                                                           i_prof.software))) date_target,
                                    decode(mea.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           pk_message.get_message(i_lang, 'COMMON_M018'),
                                           decode(mea.flg_status_plan,
                                                  pk_alert_constant.g_monitor_vs_fini,
                                                  pk_message.get_message(i_lang, 'COMMON_M018'),
                                                  pk_alert_constant.g_monitor_vs_canc,
                                                  pk_message.get_message(i_lang, 'COMMON_M018'),
                                                  pk_date_utils.date_char_hour_tsz(i_lang,
                                                                                   mea.dt_plan,
                                                                                   i_prof.institution,
                                                                                   i_prof.software))) hour_target,
                                    get_interval_desc(i_lang, i_prof, mea.id_monitorization) desc_interval,
                                    decode(mea.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           mea.flg_status_det,
                                           decode(mea.flg_status_det,
                                                  pk_alert_constant.g_monitor_vs_canc,
                                                  mea.flg_status_det,
                                                  pk_alert_constant.g_monitor_vs_expire,
                                                  mea.flg_status_det,
                                                  pk_alert_constant.g_monitor_vs_fini,
                                                  mea.flg_status_det,
                                                  decode(least(mea.dt_plan, l_sysdate_tstz),
                                                         mea.dt_plan,
                                                         pk_alert_constant.g_monitor_vs_exec,
                                                         mea.flg_status_det))) visual_status,
                                    pk_sysdomain.get_domain('MONITORIZATION.FLG_TIME', mea.flg_time, i_lang) desc_time,
                                    decode(nvl(mea.flg_notes, pk_alert_constant.g_no),
                                           pk_alert_constant.g_no,
                                           '',
                                           pk_alert_constant.g_yes,
                                           pk_message.get_message(i_lang, 'COMMON_M008')) title_notes,
                                    decode(mea.flg_status_det,
                                           pk_alert_constant.g_monitor_vs_canc,
                                           pk_alert_constant.g_yes,
                                           pk_alert_constant.g_monitor_vs_inte,
                                           pk_alert_constant.g_yes,
                                           pk_alert_constant.g_no) flg_cancel,
                                    pk_date_utils.to_char_insttimezone(i_prof, mea.dt_plan, 'YYYYMMDDHH24MISS') dt_ord1,
                                    CASE
                                         WHEN mea.flg_status_det IN
                                              (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_inte) THEN
                                          NULL
                                         ELSE
                                          vs_has_measurements(i_lang, i_prof, mea.id_monitorization_vs)
                                     END AS has_measurements,
                                    check_exec_monit(i_lang,
                                                     i_prof,
                                                     m.id_episode,
                                                     m.id_monitorization,
                                                     m.flg_time,
                                                     m.flg_status,
                                                     m.dt_begin_tstz,
                                                     pk_alert_constant.g_yes) flg_ok_button,
                                    check_cancel_monit(i_lang, i_prof, m.flg_time, m.flg_status, pk_alert_constant.g_yes) flg_cancel_button,
                                    check_detail_monit(m.flg_status) flg_detail_button,
                                    mea.status_str,
                                    mea.status_msg,
                                    mea.status_icon,
                                    mea.status_flg,
                                    nvl(m.id_co_sign_cancel, m.id_co_sign_order) id_co_sign
                      FROM monitorizations_ea mea
                     INNER JOIN episode epi
                        ON mea.id_episode = epi.id_episode
                     INNER JOIN monitorization m
                        ON mea.id_monitorization = m.id_monitorization
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                       AND mvs.id_vital_sign = mea.id_vital_sign
                     INNER JOIN monitorization_vs_plan mvsp
                        ON mvs.id_monitorization_vs = mvsp.id_monitorization_vs
                     WHERE epi.id_episode = nvl(l_id_episode, epi.id_episode)
                       AND epi.id_visit = nvl(l_id_visit, epi.id_visit)
                       AND (l_flg_status_count = 0 OR
                           mea.flg_status IN (SELECT t1.column_value
                                                 FROM TABLE(l_tbl_status) t1))
                       AND epi.id_patient = nvl(l_id_patient, epi.id_patient)
                       AND m.flg_status <> pk_alert_constant.g_monitor_vs_draft
                       AND (
                           --not report gets all
                            i_flg_report = pk_alert_constant.g_no OR
                           --
                            (
                            --if report
                             i_flg_report = pk_alert_constant.g_yes
                            --
                             AND
                            --
                             (
                             --shows canceled monitorizations or not whether flag i_cancelled
                              (i_cancelled = pk_alert_constant.g_no AND m.flg_status <> pk_alert_constant.g_monitor_vs_canc) OR
                              i_cancelled = pk_alert_constant.g_yes
                             --
                             )
                            --
                             AND
                            --
                             (
                             --shows monitorizations or not whether flag i_crit_type and the dates (i_start_date and i_end_date)
                             --Shows all the monitorizations where the req and exec was performed in the period
                              (i_crit_type = g_monit_crit_type_all_a AND
                              (m.dt_begin_tstz BETWEEN nvl(l_start_date, m.dt_begin_tstz) AND
                              nvl(l_end_date, m.dt_begin_tstz) OR
                              (mvsp.start_time BETWEEN nvl(l_start_date, mvsp.start_time) AND
                              nvl(l_end_date, mvsp.start_time) AND
                              mvsp.end_time BETWEEN nvl(l_start_date, mvsp.end_time) AND nvl(l_end_date, mvsp.end_time))))
                             --
                              OR
                             --Shows the monitorizations that where req in the period
                              (i_crit_type = g_monit_crit_type_req_r AND
                              m.dt_begin_tstz BETWEEN nvl(l_start_date, m.dt_begin_tstz) AND
                              nvl(l_end_date, m.dt_begin_tstz))
                             --
                              OR
                             --Shows the monitorizations that where exec in the period
                              (i_crit_type = g_monit_crit_type_exec_e AND
                              mvsp.start_time BETWEEN nvl(l_start_date, mvsp.start_time) AND
                              nvl(l_end_date, mvsp.start_time) AND mvsp.end_time BETWEEN nvl(l_start_date, mvsp.end_time) AND
                              nvl(l_end_date, mvsp.end_time))
                             --
                             )
                            --
                            )
                           --
                           )) t
             ORDER BY pk_sysdomain.get_rank(i_lang, 'MONITORIZATION_VS.FLG_STATUS', visual_status),
                      date_target,
                      hour_target;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_REQ',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_monitor);
            RETURN FALSE;
    END get_monitor_req;

    /******************************************************************************
       OBJECTIVO:   Obter detalhe de uma monitorização
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITOR_VS - ID da requisição.
              Saida:   O_MONITOR -  detalhe de requisião
                 O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      NOTAS:  LG 2007/08/29 Devolver informação relacionada com quem pediu o procedimento (!= de quem registou)
    
    *********************************************************************************/
    FUNCTION get_monitor_vs_req
    (
        i_lang          IN language.id_language%TYPE,
        i_id_monitor_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_prof          IN profissional,
        o_monitor       OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
        l_id_episode episode.id_episode%TYPE;
    
        err_get_monitor_vs_req EXCEPTION;
    
    BEGIN
    
        l_message := 'GET EPISODE';
        SELECT DISTINCT m.id_episode
          INTO l_id_episode
          FROM monitorization_vs mvs
         INNER JOIN monitorization m
            ON mvs.id_monitorization = m.id_monitorization
         WHERE mvs.id_monitorization_vs = i_id_monitor_vs;
    
        l_message := 'CALL GET_MONITOR_VS_REQ';
        IF NOT get_monitor_vs_req(i_lang          => i_lang,
                                  i_prof          => i_prof,
                                  i_id_monitor_vs => i_id_monitor_vs,
                                  i_scope         => l_id_episode,
                                  i_flg_scope     => pk_alert_constant.g_scope_type_episode,
                                  i_start_date    => NULL,
                                  i_end_date      => NULL,
                                  i_cancelled     => pk_alert_constant.g_yes,
                                  i_crit_type     => g_monit_crit_type_all_a,
                                  i_flg_report    => pk_alert_constant.g_no,
                                  o_monitor       => o_monitor,
                                  o_error         => o_error)
        THEN
            RAISE err_get_monitor_vs_req;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_VS_REQ',
                                              o_error);
            RETURN FALSE;
    END get_monitor_vs_req;

    /*******************************************************************************************************************************************
    * Get details of a monitoring (Return information related to who requested the procedure - != Who registered)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_ID_MONITOR_VS          ID Vital Sign Monitor request
    * @param I_SCOPE                  Scope ID (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_FLG_SCOPE              Flag Scope (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled ('Y' - Yes, 'N' - No)
    * @param I_CRIT_TYPE              Flag that indicates if the filter time to consider all records or only during the executions ('A' - All, 'E' - Executions, ...)
    * @param I_FLG_REPORT             Flag used to remove formatting ('Y' - Yes, 'N' - No)
    * @param O_MONITOR                Cursor that returns request detail
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_FLG_SCOPE              {*} 'E' Episode {*} 'V' Visit {*} 'P' Patient'
    * @value I_CANCELLED              {*} 'Y' YES {*} 'N' NO
    * @value I_CRIT_TYPE              {*} 'A' All {*} 'R' Requisitions {*} 'E' Executions
    * @value I_FLG_REPORT             {*} 'Y' YES {*} 'N' NO
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    *
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          07-Nov-2011
    *******************************************************************************************************************************************/
    FUNCTION get_monitor_vs_req
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_monitor_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_scope         IN NUMBER,
        i_flg_scope     IN VARCHAR2,
        i_start_date    IN VARCHAR2,
        i_end_date      IN VARCHAR2,
        i_cancelled     IN VARCHAR2,
        i_crit_type     IN VARCHAR2,
        i_flg_report    IN VARCHAR2,
        o_monitor       OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient patient.id_patient%TYPE;
    
        e_invalid_argument EXCEPTION;
    
        l_start_date    TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_end_date      TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_sign_off_t034 sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'SIGN_OFF_T034');
    
        l_sm_cancel_notes        sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M017');
        l_sm_order               sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M024');
        l_sm_execution           sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M016');
        l_sm_pending             sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M017');
        l_sm_draft               sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M018');
        l_sm_cancelled           sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M019');
        l_sm_discontinued        sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M020');
        l_sm_order_cosign        sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M021');
        l_sm_discontinued_cosign sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M022');
        l_sm_cancelled_cosign    sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M023');
    
    BEGIN
        l_message := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE e_invalid_argument;
        END IF;
    
        --convert string to date format
        IF i_start_date IS NOT NULL
        THEN
            l_start_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_date, NULL);
        END IF;
        IF i_end_date IS NOT NULL
        THEN
            l_end_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_date, NULL);
        END IF;
    
        l_message := 'OPEN o_monitor';
        OPEN o_monitor FOR
            SELECT *
              FROM (
                    --discontinuation co-sign
                    SELECT rownum rn,
                            epi.id_episode,
                            epi.id_visit,
                            epi.id_patient,
                            NULL flg_status,
                            NULL dt_begin_tstz,
                            NULL start_time,
                            NULL end_time,
                            c.dt_co_signed dt_monitorization,
                            4 ordering,
                            NULL notes,
                            pk_alert_constant.g_monitor_vs_exec flg_status_det,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, c.id_prof_co_signed) nick_name,
                            c.desc_status desc_status,
                            NULL flg_time,
                            NULL desc_time,
                            c.dt_co_signed dt_ordering,
                            pk_date_utils.dt_chr_tsz(i_lang, c.dt_co_signed, i_prof) date_req,
                            pk_date_utils.date_char_hour_tsz(i_lang, c.dt_co_signed, i_prof.institution, i_prof.software) hour_req,
                            NULL date_begin,
                            NULL hour_begin,
                            NULL date_end,
                            NULL hour_end,
                            NULL desc_interval,
                            NULL dt_cancel,
                            NULL title_cancel,
                            NULL prof_cancel,
                            NULL notes_cancel,
                            NULL desc_speciality,
                            NULL desc_speciality_cancel,
                            NULL date_next,
                            NULL hour_next,
                            NULL desc_vs,
                            NULL prof_order,
                            NULL order_type_desc,
                            NULL dt_order,
                            NULL name_performed,
                            NULL prof_order_spec,
                            decode(m.flg_status,
                                   pk_alert_constant.g_monitor_vs_inte,
                                   l_sm_discontinued_cosign,
                                   l_sm_cancelled_cosign) label_order,
                            NULL dt_begin_rep,
                            NULL dt_end_rep,
                            NULL dt_monitorization_rep,
                            NULL dt_cancel_rep,
                            NULL dt_next_rep,
                            NULL dt_vs_req_rep,
                            NULL cancel_reason_desc,
                            NULL id_cancel_reason,
                            c.co_sign_notes co_sign_notes
                      FROM monitorization m
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                     INNER JOIN episode epi
                        ON m.id_episode = epi.id_episode
                     INNER JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_cancel)) c
                        ON c.id_co_sign = m.id_co_sign_cancel
                     WHERE mvs.id_monitorization_vs = i_id_monitor_vs
                          --  AND m.id_co_sign_cancel IS NOT NULL
                       AND c.id_prof_co_signed IS NOT NULL
                    UNION ALL
                    --order co-sign
                    SELECT rownum rn,
                            epi.id_episode,
                            epi.id_visit,
                            epi.id_patient,
                            NULL flg_status,
                            NULL dt_begin_tstz,
                            NULL start_time,
                            NULL end_time,
                            c.dt_co_signed dt_monitorization,
                            3 ordering,
                            NULL notes,
                            pk_alert_constant.g_monitor_vs_exec flg_status_det,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, c.id_prof_co_signed) nick_name,
                            c.desc_status desc_status,
                            NULL flg_time,
                            NULL desc_time,
                            c.dt_co_signed dt_ordering,
                            pk_date_utils.dt_chr_tsz(i_lang, c.dt_co_signed, i_prof) date_req,
                            pk_date_utils.date_char_hour_tsz(i_lang, c.dt_co_signed, i_prof.institution, i_prof.software) hour_req,
                            NULL date_begin,
                            NULL hour_begin,
                            NULL date_end,
                            NULL hour_end,
                            NULL desc_interval,
                            NULL dt_cancel,
                            NULL title_cancel,
                            NULL prof_cancel,
                            NULL notes_cancel,
                            NULL desc_speciality,
                            NULL desc_speciality_cancel,
                            NULL date_next,
                            NULL hour_next,
                            NULL desc_vs,
                            NULL prof_order,
                            NULL order_type_desc,
                            NULL dt_order,
                            NULL name_performed,
                            NULL prof_order_spec,
                            l_sm_order_cosign label_order,
                            NULL dt_begin_rep,
                            NULL dt_end_rep,
                            NULL dt_monitorization_rep,
                            NULL dt_cancel_rep,
                            NULL dt_next_rep,
                            NULL dt_vs_req_rep,
                            NULL cancel_reason_desc,
                            NULL id_cancel_reason,
                            c.co_sign_notes co_sign_notes
                      FROM monitorization m
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                     INNER JOIN episode epi
                        ON m.id_episode = epi.id_episode
                     INNER JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_order)) c
                        ON c.id_co_sign = m.id_co_sign_order
                     WHERE mvs.id_monitorization_vs = i_id_monitor_vs
                       AND c.id_prof_co_signed IS NOT NULL
                    UNION ALL
                    --Executions/cancelled/discontinued/draft
                    SELECT rownum rn,
                            epi.id_episode,
                            epi.id_visit,
                            epi.id_patient,
                            m.flg_status,
                            m.dt_begin_tstz,
                            mvsp.start_time,
                            mvsp.end_time,
                            mvsp.dt_plan_tstz dt_monitorization,
                            2 ordering,
                            pk_translation.get_translation_trs(mvs.code_notes) notes,
                            decode(mvsp.flg_status, pk_alert_constant.g_monitor_vs_canc, m.flg_status, mvsp.flg_status) AS flg_status_det,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, mvs.id_prof_cancel),
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, mvsp.id_prof_performed)) nick_name,
                            pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS', m.flg_status, i_lang) desc_status,
                            m.flg_time,
                            NULL desc_time,
                            decode(mvsp.flg_status, pk_alert_constant.g_monitor_vs_canc, mvs.dt_cancel_tstz, mvsp.end_time) dt_ordering,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   pk_date_utils.dt_chr_tsz(i_lang, mvs.dt_cancel_tstz, i_prof),
                                   pk_date_utils.dt_chr_tsz(i_lang, mvsp.end_time, i_prof)) date_req,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                                    mvs.dt_cancel_tstz,
                                                                    i_prof.institution,
                                                                    i_prof.software),
                                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                                    mvsp.start_time,
                                                                    i_prof.institution,
                                                                    i_prof.software)) hour_req,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          pk_date_utils.dt_chr_tsz(i_lang,
                                                                   nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                   i_prof),
                                          NULL)) date_begin,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                                           nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                           i_prof.institution,
                                                                           i_prof.software),
                                          NULL)) hour_begin,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          pk_date_utils.dt_chr_tsz(i_lang, m.dt_end_tstz, i_prof),
                                          NULL)) date_end,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                                           m.dt_end_tstz,
                                                                           i_prof.institution,
                                                                           i_prof.software),
                                          NULL)) hour_end,
                            get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_cancelled,
                                   pk_date_utils.date_char_tsz(i_lang,
                                                               mvs.dt_cancel_tstz,
                                                               i_prof.institution,
                                                               i_prof.software),
                                   NULL) dt_cancel,
                            decode(mvsp.flg_status, pk_alert_constant.g_cancelled, l_sm_cancel_notes, NULL) title_cancel,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_cancelled,
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, mvs.id_prof_cancel),
                                   NULL) prof_cancel,
                            mvs.notes_cancel,
                            pk_prof_utils.get_spec_signature(i_lang,
                                                             i_prof,
                                                             mvsp.id_prof_performed,
                                                             mvsp.dt_plan_tstz,
                                                             m.id_episode) desc_speciality,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_cancelled,
                                   pk_prof_utils.get_spec_signature(i_lang,
                                                                    i_prof,
                                                                    mvs.id_prof_cancel,
                                                                    m.dt_monitorization_tstz,
                                                                    m.id_episode),
                                   NULL) desc_speciality_cancel,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          NULL,
                                          pk_date_utils.dt_chr_tsz(i_lang,
                                                                   (SELECT next_dt_plan
                                                                      FROM (SELECT id_monitorization_vs_plan,
                                                                                   lead(dt_plan_tstz) over(ORDER BY dt_plan_tstz) next_dt_plan
                                                                              FROM monitorization_vs_plan
                                                                             WHERE id_monitorization_vs = i_id_monitor_vs)
                                                                     WHERE id_monitorization_vs_plan =
                                                                           mvsp.id_monitorization_vs_plan),
                                                                   i_prof))) date_next,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          NULL,
                                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                                           (SELECT next_dt_plan
                                                                              FROM (SELECT id_monitorization_vs_plan,
                                                                                           lead(dt_plan_tstz) over(ORDER BY dt_plan_tstz) next_dt_plan
                                                                                      FROM monitorization_vs_plan
                                                                                     WHERE id_monitorization_vs =
                                                                                           i_id_monitor_vs)
                                                                             WHERE id_monitorization_vs_plan =
                                                                                   mvsp.id_monitorization_vs_plan),
                                                                           i_prof.institution,
                                                                           i_prof.software))) hour_next,
                            
                            (pk_monitorization.get_vs_desc(i_lang, m.id_monitorization, i_prof) ||
                            nvl2(m.id_prev_episode,
                                  ' - (' || pk_message.get_message(i_lang,
                                                                   profissional(i_prof.id,
                                                                                i_prof.institution,
                                                                                pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                                   FROM episode e
                                                                                                                  WHERE e.id_episode =
                                                                                                                        m.id_prev_episode),
                                                                                                                 i_prof.institution)),
                                                                   'IMAGE_T009') || ')',
                                  '')) desc_vs,
                            decode(mvsp.flg_status, pk_alert_constant.g_monitor_vs_canc, c.desc_prof_ordered_by, NULL) prof_order,
                            decode(mvsp.flg_status, pk_alert_constant.g_monitor_vs_canc, c.desc_order_type, NULL) order_type_desc,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   
                                   pk_date_utils.date_char_tsz(i_lang, c.dt_ordered_by, i_prof.institution, i_prof.software),
                                   NULL) dt_order,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   pk_tools.get_prof_speciality(i_lang, mvs.id_prof_order),
                                   NULL) prof_order_spec,
                            NULL name_performed,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_fini,
                                   l_sm_execution,
                                   pk_alert_constant.g_monitor_vs_pend,
                                   l_sm_pending,
                                   pk_alert_constant.g_monitor_vs_exec,
                                   l_sm_pending,
                                   pk_alert_constant.g_monitor_vs_draft,
                                   l_sm_draft,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   decode(mvs.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          l_sm_cancelled,
                                          pk_alert_constant.g_monitor_vs_inte,
                                          l_sm_discontinued)) label_order,
                            pk_date_utils.date_char_tsz(i_lang, m.dt_begin_tstz, i_prof.institution, i_prof.software) dt_begin_rep,
                            pk_date_utils.date_char_tsz(i_lang, m.dt_end_tstz, i_prof.institution, i_prof.software) dt_end_rep,
                            pk_date_utils.date_char_tsz(i_lang,
                                                        m.dt_monitorization_tstz,
                                                        i_prof.institution,
                                                        i_prof.software) dt_monitorization_rep,
                            pk_date_utils.date_char_tsz(i_lang, mvs.dt_cancel_tstz, i_prof.institution, i_prof.software) dt_cancel_rep,
                            pk_date_utils.date_char_tsz(i_lang, mvsp.dt_plan_tstz, i_prof.institution, i_prof.software) dt_next_rep,
                            pk_date_utils.date_char_tsz(i_lang,
                                                        mvs.dt_monitorization_vs_tstz,
                                                        i_prof.institution,
                                                        i_prof.software) dt_vs_req_rep,
                            decode(mvs.id_cancel_reason,
                                   NULL,
                                   NULL,
                                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, mvs.id_cancel_reason)) cancel_reason_desc,
                            mvs.id_cancel_reason,
                            NULL co_sign_notes
                      FROM monitorization m
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                     INNER JOIN monitorization_vs_plan mvsp
                        ON mvs.id_monitorization_vs = mvsp.id_monitorization_vs
                      LEFT JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_cancel)) c
                        ON c.id_co_sign = m.id_co_sign_cancel
                     INNER JOIN episode epi
                        ON m.id_episode = epi.id_episode
                     WHERE mvs.id_monitorization_vs = i_id_monitor_vs
                       AND mvsp.flg_status NOT IN (pk_alert_constant.g_monitor_vs_pend,
                                                   pk_alert_constant.g_monitor_vs_exec,
                                                   pk_alert_constant.g_monitor_vs_expire)
                    UNION ALL
                    --Order
                    SELECT *
                      FROM (SELECT row_number() over(PARTITION BY mvsp.id_monitorization_vs ORDER BY mvsp.id_monitorization_vs_plan) rn,
                                    epi.id_episode,
                                    epi.id_visit,
                                    epi.id_patient,
                                    m.flg_status,
                                    m.dt_begin_tstz,
                                    mvsp.start_time,
                                    mvsp.end_time,
                                    m.dt_monitorization_tstz dt_monitorization,
                                    1 ordering,
                                    pk_translation.get_translation_trs(mvs.code_notes) notes,
                                    pk_alert_constant.g_monitor_vs_exec AS flg_status_det,
                                    pk_prof_utils.get_name_signature(i_lang, i_prof, m.id_professional) nick_name,
                                    pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS', m.flg_status, i_lang) desc_status,
                                    m.flg_time,
                                    pk_sysdomain.get_domain('MONITORIZATION.FLG_TIME', m.flg_time, i_lang) desc_time,
                                    mvs.dt_monitorization_vs_tstz dt_ordering,
                                    pk_date_utils.dt_chr_tsz(i_lang, mvs.dt_monitorization_vs_tstz, i_prof) date_req,
                                    pk_date_utils.date_char_hour_tsz(i_lang,
                                                                     mvs.dt_monitorization_vs_tstz,
                                                                     i_prof.institution,
                                                                     i_prof.software) hour_req,
                                    decode(m.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           pk_date_utils.dt_chr_tsz(i_lang,
                                                                    nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                    i_prof)) date_begin,
                                    decode(m.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           pk_date_utils.date_char_hour_tsz(i_lang,
                                                                            nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                            i_prof.institution,
                                                                            i_prof.software)) hour_begin,
                                    decode(m.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           pk_date_utils.dt_chr_tsz(i_lang, m.dt_end_tstz, i_prof)) date_end,
                                    decode(m.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           pk_date_utils.date_char_hour_tsz(i_lang,
                                                                            m.dt_end_tstz,
                                                                            i_prof.institution,
                                                                            i_prof.software)) hour_end,
                                    get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                mvs.dt_cancel_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_cancel,
                                    decode(mvs.flg_status, pk_alert_constant.g_monitor_vs_canc, l_sm_cancel_notes, '') title_cancel,
                                    pk_prof_utils.get_name_signature(i_lang, i_prof, mvs.id_prof_cancel) prof_cancel,
                                    mvs.notes_cancel,
                                    pk_prof_utils.get_spec_signature(i_lang,
                                                                     i_prof,
                                                                     m.id_professional,
                                                                     m.dt_monitorization_tstz,
                                                                     m.id_episode) desc_speciality,
                                    pk_prof_utils.get_spec_signature(i_lang,
                                                                     i_prof,
                                                                     mvs.id_prof_cancel,
                                                                     m.dt_monitorization_tstz,
                                                                     m.id_episode) desc_speciality_cancel,
                                    NULL date_next,
                                    NULL hour_next,
                                    (pk_monitorization.get_vs_desc(i_lang, m.id_monitorization, i_prof) ||
                                    nvl2(m.id_prev_episode,
                                          ' - (' || pk_message.get_message(i_lang,
                                                                           profissional(i_prof.id,
                                                                                        i_prof.institution,
                                                                                        pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                                           FROM episode e
                                                                                                                          WHERE e.id_episode =
                                                                                                                                m.id_prev_episode),
                                                                                                                         i_prof.institution)),
                                                                           'IMAGE_T009') || ')',
                                          '')) desc_vs,
                                    c.desc_prof_ordered_by prof_order,
                                    c.desc_order_type order_type_desc,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                c.dt_ordered_by,
                                                                i_prof.institution,
                                                                i_prof.software) dt_order,
                                    pk_prof_utils.get_name_signature(i_lang, i_prof, mvsp.id_prof_performed) name_performed,
                                    pk_tools.get_prof_speciality(i_lang, c.id_prof_ordered_by) prof_order_spec,
                                    l_sm_order label_order,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                m.dt_begin_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_begin_rep,
                                    pk_date_utils.date_char_tsz(i_lang, m.dt_end_tstz, i_prof.institution, i_prof.software) dt_end_rep,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                m.dt_monitorization_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_monitorization_rep,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                mvs.dt_cancel_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_cancel_rep,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                mvsp.dt_plan_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_next_rep,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                mvs.dt_monitorization_vs_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_vs_req_rep,
                                    decode(mvs.id_cancel_reason,
                                           NULL,
                                           NULL,
                                           pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, mvs.id_cancel_reason)) cancel_reason_desc,
                                    mvs.id_cancel_reason,
                                    NULL co_sign_notes
                               FROM monitorization m
                              INNER JOIN monitorization_vs mvs
                                 ON m.id_monitorization = mvs.id_monitorization
                              INNER JOIN monitorization_vs_plan mvsp
                                 ON mvs.id_monitorization_vs = mvsp.id_monitorization_vs
                               LEFT JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_order)) c
                                 ON c.id_co_sign = m.id_co_sign_order
                              INNER JOIN episode epi
                                 ON m.id_episode = epi.id_episode
                              WHERE mvs.id_monitorization_vs = i_id_monitor_vs)
                     WHERE rn = 1) t
             WHERE t.id_episode = nvl(l_id_episode, t.id_episode)
               AND t.id_visit = nvl(l_id_visit, t.id_visit)
               AND t.id_patient = nvl(l_id_patient, t.id_patient)
               AND (
                   --not report gets all
                    i_flg_report = pk_alert_constant.g_no OR
                   --
                    (
                    --if report
                     i_flg_report = pk_alert_constant.g_yes
                    --
                     AND
                    --
                     (
                     --shows canceled monitorizations or not whether flag i_cancelled
                      (i_cancelled = pk_alert_constant.g_no AND t.flg_status <> pk_alert_constant.g_monitor_vs_canc) OR
                      i_cancelled = pk_alert_constant.g_yes
                     --
                     )
                    --
                     AND
                    --
                     (
                     --shows monitorizations or not whether flag i_crit_type and the dates (i_start_date and i_end_date)
                     --Shows all the monitorizations where the req and exec was performed in the period
                      (i_crit_type = g_monit_crit_type_all_a AND
                      (t.dt_begin_tstz BETWEEN nvl(l_start_date, t.dt_begin_tstz) AND nvl(l_end_date, t.dt_begin_tstz) OR
                      (t.start_time BETWEEN nvl(l_start_date, t.start_time) AND nvl(l_end_date, t.start_time) AND
                      t.end_time BETWEEN nvl(l_start_date, t.end_time) AND nvl(l_end_date, t.end_time))))
                     --
                      OR
                     --Shows the monitorizations that where req in the period
                      (i_crit_type = g_monit_crit_type_req_r AND
                      t.dt_begin_tstz BETWEEN nvl(l_start_date, t.dt_begin_tstz) AND nvl(l_end_date, t.dt_begin_tstz))
                     --
                      OR
                     --Shows the monitorizations that where exec in the period
                      (i_crit_type = g_monit_crit_type_exec_e AND t.start_time BETWEEN nvl(l_start_date, t.start_time) AND
                      nvl(l_end_date, t.start_time) AND t.end_time BETWEEN nvl(l_start_date, t.end_time) AND
                      nvl(l_end_date, t.end_time))
                     --
                     )
                    --
                    )
                   --
                   )
             ORDER BY dt_ordering DESC, t.hour_req DESC, t.ordering DESC; -- as only the first row of the cursor is used on UX layer, 
        -- this allows considering the rows different from 'F' first
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_VS_REQ',
                                              o_error);
            pk_types.open_my_cursor(o_monitor);
            RETURN FALSE;
    END get_monitor_vs_req;

    /**********************************************************************************************
    * Resultados de monitorizações
    *
    * @param i_lang                   the id language
    * @param i_id_monitorization_vs   Id do plano da monitorização
    * @param i_monitorization_vs_plan Id do plano da monitorização a detalhar
    * @param i_prof                   professional, software and institution ids
    * @param o_monitor                array com o detalhe da monitorização
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Paulo Fonseca
    * @version                        2.5.0
    * @since                          2009/04/29
    **********************************************************************************************/
    FUNCTION get_monitor_vs_result
    (
        i_lang                   IN language.id_language%TYPE,
        i_id_monitorization_vs   IN monitorization_vs.id_monitorization_vs%TYPE,
        i_monitorization_vs_plan IN monitorization_vs_plan.id_monitorization_vs_plan%TYPE,
        i_prof                   IN profissional,
        o_monitor                OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message              debug_msg;
        l_id_monitorization_vs monitorization_vs.id_monitorization_vs%TYPE;
    
    BEGIN
        l_message := 'GET ID_MONITORIZATION_VS';
        IF i_id_monitorization_vs IS NULL
        THEN
            SELECT id_monitorization_vs
              INTO l_id_monitorization_vs
              FROM monitorization_vs_plan
             WHERE id_monitorization_vs_plan = i_monitorization_vs_plan;
        ELSE
            l_id_monitorization_vs := i_id_monitorization_vs;
        END IF;
    
        l_message := 'OPEN O_MONITOR';
        OPEN o_monitor FOR
            SELECT pk_date_utils.dt_chr_tsz(i_lang, dt_plan_tstz, i_prof) date_target,
                   pk_date_utils.date_char_hour_tsz(i_lang, dt_plan_tstz, i_prof.institution, i_prof.software) hour_target,
                   id_vital_sign_read,
                   id_vital_sign,
                   flg_state,
                   id_prof_read id_professional,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, id_prof_read, dt_vital_sign_read_tstz, id_episode) prof_read_speciality,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_read) prof_read,
                   pk_date_utils.date_send_tsz(i_lang, dt_vital_sign_read_tstz, i_prof.institution, i_prof.software) dt_vital_sign_read,
                   pk_date_utils.dt_chr_tsz(i_lang, dt_vital_sign_read_tstz, i_prof) dt_target,
                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                    dt_vital_sign_read_tstz,
                                                    i_prof.institution,
                                                    i_prof.software) hr_target,
                   pk_translation.get_translation(i_lang, code_vital_sign) desc_vs,
                   VALUE || ' ' ||
                   pk_vital_sign.get_vital_sign_unit_measure(i_lang, id_unit_measure, id_vs_scales_element) VALUE,
                   pk_vital_sign.get_vs_scale_shortdesc(i_lang, id_vs_scales_element) scale_desc,
                   pk_sysdomain.get_rank(i_lang, 'VITAL_SIGN_READ.FLG_STATE', flg_state) rank,
                   pk_sysdomain.get_domain('VITAL_SIGN_READ.FLG_STATE', flg_state, i_lang) desc_status,
                   pk_date_utils.dt_chr_tsz(i_lang, dt_cancel_tstz, i_prof) date_status,
                   pk_date_utils.date_char_hour_tsz(i_lang, dt_cancel_tstz, i_prof.institution, i_prof.software) hour_status,
                   flg_status,
                   decode(flg_state, pk_alert_constant.g_cancelled, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_cancel,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, id_prof_cancel, dt_cancel_tstz, id_episode) prof_cancel_speciality,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_cancel) prof_cancel,
                   pk_date_utils.dt_chr_tsz(i_lang, dt_cancel_tstz, i_prof) date_cancel_target,
                   pk_date_utils.date_char_hour_tsz(i_lang, dt_cancel_tstz, i_prof.institution, i_prof.software) hour_cancel_target,
                   pk_date_utils.to_char_insttimezone(i_prof, dt_plan_tstz, 'YYYYMMDDHH24MISS') dt_ord1,
                   pk_date_utils.to_char_insttimezone(i_prof, dt_vital_sign_read_tstz, 'YYYYMMDDHH24MISS') dt_ord2,
                   pk_date_utils.to_char_insttimezone(i_prof, dt_cancel_tstz, 'YYYYMMDDHH24MISS') dt_ord3,
                   id_monitorization_vs_plan,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_performed) name_performed,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    id_prof_performed,
                                                    dt_monitorization_tstz,
                                                    id_episode) prof_performed_speciality,
                   pk_date_utils.date_send_tsz(i_lang, start_time, i_prof) start_time_send,
                   pk_date_utils.date_char_tsz(i_lang, start_time, i_prof.institution, i_prof.software) start_time_char,
                   pk_date_utils.date_send_tsz(i_lang, end_time, i_prof) end_time_send,
                   pk_date_utils.date_char_tsz(i_lang, end_time, i_prof.institution, i_prof.software) end_time_char,
                   notes_cancel,
                   id_cancel_reason,
                   decode(id_cancel_reason,
                          NULL,
                          NULL,
                          pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, id_cancel_reason)) desc_cancel_reason,
                   CASE
                        WHEN flg_status_monit IN (pk_alert_constant.g_monitor_vs_expire,
                                                  pk_alert_constant.g_monitor_vs_canc,
                                                  pk_alert_constant.g_monitor_vs_inte,
                                                  pk_alert_constant.g_monitor_vs_fini) THEN
                         pk_alert_constant.g_no
                        WHEN flg_state = pk_alert_constant.g_cancelled THEN
                         pk_alert_constant.g_no
                        WHEN flg_status = pk_alert_constant.g_monitor_vs_fini THEN
                         pk_alert_constant.g_no
                        WHEN i_prof.id = id_prof_read THEN
                         pk_alert_constant.g_yes
                        ELSE
                         pk_alert_constant.g_no
                    END flg_cancel_but
              FROM (
                    -- Glasgow Total's
                     SELECT mvsp.dt_plan_tstz,
                             (SELECT vsri.id_vital_sign_read
                                FROM vital_sign_read vsri
                               WHERE vsri.id_monitorization_vs_plan = mvsp.id_monitorization_vs_plan
                                 AND pk_delivery.check_vs_read_from_fetus(vsri.id_vital_sign_read) = 0
                                 AND rownum = 1) id_vital_sign_read,
                             mvs.id_vital_sign,
                             NULL id_unit_measure,
                             vsr.flg_state,
                             vsr.id_prof_read,
                             vsr.dt_vital_sign_read_tstz,
                             vs.code_vital_sign,
                             to_char(SUM(vsd.value)) VALUE,
                             NULL id_vs_scales_element,
                             vsr.dt_cancel_tstz,
                             mvs.flg_status,
                             vsr.id_prof_cancel,
                             mvsp.id_monitorization_vs_plan,
                             mvsp.id_prof_performed,
                             m.dt_monitorization_tstz,
                             m.id_episode,
                             mvsp.start_time,
                             mvsp.end_time,
                             vsr.notes_cancel,
                             vsr.id_cancel_reason,
                             m.flg_status flg_status_monit
                       FROM monitorization_vs_plan mvsp
                      INNER JOIN vital_sign_read vsr
                         ON mvsp.id_monitorization_vs_plan = vsr.id_monitorization_vs_plan
                      INNER JOIN monitorization_vs mvs
                         ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                      INNER JOIN monitorization m
                         ON mvs.id_monitorization = m.id_monitorization
                      INNER JOIN vital_sign vs
                         ON mvs.id_vital_sign = vs.id_vital_sign
                      INNER JOIN vital_sign_desc vsd
                         ON vsr.id_vital_sign_desc = vsd.id_vital_sign_desc
                      WHERE mvsp.id_monitorization_vs = l_id_monitorization_vs
                        AND (i_monitorization_vs_plan IS NULL OR mvsp.id_monitorization_vs_plan = i_monitorization_vs_plan)
                        AND mvsp.flg_status NOT IN
                            (pk_alert_constant.g_monitor_vs_pend, pk_alert_constant.g_monitor_vs_exec)
                        AND EXISTS (SELECT 1
                               FROM vital_sign_relation vsrl
                              WHERE vs.id_vital_sign = vsrl.id_vital_sign_parent
                                AND vsrl.relation_domain = pk_alert_constant.g_vs_rel_sum)
                        AND pk_delivery.check_vs_read_from_fetus(vsr.id_vital_sign_read) = 0
                      GROUP BY mvsp.dt_plan_tstz,
                                mvs.id_vital_sign,
                                vsr.flg_state,
                                vsr.id_prof_read,
                                vsr.dt_vital_sign_read_tstz,
                                vs.code_vital_sign,
                                --vs.code_measure_unit,
                                vsr.dt_cancel_tstz,
                                mvs.flg_status,
                                vsr.id_prof_cancel,
                                mvsp.id_monitorization_vs_plan,
                                mvsp.id_prof_performed,
                                m.dt_monitorization_tstz,
                                m.id_episode,
                                mvsp.start_time,
                                mvsp.end_time,
                                vsr.notes_cancel,
                                vsr.id_cancel_reason,
                                m.flg_status
                     UNION -- Blood Pressure's
                    SELECT mvsp.dt_plan_tstz,
                            vsr.id_vital_sign_read,
                            mvs.id_vital_sign,
                            vsr.id_unit_measure,
                            vsr.flg_state,
                            vsr.id_prof_read,
                            vsr.dt_vital_sign_read_tstz,
                            vs.code_vital_sign,
                            vsr.value || '/' ||
                            (SELECT vsr1.value
                               FROM vital_sign_read vsr1
                              INNER JOIN monitorization_vs_plan mp1
                                 ON vsr1.id_monitorization_vs_plan = mp1.id_monitorization_vs_plan
                              INNER JOIN vital_sign_relation vsrn1
                                 ON vsr1.id_vital_sign = vsrn1.id_vital_sign_detail
                              WHERE mp1.id_monitorization_vs = mvsp.id_monitorization_vs
                                AND mp1.id_monitorization_vs_plan = mvsp.id_monitorization_vs_plan
                                AND mp1.flg_status NOT IN
                                    (pk_alert_constant.g_monitor_vs_pend, pk_alert_constant.g_monitor_vs_exec)
                                AND vsrn1.relation_domain = pk_alert_constant.g_vs_rel_conc
                                AND vsrn1.rank =
                                    (SELECT MAX(vsrlmax.rank)
                                       FROM vital_sign_relation vsrlmax
                                      WHERE mvs.id_vital_sign = vsrlmax.id_vital_sign_parent
                                        AND vsrlmax.relation_domain = pk_alert_constant.g_vs_rel_conc)
                                AND pk_delivery.check_vs_read_from_fetus(vsr1.id_vital_sign_read) = 0) VALUE,
                            NULL id_vs_scales_element,
                            vsr.dt_cancel_tstz,
                            mvs.flg_status,
                            vsr.id_prof_cancel,
                            mvsp.id_monitorization_vs_plan,
                            mvsp.id_prof_performed,
                            m.dt_monitorization_tstz,
                            m.id_episode,
                            mvsp.start_time,
                            mvsp.end_time,
                            vsr.notes_cancel,
                            vsr.id_cancel_reason,
                            m.flg_status
                      FROM monitorization_vs_plan mvsp
                     INNER JOIN vital_sign_read vsr
                        ON mvsp.id_monitorization_vs_plan = vsr.id_monitorization_vs_plan
                     INNER JOIN monitorization_vs mvs
                        ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                     INNER JOIN monitorization m
                        ON mvs.id_monitorization = m.id_monitorization
                     INNER JOIN vital_sign vs
                        ON vsr.id_vital_sign = vs.id_vital_sign
                     INNER JOIN vital_sign_relation vsrl
                        ON vs.id_vital_sign = vsrl.id_vital_sign_detail
                     WHERE mvsp.id_monitorization_vs = l_id_monitorization_vs
                       AND (i_monitorization_vs_plan IS NULL OR mvsp.id_monitorization_vs_plan = i_monitorization_vs_plan)
                       AND mvsp.flg_status NOT IN
                           (pk_alert_constant.g_monitor_vs_pend, pk_alert_constant.g_monitor_vs_exec)
                       AND vsrl.relation_domain = pk_alert_constant.g_vs_rel_conc
                       AND vsrl.rank = (SELECT MIN(vsrlmin.rank)
                                          FROM vital_sign_relation vsrlmin
                                         WHERE mvs.id_vital_sign = vsrlmin.id_vital_sign_parent
                                           AND vsrlmin.relation_domain = pk_alert_constant.g_vs_rel_conc)
                       AND pk_delivery.check_vs_read_from_fetus(vsr.id_vital_sign_read) = 0
                    UNION -- Everything else
                    SELECT mvsp.dt_plan_tstz,
                            vsr.id_vital_sign_read,
                            vsr.id_vital_sign,
                            vsr.id_unit_measure,
                            vsr.flg_state,
                            vsr.id_prof_read,
                            vsr.dt_vital_sign_read_tstz,
                            vs.code_vital_sign,
                            decode(vs.flg_fill_type,
                                   pk_alert_constant.g_vs_ft_multichoice,
                                   pk_vital_sign.get_vs_alias(i_lang, vsr.id_patient, vsd.code_vital_sign_desc),
                                   to_char(vsr.value)) VALUE,
                            vsr.id_vs_scales_element,
                            vsr.dt_cancel_tstz,
                            mvs.flg_status,
                            vsr.id_prof_cancel,
                            mvsp.id_monitorization_vs_plan,
                            mvsp.id_prof_performed,
                            m.dt_monitorization_tstz,
                            m.id_episode,
                            mvsp.start_time,
                            mvsp.end_time,
                            vsr.notes_cancel,
                            vsr.id_cancel_reason,
                            m.flg_status flg_status_monit
                      FROM monitorization_vs_plan mvsp
                     INNER JOIN vital_sign_read vsr
                        ON mvsp.id_monitorization_vs_plan = vsr.id_monitorization_vs_plan
                     INNER JOIN monitorization_vs mvs
                        ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                     INNER JOIN monitorization m
                        ON mvs.id_monitorization = m.id_monitorization
                     INNER JOIN vital_sign vs
                        ON vsr.id_vital_sign = vs.id_vital_sign
                      LEFT JOIN vital_sign_desc vsd
                        ON vsr.id_vital_sign_desc = vsd.id_vital_sign_desc
                     WHERE mvsp.id_monitorization_vs = l_id_monitorization_vs
                       AND (i_monitorization_vs_plan IS NULL OR mvsp.id_monitorization_vs_plan = i_monitorization_vs_plan)
                       AND mvsp.flg_status NOT IN
                           (pk_alert_constant.g_monitor_vs_pend, pk_alert_constant.g_monitor_vs_exec)
                       AND NOT EXISTS (SELECT 1
                              FROM vital_sign_relation vsrl
                             WHERE vs.id_vital_sign = vsrl.id_vital_sign_detail
                               AND vsrl.relation_domain IN
                                   (pk_alert_constant.g_vs_rel_conc, pk_alert_constant.g_vs_rel_sum))
                       AND pk_delivery.check_vs_read_from_fetus(vsr.id_vital_sign_read) = 0)
             ORDER BY rank, dt_vital_sign_read DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => l_message,
                                              i_owner    => c_package_owner,
                                              i_package  => c_package_name,
                                              i_function => 'GET_MONITOR_VS_RESULTS',
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_monitor);
            RETURN FALSE;
    END get_monitor_vs_result;

    /******************************************************************************
       OBJECTIVO:   Obter leituras de sinais vitais pedidos numa monitorização
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION_VS - ID do detalhe da requisição.
              Saida:   O_MONITOR -  lista de detalhes de requisições
                 O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      CORRECÇÕES: CRS 2005/06/06
      NOTAS:
    *********************************************************************************/
    FUNCTION get_monitor_vs_result
    (
        i_lang                 IN language.id_language%TYPE,
        i_id_monitorization_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_prof                 IN profissional,
        o_monitor              OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN get_monitor_vs_result(i_lang                   => i_lang,
                                     i_id_monitorization_vs   => i_id_monitorization_vs,
                                     i_monitorization_vs_plan => NULL,
                                     i_prof                   => i_prof,
                                     o_monitor                => o_monitor,
                                     o_error                  => o_error);
    END get_monitor_vs_result;

    /**********************************************************************************************
    * Detalhe de cada resultado da monitorização
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_monitorization_vs_plan Id do plano da monitorização a detalhar
    * @param o_monitor_det            array com o detalhe da monitorização
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2007/10/16
    **********************************************************************************************/
    FUNCTION get_monitor_vs_result_det
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_monitorization_vs_plan IN monitorization_vs_plan.id_monitorization_vs_plan%TYPE,
        o_monitor_det            OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN get_monitor_vs_result(i_lang                   => i_lang,
                                     i_id_monitorization_vs   => NULL,
                                     i_monitorization_vs_plan => i_monitorization_vs_plan,
                                     i_prof                   => i_prof,
                                     o_monitor                => o_monitor_det,
                                     o_error                  => o_error);
    END get_monitor_vs_result_det;

    /******************************************************************************
       OBJECTIVO: Obter os SVs requisitados na monitorização indicada
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION - ID da requisicao
              Saida:  O_ERROR - erro
    
      CRIAÇÃO: CRS 2005/07/29
      NOTAS: FLG_MONITOR - Y - SV pedido na monitorização
                   N - SV ñ pedido
    *********************************************************************************/
    FUNCTION get_vs_monitor
    (
        i_lang              IN language.id_language%TYPE,
        i_id_monitorization IN monitorization_vs.id_monitorization%TYPE,
        i_prof              IN profissional,
        o_vs                OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
    BEGIN
        l_message := 'GET CURSOR';
        OPEN o_vs FOR
            SELECT DISTINCT vs.id_vital_sign,
                            vs.rank rank_show,
                            decode(nvl(mvs.id_monitorization_vs, 0),
                                   0, -- SV ñ foi pedido
                                   -- Total Glasgow é pai do SV corrente e foi pedido p/ monitorização
                                   decode(nvl(vr_det.id_vital_sign_parent, 0),
                                          aux.id_vital_sign,
                                          pk_alert_constant.g_yes,
                                          pk_alert_constant.g_no),
                                   decode(vr_par.relation_domain,
                                          pk_alert_constant.g_vs_rel_sum,
                                          pk_alert_constant.g_no,
                                          pk_alert_constant.g_yes)) flg_monitor, -- SV pedido
                            decode(nvl(mvs.id_monitorization_vs, 0),
                                   0, -- SV ñ foi pedido
                                   -- Total Glasgow é pai do SV corrente e foi pedido p/ monitorização
                                   decode(nvl(vr_det.id_vital_sign_parent, 0),
                                          aux.id_vital_sign,
                                          pk_alert_constant.g_yes,
                                          pk_alert_constant.g_no),
                                   decode(vr_par.relation_domain,
                                          pk_alert_constant.g_vs_rel_sum,
                                          pk_alert_constant.g_no,
                                          pk_alert_constant.g_yes)) flg_wizard,
                            vs.flg_show,
                            vr_det.id_vital_sign_parent,
                            decode(nvl(vr_det.id_vital_sign_relation, 0), 0, '', pk_alert_constant.g_vs_rel_sum) relation_type,
                            decode(nvl(vr_par.id_vital_sign_relation, 0), 0, vs.flg_fill_type, 'X') flg_fill_type,
                            decode(nvl(vr_det.id_vital_sign_relation, 0),
                                   0,
                                   pk_alert_constant.g_no,
                                   pk_alert_constant.g_yes) flg_sum,
                            0 rank_conc,
                            pk_translation.get_translation(i_lang, vs.code_vital_sign) name_vs
              FROM vital_sign          vs,
                   vital_sign_relation vr_par,
                   vital_sign_relation vr_det,
                   monitorization_vs   mvs,
                   vs_clin_serv        vcs,
                   -- tabela AUX só retorna valores se Total Glasgow foi pedido na monitorização
                   (SELECT DISTINCT mvs1.id_vital_sign, mvs1.id_monitorization
                      FROM monitorization_vs mvs1, vital_sign_relation vr_par1
                     WHERE mvs1.id_monitorization = i_id_monitorization
                       AND mvs1.flg_status != pk_alert_constant.g_monitor_vs_canc
                       AND vr_par1.id_vital_sign_parent = mvs1.id_vital_sign
                       AND vr_par1.relation_domain = pk_alert_constant.g_vs_rel_sum) aux
             WHERE vs.flg_available = pk_alert_constant.g_yes
               AND vs.flg_show = pk_alert_constant.g_yes
               AND vr_par.id_vital_sign_parent(+) = vs.id_vital_sign
               AND vr_par.relation_domain(+) = pk_alert_constant.g_vs_rel_sum -- Glasgow
               AND vr_det.id_vital_sign_detail(+) = vs.id_vital_sign
               AND vr_det.relation_domain(+) = pk_alert_constant.g_vs_rel_sum
               AND mvs.id_monitorization(+) = i_id_monitorization
               AND mvs.flg_status(+) != pk_alert_constant.g_monitor_vs_canc
               AND vs.id_vital_sign = mvs.id_vital_sign(+)
               AND vcs.id_vital_sign = vs.id_vital_sign
               AND vcs.id_software = i_prof.software
               AND aux.id_vital_sign(+) = vr_det.id_vital_sign_parent
            UNION
            SELECT DISTINCT vs.id_vital_sign,
                            vs.rank rank_show,
                            decode(nvl(mvs.id_monitorization_vs, 0), 0, pk_alert_constant.g_no, pk_alert_constant.g_yes) flg_monitor,
                            decode(nvl(mvs.id_monitorization_vs, 0), 0, pk_alert_constant.g_no, pk_alert_constant.g_yes) flg_wizard,
                            vs.flg_show,
                            vr_conc.id_vital_sign_parent,
                            pk_alert_constant.g_vs_rel_conc relation_type,
                            vs.flg_fill_type,
                            pk_alert_constant.g_no flg_sum,
                            vr_conc.rank rank_conc,
                            pk_translation.get_translation(i_lang, vs.code_vital_sign) name_vs
              FROM vital_sign vs, vital_sign_relation vr_conc, monitorization_vs mvs
             WHERE vs.flg_available = pk_alert_constant.g_yes
               AND vr_conc.id_vital_sign_detail = vs.id_vital_sign
               AND vr_conc.relation_domain = pk_alert_constant.g_vs_rel_conc -- Pressão arterial
               AND mvs.id_monitorization(+) = i_id_monitorization
               AND mvs.flg_status(+) != pk_alert_constant.g_monitor_vs_canc
               AND vs.id_vital_sign = mvs.id_vital_sign(+)
             ORDER BY rank_show, name_vs;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_VS_MONITOR',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_vs);
            RETURN FALSE;
    END get_vs_monitor;

    /**********************************************************************************************
    * initialize the monit type
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_id_monitorization      monitorization id 
    * @param       io_monit                 monitorization type
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/20
    **********************************************************************************************/
    FUNCTION init_monit
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_monitorization    IN monitorization.id_monitorization%TYPE,
        io_monit               IN OUT NOCOPY monit,
        i_draft                IN VARCHAR2 DEFAULT 'N',
        i_task_start_timestamp IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message            debug_msg;
        l_id_order_type      co_sign.id_order_type%TYPE;
        l_init_dft_tstz      monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_monitorization_row monitorization%ROWTYPE;
    BEGIN
        l_message := 'PK_MONITORIZATION.INIT_MONIT - get monitorization';
    
        IF i_draft = pk_alert_constant.g_no
        THEN
            SELECT m.*
              INTO l_monitorization_row
              FROM monitorization m
             WHERE m.id_monitorization = i_id_monitorization;
        
            IF i_task_start_timestamp IS NOT NULL
            THEN
                l_init_dft_tstz := i_task_start_timestamp;
            END IF;
        ELSE
            SELECT m.*
              INTO l_monitorization_row
              FROM monitorization m
             WHERE m.id_monitorization = i_id_monitorization;
        
            IF i_task_start_timestamp IS NOT NULL
            THEN
                l_init_dft_tstz := i_task_start_timestamp;
            ELSE
                BEGIN
                    SELECT t.dt_plan_tstz
                      INTO l_init_dft_tstz
                      FROM (SELECT DISTINCT mvsp.dt_plan_tstz
                            
                              FROM monitorization m
                              JOIN monitorization_vs mvs
                                ON m.id_monitorization = mvs.id_monitorization
                              JOIN monitorization_vs_plan mvsp
                                ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                               AND mvsp.flg_status = pk_monitorization.g_monit_vs_plan_final
                             WHERE m.id_monitorization = i_id_monitorization
                             ORDER BY mvsp.dt_plan_tstz DESC NULLS LAST) t
                     WHERE rownum = 1;
                EXCEPTION
                    WHEN no_data_found THEN
                        BEGIN
                            SELECT DISTINCT mvsp.dt_plan_tstz
                              INTO l_init_dft_tstz
                              FROM monitorization m
                              JOIN monitorization_vs mvs
                                ON m.id_monitorization = mvs.id_monitorization
                              JOIN monitorization_vs_plan mvsp
                                ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                               AND mvsp.flg_status = pk_monitorization.g_monit_vs_plan_ongoing
                             WHERE m.id_monitorization = i_id_monitorization;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_init_dft_tstz := NULL;
                        END;
                END;
            END IF;
        END IF;
    
        l_message := 'PK_MONITORIZATION.INIT_MONIT - get id_order_type';
        BEGIN
            SELECT c.id_order_type
              INTO l_id_order_type
              FROM co_sign c
             WHERE c.id_co_sign = l_monitorization_row.id_co_sign_order;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_order_type := NULL;
        END;
    
        io_monit := monit(id_co_sign_order          => l_monitorization_row.id_co_sign_order,
                          id_co_sign_cancel         => l_monitorization_row.id_co_sign_cancel,
                          id_monit                  => l_monitorization_row.id_monitorization,
                          id_prof                   => i_prof.id,
                          id_inst                   => i_prof.institution,
                          id_soft                   => i_prof.software,
                          id_epis                   => l_monitorization_row.id_episode,
                          dt_order_str              => get_str_date(i_lang,
                                                                    i_prof,
                                                                    nvl(l_init_dft_tstz,
                                                                        l_monitorization_row.dt_monitorization_tstz)),
                          dt_begin_str              => get_str_date(i_lang,
                                                                    i_prof,
                                                                    nvl(l_init_dft_tstz,
                                                                        l_monitorization_row.dt_begin_tstz)),
                          dt_end_str                => get_str_date(i_lang, i_prof, l_monitorization_row.dt_end_tstz),
                          dt_begin_final_str        => get_str_date(i_lang,
                                                                    i_prof,
                                                                    nvl(l_init_dft_tstz,
                                                                        l_monitorization_row.dt_begin_tstz)),
                          notes                     => pk_translation.get_translation_trs(l_monitorization_row.code_notes),
                          flg_time                  => l_monitorization_row.flg_time,
                          INTERVAL                  => NULL,
                          interval_final            => l_monitorization_row.interval,
                          id_vs                     => table_number(),
                          notes_detail              => NULL,
                          flg_status                => l_monitorization_row.flg_status,
                          flg_status_det            => l_monitorization_row.flg_status,
                          id_order_type             => l_id_order_type,
                          id_prof_order             => NULL,
                          flg_monitorization_action => pk_monitorization.g_order_action);
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'INIT_MONIT',
                                              o_error);
            RETURN FALSE;
    END init_monit;

    /******************************************************************************
       OBJECTIVO:   Cancelar requisição de monitorização de sinais vitais
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION  - ID da requisicao
                     I_PROF - Profissional que faz o cancelamento
                 I_NOTES - Notas de cancelamento
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           como é retornada em PK_LOGIN.GET_PROF_PREF
                  I_COMMIT_DATA - Flag que indica se a função deve fazer o commit dos dados
              Saida:  O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
    *********************************************************************************/
    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_prof              IN profissional,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_commit_data       IN VARCHAR2,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message     debug_msg;
        l_old_status  monitorization.flg_status%TYPE;
        l_episode     monitorization.id_episode%TYPE;
        l_commit_data BOOLEAN;
        l_char        VARCHAR2(1);
        l_found       BOOLEAN := TRUE;
        l_error_in    t_error_in := t_error_in();
        l_rowsid      table_varchar := table_varchar();
        io_monit      monit;
        -- Alert® Data Governance
        l_rowids table_varchar;
    
        CURSOR c_monitor IS
            SELECT flg_status, id_episode
              FROM monitorization
             WHERE id_monitorization = i_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini);
    
        CURSOR c_monitor_vs IS
            SELECT id_monitorization_vs
              FROM monitorization_vs
             WHERE id_monitorization = i_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini);
    
        CURSOR c_monitorization_exe(c_id_monitorization_vs monitorization_vs.id_monitorization_vs%TYPE) IS
            SELECT 'x'
              FROM monitorization_vs_plan mp
             WHERE mp.id_monitorization_vs = c_id_monitorization_vs
               AND mp.flg_status = pk_alert_constant.g_monitor_vs_fini;
    
        rec_record    sys_alert_event%ROWTYPE;
        l_rowsid_m    table_varchar := table_varchar();
        l_rowsid_plan table_varchar := table_varchar();
    BEGIN
        l_commit_data := NOT (i_commit_data = pk_alert_constant.g_no);
    
        --verifica se a requisição pode ser cancelada. Para isso, não pode estar já cancelada ou então ter detalhes com resultados
        l_message := 'GET OLD STATUS';
        OPEN c_monitor;
        FETCH c_monitor
            INTO l_old_status, l_episode;
        l_found := c_monitor%FOUND;
        CLOSE c_monitor;
    
        IF NOT l_found
        THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M001',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'CANCEL_MONITOR_REQ',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               'U');
            RETURN pk_alert_exceptions.process_error(l_error_in, o_error);
        END IF;
    
        --Cancela requisição e todos os detalhes
        l_message := 'UPDATE MONITORIZATION STATUS';
        ts_monitorization.upd(id_monitorization_in => i_id_monitorization,
                              flg_status_in        => CASE
                                                          WHEN l_found
                                                               AND l_old_status != pk_alert_constant.g_monitor_vs_draft THEN
                                                           pk_alert_constant.g_monitor_vs_inte
                                                          ELSE
                                                           pk_alert_constant.g_monitor_vs_canc
                                                      END,
                              dt_cancel_tstz_in    => l_sysdate_tstz,
                              id_prof_cancel_in    => i_prof.id,
                              notes_cancel_in      => i_notes,
                              notes_cancel_nin     => FALSE,
                              rows_out             => l_rowsid);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        --CO-SIGN Cancellation workflow
        l_message := 'CREATE MONIT OBJECT';
        IF NOT init_monit(i_lang              => i_lang,
                          i_prof              => i_prof,
                          i_id_monitorization => i_id_monitorization,
                          io_monit            => io_monit,
                          o_error             => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        
        END IF;
    
        l_message                          := 'CALL SET_CO_SIGN_CANCELATION_WF';
        io_monit.flg_monitorization_action := pk_monitorization.g_cancel_action;
        IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        --Cancela todos os detalhes ainda não cancelados
        FOR i IN c_monitor_vs
        LOOP
            l_message := 'open c_monitorization_exe ';
            OPEN c_monitorization_exe(i.id_monitorization_vs);
            FETCH c_monitorization_exe
                INTO l_char;
            l_found := c_monitorization_exe%FOUND;
            CLOSE c_monitorization_exe;
        
            IF l_found
            THEN
                --Cancela requisição e todos os detalhes
                l_message := 'UPDATE MONITORIZATION STATUS';
                ts_monitorization.upd(id_monitorization_in => i_id_monitorization,
                                      flg_status_in        => pk_alert_constant.g_monitor_vs_inte,
                                      dt_cancel_tstz_in    => l_sysdate_tstz,
                                      id_prof_cancel_in    => i_prof.id,
                                      notes_cancel_in      => i_notes,
                                      notes_cancel_nin     => FALSE,
                                      rows_out             => l_rowsid_m);
            END IF;
        
            l_message := 'UPDATE MONITORIZATION_VS';
            ts_monitorization_vs.upd(id_monitorization_vs_in => i.id_monitorization_vs,
                                     flg_status_in           => CASE
                                                                    WHEN l_old_status != pk_alert_constant.g_monitor_vs_draft THEN
                                                                     pk_alert_constant.g_monitor_vs_inte
                                                                    ELSE
                                                                     pk_alert_constant.g_monitor_vs_canc
                                                                END,
                                     dt_cancel_tstz_in       => l_sysdate_tstz,
                                     id_prof_cancel_in       => i_prof.id,
                                     notes_cancel_in         => i_notes,
                                     notes_cancel_nin        => FALSE,
                                     id_cancel_reason_in     => i_id_cancel_reason,
                                     id_cancel_reason_nin    => FALSE,
                                     rows_out                => l_rowids);
        
            l_message := 'UPDATE MONITORIZATION_VS_PLAN';
            ts_monitorization_vs_plan.upd(flg_status_in => pk_alert_constant.g_monitor_vs_canc,
                                          where_in      => 'ID_MONITORIZATION_VS = ' || i.id_monitorization_vs ||
                                                           ' AND FLG_STATUS != ''' ||
                                                           pk_alert_constant.g_monitor_vs_fini || '''',
                                          rows_out      => l_rowsid_plan);
        
            rec_record.id_sys_alert    := c_id_sys_alert_vital_sign;
            rec_record.id_software     := i_prof.software;
            rec_record.id_institution  := i_prof.institution;
            rec_record.id_professional := i_prof.id;
            rec_record.id_episode      := l_episode;
            rec_record.id_record       := i.id_monitorization_vs;
        
            l_message := 'CALL pk_alerts.delete_sys_alert_event';
            IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => rec_record,
                                                    o_error           => o_error)
            THEN
                IF l_commit_data
                THEN
                    pk_utils.undo_changes;
                END IF;
                RETURN FALSE;
            END IF;
        
        END LOOP;
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid_m,
                                      o_error      => o_error);
    
        -- Alert® Data Governance
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        l_message := 'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        IF l_commit_data
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
    END cancel_monitor_req;

    /******************************************************************************
       OBJECTIVO:   Cancelar requisição de monitorização de sinais vitais
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION  - ID da requisicao
                     I_PROF - Profissional que faz o cancelamento
                 I_NOTES - Notas de cancelamento
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           como é retornada em PK_LOGIN.GET_PROF_PREF
                  I_COMMIT_DATA - Flag que indica se a função deve fazer o commit dos dados
                  I_ID_CANCEL_REASON - Id da cancel reason associada
                  I_PROF_ORDERED - Profissional que ordenou oI_PROF_ORDERED
                  I_DT_ORDERED - Data em que ordernou
      I_DT_ORDEREDI_ORDER_TYPE - Qual o tipo de ordem - order type id
              Saida:  O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
    *********************************************************************************/
    FUNCTION cancelmonitorreq
    (
        i_lang              IN language.id_language%TYPE,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_prof              IN profissional,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_commit_data       IN VARCHAR2,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        i_prof_order        IN co_sign.id_prof_ordered_by%TYPE,
        i_dt_order          IN co_sign.dt_ordered_by%TYPE,
        i_order_type        IN order_type.id_order_type%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message     debug_msg;
        l_old_status  monitorization.flg_status%TYPE;
        l_episode     monitorization.id_episode%TYPE;
        l_commit_data BOOLEAN;
        l_char        VARCHAR2(1);
        l_found       BOOLEAN := TRUE;
        l_error_in    t_error_in := t_error_in();
        l_rowsid      table_varchar := table_varchar();
        io_monit      monit;
        -- Alert® Data Governance
        l_rowids   table_varchar;
        l_rowsid_m table_varchar := table_varchar();
        CURSOR c_monitor IS
            SELECT flg_status, id_episode
              FROM monitorization
             WHERE id_monitorization = i_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini);
    
        CURSOR c_monitor_vs IS
            SELECT id_monitorization_vs
              FROM monitorization_vs
             WHERE id_monitorization = i_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini);
    
        CURSOR c_monitorization_exe(c_id_monitorization_vs monitorization_vs.id_monitorization_vs%TYPE) IS
            SELECT 'x'
              FROM monitorization_vs_plan mp
             WHERE mp.id_monitorization_vs = c_id_monitorization_vs
               AND mp.flg_status = pk_alert_constant.g_monitor_vs_fini;
    
        rec_record    sys_alert_event%ROWTYPE;
        l_rowsid_plan table_varchar := table_varchar();
    BEGIN
        l_commit_data := NOT (i_commit_data = pk_alert_constant.g_no);
    
        --verifica se a requisição pode ser cancelada. Para isso, não pode estar já cancelada ou então ter detalhes com resultados
        l_message := 'GET OLD STATUS';
        OPEN c_monitor;
        FETCH c_monitor
            INTO l_old_status, l_episode;
        l_found := c_monitor%FOUND;
        CLOSE c_monitor;
    
        IF NOT l_found
        THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M001',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'CANCEL_MONITOR_REQ',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               'U');
            RETURN pk_alert_exceptions.process_error(l_error_in, o_error);
        END IF;
    
        --Cancela requisição e todos os detalhes
        l_message := 'UPDATE MONITORIZATION STATUS';
        ts_monitorization.upd(id_monitorization_in => i_id_monitorization,
                              flg_status_in        => pk_alert_constant.g_monitor_vs_canc,
                              dt_cancel_tstz_in    => l_sysdate_tstz,
                              id_prof_cancel_in    => i_prof.id,
                              notes_cancel_in      => i_notes,
                              notes_cancel_nin     => FALSE,
                              rows_out             => l_rowsid);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        --CO-SIGN Cancellation workflow
        l_message := 'CREATE MONIT OBJECT';
        IF NOT init_monit(i_lang              => i_lang,
                          i_prof              => i_prof,
                          i_id_monitorization => i_id_monitorization,
                          io_monit            => io_monit,
                          o_error             => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        l_message                          := 'CALL SET_CO_SIGN_CANCELATION_WF';
        io_monit.id_prof_order             := i_prof_order;
        io_monit.dt_order_str              := get_str_date(i_lang, i_prof, i_dt_order);
        io_monit.id_order_type             := i_order_type;
        io_monit.flg_monitorization_action := pk_monitorization.g_cancel_action;
        IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        --Cancela todos os detalhes ainda não cancelados
        FOR i IN c_monitor_vs
        LOOP
            l_message := 'open c_monitorization_exe ';
            OPEN c_monitorization_exe(i.id_monitorization_vs);
            FETCH c_monitorization_exe
                INTO l_char;
            l_found := c_monitorization_exe%FOUND;
            CLOSE c_monitorization_exe;
        
            IF l_found
            THEN
                --Cancela requisição e todos os detalhes
                l_message := 'UPDATE MONITORIZATION STATUS';
                ts_monitorization.upd(id_monitorization_in => i_id_monitorization,
                                      flg_status_in        => pk_alert_constant.g_monitor_vs_inte,
                                      dt_cancel_tstz_in    => l_sysdate_tstz,
                                      id_prof_cancel_in    => i_prof.id,
                                      notes_cancel_in      => i_notes,
                                      notes_cancel_nin     => FALSE,
                                      rows_out             => l_rowsid_m);
            END IF;
        
            l_message := 'UPDATE MONITORIZATION_VS';
            ts_monitorization_vs.upd(id_monitorization_vs_in => i.id_monitorization_vs,
                                     flg_status_in           => CASE
                                                                    WHEN l_found THEN
                                                                     pk_alert_constant.g_monitor_vs_inte
                                                                    ELSE
                                                                     pk_alert_constant.g_monitor_vs_canc
                                                                END,
                                     dt_cancel_tstz_in       => l_sysdate_tstz,
                                     id_prof_cancel_in       => i_prof.id,
                                     notes_cancel_in         => i_notes,
                                     notes_cancel_nin        => FALSE,
                                     id_cancel_reason_in     => i_id_cancel_reason,
                                     id_cancel_reason_nin    => FALSE,
                                     rows_out                => l_rowids);
        
            l_message := 'UPDATE MONITORIZATION_VS_PLAN';
            ts_monitorization_vs_plan.upd(flg_status_in => pk_alert_constant.g_monitor_vs_canc,
                                          where_in      => 'ID_MONITORIZATION_VS = ' || i.id_monitorization_vs ||
                                                           ' AND FLG_STATUS != ''' ||
                                                           pk_alert_constant.g_monitor_vs_fini || '''',
                                          rows_out      => l_rowsid_plan);
        
            rec_record.id_sys_alert    := c_id_sys_alert_vital_sign;
            rec_record.id_software     := i_prof.software;
            rec_record.id_institution  := i_prof.institution;
            rec_record.id_professional := i_prof.id;
            rec_record.id_episode      := l_episode;
            rec_record.id_record       := i.id_monitorization_vs;
        
            l_message := 'CALL pk_alerts.delete_sys_alert_event';
            IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => rec_record,
                                                    o_error           => o_error)
            THEN
                IF l_commit_data
                THEN
                    pk_utils.undo_changes;
                END IF;
                RETURN FALSE;
            END IF;
        
        END LOOP;
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid_m,
                                      o_error      => o_error);
    
        -- Alert® Data Governance
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        l_message := 'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        IF l_commit_data
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
    END cancelmonitorreq;

    /**********************************************************************************************
    * cancel monitorization and vital signs with commit as (Y)es
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   profissional type
    * @param i_id_monitorization      monitorization id
    * @param i_notes                  notes for cancel
    * @param i_prof_cat_type          profissional category internal flag
    * @param i_id_cancel_reason       cancel reason identifier
    * @param i_prof_ordered           Professional that i_prof_orderede monit
    * @param i_dt_ordered             Timestamp that was ordered ted monit
    * @param i_order_type             Type of order identifier
     *@param i_commit_data            Indicates if commit is to be done Y/N
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Pedro Fernandes
    * @version                        2.6.5.0.1
    * @since                          2015/04/22
    **********************************************************************************************/

    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN table_number,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        i_prof_ordered      IN co_sign.id_prof_ordered_by%TYPE,
        i_dt_ordered        IN VARCHAR2,
        i_order_type        IN order_type.id_order_type%TYPE,
        i_commit_data       IN VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_message     debug_msg;
        l_commit_data BOOLEAN;
        l_func_name   VARCHAR2(100 CHAR) := 'CANCEL_MONITOR_REQ';
    BEGIN
    
        FOR i IN 1 .. i_id_monitorization.count
        LOOP
            l_message := 'call cancel_monitor_req:' || i_id_monitorization(i) || 'i_prof_ordered:' || i_prof_ordered ||
                         'i_order_type:' || i_order_type;
            pk_alertlog.log_debug(text => l_message, object_name => c_package_name, sub_object_name => l_func_name);
            IF NOT
                cancelmonitorreq(i_lang              => i_lang,
                                 i_id_monitorization => i_id_monitorization(i),
                                 i_prof              => i_prof,
                                 i_notes             => i_notes,
                                 i_prof_cat_type     => i_prof_cat_type,
                                 i_commit_data       => i_commit_data,
                                 i_id_cancel_reason  => i_id_cancel_reason,
                                 i_prof_order        => i_prof_ordered,
                                 i_dt_order          => pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_ordered, NULL),
                                 i_order_type        => i_order_type,
                                 o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END cancel_monitor_req;

    /**********************************************************************************************
    * cancel monitorization and vital signs with commit as (Y)es
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   profissional type
    * @param i_id_monitorization      monitorization id
    * @param i_notes                  notes for cancel
    * @param i_prof_cat_type          profissional category internal flag
    * @param i_id_cancel_reason       cancel reason identifier
    * @param i_prof_ordered           Professional that i_prof_orderede monit
    * @param i_dt_ordered             Timestamp that was ordered ted monit
    * @param i_order_type             Type of order identifier
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/26
    **********************************************************************************************/

    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN table_number,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        i_prof_ordered      IN co_sign.id_prof_ordered_by%TYPE,
        i_dt_ordered        IN VARCHAR2,
        i_order_type        IN order_type.id_order_type%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_message   debug_msg;
        l_func_name VARCHAR2(100 CHAR) := 'CANCEL_MONITOR_REQ';
    BEGIN
    
        FOR i IN 1 .. i_id_monitorization.count
        LOOP
            l_message := 'call cancel_monitor_req:' || i_id_monitorization(i) || 'i_prof_ordered:' || i_prof_ordered ||
                         'i_order_type:' || i_order_type;
            pk_alertlog.log_debug(text => l_message, object_name => c_package_name, sub_object_name => l_func_name);
            IF NOT
                cancelmonitorreq(i_lang              => i_lang,
                                 i_id_monitorization => i_id_monitorization(i),
                                 i_prof              => i_prof,
                                 i_notes             => i_notes,
                                 i_prof_cat_type     => i_prof_cat_type,
                                 i_commit_data       => pk_alert_constant.g_no,
                                 i_id_cancel_reason  => i_id_cancel_reason,
                                 i_prof_order        => i_prof_ordered,
                                 i_dt_order          => pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_ordered, NULL),
                                 i_order_type        => i_order_type,
                                 o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END LOOP;
    
        COMMIT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END cancel_monitor_req;

    /**********************************************************************************************
    * cancel monitorization and vital signs with commit as (Y)es
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   profissional type
    * @param i_id_monitorization      monitorization id
    * @param i_notes                  notes for cancel
    * @param i_prof_cat_type          profissional category internal flag
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/26
    **********************************************************************************************/

    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN cancel_monitor_req(i_lang              => i_lang,
                                  i_id_monitorization => i_id_monitorization,
                                  i_prof              => i_prof,
                                  i_notes             => i_notes,
                                  i_prof_cat_type     => i_prof_cat_type,
                                  i_commit_data       => pk_alert_constant.g_yes,
                                  i_id_cancel_reason  => i_id_cancel_reason,
                                  o_error             => o_error);
    END cancel_monitor_req;
    /**********************************************************************************************
    * cancel monitorization and vital signs with commit as (Y)es
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   profissional type
    * @param i_id_monitorization      monitorization array id
    * @param i_notes                  notes for cancel
    * @param i_prof_cat_type          profissional category internal flag
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/26
    **********************************************************************************************/
    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN table_number,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_message debug_msg;
    BEGIN
    
        FOR i IN 1 .. i_id_monitorization.count
        LOOP
            l_message := 'call cancel_monitor_req:' || i_id_monitorization(i);
            IF NOT cancel_monitor_req(i_lang              => i_lang,
                                      i_id_monitorization => i_id_monitorization(i),
                                      i_prof              => i_prof,
                                      i_notes             => i_notes,
                                      i_prof_cat_type     => i_prof_cat_type,
                                      i_commit_data       => pk_alert_constant.g_yes,
                                      i_id_cancel_reason  => i_id_cancel_reason,
                                      o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END cancel_monitor_req;
    /******************************************************************************
       OBJECTIVO:   Cancelar detalhe de requisição de monitorização de sinais vitais
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION_VS - ID do detalhe da requisicao
                     I_PROF - Profissional que faz o cancelamento
                 I_NOTES - Notas de cancelamento
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           I_ID_CANCEL_REASON Cancel Reason ID
                           como é retornada em PK_LOGIN.GET_PROF_PREF
              Saida:  O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/20
      NOTAS:
    *********************************************************************************/
    FUNCTION cancel_monitor_vs_req
    (
        i_lang                 IN language.id_language%TYPE,
        i_id_monitorization_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_prof                 IN profissional,
        i_notes                IN monitorization_vs.notes_cancel%TYPE,
        i_prof_cat_type        IN category.flg_type%TYPE,
        i_id_cancel_reason     IN cancel_reason.id_cancel_reason%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message           debug_msg;
        l_old_status        monitorization_vs.flg_status%TYPE;
        l_id_monitorization monitorization.id_monitorization%TYPE;
        l_char              VARCHAR2(1);
        l_id_episode        episode.id_episode%TYPE;
        l_found             BOOLEAN := TRUE;
        l_error_in          t_error_in := t_error_in();
        g_exception EXCEPTION;
        l_rowsid_m table_varchar := table_varchar();
        -- Alert® Data Governance
        l_rowids table_varchar;
    
        CURSOR c_old_stat IS
            SELECT d.flg_status, d.id_monitorization, m.id_episode
              FROM monitorization_vs d, monitorization m
             WHERE d.id_monitorization_vs = i_id_monitorization_vs
               AND m.id_monitorization = d.id_monitorization;
        CURSOR c_monitorization_exe IS
            SELECT 'x'
              FROM monitorization_vs_plan mp
             WHERE mp.id_monitorization_vs = i_id_monitorization_vs
               AND mp.flg_status = pk_alert_constant.g_monitor_vs_fini;
    
        CURSOR c_canc(pin_id_monitorization monitorization_vs.id_monitorization%TYPE) IS
            SELECT 'X'
              FROM monitorization_vs
             WHERE id_monitorization = pin_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_inte);
        l_rowsid_plan table_varchar := table_varchar();
    BEGIN
        --verifica qual o estado anterior
        l_message := 'GET OLD STATUS';
        OPEN c_old_stat;
        FETCH c_old_stat
            INTO l_old_status, l_id_monitorization, l_id_episode;
        l_found := c_old_stat%FOUND;
        CLOSE c_old_stat;
    
        IF NOT l_found
           OR l_old_status IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini)
        THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M001',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'CANCEL_MONITOR_VS_REQ',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               'U');
            RETURN pk_alert_exceptions.process_error(l_error_in, o_error);
        END IF;
    
        l_message := 'OPEN C_MONITORIZATION_EXE';
        OPEN c_monitorization_exe;
        FETCH c_monitorization_exe
            INTO l_char;
        l_found := c_monitorization_exe%FOUND;
        CLOSE c_monitorization_exe;
    
        l_message := 'UPDATE MONITORIZATION_VS';
        ts_monitorization_vs.upd(id_monitorization_vs_in => i_id_monitorization_vs,
                                 flg_status_in           => CASE
                                                                WHEN l_found = TRUE THEN
                                                                 pk_alert_constant.g_monitor_vs_inte
                                                                ELSE
                                                                 pk_alert_constant.g_monitor_vs_canc
                                                            END,
                                 dt_cancel_tstz_in       => l_sysdate_tstz,
                                 id_prof_cancel_in       => i_prof.id,
                                 notes_cancel_in         => i_notes,
                                 id_cancel_reason_in     => i_id_cancel_reason,
                                 rows_out                => l_rowids);
    
        ts_monitorization_vs_plan.upd(flg_status_in => pk_alert_constant.g_monitor_vs_canc,
                                      where_in      => 'ID_MONITORIZATION_VS = ' || i_id_monitorization_vs ||
                                                       ' AND FLG_STATUS != ''' || pk_alert_constant.g_monitor_vs_fini || '''',
                                      rows_out      => l_rowsid_plan);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
    
        --Verificar se todos os detalhes estão cancelados e, se sim, cancela tb o cabeçalho da requisição
        l_message := 'open c_canc ';
        OPEN c_canc(l_id_monitorization);
        FETCH c_canc
            INTO l_char;
        l_found := c_canc%FOUND;
        CLOSE c_canc;
    
        --Se o cursor não devolver registos, todos os detalhes estão cancelados e pode-se cancelar o cabeçalho
        IF NOT l_found
        THEN
            l_message := 'open c_monitorization_exe ';
            OPEN c_monitorization_exe;
            FETCH c_monitorization_exe
                INTO l_char;
            l_found := c_monitorization_exe%FOUND;
            CLOSE c_monitorization_exe;
        
            -- l_found = TRUE --> Interrompe requisição e todos os detalhes
            -- l_found = FALSE --> Cancela requisição e todos os detalhes
        
            l_message := 'UPDATE MONITORIZATION STATUS';
            ts_monitorization.upd(id_monitorization_in => l_id_monitorization,
                                  flg_status_in        => CASE
                                                              WHEN l_found = TRUE THEN
                                                               pk_alert_constant.g_monitor_vs_inte
                                                              ELSE
                                                               pk_alert_constant.g_monitor_vs_canc
                                                          END,
                                  dt_cancel_tstz_in    => l_sysdate_tstz,
                                  id_prof_cancel_in    => i_prof.id,
                                  notes_cancel_in      => i_notes,
                                  rows_out             => l_rowsid_m);
        
            l_message := 'CALL t_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION',
                                          i_rowids     => l_rowsid_m,
                                          o_error      => o_error);
        
            l_message := 'UPDATE MONITORIZATIONS_EA STATUS';
            -- the monitoring will be cancelled for all vital signs
            FOR c IN (SELECT mvs.id_monitorization_vs
                        FROM monitorization_vs mvs
                       WHERE mvs.id_monitorization = l_id_monitorization)
            LOOP
            
                ts_monitorizations_ea.upd(id_monitorization_vs_in => c.id_monitorization_vs,
                                          id_monitorization_in    => l_id_monitorization,
                                          flg_status_in           => CASE
                                                                         WHEN l_found = TRUE THEN
                                                                          pk_alert_constant.g_monitor_vs_inte
                                                                         ELSE
                                                                          pk_alert_constant.g_monitor_vs_canc
                                                                     END);
            
            END LOOP;
        END IF;
    
        -- Alert® Data Governance
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        l_message := 'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_id_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
    
        DELETE sys_alert_event sad
         WHERE sad.id_sys_alert = c_id_sys_alert_vital_sign;
    
        IF NOT create_alert_vital_sign(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       i_monitorization => l_id_monitorization,
                                       o_error          => o_error)
        THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
    
        pk_icnp_fo_api_db.set_sugg_status_cancel(i_lang         => i_lang,
                                                 i_prof         => i_prof,
                                                 i_request_id   => i_id_monitorization_vs,
                                                 i_task_type_id => pk_alert_constant.g_task_monitoring,
                                                 i_sysdate_tstz => current_timestamp);
    
        COMMIT;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_VS_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_monitor_vs_req;
    /**********************************************************************************************
    * Registo de SVs através da monitorização
    *
    * @param i_lang                   the id language
    * @param i_episode                episode id
    * @param i_prof                   professional, software and institution ids
    * @param i_pat                    patient id
    * @param i_vs_id                  array de IDs de SVs
    * @param i_vs_val                 array de valores lidos (valores registados no keypad, ou ID do descritivo)
    * @param i_id_monit               monitorization id
    * @param i_dt_plan_str            data da próxima leitura. Pode vir NULL, se o keypad ñ for usado.
    * @param i_prof_cat_type          category of professional
    * @param i_prof_performed         professional performed
    * @param i_start_time             start time of execution intervention
    * @param i_end_time               end time of execution intervention
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Claudia Silva
    * @version                        1.0 
    * @since                          2005/07/28
    **********************************************************************************************/
    FUNCTION set_monitor_vs_read
    (
        i_lang               IN language.id_language%TYPE,
        i_episode            IN vital_sign_read.id_episode%TYPE,
        i_prof               IN profissional,
        i_pat                IN vital_sign_read.id_patient%TYPE,
        i_vs_id              IN table_number,
        i_vs_val             IN table_number,
        i_unit_meas          IN table_number,
        i_vs_scales_elements IN table_number,
        i_dt_vs_read         IN table_varchar,
        i_id_monit           IN monitorization.id_monitorization%TYPE,
        i_dt_plan_str        IN VARCHAR2,
        i_prof_cat_type      IN category.flg_type%TYPE,
        i_prof_performed     IN monitorization_vs_plan.id_prof_performed%TYPE,
        i_start_time         IN VARCHAR2,
        i_end_time           IN VARCHAR2,
        i_unit_meas_sel      IN table_number,
        i_tbtb_attribute     IN table_table_number,
        i_tbtb_free_text     IN table_table_clob,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message debug_msg;
    
        TYPE monit_vs_read IS RECORD(
            id_mon_vs      monitorization_vs.id_monitorization_vs%TYPE,
            id_mon_vs_plan monitorization_vs_plan.id_monitorization_vs_plan%TYPE);
    
        TYPE mvs IS TABLE OF monit_vs_read INDEX BY BINARY_INTEGER;
    
        -- Alert® Data Governance
        l_rowids_aux   table_varchar;
        l_rowids       table_varchar := table_varchar();
        l_monit_rowids table_varchar := table_varchar();
    
        l_interval             monitorization.interval%TYPE;
        l_id_vs_plan           monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_id_mvs               monitorization_vs.id_monitorization_vs%TYPE;
        l_flg_status           monitorization_vs_plan.flg_status%TYPE;
        l_flg_status_monit     monitorization.flg_status%TYPE;
        l_id_monitorization_vs monitorization_vs.id_monitorization_vs%TYPE;
        l_dt                   TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_aux               TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_begin             monitorization.dt_begin_tstz%TYPE;
        l_start_time           TIMESTAMP WITH LOCAL TIME ZONE;
        l_end_time             TIMESTAMP WITH LOCAL TIME ZONE;
        l_ret                  BOOLEAN;
        l_error_in             t_error_in := t_error_in();
    
        CURSOR c_plan(i_vs IN monitorization_vs.id_vital_sign%TYPE) IS
            SELECT INTERVAL,
                   mp.id_monitorization_vs_plan,
                   mvs.id_monitorization_vs,
                   mp.flg_status,
                   mvs.id_monitorization_vs,
                   m.flg_time,
                   m.flg_status flg_status_monit
              FROM monitorization m, monitorization_vs mvs, monitorization_vs_plan mp, vital_sign_relation vr
             WHERE m.id_monitorization = i_id_monit
               AND mvs.id_monitorization = m.id_monitorization
               AND mp.id_monitorization_vs = mvs.id_monitorization_vs
               AND mp.flg_status IN (pk_alert_constant.g_monitor_vs_exec,
                                     pk_alert_constant.g_monitor_vs_pend,
                                     pk_alert_constant.g_monitor_vs_expire)
               AND (mvs.id_vital_sign = i_vs OR
                   (vr.id_vital_sign_detail = i_vs AND
                   vr.relation_domain IN (pk_alert_constant.g_vs_rel_sum, pk_alert_constant.g_vs_rel_conc)))
               AND vr.id_vital_sign_parent(+) = mvs.id_vital_sign;
    
        CURSOR c_dt IS
            SELECT l_dt_begin, dt_end_tstz
              FROM monitorization
             WHERE id_monitorization = i_id_monit;
    
        rec_record sys_alert_event%ROWTYPE;
        --
        mon_vs       mvs;
        k            NUMBER := 0;
        l_update     BOOLEAN;
        l_mvs_plan   monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_time       monitorization.flg_time%TYPE;
        i_dt_plan    TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_vs_read vital_sign_read.dt_vital_sign_read_tstz%TYPE;
    
        l_monitorization_vs_list table_number := table_number();
        l_monit_vs_list_cnt      PLS_INTEGER;
    
        l_vital_sign_read table_number := table_number();
        l_tbtb_attribute  table_table_number := table_table_number();
        l_tbtb_free_text  table_table_clob := table_table_clob();
        l_dt_registry     VARCHAR2(4000);
        l_rowsid          table_varchar := table_varchar();
    BEGIN
        rec_record.id_sys_alert    := c_id_sys_alert_vital_sign;
        rec_record.id_software     := i_prof.software;
        rec_record.id_institution  := i_prof.institution;
        rec_record.id_professional := i_prof.id;
        rec_record.id_record       := NULL;
        rec_record.id_episode      := i_episode;
    
        --
        i_dt_plan    := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_plan_str, NULL);
        l_start_time := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_time, NULL);
        l_end_time   := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_time, NULL);
        --
    
        FOR i IN 1 .. i_vs_id.count
        LOOP
            -- Loop sobre o array de IDs de SVs lidos
            l_message := 'OPEN c_plan';
            OPEN c_plan(i_vs_id(i));
            FETCH c_plan
                INTO l_interval,
                     l_id_vs_plan,
                     l_id_mvs,
                     l_flg_status,
                     l_id_monitorization_vs,
                     l_time,
                     l_flg_status_monit;
            CLOSE c_plan;
            --        
            IF pk_sysconfig.get_config('REQ_NEXT_DAY', i_prof) = 'N'
            THEN
                IF l_time = pk_alert_constant.g_flg_time_e
                   AND trunc(nvl(i_dt_plan, l_sysdate_tstz)) != trunc(l_sysdate_tstz)
                THEN
                    l_error_in.set_all(i_lang,
                                       'MONITOR_M001',
                                       pk_message.get_message(i_lang, 'MONITOR_M003'),
                                       l_message,
                                       c_package_owner,
                                       c_package_name,
                                       'SET_MONITOR_VS_READ',
                                       pk_message.get_message(i_lang, 'MONITOR_M003'),
                                       'U');
                    l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                    pk_alert_exceptions.reset_error_state;
                    RETURN FALSE;
                END IF;
            END IF;
            --        
            l_mvs_plan := NULL;
            l_update   := TRUE;
        
            IF k != 0
            THEN
                FOR j IN 1 .. k
                LOOP
                    IF mon_vs(j).id_mon_vs = l_id_mvs
                    THEN
                        -- Esta req monit já passou
                        l_update   := FALSE;
                        l_mvs_plan := mon_vs(j).id_mon_vs_plan;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        
            IF l_update
            THEN
                --
                l_message := 'OPEN c_dt';
                OPEN c_dt;
                FETCH c_dt
                    INTO l_dt_begin, l_dt;
                CLOSE c_dt;
                --
            
                l_message := 'UPDATE monitorization_vs_plan';
                ts_monitorization_vs_plan.upd(id_monitorization_vs_plan_in => l_id_vs_plan,
                                              flg_status_in                => CASE
                                                                                  WHEN l_flg_status_monit =
                                                                                       pk_alert_constant.g_monitor_vs_expire THEN
                                                                                   pk_alert_constant.g_monitor_vs_expire
                                                                                  ELSE
                                                                                   pk_alert_constant.g_monitor_vs_fini
                                                                              END,
                                              id_prof_performed_in         => i_prof_performed,
                                              start_time_in                => l_start_time,
                                              end_time_in                  => l_end_time,
                                              rows_out                     => l_rowids);
            
                IF l_flg_status = pk_alert_constant.g_monitor_vs_pend
                THEN
                    l_message := 'UPDATE monitorization_vs(1)';
                    ts_monitorization_vs.upd(id_monitorization_vs_in => l_id_monitorization_vs,
                                             flg_status_in           => CASE
                                                                            WHEN l_flg_status_monit =
                                                                                 pk_alert_constant.g_monitor_vs_expire THEN
                                                                             pk_alert_constant.g_monitor_vs_expire
                                                                            ELSE
                                                                             pk_alert_constant.g_monitor_vs_exec
                                                                        END,
                                             rows_out                => l_rowsid);
                    l_monitorization_vs_list.extend;
                    l_monitorization_vs_list(l_monitorization_vs_list.last) := l_id_monitorization_vs;
                
                END IF;
            
                --If Expired doesn't do anything
                IF l_flg_status_monit <> pk_alert_constant.g_monitor_vs_expire
                THEN
                
                    l_dt_aux := nvl(i_dt_plan, l_sysdate_tstz + numtodsinterval(nvl(l_interval, 0), 'SECOND'));
                
                    IF l_dt IS NULL
                       OR l_dt >= l_dt_aux
                    THEN
                        l_message := 'INSERT monitorization_vs_plan(1)';
                        ts_monitorization_vs_plan.ins(id_monitorization_vs_in => l_id_mvs,
                                                      dt_plan_tstz_in         => l_dt_aux,
                                                      flg_status_in           => CASE
                                                                                     WHEN l_dt_aux <= l_sysdate_tstz THEN
                                                                                      pk_alert_constant.g_monitor_vs_exec
                                                                                     ELSE
                                                                                      pk_alert_constant.g_monitor_vs_pend
                                                                                 END,
                                                      rows_out                => l_rowids_aux);
                        l_rowids := l_rowids MULTISET UNION DISTINCT l_rowids_aux;
                    
                        IF l_flg_status_monit = pk_alert_constant.g_monitor_vs_pend
                        THEN
                            l_message := 'UPDATE monitorization to under going';
                            ts_monitorization.upd(id_monitorization_in => i_id_monit,
                                                  flg_status_in        => pk_alert_constant.g_monitor_vs_exec,
                                                  rows_out             => l_monit_rowids);
                        
                            l_message := 'CALL t_data_gov_mnt.process_update - MONITORIZATION';
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'MONITORIZATION',
                                                          i_rowids     => l_monit_rowids,
                                                          o_error      => o_error);
                        END IF;
                    
                    ELSE
                    
                        l_message := 'UPDATE monitorization(2)';
                        ts_monitorization.upd(id_monitorization_in => i_id_monit,
                                              flg_status_in        => pk_alert_constant.g_monitor_vs_fini,
                                              rows_out             => l_monit_rowids);
                    
                        l_message := 'CALL t_data_gov_mnt.process_update - MONITORIZATION';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'MONITORIZATION',
                                                      i_rowids     => l_monit_rowids,
                                                      o_error      => o_error);
                    
                        l_message := 'UPDATE monitorization_vs(2)';
                        ts_monitorization_vs.upd(id_monitorization_vs_in => l_id_monitorization_vs,
                                                 flg_status_in           => pk_alert_constant.g_monitor_vs_fini);
                    
                        l_monitorization_vs_list.extend;
                        l_monitorization_vs_list(l_monitorization_vs_list.last) := l_id_monitorization_vs;
                    
                    END IF;
                    --
                END IF;
                k := k + 1;
                mon_vs(k).id_mon_vs := l_id_mvs;
                mon_vs(k).id_mon_vs_plan := l_id_vs_plan;
            END IF;
        
            l_message := 'GET DT_VS_READ';
            IF i_dt_vs_read.count > 0
               AND i_dt_vs_read(i) IS NOT NULL
            THEN
                l_dt_vs_read := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                              i_prof      => i_prof,
                                                              i_timestamp => i_dt_vs_read(i),
                                                              i_timezone  => NULL);
            ELSE
                l_dt_vs_read := l_sysdate_tstz;
            
            END IF;
        
            IF i_tbtb_attribute.exists(i)
               AND i_tbtb_free_text.exists(i)
            THEN
                l_tbtb_attribute := table_table_number(i_tbtb_attribute(i));
                l_tbtb_free_text := table_table_clob(i_tbtb_free_text(i));
            ELSE
                l_tbtb_attribute := table_table_number();
                l_tbtb_free_text := table_table_clob();
            END IF;
        
            --
            l_message := 'CALL pk_vital_sign.set_epis_vital_sign';
            IF NOT pk_vital_sign.set_epis_vital_sign(i_lang               => i_lang,
                                                     i_episode            => i_episode,
                                                     i_prof               => i_prof,
                                                     i_pat                => i_pat,
                                                     i_vs_id              => table_number(i_vs_id(i)),
                                                     i_vs_val             => table_number(i_vs_val(i)),
                                                     i_id_monit           => nvl(l_mvs_plan, l_id_vs_plan),
                                                     i_unit_meas          => table_number(i_unit_meas(i)),
                                                     i_vs_scales_elements => table_number(i_vs_scales_elements(i)),
                                                     i_notes              => NULL,
                                                     i_prof_cat_type      => i_prof_cat_type,
                                                     i_dt_vs_read         => table_varchar(pk_date_utils.date_send_tsz(i_lang,
                                                                                                                       l_dt_vs_read,
                                                                                                                       i_prof)),
                                                     i_epis_triage        => NULL,
                                                     i_unit_meas_convert  => table_number(nvl(i_unit_meas_sel(i),
                                                                                              i_unit_meas(i))),
                                                     i_tbtb_attribute     => l_tbtb_attribute,
                                                     i_tbtb_free_text     => l_tbtb_free_text,
                                                     o_vital_sign_read    => l_vital_sign_read,
                                                     o_dt_registry        => l_dt_registry,
                                                     o_error              => o_error)
            THEN
                pk_alert_exceptions.reset_error_state;
                pk_utils.undo_changes;
                RETURN FALSE;
            END IF;
        
        END LOOP;
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        -- Alert® Data Governance
        l_message := 'CALL t_data_gov_mnt.process_insert';
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        l_message := 'CALL pk_visit.set_first_obs';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
        --
        l_monit_vs_list_cnt := l_monitorization_vs_list.count;
    
        FOR i IN 1 .. l_monit_vs_list_cnt
        LOOP
        
            rec_record.id_record := l_monitorization_vs_list(i);
        
            l_message := 'CALL pk_alerts.delete_sys_alert_event id_record: ' || l_monitorization_vs_list(i);
            pk_alertlog.log_debug(l_message);
            IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => rec_record,
                                                    o_error           => o_error)
            THEN
                pk_alert_exceptions.reset_error_state;
                pk_utils.undo_changes;
                RETURN FALSE;
            END IF;
        END LOOP;
    
        l_message := 'CALL pk_alerts.delete_sys_alert_event';
        IF NOT create_alert_vital_sign(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       i_monitorization => i_id_monit,
                                       o_error          => o_error)
        THEN
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
    
        -- Commit transactions
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'SET_MONITOR_VS_READ',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_monitor_vs_read;
    --    
    /******************************************************************************
       OBJECTIVO:   Obter lista de realizações
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_PROF - profissional que acede
              Saida: O_TIME - lista
             O_ERROR - erro
    
      CRIAÇÃO: CRS 2005/08/02
      NOTAS:
    *********************************************************************************/
    FUNCTION get_monit_time
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_time  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
    BEGIN
        l_message := 'GET CURSOR';
        OPEN o_time FOR
            SELECT val,
                   desc_val,
                   decode(pk_sysconfig.get_config('FLG_TIME_E', i_prof.institution, i_prof.software),
                          val,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_default
              FROM sys_domain
             WHERE id_language = i_lang
               AND code_domain = c_domain_monit_time
               AND flg_available = pk_alert_constant.g_yes
             ORDER BY rank, desc_val;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONIT_TIME',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_time);
            RETURN FALSE;
    END get_monit_time;

    /******************************************************************************
       OBJECTIVO: Obter concatenação dos descritivos dos SVs requisitados numa monitorização
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
               I_MONITORIZATION - ID da monitorização
                             I_PROF - profissional
                             i_flg_only_active - Y - Do not return cancelled registries. N - returns records in all status
              Saida: O_DESC - concatenação dos descritivos dos SVs
                         O_ERROR - erro
      CRIAÇÃO: CRS 2006/09/05
      NOTAS:
    *********************************************************************************/
    FUNCTION get_vs_desc
    (
        i_lang            IN language.id_language%TYPE,
        i_monitorization  IN monitorization.id_monitorization%TYPE,
        i_prof            IN profissional,
        i_flg_only_active IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN VARCHAR2 IS
        CURSOR c_vs IS
            SELECT pk_translation.get_translation(i_lang, vs.code_vital_sign) desc_vs
              FROM monitorization m, monitorization_vs mvs, vital_sign vs
             WHERE mvs.id_monitorization = m.id_monitorization
               AND m.id_monitorization = i_monitorization
               AND vs.id_vital_sign = mvs.id_vital_sign
               AND ((i_flg_only_active = pk_alert_constant.g_yes AND
                   mvs.flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_inte)) OR
                   i_flg_only_active = pk_alert_constant.g_no)
             ORDER BY desc_vs;
        l_aux VARCHAR2(4000);
    
    BEGIN
        FOR r_vs IN c_vs
        LOOP
            IF nvl(l_aux, '#') = '#'
            THEN
                l_aux := r_vs.desc_vs;
            ELSE
                l_aux := l_aux || ', ' || r_vs.desc_vs;
            END IF;
        END LOOP;
    
        RETURN l_aux;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_vs_desc;
    --
    /**********************************************************************************************
    * Actualizar o episódio de origem na monitorização de sinais vitais bem como as respectivas tabelas de relação.
      Aquando a passagem de Urgência para Internamento será necessário actualizar o ID_EPISODE na monitorização de sinais vitais
      com o novo episódio (INP) e o ID_EPISODE_ORIGIN ficará com o episódio de urgência (EDIS)
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_prof_cat_type          category of professional
    * @param i_episode                episode id
    * @param i_new_episode            new episode id 
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2007/02/19
    **********************************************************************************************/
    FUNCTION update_monitorization
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_episode       IN episode.id_episode%TYPE,
        i_new_episode   IN episode.id_episode%TYPE,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        -- Alert® Data Governance
        l_where_clause VARCHAR2(1000);
        l_rowids_m     table_varchar := table_varchar();
    
    BEGIN
        l_message      := 'UPDATE MONITORIZATION - ID_EPISODE and ID_PREV_EPISODE';
        l_where_clause := 'ID_EPISODE = ' || i_episode || ' AND FLG_STATUS NOT IN (''' ||
                          pk_alert_constant.g_monitor_vs_canc || ''', ''' || pk_alert_constant.g_monitor_vs_fini ||
                          ''' )';
        ts_monitorization.upd(id_episode_in      => i_new_episode,
                              id_prev_episode_in => i_episode,
                              where_in           => l_where_clause,
                              rows_out           => l_rowids_m);
    
        -- Alert® Data Governance
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowids_m,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'UPDATE_MONITORIZATION',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END update_monitorization;

    /***********************************************************************************************
    *
    * From now on, these functions were cretead in the CPOE context
    
    ***********************************************************************************************/

    /**********************************************************************************************
    * validate the request of the monitorization
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_monit                  monitorization type
    *
    * @return      varchar2                 'Y' on success, otherwise 'N'
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/17
    **********************************************************************************************/
    FUNCTION validate_monitor_req2
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_monitorization IN monitorization.id_monitorization%TYPE
    ) RETURN VARCHAR2 IS
        l_error                t_error_out;
        l_monit                monit;
        l_flg_prof_need_cosign sys_domain.val%TYPE;
    
    BEGIN
        IF NOT init_monit(i_lang              => i_lang,
                          i_prof              => i_prof,
                          i_id_monitorization => i_monitorization,
                          io_monit            => l_monit,
                          o_error             => l_error)
        THEN
            RETURN pk_alert_constant.g_no;
        END IF;
    
        IF l_monit.flg_status != pk_alert_constant.g_monitor_vs_draft
        THEN
            RETURN pk_alert_constant.g_no;
        ELSE
            IF l_monit.id_co_sign_order IS NULL
            THEN
                -- check if prof needs co-sign
                IF pk_co_sign_api.check_prof_needs_cosign(i_lang                   => i_lang,
                                                          i_prof                   => i_prof,
                                                          i_episode                => l_monit.id_epis,
                                                          i_task_type              => pk_alert_constant.g_task_monitoring,
                                                          i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_add,
                                                          o_flg_prof_need_cosign   => l_flg_prof_need_cosign,
                                                          o_error                  => l_error)
                THEN
                    IF l_flg_prof_need_cosign = pk_alert_constant.g_yes
                    THEN
                        RETURN pk_alert_constant.g_yes;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        IF NOT (validate_monitor_req(i_lang, i_prof, l_monit, l_error))
        THEN
            RETURN pk_alert_constant.g_yes;
        ELSE
            RETURN pk_alert_constant.g_no;
        END IF;
    END validate_monitor_req2;

    /******************************************************************************************** 
    * initialize the arrays of the messages
    * 
    * @param       o_flg_conflict            array of draft conflicts indicators 
    * @param       o_msg_title               array of message titles 
    * @param       o_msg_text                array of message texts 
    * @param       o_button                  array of buttons to show   
    * 
    *         
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/20
    ********************************************************************************************/
    FUNCTION init_conflit_ret
    (
        o_flg_conflict IN OUT table_varchar,
        o_msg_title    IN OUT table_varchar,
        o_msg_text     IN OUT table_varchar,
        o_button       IN OUT table_varchar
    ) RETURN BOOLEAN IS
    BEGIN
        o_flg_conflict.extend;
        o_msg_title.extend;
        o_msg_text.extend;
        o_button.extend;
    
        RETURN TRUE;
    END init_conflit_ret;

    /******************************************************************************************** 
    * check conflicts upon created drafts (verify if drafts can be requested or not) 
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id  
    * @param       i_draft                   draft id 
    * @param       o_flg_conflict            array of draft conflicts indicators 
    * @param       o_msg_title               array of message titles 
    * @param       o_msg_text                array of message texts 
    * @param       o_button                  array of buttons to show (it can have more than one button) 
    * @param       o_error                   error message 
    * 
    * @value       o_flg_conflict            {*} 'Y' the draft has conflicts  
    *                                        {*} 'N' no conflicts found 
    *    
    * @value       o_button                  {*} 'N' NO button is displayed 
    *                                        {*} 'R' READ button is displayed    
    *                                        {*} 'C' CONFIRM button is displayed 
    *                                        {*} Example: 'NC' NO/CONFIRM buttons are displayed 
    *         
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/18
    ********************************************************************************************/
    FUNCTION check_drafts_conflicts
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_draft        IN table_number,
        o_flg_conflict OUT table_varchar,
        o_msg_title    OUT table_varchar,
        o_msg_text     OUT table_varchar,
        o_button       OUT table_varchar,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_monit monit;
    
    BEGIN
        o_flg_conflict := table_varchar();
        o_msg_title    := table_varchar();
        o_msg_text     := table_varchar();
        o_button       := table_varchar();
    
        FOR i IN 1 .. i_draft.count
        LOOP
        
            IF NOT init_monit(i_lang              => i_lang,
                              i_prof              => i_prof,
                              i_id_monitorization => i_draft(i),
                              io_monit            => l_monit,
                              o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            IF NOT init_conflit_ret(o_flg_conflict, o_msg_title, o_msg_text, o_button)
            THEN
                RAISE l_exception;
            END IF;
        
            IF NOT validate_monitor_req(i_lang, i_prof, l_monit, o_error)
            THEN
                --TODO: confirm this
                o_flg_conflict(i) := pk_alert_constant.g_yes;
                o_msg_title(i) := 'msg' || i; -- TODO: review this message
                o_msg_text(i) := o_error.err_desc;
                o_button(i) := 'R'; -- TODO: use pk_alert_constant
            ELSE
                --TODO: confirm this
                o_flg_conflict(i) := pk_alert_constant.g_no;
                o_msg_title(i) := NULL;
                o_msg_text(i) := NULL;
                o_button(i) := 'NC'; -- TODO: use pk_alert_constant
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'CHECK_DRAFTS_CONFLICTS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END check_drafts_conflicts;

    /**********************************************************************************************
    * create monitorization_vs
    *
    * @param   i_lang                   preferred language id for this professional
    * @param   i_prof                   professional type
    * @param   io_monit                 monitorization type
    * @param   o_next_id_mvs            monitorization_vs id
    * @param   o_rows_out               rows 
    * @param   o_error                  error message
    *
    * @return  boolean                  true on success, otherwise false
    *
    * @author                           Filipe Machado
    * @version                          2.5.0.7.3
    * @since                            2009/11/18
    **********************************************************************************************/
    FUNCTION create_monitor_vs
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_idx         IN NUMBER,
        io_monit      IN OUT NOCOPY monit,
        o_next_id_mvs OUT monitorization_vs.id_monitorization_vs%TYPE,
        o_rows_out    OUT table_varchar,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_rowids_aux table_varchar;
        next_id_mvs  monitorization_vs.id_monitorization_vs%TYPE;
    
    BEGIN
        -- Monitorization VS
        ts_monitorization_vs.ins(id_monitorization_vs_out     => next_id_mvs,
                                 dt_monitorization_vs_tstz_in => l_sysdate_tstz,
                                 id_monitorization_in         => io_monit.id_monit,
                                 id_vital_sign_in             => io_monit.id_vs(i_idx),
                                 flg_status_in                => io_monit.flg_status_det,
                                 dt_order_in                  => get_tstz_date(i_lang, i_prof, io_monit.dt_order_str),
                                 --  id_prof_order_in             => io_monit.id_prof_order,
                                 --  id_order_type_in             => io_monit.id_order_type,
                                 rows_out => l_rowids_aux);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids_aux,
                                      o_error      => o_error);
    
        o_rows_out    := l_rowids_aux;
        o_next_id_mvs := next_id_mvs;
    
        pk_translation.insert_translation_trs(i_lang   => i_lang,
                                              i_code   => g_trs_monit_vs_notes || next_id_mvs,
                                              i_desc   => io_monit.notes,
                                              i_module => 'MONITORIZATION_VS');
    
        RETURN TRUE;
    
    END create_monitor_vs;

    /**********************************************************************************************
    * create monitorization_vs_plan
    *
    * @param   i_lang                   preferred language id for this professional
    * @param   i_prof                   professional type
    * @param   io_monit                 monitorization type
    * @param   o_error                  error message
    *
    * @return  boolean                  true on success, otherwise false
    *
    * @author                           Filipe Machado
    * @version                          2.5.0.7.3
    * @since                            2009/11/18
    **********************************************************************************************/
    FUNCTION create_monitor_vs_plan
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        i_id_mvs IN monitorization_vs.id_monitorization_vs%TYPE,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dt_begin_final TIMESTAMP WITH LOCAL TIME ZONE;
        l_rowsid         table_varchar := table_varchar();
        l_status_ss      monitorization_vs_plan.flg_status%TYPE;
    
    BEGIN
        -- Monitorization Planning
        l_dt_begin_final := nvl(b1 => get_tstz_date(i_lang => i_lang,
                                                    i_prof => i_prof,
                                                    i_date => io_monit.dt_begin_final_str),
                                b2 => g_sysdate_tstz);
    
        l_status_ss := CASE io_monit.flg_status
                           WHEN pk_alert_constant.g_monitor_vs_draft THEN
                            pk_alert_constant.g_monitor_vs_draft
                           ELSE
                            CASE io_monit.flg_time
                                WHEN pk_alert_constant.g_flg_time_n THEN
                                 pk_alert_constant.g_monitor_vs_pend
                                ELSE
                                 CASE sign(extract(DAY FROM(l_dt_begin_final - g_sysdate_tstz)))
                                     WHEN 1 THEN
                                      pk_alert_constant.g_monitor_vs_pend
                                     ELSE
                                      pk_alert_constant.g_monitor_vs_exec
                                 END
                            END
                       END;
    
        ts_monitorization_vs_plan.ins(id_monitorization_vs_in => i_id_mvs,
                                      dt_plan_tstz_in         => l_dt_begin_final,
                                      flg_status_in           => l_status_ss,
                                      rows_out                => l_rowsid);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    END create_monitor_vs_plan;

    /**********************************************************************************************
    * create draft task (CPOE purpose)
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_episode                episode id
    * @param       io_monit                 monitorization type
    * @param       o_draft                  list of created drafts
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/17
    **********************************************************************************************/
    FUNCTION create_draft
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        io_monit  IN OUT NOCOPY monit,
        o_draft   OUT table_number,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        l_exception EXCEPTION;
        next_id_mvs monitorization_vs.id_monitorization_vs%TYPE;
    
        l_id_monitorization_vs_plan monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_rowsid_plan               table_varchar := table_varchar();
        l_rowids                    table_varchar;
        l_rowids_aux                table_varchar;
    
        l_flg_profile     profile_template.flg_profile%TYPE;
        l_sys_alert_event sys_alert_event%ROWTYPE;
    
    BEGIN
        IF NOT validate_monitor_req(i_lang, i_prof, io_monit, o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        l_flg_profile := nvl(pk_hand_off_core.get_flg_profile(i_lang, i_prof, NULL), '#');
    
        io_monit.flg_status     := pk_alert_constant.g_monitor_vs_draft;
        io_monit.flg_status_det := pk_alert_constant.g_monitor_vs_draft; --flg_status of the monitorization_vs
    
        l_message := 'CALL TO PK_MONITORIZATION.CREATE_DRAFT - create_monitor';
        IF NOT (create_monitor(i_lang, i_prof, io_monit, o_error))
        THEN
            RAISE l_exception;
        END IF;
    
        -- For the copy to draft action no co-sign will be generated, keeping this as a comment for a while
        --        l_message := 'CALL CREATE_CO_SIGN_TASK - CREATE CO-SIGN RECORD TO THE CURRENT MONIT';
        --create co-sign task
        --io_monit.flg_monitorization_action := pk_monitorization.g_draft_action;
        IF io_monit.flg_monitorization_action = pk_monitorization.g_draft_action
        THEN
            IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        FOR i IN 1 .. io_monit.id_vs.count
        LOOP
            l_message := 'CALL TO PK_MONITORIZATION.CREATE_DRAFT - ts_monitorization_vs.ins';
        
            -- Monitorization Vital Sign (monitorization_vs)
            IF NOT create_monitor_vs(i_lang, i_prof, i, io_monit, next_id_mvs, l_rowids_aux, o_error)
            THEN
                RAISE l_exception;
            ELSE
                l_rowids := l_rowids MULTISET UNION DISTINCT l_rowids_aux;
            END IF;
        
            -- Monitorization Planning (monitorization_vs_plan)
            IF NOT create_monitor_vs_plan(i_lang, i_prof, next_id_mvs, io_monit, o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            l_message := 'CALL TO PK_MONITORIZATION.CREATE_DRAFT - get id_monitorization_vs_plan';
            SELECT mp.id_monitorization_vs_plan
              INTO l_id_monitorization_vs_plan
              FROM monitorization_vs mvs
              JOIN monitorization_vs_plan mp
                ON mp.id_monitorization_vs = mvs.id_monitorization_vs
             WHERE mvs.id_monitorization_vs = next_id_mvs
               AND mvs.id_vital_sign = io_monit.id_vs(i);
        
            l_message := 'CALL TO PK_MONITORIZATION.CREATE_DRAFT - ts_monitorization_vs_plan.upd';
            ts_monitorization_vs_plan.upd(id_monitorization_vs_plan_in => l_id_monitorization_vs_plan,
                                          id_prof_performed_in         => i_prof.id,
                                          start_time_in                => current_timestamp,
                                          end_time_in                  => current_timestamp,
                                          rows_out                     => l_rowsid_plan);
        
        END LOOP;
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
        o_draft := table_number(io_monit.id_monit);
    
        IF l_flg_profile = pk_prof_utils.g_flg_profile_template_student
        THEN
            l_sys_alert_event.id_sys_alert    := pk_alert_constant.g_alert_cpoe_draft;
            l_sys_alert_event.id_software     := i_prof.software;
            l_sys_alert_event.id_institution  := i_prof.institution;
            l_sys_alert_event.id_episode      := io_monit.id_epis;
            l_sys_alert_event.id_patient      := pk_episode.get_epis_patient(i_lang    => i_lang,
                                                                             i_prof    => i_prof,
                                                                             i_episode => io_monit.id_epis);
            l_sys_alert_event.id_record       := io_monit.id_epis;
            l_sys_alert_event.id_visit        := pk_visit.get_visit(i_episode => io_monit.id_epis, o_error => o_error);
            l_sys_alert_event.dt_record       := current_timestamp;
            l_sys_alert_event.id_professional := pk_hand_off.get_episode_responsible(i_lang       => i_lang,
                                                                                     i_prof       => i_prof,
                                                                                     i_id_episode => io_monit.id_epis,
                                                                                     o_error      => o_error);
        
            IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => l_sys_alert_event,
                                                    o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CREATE_DRAFT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END create_draft;

    /**********************************************************************************************
    * create draft task (CPOE purpose)
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_episode                episode id
    * @param       ...                      monitorization 
    * @param       o_draft                  list of created drafts
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.5
    * @since                                2009/12/14
    **********************************************************************************************/
    FUNCTION create_draft
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN monitorization.id_episode%TYPE,
        i_dt_begin_str  IN VARCHAR2,
        i_interval      IN VARCHAR2,
        i_dt_end_str    IN VARCHAR2,
        i_notes         IN CLOB,
        i_flg_time      IN monitorization.flg_time%TYPE,
        i_id_vs         IN table_number,
        i_notes_detail  IN table_varchar,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_prof_order    IN monitorization_vs.id_prof_order%TYPE := NULL,
        i_dt_order_str  IN VARCHAR2 := NULL,
        i_order_type    IN monitorization_vs.id_order_type%TYPE := NULL,
        o_draft         OUT table_number,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        io_monit monit;
        l_draft  table_number;
    
    BEGIN
        io_monit := monit(id_monit                  => NULL,
                          id_prof                   => i_prof.id,
                          id_inst                   => i_prof.institution,
                          id_soft                   => i_prof.software,
                          id_epis                   => i_episode,
                          notes                     => i_notes,
                          flg_time                  => i_flg_time,
                          dt_order_str              => i_dt_order_str,
                          dt_begin_str              => i_dt_begin_str,
                          dt_end_str                => i_dt_end_str,
                          dt_begin_final_str        => i_dt_begin_str,
                          INTERVAL                  => i_interval,
                          interval_final            => NULL,
                          id_vs                     => i_id_vs,
                          notes_detail              => i_notes_detail,
                          flg_status                => pk_alert_constant.g_monitor_vs_exec,
                          flg_status_det            => pk_alert_constant.g_monitor_vs_exec,
                          id_order_type             => i_order_type,
                          id_prof_order             => i_prof_order,
                          flg_monitorization_action => pk_monitorization.g_draft_action,
                          id_co_sign_order          => NULL,
                          id_co_sign_cancel         => NULL);
    
        IF NOT create_draft(i_lang    => i_lang,
                            i_prof    => i_prof,
                            i_episode => i_episode,
                            io_monit  => io_monit,
                            o_draft   => l_draft,
                            o_error   => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'CREATE_DRAFT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END create_draft;

    /**********************************************************************************************
    * cancel = delete a draft task (CPOE purpose)
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_episode                episode id
    * @param          i_draft                  list of draft ids
    * @param          o_error                  error message
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.3
    * @since                                   2009/11/17
    **********************************************************************************************/
    FUNCTION cancel_draft
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        i_draft   IN table_number,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message              debug_msg;
        l_id_monitorization_vs table_number;
    
    BEGIN
        FOR i IN 1 .. i_draft.count
        LOOP
            SELECT id_monitorization_vs
              BULK COLLECT
              INTO l_id_monitorization_vs
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = i_draft(i)
               AND mvs.flg_status = pk_alert_constant.g_monitor_vs_draft;
        
            FOR j IN 1 .. l_id_monitorization_vs.count
            LOOP
                l_message := 'CALL TO PK_MONITORIZATION.CANCEL_DRAFT - delete monitorization_vs_plan';
                ts_monitorization_vs_plan.del_mvsp_mvs_fk(id_monitorization_vs_in => l_id_monitorization_vs(j));
            END LOOP;
        
            l_message := 'CALL TO PK_MONITORIZATION.CANCEL_DRAFT - delete monitorization_vs';
            ts_monitorization_vs.del_mvs_mont_fk(id_monitorization_in => i_draft(i));
        
            l_message := 'CALL TO PK_MONITORIZATION.CANCEL_DRAFT - delete monitorization';
            ts_monitorization.del(id_monitorization_in => i_draft(i));
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_DRAFT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_draft;

    /**********************************************************************************************
    * get actions (CPOE purpose)
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_episode                episode id
    * @param       i_task_request           task request id (monitorization id)
    * @param       o_actions                actions cursor info 
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/18
    **********************************************************************************************/
    FUNCTION get_actions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_actions      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
    
        CURSOR c_monit IS
            SELECT m.flg_status, m.flg_time, m.dt_begin_tstz
              FROM monitorization m
             WHERE m.id_monitorization = i_task_request(1);
    
        l_flg_status    monitorization.flg_status%TYPE;
        l_flg_time      monitorization.flg_time%TYPE;
        l_dt_begin_tstz monitorization.dt_begin_tstz%TYPE;
    
        l_to_state            action.to_state%TYPE := NULL;
        l_allow_execs_expired VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
        l_to_state_exec       action.to_state%TYPE := 'E';
    
        l_ehr_access_area CONSTANT tl_task.ehr_access_area%TYPE := 'VS';
        l_permission VARCHAR2(1 CHAR) := pk_alert_constant.g_active;
    
        l_internal_error EXCEPTION;
    
        l_error VARCHAR2(2000);
        l_count NUMBER(12);
    BEGIN
    
        IF i_task_request.count = 1
        THEN
            OPEN c_monit;
            FETCH c_monit
                INTO l_flg_status, l_flg_time, l_dt_begin_tstz;
            CLOSE c_monit;
        
            l_error := 'CALL pk_ehr_access.check_area_create_permission';
            IF NOT pk_ehr_access.check_area_create_permission(i_lang    => i_lang,
                                                              i_prof    => i_prof,
                                                              i_episode => i_episode,
                                                              i_area    => l_ehr_access_area,
                                                              o_val     => l_permission,
                                                              o_error   => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            l_error               := 'CHECK EXEC PERMISSIONS';
            l_allow_execs_expired := check_exec_monit(i_lang              => i_lang,
                                                      i_prof              => i_prof,
                                                      i_episode           => i_episode,
                                                      i_id_monitorization => i_task_request(1),
                                                      i_flg_time          => l_flg_time,
                                                      i_flg_status        => l_flg_status,
                                                      i_dt_begin_tstz     => l_dt_begin_tstz,
                                                      i_flg_check_actions => pk_alert_constant.g_no);
        
            l_error := 'CHECK EXEC PERMISSIONS';
            IF l_flg_status = pk_alert_constant.g_monitor_vs_pend
               AND l_allow_execs_expired = pk_alert_constant.g_no
            THEN
                l_to_state := l_flg_status;
            END IF;
        
            l_error := 'CALL PK_ACTION.TF_GET_ACTIONS';
            OPEN o_actions FOR
                SELECT id_action,
                       id_parent,
                       level_nr,
                       l_flg_status from_state,
                       to_state,
                       desc_action,
                       icon,
                       flg_default,
                       CASE
                            WHEN l_permission = pk_alert_constant.g_no THEN
                             pk_alert_constant.g_inactive
                            ELSE
                             CASE
                                 WHEN to_state = pk_alert_constant.g_monitor_vs_pend
                                      AND l_flg_status = pk_alert_constant.g_monitor_vs_pend
                                      AND l_to_state IS NOT NULL THEN
                                  pk_alert_constant.g_inactive
                                 WHEN to_state = l_to_state_exec
                                      AND l_flg_status = pk_alert_constant.g_monitor_vs_expire
                                      AND l_allow_execs_expired = pk_alert_constant.g_no THEN
                                  pk_alert_constant.g_inactive
                                 ELSE
                                  flg_active
                             END
                        END flg_active,
                       action
                  FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, c_action_monitorization, l_flg_status)) act;
        ELSE
            SELECT COUNT(1)
              INTO l_count
              FROM monitorization m
             WHERE m.id_monitorization IN (SELECT /*+ OPT_ESTIMATE (TABLE d ROWS=1)*/
                                            column_value
                                             FROM TABLE(i_task_request) d)
               AND m.flg_status IN (pk_alert_constant.g_cancelled, pk_alert_constant.g_inactive);
            -- if there's at least one cancelled OR inactive, don't enable cancel option
            IF l_count = 0
            THEN
                -- multiple records, only cancel option is available
                l_error := 'CALL PK_ACTION.TF_GET_ACTIONS';
                OPEN o_actions FOR
                    SELECT act.id_action,
                           act.id_parent,
                           act.level_nr,
                           pk_alert_constant.g_active from_state,
                           act.to_state,
                           act.desc_action,
                           act.icon,
                           act.flg_default,
                           act.flg_active,
                           act.action
                      FROM TABLE(pk_action.tf_get_actions(i_lang,
                                                          i_prof,
                                                          c_action_monitorization,
                                                          pk_alert_constant.g_active)) act
                     WHERE act.action = 'CANCEL_MONIT';
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_ACTIONS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_actions;

    /**********************************************************************************************
    * get task parameters (CPOE purpose)
    * in other words, get task parameters needed to fill task edit screens (critical for draft editing)
    *
    * NOTE: this function can be replaced by several functions that returns the required values,  
    *       according to current task workflow edit screens
    *
    * @param           i_lang                   preferred language id for this professional
    * @param           i_prof                   professional type
    * @param           i_episode                episode id
    * @param           i_id_monitorization      monitorization id
    * @param           o_monitor                monitorization cursor info 
    * @param           o_actions                actions cursor info
    * @param           o_error                  error message
    *
    * @return          boolean                  true on success, otherwise false
    *
    * @author                                   Filipe Machado
    * @version                                  2.5.0.7.3
    * @since                                    2009/11/17
    **********************************************************************************************/
    FUNCTION get_task_parameters
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_episode           IN episode.id_episode%TYPE,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        o_monitor           OUT pk_types.cursor_type,
        o_actions           OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        l_exception EXCEPTION;
        l_timezone      timezone_region.timezone_region%TYPE;
        l_id_visit      visit.id_visit%TYPE;
        l_id_epis_type  episode.id_epis_type%TYPE;
        l_sign_off_t034 sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'SIGN_OFF_T034');
        l_sign_off_t014 sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'SIGN_OFF_T014');
    
    BEGIN
        IF NOT pk_date_utils.get_timezone(i_lang     => i_lang,
                                          i_prof     => i_prof,
                                          i_timezone => NULL,
                                          o_timezone => l_timezone,
                                          o_error    => o_error)
        THEN
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        END IF;
    
        IF NOT get_visit(i_lang, i_episode, l_id_visit, l_id_epis_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_message := 'GET CURSOR o_monitor';
        OPEN o_monitor FOR
            SELECT m.id_monitorization,
                   m.flg_status,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, m.id_professional) nick_name,
                   pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS', m.flg_status, i_lang) desc_status,
                   concat_monit_vs(i_lang, i_prof, l_id_visit, l_id_epis_type, m.id_monitorization) task_description,
                   m.flg_time,
                   pk_sysdomain.get_domain('MONITORIZATION.FLG_TIME', m.flg_time, i_lang) desc_time,
                   pk_date_utils.get_timestamp_str(i_lang, i_prof, m.dt_monitorization_tstz, NULL) date_req,
                   
                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                    m.dt_monitorization_tstz,
                                                    i_prof.institution,
                                                    i_prof.software) hour_req,
                   decode(m.flg_time,
                          pk_alert_constant.g_flg_time_n,
                          NULL,
                          pk_date_utils.get_timestamp_str(i_lang,
                                                          i_prof,
                                                          nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                          NULL)) date_begin,
                   decode(m.flg_time,
                          pk_alert_constant.g_flg_time_n,
                          pk_message.get_message(i_lang, 'COMMON_M018'),
                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                           nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                           i_prof.institution,
                                                           i_prof.software)) hour_begin,
                   decode(m.flg_time,
                          pk_alert_constant.g_flg_time_n,
                          NULL,
                          pk_date_utils.get_timestamp_str(i_lang, i_prof, m.dt_end_tstz, NULL)) date_end,
                   decode(m.flg_time,
                          pk_alert_constant.g_flg_time_n,
                          pk_message.get_message(i_lang, 'COMMON_M018'),
                          pk_date_utils.date_char_hour_tsz(i_lang, m.dt_end_tstz, i_prof.institution, i_prof.software)) hour_end,
                   get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval,
                   pk_date_utils.get_timestamp_str(i_lang, i_prof, m.dt_cancel_tstz, NULL) dt_cancel,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, m.id_prof_cancel) prof_cancel,
                   m.notes_cancel,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    m.id_professional,
                                                    m.dt_monitorization_tstz,
                                                    m.id_episode) desc_speciality,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    m.id_prof_cancel,
                                                    m.dt_monitorization_tstz,
                                                    m.id_episode) desc_speciality_cancel,
                   c.desc_prof_ordered_by prof_order,
                   pk_date_utils.get_timestamp_str(i_lang, i_prof, c.dt_ordered_by, NULL) dt_order,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, mvsp.id_prof_performed) name_performed,
                   pk_translation.get_translation_trs(m.code_notes) notes,
                   m.interval
              FROM monitorization m
              LEFT JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_order)) c
                ON c.id_co_sign = m.id_co_sign_order
            
              JOIN monitorization_vs mvs
                ON mvs.id_monitorization = m.id_monitorization
              JOIN monitorization_vs_plan mvsp
                ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
              JOIN episode e
                ON e.id_episode = m.id_episode
             WHERE e.id_visit = l_id_visit
               AND m.id_monitorization = i_id_monitorization
             ORDER BY m.id_monitorization;
    
        -- get actions 
        IF NOT get_actions(i_lang, i_prof, i_episode, table_number(i_id_monitorization), o_actions, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_TASK_PARAMETERS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_task_parameters;

    /**********************************************************************************************
    * set task parameters (CPOE purpose)
    * set task parameters changed in task edit screens (critical for draft editing)
    *   
    * NOTE: this function can be replaced by several functions that update the required values,  
    *       according to current task workflow edit screens 
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_episode                episode id
    * @param          io_monit                 monitorization type
    * @param          o_error                  error message
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.3
    * @since                                   2009/11/18
    **********************************************************************************************/
    FUNCTION set_task_parameters
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        io_monit  IN OUT NOCOPY monit,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_monitor_vs_code_notes table_varchar;
        l_monitor_vs_notes      table_clob;
        l_rowsid_vs             table_varchar := table_varchar();
        l_message               debug_msg;
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_rowsid table_varchar := table_varchar();
    BEGIN
        IF NOT validate_monitor_req(i_lang, i_prof, io_monit, o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        l_message := 'CALL TO PK_MONITORIZATION.SET_TASK_PARAMETERS - update monitorization';
        ts_monitorization.upd(id_monitorization_in      => io_monit.id_monit,
                              id_episode_in             => io_monit.id_epis,
                              flg_time_in               => io_monit.flg_time,
                              dt_begin_tstz_in          => nvl(get_tstz_date(i_lang, i_prof, io_monit.dt_begin_str),
                                                               l_sysdate_tstz),
                              dt_end_tstz_in            => get_tstz_date(i_lang, i_prof, io_monit.dt_end_str),
                              dt_end_tstz_nin           => FALSE,
                              dt_monitorization_tstz_in => l_sysdate_tstz,
                              interval_in               => io_monit.interval_final,
                              rows_out                  => l_rowsid);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        pk_translation.insert_translation_trs(i_lang   => i_lang,
                                              i_code   => g_trs_monit_notes || io_monit.id_monit,
                                              i_desc   => io_monit.notes,
                                              i_module => 'MONITORIZATION');
    
        l_message := 'CALL TO PK_MONITORIZATION.SET_TASK_PARAMETERS - update monitorization_vs';
        ts_monitorization_vs.upd(dt_order_in                  => l_sysdate_tstz,
                                 dt_monitorization_vs_tstz_in => l_sysdate_tstz,
                                 where_in                     => 'ID_MONITORIZATION = ' || io_monit.id_monit,
                                 rows_out                     => l_rowsid_vs);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowsid_vs,
                                      o_error      => o_error);
    
        l_message := 'GET CODE_NOTES FROM MONITORIZATION_VS';
        SELECT m.code_notes, io_monit.notes
          BULK COLLECT
          INTO l_monitor_vs_code_notes, l_monitor_vs_notes
          FROM monitorization_vs m
         WHERE m.id_monitorization = io_monit.id_monit;
    
        l_message := 'INSERT_TRANSLATION_TRS_BULK MONITORIZATION_VS NOTES';
        pk_translation.insert_translation_trs_bulk(i_lang   => i_lang,
                                                   i_code   => l_monitor_vs_code_notes,
                                                   i_desc   => l_monitor_vs_notes,
                                                   i_module => 'MONITORIZATION_VS');
    
        -- co-sign task record
        l_message := 'UPDATE THE EXISTING CO-SIGN RECORD - ONLY THE FIELDS. THE STATE DOES NOT CHANGE.';
        --create co-sign task
        io_monit.flg_monitorization_action := pk_monitorization.g_draft_action;
        IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'SET_TASK_PARAMETERS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_task_parameters;

    /**********************************************************************************************
    * set task parameters (CPOE purpose)
    * set task parameters changed in task edit screens (critical for draft editing)
    *   
    * NOTE: this function can be replaced by several functions that update the required values,  
    *       according to current task workflow edit screens 
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_id_monitorization      monitorization id
    * @param          i_episode                episode id
    * ...
    * @param          o_error                  error message
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.5
    * @since                                   2009/12/11
    **********************************************************************************************/
    FUNCTION set_task_parameters
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_episode           IN monitorization.id_episode%TYPE,
        i_dt_begin_str      IN VARCHAR2,
        i_interval          IN VARCHAR2,
        i_dt_end_str        IN VARCHAR2,
        i_notes             IN CLOB,
        i_flg_time          IN monitorization.flg_time%TYPE,
        i_id_vs             IN table_number,
        i_notes_detail      IN table_varchar,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_prof_order        IN monitorization_vs.id_prof_order%TYPE := NULL,
        i_dt_order_str      IN VARCHAR2 := NULL,
        i_order_type        IN monitorization_vs.id_order_type%TYPE := NULL,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_id_co_sign_order  monitorization.id_co_sign_order%TYPE;
        l_id_co_sign_cancel monitorization.id_co_sign_cancel%TYPE;
        io_monit            monit;
    
    BEGIN
        BEGIN
            SELECT m.id_co_sign_order, m.id_co_sign_cancel
              INTO l_id_co_sign_order, l_id_co_sign_cancel
              FROM monitorization m
             WHERE m.id_monitorization = i_id_monitorization;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_co_sign_order  := NULL;
                l_id_co_sign_cancel := NULL;
        END;
        io_monit := monit(id_monit                  => i_id_monitorization,
                          id_prof                   => i_prof.id,
                          id_inst                   => i_prof.institution,
                          id_soft                   => i_prof.software,
                          id_epis                   => i_episode,
                          notes                     => i_notes,
                          flg_time                  => i_flg_time,
                          dt_order_str              => i_dt_order_str,
                          dt_begin_str              => i_dt_begin_str,
                          dt_end_str                => i_dt_end_str,
                          dt_begin_final_str        => i_dt_begin_str,
                          INTERVAL                  => i_interval,
                          interval_final            => NULL,
                          id_vs                     => i_id_vs,
                          notes_detail              => i_notes_detail,
                          flg_status                => pk_alert_constant.g_monitor_vs_exec,
                          flg_status_det            => pk_alert_constant.g_monitor_vs_exec,
                          id_order_type             => i_order_type,
                          id_prof_order             => i_prof_order,
                          flg_monitorization_action => pk_monitorization.g_order_action,
                          id_co_sign_order          => l_id_co_sign_order,
                          id_co_sign_cancel         => l_id_co_sign_cancel);
    
        IF NOT set_task_parameters(i_lang    => i_lang,
                                   i_prof    => i_prof,
                                   i_episode => i_episode,
                                   io_monit  => io_monit,
                                   o_error   => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'SET_TASK_PARAMETERS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_task_parameters;

    /**********************************************************************************************
    * activate a draft = change status from 'R' to 'A' (CPOE purpose)
    * in other words, activates a set of draft tasks (task goes from draft to active workflow) 
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_episode                episode id
    * @param          i_draft                  id monitorizations collection (drafts)
    * @param          i_flg_commit             transaction control
    * @param          o_created_drafts         array of created task requests
    * @param          o_error                  error message
    *
    * @value          i_flg_commit             {*} 'Y' commit/rollback the transaction
    *                                          {*} 'N' transaction control is done outside
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.3
    * @since                                   18-Nov-2009
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.1.1
    * @changed                                 15-Sep-2010 (new parameter, o_created_tasks, was added)
    **********************************************************************************************/
    FUNCTION activate_drafts
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_draft         IN table_number,
        i_flg_commit    IN VARCHAR2,
        o_created_tasks OUT table_number,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message debug_msg;
        l_exception EXCEPTION;
    
        CURSOR c_monitor_dates(id_monit monitorization.id_monitorization%TYPE) IS
            SELECT m.dt_monitorization_tstz, m.dt_begin_tstz, m.dt_end_tstz, m.dt_cancel_tstz, m.id_professional
              FROM monitorization m
             WHERE m.id_monitorization = id_monit;
    
        CURSOR c_monitor_vs(id_monit monitorization.id_monitorization%TYPE) IS
            SELECT ROWID, id_monitorization_vs, id_prof_order, flg_co_sign, id_prof_co_sign, id_vital_sign
              FROM monitorization_vs
             WHERE id_monitorization = id_monit;
    
        r_monitor_dates      c_monitor_dates%ROWTYPE;
        l_dt_begin           TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_end             TIMESTAMP WITH LOCAL TIME ZONE;
        l_prof_cat_type      category.flg_type%TYPE;
        l_rowids             table_varchar;
        l_rowsid_m           table_varchar := table_varchar();
        l_rowsid             table_varchar := table_varchar();
        l_id_request         table_number := table_number();
        l_id_task            table_number := table_number();
        l_id_icnp_sug_interv table_number := table_number();
        io_monit             monit;
        g_exception EXCEPTION;
        l_rowsid_vs       table_varchar := table_varchar();
        l_rowsid_plan     table_varchar := table_varchar();
        l_task_type       cpoe_task_type.id_task_type%TYPE;
        l_count_rel_tasks NUMBER;
    
        l_draft          table_number;
        l_id_request_val interv_presc_det.id_interv_presc_det%TYPE;
    
    BEGIN
        l_prof_cat_type := pk_prof_utils.get_category(i_lang, i_prof => i_prof);
        l_rowids        := table_varchar();
    
        o_created_tasks := i_draft;
    
        FOR i IN 1 .. i_draft.count
        LOOP
        
            OPEN c_monitor_dates(i_draft(i));
            FETCH c_monitor_dates
                INTO r_monitor_dates;
            CLOSE c_monitor_dates;
        
            l_task_type := pk_cpoe.g_task_type_monitorization;
        
            BEGIN
                SELECT a.id_task_orig
                  INTO l_count_rel_tasks
                  FROM cpoe_tasks_relation a
                 WHERE a.id_task_dest = i_draft(i)
                   AND a.id_task_type = l_task_type
                   AND a.flg_type = 'AD';
            EXCEPTION
                WHEN no_data_found THEN
                    l_count_rel_tasks := 0;
            END;
        
            IF l_count_rel_tasks > 0
            THEN
                SELECT m.dt_end_tstz
                  INTO l_dt_end
                  FROM monitorization m
                 WHERE m.id_monitorization = l_count_rel_tasks;
            END IF;
        
            IF l_count_rel_tasks > 0
               AND (l_dt_end IS NULL OR (l_dt_end IS NOT NULL AND l_dt_end > g_sysdate_tstz))
            THEN
            
                IF NOT pk_cpoe.sync_active_to_next(i_lang      => i_lang,
                                                   i_prof      => i_prof,
                                                   i_episode   => i_episode,
                                                   i_task_type => l_task_type,
                                                   i_request   => i_draft(i),
                                                   o_error     => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                l_draft := i_draft;
            
                FOR i IN 1 .. l_draft.count
                LOOP
                    IF l_draft(i) = i_draft(i)
                    THEN
                        SELECT a.id_task_orig
                          INTO l_id_request_val
                          FROM cpoe_tasks_relation a
                         WHERE a.id_task_dest = i_draft(i);
                        l_draft(i) := l_id_request_val;
                    END IF;
                END LOOP;
            
                IF NOT cancel_draft(i_lang    => i_lang,
                                    i_prof    => i_prof,
                                    i_episode => i_episode,
                                    i_draft   => table_number(i_draft(i)),
                                    o_error   => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                o_created_tasks := l_draft;
            
                RETURN TRUE;
            END IF;
        
            -- if the dt_begin is in the past, then will be updated for current time
            IF r_monitor_dates.dt_begin_tstz < l_sysdate_tstz
            THEN
                l_dt_begin := l_sysdate_tstz;
            ELSE
                l_dt_begin := r_monitor_dates.dt_begin_tstz;
            END IF;
        
            -- if the dt_end is in the past, then will be updated for null
            IF r_monitor_dates.dt_begin_tstz < l_sysdate_tstz
            THEN
                l_dt_end := NULL;
            ELSE
                l_dt_end := r_monitor_dates.dt_end_tstz;
            END IF;
        
            l_message := 'CALL TO PK_MONITORIZATION.ACTIVE_DRAFT - update monitorization';
            ts_monitorization.upd(id_monitorization_in      => i_draft(i),
                                  flg_status_in             => pk_alert_constant.g_monitor_vs_exec,
                                  dt_begin_tstz_in          => l_dt_begin,
                                  dt_end_tstz_in            => l_dt_end,
                                  id_professional_in        => i_prof.id,
                                  dt_monitorization_tstz_in => l_sysdate_tstz,
                                  rows_out                  => l_rowsid_m);
        
            --CO-SIGN Creation workflow
            l_message := 'CREATE MONIT OBJECT';
            IF NOT init_monit(i_lang              => i_lang,
                              i_prof              => i_prof,
                              i_id_monitorization => i_draft(i),
                              io_monit            => io_monit,
                              o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            l_message                          := 'CALL SET_CO_SIGN_ORDER_WF';
            io_monit.flg_monitorization_action := g_activate_draft_action;
            IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            l_message := 'CALL TO PK_MONITORIZATION.ACTIVE_DRAFT - update monitorization_vs';
            ts_monitorization_vs.upd(flg_status_in                => pk_alert_constant.g_monitor_vs_exec,
                                     dt_order_in                  => l_sysdate_tstz,
                                     dt_monitorization_vs_tstz_in => l_sysdate_tstz,
                                     id_prof_order_in             => i_prof.id,
                                     where_in                     => 'ID_MONITORIZATION = ' || i_draft(i),
                                     rows_out                     => l_rowsid_vs);
        
            l_message := 'CALL t_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS',
                                          i_rowids     => l_rowsid_vs,
                                          o_error      => o_error);
        
            FOR j IN c_monitor_vs(i_draft(i))
            LOOP
            
                -- the co-sign control info will be updated/removed
                /* ts_monitorization_vs.upd(flg_co_sign_in      => pk_alert_constant.g_no,
                                         id_prof_co_sign_in  => NULL,
                                         id_prof_co_sign_nin => FALSE,
                                         dt_co_sign_in       => NULL,
                                         dt_co_sign_nin      => FALSE,
                                         notes_co_sign_in    => NULL,
                                         notes_co_sign_nin   => FALSE,
                where_in            => 'ID_MONITORIZATION = ' || i_draft(i));*/
            
                -- if the professional logged is a physician, the id order type (co-sign) will be removed
                -- and prof_order updated
                /*IF pk_prof_utils.get_category(i_lang, i_prof => i_prof) = pk_alert_constant.g_cat_type_doc
                THEN
                
                    ts_monitorization_vs.upd(id_order_type_in  => NULL,
                                             id_order_type_nin => FALSE,
                                             id_prof_order_in  => i_prof.id,
                                             where_in          => 'ID_MONITORIZATION = ' || i_draft(i));
                END IF;*/
            
                l_message := 'CALL TO PK_MONITORIZATION.ACTIVE_DRAFT - update monitorization_vs_plan';
                ts_monitorization_vs_plan.upd(flg_status_in        => pk_alert_constant.g_monitor_vs_exec,
                                              dt_plan_tstz_in      => nvl(l_dt_begin, l_sysdate_tstz),
                                              id_prof_performed_in => i_prof.id,
                                              where_in             => 'ID_MONITORIZATION_VS = ' ||
                                                                      j.id_monitorization_vs,
                                              rows_out             => l_rowsid_plan);
            
                -- TODO: These rules of the ALERT® Data Governance, in the near future, MUST BE in a funtion
                -- ALERT® Data Governance
                l_rowids := table_varchar();
                l_rowids.extend;
            
                l_rowids(1) := j.rowid;
            
                l_message := 'CALL t_data_gov_mnt.process_insert';
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'MONITORIZATION_VS',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            
                l_message := 'CALL TO PK_VISIT.SET_FIRST_OBS';
                IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                              i_id_episode          => i_episode,
                                              i_pat                 => NULL,
                                              i_prof                => i_prof,
                                              i_prof_cat_type       => l_prof_cat_type,
                                              i_dt_last_interaction => l_sysdate_tstz,
                                              i_dt_first_obs        => l_sysdate_tstz,
                                              o_error               => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                l_id_request.extend;
                l_id_request(l_id_request.count) := j.id_monitorization_vs;
                l_id_task.extend;
                l_id_task(l_id_request.count) := j.id_vital_sign;
            
            --/ ALERT® Data Governance
            
            END LOOP;
            l_message := 'CALL t_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS_PLAN',
                                          i_rowids     => l_rowsid_plan,
                                          o_error      => o_error);
        
            IF NOT create_alert_vital_sign(i_lang           => i_lang,
                                           i_prof           => i_prof,
                                           i_monitorization => i_draft(i),
                                           o_error          => o_error)
            THEN
                RETURN FALSE;
            END IF;
        
            IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                     i_prof                 => i_prof,
                                     i_episode              => i_episode,
                                     i_task_type            => pk_alert_constant.g_task_type_monitorization,
                                     i_task_request         => i_draft(i),
                                     i_task_start_timestamp => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                             i_prof      => i_prof,
                                                                                             i_timestamp => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                                        i_date => nvl(l_dt_begin,
                                                                                                                                                      l_sysdate_tstz),
                                                                                                                                        i_prof => i_prof),
                                                                                             i_timezone  => NULL),
                                     o_error                => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END LOOP;
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid_m,
                                      o_error      => o_error);
    
        IF i_flg_commit = pk_alert_constant.g_yes
        THEN
            COMMIT;
        END IF;
    
        pk_icnp_fo_api_db.create_suggs(i_lang               => i_lang,
                                       i_prof               => i_prof,
                                       i_id_episode         => i_episode,
                                       i_request_ids        => l_id_request,
                                       i_task_ids           => l_id_task,
                                       i_task_type_id       => pk_alert_constant.g_task_monitoring,
                                       i_sysdate_tstz       => l_sysdate_tstz,
                                       o_id_icnp_sug_interv => l_id_icnp_sug_interv);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'ACTIVATE_DRAFTS',
                                              o_error);
        
            pk_utils.undo_changes;
            RETURN FALSE;
    END activate_drafts;

    /******************************************************************************************** 
    * expire a requested task 
    * as far as we know, this is not necessary for monitorizations
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id 
    * @param       i_task_request            task request id 
    * @param       o_error                   error message 
    * 
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Nuno Neves
    * @version                               2.6.0.5.1.4
    * @since                                 2011/01/21
    ********************************************************************************************/
    FUNCTION expire_task
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_monitorization_vs table_number;
        l_flg_status_m      VARCHAR2(1);
        l_flg_status_m_vs   table_varchar;
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_rowsid table_varchar := table_varchar();
        -- Alert® Data Governance
        l_rowids      table_varchar;
        l_rowsid_plan table_varchar := table_varchar();
    BEGIN
    
        FOR i IN 1 .. i_task_request.count
        LOOP
        
            SELECT m.flg_status
              INTO l_flg_status_m
              FROM monitorization m
             WHERE m.id_monitorization = i_task_request(i);
        
            IF l_flg_status_m IS NOT NULL
            THEN
                IF l_flg_status_m = pk_alert_constant.g_monitor_vs_exec
                   OR l_flg_status_m = pk_alert_constant.g_monitor_vs_pend
                THEN
                    --'UPDATE MONITORIZATION STATUS';
                    ts_monitorization.upd(id_monitorization_in => i_task_request(i),
                                          flg_status_in        => pk_alert_constant.g_monitor_vs_expire,
                                          dt_cancel_tstz_in    => l_sysdate_tstz,
                                          id_prof_cancel_in    => i_prof.id,
                                          rows_out             => l_rowsid);
                END IF;
            END IF;
        
            -- Update monitorizations to flg_status='E' - expired
        
            SELECT mv.id_monitorization_vs, mv.flg_status
              BULK COLLECT
              INTO l_monitorization_vs, l_flg_status_m_vs
              FROM monitorization_vs mv
             WHERE mv.id_monitorization = i_task_request(i);
        
            FOR j IN 1 .. l_monitorization_vs.count
            LOOP
            
                IF l_flg_status_m_vs(j) IS NOT NULL
                THEN
                    IF l_flg_status_m_vs(j) = pk_alert_constant.g_monitor_vs_exec
                       OR l_flg_status_m_vs(j) = pk_alert_constant.g_monitor_vs_pend
                    THEN
                        --'UPDATE MONITORIZATION_VS';
                        ts_monitorization_vs.upd(id_monitorization_vs_in => l_monitorization_vs(j),
                                                 flg_status_in           => pk_alert_constant.g_monitor_vs_expire,
                                                 dt_cancel_tstz_in       => l_sysdate_tstz,
                                                 id_prof_cancel_in       => i_prof.id,
                                                 rows_out                => l_rowids);
                    
                        --'UPDATE MONITORIZATION_VS_PLAN';
                        ts_monitorization_vs_plan.upd(flg_status_in => pk_alert_constant.g_monitor_vs_expire,
                                                      where_in      => 'ID_MONITORIZATION_VS = ' ||
                                                                       l_monitorization_vs(j) || ' AND FLG_STATUS != ''' ||
                                                                       pk_alert_constant.g_monitor_vs_fini || '''',
                                                      rows_out      => l_rowsid_plan);
                    
                    END IF;
                END IF;
            
            END LOOP;
        
            --'CALL t_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END LOOP;
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        --'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => pk_prof_utils.get_category(i_lang, i_prof),
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    END expire_task;

    /******************************************************************************************** 
    * get available actions for a requested task 
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id 
    * @param       i_task_request            task request id (also used for drafts) 
    * @param       o_actions_list            list of available actions for the task request 
    * @param       o_error                   error message 
    * 
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/18
    ********************************************************************************************/
    FUNCTION get_task_actions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_actions_list OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
    
    BEGIN
        IF NOT get_actions(i_lang, i_prof, i_episode, i_task_request, o_actions_list, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_TASK_ACTIONS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_task_actions;

    /******************************************************************************************** 
    * perform a task action  
    * as far as we know, this is not necessary for monitorizations
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id 
    * @param       i_action                  action id 
    * @param       i_task_request            task request id (also used for drafts) 
    * @param       o_error                   error message 
    * 
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/18
    ********************************************************************************************/
    FUNCTION set_action
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_action       IN action.id_action%TYPE,
        i_task_request IN cpoe_process_task.id_task_request%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN TRUE;
    END set_action;

    /******************************************************************************************** 
    * copy task to draft (from an existing active/inactive task) 
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id (current episode) 
    * @param       i_task_request            task request id (used for active/inactive tasks) 
    * @param       o_draft                   draft id 
    * @param       o_error                   error message 
    * 
    * @return      boolean                   true on success, otherwise false  
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/18   
    ********************************************************************************************/
    FUNCTION copy_to_draft
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_task_request         IN cpoe_process_task.id_task_request%TYPE,
        i_task_start_timestamp IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_task_end_timestamp   IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_draft                OUT cpoe_process_task.id_task_request%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
    
        CURSOR c_monit_vs(id_monit monitorization.id_monitorization%TYPE) IS
            SELECT *
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = id_monit;
    
        l_monitorization_vs_row c_monit_vs%ROWTYPE;
    
        l_monit monit;
        l_draft table_number;
        i       NUMBER := 1;
    
        l_begin_date_tstz   monitorization.dt_begin_tstz%TYPE;
        l_dt_next_date_tstz monitorization_vs_plan.dt_plan_tstz%TYPE;
    
        l_flg_profile     profile_template.flg_profile%TYPE;
        l_sys_alert_event sys_alert_event%ROWTYPE;
        l_dt_end          cpoe_process.dt_cpoe_proc_end%TYPE;
    
    BEGIN
    
        l_flg_profile := pk_hand_off_core.get_flg_profile(i_lang, i_prof, NULL);
    
        BEGIN
            SELECT a.dt_cpoe_proc_end
              INTO l_dt_end
              FROM cpoe_process a
             WHERE a.id_episode = i_episode
               AND a.flg_status = 'A';
        EXCEPTION
            WHEN no_data_found THEN
                l_dt_end := NULL;
        END;
    
        IF NOT init_monit(i_lang                 => i_lang,
                          i_prof                 => i_prof,
                          i_id_monitorization    => i_task_request,
                          io_monit               => l_monit,
                          i_draft                => pk_alert_constant.g_yes,
                          i_task_start_timestamp => i_task_start_timestamp,
                          o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        IF i_task_start_timestamp IS NOT NULL
           OR l_dt_end IS NOT NULL
        THEN
        
            l_begin_date_tstz := pk_date_utils.get_string_tstz(i_lang, i_prof, l_monit.dt_order_str, NULL);
        
            l_dt_next_date_tstz := l_begin_date_tstz + numtodsinterval(l_monit.interval_final, 'SECOND');
        
            IF l_dt_next_date_tstz <= l_dt_end
            THEN
                l_begin_date_tstz := l_dt_next_date_tstz;
            ELSE
                WHILE l_begin_date_tstz <= i_task_start_timestamp
                LOOP
                    l_begin_date_tstz := l_begin_date_tstz + numtodsinterval(l_monit.interval_final, 'SECOND');
                END LOOP;
            END IF;
        
            l_monit.dt_begin_str       := get_str_date(i_lang, i_prof, l_begin_date_tstz);
            l_monit.dt_begin_final_str := get_str_date(i_lang, i_prof, l_begin_date_tstz);
        ELSE
            l_begin_date_tstz          := pk_date_utils.get_string_tstz(i_lang, i_prof, l_monit.dt_order_str, NULL);
            l_monit.dt_begin_str       := get_str_date(i_lang, i_prof, l_begin_date_tstz);
            l_monit.dt_begin_final_str := get_str_date(i_lang, i_prof, l_begin_date_tstz);
        END IF;
    
        -- monitorization_vs
        OPEN c_monit_vs(i_task_request);
        LOOP
            FETCH c_monit_vs
                INTO l_monitorization_vs_row;
            EXIT WHEN c_monit_vs%NOTFOUND;
            l_monit.id_vs.extend;
            l_monit.id_vs(i) := l_monitorization_vs_row.id_vital_sign;
            l_monit.id_prof_order := l_monitorization_vs_row.id_prof_order;
            l_monit.id_order_type := l_monitorization_vs_row.id_order_type;
            i := i + 1;
        END LOOP;
        CLOSE c_monit_vs;
    
        IF NOT create_draft(i_lang    => i_lang,
                            i_prof    => i_prof,
                            i_episode => i_episode,
                            io_monit  => l_monit,
                            o_draft   => l_draft,
                            o_error   => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        IF l_flg_profile = pk_prof_utils.g_flg_profile_template_student
        THEN
            l_sys_alert_event.id_sys_alert    := pk_alert_constant.g_alert_cpoe_draft;
            l_sys_alert_event.id_software     := i_prof.software;
            l_sys_alert_event.id_institution  := i_prof.institution;
            l_sys_alert_event.id_episode      := i_episode;
            l_sys_alert_event.id_patient      := pk_episode.get_epis_patient(i_lang    => i_lang,
                                                                             i_prof    => i_prof,
                                                                             i_episode => i_episode);
            l_sys_alert_event.id_record       := i_episode;
            l_sys_alert_event.id_visit        := pk_visit.get_visit(i_episode => i_episode, o_error => o_error);
            l_sys_alert_event.dt_record       := current_timestamp;
            l_sys_alert_event.id_professional := pk_hand_off.get_episode_responsible(i_lang       => i_lang,
                                                                                     i_prof       => i_prof,
                                                                                     i_id_episode => i_episode,
                                                                                     o_error      => o_error);
        
            IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => l_sys_alert_event,
                                                    o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END IF;
    
        o_draft := l_draft(1);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'COPY_TO_DRAFT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END copy_to_draft;

    /**********************************************************************************************
    * Append the monitorization vital signs in a string 
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_visit                  visit id
    * @param        i_id_epis_type           episode type id
    * @param        i_monitorization         monitoring id
    *
    * @return       varchar2                 vital signs string separated by semi-colon
    *                        
    * @author                                Tiago Silva/Filipe Machado
    * @version                               1.0
    * @since                                 2009/11/26
    **********************************************************************************************/
    FUNCTION concat_monit_vs
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_visit          IN visit.id_visit%TYPE,
        l_id_epis_type   IN episode.id_epis_type%TYPE,
        i_monitorization IN monitorization.id_monitorization%TYPE
    ) RETURN VARCHAR2 IS
        l_concat_str VARCHAR2(1000 CHAR);
        l_len_str    PLS_INTEGER := 0;
    
        l_separator     CONSTANT VARCHAR(2) := ', ';
        l_len_separator CONSTANT PLS_INTEGER := length(l_separator);
    
    BEGIN
        FOR rec IN (SELECT pk_vital_sign.get_vs_desc(i_lang, mvs.id_vital_sign) ||
                           decode(l_id_epis_type,
                                  nvl(t_ti_log.get_epis_type(i_lang,
                                                             i_prof,
                                                             e.id_epis_type,
                                                             m.flg_status,
                                                             m.id_monitorization,
                                                             pk_alert_constant.g_ti_type_mn),
                                      e.id_epis_type),
                                  '',
                                  ' - (' || pk_message.get_message(i_lang,
                                                                   profissional(i_prof.id,
                                                                                i_prof.institution,
                                                                                t_ti_log.get_epis_type_soft(i_lang,
                                                                                                            i_prof,
                                                                                                            e.id_epis_type,
                                                                                                            m.flg_status,
                                                                                                            m.id_monitorization,
                                                                                                            pk_alert_constant.g_ti_type_mn)),
                                                                   'IMAGE_T009') || ')') task_description
                      FROM monitorization m
                     INNER JOIN monitorization_vs mvs
                        ON mvs.id_monitorization = m.id_monitorization
                     INNER JOIN episode e
                        ON e.id_episode = m.id_episode
                     WHERE e.id_visit = i_visit
                       AND m.id_monitorization = i_monitorization
                     ORDER BY task_description)
        
        LOOP
        
            -- verify if string length will be greater than max buffer length
            IF (l_len_str + length(rec.task_description) + l_len_separator > 1000)
            THEN
            
                -- truncate string length
                l_concat_str := substr(l_concat_str, 1, 997) || '...';
                RETURN l_concat_str;
            ELSE
                -- concatenate task description
                l_concat_str := l_concat_str || rec.task_description || l_separator;
            
                --increment string length
                l_len_str := l_len_str + length(rec.task_description) + l_len_separator;
            END IF;
        
        END LOOP;
    
        -- remove last separator from concatenate string
        l_concat_str := substr(l_concat_str, 0, length(l_concat_str) - l_len_separator);
    
        RETURN l_concat_str;
    
    END concat_monit_vs;

    /**********************************************************************************************
    * create monitorization detail
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_commit_data            data shall be commit internal or not
    * @param          io_monit                 monitorization type
    * @param          o_error                  error message
    *
    * @value          i_commit_data            {*} 'Y' shall be commit
    *                                          {*} 'N' shall not be commit
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.3
    * @since                                   2009/11/17
    **********************************************************************************************/
    FUNCTION create_monitor_req
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_commit_data IN VARCHAR2,
        io_monit      IN OUT NOCOPY monit,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        l_exception EXCEPTION;
    
        next_id_mvs monitorization_vs.id_monitorization_vs%TYPE;
    
        l_prof_cat_type category.flg_type%TYPE;
    
        l_commit_data BOOLEAN;
    
        l_rowids     table_varchar := table_varchar();
        l_rowids_aux table_varchar;
    
        l_id_request         table_number := table_number();
        l_id_task            table_number := table_number();
        l_id_icnp_sug_interv table_number := table_number();
        l_symbol_pos         PLS_INTEGER;
        l_seconds            PLS_INTEGER;
    
        g_exception EXCEPTION;
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        l_symbol_pos := interval_has_hour_symbol(io_monit.interval);
    
        IF l_symbol_pos > 0
        THEN
            l_seconds         := get_format_interval_to_seconds(i_lang, i_prof, io_monit.interval);
            io_monit.interval := to_char(l_seconds);
        END IF;
    
        IF NOT validate_monitor_req(i_lang, i_prof, io_monit, o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF NOT create_monitor(i_lang, i_prof, io_monit, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        io_monit.flg_monitorization_action := pk_monitorization.g_order_action;
        --create co-sign task
        IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- ---- MONITORIZATION DETAIL ----
        FOR i IN 1 .. io_monit.id_vs.count
        LOOP
        
            -- Monitorization Vital Sign (monitorization_vs)
            IF NOT create_monitor_vs(i_lang, i_prof, i, io_monit, next_id_mvs, l_rowids_aux, o_error)
            
            THEN
                RAISE l_exception;
            ELSE
                l_rowids := l_rowids MULTISET UNION DISTINCT l_rowids_aux;
            
                l_id_request.extend;
                l_id_request(l_id_request.count) := next_id_mvs;
                l_id_task.extend;
                l_id_task(l_id_task.count) := io_monit.id_vs(i);
            
            END IF;
        
            -- Monitorization Planning (monitorization_vs_plan)
            IF NOT create_monitor_vs_plan(i_lang, i_prof, next_id_mvs, io_monit, o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END LOOP;
    
        IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                 i_prof                 => i_prof,
                                 i_episode              => io_monit.id_epis,
                                 i_task_type            => pk_alert_constant.g_task_type_monitorization,
                                 i_task_request         => io_monit.id_monit,
                                 i_task_start_timestamp => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_timestamp => io_monit.dt_begin_final_str,
                                                                                         i_timezone  => NULL),
                                 o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- ---/ END MONITORIZATION DETAIL ----
    
        -- ALERT® Data Governance
    
        l_prof_cat_type := pk_prof_utils.get_category(i_lang, i_prof => i_prof);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => io_monit.id_epis,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => l_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
        
            RETURN FALSE;
        END IF;
    
        IF NOT create_alert_vital_sign(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       i_monitorization => io_monit.id_monit,
                                       o_error          => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
        
            RETURN FALSE;
        END IF;
    
        pk_icnp_fo_api_db.create_suggs(i_lang               => i_lang,
                                       i_prof               => i_prof,
                                       i_id_episode         => io_monit.id_epis,
                                       i_request_ids        => l_id_request,
                                       i_task_ids           => l_id_task,
                                       i_task_type_id       => pk_alert_constant.g_task_monitoring,
                                       i_sysdate_tstz       => l_sysdate_tstz,
                                       o_id_icnp_sug_interv => l_id_icnp_sug_interv);
    
        IF l_commit_data
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    END create_monitor_req;

    /******************************************************************************
       OBJECTIVO:   Criar requisições de leituras de sinais vitais
       PARAMETROS:  Entrada:  I_LANG - Língua registada como preferência do profissional
                  I_EPISODE - ID do Episódio
                      I_PROF - Profissional que regista a requisição da leitura dos sinais vitais
                  I_DT_BEGIN - Data a partir da qual é pedida a leitura
                  I_INTERVAL - Intervalo de tempo entre leituras
                  I_DT_END - Data até à qual é pedida a leitura dos SV
                  I_NOTES - Notas da requisição
                  I_FLG_TIME - Realização: E - neste episódio;
                                   N - próximo episódio;
                               B - entre episódios
                  I_ID_VS - Array de IDs de sinais vitais
                  I_NOTES_DETAIL - Array de notas de detalhe de requisição de leituras
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           como é retornada em PK_LOGIN.GET_PROF_PREF
                    i_prof_order - id do profissional que pediu a requisição
                    i_dt_order_str - momento em que a ordem foi pedida
                    i_order_type - tipo de ordem (telefone, verbal, etc)    
                    i_commit_data - Flag que indica se a função deve fazer o commit dos dados    
    
              Saida:  O_ID_MONITORIZATION Identificador da monitorização criada 
                      O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      ALTERAÇÕES: CRS 2005/07/27
                 LG 2007/07/29 Added input vars i_prof_order, i_dt_order, i_order_type
      NOTAS: Se é requisitado p/ fora do episódio, cria agendamento, para facilitar a
           pesquisa pela grelha
    *********************************************************************************/
    FUNCTION create_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_episode           IN monitorization.id_episode%TYPE,
        i_prof              IN profissional,
        i_dt_begin_str      IN VARCHAR2,
        i_interval          IN VARCHAR2,
        i_dt_end_str        IN VARCHAR2,
        i_notes             IN CLOB,
        i_flg_time          IN monitorization.flg_time%TYPE,
        i_id_vs             IN table_number,
        i_notes_detail      IN table_varchar,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_prof_order        IN monitorization_vs.id_prof_order%TYPE := NULL,
        i_dt_order_str      IN VARCHAR2 := NULL,
        i_order_type        IN monitorization_vs.id_order_type%TYPE := NULL,
        i_commit_data       IN VARCHAR2,
        o_id_monitorization OUT monitorization.id_monitorization%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        io_monit monit;
    
    BEGIN
        io_monit := monit(id_monit                  => NULL,
                          id_prof                   => i_prof.id,
                          id_inst                   => i_prof.institution,
                          id_soft                   => i_prof.software,
                          id_epis                   => i_episode,
                          notes                     => i_notes,
                          flg_time                  => i_flg_time,
                          dt_order_str              => i_dt_order_str,
                          dt_begin_str              => i_dt_begin_str,
                          dt_end_str                => i_dt_end_str,
                          dt_begin_final_str        => NULL,
                          INTERVAL                  => i_interval,
                          interval_final            => NULL,
                          id_vs                     => i_id_vs,
                          notes_detail              => i_notes_detail,
                          flg_status                => pk_alert_constant.g_monitor_vs_exec,
                          flg_status_det            => pk_alert_constant.g_monitor_vs_exec,
                          id_order_type             => i_order_type,
                          id_prof_order             => i_prof_order,
                          flg_monitorization_action => pk_monitorization.g_order_action,
                          id_co_sign_order          => NULL,
                          id_co_sign_cancel         => NULL);
    
        IF NOT create_monitor_req(i_lang        => i_lang,
                                  i_prof        => i_prof,
                                  i_commit_data => i_commit_data,
                                  io_monit      => io_monit,
                                  o_error       => o_error)
        THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
    
        o_id_monitorization := io_monit.id_monit;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'CREATE_MONITOR_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END create_monitor_req;

    /**********************************************************************************************
    * It retrieves the id professional that ordered the monitorization
    *
    * @param        id_monitorization        monitorization ID
    *
    * @return       id_professional          professional ID
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 11-Mar-2010
    **********************************************************************************************/

    FUNCTION get_prof_ordered_by(id_monit IN monitorization.id_monitorization%TYPE)
        RETURN professional.id_professional%TYPE IS
    
        id_prof professional.id_professional%TYPE;
    BEGIN
    
        SELECT m.id_prof_order id_professional
          INTO id_prof
          FROM monitorization_vs m
         WHERE m.id_monitorization = id_monit
           AND rownum = 1;
    
        RETURN id_prof;
    
    END get_prof_ordered_by;

    /**********************************************************************************************
    * It retrieves the monitorization professional ID (the prof order or last prof performeced)
    *
    * @param        id_monitorization        monitorization ID
    *
    * @return       id_professional          professional ID
    *                        
    * @author                                Vanessa Barsottelli
    * @version                               1.0
    * @since                                 01-12-2016
    **********************************************************************************************/

    FUNCTION get_monit_prof(i_id_monitorization IN monitorization.id_monitorization%TYPE)
        RETURN professional.id_professional%TYPE IS
    
        l_id_prof professional.id_professional%TYPE;
    BEGIN
    
        SELECT decode(t.flg_status,
                      pk_alert_constant.g_monitor_vs_inte,
                      t.id_prof_cancel,
                      pk_alert_constant.g_monitor_vs_canc,
                      t.id_prof_cancel,
                      nvl(t.id_prof_performed, t.id_professional))
          INTO l_id_prof
          FROM (SELECT m.id_professional,
                       mvsp.id_prof_performed,
                       m.flg_status,
                       m.id_prof_cancel,
                       row_number() over(ORDER BY mvsp.start_time DESC, mvsp.end_time DESC) rn
                  FROM monitorization m
                  JOIN monitorization_vs mvs
                    ON mvs.id_monitorization = m.id_monitorization
                  LEFT JOIN monitorization_vs_plan mvsp
                    ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                   AND mvsp.id_prof_performed IS NOT NULL
                 WHERE m.id_monitorization = i_id_monitorization) t
         WHERE t.rn = 1;
    
        RETURN l_id_prof;
    
    END get_monit_prof;

    /**********************************************************************************************
    * CPOE - Computerized physician order entry
    * This function only is used for CPOE feature without timing filters
    * It retrieves the monitorizations list in order to show in CPOE grid 
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_patient                patient id
    * @param        i_episode                episode id
    * @param        i_task_request           array of task request (if null, return all tasks as usual)
    * @param        i_flg_report             required in all get_task_list APIs
    * @param        o_grid                   array with monitorizations list
    * @param        o_error                  Error message
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 2009/11/18
    **********************************************************************************************/
    FUNCTION get_task_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_patient      IN patient.id_patient%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        i_flg_report   IN VARCHAR2 DEFAULT 'N',
        o_grid         OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN AS
        l_dummy pk_types.cursor_type;
    BEGIN
    
        RETURN get_task_list(i_lang          => i_lang,
                             i_prof          => i_prof,
                             i_patient       => i_patient,
                             i_episode       => i_episode,
                             i_task_request  => i_task_request,
                             i_filter_tstz   => NULL,
                             i_filter_status => NULL,
                             i_flg_report    => i_flg_report,
                             i_dt_begin      => NULL,
                             i_dt_end        => NULL,
                             o_plan_list     => l_dummy,
                             o_grid          => o_grid,
                             o_error         => o_error);
    
    END get_task_list;

    /**********************************************************************************************
    * CPOE - Computerized physician order entry
    * This function only is used for CPOE feature
    * It retrieves the monitorizations list in order to show in CPOE grid with timing filters
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_patient                patient id
    * @param        i_episode                episode id
    * @param        i_task_request           array of task request (if null, return all tasks as usual)
    * @param        i_flg_report             required in all get_task_list APIs
    * @param        o_grid                   array with monitorizations list
    * @param        o_error                  Error message
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 12-Jul-2010
    **********************************************************************************************/
    FUNCTION get_task_list
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_patient       IN patient.id_patient%TYPE,
        i_episode       IN episode.id_episode%TYPE,
        i_task_request  IN table_number,
        i_filter_tstz   IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_filter_status IN table_varchar,
        i_flg_report    IN VARCHAR2 DEFAULT 'N',
        i_dt_begin      IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_dt_end        IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_plan_list     OUT pk_types.cursor_type,
        o_grid          OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message debug_msg;
        l_exception EXCEPTION;
        l_id_visit     visit.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
    
        g_other_exception EXCEPTION;
    
        l_cancelled_task_filter_interval sys_config.value%TYPE := pk_sysconfig.get_config('CPOE_CANCELLED_TASK_FILTER_INTERVAL',
                                                                                          i_prof);
        l_cancelled_task_filter_tstz     TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
    
        l_cancelled_task_filter_tstz := current_timestamp -
                                        numtodsinterval(to_number(l_cancelled_task_filter_interval), 'DAY');
    
        IF NOT get_visit(i_lang, i_episode, l_id_visit, l_id_epis_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_message := 'GET CURSOR';
        OPEN o_grid FOR
            SELECT task_type,
                   task_description,
                   id_professional,
                   icon_warning,
                   status_string,
                   id_request,
                   start_date_tstz,
                   end_date_tstz,
                   creation_date_tstz,
                   flg_status,
                   flg_cancel,
                   flg_conflict,
                   NULL id_task,
                   --New Fields for CPOE API in Reports
                   --ALERT-202996 (AN)
                   task_title,
                   task_instructions,
                   pk_translation.get_translation_trs(task_notes_code) task_notes,
                   NULL drug_dose,
                   NULL drug_route,
                   NULL drug_take_in_case,
                   task_status,
                   NULL AS instr_bg_color,
                   NULL AS instr_bg_alpha,
                   NULL AS task_icon,
                   pk_alert_constant.g_no AS flg_need_ack,
                   NULL AS edit_icon,
                   NULL AS action_desc,
                   NULL AS previous_status,
                   pk_alert_constant.g_task_monitoring AS id_task_type_source,
                   NULL AS id_task_dependency,
                   decode(flg_status,
                          pk_alert_constant.g_monitor_vs_canc,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_rep_cancel,
                   NULL flg_prn_conditional
              FROM (
                    --retrieve all tasks (in (i_task_request) OR into (i_filter_status AND dt_end >= i_filter_tstz))
                    SELECT DISTINCT pk_alert_constant.g_task_type_monitorization task_type,
                                     concat_monit_vs(i_lang, i_prof, l_id_visit, l_id_epis_type, mea.id_monitorization) ||
                                     decode(i_flg_report,
                                            pk_alert_constant.g_no,
                                            chr(10) || get_monit_instructions(i_lang, i_prof, mea.id_monitorization, 'SIE')) AS task_description,
                                     get_monit_prof(mea.id_monitorization) id_professional,
                                     NULL icon_warning,
                                     -- gets first active monit_vs status string
                                     first_value(pk_utils.get_status_string(i_lang,
                                                                            i_prof,
                                                                            mea.status_str,
                                                                            mea.status_msg,
                                                                            mea.status_icon,
                                                                            mea.status_flg)) over(PARTITION BY mea.id_monitorization ORDER BY decode(mea.flg_status, 'C', 2, 1)) AS status_string,
                                     mea.id_monitorization id_request,
                                     mea.dt_begin start_date_tstz,
                                     mea.dt_end end_date_tstz,
                                     nvl(mea.dt_dg_last_update, mea.dt_order) creation_date_tstz, -- ALERT-283519
                                     mea.flg_status flg_status,
                                     decode(mea.flg_status,
                                            pk_alert_constant.g_monitor_vs_exec,
                                            pk_alert_constant.g_yes,
                                            pk_alert_constant.g_monitor_vs_pend,
                                            pk_alert_constant.g_yes,
                                            pk_alert_constant.g_no) flg_cancel,
                                     pk_alert_constant.g_no flg_conflict,
                                     pk_sysdomain.get_rank(i_lang,
                                                           'MONITORIZATION.FLG_STATUS',
                                                           decode(mea.flg_time,
                                                                  pk_alert_constant.g_flg_time_n,
                                                                  mea.flg_status,
                                                                  decode(mea.flg_status,
                                                                         pk_alert_constant.g_monitor_vs_canc,
                                                                         mea.flg_status,
                                                                         pk_alert_constant.g_monitor_vs_fini,
                                                                         mea.flg_status,
                                                                         decode(least(mea.dt_plan, l_sysdate_tstz),
                                                                                mea.dt_plan,
                                                                                pk_alert_constant.g_monitor_vs_exec,
                                                                                mea.flg_status)))) AS rank,
                                     --New Fields for CPOE API in Reports
                                     --ALERT-202996 (AN)
                                     decode(i_flg_report,
                                            pk_alert_constant.g_yes,
                                            (get_vs_desc(i_lang, m.id_monitorization, i_prof) ||
                                            nvl2(m.id_prev_episode,
                                                  ' - (' || pk_message.get_message(i_lang,
                                                                                   profissional(i_prof.id,
                                                                                                i_prof.institution,
                                                                                                pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                                                   FROM episode e
                                                                                                                                  WHERE e.id_episode =
                                                                                                                                        m.id_prev_episode),
                                                                                                                                 i_prof.institution)),
                                                                                   'IMAGE_T009') || ')',
                                                  '')),
                                            concat_monit_vs(i_lang,
                                                            i_prof,
                                                            l_id_visit,
                                                            l_id_epis_type,
                                                            mea.id_monitorization)) task_title,
                                     decode(i_flg_report,
                                            pk_alert_constant.g_yes,
                                            get_interval_desc(i_lang, i_prof, m.id_monitorization)) task_instructions,
                                     decode(i_flg_report, pk_alert_constant.g_yes, mvs.code_notes) task_notes_code,
                                     decode(i_flg_report,
                                            pk_alert_constant.g_yes,
                                            pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS', m.flg_status, i_lang)) task_status
                      FROM monitorizations_ea mea
                     INNER JOIN episode epi
                        ON mea.id_episode = epi.id_episode
                     INNER JOIN monitorization m
                        ON mea.id_monitorization = m.id_monitorization
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                     WHERE epi.id_visit = l_id_visit
                       AND (mea.id_monitorization IN (SELECT *
                                                        FROM TABLE(i_task_request)) OR i_task_request IS NULL)
                       AND (i_task_request IS NULL OR
                           mea.id_monitorization IN (SELECT /*+ OPT_ESTIMATE (TABLE d ROWS=1)*/
                                                       d.column_value
                                                        FROM TABLE(i_task_request) d))
                       AND (mea.flg_status NOT IN (SELECT /*+ OPT_ESTIMATE (TABLE t ROWS=1)*/
                                                    t.column_value
                                                     FROM TABLE(i_filter_status) t) OR
                           (mea.dt_end > i_filter_tstz AND m.dt_cancel_tstz IS NULL) OR
                           (m.dt_cancel_tstz IS NOT NULL AND m.dt_cancel_tstz > l_cancelled_task_filter_tstz))
                    UNION ALL
                    -- retrieve drafts
                    SELECT t.task_type,
                            t.task_description,
                            t.id_professional,
                            t.icon_warning,
                            pk_utils.get_status_string_immediate(i_lang,
                                                                 i_prof,
                                                                 pk_alert_constant.g_display_type_icon,
                                                                 t.flg_status,
                                                                 NULL,
                                                                 NULL,
                                                                 'MONITORIZATION.FLG_STATUS',
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 l_sysdate_tstz) AS status_string,
                            t.id_request,
                            t.start_date_tstz,
                            t.end_date_tstz,
                            t.creation_date_tstz,
                            t.flg_status,
                            t.flg_cancel,
                            t.flg_conflict,
                            t.rank,
                            t.task_title,
                            t.task_instructions,
                            t.task_notes_code,
                            t.task_status
                      FROM (SELECT DISTINCT pk_alert_constant.g_task_type_monitorization task_type,
                                             concat_monit_vs(i_lang,
                                                             i_prof,
                                                             l_id_visit,
                                                             l_id_epis_type,
                                                             m.id_monitorization) ||
                                             decode(i_flg_report,
                                                    pk_alert_constant.g_no,
                                                    chr(10) ||
                                                    get_monit_instructions(i_lang, i_prof, m.id_monitorization, 'SIE')) AS task_description,
                                             nvl(get_prof_ordered_by(m.id_monitorization), m.id_professional) id_professional,
                                             NULL icon_warning,
                                             m.id_monitorization id_request,
                                             m.dt_begin_tstz start_date_tstz,
                                             m.dt_end_tstz end_date_tstz,
                                             m.dt_monitorization_tstz creation_date_tstz,
                                             m.flg_status flg_status,
                                             decode(m.flg_status,
                                                    pk_alert_constant.g_monitor_vs_exec,
                                                    pk_alert_constant.g_yes,
                                                    pk_alert_constant.g_monitor_vs_pend,
                                                    pk_alert_constant.g_yes,
                                                    pk_alert_constant.g_no) flg_cancel,
                                             decode(validate_monitor_req2(i_lang, i_prof, m.id_monitorization),
                                                    pk_alert_constant.g_yes,
                                                    pk_alert_constant.g_yes,
                                                    -- verify if dt_end is lower than current timestamp (conflict verified just for draft monits)
                                                    decode(pk_date_utils.compare_dates_tsz(i_prof,
                                                                                           m.dt_end_tstz,
                                                                                           l_sysdate_tstz),
                                                           pk_alert_constant.g_date_lower,
                                                           pk_alert_constant.g_yes,
                                                           pk_alert_constant.g_no)) flg_conflict,
                                             pk_sysdomain.get_rank(i_lang,
                                                                   'MONITORIZATION.FLG_STATUS',
                                                                   decode(m.flg_time,
                                                                          pk_alert_constant.g_flg_time_n,
                                                                          m.flg_status,
                                                                          decode(m.flg_status,
                                                                                 pk_alert_constant.g_monitor_vs_canc,
                                                                                 m.flg_status,
                                                                                 pk_alert_constant.g_monitor_vs_fini,
                                                                                 m.flg_status))) AS rank,
                                             --New Fields for CPOE API in Reports
                                             --ALERT-202996 (AN)
                                             decode(i_flg_report,
                                                    pk_alert_constant.g_yes,
                                                    (get_vs_desc(i_lang, m.id_monitorization, i_prof) ||
                                                    nvl2(m.id_prev_episode,
                                                          ' - (' || pk_message.get_message(i_lang,
                                                                                           profissional(i_prof.id,
                                                                                                        i_prof.institution,
                                                                                                        pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                                                           FROM episode e
                                                                                                                                          WHERE e.id_episode =
                                                                                                                                                m.id_prev_episode),
                                                                                                                                         i_prof.institution)),
                                                                                           'IMAGE_T009') || ')',
                                                          '')),
                                                    concat_monit_vs(i_lang,
                                                                    i_prof,
                                                                    l_id_visit,
                                                                    l_id_epis_type,
                                                                    m.id_monitorization)) task_title,
                                             decode(i_flg_report,
                                                    pk_alert_constant.g_yes,
                                                    get_interval_desc(i_lang, i_prof, m.id_monitorization)) task_instructions,
                                             decode(i_flg_report, pk_alert_constant.g_yes, mvs.code_notes) task_notes_code,
                                             decode(i_flg_report,
                                                    pk_alert_constant.g_yes,
                                                    pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS',
                                                                            m.flg_status,
                                                                            i_lang)) task_status
                               FROM monitorization m
                              INNER JOIN episode e
                                 ON e.id_episode = m.id_episode
                              INNER JOIN monitorization_vs mvs
                                 ON m.id_monitorization = mvs.id_monitorization
                              WHERE e.id_visit = l_id_visit
                                AND (m.id_monitorization IN (SELECT *
                                                               FROM TABLE(i_task_request)) OR i_task_request IS NULL)
                                AND m.flg_status = pk_alert_constant.g_monitor_vs_draft) t)
            
             ORDER BY rank, start_date_tstz;
    
        IF i_flg_report = pk_alert_constant.g_yes
        THEN
        
            IF NOT get_order_plan_report(i_lang          => i_lang,
                                         i_prof          => i_prof,
                                         i_episode       => i_episode,
                                         i_task_request  => i_task_request,
                                         i_cpoe_dt_begin => i_dt_begin,
                                         i_cpoe_dt_end   => i_dt_end,
                                         o_plan_rep      => o_plan_list,
                                         o_error         => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_TASK_LIST',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_grid);
            RETURN FALSE;
    END get_task_list;

    /**********************************************************************************************
    * It retrieves the monitorization VS details (CPOE purpose) 
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_monitorization         monitorization id
    * @param        o_monit_vs               array with monitorizations vs list
    * @param        o_error                  Error message
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               2.5.0.7.5
    * @since                                 2009/12/04
    **********************************************************************************************/
    FUNCTION get_monit_vs_det
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_monitorization IN monitorization.id_monitorization%TYPE,
        o_monit_vs       OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        OPEN o_monit_vs FOR
            SELECT mvs.id_monitorization_vs, mvs.id_monitorization, mvs.id_vital_sign, mvs.flg_status
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = i_monitorization;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONIT_VS_DET',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_monit_vs);
            RETURN FALSE;
    END get_monit_vs_det;

    /*
    * Provide list of ongoing MONITORIZATION tasks for the patient death feature. All the monits in this list must be possible to cancel.
    *
    * @param   I_LANG               language associated to the professional executing the request
    * @param   I_PROF               Professional type
    * @param   I_ID_PATIENT         Patient ID
    *
    * @RETURN  tf_tasks_list (table of tr_tasks_list)
    * @author  Rui de Sousa Neves
    * @version 2.6.0.3
    * @since   11-MAY-2010
    *
    */
    FUNCTION get_ongoing_tasks_monit
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN patient.id_patient%TYPE
    ) RETURN tf_tasks_list IS
    
        t tf_tasks_list;
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'get_ongoing_tasks_monit';
    
        l_dbg_msg debug_msg;
    
    BEGIN
    
        l_dbg_msg := 'SELECT';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        SELECT tr_tasks_list(id_task, desc_task, epis_type, dt_task)
          BULK COLLECT
          INTO t
          FROM (SELECT m.id_monitorization id_task,
                       pk_monitorization.concat_monit_vs(i_lang,
                                                         i_prof,
                                                         epi.id_visit,
                                                         epi.id_epis_type,
                                                         m.id_monitorization) desc_task,
                       pk_translation.get_translation(i_lang, et.code_epis_type) epis_type,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, m.dt_monitorization_tstz, i_prof) dt_task
                  FROM monitorization m
                 INNER JOIN episode epi
                    ON epi.id_episode = m.id_episode
                 INNER JOIN epis_type et
                    ON et.id_epis_type = epi.id_epis_type
                 WHERE epi.id_patient = i_id_patient
                      -- status canceled or interrupted are already canceled. Finished are also not suspendable.
                   AND m.flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc,
                                            pk_alert_constant.g_monitor_vs_inte,
                                            pk_alert_constant.g_monitor_vs_fini,
                                            pk_alert_constant.g_monitor_vs_draft)
                 ORDER BY dt_task DESC);
    
        RETURN t;
    
    END get_ongoing_tasks_monit;

    /*
    * Provide list of MONITORIZATION tasks for a given status
    *
    * @param   I_LANG               language associated to the professional executing the request
    * @param   I_PROF               Professional type
    * @param   I_ID_SUSP_ACTION     Corresponding ID_SUSP_ACTION
    * @param   I_WF_STATUS          Status for tasks
    *
    * @RETURN  tf_tasks_list (table of tr_tasks_list)
    * @author  Rui de Sousa Neves
    * @version 2.6.0.3
    * @since   18-MAY-2010
    *
    */
    FUNCTION get_wfstatus_tasks_monit
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_susp_action IN susp_task.id_susp_action%TYPE,
        i_wfstatus       IN susp_task.flg_status%TYPE
    ) RETURN tf_tasks_react_list IS
    
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'get_wfstatus_tasks_monit';
        t tf_tasks_react_list;
        l_code_epis_type CONSTANT VARCHAR2(30 CHAR) := 'EPIS_TYPE.CODE_EPIS_TYPE.';
    
        l_dbg_msg debug_msg;
    
    BEGIN
    
        l_dbg_msg := 'SELECT';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        SELECT tr_tasks_react_list(id_task, id_susp_task, desc_task, epis_type, dt_task)
          BULK COLLECT
          INTO t
          FROM (SELECT stm.id_monitorization id_task,
                       st.id_susp_task,
                       pk_monitorization.concat_monit_vs(i_lang,
                                                         i_prof,
                                                         e.id_visit,
                                                         e.id_epis_type,
                                                         stm.id_monitorization) desc_task,
                       pk_translation.get_translation(i_lang, l_code_epis_type || e.id_epis_type) epis_type,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, m.dt_monitorization_tstz, i_prof) dt_task
                  FROM susp_task st
                 INNER JOIN susp_task_monitoring stm
                    ON stm.id_susp_task = st.id_susp_task
                 INNER JOIN monitorization m
                    ON m.id_monitorization = stm.id_monitorization
                 INNER JOIN episode e
                    ON m.id_episode = e.id_episode
                 WHERE st.id_susp_action = i_id_susp_action
                   AND st.flg_status = i_wfstatus
                 ORDER BY dt_task DESC);
    
        RETURN t;
    
    END get_wfstatus_tasks_monit;

    /*
    * Suspend the ongoing tasks - Monitorization
    *
    * @param   I_LANG               language associated to the professional executing the request
    * @param   I_PROF               Professional type
    * @param   I_TASK               ID from the corresponding task
    * @param   I_FLG_REASON         Reason for the WF suspension: 'D' (Death)
    * @param   O_MSG_ERROR          Message to send to the UX in case one of the functions has some kind of error
    * @param   O_ERROR              warning/error message
    *
    * @RETURN  TRUE if success, FALSE otherwise
    * @author  Rui de Sousa Neves
    * @version 2.6.0.3
    * @since   13-MAY-2010
    *
    */
    FUNCTION suspend_task_monit
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_task       IN NUMBER,
        i_flg_reason IN VARCHAR2,
        o_msg_error  OUT VARCHAR2,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'suspend_task_monit';
        l_dbg_msg debug_msg;
    
        l_mess_error CONSTANT sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                      i_code_mess => 'MONITOR_M011');
        l_prof_cat_type  category.flg_type%TYPE;
        l_flg_status     monitorization.flg_status%TYPE;
        l_flg_status_arr table_varchar;
        l_id_monit_arr   table_number;
        l_flg_status_mvp monitorization_vs_plan.flg_status%TYPE;
        l_id_monit_mvp   monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_rows           table_varchar := table_varchar();
    
        CURSOR c_monit(pin_id_monit monitorization.id_monitorization%TYPE) IS
            SELECT m.flg_status
              FROM monitorization m
             WHERE m.id_monitorization = pin_id_monit;
    
        CURSOR c_monit_vs(pin_id_monit monitorization.id_monitorization%TYPE) IS
            SELECT mvs.flg_status, mvs.id_monitorization_vs
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = pin_id_monit;
    
        CURSOR c_monit_vs_plan(pin_id_monit monitorization_vs.id_monitorization_vs%TYPE) IS
            SELECT mvp.flg_status, mvp.id_monitorization_vs_plan
              FROM monitorization_vs_plan mvp
             WHERE mvp.id_monitorization_vs = pin_id_monit;
    
    BEGIN
    
        l_dbg_msg := 'CASE I_FLG_REASON';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        -- Saves on FLG_STATUS_PREV the last FLG_STATUS before cancelling the event on tables: monitorization, monitorization_vs, monitorization_vs_plan  
        l_dbg_msg := 'OPEN c_monit';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        OPEN c_monit(i_task);
        FETCH c_monit
            INTO l_flg_status;
        CLOSE c_monit;
    
        -- Updates Flg_status on Monitorization
        l_dbg_msg := 'UPD flg_status_prev Monitorization';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        ts_monitorization.upd(id_monitorization_in => i_task, flg_status_prev_in => l_flg_status, rows_out => l_rows);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rows,
                                      o_error      => o_error);
        -- gets all monitorization_vs for a certain monitorization
        l_dbg_msg := 'OPEN c_monit_vs';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        OPEN c_monit_vs(i_task);
        FETCH c_monit_vs BULK COLLECT
            INTO l_flg_status_arr, l_id_monit_arr;
        CLOSE c_monit_vs;
    
        -- runs every monitorization_vs
        l_dbg_msg := 'FOR i IN 1 .. l_flg_status_arr.COUNT';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        FOR i IN 1 .. l_flg_status_arr.count
        LOOP
        
            -- Updates Flg_status on Monitorization_vs
            l_dbg_msg := 'UPD flg_status_prev Monitorization Vital Sign';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            ts_monitorization_vs.upd(id_monitorization_vs_in => l_id_monit_arr(i),
                                     flg_status_prev_in      => l_flg_status_arr(i),
                                     rows_out                => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        
            -- gets monitorization_vs_plan for a certain monitorization_vs
            l_dbg_msg := 'OPEN c_monit_vs_plan';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            OPEN c_monit_vs_plan(l_id_monit_arr(i));
            FETCH c_monit_vs_plan
                INTO l_flg_status_mvp, l_id_monit_mvp;
            CLOSE c_monit_vs_plan;
        
            -- Updates Flg_status on Monitorization_vs_plan
            l_dbg_msg := 'UPD flg_status_prev Monitorization Plan';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            ts_monitorization_vs_plan.upd(id_monitorization_vs_plan_in => l_id_monit_mvp,
                                          flg_status_prev_in           => l_flg_status_mvp,
                                          rows_out                     => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS_PLAN',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        END LOOP;
    
        -- get professional category
        l_dbg_msg := 'GET Category';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        l_prof_cat_type := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
    
        -- cancel monitorization
        l_dbg_msg := 'CANCEL Monitorization';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        IF NOT pk_monitorization.cancel_monitor_req(i_lang              => i_lang,
                                                    i_id_monitorization => i_task,
                                                    i_prof              => i_prof,
                                                    i_prof_cat_type     => l_prof_cat_type,
                                                    i_notes             => NULL,
                                                    i_commit_data       => pk_alert_constant.g_no,
                                                    i_id_cancel_reason  => pk_cancel_reason.c_reason_patient_death,
                                                    o_error             => o_error)
        THEN
            -- returns error message
            o_msg_error := REPLACE(l_mess_error,
                                   '@1',
                                   pk_monitorization.get_vs_desc(i_lang           => i_lang,
                                                                 i_monitorization => i_task,
                                                                 i_prof           => i_prof));
            l_dbg_msg   := 'ERROR CANCEL Monitorization ' || o_msg_error;
            pk_alertlog.log_error(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    END suspend_task_monit;

    /*
    * Reactivate the ongoing tasks - Monitorization
    *
    * @param   I_LANG               language associated to the professional executing the request
    * @param   I_PROF               Professional type
    * @param   I_TASK               ID from the corresponding task
    * @param   O_MSG_ERROR          Message to send to the UX in case one of the functions has some kind of error
    * @param   O_ERROR              warning/error message
    *
    * @RETURN  TRUE if success, FALSE otherwise
    * @author  Rui de Sousa Neves
    * @version 2.6.0.3
    * @since   21-MAY-2010
    *
    */
    FUNCTION reactivate_task_monit
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_task      IN NUMBER,
        o_msg_error OUT VARCHAR2,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'reactivate_task_monit';
        l_dbg_msg debug_msg;
    
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        l_mess_error CONSTANT sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                      i_code_mess => 'MONITOR_M012');
        l_prof_cat_type   category.flg_type%TYPE;
        l_flg_status      monitorization.flg_status%TYPE;
        l_flg_status_arr  table_varchar;
        l_id_monit_vs_arr table_number;
        l_flg_status_mvp  monitorization_vs_plan.flg_status%TYPE;
        l_id_monit_mvp    monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_id_episode      episode.id_episode%TYPE;
        l_dt_begin_str    VARCHAR2(100);
        l_dt_end_str      VARCHAR2(100);
        l_notes           CLOB;
        l_flg_time        monitorization.flg_time%TYPE;
        l_interval        monitorization.interval%TYPE;
        l_prof            monitorization.id_professional%TYPE;
        l_notes_arr       table_varchar;
        l_rows            table_varchar := table_varchar();
        l_mvs             monitorization_vs%ROWTYPE;
    
        CURSOR c_monit(pin_id_monit monitorization.id_monitorization%TYPE) IS
            SELECT m.flg_status_prev,
                   m.id_episode,
                   m.dt_begin_tstz,
                   m.dt_end_tstz,
                   pk_translation.get_translation_trs(m.code_notes) notes,
                   m.flg_time,
                   m.interval,
                   m.id_professional
              FROM monitorization m
             WHERE m.id_monitorization = pin_id_monit;
    
        CURSOR c_monit_vs(pin_id_monit monitorization.id_monitorization%TYPE) IS
            SELECT mvs.flg_status_prev,
                   mvs.id_monitorization_vs,
                   pk_translation.get_translation_trs(mvs.code_notes) notes
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = pin_id_monit;
    
        CURSOR c_monit_vs_plan(pin_id_monit monitorization_vs.id_monitorization_vs%TYPE) IS
            SELECT mvp.flg_status_prev, mvp.id_monitorization_vs_plan
              FROM monitorization_vs_plan mvp
             WHERE mvp.id_monitorization_vs = pin_id_monit;
    
    BEGIN
    
        -- Puts FLG_STATUS_PREV as FLG_STATUS on the following tables: MONITORIZATION, MONITORIZATION_VS_PLAN and MONITORIZATION_VS.  
        l_dbg_msg := 'OPEN c_monit';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        OPEN c_monit(i_task);
        FETCH c_monit
            INTO l_flg_status, l_id_episode, l_dt_begin_str, l_dt_end_str, l_notes, l_flg_time, l_interval, l_prof;
        CLOSE c_monit;
    
        -- updates flg_status on monitorization
        l_dbg_msg := 'UPD flg_status Monitorization';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        ts_monitorization.upd(id_monitorization_in => i_task,
                              flg_status_in        => l_flg_status,
                              id_prof_cancel_in    => NULL,
                              id_prof_cancel_nin   => FALSE,
                              dt_cancel_tstz_in    => NULL,
                              dt_cancel_tstz_nin   => FALSE,
                              rows_out             => l_rows);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rows,
                                      o_error      => o_error);
        -- gets all monitorization_vs for a certain monitorization
        l_dbg_msg := 'OPEN c_monit_vs';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        OPEN c_monit_vs(i_task);
        FETCH c_monit_vs BULK COLLECT
            INTO l_flg_status_arr, l_id_monit_vs_arr, l_notes_arr;
        CLOSE c_monit_vs;
    
        l_dbg_msg := 'FOR';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        FOR i IN 1 .. l_id_monit_vs_arr.count
        LOOP
        
            -- updates flg_status on monitorization_vs
            l_dbg_msg := 'UPD flg_status Monitorization Vital Sign';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
            ts_monitorization_vs.upd(id_monitorization_vs_in => l_id_monit_vs_arr(i),
                                     flg_status_in           => l_flg_status_arr(i),
                                     id_prof_cancel_in       => NULL,
                                     id_prof_cancel_nin      => FALSE,
                                     dt_cancel_tstz_in       => NULL,
                                     dt_cancel_tstz_nin      => FALSE,
                                     rows_out                => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
            -- gets all monitorization_vs_plan for a certain monitorization_vs
            l_dbg_msg := 'OPEN c_monit_vs_plan';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            OPEN c_monit_vs_plan(l_id_monit_vs_arr(i));
            FETCH c_monit_vs_plan
                INTO l_flg_status_mvp, l_id_monit_mvp;
            CLOSE c_monit_vs_plan;
        
            -- updates flg_status on monitorization_vs_plan
            l_dbg_msg := 'UPD flg_status Monitorization Planning';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            ts_monitorization_vs_plan.upd(id_monitorization_vs_plan_in => l_id_monit_mvp,
                                          flg_status_in                => l_flg_status_mvp,
                                          rows_out                     => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS_PLAN',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        
            SELECT mvs.*
              INTO l_mvs
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization_vs = l_id_monit_vs_arr(i);
        
        END LOOP;
    
        -- CPOE synch
        l_dbg_msg := 'CPOE SYNC';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                 i_prof                 => i_prof,
                                 i_episode              => l_id_episode,
                                 i_task_type            => pk_alert_constant.g_task_type_monitorization,
                                 i_task_request         => i_task,
                                 i_task_start_timestamp => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_timestamp => l_dt_begin_str,
                                                                                         i_timezone  => NULL),
                                 o_error                => o_error)
        THEN
            o_msg_error := REPLACE(l_mess_error,
                                   '@1',
                                   pk_monitorization.get_vs_desc(i_lang           => i_lang,
                                                                 i_monitorization => i_task,
                                                                 i_prof           => i_prof));
            l_dbg_msg   := 'ERROR CPOE SYNCH ' || o_msg_error;
            pk_alertlog.log_error(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        
            RETURN FALSE;
        END IF;
    
        -- updates set_first_obs
        l_dbg_msg := 'SET First OBS';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        l_prof_cat_type := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_id_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => l_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            o_msg_error := REPLACE(l_mess_error,
                                   '@1',
                                   pk_monitorization.get_vs_desc(i_lang           => i_lang,
                                                                 i_monitorization => i_task,
                                                                 i_prof           => i_prof));
            l_dbg_msg   := 'ERROR SET First OBS' || o_msg_error;
            pk_alertlog.log_error(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
            RETURN FALSE;
        END IF;
    
        -- updates alerts
        l_dbg_msg := 'UPD Alerts';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        IF NOT
            create_alert_vital_sign(i_lang => i_lang, i_prof => i_prof, i_monitorization => i_task, o_error => o_error)
        THEN
            o_msg_error := REPLACE(l_mess_error,
                                   '@1',
                                   pk_monitorization.get_vs_desc(i_lang           => i_lang,
                                                                 i_monitorization => i_task,
                                                                 i_prof           => i_prof));
            l_dbg_msg   := 'ERROR UPD Alerts' || o_msg_error;
            pk_alertlog.log_error(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    END reactivate_task_monit;

    /**********************************************************************************************
    *
    * This function only is used for CPOE feature
    * get tasks status based in their request
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_episode                episode id
    * @param        i_task_request           array of task request
    * @param        o_task_status            cursor with all requested tast status
    * @param        o_error                  error structure for exception handling
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 14-Sep-2010
    **********************************************************************************************/
    FUNCTION get_task_status
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_task_status  OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        l_exception EXCEPTION;
        l_id_visit     visit.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
    
    BEGIN
        IF NOT get_visit(i_lang, i_episode, l_id_visit, l_id_epis_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_message := 'GET CURSOR o_task_status';
        OPEN o_task_status FOR
            SELECT DISTINCT pk_alert_constant.g_task_type_monitorization task_type,
                            mea.id_monitorization                        id_request,
                            mea.flg_status                               flg_status
              FROM monitorizations_ea mea, episode epi
             WHERE mea.id_episode = epi.id_episode
               AND epi.id_visit = l_id_visit
               AND (mea.id_monitorization IN (SELECT *
                                                FROM TABLE(i_task_request)) OR i_task_request IS NULL)
            UNION ALL
            -- retrieve drafts
            SELECT pk_alert_constant.g_task_type_monitorization task_type,
                   m.id_monitorization                          id_request,
                   m.flg_status                                 flg_status
              FROM monitorization m
             INNER JOIN episode e
                ON e.id_episode = m.id_episode
             WHERE e.id_visit = l_id_visit
               AND (m.id_monitorization IN (SELECT *
                                              FROM TABLE(i_task_request)) OR i_task_request IS NULL)
               AND m.flg_status = pk_alert_constant.g_monitor_vs_draft;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_TASK_STATUS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_task_status);
            RETURN FALSE;
    END get_task_status;

    /**********************************************************************************************
    * 
    * This function only is used for CPOE feature
    * cancel all draft tasks
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_episode                episode id
    * @param        o_error                  error structure for exception handling
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 14-Sep-2010
    **********************************************************************************************/
    FUNCTION cancel_all_drafts
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_id_visit     visit.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
        l_message      debug_msg;
    
        CURSOR c_drafts(i_visit episode.id_visit%TYPE) IS
            SELECT m.id_monitorization
              FROM monitorization m
              JOIN episode e
                ON e.id_episode = m.id_episode
             WHERE m.flg_status = pk_alert_constant.g_monitor_vs_draft
               AND e.id_visit = i_visit;
    
        l_monit_drafts table_number;
    
    BEGIN
        IF NOT get_visit(i_lang, i_episode, l_id_visit, l_id_epis_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_message := 'cursor cancel_all_drafts';
        pk_alertlog.log_debug(l_message, c_package_name);
    
        OPEN c_drafts(l_id_visit);
        FETCH c_drafts BULK COLLECT
            INTO l_monit_drafts;
        CLOSE c_drafts;
    
        IF l_monit_drafts.count > 0
        THEN
            IF NOT cancel_draft(i_lang    => i_lang,
                                i_prof    => i_prof,
                                i_episode => i_episode,
                                i_draft   => l_monit_drafts,
                                o_error   => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_ALL_DRAFTS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_all_drafts;

    /**********************************************************************************************
    * Returns information about a given request
    *
    * @param i_lang                  Language ID
    * @param i_prof                  Professional
    * @param i_id_request            Request ID
    * @param o_description           Description
    * @param o_instructions          Instructions
    * @param o_flg_status            Flg_status
    *                        
    * @author                        Filipe Machado
    * @version                       v2.5.1.3
    * @since                         02-Feb-2011
    **********************************************************************************************/
    PROCEDURE get_therapeutic_status
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_request   IN NUMBER,
        o_description  OUT VARCHAR2,
        o_instructions OUT VARCHAR2,
        o_flg_status   OUT VARCHAR2
    ) IS
    BEGIN
    
        SELECT pk_vital_sign.get_vs_desc(i_lang, mvs.id_vital_sign),
               get_instructions(i_lang, i_prof, mvs.id_monitorization_vs),
               decode(mvs.flg_status,
                      pk_alert_constant.g_monitor_vs_canc,
                      pk_alert_constant.g_no,
                      decode(mvs.flg_status,
                             pk_alert_constant.g_monitor_vs_inte,
                             pk_alert_constant.g_no,
                             pk_alert_constant.g_yes),
                      pk_alert_constant.g_yes)
          INTO o_description, o_instructions, o_flg_status
          FROM monitorization_vs mvs
          JOIN monitorization m
            ON m.id_monitorization = mvs.id_monitorization
         WHERE mvs.id_monitorization_vs = i_id_request;
    END get_therapeutic_status;

    /**********************************************************************************************
    * Returns the instructions for a procedure request according to the passed format, using 
    * combinations of the following values: T (type), N (requirement date), I (interval), S 
    * (start date), E (end date).
    *
    * @param i_lang                ID language
    * @param i_prof                Professional
    * @param i_id_monit_vs         Moniutorization_vs ID
    * @param i_format              Output string format (optional)
    *
    * @return                      Instructions for this monitoring
    *                        
    * @author                      Filipe Machado
    * @version                     2.5.1.3
    * @since                       02-Feb-2011
    **********************************************************************************************/
    FUNCTION get_instructions
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_id_monit_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_format      IN VARCHAR2 DEFAULT 'TNISE'
    ) RETURN VARCHAR2 IS
        l_type     VARCHAR2(4000);
        l_interval VARCHAR2(4000);
        l_start    VARCHAR2(4000);
        l_end      VARCHAR2(4000);
        l_ret      VARCHAR2(4000);
        l_req      VARCHAR2(4000);
    
        l_void VARCHAR2(3) := '---';
    
        l_interval_mess VARCHAR2(4000);
        l_dt_start_mess VARCHAR2(4000);
        l_dt_end_mess   VARCHAR2(4000);
        l_dt_req_mess   VARCHAR2(4000);
    
        PROCEDURE add_to_ret
        (
            i_add      IN VARCHAR2,
            i_original IN OUT VARCHAR2
        ) IS
        BEGIN
            IF i_original IS NULL
            THEN
                i_original := i_add;
            ELSE
                i_original := i_original || '; ' || nvl(i_add, l_void);
            END IF;
        END add_to_ret;
    
    BEGIN
    
        l_dt_start_mess := pk_message.get_message(i_lang, i_prof, 'MONITOR_T002');
        l_dt_end_mess   := pk_message.get_message(i_lang, i_prof, 'MONITOR_T004');
        l_interval_mess := pk_message.get_message(i_lang, i_prof, 'MONITOR_T003');
        l_dt_req_mess   := pk_message.get_message(i_lang, i_prof, 'MONITOR_T012');
    
        SELECT DISTINCT pk_vital_sign.get_vs_desc(i_lang, mvs.id_vital_sign) desc_vs,
                        (pk_date_utils.date_char_hour_tsz(i_lang,
                                                          mvs.dt_monitorization_vs_tstz,
                                                          i_prof.institution,
                                                          i_prof.software) || ' ' ||
                        pk_date_utils.dt_chr_tsz(i_lang, mvs.dt_monitorization_vs_tstz, i_prof)) dt_req,
                        
                        (decode(m.flg_time,
                                pk_alert_constant.g_flg_time_n,
                                pk_message.get_message(i_lang, 'COMMON_M018'),
                                pk_date_utils.date_char_hour_tsz(i_lang,
                                                                 nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                 i_prof.institution,
                                                                 i_prof.software)) || ' ' ||
                        decode(m.flg_time,
                                pk_alert_constant.g_flg_time_n,
                                NULL,
                                pk_date_utils.dt_chr_tsz(i_lang, nvl(m.dt_begin_tstz, m.dt_monitorization_tstz), i_prof))) dt_begin,
                        
                        (decode(m.flg_time,
                                pk_alert_constant.g_flg_time_n,
                                pk_message.get_message(i_lang, 'COMMON_M018'),
                                pk_date_utils.date_char_hour_tsz(i_lang,
                                                                 m.dt_end_tstz,
                                                                 i_prof.institution,
                                                                 i_prof.software)) || ' ' ||
                        decode(m.flg_time,
                                pk_alert_constant.g_flg_time_n,
                                NULL,
                                pk_date_utils.dt_chr_tsz(i_lang, m.dt_end_tstz, i_prof))) dt_end,
                        get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval
          INTO l_type, l_req, l_start, l_end, l_interval
          FROM monitorization m, monitorization_vs mvs, monitorization_vs_plan mvsp
         WHERE m.id_monitorization = mvs.id_monitorization
           AND mvs.id_monitorization_vs = i_id_monit_vs
           AND mvs.id_monitorization_vs = mvs.id_monitorization_vs
           AND mvs.id_monitorization_vs = mvsp.id_monitorization_vs;
    
        FOR i IN 1 .. length(i_format)
        LOOP
            CASE substr(i_format, i, 1)
                WHEN 'T' THEN
                    add_to_ret(l_type, l_ret);
                WHEN 'N' THEN
                    add_to_ret(l_dt_req_mess || ': ' || l_req, l_ret);
                WHEN 'I' THEN
                    add_to_ret(l_interval_mess || ': ' || l_interval, l_ret);
                WHEN 'S' THEN
                    add_to_ret(l_dt_start_mess || ': ' || l_start, l_ret);
                WHEN 'E' THEN
                    IF l_end IS NOT NULL
                    THEN
                        add_to_ret(l_dt_end_mess || ': ' || l_end, l_ret);
                    END IF;
                ELSE
                    NULL;
            END CASE;
        END LOOP;
    
        RETURN l_ret;
    END get_instructions;

    /**********************************************************************************************
    * Returns the instructions for a monitorization request according to the passed format, using 
    * combinations of the following values: N (requirement date), I (interval), S 
    * (start date), E (end date).
    *
    * @param i_lang                ID language
    * @param i_prof                Professional
    * @param i_id_monit            Monitorization ID
    * @param i_format              Output string format (optional)
    *
    * @return                      Instructions for this monitoring
    *                        
    * @author                      Tiago silva
    * @since                       19-Sep-2014
    **********************************************************************************************/
    FUNCTION get_monit_instructions_clob
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_id_monit IN monitorization.id_monitorization%TYPE,
        i_format   IN VARCHAR2 DEFAULT 'NISE'
    ) RETURN CLOB IS
        l_interval VARCHAR2(4000);
        l_start    VARCHAR2(4000);
        l_end      VARCHAR2(4000);
        l_ret      CLOB;
        l_req      VARCHAR2(4000);
    
        l_void VARCHAR2(3) := '---';
    
        l_interval_mess VARCHAR2(4000);
        l_dt_start_mess VARCHAR2(4000);
        l_dt_end_mess   VARCHAR2(4000);
        l_dt_req_mess   VARCHAR2(4000);
    
        PROCEDURE add_to_ret
        (
            i_add      IN CLOB,
            i_original IN OUT CLOB
        ) IS
        BEGIN
            IF i_original IS NULL
            THEN
                i_original := i_add;
            ELSE
                i_original := i_original || '; ' || nvl(i_add, l_void);
            END IF;
        END add_to_ret;
    
    BEGIN
    
        l_dt_start_mess := pk_message.get_message(i_lang, i_prof, 'MONITOR_T002');
        l_dt_end_mess   := pk_message.get_message(i_lang, i_prof, 'MONITOR_T004');
        l_interval_mess := pk_message.get_message(i_lang, i_prof, 'MONITOR_T003');
        l_dt_req_mess   := pk_message.get_message(i_lang, i_prof, 'MONITOR_T012');
    
        SELECT (pk_date_utils.date_char_hour_tsz(i_lang, m.dt_monitorization_tstz, i_prof.institution, i_prof.software) || ' ' ||
               pk_date_utils.dt_chr_tsz(i_lang, m.dt_monitorization_tstz, i_prof)) dt_req,
               (decode(m.flg_time,
                       pk_alert_constant.g_flg_time_n,
                       pk_message.get_message(i_lang, 'COMMON_M018'),
                       pk_date_utils.date_char_hour_tsz(i_lang,
                                                        nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                        i_prof.institution,
                                                        i_prof.software)) || ' ' ||
               decode(m.flg_time,
                       pk_alert_constant.g_flg_time_n,
                       NULL,
                       pk_date_utils.dt_chr_tsz(i_lang, nvl(m.dt_begin_tstz, m.dt_begin_tstz), i_prof))) dt_begin,
               
               (decode(m.flg_time,
                       pk_alert_constant.g_flg_time_n,
                       pk_message.get_message(i_lang, 'COMMON_M018'),
                       pk_date_utils.date_char_hour_tsz(i_lang, m.dt_end_tstz, i_prof.institution, i_prof.software)) || ' ' ||
               decode(m.flg_time,
                       pk_alert_constant.g_flg_time_n,
                       NULL,
                       pk_date_utils.dt_chr_tsz(i_lang, m.dt_end_tstz, i_prof))) dt_end,
               get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval
          INTO l_req, l_start, l_end, l_interval
          FROM monitorization m
         WHERE m.id_monitorization = i_id_monit;
    
        FOR i IN 1 .. length(i_format)
        LOOP
            CASE substr(i_format, i, 1)
                WHEN 'N' THEN
                    add_to_ret(l_dt_req_mess || ': ' || l_req, l_ret);
                WHEN 'S' THEN
                    add_to_ret(l_dt_start_mess || ': ' || l_start, l_ret);
                WHEN 'I' THEN
                    add_to_ret(l_interval_mess || ': ' || l_interval, l_ret);
                WHEN 'E' THEN
                    IF TRIM(l_end) IS NOT NULL
                    THEN
                        add_to_ret(l_dt_end_mess || ': ' || l_end, l_ret);
                    END IF;
                ELSE
                    NULL;
            END CASE;
        END LOOP;
    
        RETURN l_ret;
    END get_monit_instructions_clob;

    FUNCTION get_monit_instructions
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_id_monit IN monitorization.id_monitorization%TYPE,
        i_format   IN VARCHAR2 DEFAULT 'NISE'
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN pk_string_utils.clob_to_varchar2(i_clob            => get_monit_instructions_clob(i_lang     => i_lang,
                                                                                                 i_prof     => i_prof,
                                                                                                 i_id_monit => i_id_monit,
                                                                                                 i_format   => i_format),
                                                i_maxlenght_bytes => pk_alert_constant.g_sql_varchar2_maxsize);
    END get_monit_instructions;

    /**********************************************************************************************
    * 
    * This function only is used for H AND P feature
    * get the the monitoring description
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_monitorization      Monitoring ID
    * @param        o_desc                   Monitoring description
    * @param        o_error                  error structure for exception handling
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Sofia Mendes
    * @version                               v2.6.1.2
    * @since                                 20-Set-2011
    **********************************************************************************************/
    FUNCTION get_monitor_description
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_flg_only_active   IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        o_desc              OUT CLOB,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    BEGIN
    
        l_message := 'GET description. i_id_monitorization: ' || i_id_monitorization;
        pk_alertlog.log_debug(l_message);
    
        SELECT desc_vs || CASE
                    WHEN desc_interval IS NOT NULL THEN
                     ': ' || desc_interval
                END
          INTO o_desc
          FROM (SELECT get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval,
                       (pk_monitorization.get_vs_desc(i_lang, m.id_monitorization, i_prof, i_flg_only_active) ||
                       nvl2(m.id_prev_episode,
                             ' - (' || pk_message.get_message(i_lang,
                                                              profissional(i_prof.id,
                                                                           i_prof.institution,
                                                                           pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                              FROM episode e
                                                                                                             WHERE e.id_episode =
                                                                                                                   m.id_prev_episode),
                                                                                                            i_prof.institution)),
                                                              'IMAGE_T009') || ')',
                             '')) desc_vs
                
                  FROM monitorization m
                 WHERE m.id_monitorization = i_id_monitorization) t;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'get_monitor_description',
                                              o_error);
            RETURN FALSE;
    END get_monitor_description;

    /**********************************************************************************************
    * Return date interval
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   Profissional ID
    * @param i_interval               Monotorization's interval
    *
    * @param o_error                  error message
    *
    * @return varchar                 Return format hour/minute interval 
    *
    * @author                         Filipe Silva
    * @version                        2.6.1.2
    * @since                          2011/07/07
    **********************************************************************************************/
    FUNCTION get_format_monit_interval
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_interval IN monitorization.interval%TYPE
    ) RETURN VARCHAR IS
    
        l_hours   NUMBER;
        l_minutes NUMBER;
        l_desc    VARCHAR2(1000 CHAR);
        l_message debug_msg;
    
    BEGIN
    
        l_message := 'extract hours and minutes for interval: ' || i_interval;
        pk_alertlog.log_debug(l_message);
    
        SELECT extract(hour FROM numtodsinterval(i_interval, 'second')) +
               (extract(DAY FROM numtodsinterval(i_interval, 'second')) * 24) hours,
               to_char(trunc(SYSDATE) + numtodsinterval(i_interval, 'second'), 'mi') minutes
          INTO l_hours, l_minutes
          FROM dual;
    
        l_desc := pk_inp_util.get_format_interval(i_lang => i_lang, i_hours => l_hours, i_minutes => l_minutes);
    
        RETURN l_desc;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
        
    END get_format_monit_interval;

    /**********************************************************************************************
    * Return interval description
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   Profissional ID
    * @param i_id_monitorization      Monitorization ID
    *
    * @return varchar                 Return format hour/minute interval 
    *
    * @author                         Filipe Silva
    * @version                        2.6.1.2
    * @since                          2011/07/07
    **********************************************************************************************/
    FUNCTION get_interval_desc
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE
    ) RETURN VARCHAR IS
    
        l_not_applicable_msg sys_message.code_message%TYPE := pk_message.get_message(i_lang, 'COMMON_M018');
        l_day_msg            sys_message.code_message%TYPE := pk_message.get_message(i_lang, 'MONITORIZATION_M001');
        l_days_msg           sys_message.code_message%TYPE := pk_message.get_message(i_lang, 'MONITORIZATION_M002');
        l_desc_interval      VARCHAR2(1000 CHAR);
        l_message            debug_msg;
    
    BEGIN
    
        l_message := 'Calcule the interval for monitorization id ' || i_id_monitorization;
        pk_alertlog.log_debug(l_message);
        BEGIN
            SELECT decode(m.interval,
                          NULL,
                          l_not_applicable_msg,
                          decode(m.flg_time,
                                 pk_alert_constant.g_flg_time_b,
                                 (to_char(trunc(nvl(m.interval, 0) / 86400)) || ' ' ||
                                 decode(m.interval, 86400, l_day_msg, l_days_msg)),
                                 get_format_monit_interval(i_lang, i_prof, nvl(m.interval, 0)))) desc_interval
              INTO l_desc_interval
              FROM monitorization m
             WHERE m.id_monitorization = i_id_monitorization;
        EXCEPTION
            WHEN no_data_found THEN
                l_desc_interval := NULL;
        END;
    
        RETURN l_desc_interval;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_interval_desc;

    /**********************************************************************************************
    * Format interval (HH:MM) to seconds
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   Profissional ID
    * @param i_interval               Interval defined with this format (HH:MM)
    *
    * @return number                 Return interval in seconds 
    *
    * @author                         Filipe Silva
    * @version                        2.6.1.2
    * @since                          2011/07/07
    **********************************************************************************************/

    FUNCTION get_format_interval_to_seconds
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_interval IN VARCHAR
    ) RETURN NUMBER IS
    
        l_string  table_varchar := table_varchar();
        l_hours   PLS_INTEGER;
        l_minutes PLS_INTEGER;
        l_message debug_msg;
    
    BEGIN
    
        l_message := 'Split interval in hours and seconds ' || i_interval;
        pk_alertlog.log_debug(l_message);
        --split the interval in hours and minutes
        BEGIN
            SELECT pk_utils.str_split_l(i_interval, ':')
              INTO l_string
              FROM dual;
        EXCEPTION
            WHEN no_data_found THEN
                l_string := table_varchar();
        END;
    
        IF l_string IS NOT NULL
           AND l_string.count > 0
        THEN
        
            l_message := 'Convert hours: ' || l_string(1) || ' to seconds';
            pk_alertlog.log_debug(l_message);
            -- convert hours to seconds
            l_hours := nvl(to_number(l_string(1)), 0) * 60 * 60;
        
            l_message := 'Convert minutes: ' || l_string(2) || ' to seconds';
            pk_alertlog.log_debug(l_message);
            -- convert minutes to seconds
            l_minutes := nvl(to_number(l_string(2)), 0) * 60;
        
        END IF;
    
        RETURN l_hours + l_minutes;
    
    END get_format_interval_to_seconds;

    /**********************************************************************************************
    * Checks if monitorization has permission to execute 
    *
    * @param        i_lang                  Preferred language id for this professional
    * @param        i_prof                  Profissional ID
    * @param        i_episode               Episode ID
    * @param        i_id_monitorization     Monitorization Episode Identifier
    * @param        i_flg_time              Flag time of monitorization
    * @param        i_flg_status            Flag status of monitorization
    * @param        i_dt_begin_tstz         Begin date of monitorization
    * @param        i_flg_check_actions     Flag whether to check on action permissions or not (Y/N)
    *
    * @return                               Has permission or not (Y/N)
    *                        
    * @author                               António Neto
    * @version                              2.5.1.8.1
    * @since                                19-Oct-2011
    **********************************************************************************************/
    FUNCTION check_exec_monit
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_episode           IN episode.id_episode%TYPE,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_flg_time          IN monitorization.flg_time%TYPE,
        i_flg_status        IN monitorization.flg_status%TYPE,
        i_dt_begin_tstz     IN monitorization.dt_begin_tstz%TYPE,
        i_flg_check_actions IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN VARCHAR2 IS
        l_exec_permissions VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    
        l_num_exec PLS_INTEGER;
    
        l_dt_server TIMESTAMP(6) WITH LOCAL TIME ZONE := current_timestamp;
    
        l_monit_exec_before_date CONSTANT VARCHAR2(22 CHAR) := 'MONIT_EXEC_BEFORE_DATE';
    BEGIN
        --check permissions for active status
        CASE
            WHEN i_flg_status IN (pk_alert_constant.g_monitor_vs_canc,
                                  pk_alert_constant.g_monitor_vs_inte,
                                  pk_alert_constant.g_monitor_vs_fini) THEN
                l_exec_permissions := pk_alert_constant.g_no;
            WHEN i_flg_status = pk_alert_constant.g_monitor_vs_expire THEN
                l_exec_permissions := check_extra_take(i_lang         => i_lang,
                                                       i_prof         => i_prof,
                                                       i_episode      => i_episode,
                                                       i_task_request => i_id_monitorization);
            WHEN i_flg_time = pk_alert_constant.g_flg_time_n THEN
                l_exec_permissions := pk_alert_constant.g_no;
            WHEN i_flg_status = pk_alert_constant.g_monitor_vs_pend THEN
                IF i_dt_begin_tstz <= l_dt_server
                THEN
                    l_exec_permissions := pk_alert_constant.g_yes;
                ELSE
                    l_exec_permissions := pk_sysconfig.get_config(i_code_cf => l_monit_exec_before_date,
                                                                  i_prof    => i_prof);
                END IF;
            WHEN i_flg_status = pk_alert_constant.g_monitor_vs_exec THEN
                l_exec_permissions := pk_alert_constant.g_yes;
            WHEN i_flg_status = pk_alert_constant.g_monitor_vs_draft THEN
                l_exec_permissions := pk_alert_constant.g_no;
            ELSE
                l_exec_permissions := pk_alert_constant.g_no;
        END CASE;
    
        IF i_flg_check_actions = pk_alert_constant.g_yes
           AND l_exec_permissions = pk_alert_constant.g_yes
        THEN
            --check action permissions for execution (Draft, Expire, Pening)
            BEGIN
                SELECT COUNT(1)
                  INTO l_num_exec
                  FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, c_action_monitorization, i_flg_status)) act
                 WHERE to_state IN (pk_alert_constant.g_monitor_vs_pend,
                                    pk_alert_constant.g_monitor_vs_expire,
                                    pk_alert_constant.g_monitor_vs_exec);
            
                IF l_num_exec > 0
                THEN
                    l_exec_permissions := pk_alert_constant.g_yes;
                ELSE
                    l_exec_permissions := pk_alert_constant.g_no;
                END IF;
            EXCEPTION
                WHEN no_data_found THEN
                    l_exec_permissions := pk_alert_constant.g_no;
            END;
        END IF;
    
        RETURN l_exec_permissions;
    END check_exec_monit;

    /**********************************************************************************************
    * Checks if monitorization has permission to cancel 
    *
    * @param        i_lang                  Preferred language id for this professional
    * @param        i_prof                  Profissional ID
    * @param        i_flg_time              Flag time of monitorization
    * @param        i_flg_status            Flag status of monitorization
    * @param        i_flg_check_actions     Flag whether to check on action permissions or not (Y/N)
    *
    * @return                               Has permission or not (Y/N)
    *                        
    * @author                               António Neto
    * @version                              2.5.1.8.1
    * @since                                20-Oct-2011
    **********************************************************************************************/
    FUNCTION check_cancel_monit
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_flg_time          IN monitorization.flg_time%TYPE,
        i_flg_status        IN monitorization.flg_status%TYPE,
        i_flg_check_actions IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN VARCHAR2 IS
        l_canc_permissions VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    
        l_num_canc PLS_INTEGER;
    BEGIN
        --check permissions for active status
        CASE
            WHEN i_flg_status IN (pk_alert_constant.g_monitor_vs_canc,
                                  pk_alert_constant.g_monitor_vs_inte,
                                  pk_alert_constant.g_monitor_vs_fini,
                                  pk_alert_constant.g_monitor_vs_expire) THEN
                l_canc_permissions := pk_alert_constant.g_no;
            WHEN i_flg_time = pk_alert_constant.g_flg_time_n THEN
                l_canc_permissions := pk_alert_constant.g_yes;
            WHEN i_flg_status IN (pk_alert_constant.g_monitor_vs_pend,
                                  pk_alert_constant.g_monitor_vs_exec,
                                  pk_alert_constant.g_monitor_vs_draft) THEN
                l_canc_permissions := pk_alert_constant.g_yes;
            ELSE
                l_canc_permissions := pk_alert_constant.g_no;
        END CASE;
    
        IF i_flg_check_actions = pk_alert_constant.g_yes
           AND l_canc_permissions = pk_alert_constant.g_yes
        THEN
            --check action permissions for execution (Draft, Expire, Pening)
            BEGIN
                SELECT COUNT(1)
                  INTO l_num_canc
                  FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, c_action_monitorization, i_flg_status)) act
                 WHERE to_state IN (pk_alert_constant.g_monitor_vs_canc);
            
                IF l_num_canc > 0
                THEN
                    l_canc_permissions := pk_alert_constant.g_yes;
                ELSE
                    l_canc_permissions := pk_alert_constant.g_no;
                END IF;
            EXCEPTION
                WHEN no_data_found THEN
                    l_canc_permissions := pk_alert_constant.g_no;
            END;
        END IF;
    
        RETURN l_canc_permissions;
    END check_cancel_monit;

    /**********************************************************************************************
    * Checks if monitorization has permission to see Detail screen 
    *
    * @param        i_flg_status            Flag status of monitorization
    *
    * @return                               Has permission or not (Y/N)
    *                        
    * @author                               António Neto
    * @version                              2.5.1.8.1
    * @since                                20-Oct-2011
    **********************************************************************************************/
    FUNCTION check_detail_monit(i_flg_status IN monitorization.flg_status%TYPE) RETURN VARCHAR2 IS
    BEGIN
        IF i_flg_status IS NOT NULL
        THEN
            RETURN pk_alert_constant.g_yes;
        ELSE
            RETURN pk_alert_constant.g_no;
        END IF;
    END check_detail_monit;

    /**********************************************************************************************
    * Check the possibility to be recorded in the system an execution after the task was expired.
    * It was defined that it should be possible to record in the system the last execution made after the task expiration.
    * It should not be possible to record more than one excecution after the task was expired. 
    *
    * @param       i_lang                    Professional preferred language
    * @param       i_prof                    Professional identification and its context (institution and software)
    * @param       i_episode                 Episode ID
    * @param       i_task_request            Task request ID (ID_MONITORIZATION)
    * @param       o_error                   Error information
    *
    * @return                                'Y' An execution is allowed. 'N' No execution is allowed (or the task has not expired).
    *
    * @author                                António Neto
    * @version                               2.5.1.8
    * @since                                 13-Sep-2011
    **********************************************************************************************/
    FUNCTION check_extra_take
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN cpoe_process_task.id_task_request%TYPE
    ) RETURN VARCHAR IS
        co_function_name CONSTANT VARCHAR2(30 CHAR) := 'CHECK_EXTRA_TAKE';
        l_error                   t_error_out;
        l_execution_allowed       VARCHAR2(1 CHAR);
        l_status                  monitorization.flg_status%TYPE;
        l_dt_expire               monitorization.dt_cancel_tstz%TYPE;
        l_post_expired_executions NUMBER;
        l_message                 debug_msg;
    
    BEGIN
        -- By default assumes the execution is not allowed
        l_execution_allowed := pk_alert_constant.g_no;
    
        -- Check if the task has expired
        l_message := 'Get status';
        SELECT m.flg_status, m.dt_cancel_tstz
          INTO l_status, l_dt_expire
          FROM monitorization m
         WHERE m.id_monitorization = i_task_request;
    
        -- Hidrics expired 
        IF l_status = pk_alert_constant.g_monitor_vs_expire
        THEN
        
            -- Check if already exists one execution after the task was expired
            l_message := 'Counting post-expired executions';
            SELECT COUNT(*)
              INTO l_post_expired_executions
              FROM monitorization_vs_plan mvsp
             INNER JOIN monitorization_vs mvs
                ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
             INNER JOIN monitorization m
                ON mvs.id_monitorization = m.id_monitorization
             WHERE m.id_monitorization = i_task_request
               AND mvsp.flg_status <> pk_alert_constant.g_monitor_vs_canc
               AND (trunc(mvsp.start_time, 'MI') >= trunc(l_dt_expire, 'MI') OR
                   trunc(mvsp.end_time, 'MI') >= trunc(l_dt_expire, 'MI'));
        
            -- If there is not one execution after the task has been expired, then execution is allowed
            IF l_post_expired_executions = 0
            THEN
                l_execution_allowed := pk_alert_constant.g_yes;
            END IF;
        
        END IF;
    
        RETURN l_execution_allowed;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => l_message,
                                              i_owner    => c_package_owner,
                                              i_package  => c_package_name,
                                              i_function => co_function_name,
                                              o_error    => l_error);
            RAISE;
    END check_extra_take;
    --
    /**********************************************************************************************
    * get the monitoring description
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_monitorization      Monitoring ID
    *
    * @return       Monitoring description
    *                        
    * @author                                Alexandre Santos
    * @version                               v2.6.4
    * @since                                 23-Dec-2014
    **********************************************************************************************/
    FUNCTION get_monitor_description
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_id_co_sign_hist   IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN CLOB IS
        l_func_name CONSTANT VARCHAR2(32 CHAR) := 'GET_MONITOR_DESCRIPTION';
        --
        l_debug_msg debug_msg;
        --
        l_error t_error_out;
        l_ret   CLOB;
    BEGIN
        l_debug_msg := 'CALL PK_MONITORIZATION.GET_MONITOR_DESCRIPTION';
        pk_alertlog.log_debug(text => l_debug_msg, object_name => c_package_name, sub_object_name => l_func_name);
        IF NOT pk_monitorization.get_monitor_description(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_monitorization => i_id_monitorization,
                                                         i_flg_only_active   => pk_alert_constant.get_no,
                                                         o_desc              => l_ret,
                                                         o_error             => l_error)
        THEN
            l_debug_msg := 'ERROR CALLING PK_MONITORIZATION.GET_MONITOR_DESCRIPTION';
            pk_alertlog.log_error(text => l_debug_msg, object_name => c_package_name, sub_object_name => l_func_name);
            l_ret := NULL;
        END IF;
    
        RETURN l_ret;
    END get_monitor_description;

    /**********************************************************************************************
    * get the monitoring description
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_monitorization      Monitoring ID
    *
    * @return       Monitoring start date
    *                        
    * @author                                Nuno Alves
    * @version                               v2.6.5
    * @since                                 14-10-2015
    **********************************************************************************************/
    FUNCTION get_monitor_start_date
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_id_co_sign_hist   IN co_sign_hist.id_co_sign_hist%TYPE DEFAULT NULL
    ) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
        l_func_name CONSTANT VARCHAR2(32 CHAR) := 'GET_MONITOR_DESCRIPTION';
        --
        l_debug_msg debug_msg;
        --
        l_error t_error_out;
        l_ret   monitorization.dt_begin_tstz%TYPE;
    BEGIN
        l_debug_msg := 'GET DT_BEGIN_TSTZ FOR ID_MONITORIZATION' || i_id_monitorization;
        pk_alertlog.log_debug(l_func_name || ' | ' || l_debug_msg);
        SELECT decode(m.flg_time, pk_alert_constant.g_flg_time_n, NULL, nvl(m.dt_begin_tstz, m.dt_monitorization_tstz))
          INTO l_ret
          FROM monitorization m
         WHERE m.id_monitorization = i_id_monitorization;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_monitor_start_date;

    --
    /**********************************************************************************************
    * get the monitoring instructions
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_monitorization      Monitoring ID
    *
    * @return       Monitoring instructions
    *                        
    * @author                                Alexandre Santos
    * @version                               v2.6.4
    * @since                                 23-Dec-2014
    **********************************************************************************************/
    FUNCTION get_monitor_instructions
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_id_co_sign_hist   IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN CLOB IS
    BEGIN
        RETURN get_monit_instructions_clob(i_lang     => i_lang,
                                           i_prof     => i_prof,
                                           i_id_monit => i_id_monitorization,
                                           i_format   => 'SIE');
    END get_monitor_instructions;

    /**********************************************************************************************
    * get monitorization action description
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_co_sign             Co-sign ID
    *
    * @return       Monitoring action description
    *                        
    * @author                                Vanessa Barsottelli
    * @version                               v2.6.4
    * @since                                 14-Jan-2015
    **********************************************************************************************/
    FUNCTION get_monitor_action_desc
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_id_action         IN action.id_action%TYPE,
        i_id_co_sign_hist   IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(25 CHAR) := 'GET_MONITOR_ACTION_DESC';
    
        l_sm_action_order       sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                        i_prof      => i_prof,
                                                                                        i_code_mess => 'MONITOR_T023');
        l_sm_action_cancel      sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                        i_prof      => i_prof,
                                                                                        i_code_mess => 'MONITOR_M019');
        l_sm_action_discontinue sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                        i_prof      => i_prof,
                                                                                        i_code_mess => 'MONITOR_M020');
        l_description           sys_message.desc_message%TYPE;
        l_message               debug_msg;
    
        l_id_action_add    action.id_action%TYPE;
        l_id_action_cancel action.id_action%TYPE;
    BEGIN
    
        IF i_id_monitorization IS NULL
           OR i_id_monitorization IS NULL
        THEN
            RETURN NULL;
        END IF;
    
        l_id_action_add    := pk_co_sign.get_id_action(i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_add,
                                                       i_action                 => NULL);
        l_id_action_cancel := pk_co_sign.get_id_action(i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_cancel,
                                                       i_action                 => NULL);
    
        l_message := 'GET ACTION DESCRIPTION FOR i_id_monitorization = ' || i_id_monitorization || ', i_id_action = ' ||
                     i_id_action;
        SELECT CASE i_id_action
                   WHEN l_id_action_add THEN
                    l_sm_action_order
                   WHEN l_id_action_cancel THEN
                    CASE m.flg_status
                        WHEN pk_alert_constant.g_monitor_vs_canc THEN
                         l_sm_action_cancel
                        WHEN pk_alert_constant.g_monitor_vs_inte THEN
                         l_sm_action_discontinue
                    END
                   ELSE
                    NULL
               END
          INTO l_description
          FROM monitorization m
         WHERE m.id_monitorization = i_id_monitorization;
    
        RETURN l_description;
    
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error t_error_out;
            BEGIN
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  l_message,
                                                  c_package_owner,
                                                  c_package_name,
                                                  l_func_name,
                                                  l_error);
                RETURN NULL;
            END;
    END get_monitor_action_desc;

    FUNCTION inactivate_monitorztn_tasks
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_inst        IN institution.id_institution%TYPE,
        i_ids_exclude IN OUT table_number,
        o_has_error   OUT BOOLEAN,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_cancel_cfg sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'INACTIVATE_CANCEL_REASON',
                                                                      i_prof    => i_prof);
    
        l_descontinued_cfg sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'INACTIVATE_DISCONTINUED_REASON',
                                                                            i_prof    => i_prof);
    
        l_cancel_id cancel_reason.id_cancel_reason%TYPE := pk_cancel_reason.get_id_by_content(i_lang,
                                                                                              i_prof,
                                                                                              l_cancel_cfg);
    
        l_descontinued_id cancel_reason.id_cancel_reason%TYPE := pk_cancel_reason.get_id_by_content(i_lang,
                                                                                                    i_prof,
                                                                                                    l_descontinued_cfg);
    
        l_tbl_config t_tbl_config_table := pk_core_config.get_values_by_mkt_inst_sw(i_lang => NULL,
                                                                                    i_prof => profissional(0, i_inst, 0),
                                                                                    i_area => 'MONITORIZATION_INACTIVATE');
    
        l_max_rows sys_config.value%TYPE := pk_sysconfig.get_config(i_prof    => i_prof,
                                                                    i_code_cf => 'INACTIVATE_TASKS_MAX_NUMBER_ROWS');
    
        l_monitorization_req table_number;
        l_final_status       table_varchar;
    
        l_error t_error_out;
        g_other_exception EXCEPTION;
    
        l_tbl_error_ids table_number := table_number();
    
        --The cursor will not fetch the records for the ids (id_monitorization) sent in i_ids_exclude        
        CURSOR c_monitorization_req(ids_exclude IN table_number) IS
            SELECT m.id_monitorization, cfg.field_04
              FROM monitorization m
             INNER JOIN episode e
                ON e.id_episode = m.id_episode
              LEFT JOIN episode prev_e
                ON prev_e.id_prev_episode = e.id_episode
               AND e.id_visit = prev_e.id_visit
             INNER JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                          *
                           FROM TABLE(l_tbl_config) t) cfg
                ON cfg.field_01 = m.flg_status
              LEFT JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                          t.column_value
                           FROM TABLE(i_ids_exclude) t) t_ids
                ON t_ids.column_value = m.id_monitorization
             WHERE e.id_institution = i_inst
               AND e.dt_end_tstz IS NOT NULL
               AND (prev_e.id_episode IS NULL OR prev_e.flg_status = pk_alert_constant.g_inactive)
               AND pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                    i_timestamp => (pk_date_utils.add_to_ltstz(i_timestamp => e.dt_end_tstz,
                                                                                               i_amount    => cfg.field_02,
                                                                                               i_unit      => cfg.field_03))) <=
                   pk_date_utils.trunc_insttimezone(i_prof => i_prof, i_timestamp => current_timestamp)
               AND rownum <= l_max_rows
               AND t_ids.column_value IS NULL;
    
    BEGIN
    
        o_has_error := FALSE;
    
        OPEN c_monitorization_req(i_ids_exclude);
        FETCH c_monitorization_req BULK COLLECT
            INTO l_monitorization_req, l_final_status;
        CLOSE c_monitorization_req;
    
        IF l_monitorization_req.count > 0
        THEN
            FOR i IN 1 .. l_monitorization_req.count
            LOOP
                IF l_final_status(i) IN (pk_alert_constant.g_monitor_vs_inte, pk_alert_constant.g_monitor_vs_canc)
                THEN
                    SAVEPOINT init_cancel;
                    IF NOT pk_monitorization.cancel_monitor_req(i_lang              => i_lang,
                                                           i_id_monitorization => l_monitorization_req(i),
                                                           i_prof              => i_prof,
                                                           i_notes             => NULL,
                                                           i_prof_cat_type     => NULL,
                                                           i_commit_data       => pk_alert_constant.get_no,
                                                           i_id_cancel_reason  => CASE
                                                                                      WHEN l_final_status(i) =
                                                                                           pk_alert_constant.g_monitor_vs_inte THEN
                                                                                       l_descontinued_id
                                                                                      ELSE
                                                                                       l_cancel_id
                                                                                  END,
                                                           o_error             => l_error)
                    THEN
                        ROLLBACK TO init_cancel;
                    
                        --If, for the given id_monitorization, an error is generated, o_has_error is set as TRUE,
                        --this way, the loop cicle may continue, but the system will know that at least one error has happened
                        o_has_error := TRUE;
                    
                        --A log for the id_monitorization that raised the error must be generated 
                        pk_alert_exceptions.reset_error_state;
                        l_error.err_desc := 'ERROR CALLING PK_MONITORIZATION.CANCEL_MONITOR_REQ FOR RECORD ' ||
                                            l_monitorization_req(i);
                        pk_alert_exceptions.process_error(i_lang,
                                                          SQLCODE,
                                                          SQLERRM,
                                                          l_error.err_desc,
                                                          c_package_owner,
                                                          c_package_name,
                                                          'INACTIVATE_MONITORZTN_TASKS',
                                                          o_error);
                    
                        --The array for the ids (id_monitorization) that raised the error is incremented
                        l_tbl_error_ids.extend();
                        l_tbl_error_ids(l_tbl_error_ids.count) := l_monitorization_req(i);
                    
                        CONTINUE;
                    END IF;
                END IF;
            END LOOP;
        
            --When the number of error ids match the max number of rows that can be processed for each call,
            --it means that no id_monitorization has been inactivated.
            --The next time the Job would be executed, the cursor would fetch the same set fetched on the previous call,
            --and therefore, from this point on, no more records would be inactivated.
            IF l_tbl_error_ids.count = l_max_rows
            THEN
                FOR i IN l_tbl_error_ids.first .. l_tbl_error_ids.last
                LOOP
                    --i_ids_exclude is an IN OUT parameter, and is incremented with the ids (id_monitorization) that could not
                    --be inactivated with the current call of the function
                    i_ids_exclude.extend();
                    i_ids_exclude(i_ids_exclude.count) := l_tbl_error_ids(i);
                END LOOP;
            
                --Since no inactivations were performed with the current call, a new call to this function is performed,
                --however, this time, the array i_ids_exclude will include a list of ids that cannot be fetched by the cursor
                --on the next call. The recursion will be perfomed until at least one record is inactivated, or the cursor
                --has no more records to fetch.
                --Note: i_ids_exclude is incremented and is an IN OUT parameter, therefore, 
                --it will hold all the ids that were not inactivated from ALL calls.            
                IF NOT pk_monitorization.inactivate_monitorztn_tasks(i_lang        => i_lang,
                                                                     i_prof        => i_prof,
                                                                     i_inst        => i_inst,
                                                                     i_ids_exclude => i_ids_exclude,
                                                                     o_has_error   => o_has_error,
                                                                     o_error       => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error.err_desc,
                                              c_package_owner,
                                              c_package_name,
                                              'INACTIVATE_MONITORZTN_TASKS',
                                              l_error);
            RETURN FALSE;
    END inactivate_monitorztn_tasks;

    FUNCTION get_order_plan_report
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_task_request  IN table_number,
        i_cpoe_dt_begin IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_cpoe_dt_end   IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_plan_rep      OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_order_plan_rep       t_tbl_order_recurr_plan;
        l_order_plan_rep_union t_tbl_order_recurr_plan := t_tbl_order_recurr_plan();
        l_tbl_interv_presc_det table_number;
        l_tbl_ipd_dt_begin     table_timestamp_tstz;
        l_last_reached         VARCHAR2(20 CHAR);
        l_order_recurrence     order_recurr_plan.id_order_recurr_plan%TYPE;
        l_t_order_recurr       table_number;
        l_cp_begin             TIMESTAMP WITH LOCAL TIME ZONE;
        l_cp_end               TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_interv_presc_plan_last interv_presc_plan.id_interv_presc_plan%TYPE;
        l_interv_presc_plan_next interv_presc_plan.id_interv_presc_plan%TYPE;
    
        l_tbl_monitorization table_number;
        l_id_monit_vs        monitorization_vs.id_monitorization_vs%TYPE;
    
        l_tbl_rec_exec_static t_tbl_cpoe_execution;
        l_tbl_rec_exec_final  t_tbl_cpoe_execution := t_tbl_cpoe_execution();
        l_last_date           monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_interval            monitorization.interval%TYPE;
        l_calc_last_date      monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_dt_end              monitorization.dt_end_tstz%TYPE;
    
        l_flg_status_m monitorization.flg_status%TYPE;
    
        l_error t_error_out;
    BEGIN
    
        IF i_cpoe_dt_begin IS NULL
        THEN
            IF NOT pk_episode.get_epis_dt_begin_tstz(i_lang          => i_lang,
                                                     i_prof          => i_prof,
                                                     i_id_episode    => i_episode,
                                                     o_dt_begin_tstz => l_cp_begin,
                                                     o_error         => o_error)
            THEN
                l_cp_begin := current_timestamp;
            END IF;
        ELSE
            l_cp_begin := i_cpoe_dt_begin;
        END IF;
    
        IF i_cpoe_dt_end IS NULL
        THEN
            l_cp_end := nvl(pk_date_utils.add_days_to_tstz(i_timestamp => l_cp_begin, i_days => 1), current_timestamp);
        ELSE
            l_cp_end := i_cpoe_dt_end;
        END IF;
    
        SELECT a.id_monitorization
          BULK COLLECT
          INTO l_tbl_monitorization
          FROM monitorization a
         WHERE a.id_episode = i_episode
           AND a.flg_status NOT IN ('E', 'R', 'C');
    
        FOR i IN 1 .. l_tbl_monitorization.count
        LOOP
            SELECT a.id_monitorization_vs
              INTO l_id_monit_vs
              FROM monitorization_vs a
             WHERE a.id_monitorization = l_tbl_monitorization(i)
               AND rownum = 1;
        
            SELECT t_rec_cpoe_execution(id_task_type    => NULL,
                                         id_prescription => t.id_monit,
                                         planned_date    => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                        i_date => t.dt_plan,
                                                                                        i_prof => i_prof),
                                         exec_date       => CASE
                                                                WHEN t.dt_start_time IS NULL THEN
                                                                 NULL
                                                                ELSE
                                                                 pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => t.dt_start_time, i_prof => i_prof)
                                                            END,
                                         exec_notes      => NULL,
                                         out_of_period   => t.out_of_period)
              BULK COLLECT
              INTO l_tbl_rec_exec_static
              FROM (SELECT b.id_monitorization id_monit,
                           a.dt_plan_tstz dt_plan,
                           a.start_time dt_start_time,
                           'N' out_of_period
                      FROM monitorization_vs_plan a
                     INNER JOIN monitorization_vs b
                        ON a.id_monitorization_vs = b.id_monitorization_vs
                     WHERE a.id_monitorization_vs = l_id_monit_vs
                       AND a.flg_status = pk_monitorization.g_monit_vs_plan_final
                       AND a.dt_plan_tstz BETWEEN l_cp_begin AND l_cp_end
                    UNION ALL
                    SELECT z.id_monit, z.dt_plan, z.dt_start_time, z.out_of_period
                      FROM (SELECT b.id_monitorization id_monit,
                                   a.dt_plan_tstz dt_plan,
                                   a.start_time dt_start_time,
                                   'Y' out_of_period
                              FROM monitorization_vs_plan a
                             INNER JOIN monitorization_vs b
                                ON a.id_monitorization_vs = b.id_monitorization_vs
                             WHERE a.id_monitorization_vs = l_id_monit_vs
                               AND a.dt_plan_tstz < l_cp_begin
                               AND a.flg_status = pk_monitorization.g_monit_vs_plan_final
                             ORDER BY a.dt_plan_tstz DESC) z
                     WHERE rownum = 1) t;
        
            BEGIN
                SELECT DISTINCT a.dt_plan_tstz
                  INTO l_last_date
                  FROM monitorization_vs_plan a
                 WHERE a.id_monitorization_vs = l_id_monit_vs
                   AND a.flg_status != pk_monitorization.g_monit_vs_plan_final
                 ORDER BY a.dt_plan_tstz DESC;
            EXCEPTION
                WHEN OTHERS THEN
                    l_last_date := NULL;
            END;
        
            IF l_last_date IS NOT NULL
               AND l_last_date <= l_cp_end
            THEN
            
                SELECT m.interval, m.dt_end_tstz
                  INTO l_interval, l_dt_end
                  FROM monitorization m
                 WHERE m.id_monitorization = l_tbl_monitorization(i);
            
                SELECT m.flg_status
                  INTO l_flg_status_m
                  FROM monitorization m
                 WHERE m.id_monitorization = l_tbl_monitorization(i);
            
                IF l_flg_status_m != 'I'
                THEN
                    --It is possible to order a monitorization with a frequency of 00h:00m, which
                    --means there are no real planed dates for execution. For these cases, the monitorization
                    --will be stored with an interval of 0, and in the application, after an execution, 
                    --the monitorization will automatically be again set as 'delayed'.
                    --Therefore, for these cases, the function will no longer return the planned executions.
                    IF l_interval IS NOT NULL
                       AND l_interval > 0
                    THEN
                        l_calc_last_date := l_last_date + numtodsinterval(l_interval, 'SECOND');
                    
                        WHILE l_calc_last_date < l_cp_end
                              AND (l_calc_last_date <= l_dt_end OR l_dt_end IS NULL)
                        LOOP
                            IF l_calc_last_date >= l_cp_begin
                            THEN
                                l_tbl_rec_exec_static.extend;
                                l_tbl_rec_exec_static(l_tbl_rec_exec_static.count) := t_rec_cpoe_execution(id_task_type    => NULL,
                                                                                                           id_prescription => l_tbl_monitorization(i),
                                                                                                           planned_date    => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                                                          i_date => l_calc_last_date,
                                                                                                                                                          i_prof => i_prof),
                                                                                                           exec_date       => NULL,
                                                                                                           exec_notes      => NULL,
                                                                                                           out_of_period   => pk_alert_constant.g_no);
                            END IF;
                            l_calc_last_date := l_calc_last_date + numtodsinterval(l_interval, 'SECOND');
                        
                        END LOOP;
                    END IF;
                END IF;
            END IF;
            l_tbl_rec_exec_final := l_tbl_rec_exec_final MULTISET UNION l_tbl_rec_exec_static;
        END LOOP;
    
        OPEN o_plan_rep FOR
            SELECT t.id_prescription, t.planned_date, t.exec_date, t.exec_notes, t.out_of_period
              FROM TABLE(l_tbl_rec_exec_final) t;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error.err_desc,
                                              c_package_owner,
                                              c_package_name,
                                              'INACTIVATE_MONITORZTN_TASKS',
                                              l_error);
            pk_types.open_my_cursor(o_plan_rep);
            RETURN FALSE;
        
    END get_order_plan_report;

--
-- INITIALIZATION SECTION
-- 

BEGIN
    -- Initializes log context
    pk_alertlog.log_init(object_name => c_package_name);

END pk_monitorization;
/
CREATE OR REPLACE PACKAGE BODY pk_monitorization AS

    --
    -- PRIVATE SUBTYPES
    -- 

    SUBTYPE obj_name IS VARCHAR2(32 CHAR);
    SUBTYPE debug_msg IS VARCHAR2(200 CHAR);

    --
    -- PRIVATE CONSTANTS
    -- 

    -- Package info
    c_package_owner CONSTANT obj_name := 'ALERT';
    c_package_name  CONSTANT obj_name := pk_alertlog.who_am_i();

    --

    c_domain_monit_time        CONSTANT sys_domain.code_domain%TYPE := 'MONITORIZATION.FLG_TIME';
    c_flg_doctor               CONSTANT category.flg_type%TYPE := 'D';
    c_planned_date             CONSTANT sys_config.value%TYPE := 'PLANNED_DATE';
    c_id_sys_alert_vital_sign  CONSTANT sys_alert.id_sys_alert%TYPE := 11;
    c_id_sys_alert_vs_pcontext CONSTANT sys_alert.id_sys_alert%TYPE := 43;
    c_action_monitorization    CONSTANT action.subject%TYPE := 'MONITORIZATION';

    --
    -- FUNCTIONS
    -- 

    /**********************************************************************************************
    * Checks if monitorization was executed at least once
    * @param        i_id_monitorization     Monitorization Episode Identifier
    
    * @return                               TRUE or FALSE
    *                        
    * @author                               Nuno Alves
    * @version                              2.6.5.0.1
    * @since                                06-05-2015
    **********************************************************************************************/
    FUNCTION check_monit_has_execs(i_id_monitorization IN monitorization.id_monitorization%TYPE) RETURN BOOLEAN IS
        l_count NUMBER;
    BEGIN
        SELECT COUNT(1)
          INTO l_count
          FROM monitorization m
          JOIN monitorization_vs mvs
            ON m.id_monitorization = mvs.id_monitorization
          JOIN monitorization_vs_plan mvsp
            ON mvs.id_monitorization_vs = mvsp.id_monitorization_vs
         WHERE m.id_monitorization = i_id_monitorization
           AND mvsp.flg_status = g_monit_vs_plan_final;
    
        RETURN l_count > 0;
    END check_monit_has_execs;

    /**********************************************************************************************
    * set co-sign feature
    *
    * @param      i_lang                   preferred language id for this professional
    * @param      i_prof                   professional type
    * @param      io_monit                 monitorization type
    * @param      o_error                  error message
    *
    * @return     boolean                  true on success, otherwise false
    *
    * @author                              Filipe Machado
    * @version                             2.5.0.7.3
    * @since                               2009/11/18
    **********************************************************************************************/
    FUNCTION set_cosign
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN OUT monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(32 CHAR) := 'SET_COSIGN';
        --
        l_debug_msg            debug_msg;
        l_id_co_sign           co_sign.id_co_sign%TYPE;
        l_id_co_sign_hist      co_sign_hist.id_co_sign_hist%TYPE;
        l_flg_prof_need_cosign VARCHAR2(1 CHAR);
        l_rowsid               table_varchar := table_varchar();
        --
        l_exception EXCEPTION;
        --
        --Code based on Filipe Machado function with the same name
        FUNCTION check_cosign
        (
            i_lang                   IN language.id_language%TYPE,
            i_prof                   IN profissional,
            i_episode                IN episode.id_episode%TYPE,
            i_id_monitorization      IN monitorization.id_monitorization%TYPE,
            i_flg_status             IN monitorization.flg_status%TYPE,
            i_cosign_def_action_type IN VARCHAR2,
            o_flg_prof_need_cosign   OUT VARCHAR2,
            o_error                  OUT t_error_out
        ) RETURN BOOLEAN IS
        BEGIN
            -- check whether the task needs of confirmation through co-sign or not
            IF NOT pk_co_sign_api.check_prof_needs_cosign(i_lang                   => i_lang,
                                                          i_prof                   => i_prof,
                                                          i_episode                => i_episode,
                                                          i_task_type              => pk_alert_constant.g_task_monitoring,
                                                          i_cosign_def_action_type => i_cosign_def_action_type,
                                                          o_flg_prof_need_cosign   => o_flg_prof_need_cosign,
                                                          o_error                  => o_error)
            THEN
                pk_alert_exceptions.reset_error_state;
                RETURN FALSE;
            END IF;
        
            -- insert on the status log
            IF NOT t_ti_log.ins_log(i_lang       => i_lang,
                                    i_prof       => i_prof,
                                    i_id_episode => i_episode,
                                    i_flg_status => i_flg_status,
                                    i_id_record  => i_id_monitorization,
                                    i_flg_type   => pk_alert_constant.g_ti_type_mn,
                                    o_error      => o_error)
            THEN
                pk_alert_exceptions.reset_error_state;
                RETURN FALSE;
            END IF;
        
            RETURN TRUE;
        END check_cosign;
    BEGIN
        l_debug_msg := 'CALL CHECK_COSIGN';
        pk_alertlog.log_debug(text => l_debug_msg, object_name => c_package_name, sub_object_name => l_func_name);
        IF NOT check_cosign(i_lang                   => i_lang,
                       i_prof                   => i_prof,
                       i_episode                => io_monit.id_epis,
                       i_id_monitorization      => io_monit.id_monit,
                       i_flg_status             => io_monit.flg_status,
                       i_cosign_def_action_type => CASE
                                                       WHEN io_monit.flg_monitorization_action IN
                                                            (pk_monitorization.g_order_action, pk_monitorization.g_draft_action) THEN
                                                        pk_co_sign_api.g_cosign_action_def_add
                                                       WHEN io_monit.flg_monitorization_action = pk_monitorization.g_cancel_action THEN
                                                        pk_co_sign_api.g_cosign_action_def_cancel
                                                       ELSE
                                                        pk_co_sign_api.g_cosign_action_def_add
                                                   END,
                       o_flg_prof_need_cosign   => l_flg_prof_need_cosign,
                       o_error                  => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        CASE
            WHEN io_monit.flg_monitorization_action = pk_monitorization.g_order_action
                 AND l_flg_prof_need_cosign = pk_alert_constant.g_yes THEN
                l_debug_msg := 'CALL PK_CO_SIGN_API.SET_PENDING_CO_SIGN_TASK';
                pk_alertlog.log_debug(text            => l_debug_msg,
                                      object_name     => c_package_name,
                                      sub_object_name => l_func_name);
                IF NOT pk_co_sign_api.set_pending_co_sign_task(i_lang                   => i_lang,
                                                               i_prof                   => i_prof,
                                                               i_episode                => io_monit.id_epis,
                                                               i_id_task_type           => pk_alert_constant.g_task_monitoring,
                                                               i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_add,
                                                               i_id_task                => io_monit.id_monit,
                                                               i_id_task_group          => io_monit.id_monit,
                                                               i_id_order_type          => io_monit.id_order_type,
                                                               i_id_prof_created        => i_prof.id,
                                                               i_id_prof_ordered_by     => io_monit.id_prof_order,
                                                               i_dt_created             => current_timestamp,
                                                               i_dt_ordered_by          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                         i_prof,
                                                                                                                         io_monit.dt_order_str,
                                                                                                                         NULL),
                                                               o_id_co_sign             => l_id_co_sign,
                                                               o_id_co_sign_hist        => l_id_co_sign_hist,
                                                               o_error                  => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                l_debug_msg := 'CALL TS_MONITORIZATION.UPD';
                pk_alertlog.log_debug(text            => l_debug_msg,
                                      object_name     => c_package_name,
                                      sub_object_name => l_func_name);
                ts_monitorization.upd(id_monitorization_in => io_monit.id_monit,
                                      id_co_sign_order_in  => l_id_co_sign,
                                      rows_out             => l_rowsid);
                l_debug_msg := 'CALL t_data_gov_mnt.process_update';
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'MONITORIZATION',
                                              i_rowids     => l_rowsid,
                                              o_error      => o_error);
                io_monit.id_co_sign_order := l_id_co_sign;
            WHEN io_monit.flg_monitorization_action = pk_monitorization.g_cancel_action THEN
                IF l_flg_prof_need_cosign = pk_alert_constant.g_no
                   AND io_monit.id_co_sign_order IS NOT NULL
                   AND NOT check_monit_has_execs(io_monit.id_monit)
                THEN
                    --This means that the professional doesn't need co_sign to cancel the monitorization 
                    -- and the monitorization has not been executed yet
                    l_debug_msg := 'CALL TO PK_CO_SIGN_API.SET_TASK_OUTDATED - ID_CO_SIGN:' ||
                                   io_monit.id_co_sign_order;
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                    IF NOT pk_co_sign_api.set_task_outdated(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_episode         => io_monit.id_epis,
                                                            i_id_co_sign      => io_monit.id_co_sign_order,
                                                            i_dt_update       => current_timestamp,
                                                            o_id_co_sign_hist => l_id_co_sign_hist,
                                                            o_error           => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                ELSIF l_flg_prof_need_cosign = pk_alert_constant.g_yes
                THEN
                    -- Professional needs co_sign to cancel the monitorization
                    l_debug_msg := 'CALL PK_CO_SIGN_API.SET_PENDING_CO_SIGN_TASK';
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                
                    IF NOT pk_co_sign_api.set_pending_co_sign_task(i_lang                   => i_lang,
                                                                   i_prof                   => i_prof,
                                                                   i_episode                => io_monit.id_epis,
                                                                   i_id_task_type           => pk_alert_constant.g_task_monitoring,
                                                                   i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_cancel,
                                                                   i_id_task                => io_monit.id_monit,
                                                                   i_id_task_group          => io_monit.id_monit,
                                                                   i_id_order_type          => io_monit.id_order_type,
                                                                   i_id_prof_created        => i_prof.id,
                                                                   i_id_prof_ordered_by     => io_monit.id_prof_order,
                                                                   i_dt_created             => current_timestamp,
                                                                   i_dt_ordered_by          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                             i_prof,
                                                                                                                             io_monit.dt_order_str,
                                                                                                                             NULL),
                                                                   o_id_co_sign             => l_id_co_sign,
                                                                   o_id_co_sign_hist        => l_id_co_sign_hist,
                                                                   o_error                  => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    -- Check if monit has not been executed yet
                    IF io_monit.id_co_sign_order IS NOT NULL
                       AND NOT check_monit_has_execs(io_monit.id_monit)
                    THEN
                        l_debug_msg := 'CALL PK_CO_SIGN_API.SET_TASK_OUTDATED - ID_CO_SIGN:' ||
                                       io_monit.id_co_sign_order;
                        pk_alertlog.log_debug(text            => l_debug_msg,
                                              object_name     => c_package_name,
                                              sub_object_name => l_func_name);
                        IF NOT pk_co_sign_api.set_task_outdated(i_lang            => i_lang,
                                                                i_prof            => i_prof,
                                                                i_episode         => io_monit.id_epis,
                                                                i_id_co_sign      => io_monit.id_co_sign_order,
                                                                i_dt_update       => current_timestamp,
                                                                o_id_co_sign_hist => l_id_co_sign_hist,
                                                                o_error           => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    END IF;
                
                    l_debug_msg := 'CALL TS_MONITORIZATION.UPD';
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                    ts_monitorization.upd(id_monitorization_in => io_monit.id_monit,
                                          id_co_sign_cancel_in => l_id_co_sign,
                                          rows_out             => l_rowsid);
                    l_debug_msg := 'CALL t_data_gov_mnt.process_update';
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'MONITORIZATION',
                                                  i_rowids     => l_rowsid,
                                                  o_error      => o_error);
                    io_monit.id_co_sign_cancel := l_id_co_sign;
                END IF;
            WHEN (io_monit.flg_monitorization_action = pk_monitorization.g_draft_action OR
                 io_monit.flg_monitorization_action = pk_monitorization.g_activate_draft_action)
                 AND l_flg_prof_need_cosign = pk_alert_constant.g_yes THEN
            
                IF io_monit.flg_monitorization_action = pk_monitorization.g_activate_draft_action
                THEN
                    IF NOT pk_co_sign_api.set_task_pending(i_lang            => i_lang,
                                                           i_prof            => i_prof,
                                                           i_episode         => io_monit.id_epis,
                                                           i_id_co_sign      => io_monit.id_co_sign_order,
                                                           i_dt_update       => current_timestamp,
                                                           o_id_co_sign_hist => l_id_co_sign_hist,
                                                           o_error           => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                ELSE
                
                    l_debug_msg := 'CALL PK_CO_SIGN_API.SET_DRAFT_CO_SIGN_TASK';
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                    IF NOT pk_co_sign_api.set_draft_co_sign_task(i_lang               => i_lang,
                                                                 i_prof               => i_prof,
                                                                 i_episode            => io_monit.id_epis,
                                                                 i_id_co_sign         => io_monit.id_co_sign_order,
                                                                 i_id_task_type       => pk_alert_constant.g_task_monitoring,
                                                                 i_id_task            => io_monit.id_monit,
                                                                 i_id_task_group      => io_monit.id_monit,
                                                                 i_id_order_type      => io_monit.id_order_type,
                                                                 i_id_prof_created    => io_monit.id_prof,
                                                                 i_id_prof_ordered_by => io_monit.id_prof_order,
                                                                 i_dt_created         => current_timestamp,
                                                                 i_dt_ordered_by      => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                       i_prof,
                                                                                                                       io_monit.dt_order_str,
                                                                                                                       NULL),
                                                                 o_id_co_sign         => l_id_co_sign,
                                                                 o_id_co_sign_hist    => l_id_co_sign_hist,
                                                                 o_error              => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    l_debug_msg := 'CALL TS_MONITORIZATION.UPD';
                    pk_alertlog.log_debug(text            => l_debug_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
                    l_debug_msg := 'CALL TS_MONITORIZATION.UPD';
                    ts_monitorization.upd(id_monitorization_in => io_monit.id_monit,
                                          id_co_sign_order_in  => l_id_co_sign,
                                          rows_out             => l_rowsid);
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'MONITORIZATION',
                                                  i_rowids     => l_rowsid,
                                                  o_error      => o_error);
                    io_monit.id_co_sign_order := l_id_co_sign;
                END IF;
            ELSE
                NULL;
        END CASE;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_debug_msg,
                                              c_package_owner,
                                              c_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_cosign;

    /**********************************************************************************************
    * retrieves the id visit and id episode type for a determined episode
    *
    * @param    i_lang                   preferred language id for this professional
    * @param    i_id_episode             episode id
    * @param    o_id_visit               visit id for this episode
    * @param    o_id_epis_type           episode type id concerning this episode
    * @param    o_error OUT              error message
    *
    * @return                         true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/17
    **********************************************************************************************/
    FUNCTION get_visit
    (
        i_lang         IN language.id_language%TYPE,
        i_id_episode   IN episode.id_episode%TYPE,
        o_id_visit     OUT visit.id_visit%TYPE,
        o_id_epis_type OUT epis_type.id_epis_type%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        -- GET VISIT
        SELECT id_visit, id_epis_type
          INTO o_id_visit, o_id_epis_type
          FROM episode
         WHERE id_episode = i_id_episode;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_VISIT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_visit;

    /**********************************************************************************************
    * get TIMESTAMP date
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_date                   date (VARCHAR2)
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.5
    * @since                                2009/12/09
    **********************************************************************************************/
    FUNCTION get_tstz_date
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional,
        i_date IN VARCHAR2
    ) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
    BEGIN
        RETURN pk_date_utils.get_string_tstz(i_lang, i_prof, i_date, NULL);
    END get_tstz_date;

    /**********************************************************************************************
    * create monitorization
    *
    * @param  i_lang                  preferred language id for this professional
    * @param  i_prof                  professional type
    * @param  io_monit                monitorization type
    * @param  o_error                 error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/17
    **********************************************************************************************/
    FUNCTION create_monitor
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        next_id_m    monitorization.id_monitorization%TYPE;
        l_id_patient patient.id_patient%TYPE;
        l_rowids     table_varchar;
    
    BEGIN
        -- Monitorization Request
        ts_monitorization.ins(id_monitorization_out     => next_id_m,
                              dt_monitorization_tstz_in => l_sysdate_tstz,
                              id_episode_in             => io_monit.id_epis,
                              id_professional_in        => i_prof.id,
                              dt_begin_tstz_in          => get_tstz_date(i_lang, i_prof, io_monit.dt_begin_final_str),
                              flg_time_in               => io_monit.flg_time,
                              dt_end_tstz_in            => get_tstz_date(i_lang, i_prof, io_monit.dt_end_str),
                              interval_in               => io_monit.interval_final,
                              flg_status_in             => io_monit.flg_status,
                              rows_out                  => l_rowids);
    
        io_monit.id_monit := next_id_m;
    
        BEGIN
            SELECT e.id_patient
              INTO l_id_patient
              FROM episode e
             WHERE e.id_episode = io_monit.id_epis;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END;
    
        pk_translation.insert_translation_trs(i_lang              => i_lang,
                                              i_code              => g_trs_monit_notes || next_id_m,
                                              i_desc              => io_monit.notes,
                                              i_module            => 'MONITORIZATION',
                                              i_episode           => io_monit.id_epis,
                                              i_patient           => l_id_patient,
                                              i_professional      => i_prof.id,
                                              i_dt_record         => l_sysdate_tstz,
                                              i_flg_record_format => 'F',
                                              i_task_type         => pk_alert_constant.g_task_monitoring);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    END create_monitor;

    /**********************************************************************************************
    * get the position of hour separator or 0 if does not exit
    *
    * @param           symbol                   VARCHAR2
    *
    * @return          number                   position of the character ':'
    *
    * @author                                   Filipe Machado
    * @version                                  2.5.0.7.3
    * @since                                    2009/11/17
    **********************************************************************************************/
    FUNCTION interval_has_hour_symbol(symbol VARCHAR2) RETURN NUMBER AS
    BEGIN
        RETURN instr(symbol, ':');
    END interval_has_hour_symbol;

    --

    FUNCTION create_alert_vital_sign
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_monitorization IN monitorization.id_monitorization%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message         debug_msg;
        l_alert_expire_vs VARCHAR2(10);
    
        CURSOR c_get_data IS
            SELECT t.id_episode,
                   m.id_monitorization_vs id_reg,
                   MIN(decode(t.flg_time,
                              pk_alert_constant.g_flg_time_n,
                              NULL,
                              decode(mvp.flg_status,
                                     pk_alert_constant.g_monitor_vs_fini,
                                     NULL,
                                     pk_alert_constant.g_monitor_vs_canc,
                                     NULL,
                                     
                                     mvp.dt_plan_tstz
                                     
                                     ))) dt_req_tstz
              FROM monitorization_vs m, monitorization t, monitorization_vs_plan mvp, episode e, visit v, epis_info ei
             WHERE m.flg_status IN (pk_alert_constant.g_monitor_vs_exec, pk_alert_constant.g_monitor_vs_pend)
               AND t.id_monitorization = m.id_monitorization
               AND (t.flg_time = pk_alert_constant.g_flg_time_e AND
                   (nvl((SELECT CAST(pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL),
                                                                      t.dt_begin_tstz) AS TIMESTAMP WITH LOCAL TIME ZONE)
                           FROM dual),
                         (SELECT CAST(pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL),
                                                                       t.dt_monitorization_tstz) AS TIMESTAMP WITH LOCAL TIME ZONE)
                            FROM dual)) BETWEEN
                   pk_date_utils.add_days_to_tstz(pk_date_utils.trunc_insttimezone(profissional(NULL,
                                                                                                  v.id_institution,
                                                                                                  NULL),
                                                                                     l_sysdate_tstz,
                                                                                     NULL),
                                                    -l_alert_expire_vs) AND
                   
                   (SELECT CAST(pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL),
                                                                   l_sysdate_tstz) AS TIMESTAMP WITH LOCAL TIME ZONE)
                        FROM dual))
                   
                   OR
                   (t.flg_time = pk_alert_constant.g_flg_time_b AND
                   pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL),
                                                      mvp.dt_plan_tstz,
                                                      NULL) =
                   pk_date_utils.trunc_insttimezone(profissional(NULL, v.id_institution, NULL), l_sysdate_tstz, NULL)))
                  
               AND t.flg_status IN (pk_alert_constant.g_monitor_vs_exec, pk_alert_constant.g_monitor_vs_pend)
               AND e.id_episode = t.id_episode
               AND e.flg_status IN (pk_alert_constant.g_epis_status_active, pk_alert_constant.g_epis_status_pendent)
               AND v.id_visit = e.id_visit
               AND mvp.id_monitorization_vs = m.id_monitorization_vs
               AND mvp.flg_status IN (pk_alert_constant.g_monitor_vs_exec, pk_alert_constant.g_monitor_vs_pend)
               AND ei.id_episode = e.id_episode
               AND m.id_monitorization = i_monitorization
             GROUP BY t.id_episode,
                      m.id_monitorization_vs,
                      v.id_institution,
                      pk_sysconfig.get_config('ALERT_VITAL_SIGN_TIMEOUT', v.id_institution, ei.id_software),
                      e.id_clinical_service;
    
    BEGIN
    
        l_alert_expire_vs := pk_sysconfig.get_config('ALERT_EXPIRE_VS', i_prof.institution, i_prof.software);
    
        IF pk_alerts.is_event_version(c_id_sys_alert_vital_sign)
        THEN
        
            --Insere/actualiza os alertas que ainda se verificam
            l_message := 'INSERT NEW ALERTS - VITAL_SIGN';
            FOR c IN c_get_data
            LOOP
                IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_sys_alert           => c_id_sys_alert_vital_sign,
                                                        i_id_episode          => c.id_episode,
                                                        i_id_record           => c.id_reg,
                                                        i_dt_record           => nvl(c.dt_req_tstz, l_sysdate_tstz),
                                                        i_id_professional     => i_prof.id,
                                                        i_id_room             => NULL,
                                                        i_id_clinical_service => NULL,
                                                        i_flg_type_dest       => 'C',
                                                        i_replace1            => NULL,
                                                        o_error               => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            END LOOP;
        END IF;
    
        IF pk_alerts.is_event_version(c_id_sys_alert_vs_pcontext)
        THEN
            --Insere/actualiza os alertas que ainda se verificam
            l_message := 'INSERT NEW ALERTS - VITAL_SIGN';
            FOR c IN c_get_data
            LOOP
                IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_sys_alert           => c_id_sys_alert_vs_pcontext,
                                                        i_id_episode          => c.id_episode,
                                                        i_id_record           => c.id_reg,
                                                        i_dt_record           => nvl(c.dt_req_tstz, l_sysdate_tstz),
                                                        i_id_professional     => i_prof.id,
                                                        i_id_room             => NULL,
                                                        i_id_clinical_service => NULL,
                                                        i_flg_type_dest       => 'C',
                                                        i_replace1            => NULL,
                                                        o_error               => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            END LOOP;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CREATE_ALERT_VITAL_SIGN',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END create_alert_vital_sign;

    /******************************************************************************
       OBJECTIVO:   Chama a função create_monitor_req com o valor do parâmetro commit_data a YES
       PARAMETROS:  Entrada:  I_LANG - Língua registada como preferência do profissional
                  I_EPISODE - ID do Episódio
                      I_PROF - Profissional que regista a requisição da leitura dos sinais vitais
                  I_DT_BEGIN - Data a partir da qual é pedida a leitura
                  I_INTERVAL - Intervalo de tempo entre leituras
                  I_DT_END - Data até à qual é pedida a leitura dos SV
                  I_NOTES - Notas da requisição
                  I_FLG_TIME - Realização: E - neste episódio;
                                   N - próximo episódio;
                               B - entre episódios
                  I_ID_VS - Array de IDs de sinais vitais
                  I_NOTES_DETAIL - Array de notas de detalhe de requisição de leituras
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           como é retornada em PK_LOGIN.GET_PROF_PREF
                    i_prof_order - id do profissional que pediu a requisição
                    i_dt_order_str - momento em que a ordem foi pedida
                    i_order_type - tipo de ordem (telefone, verbal, etc)
              Saida:   O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      ALTERAÇÕES: CRS 2005/07/27
                 LG 2007/07/29 Added input vars i_prof_order, i_dt_order, i_order_type
      NOTAS: Se é requisitado p/ fora do episódio, cria agendamento, para facilitar a
           pesquisa pela grelha
    *********************************************************************************/
    FUNCTION create_monitor_req
    (
        i_lang          IN language.id_language%TYPE,
        i_episode       IN monitorization.id_episode%TYPE,
        i_prof          IN profissional,
        i_dt_begin_str  IN VARCHAR2,
        i_interval      IN VARCHAR2,
        i_dt_end_str    IN VARCHAR2,
        i_notes         IN CLOB,
        i_flg_time      IN monitorization.flg_time%TYPE,
        i_id_vs         IN table_number,
        i_notes_detail  IN table_varchar,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_prof_order    IN monitorization_vs.id_prof_order%TYPE := NULL,
        i_dt_order_str  IN VARCHAR2 := NULL,
        i_order_type    IN monitorization_vs.id_order_type%TYPE := NULL,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_monitorization monitorization.id_monitorization%TYPE;
    
    BEGIN
    
        RETURN create_monitor_req(i_lang              => i_lang,
                                  i_episode           => i_episode,
                                  i_prof              => i_prof,
                                  i_dt_begin_str      => i_dt_begin_str,
                                  i_interval          => i_interval,
                                  i_dt_end_str        => i_dt_end_str,
                                  i_notes             => i_notes,
                                  i_flg_time          => i_flg_time,
                                  i_id_vs             => i_id_vs,
                                  i_notes_detail      => i_notes_detail,
                                  i_prof_cat_type     => i_prof_cat_type,
                                  i_prof_order        => i_prof_order,
                                  i_dt_order_str      => i_dt_order_str,
                                  i_order_type        => i_order_type,
                                  i_commit_data       => pk_alert_constant.g_yes,
                                  o_id_monitorization => l_id_monitorization,
                                  o_error             => o_error);
    END create_monitor_req;

    /**********************************************************************************************
    * validate the boundaries among date begin, date end and current date of the monitorization
    *
    * @param   i_lang                   preferred language id for this professional
    * @param   io_monit                 monitorization type
    * @param   signal                   signal between boundaries {
    *                                                               'lt' less than, 
    *                                                               'eq' equal,
    *                                                               'dd' day is different,
    *                                                               'gt' greater than
    *                                                             }
    * @value   signal                   {*} 'lt' less than 
    *                                   {*} 'eq' equal
    *                                   {*} 'dd' day is different
    *                                   {*} 'gt' greater than
    *                                   
    *
    * @param   o_error                  error message
    *
    * @return  boolean                  true on success, otherwise false
    *
    * @author                           Filipe Machado
    * @version                          2.5.0.7.3
    * @since                            2009/11/17
    **********************************************************************************************/
    FUNCTION validate_boundaries
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN monit,
        signal   IN VARCHAR2,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        dt_begin_tstz TIMESTAMP WITH LOCAL TIME ZONE;
        dt_end_tstz   TIMESTAMP WITH LOCAL TIME ZONE;
        l_prof        profissional;
    
    BEGIN
        dt_begin_tstz := get_tstz_date(i_lang => i_lang, i_prof => i_prof, i_date => io_monit.dt_begin_str);
        dt_end_tstz   := get_tstz_date(i_lang => i_lang, i_prof => i_prof, i_date => io_monit.dt_end_str);
    
        l_prof := profissional(io_monit.id_prof, io_monit.id_inst, io_monit.id_soft);
    
        CASE signal
            WHEN 'lt' THEN
                RETURN(pk_date_utils.trunc_insttimezone(l_prof, dt_begin_tstz, NULL) <
                       pk_date_utils.trunc_insttimezone(l_prof, l_sysdate_tstz, 'SS'));
            WHEN 'eq' THEN
                RETURN(pk_date_utils.trunc_insttimezone(l_prof, dt_begin_tstz, NULL) =
                       pk_date_utils.trunc_insttimezone(l_prof, l_sysdate_tstz, NULL));
            WHEN 'dd' THEN
                RETURN((pk_date_utils.trunc_insttimezone(i_prof, dt_begin_tstz, 'DD') !=
                       pk_date_utils.trunc_insttimezone(i_prof, l_sysdate_tstz, 'DD')) OR
                       (pk_date_utils.trunc_insttimezone(i_prof, dt_end_tstz, 'DD') !=
                       pk_date_utils.trunc_insttimezone(i_prof, l_sysdate_tstz, 'DD')));
            WHEN 'gt' THEN
                RETURN(pk_date_utils.trunc_insttimezone(l_prof, dt_begin_tstz, 'SS') >
                       pk_date_utils.trunc_insttimezone(l_prof, l_sysdate_tstz, 'SS'));
            ELSE
                RETURN FALSE;
        END CASE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'VALIDATE_BOUNDARIES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END validate_boundaries;

    /**********************************************************************************************
    * get VARCHAR2 date
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_date                   date ( TIMESTAMP   WITH LOCAL TIME ZONE)
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.5
    * @since                                2009/12/09
    **********************************************************************************************/
    FUNCTION get_str_date
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional,
        i_date IN TIMESTAMP WITH LOCAL TIME ZONE
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN pk_date_utils.get_timestamp_str(i_lang, i_prof, i_date, NULL);
    END get_str_date;

    /**********************************************************************************************
    * manage the dates parameters
    *
    * @param     i_lang                   preferred language id for this professional
    * @param     i_prof                   id for this professional
    * @param     io_monit                 monitorization type                                                       
    *
    * @return    boolean                  true on success, otherwise false
    *
    * @author                             Filipe Machado
    * @version                            2.5.1
    * @since                              16-Jul-2010
    * @reason                             ALERT-110918   
    **********************************************************************************************/

    FUNCTION manage_dates
    (
        i_lang   language.id_language%TYPE,
        i_prof   profissional,
        io_monit IN OUT NOCOPY monit
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    BEGIN
    
        io_monit.dt_begin_final_str := nvl(io_monit.dt_begin_str,
                                           get_str_date(i_lang => i_lang, i_prof => i_prof, i_date => l_sysdate_tstz));
    
        IF io_monit.dt_end_str IS NOT NULL
           AND
          
           (pk_date_utils.trunc_insttimezone(i_prof,
                                             get_tstz_date(i_lang => i_lang,
                                                           i_prof => i_prof,
                                                           i_date => io_monit.dt_end_str),
                                             'SS') < pk_date_utils.trunc_insttimezone(i_prof, l_sysdate_tstz, 'SS'))
        THEN
            io_monit.dt_end_str := get_str_date(i_lang => i_lang, i_prof => i_prof, i_date => l_sysdate_tstz);
        END IF;
    
        RETURN TRUE;
    
    END manage_dates;

    /**********************************************************************************************
    * Initialize the flags of the monitorization
    *
    * @param     i_lang                   preferred language id for this professional
    * @param     io_monit                 monitorization type                                                       
    * @param     o_error                  error message
    *
    * @return    boolean                  true on success, otherwise false
    *
    * @author                             Filipe Machado
    * @version                            2.5.0.7.3
    * @since                              2009/11/17
    **********************************************************************************************/
    FUNCTION set_init
    (
        i_lang   language.id_language%TYPE,
        i_prof   profissional,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        CASE io_monit.flg_time
            WHEN pk_alert_constant.g_flg_time_n THEN
                io_monit.flg_status         := pk_alert_constant.g_monitor_vs_pend;
                io_monit.flg_status_det     := io_monit.flg_status;
                io_monit.dt_begin_final_str := NULL;
            
            WHEN pk_alert_constant.g_flg_time_b THEN
            
                IF validate_boundaries(i_lang, i_prof, io_monit, 'gt', o_error)
                THEN
                    io_monit.flg_status         := pk_alert_constant.g_monitor_vs_pend;
                    io_monit.flg_status_det     := io_monit.flg_status;
                    io_monit.dt_begin_final_str := io_monit.dt_begin_str;
                ELSE
                    io_monit.flg_status     := pk_alert_constant.g_monitor_vs_exec;
                    io_monit.flg_status_det := io_monit.flg_status;
                
                    IF NOT manage_dates(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                END IF;
            
            WHEN pk_alert_constant.g_flg_time_e THEN
            
                IF validate_boundaries(i_lang, i_prof, io_monit, 'gt', o_error)
                THEN
                    io_monit.flg_status         := pk_alert_constant.g_monitor_vs_pend;
                    io_monit.flg_status_det     := io_monit.flg_status;
                    io_monit.dt_begin_final_str := io_monit.dt_begin_str;
                ELSE
                    io_monit.flg_status     := pk_alert_constant.g_monitor_vs_exec;
                    io_monit.flg_status_det := io_monit.flg_status;
                
                    IF NOT manage_dates(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit)
                    THEN
                        RETURN FALSE;
                    END IF;
                
                END IF;
        END CASE;
    
        --io_monit.id_prof_order := nvl(io_monit.id_prof_order, i_prof.id);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'set_init',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END set_init;
    /**********************************************************************************************
    * validate interval
    *
    * @param i_lang                   preferred language id for this professional
    * @param io_monit                 monitorization type
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/17
    **********************************************************************************************/
    FUNCTION validate_interval
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        l_excep_interval      EXCEPTION;
        l_excep_interval_hour EXCEPTION;
        l_error_in           t_error_in := t_error_in();
        l_ret                BOOLEAN;
        l_monit_interval_max sys_config.value%TYPE;
    
    BEGIN
    
        IF io_monit.interval_final IS NOT NULL
        THEN
            RETURN TRUE;
        END IF;
    
        l_message := 'VALIDATE_INTERVAL - BETWEEN EPISODE OR CURRENT EPISODE AND INTERVAL NOT DEFINED';
        pk_alertlog.log_debug(l_message);
        IF io_monit.flg_time IN (pk_alert_constant.g_flg_time_b, pk_alert_constant.g_flg_time_e)
           AND io_monit.interval IS NULL
        THEN
            RAISE l_excep_interval;
        END IF;
    
        -- Is it being also done this validation on the flash side (multichoice), isn't?
        l_message := 'GET INTERVAL MAX OF MONITORIZATIONS';
        pk_alertlog.log_debug(l_message);
        l_monit_interval_max := pk_sysconfig.get_config(i_code_cf => 'MONITORIZATION_INTERVAL_MAX', i_prof => i_prof);
        --put the value in seconds  (the sysconfig is defined in hours)
        l_monit_interval_max := nvl(to_number(l_monit_interval_max), 0) * 60;
    
        --check if the interval is biggest to the interval defined in sysconfig
        --this is also validated by flash (keypad)    
        IF io_monit.flg_time = pk_alert_constant.g_flg_time_e
           AND to_number(io_monit.interval) > l_monit_interval_max
        THEN
            RAISE l_excep_interval_hour;
        END IF;
    
        io_monit.interval_final := NULL;
        IF io_monit.interval IS NOT NULL
        THEN
            io_monit.interval_final := to_number(nvl(io_monit.interval, 0));
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_excep_interval THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M010',
                               pk_message.get_message(i_lang, 'MONITOR_M006'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'VALIDATE_INTERVAL',
                               pk_message.get_message(i_lang, 'MONITOR_M006'),
                               'U');
            l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
            RETURN l_ret;
        
        WHEN l_excep_interval_hour THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M010',
                               pk_message.get_message(i_lang, 'MONITOR_M008'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'VALIDATE_INTERVAL',
                               pk_message.get_message(i_lang, 'MONITOR_M008'),
                               'U');
            l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
            RETURN l_ret;
    END validate_interval;

    /**********************************************************************************************
    * validate the request of the monitorization
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       io_monit                 monitorization type
    * @param       o_error                  error message
    *
    * @return      boolean                  true = no conflicts, false = has conflits
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/17
    **********************************************************************************************/
    FUNCTION validate_monitor_req
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message      debug_msg;
        l_req_next_day BOOLEAN;
        l_excep_ddb_dif_dda EXCEPTION;
        l_excep_interval    EXCEPTION;
        l_error_in      t_error_in := t_error_in();
        l_ret           BOOLEAN := FALSE;
        l_dt_begin_tstz TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
    
        io_monit.id_prof := nvl(io_monit.id_prof, i_prof.id);
        io_monit.id_inst := nvl(io_monit.id_inst, i_prof.institution);
        io_monit.id_soft := nvl(io_monit.id_soft, i_prof.software);
    
        -- if date order is not defined yet
        IF (io_monit.dt_order_str IS NULL)
        THEN
            -- the sysdate is assigned
            io_monit.dt_order_str := pk_date_utils.get_timestamp_str(i_lang      => i_lang,
                                                                     i_prof      => i_prof,
                                                                     i_timestamp => l_sysdate_tstz,
                                                                     i_timezone  => NULL);
        END IF;
    
        CASE io_monit.flg_time
        
            WHEN pk_alert_constant.g_flg_time_n THEN
                -- next episode
                l_ret := set_init(i_lang, i_prof, io_monit, o_error);
            
            WHEN pk_alert_constant.g_flg_time_b THEN
                -- between episodes
                l_ret := set_init(i_lang, i_prof, io_monit, o_error);
            
            WHEN pk_alert_constant.g_flg_time_e THEN
                -- current episode
                l_req_next_day  := (pk_sysconfig.get_config('REQ_NEXT_DAY', i_prof) = pk_alert_constant.g_no);
                l_dt_begin_tstz := pk_date_utils.get_string_tstz(i_lang, i_prof, io_monit.dt_begin_str, NULL);
            
                IF l_req_next_day
                   AND (l_dt_begin_tstz > current_timestamp)
                THEN
                    -- Isn't this validated from flash side?
                    IF validate_boundaries(i_lang, i_prof, io_monit, 'dd', o_error)
                    THEN
                        RAISE l_excep_ddb_dif_dda;
                    END IF;
                END IF;
            
                l_ret := set_init(i_lang, i_prof, io_monit, o_error);
            
            ELSE
                RETURN TRUE;
            
        END CASE;
    
        IF io_monit.interval_final IS NULL
        THEN
            l_message := 'validate_monitor_req - between episode or current episode and interval not defined';
            IF (io_monit.flg_time IN (pk_alert_constant.g_flg_time_b, pk_alert_constant.g_flg_time_e) AND
               io_monit.interval IS NULL)
               OR (NOT validate_interval(i_lang, i_prof, io_monit, o_error))
            THEN
                RAISE l_excep_interval;
            END IF;
        END IF;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN l_excep_ddb_dif_dda THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M009',
                               pk_message.get_message(i_lang, 'MONITOR_M009'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'VALIDATE_MONITOR_REQ',
                               pk_message.get_message(i_lang, 'MONITOR_M009'),
                               'U');
        
            l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
        
            RETURN l_ret;
        
        WHEN OTHERS THEN
            RETURN FALSE;
        
    END validate_monitor_req;

    /******************************************************************************
       OBJECTIVO: Obter a info a mostrar no ecrã intermédio de registo de nova
              req. de monitorização
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                             I_ID_MONITOR_VS - ID de monitorização
                             I_ID_VS - Array de IDs de sinais vitais
                    Saida:   O_MONITOR -  lista de requisições
                 O_ERROR - erro
    
      CRIAÇÃO: CRS 2005/07/28
      NOTAS:
    *********************************************************************************/
    FUNCTION get_aux_monitor
    (
        i_lang          IN language.id_language%TYPE,
        i_id_monitor_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_prof          IN profissional,
        i_dt_first_read IN VARCHAR2,
        o_monitor       OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        c_function_name CONSTANT obj_name := 'GET_AUX_MONITOR';
        l_dbg_msg debug_msg;
    
        l_monitor_start_date_type sys_config.value%TYPE;
        l_msg_na                  sys_message.desc_message%TYPE;
        l_msg_title_sv            sys_message.desc_message%TYPE;
    
        l_dt_first_read TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
        l_dbg_msg := 'get sys config';
        pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => c_function_name);
        l_monitor_start_date_type := nvl(s1 => pk_sysconfig.get_config(i_code_cf   => 'MONITOR_START_DATE',
                                                                       i_prof_inst => i_prof.institution,
                                                                       i_prof_soft => i_prof.software),
                                         s2 => 'PLANNED_DATE');
    
        l_dbg_msg := 'get sys messages';
        pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => c_function_name);
        l_msg_na       := pk_message.get_message(i_lang => i_lang, i_code_mess => 'COMMON_M018');
        l_msg_title_sv := pk_message.get_message(i_lang => i_lang, i_code_mess => 'MONITOR_M005');
    
        l_dbg_msg := 'get sys messages';
        pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => c_function_name);
        l_dt_first_read := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                         i_prof      => i_prof,
                                                         i_timestamp => i_dt_first_read,
                                                         i_timezone  => NULL);
    
        l_dbg_msg := 'get cursor';
        pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => c_function_name);
        OPEN o_monitor FOR
            SELECT DISTINCT decode(sign(extract(DAY FROM(decode(l_monitor_start_date_type,
                                                            c_planned_date,
                                                            mea.dt_plan,
                                                            l_dt_first_read) +
                                                     numtodsinterval(nvl(mea.interval, 0), 'SECOND') -
                                                     nvl(mea.dt_end,
                                                         decode(l_monitor_start_date_type,
                                                                c_planned_date,
                                                                mea.dt_plan,
                                                                l_dt_first_read) + numtodsinterval(1, 'DAY') +
                                                         numtodsinterval(nvl(mea.interval, 0), 'SECOND'))))),
                                   1,
                                   l_msg_na,
                                   pk_date_utils.date_char_tsz(i_lang,
                                                               decode(l_monitor_start_date_type,
                                                                      c_planned_date,
                                                                      mea.dt_plan,
                                                                      l_dt_first_read) +
                                                               numtodsinterval(nvl(mea.interval, 0), 'SECOND'),
                                                               i_prof.institution,
                                                               i_prof.software)) AS dt_plan,
                            decode(sign(extract(DAY FROM(decode(l_monitor_start_date_type,
                                                            c_planned_date,
                                                            mea.dt_plan,
                                                            l_dt_first_read) +
                                                     numtodsinterval(nvl(mea.interval, 0), 'SECOND') -
                                                     nvl(mea.dt_end,
                                                         decode(l_monitor_start_date_type,
                                                                c_planned_date,
                                                                mea.dt_plan,
                                                                l_dt_first_read) + numtodsinterval(1, 'DAY') +
                                                         numtodsinterval(nvl(mea.interval, 0), 'SECOND'))))),
                                   1,
                                   l_msg_na,
                                   pk_date_utils.date_send_tsz(i_lang,
                                                               decode(l_monitor_start_date_type,
                                                                      c_planned_date,
                                                                      mea.dt_plan,
                                                                      l_dt_first_read) +
                                                               numtodsinterval(nvl(mea.interval, 0), 'SECOND'),
                                                               i_prof)) AS date_plan,
                            pk_vital_sign.get_vs_desc(i_lang, mea.id_vital_sign) AS desc_vital_sign,
                            l_msg_title_sv AS title_sv,
                            decode(sign(extract(DAY
                                                FROM(l_dt_first_read + numtodsinterval(nvl(mea.interval, 0), 'SECOND') -
                                                     nvl(mea.dt_end,
                                                         l_dt_first_read + numtodsinterval(1, 'DAY') +
                                                         numtodsinterval(nvl(mea.interval, 0), 'SECOND'))))),
                                   1,
                                   pk_alert_constant.g_no,
                                   pk_alert_constant.g_yes) AS flg_edit,
                            pk_date_utils.date_send_tsz(i_lang, nvl(mvsp.start_time, mea.dt_monitorization), i_prof) AS dt_val,
                            pk_date_utils.date_send_tsz(i_lang, mea.dt_begin, i_prof) AS dt_start_req,
                            pk_date_utils.date_send_tsz(i_lang, mea.dt_end, i_prof) AS dt_end_req
              FROM monitorizations_ea mea
             INNER JOIN monitorization_vs_plan mvsp
                ON mea.id_monitorization_vs_plan = mvsp.id_monitorization_vs_plan
             WHERE mea.id_monitorization_vs = i_id_monitor_vs
               AND mea.flg_status_plan NOT IN
                   (pk_alert_constant.g_monitor_vs_fini, pk_alert_constant.g_monitor_vs_canc);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => l_dbg_msg,
                                              i_owner    => c_package_owner,
                                              i_package  => c_package_name,
                                              i_function => c_function_name,
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(i_cursor => o_monitor);
            RETURN FALSE;
        
    END get_aux_monitor;

    /******************************************************************************
       OBJECTIVO:   Obtém todos os parâmetros que devolvem o estado de uma requisição de uma monitorização.  
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                             I_PROF - ID do profissional
                             I_ID_MONITORIZATION - ID da monitorização
                    Saida:   O_FLG_STATUS - Estado da requisição
                             O_DESC_STAT - Formato de apresentação do estado
                             O_FLG_TEXT - Texto a apresentar no estado
                             O_COLOR_STATUS - Cor do estado
                             O_FLG_FINISHED - Indica se a requisição da monitorização já está num estado final
                             O_FLG_CANCELED - Indica se a requisição da monitorização foi cancelada
                             O_ERROR - Mensagem erro
    
      CRIAÇÃO: Tiago Silva 2008/05/28
      NOTAS:
    *********************************************************************************/
    FUNCTION get_monitor_req_status
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        o_flg_status        OUT monitorization.flg_status%TYPE,
        o_status_string     OUT VARCHAR2,
        o_flg_finished      OUT VARCHAR2,
        o_flg_canceled      OUT VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
    BEGIN
        l_message := 'GET REQUEST STATUS';
        SELECT flg_status, status_string, flg_finished, flg_canceled
          INTO o_flg_status, o_status_string, o_flg_finished, o_flg_canceled
          FROM (SELECT mea.flg_status,
                       pk_utils.get_status_string(i_lang,
                                                  i_prof,
                                                  mea.status_str,
                                                  mea.status_msg,
                                                  mea.status_icon,
                                                  mea.status_flg) status_string,
                       decode(mea.flg_status,
                              pk_alert_constant.g_monitor_vs_fini,
                              pk_alert_constant.g_yes,
                              pk_alert_constant.g_no) AS flg_finished,
                       decode(mea.flg_status,
                              pk_alert_constant.g_monitor_vs_canc,
                              pk_alert_constant.g_yes,
                              pk_alert_constant.g_no) AS flg_canceled
                  FROM monitorizations_ea mea
                 WHERE mea.id_monitorization = i_id_monitorization
                 ORDER BY decode(mea.flg_status_det, pk_alert_constant.g_monitor_vs_canc, 2, 1))
         WHERE rownum = 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_REQ_STATUS',
                                              o_error);
            RETURN FALSE;
    END get_monitor_req_status;

    /**********************************************************************************************
    * It indicates whether a vital_sign has measurements or not
    *
    * @param i_lang                  Language ID
    * @param i_prof                  Professional
    * @param i_monitoring_vs         Monitorization vital sign ID
    *                        
    * @author                        Filipe Machado
    * @version                       v2.6.1.1
    * @since                         28-Jun-2011
    **********************************************************************************************/

    FUNCTION vs_has_measurements
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_monitoring_vs IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret VARCHAR2(1 CHAR);
    BEGIN
    
        SELECT CASE COUNT(1)
                   WHEN 0 THEN
                    pk_alert_constant.get_no()
                   ELSE
                    pk_alert_constant.get_yes()
               END CASE
          INTO l_ret
          FROM monitorizations_ea mea
         INNER JOIN episode e
            ON mea.id_episode = e.id_episode
         INNER JOIN monitorization_vs_plan mvsp
            ON mvsp.id_monitorization_vs = mea.id_monitorization_vs
         WHERE mea.id_monitorization_vs = i_monitoring_vs
           AND mea.flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_draft)
           AND e.flg_status != pk_alert_constant.g_epis_status_cancel
           AND mvsp.flg_status = pk_alert_constant.g_monitor_vs_fini;
    
        RETURN l_ret;
    
    END vs_has_measurements;

    /******************************************************************************
       OBJECTIVO:   Obter requisições de monitorização de sinais vitais num episódio
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                             I_EPISODE - ID do episódio
                    Saida:   O_MONITOR -  lista de requisições
                             O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      ALTERAÇÕES: CRS 2005/06/06
              CRS 2005/07/27
              CMF 27-05-2008 ORIENTAR CONSULTA PARA A VISITA
      NOTAS:
    *********************************************************************************/
    FUNCTION get_monitor_req
    (
        i_lang    IN language.id_language%TYPE,
        i_episode IN episode.id_episode%TYPE,
        i_prof    IN profissional,
        o_monitor OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
        l_id_epis_type episode.id_epis_type%TYPE;
        l_id_visit     visit.id_visit%TYPE;
    
        err_get_monitor_req EXCEPTION;
    BEGIN
        l_message := 'GET VISIT';
        SELECT id_visit, id_epis_type
          INTO l_id_visit, l_id_epis_type
          FROM episode
         WHERE id_episode = i_episode;
    
        l_message := 'CALL GET_MONITOR_REQ';
        IF NOT get_monitor_req(i_lang         => i_lang,
                               i_prof         => i_prof,
                               i_scope        => l_id_visit,
                               i_flg_scope    => pk_alert_constant.g_scope_type_visit,
                               i_start_date   => NULL,
                               i_end_date     => NULL,
                               i_cancelled    => pk_alert_constant.g_yes,
                               i_crit_type    => g_monit_crit_type_all_a,
                               i_flg_report   => pk_alert_constant.g_no,
                               i_id_epis_type => l_id_epis_type,
                               o_monitor      => o_monitor,
                               o_error        => o_error)
        THEN
            RAISE err_get_monitor_req;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_REQ',
                                              o_error);
            RETURN FALSE;
    END get_monitor_req;

    /*******************************************************************************************************************************************
    * Get requests monitoring of vital signs in an episode (Guided for consultation visit)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_SCOPE                  Scope ID (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_FLG_SCOPE              Flag Scope (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled ('Y' - Yes, 'N' - No)
    * @param I_CRIT_TYPE              Flag that indicates if the filter time to consider all records or only during the executions ('A' - All, 'E' - Executions, ...)
    * @param I_FLG_REPORT             Flag used to remove formatting ('Y' - Yes, 'N' - No)
    * @param I_ID_EPIS_TYPE           Type of episode
    * @param O_MONITOR                Cursor that returns monitorizations
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_FLG_SCOPE              {*} 'E' Episode {*} 'V' Visit {*} 'P' Patient'
    * @value I_CANCELLED              {*} 'Y' YES {*} 'N' NO
    * @value I_CRIT_TYPE              {*} 'A' All {*} 'R' Requisitions {*} 'E' Executions
    * @value I_FLG_REPORT             {*} 'Y' YES {*} 'N' NO
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    *
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          07-Nov-2011
    *******************************************************************************************************************************************/
    FUNCTION get_monitor_req
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_scope        IN NUMBER,
        i_flg_scope    IN VARCHAR2,
        i_start_date   IN VARCHAR2,
        i_end_date     IN VARCHAR2,
        i_cancelled    IN VARCHAR2,
        i_crit_type    IN VARCHAR2,
        i_flg_report   IN VARCHAR2,
        i_id_epis_type IN episode.id_epis_type%TYPE,
        i_flg_status   IN table_varchar DEFAULT NULL,
        o_monitor      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message  debug_msg;
        l_timezone timezone_region.timezone_region%TYPE;
    
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient patient.id_patient%TYPE;
    
        e_invalid_argument EXCEPTION;
    
        l_start_date TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_end_date   TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
    
        l_flg_status_count NUMBER;
        l_tbl_status       table_varchar;
    
    BEGIN
    
        IF i_flg_status IS NOT NULL
        THEN
            IF i_flg_status.count = 0
            THEN
                l_flg_status_count := 0;
                l_tbl_status       := table_varchar();
            ELSE
                l_tbl_status := i_flg_status;
            END IF;
        ELSE
            l_flg_status_count := 0;
            l_tbl_status       := table_varchar();
        END IF;
    
        l_message := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE e_invalid_argument;
        END IF;
    
        --convert string to date format
        IF i_start_date IS NOT NULL
        THEN
            l_start_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_date, NULL);
        END IF;
        IF i_end_date IS NOT NULL
        THEN
            l_end_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_date, NULL);
        END IF;
    
        IF NOT pk_date_utils.get_timezone(i_lang     => i_lang,
                                          i_prof     => i_prof,
                                          i_timezone => NULL,
                                          o_timezone => l_timezone,
                                          o_error    => o_error)
        THEN
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        END IF;
    
        l_message := 'GET CURSOR';
        OPEN o_monitor FOR
            SELECT t.*,
                   pk_utils.get_status_string(i_lang, i_prof, t.status_str, t.status_msg, t.status_icon, t.status_flg) status_string
              FROM (SELECT DISTINCT mea.id_vital_sign,
                                    mea.id_monitorization,
                                    mea.num_monit,
                                    mea.id_monitorization_vs,
                                    mea.flg_status_det,
                                    mea.flg_status,
                                    mea.flg_time,
                                    pk_vital_sign.get_vs_desc(i_lang, mea.id_vital_sign) ||
                                    decode(nvl(i_id_epis_type, epi.id_epis_type),
                                           nvl(t_ti_log.get_epis_type(i_lang,
                                                                      i_prof,
                                                                      epi.id_epis_type,
                                                                      mea.flg_status,
                                                                      mea.id_monitorization,
                                                                      pk_alert_constant.g_ti_type_mn),
                                               epi.id_epis_type),
                                           '',
                                           ' - (' || pk_message.get_message(i_lang,
                                                                            profissional(i_prof.id,
                                                                                         i_prof.institution,
                                                                                         t_ti_log.get_epis_type_soft(i_lang,
                                                                                                                     i_prof,
                                                                                                                     epi.id_epis_type,
                                                                                                                     mea.flg_status,
                                                                                                                     mea.id_monitorization,
                                                                                                                     pk_alert_constant.g_ti_type_mn)),
                                                                            'IMAGE_T009') || ')') desc_vital_sign,
                                    decode(mea.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           decode(mea.flg_status_plan,
                                                  pk_alert_constant.g_monitor_vs_fini,
                                                  NULL,
                                                  pk_alert_constant.g_monitor_vs_canc,
                                                  NULL,
                                                  pk_date_utils.dt_chr_tsz(i_lang,
                                                                           mea.dt_plan,
                                                                           i_prof.institution,
                                                                           i_prof.software))) date_target,
                                    decode(mea.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           pk_message.get_message(i_lang, 'COMMON_M018'),
                                           decode(mea.flg_status_plan,
                                                  pk_alert_constant.g_monitor_vs_fini,
                                                  pk_message.get_message(i_lang, 'COMMON_M018'),
                                                  pk_alert_constant.g_monitor_vs_canc,
                                                  pk_message.get_message(i_lang, 'COMMON_M018'),
                                                  pk_date_utils.date_char_hour_tsz(i_lang,
                                                                                   mea.dt_plan,
                                                                                   i_prof.institution,
                                                                                   i_prof.software))) hour_target,
                                    get_interval_desc(i_lang, i_prof, mea.id_monitorization) desc_interval,
                                    decode(mea.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           mea.flg_status_det,
                                           decode(mea.flg_status_det,
                                                  pk_alert_constant.g_monitor_vs_canc,
                                                  mea.flg_status_det,
                                                  pk_alert_constant.g_monitor_vs_expire,
                                                  mea.flg_status_det,
                                                  pk_alert_constant.g_monitor_vs_fini,
                                                  mea.flg_status_det,
                                                  decode(least(mea.dt_plan, l_sysdate_tstz),
                                                         mea.dt_plan,
                                                         pk_alert_constant.g_monitor_vs_exec,
                                                         mea.flg_status_det))) visual_status,
                                    pk_sysdomain.get_domain('MONITORIZATION.FLG_TIME', mea.flg_time, i_lang) desc_time,
                                    decode(nvl(mea.flg_notes, pk_alert_constant.g_no),
                                           pk_alert_constant.g_no,
                                           '',
                                           pk_alert_constant.g_yes,
                                           pk_message.get_message(i_lang, 'COMMON_M008')) title_notes,
                                    decode(mea.flg_status_det,
                                           pk_alert_constant.g_monitor_vs_canc,
                                           pk_alert_constant.g_yes,
                                           pk_alert_constant.g_monitor_vs_inte,
                                           pk_alert_constant.g_yes,
                                           pk_alert_constant.g_no) flg_cancel,
                                    pk_date_utils.to_char_insttimezone(i_prof, mea.dt_plan, 'YYYYMMDDHH24MISS') dt_ord1,
                                    CASE
                                         WHEN mea.flg_status_det IN
                                              (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_inte) THEN
                                          NULL
                                         ELSE
                                          vs_has_measurements(i_lang, i_prof, mea.id_monitorization_vs)
                                     END AS has_measurements,
                                    check_exec_monit(i_lang,
                                                     i_prof,
                                                     m.id_episode,
                                                     m.id_monitorization,
                                                     m.flg_time,
                                                     m.flg_status,
                                                     m.dt_begin_tstz,
                                                     pk_alert_constant.g_yes) flg_ok_button,
                                    check_cancel_monit(i_lang, i_prof, m.flg_time, m.flg_status, pk_alert_constant.g_yes) flg_cancel_button,
                                    check_detail_monit(m.flg_status) flg_detail_button,
                                    mea.status_str,
                                    mea.status_msg,
                                    mea.status_icon,
                                    mea.status_flg,
                                    nvl(m.id_co_sign_cancel, m.id_co_sign_order) id_co_sign
                      FROM monitorizations_ea mea
                     INNER JOIN episode epi
                        ON mea.id_episode = epi.id_episode
                     INNER JOIN monitorization m
                        ON mea.id_monitorization = m.id_monitorization
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                       AND mvs.id_vital_sign = mea.id_vital_sign
                     INNER JOIN monitorization_vs_plan mvsp
                        ON mvs.id_monitorization_vs = mvsp.id_monitorization_vs
                     WHERE epi.id_episode = nvl(l_id_episode, epi.id_episode)
                       AND epi.id_visit = nvl(l_id_visit, epi.id_visit)
                       AND (l_flg_status_count = 0 OR
                           mea.flg_status IN (SELECT t1.column_value
                                                 FROM TABLE(l_tbl_status) t1))
                       AND epi.id_patient = nvl(l_id_patient, epi.id_patient)
                       AND m.flg_status <> pk_alert_constant.g_monitor_vs_draft
                       AND (
                           --not report gets all
                            i_flg_report = pk_alert_constant.g_no OR
                           --
                            (
                            --if report
                             i_flg_report = pk_alert_constant.g_yes
                            --
                             AND
                            --
                             (
                             --shows canceled monitorizations or not whether flag i_cancelled
                              (i_cancelled = pk_alert_constant.g_no AND m.flg_status <> pk_alert_constant.g_monitor_vs_canc) OR
                              i_cancelled = pk_alert_constant.g_yes
                             --
                             )
                            --
                             AND
                            --
                             (
                             --shows monitorizations or not whether flag i_crit_type and the dates (i_start_date and i_end_date)
                             --Shows all the monitorizations where the req and exec was performed in the period
                              (i_crit_type = g_monit_crit_type_all_a AND
                              (m.dt_begin_tstz BETWEEN nvl(l_start_date, m.dt_begin_tstz) AND
                              nvl(l_end_date, m.dt_begin_tstz) OR
                              (mvsp.start_time BETWEEN nvl(l_start_date, mvsp.start_time) AND
                              nvl(l_end_date, mvsp.start_time) AND
                              mvsp.end_time BETWEEN nvl(l_start_date, mvsp.end_time) AND nvl(l_end_date, mvsp.end_time))))
                             --
                              OR
                             --Shows the monitorizations that where req in the period
                              (i_crit_type = g_monit_crit_type_req_r AND
                              m.dt_begin_tstz BETWEEN nvl(l_start_date, m.dt_begin_tstz) AND
                              nvl(l_end_date, m.dt_begin_tstz))
                             --
                              OR
                             --Shows the monitorizations that where exec in the period
                              (i_crit_type = g_monit_crit_type_exec_e AND
                              mvsp.start_time BETWEEN nvl(l_start_date, mvsp.start_time) AND
                              nvl(l_end_date, mvsp.start_time) AND mvsp.end_time BETWEEN nvl(l_start_date, mvsp.end_time) AND
                              nvl(l_end_date, mvsp.end_time))
                             --
                             )
                            --
                            )
                           --
                           )) t
             ORDER BY pk_sysdomain.get_rank(i_lang, 'MONITORIZATION_VS.FLG_STATUS', visual_status),
                      date_target,
                      hour_target;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_REQ',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_monitor);
            RETURN FALSE;
    END get_monitor_req;

    /******************************************************************************
       OBJECTIVO:   Obter detalhe de uma monitorização
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITOR_VS - ID da requisição.
              Saida:   O_MONITOR -  detalhe de requisião
                 O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      NOTAS:  LG 2007/08/29 Devolver informação relacionada com quem pediu o procedimento (!= de quem registou)
    
    *********************************************************************************/
    FUNCTION get_monitor_vs_req
    (
        i_lang          IN language.id_language%TYPE,
        i_id_monitor_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_prof          IN profissional,
        o_monitor       OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
        l_id_episode episode.id_episode%TYPE;
    
        err_get_monitor_vs_req EXCEPTION;
    
    BEGIN
    
        l_message := 'GET EPISODE';
        SELECT DISTINCT m.id_episode
          INTO l_id_episode
          FROM monitorization_vs mvs
         INNER JOIN monitorization m
            ON mvs.id_monitorization = m.id_monitorization
         WHERE mvs.id_monitorization_vs = i_id_monitor_vs;
    
        l_message := 'CALL GET_MONITOR_VS_REQ';
        IF NOT get_monitor_vs_req(i_lang          => i_lang,
                                  i_prof          => i_prof,
                                  i_id_monitor_vs => i_id_monitor_vs,
                                  i_scope         => l_id_episode,
                                  i_flg_scope     => pk_alert_constant.g_scope_type_episode,
                                  i_start_date    => NULL,
                                  i_end_date      => NULL,
                                  i_cancelled     => pk_alert_constant.g_yes,
                                  i_crit_type     => g_monit_crit_type_all_a,
                                  i_flg_report    => pk_alert_constant.g_no,
                                  o_monitor       => o_monitor,
                                  o_error         => o_error)
        THEN
            RAISE err_get_monitor_vs_req;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_VS_REQ',
                                              o_error);
            RETURN FALSE;
    END get_monitor_vs_req;

    /*******************************************************************************************************************************************
    * Get details of a monitoring (Return information related to who requested the procedure - != Who registered)
    * 
    * @param I_LANG                   Language ID for translations
    * @param I_PROF                   Professional vector of information (professional ID, institution ID, software ID)
    * @param I_ID_MONITOR_VS          ID Vital Sign Monitor request
    * @param I_SCOPE                  Scope ID (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_FLG_SCOPE              Flag Scope (E-Episode ID, V-Visit ID, P-Patient ID)
    * @param I_START_DATE             Start date for temporal filtering
    * @param I_END_DATE               End date for temporal filtering
    * @param I_CANCELLED              Indicates whether the records should be returned canceled ('Y' - Yes, 'N' - No)
    * @param I_CRIT_TYPE              Flag that indicates if the filter time to consider all records or only during the executions ('A' - All, 'E' - Executions, ...)
    * @param I_FLG_REPORT             Flag used to remove formatting ('Y' - Yes, 'N' - No)
    * @param O_MONITOR                Cursor that returns request detail
    * @param O_ERROR                  If an error accurs, this parameter will have information about the error
    * 
    * @value I_FLG_SCOPE              {*} 'E' Episode {*} 'V' Visit {*} 'P' Patient'
    * @value I_CANCELLED              {*} 'Y' YES {*} 'N' NO
    * @value I_CRIT_TYPE              {*} 'A' All {*} 'R' Requisitions {*} 'E' Executions
    * @value I_FLG_REPORT             {*} 'Y' YES {*} 'N' NO
    * 
    * @return                         Returns TRUE if success, otherwise returns FALSE
    *
    * @author                         António Neto
    * @version                        2.6.1.5
    * @since                          07-Nov-2011
    *******************************************************************************************************************************************/
    FUNCTION get_monitor_vs_req
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_monitor_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_scope         IN NUMBER,
        i_flg_scope     IN VARCHAR2,
        i_start_date    IN VARCHAR2,
        i_end_date      IN VARCHAR2,
        i_cancelled     IN VARCHAR2,
        i_crit_type     IN VARCHAR2,
        i_flg_report    IN VARCHAR2,
        o_monitor       OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_patient patient.id_patient%TYPE;
    
        e_invalid_argument EXCEPTION;
    
        l_start_date    TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_end_date      TIMESTAMP(6) WITH LOCAL TIME ZONE := NULL;
        l_sign_off_t034 sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'SIGN_OFF_T034');
    
        l_sm_cancel_notes        sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M017');
        l_sm_order               sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M024');
        l_sm_execution           sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M016');
        l_sm_pending             sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M017');
        l_sm_draft               sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M018');
        l_sm_cancelled           sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M019');
        l_sm_discontinued        sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M020');
        l_sm_order_cosign        sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M021');
        l_sm_discontinued_cosign sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M022');
        l_sm_cancelled_cosign    sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'MONITOR_M023');
    
    BEGIN
        l_message := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_flg_scope,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE e_invalid_argument;
        END IF;
    
        --convert string to date format
        IF i_start_date IS NOT NULL
        THEN
            l_start_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_date, NULL);
        END IF;
        IF i_end_date IS NOT NULL
        THEN
            l_end_date := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_date, NULL);
        END IF;
    
        l_message := 'OPEN o_monitor';
        OPEN o_monitor FOR
            SELECT *
              FROM (
                    --discontinuation co-sign
                    SELECT rownum rn,
                            epi.id_episode,
                            epi.id_visit,
                            epi.id_patient,
                            NULL flg_status,
                            NULL dt_begin_tstz,
                            NULL start_time,
                            NULL end_time,
                            c.dt_co_signed dt_monitorization,
                            4 ordering,
                            NULL notes,
                            pk_alert_constant.g_monitor_vs_exec flg_status_det,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, c.id_prof_co_signed) nick_name,
                            c.desc_status desc_status,
                            NULL flg_time,
                            NULL desc_time,
                            c.dt_co_signed dt_ordering,
                            pk_date_utils.dt_chr_tsz(i_lang, c.dt_co_signed, i_prof) date_req,
                            pk_date_utils.date_char_hour_tsz(i_lang, c.dt_co_signed, i_prof.institution, i_prof.software) hour_req,
                            NULL date_begin,
                            NULL hour_begin,
                            NULL date_end,
                            NULL hour_end,
                            NULL desc_interval,
                            NULL dt_cancel,
                            NULL title_cancel,
                            NULL prof_cancel,
                            NULL notes_cancel,
                            NULL desc_speciality,
                            NULL desc_speciality_cancel,
                            NULL date_next,
                            NULL hour_next,
                            NULL desc_vs,
                            NULL prof_order,
                            NULL order_type_desc,
                            NULL dt_order,
                            NULL name_performed,
                            NULL prof_order_spec,
                            decode(m.flg_status,
                                   pk_alert_constant.g_monitor_vs_inte,
                                   l_sm_discontinued_cosign,
                                   l_sm_cancelled_cosign) label_order,
                            NULL dt_begin_rep,
                            NULL dt_end_rep,
                            NULL dt_monitorization_rep,
                            NULL dt_cancel_rep,
                            NULL dt_next_rep,
                            NULL dt_vs_req_rep,
                            NULL cancel_reason_desc,
                            NULL id_cancel_reason,
                            c.co_sign_notes co_sign_notes
                      FROM monitorization m
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                     INNER JOIN episode epi
                        ON m.id_episode = epi.id_episode
                     INNER JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_cancel)) c
                        ON c.id_co_sign = m.id_co_sign_cancel
                     WHERE mvs.id_monitorization_vs = i_id_monitor_vs
                          --  AND m.id_co_sign_cancel IS NOT NULL
                       AND c.id_prof_co_signed IS NOT NULL
                    UNION ALL
                    --order co-sign
                    SELECT rownum rn,
                            epi.id_episode,
                            epi.id_visit,
                            epi.id_patient,
                            NULL flg_status,
                            NULL dt_begin_tstz,
                            NULL start_time,
                            NULL end_time,
                            c.dt_co_signed dt_monitorization,
                            3 ordering,
                            NULL notes,
                            pk_alert_constant.g_monitor_vs_exec flg_status_det,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, c.id_prof_co_signed) nick_name,
                            c.desc_status desc_status,
                            NULL flg_time,
                            NULL desc_time,
                            c.dt_co_signed dt_ordering,
                            pk_date_utils.dt_chr_tsz(i_lang, c.dt_co_signed, i_prof) date_req,
                            pk_date_utils.date_char_hour_tsz(i_lang, c.dt_co_signed, i_prof.institution, i_prof.software) hour_req,
                            NULL date_begin,
                            NULL hour_begin,
                            NULL date_end,
                            NULL hour_end,
                            NULL desc_interval,
                            NULL dt_cancel,
                            NULL title_cancel,
                            NULL prof_cancel,
                            NULL notes_cancel,
                            NULL desc_speciality,
                            NULL desc_speciality_cancel,
                            NULL date_next,
                            NULL hour_next,
                            NULL desc_vs,
                            NULL prof_order,
                            NULL order_type_desc,
                            NULL dt_order,
                            NULL name_performed,
                            NULL prof_order_spec,
                            l_sm_order_cosign label_order,
                            NULL dt_begin_rep,
                            NULL dt_end_rep,
                            NULL dt_monitorization_rep,
                            NULL dt_cancel_rep,
                            NULL dt_next_rep,
                            NULL dt_vs_req_rep,
                            NULL cancel_reason_desc,
                            NULL id_cancel_reason,
                            c.co_sign_notes co_sign_notes
                      FROM monitorization m
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                     INNER JOIN episode epi
                        ON m.id_episode = epi.id_episode
                     INNER JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_order)) c
                        ON c.id_co_sign = m.id_co_sign_order
                     WHERE mvs.id_monitorization_vs = i_id_monitor_vs
                       AND c.id_prof_co_signed IS NOT NULL
                    UNION ALL
                    --Executions/cancelled/discontinued/draft
                    SELECT rownum rn,
                            epi.id_episode,
                            epi.id_visit,
                            epi.id_patient,
                            m.flg_status,
                            m.dt_begin_tstz,
                            mvsp.start_time,
                            mvsp.end_time,
                            mvsp.dt_plan_tstz dt_monitorization,
                            2 ordering,
                            pk_translation.get_translation_trs(mvs.code_notes) notes,
                            decode(mvsp.flg_status, pk_alert_constant.g_monitor_vs_canc, m.flg_status, mvsp.flg_status) AS flg_status_det,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, mvs.id_prof_cancel),
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, mvsp.id_prof_performed)) nick_name,
                            pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS', m.flg_status, i_lang) desc_status,
                            m.flg_time,
                            NULL desc_time,
                            decode(mvsp.flg_status, pk_alert_constant.g_monitor_vs_canc, mvs.dt_cancel_tstz, mvsp.end_time) dt_ordering,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   pk_date_utils.dt_chr_tsz(i_lang, mvs.dt_cancel_tstz, i_prof),
                                   pk_date_utils.dt_chr_tsz(i_lang, mvsp.end_time, i_prof)) date_req,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                                    mvs.dt_cancel_tstz,
                                                                    i_prof.institution,
                                                                    i_prof.software),
                                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                                    mvsp.start_time,
                                                                    i_prof.institution,
                                                                    i_prof.software)) hour_req,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          pk_date_utils.dt_chr_tsz(i_lang,
                                                                   nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                   i_prof),
                                          NULL)) date_begin,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                                           nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                           i_prof.institution,
                                                                           i_prof.software),
                                          NULL)) hour_begin,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          pk_date_utils.dt_chr_tsz(i_lang, m.dt_end_tstz, i_prof),
                                          NULL)) date_end,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                                           m.dt_end_tstz,
                                                                           i_prof.institution,
                                                                           i_prof.software),
                                          NULL)) hour_end,
                            get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_cancelled,
                                   pk_date_utils.date_char_tsz(i_lang,
                                                               mvs.dt_cancel_tstz,
                                                               i_prof.institution,
                                                               i_prof.software),
                                   NULL) dt_cancel,
                            decode(mvsp.flg_status, pk_alert_constant.g_cancelled, l_sm_cancel_notes, NULL) title_cancel,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_cancelled,
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, mvs.id_prof_cancel),
                                   NULL) prof_cancel,
                            mvs.notes_cancel,
                            pk_prof_utils.get_spec_signature(i_lang,
                                                             i_prof,
                                                             mvsp.id_prof_performed,
                                                             mvsp.dt_plan_tstz,
                                                             m.id_episode) desc_speciality,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_cancelled,
                                   pk_prof_utils.get_spec_signature(i_lang,
                                                                    i_prof,
                                                                    mvs.id_prof_cancel,
                                                                    m.dt_monitorization_tstz,
                                                                    m.id_episode),
                                   NULL) desc_speciality_cancel,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          NULL,
                                          pk_date_utils.dt_chr_tsz(i_lang,
                                                                   (SELECT next_dt_plan
                                                                      FROM (SELECT id_monitorization_vs_plan,
                                                                                   lead(dt_plan_tstz) over(ORDER BY dt_plan_tstz) next_dt_plan
                                                                              FROM monitorization_vs_plan
                                                                             WHERE id_monitorization_vs = i_id_monitor_vs)
                                                                     WHERE id_monitorization_vs_plan =
                                                                           mvsp.id_monitorization_vs_plan),
                                                                   i_prof))) date_next,
                            decode(m.flg_time,
                                   pk_alert_constant.g_flg_time_n,
                                   NULL,
                                   decode(mvsp.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          NULL,
                                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                                           (SELECT next_dt_plan
                                                                              FROM (SELECT id_monitorization_vs_plan,
                                                                                           lead(dt_plan_tstz) over(ORDER BY dt_plan_tstz) next_dt_plan
                                                                                      FROM monitorization_vs_plan
                                                                                     WHERE id_monitorization_vs =
                                                                                           i_id_monitor_vs)
                                                                             WHERE id_monitorization_vs_plan =
                                                                                   mvsp.id_monitorization_vs_plan),
                                                                           i_prof.institution,
                                                                           i_prof.software))) hour_next,
                            
                            (pk_monitorization.get_vs_desc(i_lang, m.id_monitorization, i_prof) ||
                            nvl2(m.id_prev_episode,
                                  ' - (' || pk_message.get_message(i_lang,
                                                                   profissional(i_prof.id,
                                                                                i_prof.institution,
                                                                                pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                                   FROM episode e
                                                                                                                  WHERE e.id_episode =
                                                                                                                        m.id_prev_episode),
                                                                                                                 i_prof.institution)),
                                                                   'IMAGE_T009') || ')',
                                  '')) desc_vs,
                            decode(mvsp.flg_status, pk_alert_constant.g_monitor_vs_canc, c.desc_prof_ordered_by, NULL) prof_order,
                            decode(mvsp.flg_status, pk_alert_constant.g_monitor_vs_canc, c.desc_order_type, NULL) order_type_desc,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   
                                   pk_date_utils.date_char_tsz(i_lang, c.dt_ordered_by, i_prof.institution, i_prof.software),
                                   NULL) dt_order,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   pk_tools.get_prof_speciality(i_lang, mvs.id_prof_order),
                                   NULL) prof_order_spec,
                            NULL name_performed,
                            decode(mvsp.flg_status,
                                   pk_alert_constant.g_monitor_vs_fini,
                                   l_sm_execution,
                                   pk_alert_constant.g_monitor_vs_pend,
                                   l_sm_pending,
                                   pk_alert_constant.g_monitor_vs_exec,
                                   l_sm_pending,
                                   pk_alert_constant.g_monitor_vs_draft,
                                   l_sm_draft,
                                   pk_alert_constant.g_monitor_vs_canc,
                                   decode(mvs.flg_status,
                                          pk_alert_constant.g_monitor_vs_canc,
                                          l_sm_cancelled,
                                          pk_alert_constant.g_monitor_vs_inte,
                                          l_sm_discontinued)) label_order,
                            pk_date_utils.date_char_tsz(i_lang, m.dt_begin_tstz, i_prof.institution, i_prof.software) dt_begin_rep,
                            pk_date_utils.date_char_tsz(i_lang, m.dt_end_tstz, i_prof.institution, i_prof.software) dt_end_rep,
                            pk_date_utils.date_char_tsz(i_lang,
                                                        m.dt_monitorization_tstz,
                                                        i_prof.institution,
                                                        i_prof.software) dt_monitorization_rep,
                            pk_date_utils.date_char_tsz(i_lang, mvs.dt_cancel_tstz, i_prof.institution, i_prof.software) dt_cancel_rep,
                            pk_date_utils.date_char_tsz(i_lang, mvsp.dt_plan_tstz, i_prof.institution, i_prof.software) dt_next_rep,
                            pk_date_utils.date_char_tsz(i_lang,
                                                        mvs.dt_monitorization_vs_tstz,
                                                        i_prof.institution,
                                                        i_prof.software) dt_vs_req_rep,
                            decode(mvs.id_cancel_reason,
                                   NULL,
                                   NULL,
                                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, mvs.id_cancel_reason)) cancel_reason_desc,
                            mvs.id_cancel_reason,
                            NULL co_sign_notes
                      FROM monitorization m
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                     INNER JOIN monitorization_vs_plan mvsp
                        ON mvs.id_monitorization_vs = mvsp.id_monitorization_vs
                      LEFT JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_cancel)) c
                        ON c.id_co_sign = m.id_co_sign_cancel
                     INNER JOIN episode epi
                        ON m.id_episode = epi.id_episode
                     WHERE mvs.id_monitorization_vs = i_id_monitor_vs
                       AND mvsp.flg_status NOT IN (pk_alert_constant.g_monitor_vs_pend,
                                                   pk_alert_constant.g_monitor_vs_exec,
                                                   pk_alert_constant.g_monitor_vs_expire)
                    UNION ALL
                    --Order
                    SELECT *
                      FROM (SELECT row_number() over(PARTITION BY mvsp.id_monitorization_vs ORDER BY mvsp.id_monitorization_vs_plan) rn,
                                    epi.id_episode,
                                    epi.id_visit,
                                    epi.id_patient,
                                    m.flg_status,
                                    m.dt_begin_tstz,
                                    mvsp.start_time,
                                    mvsp.end_time,
                                    m.dt_monitorization_tstz dt_monitorization,
                                    1 ordering,
                                    pk_translation.get_translation_trs(mvs.code_notes) notes,
                                    pk_alert_constant.g_monitor_vs_exec AS flg_status_det,
                                    pk_prof_utils.get_name_signature(i_lang, i_prof, m.id_professional) nick_name,
                                    pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS', m.flg_status, i_lang) desc_status,
                                    m.flg_time,
                                    pk_sysdomain.get_domain('MONITORIZATION.FLG_TIME', m.flg_time, i_lang) desc_time,
                                    mvs.dt_monitorization_vs_tstz dt_ordering,
                                    pk_date_utils.dt_chr_tsz(i_lang, mvs.dt_monitorization_vs_tstz, i_prof) date_req,
                                    pk_date_utils.date_char_hour_tsz(i_lang,
                                                                     mvs.dt_monitorization_vs_tstz,
                                                                     i_prof.institution,
                                                                     i_prof.software) hour_req,
                                    decode(m.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           pk_date_utils.dt_chr_tsz(i_lang,
                                                                    nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                    i_prof)) date_begin,
                                    decode(m.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           pk_date_utils.date_char_hour_tsz(i_lang,
                                                                            nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                            i_prof.institution,
                                                                            i_prof.software)) hour_begin,
                                    decode(m.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           pk_date_utils.dt_chr_tsz(i_lang, m.dt_end_tstz, i_prof)) date_end,
                                    decode(m.flg_time,
                                           pk_alert_constant.g_flg_time_n,
                                           NULL,
                                           pk_date_utils.date_char_hour_tsz(i_lang,
                                                                            m.dt_end_tstz,
                                                                            i_prof.institution,
                                                                            i_prof.software)) hour_end,
                                    get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                mvs.dt_cancel_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_cancel,
                                    decode(mvs.flg_status, pk_alert_constant.g_monitor_vs_canc, l_sm_cancel_notes, '') title_cancel,
                                    pk_prof_utils.get_name_signature(i_lang, i_prof, mvs.id_prof_cancel) prof_cancel,
                                    mvs.notes_cancel,
                                    pk_prof_utils.get_spec_signature(i_lang,
                                                                     i_prof,
                                                                     m.id_professional,
                                                                     m.dt_monitorization_tstz,
                                                                     m.id_episode) desc_speciality,
                                    pk_prof_utils.get_spec_signature(i_lang,
                                                                     i_prof,
                                                                     mvs.id_prof_cancel,
                                                                     m.dt_monitorization_tstz,
                                                                     m.id_episode) desc_speciality_cancel,
                                    NULL date_next,
                                    NULL hour_next,
                                    (pk_monitorization.get_vs_desc(i_lang, m.id_monitorization, i_prof) ||
                                    nvl2(m.id_prev_episode,
                                          ' - (' || pk_message.get_message(i_lang,
                                                                           profissional(i_prof.id,
                                                                                        i_prof.institution,
                                                                                        pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                                           FROM episode e
                                                                                                                          WHERE e.id_episode =
                                                                                                                                m.id_prev_episode),
                                                                                                                         i_prof.institution)),
                                                                           'IMAGE_T009') || ')',
                                          '')) desc_vs,
                                    c.desc_prof_ordered_by prof_order,
                                    c.desc_order_type order_type_desc,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                c.dt_ordered_by,
                                                                i_prof.institution,
                                                                i_prof.software) dt_order,
                                    pk_prof_utils.get_name_signature(i_lang, i_prof, mvsp.id_prof_performed) name_performed,
                                    pk_tools.get_prof_speciality(i_lang, c.id_prof_ordered_by) prof_order_spec,
                                    l_sm_order label_order,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                m.dt_begin_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_begin_rep,
                                    pk_date_utils.date_char_tsz(i_lang, m.dt_end_tstz, i_prof.institution, i_prof.software) dt_end_rep,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                m.dt_monitorization_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_monitorization_rep,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                mvs.dt_cancel_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_cancel_rep,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                mvsp.dt_plan_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_next_rep,
                                    pk_date_utils.date_char_tsz(i_lang,
                                                                mvs.dt_monitorization_vs_tstz,
                                                                i_prof.institution,
                                                                i_prof.software) dt_vs_req_rep,
                                    decode(mvs.id_cancel_reason,
                                           NULL,
                                           NULL,
                                           pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, mvs.id_cancel_reason)) cancel_reason_desc,
                                    mvs.id_cancel_reason,
                                    NULL co_sign_notes
                               FROM monitorization m
                              INNER JOIN monitorization_vs mvs
                                 ON m.id_monitorization = mvs.id_monitorization
                              INNER JOIN monitorization_vs_plan mvsp
                                 ON mvs.id_monitorization_vs = mvsp.id_monitorization_vs
                               LEFT JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_order)) c
                                 ON c.id_co_sign = m.id_co_sign_order
                              INNER JOIN episode epi
                                 ON m.id_episode = epi.id_episode
                              WHERE mvs.id_monitorization_vs = i_id_monitor_vs)
                     WHERE rn = 1) t
             WHERE t.id_episode = nvl(l_id_episode, t.id_episode)
               AND t.id_visit = nvl(l_id_visit, t.id_visit)
               AND t.id_patient = nvl(l_id_patient, t.id_patient)
               AND (
                   --not report gets all
                    i_flg_report = pk_alert_constant.g_no OR
                   --
                    (
                    --if report
                     i_flg_report = pk_alert_constant.g_yes
                    --
                     AND
                    --
                     (
                     --shows canceled monitorizations or not whether flag i_cancelled
                      (i_cancelled = pk_alert_constant.g_no AND t.flg_status <> pk_alert_constant.g_monitor_vs_canc) OR
                      i_cancelled = pk_alert_constant.g_yes
                     --
                     )
                    --
                     AND
                    --
                     (
                     --shows monitorizations or not whether flag i_crit_type and the dates (i_start_date and i_end_date)
                     --Shows all the monitorizations where the req and exec was performed in the period
                      (i_crit_type = g_monit_crit_type_all_a AND
                      (t.dt_begin_tstz BETWEEN nvl(l_start_date, t.dt_begin_tstz) AND nvl(l_end_date, t.dt_begin_tstz) OR
                      (t.start_time BETWEEN nvl(l_start_date, t.start_time) AND nvl(l_end_date, t.start_time) AND
                      t.end_time BETWEEN nvl(l_start_date, t.end_time) AND nvl(l_end_date, t.end_time))))
                     --
                      OR
                     --Shows the monitorizations that where req in the period
                      (i_crit_type = g_monit_crit_type_req_r AND
                      t.dt_begin_tstz BETWEEN nvl(l_start_date, t.dt_begin_tstz) AND nvl(l_end_date, t.dt_begin_tstz))
                     --
                      OR
                     --Shows the monitorizations that where exec in the period
                      (i_crit_type = g_monit_crit_type_exec_e AND t.start_time BETWEEN nvl(l_start_date, t.start_time) AND
                      nvl(l_end_date, t.start_time) AND t.end_time BETWEEN nvl(l_start_date, t.end_time) AND
                      nvl(l_end_date, t.end_time))
                     --
                     )
                    --
                    )
                   --
                   )
             ORDER BY dt_ordering DESC, t.hour_req DESC, t.ordering DESC; -- as only the first row of the cursor is used on UX layer, 
        -- this allows considering the rows different from 'F' first
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONITOR_VS_REQ',
                                              o_error);
            pk_types.open_my_cursor(o_monitor);
            RETURN FALSE;
    END get_monitor_vs_req;

    /**********************************************************************************************
    * Resultados de monitorizações
    *
    * @param i_lang                   the id language
    * @param i_id_monitorization_vs   Id do plano da monitorização
    * @param i_monitorization_vs_plan Id do plano da monitorização a detalhar
    * @param i_prof                   professional, software and institution ids
    * @param o_monitor                array com o detalhe da monitorização
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Paulo Fonseca
    * @version                        2.5.0
    * @since                          2009/04/29
    **********************************************************************************************/
    FUNCTION get_monitor_vs_result
    (
        i_lang                   IN language.id_language%TYPE,
        i_id_monitorization_vs   IN monitorization_vs.id_monitorization_vs%TYPE,
        i_monitorization_vs_plan IN monitorization_vs_plan.id_monitorization_vs_plan%TYPE,
        i_prof                   IN profissional,
        o_monitor                OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message              debug_msg;
        l_id_monitorization_vs monitorization_vs.id_monitorization_vs%TYPE;
    
    BEGIN
        l_message := 'GET ID_MONITORIZATION_VS';
        IF i_id_monitorization_vs IS NULL
        THEN
            SELECT id_monitorization_vs
              INTO l_id_monitorization_vs
              FROM monitorization_vs_plan
             WHERE id_monitorization_vs_plan = i_monitorization_vs_plan;
        ELSE
            l_id_monitorization_vs := i_id_monitorization_vs;
        END IF;
    
        l_message := 'OPEN O_MONITOR';
        OPEN o_monitor FOR
            SELECT pk_date_utils.dt_chr_tsz(i_lang, dt_plan_tstz, i_prof) date_target,
                   pk_date_utils.date_char_hour_tsz(i_lang, dt_plan_tstz, i_prof.institution, i_prof.software) hour_target,
                   id_vital_sign_read,
                   id_vital_sign,
                   flg_state,
                   id_prof_read id_professional,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, id_prof_read, dt_vital_sign_read_tstz, id_episode) prof_read_speciality,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_read) prof_read,
                   pk_date_utils.date_send_tsz(i_lang, dt_vital_sign_read_tstz, i_prof.institution, i_prof.software) dt_vital_sign_read,
                   pk_date_utils.dt_chr_tsz(i_lang, dt_vital_sign_read_tstz, i_prof) dt_target,
                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                    dt_vital_sign_read_tstz,
                                                    i_prof.institution,
                                                    i_prof.software) hr_target,
                   pk_translation.get_translation(i_lang, code_vital_sign) desc_vs,
                   VALUE || ' ' ||
                   pk_vital_sign.get_vital_sign_unit_measure(i_lang, id_unit_measure, id_vs_scales_element) VALUE,
                   pk_vital_sign.get_vs_scale_shortdesc(i_lang, id_vs_scales_element) scale_desc,
                   pk_sysdomain.get_rank(i_lang, 'VITAL_SIGN_READ.FLG_STATE', flg_state) rank,
                   pk_sysdomain.get_domain('VITAL_SIGN_READ.FLG_STATE', flg_state, i_lang) desc_status,
                   pk_date_utils.dt_chr_tsz(i_lang, dt_cancel_tstz, i_prof) date_status,
                   pk_date_utils.date_char_hour_tsz(i_lang, dt_cancel_tstz, i_prof.institution, i_prof.software) hour_status,
                   flg_status,
                   decode(flg_state, pk_alert_constant.g_cancelled, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_cancel,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, id_prof_cancel, dt_cancel_tstz, id_episode) prof_cancel_speciality,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_cancel) prof_cancel,
                   pk_date_utils.dt_chr_tsz(i_lang, dt_cancel_tstz, i_prof) date_cancel_target,
                   pk_date_utils.date_char_hour_tsz(i_lang, dt_cancel_tstz, i_prof.institution, i_prof.software) hour_cancel_target,
                   pk_date_utils.to_char_insttimezone(i_prof, dt_plan_tstz, 'YYYYMMDDHH24MISS') dt_ord1,
                   pk_date_utils.to_char_insttimezone(i_prof, dt_vital_sign_read_tstz, 'YYYYMMDDHH24MISS') dt_ord2,
                   pk_date_utils.to_char_insttimezone(i_prof, dt_cancel_tstz, 'YYYYMMDDHH24MISS') dt_ord3,
                   id_monitorization_vs_plan,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_performed) name_performed,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    id_prof_performed,
                                                    dt_monitorization_tstz,
                                                    id_episode) prof_performed_speciality,
                   pk_date_utils.date_send_tsz(i_lang, start_time, i_prof) start_time_send,
                   pk_date_utils.date_char_tsz(i_lang, start_time, i_prof.institution, i_prof.software) start_time_char,
                   pk_date_utils.date_send_tsz(i_lang, end_time, i_prof) end_time_send,
                   pk_date_utils.date_char_tsz(i_lang, end_time, i_prof.institution, i_prof.software) end_time_char,
                   notes_cancel,
                   id_cancel_reason,
                   decode(id_cancel_reason,
                          NULL,
                          NULL,
                          pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, id_cancel_reason)) desc_cancel_reason,
                   CASE
                        WHEN flg_status_monit IN (pk_alert_constant.g_monitor_vs_expire,
                                                  pk_alert_constant.g_monitor_vs_canc,
                                                  pk_alert_constant.g_monitor_vs_inte,
                                                  pk_alert_constant.g_monitor_vs_fini) THEN
                         pk_alert_constant.g_no
                        WHEN flg_state = pk_alert_constant.g_cancelled THEN
                         pk_alert_constant.g_no
                        WHEN flg_status = pk_alert_constant.g_monitor_vs_fini THEN
                         pk_alert_constant.g_no
                        WHEN i_prof.id = id_prof_read THEN
                         pk_alert_constant.g_yes
                        ELSE
                         pk_alert_constant.g_no
                    END flg_cancel_but
              FROM (
                    -- Glasgow Total's
                     SELECT mvsp.dt_plan_tstz,
                             (SELECT vsri.id_vital_sign_read
                                FROM vital_sign_read vsri
                               WHERE vsri.id_monitorization_vs_plan = mvsp.id_monitorization_vs_plan
                                 AND pk_delivery.check_vs_read_from_fetus(vsri.id_vital_sign_read) = 0
                                 AND rownum = 1) id_vital_sign_read,
                             mvs.id_vital_sign,
                             NULL id_unit_measure,
                             vsr.flg_state,
                             vsr.id_prof_read,
                             vsr.dt_vital_sign_read_tstz,
                             vs.code_vital_sign,
                             to_char(SUM(vsd.value)) VALUE,
                             NULL id_vs_scales_element,
                             vsr.dt_cancel_tstz,
                             mvs.flg_status,
                             vsr.id_prof_cancel,
                             mvsp.id_monitorization_vs_plan,
                             mvsp.id_prof_performed,
                             m.dt_monitorization_tstz,
                             m.id_episode,
                             mvsp.start_time,
                             mvsp.end_time,
                             vsr.notes_cancel,
                             vsr.id_cancel_reason,
                             m.flg_status flg_status_monit
                       FROM monitorization_vs_plan mvsp
                      INNER JOIN vital_sign_read vsr
                         ON mvsp.id_monitorization_vs_plan = vsr.id_monitorization_vs_plan
                      INNER JOIN monitorization_vs mvs
                         ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                      INNER JOIN monitorization m
                         ON mvs.id_monitorization = m.id_monitorization
                      INNER JOIN vital_sign vs
                         ON mvs.id_vital_sign = vs.id_vital_sign
                      INNER JOIN vital_sign_desc vsd
                         ON vsr.id_vital_sign_desc = vsd.id_vital_sign_desc
                      WHERE mvsp.id_monitorization_vs = l_id_monitorization_vs
                        AND (i_monitorization_vs_plan IS NULL OR mvsp.id_monitorization_vs_plan = i_monitorization_vs_plan)
                        AND mvsp.flg_status NOT IN
                            (pk_alert_constant.g_monitor_vs_pend, pk_alert_constant.g_monitor_vs_exec)
                        AND EXISTS (SELECT 1
                               FROM vital_sign_relation vsrl
                              WHERE vs.id_vital_sign = vsrl.id_vital_sign_parent
                                AND vsrl.relation_domain = pk_alert_constant.g_vs_rel_sum)
                        AND pk_delivery.check_vs_read_from_fetus(vsr.id_vital_sign_read) = 0
                      GROUP BY mvsp.dt_plan_tstz,
                                mvs.id_vital_sign,
                                vsr.flg_state,
                                vsr.id_prof_read,
                                vsr.dt_vital_sign_read_tstz,
                                vs.code_vital_sign,
                                --vs.code_measure_unit,
                                vsr.dt_cancel_tstz,
                                mvs.flg_status,
                                vsr.id_prof_cancel,
                                mvsp.id_monitorization_vs_plan,
                                mvsp.id_prof_performed,
                                m.dt_monitorization_tstz,
                                m.id_episode,
                                mvsp.start_time,
                                mvsp.end_time,
                                vsr.notes_cancel,
                                vsr.id_cancel_reason,
                                m.flg_status
                     UNION -- Blood Pressure's
                    SELECT mvsp.dt_plan_tstz,
                            vsr.id_vital_sign_read,
                            mvs.id_vital_sign,
                            vsr.id_unit_measure,
                            vsr.flg_state,
                            vsr.id_prof_read,
                            vsr.dt_vital_sign_read_tstz,
                            vs.code_vital_sign,
                            vsr.value || '/' ||
                            (SELECT vsr1.value
                               FROM vital_sign_read vsr1
                              INNER JOIN monitorization_vs_plan mp1
                                 ON vsr1.id_monitorization_vs_plan = mp1.id_monitorization_vs_plan
                              INNER JOIN vital_sign_relation vsrn1
                                 ON vsr1.id_vital_sign = vsrn1.id_vital_sign_detail
                              WHERE mp1.id_monitorization_vs = mvsp.id_monitorization_vs
                                AND mp1.id_monitorization_vs_plan = mvsp.id_monitorization_vs_plan
                                AND mp1.flg_status NOT IN
                                    (pk_alert_constant.g_monitor_vs_pend, pk_alert_constant.g_monitor_vs_exec)
                                AND vsrn1.relation_domain = pk_alert_constant.g_vs_rel_conc
                                AND vsrn1.rank =
                                    (SELECT MAX(vsrlmax.rank)
                                       FROM vital_sign_relation vsrlmax
                                      WHERE mvs.id_vital_sign = vsrlmax.id_vital_sign_parent
                                        AND vsrlmax.relation_domain = pk_alert_constant.g_vs_rel_conc)
                                AND pk_delivery.check_vs_read_from_fetus(vsr1.id_vital_sign_read) = 0) VALUE,
                            NULL id_vs_scales_element,
                            vsr.dt_cancel_tstz,
                            mvs.flg_status,
                            vsr.id_prof_cancel,
                            mvsp.id_monitorization_vs_plan,
                            mvsp.id_prof_performed,
                            m.dt_monitorization_tstz,
                            m.id_episode,
                            mvsp.start_time,
                            mvsp.end_time,
                            vsr.notes_cancel,
                            vsr.id_cancel_reason,
                            m.flg_status
                      FROM monitorization_vs_plan mvsp
                     INNER JOIN vital_sign_read vsr
                        ON mvsp.id_monitorization_vs_plan = vsr.id_monitorization_vs_plan
                     INNER JOIN monitorization_vs mvs
                        ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                     INNER JOIN monitorization m
                        ON mvs.id_monitorization = m.id_monitorization
                     INNER JOIN vital_sign vs
                        ON vsr.id_vital_sign = vs.id_vital_sign
                     INNER JOIN vital_sign_relation vsrl
                        ON vs.id_vital_sign = vsrl.id_vital_sign_detail
                     WHERE mvsp.id_monitorization_vs = l_id_monitorization_vs
                       AND (i_monitorization_vs_plan IS NULL OR mvsp.id_monitorization_vs_plan = i_monitorization_vs_plan)
                       AND mvsp.flg_status NOT IN
                           (pk_alert_constant.g_monitor_vs_pend, pk_alert_constant.g_monitor_vs_exec)
                       AND vsrl.relation_domain = pk_alert_constant.g_vs_rel_conc
                       AND vsrl.rank = (SELECT MIN(vsrlmin.rank)
                                          FROM vital_sign_relation vsrlmin
                                         WHERE mvs.id_vital_sign = vsrlmin.id_vital_sign_parent
                                           AND vsrlmin.relation_domain = pk_alert_constant.g_vs_rel_conc)
                       AND pk_delivery.check_vs_read_from_fetus(vsr.id_vital_sign_read) = 0
                    UNION -- Everything else
                    SELECT mvsp.dt_plan_tstz,
                            vsr.id_vital_sign_read,
                            vsr.id_vital_sign,
                            vsr.id_unit_measure,
                            vsr.flg_state,
                            vsr.id_prof_read,
                            vsr.dt_vital_sign_read_tstz,
                            vs.code_vital_sign,
                            decode(vs.flg_fill_type,
                                   pk_alert_constant.g_vs_ft_multichoice,
                                   pk_vital_sign.get_vs_alias(i_lang, vsr.id_patient, vsd.code_vital_sign_desc),
                                   to_char(vsr.value)) VALUE,
                            vsr.id_vs_scales_element,
                            vsr.dt_cancel_tstz,
                            mvs.flg_status,
                            vsr.id_prof_cancel,
                            mvsp.id_monitorization_vs_plan,
                            mvsp.id_prof_performed,
                            m.dt_monitorization_tstz,
                            m.id_episode,
                            mvsp.start_time,
                            mvsp.end_time,
                            vsr.notes_cancel,
                            vsr.id_cancel_reason,
                            m.flg_status flg_status_monit
                      FROM monitorization_vs_plan mvsp
                     INNER JOIN vital_sign_read vsr
                        ON mvsp.id_monitorization_vs_plan = vsr.id_monitorization_vs_plan
                     INNER JOIN monitorization_vs mvs
                        ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                     INNER JOIN monitorization m
                        ON mvs.id_monitorization = m.id_monitorization
                     INNER JOIN vital_sign vs
                        ON vsr.id_vital_sign = vs.id_vital_sign
                      LEFT JOIN vital_sign_desc vsd
                        ON vsr.id_vital_sign_desc = vsd.id_vital_sign_desc
                     WHERE mvsp.id_monitorization_vs = l_id_monitorization_vs
                       AND (i_monitorization_vs_plan IS NULL OR mvsp.id_monitorization_vs_plan = i_monitorization_vs_plan)
                       AND mvsp.flg_status NOT IN
                           (pk_alert_constant.g_monitor_vs_pend, pk_alert_constant.g_monitor_vs_exec)
                       AND NOT EXISTS (SELECT 1
                              FROM vital_sign_relation vsrl
                             WHERE vs.id_vital_sign = vsrl.id_vital_sign_detail
                               AND vsrl.relation_domain IN
                                   (pk_alert_constant.g_vs_rel_conc, pk_alert_constant.g_vs_rel_sum))
                       AND pk_delivery.check_vs_read_from_fetus(vsr.id_vital_sign_read) = 0)
             ORDER BY rank, dt_vital_sign_read DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => l_message,
                                              i_owner    => c_package_owner,
                                              i_package  => c_package_name,
                                              i_function => 'GET_MONITOR_VS_RESULTS',
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_monitor);
            RETURN FALSE;
    END get_monitor_vs_result;

    /******************************************************************************
       OBJECTIVO:   Obter leituras de sinais vitais pedidos numa monitorização
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION_VS - ID do detalhe da requisição.
              Saida:   O_MONITOR -  lista de detalhes de requisições
                 O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      CORRECÇÕES: CRS 2005/06/06
      NOTAS:
    *********************************************************************************/
    FUNCTION get_monitor_vs_result
    (
        i_lang                 IN language.id_language%TYPE,
        i_id_monitorization_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_prof                 IN profissional,
        o_monitor              OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN get_monitor_vs_result(i_lang                   => i_lang,
                                     i_id_monitorization_vs   => i_id_monitorization_vs,
                                     i_monitorization_vs_plan => NULL,
                                     i_prof                   => i_prof,
                                     o_monitor                => o_monitor,
                                     o_error                  => o_error);
    END get_monitor_vs_result;

    /**********************************************************************************************
    * Detalhe de cada resultado da monitorização
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_monitorization_vs_plan Id do plano da monitorização a detalhar
    * @param o_monitor_det            array com o detalhe da monitorização
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2007/10/16
    **********************************************************************************************/
    FUNCTION get_monitor_vs_result_det
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_monitorization_vs_plan IN monitorization_vs_plan.id_monitorization_vs_plan%TYPE,
        o_monitor_det            OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN get_monitor_vs_result(i_lang                   => i_lang,
                                     i_id_monitorization_vs   => NULL,
                                     i_monitorization_vs_plan => i_monitorization_vs_plan,
                                     i_prof                   => i_prof,
                                     o_monitor                => o_monitor_det,
                                     o_error                  => o_error);
    END get_monitor_vs_result_det;

    /******************************************************************************
       OBJECTIVO: Obter os SVs requisitados na monitorização indicada
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION - ID da requisicao
              Saida:  O_ERROR - erro
    
      CRIAÇÃO: CRS 2005/07/29
      NOTAS: FLG_MONITOR - Y - SV pedido na monitorização
                   N - SV ñ pedido
    *********************************************************************************/
    FUNCTION get_vs_monitor
    (
        i_lang              IN language.id_language%TYPE,
        i_id_monitorization IN monitorization_vs.id_monitorization%TYPE,
        i_prof              IN profissional,
        o_vs                OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
    BEGIN
        l_message := 'GET CURSOR';
        OPEN o_vs FOR
            SELECT DISTINCT vs.id_vital_sign,
                            vs.rank rank_show,
                            decode(nvl(mvs.id_monitorization_vs, 0),
                                   0, -- SV ñ foi pedido
                                   -- Total Glasgow é pai do SV corrente e foi pedido p/ monitorização
                                   decode(nvl(vr_det.id_vital_sign_parent, 0),
                                          aux.id_vital_sign,
                                          pk_alert_constant.g_yes,
                                          pk_alert_constant.g_no),
                                   decode(vr_par.relation_domain,
                                          pk_alert_constant.g_vs_rel_sum,
                                          pk_alert_constant.g_no,
                                          pk_alert_constant.g_yes)) flg_monitor, -- SV pedido
                            decode(nvl(mvs.id_monitorization_vs, 0),
                                   0, -- SV ñ foi pedido
                                   -- Total Glasgow é pai do SV corrente e foi pedido p/ monitorização
                                   decode(nvl(vr_det.id_vital_sign_parent, 0),
                                          aux.id_vital_sign,
                                          pk_alert_constant.g_yes,
                                          pk_alert_constant.g_no),
                                   decode(vr_par.relation_domain,
                                          pk_alert_constant.g_vs_rel_sum,
                                          pk_alert_constant.g_no,
                                          pk_alert_constant.g_yes)) flg_wizard,
                            vs.flg_show,
                            vr_det.id_vital_sign_parent,
                            decode(nvl(vr_det.id_vital_sign_relation, 0), 0, '', pk_alert_constant.g_vs_rel_sum) relation_type,
                            decode(nvl(vr_par.id_vital_sign_relation, 0), 0, vs.flg_fill_type, 'X') flg_fill_type,
                            decode(nvl(vr_det.id_vital_sign_relation, 0),
                                   0,
                                   pk_alert_constant.g_no,
                                   pk_alert_constant.g_yes) flg_sum,
                            0 rank_conc,
                            pk_translation.get_translation(i_lang, vs.code_vital_sign) name_vs
              FROM vital_sign          vs,
                   vital_sign_relation vr_par,
                   vital_sign_relation vr_det,
                   monitorization_vs   mvs,
                   vs_clin_serv        vcs,
                   -- tabela AUX só retorna valores se Total Glasgow foi pedido na monitorização
                   (SELECT DISTINCT mvs1.id_vital_sign, mvs1.id_monitorization
                      FROM monitorization_vs mvs1, vital_sign_relation vr_par1
                     WHERE mvs1.id_monitorization = i_id_monitorization
                       AND mvs1.flg_status != pk_alert_constant.g_monitor_vs_canc
                       AND vr_par1.id_vital_sign_parent = mvs1.id_vital_sign
                       AND vr_par1.relation_domain = pk_alert_constant.g_vs_rel_sum) aux
             WHERE vs.flg_available = pk_alert_constant.g_yes
               AND vs.flg_show = pk_alert_constant.g_yes
               AND vr_par.id_vital_sign_parent(+) = vs.id_vital_sign
               AND vr_par.relation_domain(+) = pk_alert_constant.g_vs_rel_sum -- Glasgow
               AND vr_det.id_vital_sign_detail(+) = vs.id_vital_sign
               AND vr_det.relation_domain(+) = pk_alert_constant.g_vs_rel_sum
               AND mvs.id_monitorization(+) = i_id_monitorization
               AND mvs.flg_status(+) != pk_alert_constant.g_monitor_vs_canc
               AND vs.id_vital_sign = mvs.id_vital_sign(+)
               AND vcs.id_vital_sign = vs.id_vital_sign
               AND vcs.id_software = i_prof.software
               AND aux.id_vital_sign(+) = vr_det.id_vital_sign_parent
            UNION
            SELECT DISTINCT vs.id_vital_sign,
                            vs.rank rank_show,
                            decode(nvl(mvs.id_monitorization_vs, 0), 0, pk_alert_constant.g_no, pk_alert_constant.g_yes) flg_monitor,
                            decode(nvl(mvs.id_monitorization_vs, 0), 0, pk_alert_constant.g_no, pk_alert_constant.g_yes) flg_wizard,
                            vs.flg_show,
                            vr_conc.id_vital_sign_parent,
                            pk_alert_constant.g_vs_rel_conc relation_type,
                            vs.flg_fill_type,
                            pk_alert_constant.g_no flg_sum,
                            vr_conc.rank rank_conc,
                            pk_translation.get_translation(i_lang, vs.code_vital_sign) name_vs
              FROM vital_sign vs, vital_sign_relation vr_conc, monitorization_vs mvs
             WHERE vs.flg_available = pk_alert_constant.g_yes
               AND vr_conc.id_vital_sign_detail = vs.id_vital_sign
               AND vr_conc.relation_domain = pk_alert_constant.g_vs_rel_conc -- Pressão arterial
               AND mvs.id_monitorization(+) = i_id_monitorization
               AND mvs.flg_status(+) != pk_alert_constant.g_monitor_vs_canc
               AND vs.id_vital_sign = mvs.id_vital_sign(+)
             ORDER BY rank_show, name_vs;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_VS_MONITOR',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_vs);
            RETURN FALSE;
    END get_vs_monitor;

    /**********************************************************************************************
    * initialize the monit type
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_id_monitorization      monitorization id 
    * @param       io_monit                 monitorization type
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/20
    **********************************************************************************************/
    FUNCTION init_monit
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_monitorization    IN monitorization.id_monitorization%TYPE,
        io_monit               IN OUT NOCOPY monit,
        i_draft                IN VARCHAR2 DEFAULT 'N',
        i_task_start_timestamp IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message            debug_msg;
        l_id_order_type      co_sign.id_order_type%TYPE;
        l_init_dft_tstz      monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_monitorization_row monitorization%ROWTYPE;
    BEGIN
        l_message := 'PK_MONITORIZATION.INIT_MONIT - get monitorization';
    
        IF i_draft = pk_alert_constant.g_no
        THEN
            SELECT m.*
              INTO l_monitorization_row
              FROM monitorization m
             WHERE m.id_monitorization = i_id_monitorization;
        
            IF i_task_start_timestamp IS NOT NULL
            THEN
                l_init_dft_tstz := i_task_start_timestamp;
            END IF;
        ELSE
            SELECT m.*
              INTO l_monitorization_row
              FROM monitorization m
             WHERE m.id_monitorization = i_id_monitorization;
        
            IF i_task_start_timestamp IS NOT NULL
            THEN
                l_init_dft_tstz := i_task_start_timestamp;
            ELSE
                BEGIN
                    SELECT t.dt_plan_tstz
                      INTO l_init_dft_tstz
                      FROM (SELECT DISTINCT mvsp.dt_plan_tstz
                            
                              FROM monitorization m
                              JOIN monitorization_vs mvs
                                ON m.id_monitorization = mvs.id_monitorization
                              JOIN monitorization_vs_plan mvsp
                                ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                               AND mvsp.flg_status = pk_monitorization.g_monit_vs_plan_final
                             WHERE m.id_monitorization = i_id_monitorization
                             ORDER BY mvsp.dt_plan_tstz DESC NULLS LAST) t
                     WHERE rownum = 1;
                EXCEPTION
                    WHEN no_data_found THEN
                        BEGIN
                            SELECT DISTINCT mvsp.dt_plan_tstz
                              INTO l_init_dft_tstz
                              FROM monitorization m
                              JOIN monitorization_vs mvs
                                ON m.id_monitorization = mvs.id_monitorization
                              JOIN monitorization_vs_plan mvsp
                                ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                               AND mvsp.flg_status = pk_monitorization.g_monit_vs_plan_ongoing
                             WHERE m.id_monitorization = i_id_monitorization;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_init_dft_tstz := NULL;
                        END;
                END;
            END IF;
        END IF;
    
        l_message := 'PK_MONITORIZATION.INIT_MONIT - get id_order_type';
        BEGIN
            SELECT c.id_order_type
              INTO l_id_order_type
              FROM co_sign c
             WHERE c.id_co_sign = l_monitorization_row.id_co_sign_order;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_order_type := NULL;
        END;
    
        io_monit := monit(id_co_sign_order          => l_monitorization_row.id_co_sign_order,
                          id_co_sign_cancel         => l_monitorization_row.id_co_sign_cancel,
                          id_monit                  => l_monitorization_row.id_monitorization,
                          id_prof                   => i_prof.id,
                          id_inst                   => i_prof.institution,
                          id_soft                   => i_prof.software,
                          id_epis                   => l_monitorization_row.id_episode,
                          dt_order_str              => get_str_date(i_lang,
                                                                    i_prof,
                                                                    nvl(l_init_dft_tstz,
                                                                        l_monitorization_row.dt_monitorization_tstz)),
                          dt_begin_str              => get_str_date(i_lang,
                                                                    i_prof,
                                                                    nvl(l_init_dft_tstz,
                                                                        l_monitorization_row.dt_begin_tstz)),
                          dt_end_str                => get_str_date(i_lang, i_prof, l_monitorization_row.dt_end_tstz),
                          dt_begin_final_str        => get_str_date(i_lang,
                                                                    i_prof,
                                                                    nvl(l_init_dft_tstz,
                                                                        l_monitorization_row.dt_begin_tstz)),
                          notes                     => pk_translation.get_translation_trs(l_monitorization_row.code_notes),
                          flg_time                  => l_monitorization_row.flg_time,
                          INTERVAL                  => NULL,
                          interval_final            => l_monitorization_row.interval,
                          id_vs                     => table_number(),
                          notes_detail              => NULL,
                          flg_status                => l_monitorization_row.flg_status,
                          flg_status_det            => l_monitorization_row.flg_status,
                          id_order_type             => l_id_order_type,
                          id_prof_order             => NULL,
                          flg_monitorization_action => pk_monitorization.g_order_action);
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'INIT_MONIT',
                                              o_error);
            RETURN FALSE;
    END init_monit;

    /******************************************************************************
       OBJECTIVO:   Cancelar requisição de monitorização de sinais vitais
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION  - ID da requisicao
                     I_PROF - Profissional que faz o cancelamento
                 I_NOTES - Notas de cancelamento
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           como é retornada em PK_LOGIN.GET_PROF_PREF
                  I_COMMIT_DATA - Flag que indica se a função deve fazer o commit dos dados
              Saida:  O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
    *********************************************************************************/
    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_prof              IN profissional,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_commit_data       IN VARCHAR2,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message     debug_msg;
        l_old_status  monitorization.flg_status%TYPE;
        l_episode     monitorization.id_episode%TYPE;
        l_commit_data BOOLEAN;
        l_char        VARCHAR2(1);
        l_found       BOOLEAN := TRUE;
        l_error_in    t_error_in := t_error_in();
        l_rowsid      table_varchar := table_varchar();
        io_monit      monit;
        -- Alert® Data Governance
        l_rowids table_varchar;
    
        CURSOR c_monitor IS
            SELECT flg_status, id_episode
              FROM monitorization
             WHERE id_monitorization = i_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini);
    
        CURSOR c_monitor_vs IS
            SELECT id_monitorization_vs
              FROM monitorization_vs
             WHERE id_monitorization = i_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini);
    
        CURSOR c_monitorization_exe(c_id_monitorization_vs monitorization_vs.id_monitorization_vs%TYPE) IS
            SELECT 'x'
              FROM monitorization_vs_plan mp
             WHERE mp.id_monitorization_vs = c_id_monitorization_vs
               AND mp.flg_status = pk_alert_constant.g_monitor_vs_fini;
    
        rec_record    sys_alert_event%ROWTYPE;
        l_rowsid_m    table_varchar := table_varchar();
        l_rowsid_plan table_varchar := table_varchar();
    BEGIN
        l_commit_data := NOT (i_commit_data = pk_alert_constant.g_no);
    
        --verifica se a requisição pode ser cancelada. Para isso, não pode estar já cancelada ou então ter detalhes com resultados
        l_message := 'GET OLD STATUS';
        OPEN c_monitor;
        FETCH c_monitor
            INTO l_old_status, l_episode;
        l_found := c_monitor%FOUND;
        CLOSE c_monitor;
    
        IF NOT l_found
        THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M001',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'CANCEL_MONITOR_REQ',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               'U');
            RETURN pk_alert_exceptions.process_error(l_error_in, o_error);
        END IF;
    
        --Cancela requisição e todos os detalhes
        l_message := 'UPDATE MONITORIZATION STATUS';
        ts_monitorization.upd(id_monitorization_in => i_id_monitorization,
                              flg_status_in        => CASE
                                                          WHEN l_found
                                                               AND l_old_status != pk_alert_constant.g_monitor_vs_draft THEN
                                                           pk_alert_constant.g_monitor_vs_inte
                                                          ELSE
                                                           pk_alert_constant.g_monitor_vs_canc
                                                      END,
                              dt_cancel_tstz_in    => l_sysdate_tstz,
                              id_prof_cancel_in    => i_prof.id,
                              notes_cancel_in      => i_notes,
                              notes_cancel_nin     => FALSE,
                              rows_out             => l_rowsid);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        --CO-SIGN Cancellation workflow
        l_message := 'CREATE MONIT OBJECT';
        IF NOT init_monit(i_lang              => i_lang,
                          i_prof              => i_prof,
                          i_id_monitorization => i_id_monitorization,
                          io_monit            => io_monit,
                          o_error             => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        
        END IF;
    
        l_message                          := 'CALL SET_CO_SIGN_CANCELATION_WF';
        io_monit.flg_monitorization_action := pk_monitorization.g_cancel_action;
        IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        --Cancela todos os detalhes ainda não cancelados
        FOR i IN c_monitor_vs
        LOOP
            l_message := 'open c_monitorization_exe ';
            OPEN c_monitorization_exe(i.id_monitorization_vs);
            FETCH c_monitorization_exe
                INTO l_char;
            l_found := c_monitorization_exe%FOUND;
            CLOSE c_monitorization_exe;
        
            IF l_found
            THEN
                --Cancela requisição e todos os detalhes
                l_message := 'UPDATE MONITORIZATION STATUS';
                ts_monitorization.upd(id_monitorization_in => i_id_monitorization,
                                      flg_status_in        => pk_alert_constant.g_monitor_vs_inte,
                                      dt_cancel_tstz_in    => l_sysdate_tstz,
                                      id_prof_cancel_in    => i_prof.id,
                                      notes_cancel_in      => i_notes,
                                      notes_cancel_nin     => FALSE,
                                      rows_out             => l_rowsid_m);
            END IF;
        
            l_message := 'UPDATE MONITORIZATION_VS';
            ts_monitorization_vs.upd(id_monitorization_vs_in => i.id_monitorization_vs,
                                     flg_status_in           => CASE
                                                                    WHEN l_old_status != pk_alert_constant.g_monitor_vs_draft THEN
                                                                     pk_alert_constant.g_monitor_vs_inte
                                                                    ELSE
                                                                     pk_alert_constant.g_monitor_vs_canc
                                                                END,
                                     dt_cancel_tstz_in       => l_sysdate_tstz,
                                     id_prof_cancel_in       => i_prof.id,
                                     notes_cancel_in         => i_notes,
                                     notes_cancel_nin        => FALSE,
                                     id_cancel_reason_in     => i_id_cancel_reason,
                                     id_cancel_reason_nin    => FALSE,
                                     rows_out                => l_rowids);
        
            l_message := 'UPDATE MONITORIZATION_VS_PLAN';
            ts_monitorization_vs_plan.upd(flg_status_in => pk_alert_constant.g_monitor_vs_canc,
                                          where_in      => 'ID_MONITORIZATION_VS = ' || i.id_monitorization_vs ||
                                                           ' AND FLG_STATUS != ''' ||
                                                           pk_alert_constant.g_monitor_vs_fini || '''',
                                          rows_out      => l_rowsid_plan);
        
            rec_record.id_sys_alert    := c_id_sys_alert_vital_sign;
            rec_record.id_software     := i_prof.software;
            rec_record.id_institution  := i_prof.institution;
            rec_record.id_professional := i_prof.id;
            rec_record.id_episode      := l_episode;
            rec_record.id_record       := i.id_monitorization_vs;
        
            l_message := 'CALL pk_alerts.delete_sys_alert_event';
            IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => rec_record,
                                                    o_error           => o_error)
            THEN
                IF l_commit_data
                THEN
                    pk_utils.undo_changes;
                END IF;
                RETURN FALSE;
            END IF;
        
        END LOOP;
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid_m,
                                      o_error      => o_error);
    
        -- Alert® Data Governance
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        l_message := 'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        IF l_commit_data
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
    END cancel_monitor_req;

    /******************************************************************************
       OBJECTIVO:   Cancelar requisição de monitorização de sinais vitais
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION  - ID da requisicao
                     I_PROF - Profissional que faz o cancelamento
                 I_NOTES - Notas de cancelamento
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           como é retornada em PK_LOGIN.GET_PROF_PREF
                  I_COMMIT_DATA - Flag que indica se a função deve fazer o commit dos dados
                  I_ID_CANCEL_REASON - Id da cancel reason associada
                  I_PROF_ORDERED - Profissional que ordenou oI_PROF_ORDERED
                  I_DT_ORDERED - Data em que ordernou
      I_DT_ORDEREDI_ORDER_TYPE - Qual o tipo de ordem - order type id
              Saida:  O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
    *********************************************************************************/
    FUNCTION cancelmonitorreq
    (
        i_lang              IN language.id_language%TYPE,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_prof              IN profissional,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_commit_data       IN VARCHAR2,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        i_prof_order        IN co_sign.id_prof_ordered_by%TYPE,
        i_dt_order          IN co_sign.dt_ordered_by%TYPE,
        i_order_type        IN order_type.id_order_type%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message     debug_msg;
        l_old_status  monitorization.flg_status%TYPE;
        l_episode     monitorization.id_episode%TYPE;
        l_commit_data BOOLEAN;
        l_char        VARCHAR2(1);
        l_found       BOOLEAN := TRUE;
        l_error_in    t_error_in := t_error_in();
        l_rowsid      table_varchar := table_varchar();
        io_monit      monit;
        -- Alert® Data Governance
        l_rowids   table_varchar;
        l_rowsid_m table_varchar := table_varchar();
        CURSOR c_monitor IS
            SELECT flg_status, id_episode
              FROM monitorization
             WHERE id_monitorization = i_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini);
    
        CURSOR c_monitor_vs IS
            SELECT id_monitorization_vs
              FROM monitorization_vs
             WHERE id_monitorization = i_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini);
    
        CURSOR c_monitorization_exe(c_id_monitorization_vs monitorization_vs.id_monitorization_vs%TYPE) IS
            SELECT 'x'
              FROM monitorization_vs_plan mp
             WHERE mp.id_monitorization_vs = c_id_monitorization_vs
               AND mp.flg_status = pk_alert_constant.g_monitor_vs_fini;
    
        rec_record    sys_alert_event%ROWTYPE;
        l_rowsid_plan table_varchar := table_varchar();
    BEGIN
        l_commit_data := NOT (i_commit_data = pk_alert_constant.g_no);
    
        --verifica se a requisição pode ser cancelada. Para isso, não pode estar já cancelada ou então ter detalhes com resultados
        l_message := 'GET OLD STATUS';
        OPEN c_monitor;
        FETCH c_monitor
            INTO l_old_status, l_episode;
        l_found := c_monitor%FOUND;
        CLOSE c_monitor;
    
        IF NOT l_found
        THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M001',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'CANCEL_MONITOR_REQ',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               'U');
            RETURN pk_alert_exceptions.process_error(l_error_in, o_error);
        END IF;
    
        --Cancela requisição e todos os detalhes
        l_message := 'UPDATE MONITORIZATION STATUS';
        ts_monitorization.upd(id_monitorization_in => i_id_monitorization,
                              flg_status_in        => pk_alert_constant.g_monitor_vs_canc,
                              dt_cancel_tstz_in    => l_sysdate_tstz,
                              id_prof_cancel_in    => i_prof.id,
                              notes_cancel_in      => i_notes,
                              notes_cancel_nin     => FALSE,
                              rows_out             => l_rowsid);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        --CO-SIGN Cancellation workflow
        l_message := 'CREATE MONIT OBJECT';
        IF NOT init_monit(i_lang              => i_lang,
                          i_prof              => i_prof,
                          i_id_monitorization => i_id_monitorization,
                          io_monit            => io_monit,
                          o_error             => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        l_message                          := 'CALL SET_CO_SIGN_CANCELATION_WF';
        io_monit.id_prof_order             := i_prof_order;
        io_monit.dt_order_str              := get_str_date(i_lang, i_prof, i_dt_order);
        io_monit.id_order_type             := i_order_type;
        io_monit.flg_monitorization_action := pk_monitorization.g_cancel_action;
        IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        --Cancela todos os detalhes ainda não cancelados
        FOR i IN c_monitor_vs
        LOOP
            l_message := 'open c_monitorization_exe ';
            OPEN c_monitorization_exe(i.id_monitorization_vs);
            FETCH c_monitorization_exe
                INTO l_char;
            l_found := c_monitorization_exe%FOUND;
            CLOSE c_monitorization_exe;
        
            IF l_found
            THEN
                --Cancela requisição e todos os detalhes
                l_message := 'UPDATE MONITORIZATION STATUS';
                ts_monitorization.upd(id_monitorization_in => i_id_monitorization,
                                      flg_status_in        => pk_alert_constant.g_monitor_vs_inte,
                                      dt_cancel_tstz_in    => l_sysdate_tstz,
                                      id_prof_cancel_in    => i_prof.id,
                                      notes_cancel_in      => i_notes,
                                      notes_cancel_nin     => FALSE,
                                      rows_out             => l_rowsid_m);
            END IF;
        
            l_message := 'UPDATE MONITORIZATION_VS';
            ts_monitorization_vs.upd(id_monitorization_vs_in => i.id_monitorization_vs,
                                     flg_status_in           => CASE
                                                                    WHEN l_found THEN
                                                                     pk_alert_constant.g_monitor_vs_inte
                                                                    ELSE
                                                                     pk_alert_constant.g_monitor_vs_canc
                                                                END,
                                     dt_cancel_tstz_in       => l_sysdate_tstz,
                                     id_prof_cancel_in       => i_prof.id,
                                     notes_cancel_in         => i_notes,
                                     notes_cancel_nin        => FALSE,
                                     id_cancel_reason_in     => i_id_cancel_reason,
                                     id_cancel_reason_nin    => FALSE,
                                     rows_out                => l_rowids);
        
            l_message := 'UPDATE MONITORIZATION_VS_PLAN';
            ts_monitorization_vs_plan.upd(flg_status_in => pk_alert_constant.g_monitor_vs_canc,
                                          where_in      => 'ID_MONITORIZATION_VS = ' || i.id_monitorization_vs ||
                                                           ' AND FLG_STATUS != ''' ||
                                                           pk_alert_constant.g_monitor_vs_fini || '''',
                                          rows_out      => l_rowsid_plan);
        
            rec_record.id_sys_alert    := c_id_sys_alert_vital_sign;
            rec_record.id_software     := i_prof.software;
            rec_record.id_institution  := i_prof.institution;
            rec_record.id_professional := i_prof.id;
            rec_record.id_episode      := l_episode;
            rec_record.id_record       := i.id_monitorization_vs;
        
            l_message := 'CALL pk_alerts.delete_sys_alert_event';
            IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => rec_record,
                                                    o_error           => o_error)
            THEN
                IF l_commit_data
                THEN
                    pk_utils.undo_changes;
                END IF;
                RETURN FALSE;
            END IF;
        
        END LOOP;
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid_m,
                                      o_error      => o_error);
    
        -- Alert® Data Governance
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        l_message := 'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
        END IF;
    
        IF l_commit_data
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
            RETURN FALSE;
    END cancelmonitorreq;

    /**********************************************************************************************
    * cancel monitorization and vital signs with commit as (Y)es
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   profissional type
    * @param i_id_monitorization      monitorization id
    * @param i_notes                  notes for cancel
    * @param i_prof_cat_type          profissional category internal flag
    * @param i_id_cancel_reason       cancel reason identifier
    * @param i_prof_ordered           Professional that i_prof_orderede monit
    * @param i_dt_ordered             Timestamp that was ordered ted monit
    * @param i_order_type             Type of order identifier
     *@param i_commit_data            Indicates if commit is to be done Y/N
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Pedro Fernandes
    * @version                        2.6.5.0.1
    * @since                          2015/04/22
    **********************************************************************************************/

    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN table_number,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        i_prof_ordered      IN co_sign.id_prof_ordered_by%TYPE,
        i_dt_ordered        IN VARCHAR2,
        i_order_type        IN order_type.id_order_type%TYPE,
        i_commit_data       IN VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_message     debug_msg;
        l_commit_data BOOLEAN;
        l_func_name   VARCHAR2(100 CHAR) := 'CANCEL_MONITOR_REQ';
    BEGIN
    
        FOR i IN 1 .. i_id_monitorization.count
        LOOP
            l_message := 'call cancel_monitor_req:' || i_id_monitorization(i) || 'i_prof_ordered:' || i_prof_ordered ||
                         'i_order_type:' || i_order_type;
            pk_alertlog.log_debug(text => l_message, object_name => c_package_name, sub_object_name => l_func_name);
            IF NOT
                cancelmonitorreq(i_lang              => i_lang,
                                 i_id_monitorization => i_id_monitorization(i),
                                 i_prof              => i_prof,
                                 i_notes             => i_notes,
                                 i_prof_cat_type     => i_prof_cat_type,
                                 i_commit_data       => i_commit_data,
                                 i_id_cancel_reason  => i_id_cancel_reason,
                                 i_prof_order        => i_prof_ordered,
                                 i_dt_order          => pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_ordered, NULL),
                                 i_order_type        => i_order_type,
                                 o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END cancel_monitor_req;

    /**********************************************************************************************
    * cancel monitorization and vital signs with commit as (Y)es
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   profissional type
    * @param i_id_monitorization      monitorization id
    * @param i_notes                  notes for cancel
    * @param i_prof_cat_type          profissional category internal flag
    * @param i_id_cancel_reason       cancel reason identifier
    * @param i_prof_ordered           Professional that i_prof_orderede monit
    * @param i_dt_ordered             Timestamp that was ordered ted monit
    * @param i_order_type             Type of order identifier
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/26
    **********************************************************************************************/

    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN table_number,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        i_prof_ordered      IN co_sign.id_prof_ordered_by%TYPE,
        i_dt_ordered        IN VARCHAR2,
        i_order_type        IN order_type.id_order_type%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_message   debug_msg;
        l_func_name VARCHAR2(100 CHAR) := 'CANCEL_MONITOR_REQ';
    BEGIN
    
        FOR i IN 1 .. i_id_monitorization.count
        LOOP
            l_message := 'call cancel_monitor_req:' || i_id_monitorization(i) || 'i_prof_ordered:' || i_prof_ordered ||
                         'i_order_type:' || i_order_type;
            pk_alertlog.log_debug(text => l_message, object_name => c_package_name, sub_object_name => l_func_name);
            IF NOT
                cancelmonitorreq(i_lang              => i_lang,
                                 i_id_monitorization => i_id_monitorization(i),
                                 i_prof              => i_prof,
                                 i_notes             => i_notes,
                                 i_prof_cat_type     => i_prof_cat_type,
                                 i_commit_data       => pk_alert_constant.g_no,
                                 i_id_cancel_reason  => i_id_cancel_reason,
                                 i_prof_order        => i_prof_ordered,
                                 i_dt_order          => pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_ordered, NULL),
                                 i_order_type        => i_order_type,
                                 o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END LOOP;
    
        COMMIT;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END cancel_monitor_req;

    /**********************************************************************************************
    * cancel monitorization and vital signs with commit as (Y)es
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   profissional type
    * @param i_id_monitorization      monitorization id
    * @param i_notes                  notes for cancel
    * @param i_prof_cat_type          profissional category internal flag
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/26
    **********************************************************************************************/

    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN cancel_monitor_req(i_lang              => i_lang,
                                  i_id_monitorization => i_id_monitorization,
                                  i_prof              => i_prof,
                                  i_notes             => i_notes,
                                  i_prof_cat_type     => i_prof_cat_type,
                                  i_commit_data       => pk_alert_constant.g_yes,
                                  i_id_cancel_reason  => i_id_cancel_reason,
                                  o_error             => o_error);
    END cancel_monitor_req;
    /**********************************************************************************************
    * cancel monitorization and vital signs with commit as (Y)es
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   profissional type
    * @param i_id_monitorization      monitorization array id
    * @param i_notes                  notes for cancel
    * @param i_prof_cat_type          profissional category internal flag
    * @param o_error                  error message
    *
    * @return boolean                 true on success, otherwise false
    *
    * @author                         Filipe Machado
    * @version                        2.5.0.7.3
    * @since                          2009/11/26
    **********************************************************************************************/
    FUNCTION cancel_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN table_number,
        i_notes             IN monitorization.notes_cancel%TYPE,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_cancel_reason  IN cancel_reason.id_cancel_reason%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_message debug_msg;
    BEGIN
    
        FOR i IN 1 .. i_id_monitorization.count
        LOOP
            l_message := 'call cancel_monitor_req:' || i_id_monitorization(i);
            IF NOT cancel_monitor_req(i_lang              => i_lang,
                                      i_id_monitorization => i_id_monitorization(i),
                                      i_prof              => i_prof,
                                      i_notes             => i_notes,
                                      i_prof_cat_type     => i_prof_cat_type,
                                      i_commit_data       => pk_alert_constant.g_yes,
                                      i_id_cancel_reason  => i_id_cancel_reason,
                                      o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END cancel_monitor_req;
    /******************************************************************************
       OBJECTIVO:   Cancelar detalhe de requisição de monitorização de sinais vitais
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_ID_MONITORIZATION_VS - ID do detalhe da requisicao
                     I_PROF - Profissional que faz o cancelamento
                 I_NOTES - Notas de cancelamento
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           I_ID_CANCEL_REASON Cancel Reason ID
                           como é retornada em PK_LOGIN.GET_PROF_PREF
              Saida:  O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/20
      NOTAS:
    *********************************************************************************/
    FUNCTION cancel_monitor_vs_req
    (
        i_lang                 IN language.id_language%TYPE,
        i_id_monitorization_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_prof                 IN profissional,
        i_notes                IN monitorization_vs.notes_cancel%TYPE,
        i_prof_cat_type        IN category.flg_type%TYPE,
        i_id_cancel_reason     IN cancel_reason.id_cancel_reason%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message           debug_msg;
        l_old_status        monitorization_vs.flg_status%TYPE;
        l_id_monitorization monitorization.id_monitorization%TYPE;
        l_char              VARCHAR2(1);
        l_id_episode        episode.id_episode%TYPE;
        l_found             BOOLEAN := TRUE;
        l_error_in          t_error_in := t_error_in();
        g_exception EXCEPTION;
        l_rowsid_m table_varchar := table_varchar();
        -- Alert® Data Governance
        l_rowids table_varchar;
    
        CURSOR c_old_stat IS
            SELECT d.flg_status, d.id_monitorization, m.id_episode
              FROM monitorization_vs d, monitorization m
             WHERE d.id_monitorization_vs = i_id_monitorization_vs
               AND m.id_monitorization = d.id_monitorization;
        CURSOR c_monitorization_exe IS
            SELECT 'x'
              FROM monitorization_vs_plan mp
             WHERE mp.id_monitorization_vs = i_id_monitorization_vs
               AND mp.flg_status = pk_alert_constant.g_monitor_vs_fini;
    
        CURSOR c_canc(pin_id_monitorization monitorization_vs.id_monitorization%TYPE) IS
            SELECT 'X'
              FROM monitorization_vs
             WHERE id_monitorization = pin_id_monitorization
               AND flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_inte);
        l_rowsid_plan table_varchar := table_varchar();
    BEGIN
        --verifica qual o estado anterior
        l_message := 'GET OLD STATUS';
        OPEN c_old_stat;
        FETCH c_old_stat
            INTO l_old_status, l_id_monitorization, l_id_episode;
        l_found := c_old_stat%FOUND;
        CLOSE c_old_stat;
    
        IF NOT l_found
           OR l_old_status IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_fini)
        THEN
            l_error_in.set_all(i_lang,
                               'MONITOR_M001',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               l_message,
                               c_package_owner,
                               c_package_name,
                               'CANCEL_MONITOR_VS_REQ',
                               pk_message.get_message(i_lang, 'MONITOR_M001'),
                               'U');
            RETURN pk_alert_exceptions.process_error(l_error_in, o_error);
        END IF;
    
        l_message := 'OPEN C_MONITORIZATION_EXE';
        OPEN c_monitorization_exe;
        FETCH c_monitorization_exe
            INTO l_char;
        l_found := c_monitorization_exe%FOUND;
        CLOSE c_monitorization_exe;
    
        l_message := 'UPDATE MONITORIZATION_VS';
        ts_monitorization_vs.upd(id_monitorization_vs_in => i_id_monitorization_vs,
                                 flg_status_in           => CASE
                                                                WHEN l_found = TRUE THEN
                                                                 pk_alert_constant.g_monitor_vs_inte
                                                                ELSE
                                                                 pk_alert_constant.g_monitor_vs_canc
                                                            END,
                                 dt_cancel_tstz_in       => l_sysdate_tstz,
                                 id_prof_cancel_in       => i_prof.id,
                                 notes_cancel_in         => i_notes,
                                 id_cancel_reason_in     => i_id_cancel_reason,
                                 rows_out                => l_rowids);
    
        ts_monitorization_vs_plan.upd(flg_status_in => pk_alert_constant.g_monitor_vs_canc,
                                      where_in      => 'ID_MONITORIZATION_VS = ' || i_id_monitorization_vs ||
                                                       ' AND FLG_STATUS != ''' || pk_alert_constant.g_monitor_vs_fini || '''',
                                      rows_out      => l_rowsid_plan);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
    
        --Verificar se todos os detalhes estão cancelados e, se sim, cancela tb o cabeçalho da requisição
        l_message := 'open c_canc ';
        OPEN c_canc(l_id_monitorization);
        FETCH c_canc
            INTO l_char;
        l_found := c_canc%FOUND;
        CLOSE c_canc;
    
        --Se o cursor não devolver registos, todos os detalhes estão cancelados e pode-se cancelar o cabeçalho
        IF NOT l_found
        THEN
            l_message := 'open c_monitorization_exe ';
            OPEN c_monitorization_exe;
            FETCH c_monitorization_exe
                INTO l_char;
            l_found := c_monitorization_exe%FOUND;
            CLOSE c_monitorization_exe;
        
            -- l_found = TRUE --> Interrompe requisição e todos os detalhes
            -- l_found = FALSE --> Cancela requisição e todos os detalhes
        
            l_message := 'UPDATE MONITORIZATION STATUS';
            ts_monitorization.upd(id_monitorization_in => l_id_monitorization,
                                  flg_status_in        => CASE
                                                              WHEN l_found = TRUE THEN
                                                               pk_alert_constant.g_monitor_vs_inte
                                                              ELSE
                                                               pk_alert_constant.g_monitor_vs_canc
                                                          END,
                                  dt_cancel_tstz_in    => l_sysdate_tstz,
                                  id_prof_cancel_in    => i_prof.id,
                                  notes_cancel_in      => i_notes,
                                  rows_out             => l_rowsid_m);
        
            l_message := 'CALL t_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION',
                                          i_rowids     => l_rowsid_m,
                                          o_error      => o_error);
        
            l_message := 'UPDATE MONITORIZATIONS_EA STATUS';
            -- the monitoring will be cancelled for all vital signs
            FOR c IN (SELECT mvs.id_monitorization_vs
                        FROM monitorization_vs mvs
                       WHERE mvs.id_monitorization = l_id_monitorization)
            LOOP
            
                ts_monitorizations_ea.upd(id_monitorization_vs_in => c.id_monitorization_vs,
                                          id_monitorization_in    => l_id_monitorization,
                                          flg_status_in           => CASE
                                                                         WHEN l_found = TRUE THEN
                                                                          pk_alert_constant.g_monitor_vs_inte
                                                                         ELSE
                                                                          pk_alert_constant.g_monitor_vs_canc
                                                                     END);
            
            END LOOP;
        END IF;
    
        -- Alert® Data Governance
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        l_message := 'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_id_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
    
        DELETE sys_alert_event sad
         WHERE sad.id_sys_alert = c_id_sys_alert_vital_sign;
    
        IF NOT create_alert_vital_sign(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       i_monitorization => l_id_monitorization,
                                       o_error          => o_error)
        THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
    
        pk_icnp_fo_api_db.set_sugg_status_cancel(i_lang         => i_lang,
                                                 i_prof         => i_prof,
                                                 i_request_id   => i_id_monitorization_vs,
                                                 i_task_type_id => pk_alert_constant.g_task_monitoring,
                                                 i_sysdate_tstz => current_timestamp);
    
        COMMIT;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_MONITOR_VS_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_monitor_vs_req;
    /**********************************************************************************************
    * Registo de SVs através da monitorização
    *
    * @param i_lang                   the id language
    * @param i_episode                episode id
    * @param i_prof                   professional, software and institution ids
    * @param i_pat                    patient id
    * @param i_vs_id                  array de IDs de SVs
    * @param i_vs_val                 array de valores lidos (valores registados no keypad, ou ID do descritivo)
    * @param i_id_monit               monitorization id
    * @param i_dt_plan_str            data da próxima leitura. Pode vir NULL, se o keypad ñ for usado.
    * @param i_prof_cat_type          category of professional
    * @param i_prof_performed         professional performed
    * @param i_start_time             start time of execution intervention
    * @param i_end_time               end time of execution intervention
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Claudia Silva
    * @version                        1.0 
    * @since                          2005/07/28
    **********************************************************************************************/
    FUNCTION set_monitor_vs_read
    (
        i_lang               IN language.id_language%TYPE,
        i_episode            IN vital_sign_read.id_episode%TYPE,
        i_prof               IN profissional,
        i_pat                IN vital_sign_read.id_patient%TYPE,
        i_vs_id              IN table_number,
        i_vs_val             IN table_number,
        i_unit_meas          IN table_number,
        i_vs_scales_elements IN table_number,
        i_dt_vs_read         IN table_varchar,
        i_id_monit           IN monitorization.id_monitorization%TYPE,
        i_dt_plan_str        IN VARCHAR2,
        i_prof_cat_type      IN category.flg_type%TYPE,
        i_prof_performed     IN monitorization_vs_plan.id_prof_performed%TYPE,
        i_start_time         IN VARCHAR2,
        i_end_time           IN VARCHAR2,
        i_unit_meas_sel      IN table_number,
        i_tbtb_attribute     IN table_table_number,
        i_tbtb_free_text     IN table_table_clob,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message debug_msg;
    
        TYPE monit_vs_read IS RECORD(
            id_mon_vs      monitorization_vs.id_monitorization_vs%TYPE,
            id_mon_vs_plan monitorization_vs_plan.id_monitorization_vs_plan%TYPE);
    
        TYPE mvs IS TABLE OF monit_vs_read INDEX BY BINARY_INTEGER;
    
        -- Alert® Data Governance
        l_rowids_aux   table_varchar;
        l_rowids       table_varchar := table_varchar();
        l_monit_rowids table_varchar := table_varchar();
    
        l_interval             monitorization.interval%TYPE;
        l_id_vs_plan           monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_id_mvs               monitorization_vs.id_monitorization_vs%TYPE;
        l_flg_status           monitorization_vs_plan.flg_status%TYPE;
        l_flg_status_monit     monitorization.flg_status%TYPE;
        l_id_monitorization_vs monitorization_vs.id_monitorization_vs%TYPE;
        l_dt                   TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_aux               TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_begin             monitorization.dt_begin_tstz%TYPE;
        l_start_time           TIMESTAMP WITH LOCAL TIME ZONE;
        l_end_time             TIMESTAMP WITH LOCAL TIME ZONE;
        l_ret                  BOOLEAN;
        l_error_in             t_error_in := t_error_in();
    
        CURSOR c_plan(i_vs IN monitorization_vs.id_vital_sign%TYPE) IS
            SELECT INTERVAL,
                   mp.id_monitorization_vs_plan,
                   mvs.id_monitorization_vs,
                   mp.flg_status,
                   mvs.id_monitorization_vs,
                   m.flg_time,
                   m.flg_status flg_status_monit
              FROM monitorization m, monitorization_vs mvs, monitorization_vs_plan mp, vital_sign_relation vr
             WHERE m.id_monitorization = i_id_monit
               AND mvs.id_monitorization = m.id_monitorization
               AND mp.id_monitorization_vs = mvs.id_monitorization_vs
               AND mp.flg_status IN (pk_alert_constant.g_monitor_vs_exec,
                                     pk_alert_constant.g_monitor_vs_pend,
                                     pk_alert_constant.g_monitor_vs_expire)
               AND (mvs.id_vital_sign = i_vs OR
                   (vr.id_vital_sign_detail = i_vs AND
                   vr.relation_domain IN (pk_alert_constant.g_vs_rel_sum, pk_alert_constant.g_vs_rel_conc)))
               AND vr.id_vital_sign_parent(+) = mvs.id_vital_sign;
    
        CURSOR c_dt IS
            SELECT l_dt_begin, dt_end_tstz
              FROM monitorization
             WHERE id_monitorization = i_id_monit;
    
        rec_record sys_alert_event%ROWTYPE;
        --
        mon_vs       mvs;
        k            NUMBER := 0;
        l_update     BOOLEAN;
        l_mvs_plan   monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_time       monitorization.flg_time%TYPE;
        i_dt_plan    TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_vs_read vital_sign_read.dt_vital_sign_read_tstz%TYPE;
    
        l_monitorization_vs_list table_number := table_number();
        l_monit_vs_list_cnt      PLS_INTEGER;
    
        l_vital_sign_read table_number := table_number();
        l_tbtb_attribute  table_table_number := table_table_number();
        l_tbtb_free_text  table_table_clob := table_table_clob();
        l_dt_registry     VARCHAR2(4000);
        l_rowsid          table_varchar := table_varchar();
    BEGIN
        rec_record.id_sys_alert    := c_id_sys_alert_vital_sign;
        rec_record.id_software     := i_prof.software;
        rec_record.id_institution  := i_prof.institution;
        rec_record.id_professional := i_prof.id;
        rec_record.id_record       := NULL;
        rec_record.id_episode      := i_episode;
    
        --
        i_dt_plan    := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_plan_str, NULL);
        l_start_time := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_time, NULL);
        l_end_time   := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_time, NULL);
        --
    
        FOR i IN 1 .. i_vs_id.count
        LOOP
            -- Loop sobre o array de IDs de SVs lidos
            l_message := 'OPEN c_plan';
            OPEN c_plan(i_vs_id(i));
            FETCH c_plan
                INTO l_interval,
                     l_id_vs_plan,
                     l_id_mvs,
                     l_flg_status,
                     l_id_monitorization_vs,
                     l_time,
                     l_flg_status_monit;
            CLOSE c_plan;
            --        
            IF pk_sysconfig.get_config('REQ_NEXT_DAY', i_prof) = 'N'
            THEN
                IF l_time = pk_alert_constant.g_flg_time_e
                   AND trunc(nvl(i_dt_plan, l_sysdate_tstz)) != trunc(l_sysdate_tstz)
                THEN
                    l_error_in.set_all(i_lang,
                                       'MONITOR_M001',
                                       pk_message.get_message(i_lang, 'MONITOR_M003'),
                                       l_message,
                                       c_package_owner,
                                       c_package_name,
                                       'SET_MONITOR_VS_READ',
                                       pk_message.get_message(i_lang, 'MONITOR_M003'),
                                       'U');
                    l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                    pk_alert_exceptions.reset_error_state;
                    RETURN FALSE;
                END IF;
            END IF;
            --        
            l_mvs_plan := NULL;
            l_update   := TRUE;
        
            IF k != 0
            THEN
                FOR j IN 1 .. k
                LOOP
                    IF mon_vs(j).id_mon_vs = l_id_mvs
                    THEN
                        -- Esta req monit já passou
                        l_update   := FALSE;
                        l_mvs_plan := mon_vs(j).id_mon_vs_plan;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        
            IF l_update
            THEN
                --
                l_message := 'OPEN c_dt';
                OPEN c_dt;
                FETCH c_dt
                    INTO l_dt_begin, l_dt;
                CLOSE c_dt;
                --
            
                l_message := 'UPDATE monitorization_vs_plan';
                ts_monitorization_vs_plan.upd(id_monitorization_vs_plan_in => l_id_vs_plan,
                                              flg_status_in                => CASE
                                                                                  WHEN l_flg_status_monit =
                                                                                       pk_alert_constant.g_monitor_vs_expire THEN
                                                                                   pk_alert_constant.g_monitor_vs_expire
                                                                                  ELSE
                                                                                   pk_alert_constant.g_monitor_vs_fini
                                                                              END,
                                              id_prof_performed_in         => i_prof_performed,
                                              start_time_in                => l_start_time,
                                              end_time_in                  => l_end_time,
                                              rows_out                     => l_rowids);
            
                IF l_flg_status = pk_alert_constant.g_monitor_vs_pend
                THEN
                    l_message := 'UPDATE monitorization_vs(1)';
                    ts_monitorization_vs.upd(id_monitorization_vs_in => l_id_monitorization_vs,
                                             flg_status_in           => CASE
                                                                            WHEN l_flg_status_monit =
                                                                                 pk_alert_constant.g_monitor_vs_expire THEN
                                                                             pk_alert_constant.g_monitor_vs_expire
                                                                            ELSE
                                                                             pk_alert_constant.g_monitor_vs_exec
                                                                        END,
                                             rows_out                => l_rowsid);
                    l_monitorization_vs_list.extend;
                    l_monitorization_vs_list(l_monitorization_vs_list.last) := l_id_monitorization_vs;
                
                END IF;
            
                --If Expired doesn't do anything
                IF l_flg_status_monit <> pk_alert_constant.g_monitor_vs_expire
                THEN
                
                    l_dt_aux := nvl(i_dt_plan, l_sysdate_tstz + numtodsinterval(nvl(l_interval, 0), 'SECOND'));
                
                    IF l_dt IS NULL
                       OR l_dt >= l_dt_aux
                    THEN
                        l_message := 'INSERT monitorization_vs_plan(1)';
                        ts_monitorization_vs_plan.ins(id_monitorization_vs_in => l_id_mvs,
                                                      dt_plan_tstz_in         => l_dt_aux,
                                                      flg_status_in           => CASE
                                                                                     WHEN l_dt_aux <= l_sysdate_tstz THEN
                                                                                      pk_alert_constant.g_monitor_vs_exec
                                                                                     ELSE
                                                                                      pk_alert_constant.g_monitor_vs_pend
                                                                                 END,
                                                      rows_out                => l_rowids_aux);
                        l_rowids := l_rowids MULTISET UNION DISTINCT l_rowids_aux;
                    
                        IF l_flg_status_monit = pk_alert_constant.g_monitor_vs_pend
                        THEN
                            l_message := 'UPDATE monitorization to under going';
                            ts_monitorization.upd(id_monitorization_in => i_id_monit,
                                                  flg_status_in        => pk_alert_constant.g_monitor_vs_exec,
                                                  rows_out             => l_monit_rowids);
                        
                            l_message := 'CALL t_data_gov_mnt.process_update - MONITORIZATION';
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'MONITORIZATION',
                                                          i_rowids     => l_monit_rowids,
                                                          o_error      => o_error);
                        END IF;
                    
                    ELSE
                    
                        l_message := 'UPDATE monitorization(2)';
                        ts_monitorization.upd(id_monitorization_in => i_id_monit,
                                              flg_status_in        => pk_alert_constant.g_monitor_vs_fini,
                                              rows_out             => l_monit_rowids);
                    
                        l_message := 'CALL t_data_gov_mnt.process_update - MONITORIZATION';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'MONITORIZATION',
                                                      i_rowids     => l_monit_rowids,
                                                      o_error      => o_error);
                    
                        l_message := 'UPDATE monitorization_vs(2)';
                        ts_monitorization_vs.upd(id_monitorization_vs_in => l_id_monitorization_vs,
                                                 flg_status_in           => pk_alert_constant.g_monitor_vs_fini);
                    
                        l_monitorization_vs_list.extend;
                        l_monitorization_vs_list(l_monitorization_vs_list.last) := l_id_monitorization_vs;
                    
                    END IF;
                    --
                END IF;
                k := k + 1;
                mon_vs(k).id_mon_vs := l_id_mvs;
                mon_vs(k).id_mon_vs_plan := l_id_vs_plan;
            END IF;
        
            l_message := 'GET DT_VS_READ';
            IF i_dt_vs_read.count > 0
               AND i_dt_vs_read(i) IS NOT NULL
            THEN
                l_dt_vs_read := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                              i_prof      => i_prof,
                                                              i_timestamp => i_dt_vs_read(i),
                                                              i_timezone  => NULL);
            ELSE
                l_dt_vs_read := l_sysdate_tstz;
            
            END IF;
        
            IF i_tbtb_attribute.exists(i)
               AND i_tbtb_free_text.exists(i)
            THEN
                l_tbtb_attribute := table_table_number(i_tbtb_attribute(i));
                l_tbtb_free_text := table_table_clob(i_tbtb_free_text(i));
            ELSE
                l_tbtb_attribute := table_table_number();
                l_tbtb_free_text := table_table_clob();
            END IF;
        
            --
            l_message := 'CALL pk_vital_sign.set_epis_vital_sign';
            IF NOT pk_vital_sign.set_epis_vital_sign(i_lang               => i_lang,
                                                     i_episode            => i_episode,
                                                     i_prof               => i_prof,
                                                     i_pat                => i_pat,
                                                     i_vs_id              => table_number(i_vs_id(i)),
                                                     i_vs_val             => table_number(i_vs_val(i)),
                                                     i_id_monit           => nvl(l_mvs_plan, l_id_vs_plan),
                                                     i_unit_meas          => table_number(i_unit_meas(i)),
                                                     i_vs_scales_elements => table_number(i_vs_scales_elements(i)),
                                                     i_notes              => NULL,
                                                     i_prof_cat_type      => i_prof_cat_type,
                                                     i_dt_vs_read         => table_varchar(pk_date_utils.date_send_tsz(i_lang,
                                                                                                                       l_dt_vs_read,
                                                                                                                       i_prof)),
                                                     i_epis_triage        => NULL,
                                                     i_unit_meas_convert  => table_number(nvl(i_unit_meas_sel(i),
                                                                                              i_unit_meas(i))),
                                                     i_tbtb_attribute     => l_tbtb_attribute,
                                                     i_tbtb_free_text     => l_tbtb_free_text,
                                                     o_vital_sign_read    => l_vital_sign_read,
                                                     o_dt_registry        => l_dt_registry,
                                                     o_error              => o_error)
            THEN
                pk_alert_exceptions.reset_error_state;
                pk_utils.undo_changes;
                RETURN FALSE;
            END IF;
        
        END LOOP;
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        -- Alert® Data Governance
        l_message := 'CALL t_data_gov_mnt.process_insert';
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        l_message := 'CALL pk_visit.set_first_obs';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => i_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
        --
        l_monit_vs_list_cnt := l_monitorization_vs_list.count;
    
        FOR i IN 1 .. l_monit_vs_list_cnt
        LOOP
        
            rec_record.id_record := l_monitorization_vs_list(i);
        
            l_message := 'CALL pk_alerts.delete_sys_alert_event id_record: ' || l_monitorization_vs_list(i);
            pk_alertlog.log_debug(l_message);
            IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => rec_record,
                                                    o_error           => o_error)
            THEN
                pk_alert_exceptions.reset_error_state;
                pk_utils.undo_changes;
                RETURN FALSE;
            END IF;
        END LOOP;
    
        l_message := 'CALL pk_alerts.delete_sys_alert_event';
        IF NOT create_alert_vital_sign(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       i_monitorization => i_id_monit,
                                       o_error          => o_error)
        THEN
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
    
        -- Commit transactions
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'SET_MONITOR_VS_READ',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_monitor_vs_read;
    --    
    /******************************************************************************
       OBJECTIVO:   Obter lista de realizações
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
                   I_PROF - profissional que acede
              Saida: O_TIME - lista
             O_ERROR - erro
    
      CRIAÇÃO: CRS 2005/08/02
      NOTAS:
    *********************************************************************************/
    FUNCTION get_monit_time
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_time  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    
    BEGIN
        l_message := 'GET CURSOR';
        OPEN o_time FOR
            SELECT val,
                   desc_val,
                   decode(pk_sysconfig.get_config('FLG_TIME_E', i_prof.institution, i_prof.software),
                          val,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_default
              FROM sys_domain
             WHERE id_language = i_lang
               AND code_domain = c_domain_monit_time
               AND flg_available = pk_alert_constant.g_yes
             ORDER BY rank, desc_val;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONIT_TIME',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_time);
            RETURN FALSE;
    END get_monit_time;

    /******************************************************************************
       OBJECTIVO: Obter concatenação dos descritivos dos SVs requisitados numa monitorização
       PARAMETROS:  Entrada: I_LANG - Língua registada como preferência do profissional
               I_MONITORIZATION - ID da monitorização
                             I_PROF - profissional
                             i_flg_only_active - Y - Do not return cancelled registries. N - returns records in all status
              Saida: O_DESC - concatenação dos descritivos dos SVs
                         O_ERROR - erro
      CRIAÇÃO: CRS 2006/09/05
      NOTAS:
    *********************************************************************************/
    FUNCTION get_vs_desc
    (
        i_lang            IN language.id_language%TYPE,
        i_monitorization  IN monitorization.id_monitorization%TYPE,
        i_prof            IN profissional,
        i_flg_only_active IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN VARCHAR2 IS
        CURSOR c_vs IS
            SELECT pk_translation.get_translation(i_lang, vs.code_vital_sign) desc_vs
              FROM monitorization m, monitorization_vs mvs, vital_sign vs
             WHERE mvs.id_monitorization = m.id_monitorization
               AND m.id_monitorization = i_monitorization
               AND vs.id_vital_sign = mvs.id_vital_sign
               AND ((i_flg_only_active = pk_alert_constant.g_yes AND
                   mvs.flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc, pk_alert_constant.g_monitor_vs_inte)) OR
                   i_flg_only_active = pk_alert_constant.g_no)
             ORDER BY desc_vs;
        l_aux VARCHAR2(4000);
    
    BEGIN
        FOR r_vs IN c_vs
        LOOP
            IF nvl(l_aux, '#') = '#'
            THEN
                l_aux := r_vs.desc_vs;
            ELSE
                l_aux := l_aux || ', ' || r_vs.desc_vs;
            END IF;
        END LOOP;
    
        RETURN l_aux;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_vs_desc;
    --
    /**********************************************************************************************
    * Actualizar o episódio de origem na monitorização de sinais vitais bem como as respectivas tabelas de relação.
      Aquando a passagem de Urgência para Internamento será necessário actualizar o ID_EPISODE na monitorização de sinais vitais
      com o novo episódio (INP) e o ID_EPISODE_ORIGIN ficará com o episódio de urgência (EDIS)
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_prof_cat_type          category of professional
    * @param i_episode                episode id
    * @param i_new_episode            new episode id 
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2007/02/19
    **********************************************************************************************/
    FUNCTION update_monitorization
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_episode       IN episode.id_episode%TYPE,
        i_new_episode   IN episode.id_episode%TYPE,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        -- Alert® Data Governance
        l_where_clause VARCHAR2(1000);
        l_rowids_m     table_varchar := table_varchar();
    
    BEGIN
        l_message      := 'UPDATE MONITORIZATION - ID_EPISODE and ID_PREV_EPISODE';
        l_where_clause := 'ID_EPISODE = ' || i_episode || ' AND FLG_STATUS NOT IN (''' ||
                          pk_alert_constant.g_monitor_vs_canc || ''', ''' || pk_alert_constant.g_monitor_vs_fini ||
                          ''' )';
        ts_monitorization.upd(id_episode_in      => i_new_episode,
                              id_prev_episode_in => i_episode,
                              where_in           => l_where_clause,
                              rows_out           => l_rowids_m);
    
        -- Alert® Data Governance
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowids_m,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'UPDATE_MONITORIZATION',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END update_monitorization;

    /***********************************************************************************************
    *
    * From now on, these functions were cretead in the CPOE context
    
    ***********************************************************************************************/

    /**********************************************************************************************
    * validate the request of the monitorization
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_monit                  monitorization type
    *
    * @return      varchar2                 'Y' on success, otherwise 'N'
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/17
    **********************************************************************************************/
    FUNCTION validate_monitor_req2
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_monitorization IN monitorization.id_monitorization%TYPE
    ) RETURN VARCHAR2 IS
        l_error                t_error_out;
        l_monit                monit;
        l_flg_prof_need_cosign sys_domain.val%TYPE;
    
    BEGIN
        IF NOT init_monit(i_lang              => i_lang,
                          i_prof              => i_prof,
                          i_id_monitorization => i_monitorization,
                          io_monit            => l_monit,
                          o_error             => l_error)
        THEN
            RETURN pk_alert_constant.g_no;
        END IF;
    
        IF l_monit.flg_status != pk_alert_constant.g_monitor_vs_draft
        THEN
            RETURN pk_alert_constant.g_no;
        ELSE
            IF l_monit.id_co_sign_order IS NULL
            THEN
                -- check if prof needs co-sign
                IF pk_co_sign_api.check_prof_needs_cosign(i_lang                   => i_lang,
                                                          i_prof                   => i_prof,
                                                          i_episode                => l_monit.id_epis,
                                                          i_task_type              => pk_alert_constant.g_task_monitoring,
                                                          i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_add,
                                                          o_flg_prof_need_cosign   => l_flg_prof_need_cosign,
                                                          o_error                  => l_error)
                THEN
                    IF l_flg_prof_need_cosign = pk_alert_constant.g_yes
                    THEN
                        RETURN pk_alert_constant.g_yes;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        IF NOT (validate_monitor_req(i_lang, i_prof, l_monit, l_error))
        THEN
            RETURN pk_alert_constant.g_yes;
        ELSE
            RETURN pk_alert_constant.g_no;
        END IF;
    END validate_monitor_req2;

    /******************************************************************************************** 
    * initialize the arrays of the messages
    * 
    * @param       o_flg_conflict            array of draft conflicts indicators 
    * @param       o_msg_title               array of message titles 
    * @param       o_msg_text                array of message texts 
    * @param       o_button                  array of buttons to show   
    * 
    *         
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/20
    ********************************************************************************************/
    FUNCTION init_conflit_ret
    (
        o_flg_conflict IN OUT table_varchar,
        o_msg_title    IN OUT table_varchar,
        o_msg_text     IN OUT table_varchar,
        o_button       IN OUT table_varchar
    ) RETURN BOOLEAN IS
    BEGIN
        o_flg_conflict.extend;
        o_msg_title.extend;
        o_msg_text.extend;
        o_button.extend;
    
        RETURN TRUE;
    END init_conflit_ret;

    /******************************************************************************************** 
    * check conflicts upon created drafts (verify if drafts can be requested or not) 
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id  
    * @param       i_draft                   draft id 
    * @param       o_flg_conflict            array of draft conflicts indicators 
    * @param       o_msg_title               array of message titles 
    * @param       o_msg_text                array of message texts 
    * @param       o_button                  array of buttons to show (it can have more than one button) 
    * @param       o_error                   error message 
    * 
    * @value       o_flg_conflict            {*} 'Y' the draft has conflicts  
    *                                        {*} 'N' no conflicts found 
    *    
    * @value       o_button                  {*} 'N' NO button is displayed 
    *                                        {*} 'R' READ button is displayed    
    *                                        {*} 'C' CONFIRM button is displayed 
    *                                        {*} Example: 'NC' NO/CONFIRM buttons are displayed 
    *         
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/18
    ********************************************************************************************/
    FUNCTION check_drafts_conflicts
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_draft        IN table_number,
        o_flg_conflict OUT table_varchar,
        o_msg_title    OUT table_varchar,
        o_msg_text     OUT table_varchar,
        o_button       OUT table_varchar,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_monit monit;
    
    BEGIN
        o_flg_conflict := table_varchar();
        o_msg_title    := table_varchar();
        o_msg_text     := table_varchar();
        o_button       := table_varchar();
    
        FOR i IN 1 .. i_draft.count
        LOOP
        
            IF NOT init_monit(i_lang              => i_lang,
                              i_prof              => i_prof,
                              i_id_monitorization => i_draft(i),
                              io_monit            => l_monit,
                              o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            IF NOT init_conflit_ret(o_flg_conflict, o_msg_title, o_msg_text, o_button)
            THEN
                RAISE l_exception;
            END IF;
        
            IF NOT validate_monitor_req(i_lang, i_prof, l_monit, o_error)
            THEN
                --TODO: confirm this
                o_flg_conflict(i) := pk_alert_constant.g_yes;
                o_msg_title(i) := 'msg' || i; -- TODO: review this message
                o_msg_text(i) := o_error.err_desc;
                o_button(i) := 'R'; -- TODO: use pk_alert_constant
            ELSE
                --TODO: confirm this
                o_flg_conflict(i) := pk_alert_constant.g_no;
                o_msg_title(i) := NULL;
                o_msg_text(i) := NULL;
                o_button(i) := 'NC'; -- TODO: use pk_alert_constant
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'CHECK_DRAFTS_CONFLICTS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END check_drafts_conflicts;

    /**********************************************************************************************
    * create monitorization_vs
    *
    * @param   i_lang                   preferred language id for this professional
    * @param   i_prof                   professional type
    * @param   io_monit                 monitorization type
    * @param   o_next_id_mvs            monitorization_vs id
    * @param   o_rows_out               rows 
    * @param   o_error                  error message
    *
    * @return  boolean                  true on success, otherwise false
    *
    * @author                           Filipe Machado
    * @version                          2.5.0.7.3
    * @since                            2009/11/18
    **********************************************************************************************/
    FUNCTION create_monitor_vs
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_idx         IN NUMBER,
        io_monit      IN OUT NOCOPY monit,
        o_next_id_mvs OUT monitorization_vs.id_monitorization_vs%TYPE,
        o_rows_out    OUT table_varchar,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_rowids_aux table_varchar;
        next_id_mvs  monitorization_vs.id_monitorization_vs%TYPE;
    
    BEGIN
        -- Monitorization VS
        ts_monitorization_vs.ins(id_monitorization_vs_out     => next_id_mvs,
                                 dt_monitorization_vs_tstz_in => l_sysdate_tstz,
                                 id_monitorization_in         => io_monit.id_monit,
                                 id_vital_sign_in             => io_monit.id_vs(i_idx),
                                 flg_status_in                => io_monit.flg_status_det,
                                 dt_order_in                  => get_tstz_date(i_lang, i_prof, io_monit.dt_order_str),
                                 --  id_prof_order_in             => io_monit.id_prof_order,
                                 --  id_order_type_in             => io_monit.id_order_type,
                                 rows_out => l_rowids_aux);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids_aux,
                                      o_error      => o_error);
    
        o_rows_out    := l_rowids_aux;
        o_next_id_mvs := next_id_mvs;
    
        pk_translation.insert_translation_trs(i_lang   => i_lang,
                                              i_code   => g_trs_monit_vs_notes || next_id_mvs,
                                              i_desc   => io_monit.notes,
                                              i_module => 'MONITORIZATION_VS');
    
        RETURN TRUE;
    
    END create_monitor_vs;

    /**********************************************************************************************
    * create monitorization_vs_plan
    *
    * @param   i_lang                   preferred language id for this professional
    * @param   i_prof                   professional type
    * @param   io_monit                 monitorization type
    * @param   o_error                  error message
    *
    * @return  boolean                  true on success, otherwise false
    *
    * @author                           Filipe Machado
    * @version                          2.5.0.7.3
    * @since                            2009/11/18
    **********************************************************************************************/
    FUNCTION create_monitor_vs_plan
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        i_id_mvs IN monitorization_vs.id_monitorization_vs%TYPE,
        io_monit IN OUT NOCOPY monit,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dt_begin_final TIMESTAMP WITH LOCAL TIME ZONE;
        l_rowsid         table_varchar := table_varchar();
        l_status_ss      monitorization_vs_plan.flg_status%TYPE;
    
    BEGIN
        -- Monitorization Planning
        l_dt_begin_final := nvl(b1 => get_tstz_date(i_lang => i_lang,
                                                    i_prof => i_prof,
                                                    i_date => io_monit.dt_begin_final_str),
                                b2 => g_sysdate_tstz);
    
        l_status_ss := CASE io_monit.flg_status
                           WHEN pk_alert_constant.g_monitor_vs_draft THEN
                            pk_alert_constant.g_monitor_vs_draft
                           ELSE
                            CASE io_monit.flg_time
                                WHEN pk_alert_constant.g_flg_time_n THEN
                                 pk_alert_constant.g_monitor_vs_pend
                                ELSE
                                 CASE sign(extract(DAY FROM(l_dt_begin_final - g_sysdate_tstz)))
                                     WHEN 1 THEN
                                      pk_alert_constant.g_monitor_vs_pend
                                     ELSE
                                      pk_alert_constant.g_monitor_vs_exec
                                 END
                            END
                       END;
    
        ts_monitorization_vs_plan.ins(id_monitorization_vs_in => i_id_mvs,
                                      dt_plan_tstz_in         => l_dt_begin_final,
                                      flg_status_in           => l_status_ss,
                                      rows_out                => l_rowsid);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    END create_monitor_vs_plan;

    /**********************************************************************************************
    * create draft task (CPOE purpose)
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_episode                episode id
    * @param       io_monit                 monitorization type
    * @param       o_draft                  list of created drafts
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/17
    **********************************************************************************************/
    FUNCTION create_draft
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        io_monit  IN OUT NOCOPY monit,
        o_draft   OUT table_number,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        l_exception EXCEPTION;
        next_id_mvs monitorization_vs.id_monitorization_vs%TYPE;
    
        l_id_monitorization_vs_plan monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_rowsid_plan               table_varchar := table_varchar();
        l_rowids                    table_varchar;
        l_rowids_aux                table_varchar;
    
        l_flg_profile     profile_template.flg_profile%TYPE;
        l_sys_alert_event sys_alert_event%ROWTYPE;
    
    BEGIN
        IF NOT validate_monitor_req(i_lang, i_prof, io_monit, o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        l_flg_profile := nvl(pk_hand_off_core.get_flg_profile(i_lang, i_prof, NULL), '#');
    
        io_monit.flg_status     := pk_alert_constant.g_monitor_vs_draft;
        io_monit.flg_status_det := pk_alert_constant.g_monitor_vs_draft; --flg_status of the monitorization_vs
    
        l_message := 'CALL TO PK_MONITORIZATION.CREATE_DRAFT - create_monitor';
        IF NOT (create_monitor(i_lang, i_prof, io_monit, o_error))
        THEN
            RAISE l_exception;
        END IF;
    
        -- For the copy to draft action no co-sign will be generated, keeping this as a comment for a while
        --        l_message := 'CALL CREATE_CO_SIGN_TASK - CREATE CO-SIGN RECORD TO THE CURRENT MONIT';
        --create co-sign task
        --io_monit.flg_monitorization_action := pk_monitorization.g_draft_action;
        IF io_monit.flg_monitorization_action = pk_monitorization.g_draft_action
        THEN
            IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        FOR i IN 1 .. io_monit.id_vs.count
        LOOP
            l_message := 'CALL TO PK_MONITORIZATION.CREATE_DRAFT - ts_monitorization_vs.ins';
        
            -- Monitorization Vital Sign (monitorization_vs)
            IF NOT create_monitor_vs(i_lang, i_prof, i, io_monit, next_id_mvs, l_rowids_aux, o_error)
            THEN
                RAISE l_exception;
            ELSE
                l_rowids := l_rowids MULTISET UNION DISTINCT l_rowids_aux;
            END IF;
        
            -- Monitorization Planning (monitorization_vs_plan)
            IF NOT create_monitor_vs_plan(i_lang, i_prof, next_id_mvs, io_monit, o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            l_message := 'CALL TO PK_MONITORIZATION.CREATE_DRAFT - get id_monitorization_vs_plan';
            SELECT mp.id_monitorization_vs_plan
              INTO l_id_monitorization_vs_plan
              FROM monitorization_vs mvs
              JOIN monitorization_vs_plan mp
                ON mp.id_monitorization_vs = mvs.id_monitorization_vs
             WHERE mvs.id_monitorization_vs = next_id_mvs
               AND mvs.id_vital_sign = io_monit.id_vs(i);
        
            l_message := 'CALL TO PK_MONITORIZATION.CREATE_DRAFT - ts_monitorization_vs_plan.upd';
            ts_monitorization_vs_plan.upd(id_monitorization_vs_plan_in => l_id_monitorization_vs_plan,
                                          id_prof_performed_in         => i_prof.id,
                                          start_time_in                => current_timestamp,
                                          end_time_in                  => current_timestamp,
                                          rows_out                     => l_rowsid_plan);
        
        END LOOP;
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
        o_draft := table_number(io_monit.id_monit);
    
        IF l_flg_profile = pk_prof_utils.g_flg_profile_template_student
        THEN
            l_sys_alert_event.id_sys_alert    := pk_alert_constant.g_alert_cpoe_draft;
            l_sys_alert_event.id_software     := i_prof.software;
            l_sys_alert_event.id_institution  := i_prof.institution;
            l_sys_alert_event.id_episode      := io_monit.id_epis;
            l_sys_alert_event.id_patient      := pk_episode.get_epis_patient(i_lang    => i_lang,
                                                                             i_prof    => i_prof,
                                                                             i_episode => io_monit.id_epis);
            l_sys_alert_event.id_record       := io_monit.id_epis;
            l_sys_alert_event.id_visit        := pk_visit.get_visit(i_episode => io_monit.id_epis, o_error => o_error);
            l_sys_alert_event.dt_record       := current_timestamp;
            l_sys_alert_event.id_professional := pk_hand_off.get_episode_responsible(i_lang       => i_lang,
                                                                                     i_prof       => i_prof,
                                                                                     i_id_episode => io_monit.id_epis,
                                                                                     o_error      => o_error);
        
            IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => l_sys_alert_event,
                                                    o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CREATE_DRAFT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END create_draft;

    /**********************************************************************************************
    * create draft task (CPOE purpose)
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_episode                episode id
    * @param       ...                      monitorization 
    * @param       o_draft                  list of created drafts
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.5
    * @since                                2009/12/14
    **********************************************************************************************/
    FUNCTION create_draft
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN monitorization.id_episode%TYPE,
        i_dt_begin_str  IN VARCHAR2,
        i_interval      IN VARCHAR2,
        i_dt_end_str    IN VARCHAR2,
        i_notes         IN CLOB,
        i_flg_time      IN monitorization.flg_time%TYPE,
        i_id_vs         IN table_number,
        i_notes_detail  IN table_varchar,
        i_prof_cat_type IN category.flg_type%TYPE,
        i_prof_order    IN monitorization_vs.id_prof_order%TYPE := NULL,
        i_dt_order_str  IN VARCHAR2 := NULL,
        i_order_type    IN monitorization_vs.id_order_type%TYPE := NULL,
        o_draft         OUT table_number,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        io_monit monit;
        l_draft  table_number;
    
    BEGIN
        io_monit := monit(id_monit                  => NULL,
                          id_prof                   => i_prof.id,
                          id_inst                   => i_prof.institution,
                          id_soft                   => i_prof.software,
                          id_epis                   => i_episode,
                          notes                     => i_notes,
                          flg_time                  => i_flg_time,
                          dt_order_str              => i_dt_order_str,
                          dt_begin_str              => i_dt_begin_str,
                          dt_end_str                => i_dt_end_str,
                          dt_begin_final_str        => i_dt_begin_str,
                          INTERVAL                  => i_interval,
                          interval_final            => NULL,
                          id_vs                     => i_id_vs,
                          notes_detail              => i_notes_detail,
                          flg_status                => pk_alert_constant.g_monitor_vs_exec,
                          flg_status_det            => pk_alert_constant.g_monitor_vs_exec,
                          id_order_type             => i_order_type,
                          id_prof_order             => i_prof_order,
                          flg_monitorization_action => pk_monitorization.g_draft_action,
                          id_co_sign_order          => NULL,
                          id_co_sign_cancel         => NULL);
    
        IF NOT create_draft(i_lang    => i_lang,
                            i_prof    => i_prof,
                            i_episode => i_episode,
                            io_monit  => io_monit,
                            o_draft   => l_draft,
                            o_error   => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'CREATE_DRAFT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END create_draft;

    /**********************************************************************************************
    * cancel = delete a draft task (CPOE purpose)
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_episode                episode id
    * @param          i_draft                  list of draft ids
    * @param          o_error                  error message
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.3
    * @since                                   2009/11/17
    **********************************************************************************************/
    FUNCTION cancel_draft
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        i_draft   IN table_number,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message              debug_msg;
        l_id_monitorization_vs table_number;
    
    BEGIN
        FOR i IN 1 .. i_draft.count
        LOOP
            SELECT id_monitorization_vs
              BULK COLLECT
              INTO l_id_monitorization_vs
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = i_draft(i)
               AND mvs.flg_status = pk_alert_constant.g_monitor_vs_draft;
        
            FOR j IN 1 .. l_id_monitorization_vs.count
            LOOP
                l_message := 'CALL TO PK_MONITORIZATION.CANCEL_DRAFT - delete monitorization_vs_plan';
                ts_monitorization_vs_plan.del_mvsp_mvs_fk(id_monitorization_vs_in => l_id_monitorization_vs(j));
            END LOOP;
        
            l_message := 'CALL TO PK_MONITORIZATION.CANCEL_DRAFT - delete monitorization_vs';
            ts_monitorization_vs.del_mvs_mont_fk(id_monitorization_in => i_draft(i));
        
            l_message := 'CALL TO PK_MONITORIZATION.CANCEL_DRAFT - delete monitorization';
            ts_monitorization.del(id_monitorization_in => i_draft(i));
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_DRAFT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_draft;

    /**********************************************************************************************
    * get actions (CPOE purpose)
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_episode                episode id
    * @param       i_task_request           task request id (monitorization id)
    * @param       o_actions                actions cursor info 
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Filipe Machado
    * @version                              2.5.0.7.3
    * @since                                2009/11/18
    **********************************************************************************************/
    FUNCTION get_actions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_actions      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
    
        CURSOR c_monit IS
            SELECT m.flg_status, m.flg_time, m.dt_begin_tstz
              FROM monitorization m
             WHERE m.id_monitorization = i_task_request(1);
    
        l_flg_status    monitorization.flg_status%TYPE;
        l_flg_time      monitorization.flg_time%TYPE;
        l_dt_begin_tstz monitorization.dt_begin_tstz%TYPE;
    
        l_to_state            action.to_state%TYPE := NULL;
        l_allow_execs_expired VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
        l_to_state_exec       action.to_state%TYPE := 'E';
    
        l_ehr_access_area CONSTANT tl_task.ehr_access_area%TYPE := 'VS';
        l_permission VARCHAR2(1 CHAR) := pk_alert_constant.g_active;
    
        l_internal_error EXCEPTION;
    
        l_error VARCHAR2(2000);
        l_count NUMBER(12);
    BEGIN
    
        IF i_task_request.count = 1
        THEN
            OPEN c_monit;
            FETCH c_monit
                INTO l_flg_status, l_flg_time, l_dt_begin_tstz;
            CLOSE c_monit;
        
            l_error := 'CALL pk_ehr_access.check_area_create_permission';
            IF NOT pk_ehr_access.check_area_create_permission(i_lang    => i_lang,
                                                              i_prof    => i_prof,
                                                              i_episode => i_episode,
                                                              i_area    => l_ehr_access_area,
                                                              o_val     => l_permission,
                                                              o_error   => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            l_error               := 'CHECK EXEC PERMISSIONS';
            l_allow_execs_expired := check_exec_monit(i_lang              => i_lang,
                                                      i_prof              => i_prof,
                                                      i_episode           => i_episode,
                                                      i_id_monitorization => i_task_request(1),
                                                      i_flg_time          => l_flg_time,
                                                      i_flg_status        => l_flg_status,
                                                      i_dt_begin_tstz     => l_dt_begin_tstz,
                                                      i_flg_check_actions => pk_alert_constant.g_no);
        
            l_error := 'CHECK EXEC PERMISSIONS';
            IF l_flg_status = pk_alert_constant.g_monitor_vs_pend
               AND l_allow_execs_expired = pk_alert_constant.g_no
            THEN
                l_to_state := l_flg_status;
            END IF;
        
            l_error := 'CALL PK_ACTION.TF_GET_ACTIONS';
            OPEN o_actions FOR
                SELECT id_action,
                       id_parent,
                       level_nr,
                       l_flg_status from_state,
                       to_state,
                       desc_action,
                       icon,
                       flg_default,
                       CASE
                            WHEN l_permission = pk_alert_constant.g_no THEN
                             pk_alert_constant.g_inactive
                            ELSE
                             CASE
                                 WHEN to_state = pk_alert_constant.g_monitor_vs_pend
                                      AND l_flg_status = pk_alert_constant.g_monitor_vs_pend
                                      AND l_to_state IS NOT NULL THEN
                                  pk_alert_constant.g_inactive
                                 WHEN to_state = l_to_state_exec
                                      AND l_flg_status = pk_alert_constant.g_monitor_vs_expire
                                      AND l_allow_execs_expired = pk_alert_constant.g_no THEN
                                  pk_alert_constant.g_inactive
                                 ELSE
                                  flg_active
                             END
                        END flg_active,
                       action
                  FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, c_action_monitorization, l_flg_status)) act;
        ELSE
            SELECT COUNT(1)
              INTO l_count
              FROM monitorization m
             WHERE m.id_monitorization IN (SELECT /*+ OPT_ESTIMATE (TABLE d ROWS=1)*/
                                            column_value
                                             FROM TABLE(i_task_request) d)
               AND m.flg_status IN (pk_alert_constant.g_cancelled, pk_alert_constant.g_inactive);
            -- if there's at least one cancelled OR inactive, don't enable cancel option
            IF l_count = 0
            THEN
                -- multiple records, only cancel option is available
                l_error := 'CALL PK_ACTION.TF_GET_ACTIONS';
                OPEN o_actions FOR
                    SELECT act.id_action,
                           act.id_parent,
                           act.level_nr,
                           pk_alert_constant.g_active from_state,
                           act.to_state,
                           act.desc_action,
                           act.icon,
                           act.flg_default,
                           act.flg_active,
                           act.action
                      FROM TABLE(pk_action.tf_get_actions(i_lang,
                                                          i_prof,
                                                          c_action_monitorization,
                                                          pk_alert_constant.g_active)) act
                     WHERE act.action = 'CANCEL_MONIT';
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_ACTIONS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_actions;

    /**********************************************************************************************
    * get task parameters (CPOE purpose)
    * in other words, get task parameters needed to fill task edit screens (critical for draft editing)
    *
    * NOTE: this function can be replaced by several functions that returns the required values,  
    *       according to current task workflow edit screens
    *
    * @param           i_lang                   preferred language id for this professional
    * @param           i_prof                   professional type
    * @param           i_episode                episode id
    * @param           i_id_monitorization      monitorization id
    * @param           o_monitor                monitorization cursor info 
    * @param           o_actions                actions cursor info
    * @param           o_error                  error message
    *
    * @return          boolean                  true on success, otherwise false
    *
    * @author                                   Filipe Machado
    * @version                                  2.5.0.7.3
    * @since                                    2009/11/17
    **********************************************************************************************/
    FUNCTION get_task_parameters
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_episode           IN episode.id_episode%TYPE,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        o_monitor           OUT pk_types.cursor_type,
        o_actions           OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        l_exception EXCEPTION;
        l_timezone      timezone_region.timezone_region%TYPE;
        l_id_visit      visit.id_visit%TYPE;
        l_id_epis_type  episode.id_epis_type%TYPE;
        l_sign_off_t034 sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'SIGN_OFF_T034');
        l_sign_off_t014 sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'SIGN_OFF_T014');
    
    BEGIN
        IF NOT pk_date_utils.get_timezone(i_lang     => i_lang,
                                          i_prof     => i_prof,
                                          i_timezone => NULL,
                                          o_timezone => l_timezone,
                                          o_error    => o_error)
        THEN
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        END IF;
    
        IF NOT get_visit(i_lang, i_episode, l_id_visit, l_id_epis_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_message := 'GET CURSOR o_monitor';
        OPEN o_monitor FOR
            SELECT m.id_monitorization,
                   m.flg_status,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, m.id_professional) nick_name,
                   pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS', m.flg_status, i_lang) desc_status,
                   concat_monit_vs(i_lang, i_prof, l_id_visit, l_id_epis_type, m.id_monitorization) task_description,
                   m.flg_time,
                   pk_sysdomain.get_domain('MONITORIZATION.FLG_TIME', m.flg_time, i_lang) desc_time,
                   pk_date_utils.get_timestamp_str(i_lang, i_prof, m.dt_monitorization_tstz, NULL) date_req,
                   
                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                    m.dt_monitorization_tstz,
                                                    i_prof.institution,
                                                    i_prof.software) hour_req,
                   decode(m.flg_time,
                          pk_alert_constant.g_flg_time_n,
                          NULL,
                          pk_date_utils.get_timestamp_str(i_lang,
                                                          i_prof,
                                                          nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                          NULL)) date_begin,
                   decode(m.flg_time,
                          pk_alert_constant.g_flg_time_n,
                          pk_message.get_message(i_lang, 'COMMON_M018'),
                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                           nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                           i_prof.institution,
                                                           i_prof.software)) hour_begin,
                   decode(m.flg_time,
                          pk_alert_constant.g_flg_time_n,
                          NULL,
                          pk_date_utils.get_timestamp_str(i_lang, i_prof, m.dt_end_tstz, NULL)) date_end,
                   decode(m.flg_time,
                          pk_alert_constant.g_flg_time_n,
                          pk_message.get_message(i_lang, 'COMMON_M018'),
                          pk_date_utils.date_char_hour_tsz(i_lang, m.dt_end_tstz, i_prof.institution, i_prof.software)) hour_end,
                   get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval,
                   pk_date_utils.get_timestamp_str(i_lang, i_prof, m.dt_cancel_tstz, NULL) dt_cancel,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, m.id_prof_cancel) prof_cancel,
                   m.notes_cancel,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    m.id_professional,
                                                    m.dt_monitorization_tstz,
                                                    m.id_episode) desc_speciality,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    m.id_prof_cancel,
                                                    m.dt_monitorization_tstz,
                                                    m.id_episode) desc_speciality_cancel,
                   c.desc_prof_ordered_by prof_order,
                   pk_date_utils.get_timestamp_str(i_lang, i_prof, c.dt_ordered_by, NULL) dt_order,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, mvsp.id_prof_performed) name_performed,
                   pk_translation.get_translation_trs(m.code_notes) notes,
                   m.interval
              FROM monitorization m
              LEFT JOIN TABLE(pk_co_sign_api.tf_co_sign_task_info(i_lang => i_lang, i_prof => i_prof, i_episode => m.id_episode, i_id_co_sign => m.id_co_sign_order)) c
                ON c.id_co_sign = m.id_co_sign_order
            
              JOIN monitorization_vs mvs
                ON mvs.id_monitorization = m.id_monitorization
              JOIN monitorization_vs_plan mvsp
                ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
              JOIN episode e
                ON e.id_episode = m.id_episode
             WHERE e.id_visit = l_id_visit
               AND m.id_monitorization = i_id_monitorization
             ORDER BY m.id_monitorization;
    
        -- get actions 
        IF NOT get_actions(i_lang, i_prof, i_episode, table_number(i_id_monitorization), o_actions, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_TASK_PARAMETERS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_task_parameters;

    /**********************************************************************************************
    * set task parameters (CPOE purpose)
    * set task parameters changed in task edit screens (critical for draft editing)
    *   
    * NOTE: this function can be replaced by several functions that update the required values,  
    *       according to current task workflow edit screens 
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_episode                episode id
    * @param          io_monit                 monitorization type
    * @param          o_error                  error message
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.3
    * @since                                   2009/11/18
    **********************************************************************************************/
    FUNCTION set_task_parameters
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        io_monit  IN OUT NOCOPY monit,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_monitor_vs_code_notes table_varchar;
        l_monitor_vs_notes      table_clob;
        l_rowsid_vs             table_varchar := table_varchar();
        l_message               debug_msg;
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_rowsid table_varchar := table_varchar();
    BEGIN
        IF NOT validate_monitor_req(i_lang, i_prof, io_monit, o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        l_message := 'CALL TO PK_MONITORIZATION.SET_TASK_PARAMETERS - update monitorization';
        ts_monitorization.upd(id_monitorization_in      => io_monit.id_monit,
                              id_episode_in             => io_monit.id_epis,
                              flg_time_in               => io_monit.flg_time,
                              dt_begin_tstz_in          => nvl(get_tstz_date(i_lang, i_prof, io_monit.dt_begin_str),
                                                               l_sysdate_tstz),
                              dt_end_tstz_in            => get_tstz_date(i_lang, i_prof, io_monit.dt_end_str),
                              dt_end_tstz_nin           => FALSE,
                              dt_monitorization_tstz_in => l_sysdate_tstz,
                              interval_in               => io_monit.interval_final,
                              rows_out                  => l_rowsid);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        pk_translation.insert_translation_trs(i_lang   => i_lang,
                                              i_code   => g_trs_monit_notes || io_monit.id_monit,
                                              i_desc   => io_monit.notes,
                                              i_module => 'MONITORIZATION');
    
        l_message := 'CALL TO PK_MONITORIZATION.SET_TASK_PARAMETERS - update monitorization_vs';
        ts_monitorization_vs.upd(dt_order_in                  => l_sysdate_tstz,
                                 dt_monitorization_vs_tstz_in => l_sysdate_tstz,
                                 where_in                     => 'ID_MONITORIZATION = ' || io_monit.id_monit,
                                 rows_out                     => l_rowsid_vs);
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowsid_vs,
                                      o_error      => o_error);
    
        l_message := 'GET CODE_NOTES FROM MONITORIZATION_VS';
        SELECT m.code_notes, io_monit.notes
          BULK COLLECT
          INTO l_monitor_vs_code_notes, l_monitor_vs_notes
          FROM monitorization_vs m
         WHERE m.id_monitorization = io_monit.id_monit;
    
        l_message := 'INSERT_TRANSLATION_TRS_BULK MONITORIZATION_VS NOTES';
        pk_translation.insert_translation_trs_bulk(i_lang   => i_lang,
                                                   i_code   => l_monitor_vs_code_notes,
                                                   i_desc   => l_monitor_vs_notes,
                                                   i_module => 'MONITORIZATION_VS');
    
        -- co-sign task record
        l_message := 'UPDATE THE EXISTING CO-SIGN RECORD - ONLY THE FIELDS. THE STATE DOES NOT CHANGE.';
        --create co-sign task
        io_monit.flg_monitorization_action := pk_monitorization.g_draft_action;
        IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'SET_TASK_PARAMETERS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_task_parameters;

    /**********************************************************************************************
    * set task parameters (CPOE purpose)
    * set task parameters changed in task edit screens (critical for draft editing)
    *   
    * NOTE: this function can be replaced by several functions that update the required values,  
    *       according to current task workflow edit screens 
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_id_monitorization      monitorization id
    * @param          i_episode                episode id
    * ...
    * @param          o_error                  error message
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.5
    * @since                                   2009/12/11
    **********************************************************************************************/
    FUNCTION set_task_parameters
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_episode           IN monitorization.id_episode%TYPE,
        i_dt_begin_str      IN VARCHAR2,
        i_interval          IN VARCHAR2,
        i_dt_end_str        IN VARCHAR2,
        i_notes             IN CLOB,
        i_flg_time          IN monitorization.flg_time%TYPE,
        i_id_vs             IN table_number,
        i_notes_detail      IN table_varchar,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_prof_order        IN monitorization_vs.id_prof_order%TYPE := NULL,
        i_dt_order_str      IN VARCHAR2 := NULL,
        i_order_type        IN monitorization_vs.id_order_type%TYPE := NULL,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_id_co_sign_order  monitorization.id_co_sign_order%TYPE;
        l_id_co_sign_cancel monitorization.id_co_sign_cancel%TYPE;
        io_monit            monit;
    
    BEGIN
        BEGIN
            SELECT m.id_co_sign_order, m.id_co_sign_cancel
              INTO l_id_co_sign_order, l_id_co_sign_cancel
              FROM monitorization m
             WHERE m.id_monitorization = i_id_monitorization;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_co_sign_order  := NULL;
                l_id_co_sign_cancel := NULL;
        END;
        io_monit := monit(id_monit                  => i_id_monitorization,
                          id_prof                   => i_prof.id,
                          id_inst                   => i_prof.institution,
                          id_soft                   => i_prof.software,
                          id_epis                   => i_episode,
                          notes                     => i_notes,
                          flg_time                  => i_flg_time,
                          dt_order_str              => i_dt_order_str,
                          dt_begin_str              => i_dt_begin_str,
                          dt_end_str                => i_dt_end_str,
                          dt_begin_final_str        => i_dt_begin_str,
                          INTERVAL                  => i_interval,
                          interval_final            => NULL,
                          id_vs                     => i_id_vs,
                          notes_detail              => i_notes_detail,
                          flg_status                => pk_alert_constant.g_monitor_vs_exec,
                          flg_status_det            => pk_alert_constant.g_monitor_vs_exec,
                          id_order_type             => i_order_type,
                          id_prof_order             => i_prof_order,
                          flg_monitorization_action => pk_monitorization.g_order_action,
                          id_co_sign_order          => l_id_co_sign_order,
                          id_co_sign_cancel         => l_id_co_sign_cancel);
    
        IF NOT set_task_parameters(i_lang    => i_lang,
                                   i_prof    => i_prof,
                                   i_episode => i_episode,
                                   io_monit  => io_monit,
                                   o_error   => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'SET_TASK_PARAMETERS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_task_parameters;

    /**********************************************************************************************
    * activate a draft = change status from 'R' to 'A' (CPOE purpose)
    * in other words, activates a set of draft tasks (task goes from draft to active workflow) 
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_episode                episode id
    * @param          i_draft                  id monitorizations collection (drafts)
    * @param          i_flg_commit             transaction control
    * @param          o_created_drafts         array of created task requests
    * @param          o_error                  error message
    *
    * @value          i_flg_commit             {*} 'Y' commit/rollback the transaction
    *                                          {*} 'N' transaction control is done outside
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.3
    * @since                                   18-Nov-2009
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.1.1
    * @changed                                 15-Sep-2010 (new parameter, o_created_tasks, was added)
    **********************************************************************************************/
    FUNCTION activate_drafts
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_draft         IN table_number,
        i_flg_commit    IN VARCHAR2,
        o_created_tasks OUT table_number,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message debug_msg;
        l_exception EXCEPTION;
    
        CURSOR c_monitor_dates(id_monit monitorization.id_monitorization%TYPE) IS
            SELECT m.dt_monitorization_tstz, m.dt_begin_tstz, m.dt_end_tstz, m.dt_cancel_tstz, m.id_professional
              FROM monitorization m
             WHERE m.id_monitorization = id_monit;
    
        CURSOR c_monitor_vs(id_monit monitorization.id_monitorization%TYPE) IS
            SELECT ROWID, id_monitorization_vs, id_prof_order, flg_co_sign, id_prof_co_sign, id_vital_sign
              FROM monitorization_vs
             WHERE id_monitorization = id_monit;
    
        r_monitor_dates      c_monitor_dates%ROWTYPE;
        l_dt_begin           TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_end             TIMESTAMP WITH LOCAL TIME ZONE;
        l_prof_cat_type      category.flg_type%TYPE;
        l_rowids             table_varchar;
        l_rowsid_m           table_varchar := table_varchar();
        l_rowsid             table_varchar := table_varchar();
        l_id_request         table_number := table_number();
        l_id_task            table_number := table_number();
        l_id_icnp_sug_interv table_number := table_number();
        io_monit             monit;
        g_exception EXCEPTION;
        l_rowsid_vs       table_varchar := table_varchar();
        l_rowsid_plan     table_varchar := table_varchar();
        l_task_type       cpoe_task_type.id_task_type%TYPE;
        l_count_rel_tasks NUMBER;
    
        l_draft          table_number;
        l_id_request_val interv_presc_det.id_interv_presc_det%TYPE;
    
    BEGIN
        l_prof_cat_type := pk_prof_utils.get_category(i_lang, i_prof => i_prof);
        l_rowids        := table_varchar();
    
        o_created_tasks := i_draft;
    
        FOR i IN 1 .. i_draft.count
        LOOP
        
            OPEN c_monitor_dates(i_draft(i));
            FETCH c_monitor_dates
                INTO r_monitor_dates;
            CLOSE c_monitor_dates;
        
            l_task_type := pk_cpoe.g_task_type_monitorization;
        
            BEGIN
                SELECT a.id_task_orig
                  INTO l_count_rel_tasks
                  FROM cpoe_tasks_relation a
                 WHERE a.id_task_dest = i_draft(i)
                   AND a.id_task_type = l_task_type
                   AND a.flg_type = 'AD';
            EXCEPTION
                WHEN no_data_found THEN
                    l_count_rel_tasks := 0;
            END;
        
            IF l_count_rel_tasks > 0
            THEN
                SELECT m.dt_end_tstz
                  INTO l_dt_end
                  FROM monitorization m
                 WHERE m.id_monitorization = l_count_rel_tasks;
            END IF;
        
            IF l_count_rel_tasks > 0
               AND (l_dt_end IS NULL OR (l_dt_end IS NOT NULL AND l_dt_end > g_sysdate_tstz))
            THEN
            
                IF NOT pk_cpoe.sync_active_to_next(i_lang      => i_lang,
                                                   i_prof      => i_prof,
                                                   i_episode   => i_episode,
                                                   i_task_type => l_task_type,
                                                   i_request   => i_draft(i),
                                                   o_error     => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                l_draft := i_draft;
            
                FOR i IN 1 .. l_draft.count
                LOOP
                    IF l_draft(i) = i_draft(i)
                    THEN
                        SELECT a.id_task_orig
                          INTO l_id_request_val
                          FROM cpoe_tasks_relation a
                         WHERE a.id_task_dest = i_draft(i);
                        l_draft(i) := l_id_request_val;
                    END IF;
                END LOOP;
            
                IF NOT cancel_draft(i_lang    => i_lang,
                                    i_prof    => i_prof,
                                    i_episode => i_episode,
                                    i_draft   => table_number(i_draft(i)),
                                    o_error   => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                o_created_tasks := l_draft;
            
                RETURN TRUE;
            END IF;
        
            -- if the dt_begin is in the past, then will be updated for current time
            IF r_monitor_dates.dt_begin_tstz < l_sysdate_tstz
            THEN
                l_dt_begin := l_sysdate_tstz;
            ELSE
                l_dt_begin := r_monitor_dates.dt_begin_tstz;
            END IF;
        
            -- if the dt_end is in the past, then will be updated for null
            IF r_monitor_dates.dt_begin_tstz < l_sysdate_tstz
            THEN
                l_dt_end := NULL;
            ELSE
                l_dt_end := r_monitor_dates.dt_end_tstz;
            END IF;
        
            l_message := 'CALL TO PK_MONITORIZATION.ACTIVE_DRAFT - update monitorization';
            ts_monitorization.upd(id_monitorization_in      => i_draft(i),
                                  flg_status_in             => pk_alert_constant.g_monitor_vs_exec,
                                  dt_begin_tstz_in          => l_dt_begin,
                                  dt_end_tstz_in            => l_dt_end,
                                  id_professional_in        => i_prof.id,
                                  dt_monitorization_tstz_in => l_sysdate_tstz,
                                  rows_out                  => l_rowsid_m);
        
            --CO-SIGN Creation workflow
            l_message := 'CREATE MONIT OBJECT';
            IF NOT init_monit(i_lang              => i_lang,
                              i_prof              => i_prof,
                              i_id_monitorization => i_draft(i),
                              io_monit            => io_monit,
                              o_error             => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            l_message                          := 'CALL SET_CO_SIGN_ORDER_WF';
            io_monit.flg_monitorization_action := g_activate_draft_action;
            IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            l_message := 'CALL TO PK_MONITORIZATION.ACTIVE_DRAFT - update monitorization_vs';
            ts_monitorization_vs.upd(flg_status_in                => pk_alert_constant.g_monitor_vs_exec,
                                     dt_order_in                  => l_sysdate_tstz,
                                     dt_monitorization_vs_tstz_in => l_sysdate_tstz,
                                     id_prof_order_in             => i_prof.id,
                                     where_in                     => 'ID_MONITORIZATION = ' || i_draft(i),
                                     rows_out                     => l_rowsid_vs);
        
            l_message := 'CALL t_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS',
                                          i_rowids     => l_rowsid_vs,
                                          o_error      => o_error);
        
            FOR j IN c_monitor_vs(i_draft(i))
            LOOP
            
                -- the co-sign control info will be updated/removed
                /* ts_monitorization_vs.upd(flg_co_sign_in      => pk_alert_constant.g_no,
                                         id_prof_co_sign_in  => NULL,
                                         id_prof_co_sign_nin => FALSE,
                                         dt_co_sign_in       => NULL,
                                         dt_co_sign_nin      => FALSE,
                                         notes_co_sign_in    => NULL,
                                         notes_co_sign_nin   => FALSE,
                where_in            => 'ID_MONITORIZATION = ' || i_draft(i));*/
            
                -- if the professional logged is a physician, the id order type (co-sign) will be removed
                -- and prof_order updated
                /*IF pk_prof_utils.get_category(i_lang, i_prof => i_prof) = pk_alert_constant.g_cat_type_doc
                THEN
                
                    ts_monitorization_vs.upd(id_order_type_in  => NULL,
                                             id_order_type_nin => FALSE,
                                             id_prof_order_in  => i_prof.id,
                                             where_in          => 'ID_MONITORIZATION = ' || i_draft(i));
                END IF;*/
            
                l_message := 'CALL TO PK_MONITORIZATION.ACTIVE_DRAFT - update monitorization_vs_plan';
                ts_monitorization_vs_plan.upd(flg_status_in        => pk_alert_constant.g_monitor_vs_exec,
                                              dt_plan_tstz_in      => nvl(l_dt_begin, l_sysdate_tstz),
                                              id_prof_performed_in => i_prof.id,
                                              where_in             => 'ID_MONITORIZATION_VS = ' ||
                                                                      j.id_monitorization_vs,
                                              rows_out             => l_rowsid_plan);
            
                -- TODO: These rules of the ALERT® Data Governance, in the near future, MUST BE in a funtion
                -- ALERT® Data Governance
                l_rowids := table_varchar();
                l_rowids.extend;
            
                l_rowids(1) := j.rowid;
            
                l_message := 'CALL t_data_gov_mnt.process_insert';
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'MONITORIZATION_VS',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            
                l_message := 'CALL TO PK_VISIT.SET_FIRST_OBS';
                IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                              i_id_episode          => i_episode,
                                              i_pat                 => NULL,
                                              i_prof                => i_prof,
                                              i_prof_cat_type       => l_prof_cat_type,
                                              i_dt_last_interaction => l_sysdate_tstz,
                                              i_dt_first_obs        => l_sysdate_tstz,
                                              o_error               => o_error)
                THEN
                    RETURN FALSE;
                END IF;
            
                l_id_request.extend;
                l_id_request(l_id_request.count) := j.id_monitorization_vs;
                l_id_task.extend;
                l_id_task(l_id_request.count) := j.id_vital_sign;
            
            --/ ALERT® Data Governance
            
            END LOOP;
            l_message := 'CALL t_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS_PLAN',
                                          i_rowids     => l_rowsid_plan,
                                          o_error      => o_error);
        
            IF NOT create_alert_vital_sign(i_lang           => i_lang,
                                           i_prof           => i_prof,
                                           i_monitorization => i_draft(i),
                                           o_error          => o_error)
            THEN
                RETURN FALSE;
            END IF;
        
            IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                     i_prof                 => i_prof,
                                     i_episode              => i_episode,
                                     i_task_type            => pk_alert_constant.g_task_type_monitorization,
                                     i_task_request         => i_draft(i),
                                     i_task_start_timestamp => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                             i_prof      => i_prof,
                                                                                             i_timestamp => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                                        i_date => nvl(l_dt_begin,
                                                                                                                                                      l_sysdate_tstz),
                                                                                                                                        i_prof => i_prof),
                                                                                             i_timezone  => NULL),
                                     o_error                => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END LOOP;
    
        l_message := 'CALL t_data_gov_mnt.process_update';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid_m,
                                      o_error      => o_error);
    
        IF i_flg_commit = pk_alert_constant.g_yes
        THEN
            COMMIT;
        END IF;
    
        pk_icnp_fo_api_db.create_suggs(i_lang               => i_lang,
                                       i_prof               => i_prof,
                                       i_id_episode         => i_episode,
                                       i_request_ids        => l_id_request,
                                       i_task_ids           => l_id_task,
                                       i_task_type_id       => pk_alert_constant.g_task_monitoring,
                                       i_sysdate_tstz       => l_sysdate_tstz,
                                       o_id_icnp_sug_interv => l_id_icnp_sug_interv);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'ACTIVATE_DRAFTS',
                                              o_error);
        
            pk_utils.undo_changes;
            RETURN FALSE;
    END activate_drafts;

    /******************************************************************************************** 
    * expire a requested task 
    * as far as we know, this is not necessary for monitorizations
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id 
    * @param       i_task_request            task request id 
    * @param       o_error                   error message 
    * 
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Nuno Neves
    * @version                               2.6.0.5.1.4
    * @since                                 2011/01/21
    ********************************************************************************************/
    FUNCTION expire_task
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_monitorization_vs table_number;
        l_flg_status_m      VARCHAR2(1);
        l_flg_status_m_vs   table_varchar;
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_rowsid table_varchar := table_varchar();
        -- Alert® Data Governance
        l_rowids      table_varchar;
        l_rowsid_plan table_varchar := table_varchar();
    BEGIN
    
        FOR i IN 1 .. i_task_request.count
        LOOP
        
            SELECT m.flg_status
              INTO l_flg_status_m
              FROM monitorization m
             WHERE m.id_monitorization = i_task_request(i);
        
            IF l_flg_status_m IS NOT NULL
            THEN
                IF l_flg_status_m = pk_alert_constant.g_monitor_vs_exec
                   OR l_flg_status_m = pk_alert_constant.g_monitor_vs_pend
                THEN
                    --'UPDATE MONITORIZATION STATUS';
                    ts_monitorization.upd(id_monitorization_in => i_task_request(i),
                                          flg_status_in        => pk_alert_constant.g_monitor_vs_expire,
                                          dt_cancel_tstz_in    => l_sysdate_tstz,
                                          id_prof_cancel_in    => i_prof.id,
                                          rows_out             => l_rowsid);
                END IF;
            END IF;
        
            -- Update monitorizations to flg_status='E' - expired
        
            SELECT mv.id_monitorization_vs, mv.flg_status
              BULK COLLECT
              INTO l_monitorization_vs, l_flg_status_m_vs
              FROM monitorization_vs mv
             WHERE mv.id_monitorization = i_task_request(i);
        
            FOR j IN 1 .. l_monitorization_vs.count
            LOOP
            
                IF l_flg_status_m_vs(j) IS NOT NULL
                THEN
                    IF l_flg_status_m_vs(j) = pk_alert_constant.g_monitor_vs_exec
                       OR l_flg_status_m_vs(j) = pk_alert_constant.g_monitor_vs_pend
                    THEN
                        --'UPDATE MONITORIZATION_VS';
                        ts_monitorization_vs.upd(id_monitorization_vs_in => l_monitorization_vs(j),
                                                 flg_status_in           => pk_alert_constant.g_monitor_vs_expire,
                                                 dt_cancel_tstz_in       => l_sysdate_tstz,
                                                 id_prof_cancel_in       => i_prof.id,
                                                 rows_out                => l_rowids);
                    
                        --'UPDATE MONITORIZATION_VS_PLAN';
                        ts_monitorization_vs_plan.upd(flg_status_in => pk_alert_constant.g_monitor_vs_expire,
                                                      where_in      => 'ID_MONITORIZATION_VS = ' ||
                                                                       l_monitorization_vs(j) || ' AND FLG_STATUS != ''' ||
                                                                       pk_alert_constant.g_monitor_vs_fini || '''',
                                                      rows_out      => l_rowsid_plan);
                    
                    END IF;
                END IF;
            
            END LOOP;
        
            --'CALL t_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END LOOP;
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS_PLAN',
                                      i_rowids     => l_rowsid_plan,
                                      o_error      => o_error);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rowsid,
                                      o_error      => o_error);
    
        --'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => pk_prof_utils.get_category(i_lang, i_prof),
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    END expire_task;

    /******************************************************************************************** 
    * get available actions for a requested task 
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id 
    * @param       i_task_request            task request id (also used for drafts) 
    * @param       o_actions_list            list of available actions for the task request 
    * @param       o_error                   error message 
    * 
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/18
    ********************************************************************************************/
    FUNCTION get_task_actions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_actions_list OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
    
    BEGIN
        IF NOT get_actions(i_lang, i_prof, i_episode, i_task_request, o_actions_list, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_TASK_ACTIONS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_task_actions;

    /******************************************************************************************** 
    * perform a task action  
    * as far as we know, this is not necessary for monitorizations
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id 
    * @param       i_action                  action id 
    * @param       i_task_request            task request id (also used for drafts) 
    * @param       o_error                   error message 
    * 
    * @return      boolean                   true on success, otherwise false     
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/18
    ********************************************************************************************/
    FUNCTION set_action
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_action       IN action.id_action%TYPE,
        i_task_request IN cpoe_process_task.id_task_request%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN TRUE;
    END set_action;

    /******************************************************************************************** 
    * copy task to draft (from an existing active/inactive task) 
    * 
    * @param       i_lang                    preferred language id for this professional 
    * @param       i_prof                    professional id structure 
    * @param       i_episode                 episode id (current episode) 
    * @param       i_task_request            task request id (used for active/inactive tasks) 
    * @param       o_draft                   draft id 
    * @param       o_error                   error message 
    * 
    * @return      boolean                   true on success, otherwise false  
    *
    * @author                                Filipe Machado
    * @version                               2.5.0.7.3
    * @since                                 2009/11/18   
    ********************************************************************************************/
    FUNCTION copy_to_draft
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_task_request         IN cpoe_process_task.id_task_request%TYPE,
        i_task_start_timestamp IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_task_end_timestamp   IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_draft                OUT cpoe_process_task.id_task_request%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
    
        CURSOR c_monit_vs(id_monit monitorization.id_monitorization%TYPE) IS
            SELECT *
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = id_monit;
    
        l_monitorization_vs_row c_monit_vs%ROWTYPE;
    
        l_monit monit;
        l_draft table_number;
        i       NUMBER := 1;
    
        l_begin_date_tstz   monitorization.dt_begin_tstz%TYPE;
        l_dt_next_date_tstz monitorization_vs_plan.dt_plan_tstz%TYPE;
    
        l_flg_profile     profile_template.flg_profile%TYPE;
        l_sys_alert_event sys_alert_event%ROWTYPE;
        l_dt_end          cpoe_process.dt_cpoe_proc_end%TYPE;
    
    BEGIN
    
        l_flg_profile := pk_hand_off_core.get_flg_profile(i_lang, i_prof, NULL);
    
        BEGIN
            SELECT a.dt_cpoe_proc_end
              INTO l_dt_end
              FROM cpoe_process a
             WHERE a.id_episode = i_episode
               AND a.flg_status = 'A';
        EXCEPTION
            WHEN no_data_found THEN
                l_dt_end := NULL;
        END;
    
        IF NOT init_monit(i_lang                 => i_lang,
                          i_prof                 => i_prof,
                          i_id_monitorization    => i_task_request,
                          io_monit               => l_monit,
                          i_draft                => pk_alert_constant.g_yes,
                          i_task_start_timestamp => i_task_start_timestamp,
                          o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        IF i_task_start_timestamp IS NOT NULL
           OR l_dt_end IS NOT NULL
        THEN
        
            l_begin_date_tstz := pk_date_utils.get_string_tstz(i_lang, i_prof, l_monit.dt_order_str, NULL);
        
            l_dt_next_date_tstz := l_begin_date_tstz + numtodsinterval(l_monit.interval_final, 'SECOND');
        
            IF l_dt_next_date_tstz <= l_dt_end
            THEN
                l_begin_date_tstz := l_dt_next_date_tstz;
            ELSE
                WHILE l_begin_date_tstz <= i_task_start_timestamp
                LOOP
                    l_begin_date_tstz := l_begin_date_tstz + numtodsinterval(l_monit.interval_final, 'SECOND');
                END LOOP;
            END IF;
        
            l_monit.dt_begin_str       := get_str_date(i_lang, i_prof, l_begin_date_tstz);
            l_monit.dt_begin_final_str := get_str_date(i_lang, i_prof, l_begin_date_tstz);
        ELSE
            l_begin_date_tstz          := pk_date_utils.get_string_tstz(i_lang, i_prof, l_monit.dt_order_str, NULL);
            l_monit.dt_begin_str       := get_str_date(i_lang, i_prof, l_begin_date_tstz);
            l_monit.dt_begin_final_str := get_str_date(i_lang, i_prof, l_begin_date_tstz);
        END IF;
    
        -- monitorization_vs
        OPEN c_monit_vs(i_task_request);
        LOOP
            FETCH c_monit_vs
                INTO l_monitorization_vs_row;
            EXIT WHEN c_monit_vs%NOTFOUND;
            l_monit.id_vs.extend;
            l_monit.id_vs(i) := l_monitorization_vs_row.id_vital_sign;
            l_monit.id_prof_order := l_monitorization_vs_row.id_prof_order;
            l_monit.id_order_type := l_monitorization_vs_row.id_order_type;
            i := i + 1;
        END LOOP;
        CLOSE c_monit_vs;
    
        IF NOT create_draft(i_lang    => i_lang,
                            i_prof    => i_prof,
                            i_episode => i_episode,
                            io_monit  => l_monit,
                            o_draft   => l_draft,
                            o_error   => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        IF l_flg_profile = pk_prof_utils.g_flg_profile_template_student
        THEN
            l_sys_alert_event.id_sys_alert    := pk_alert_constant.g_alert_cpoe_draft;
            l_sys_alert_event.id_software     := i_prof.software;
            l_sys_alert_event.id_institution  := i_prof.institution;
            l_sys_alert_event.id_episode      := i_episode;
            l_sys_alert_event.id_patient      := pk_episode.get_epis_patient(i_lang    => i_lang,
                                                                             i_prof    => i_prof,
                                                                             i_episode => i_episode);
            l_sys_alert_event.id_record       := i_episode;
            l_sys_alert_event.id_visit        := pk_visit.get_visit(i_episode => i_episode, o_error => o_error);
            l_sys_alert_event.dt_record       := current_timestamp;
            l_sys_alert_event.id_professional := pk_hand_off.get_episode_responsible(i_lang       => i_lang,
                                                                                     i_prof       => i_prof,
                                                                                     i_id_episode => i_episode,
                                                                                     o_error      => o_error);
        
            IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                    i_prof            => i_prof,
                                                    i_sys_alert_event => l_sys_alert_event,
                                                    o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END IF;
    
        o_draft := l_draft(1);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'COPY_TO_DRAFT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END copy_to_draft;

    /**********************************************************************************************
    * Append the monitorization vital signs in a string 
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_visit                  visit id
    * @param        i_id_epis_type           episode type id
    * @param        i_monitorization         monitoring id
    *
    * @return       varchar2                 vital signs string separated by semi-colon
    *                        
    * @author                                Tiago Silva/Filipe Machado
    * @version                               1.0
    * @since                                 2009/11/26
    **********************************************************************************************/
    FUNCTION concat_monit_vs
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_visit          IN visit.id_visit%TYPE,
        l_id_epis_type   IN episode.id_epis_type%TYPE,
        i_monitorization IN monitorization.id_monitorization%TYPE
    ) RETURN VARCHAR2 IS
        l_concat_str VARCHAR2(1000 CHAR);
        l_len_str    PLS_INTEGER := 0;
    
        l_separator     CONSTANT VARCHAR(2) := ', ';
        l_len_separator CONSTANT PLS_INTEGER := length(l_separator);
    
    BEGIN
        FOR rec IN (SELECT pk_vital_sign.get_vs_desc(i_lang, mvs.id_vital_sign) ||
                           decode(l_id_epis_type,
                                  nvl(t_ti_log.get_epis_type(i_lang,
                                                             i_prof,
                                                             e.id_epis_type,
                                                             m.flg_status,
                                                             m.id_monitorization,
                                                             pk_alert_constant.g_ti_type_mn),
                                      e.id_epis_type),
                                  '',
                                  ' - (' || pk_message.get_message(i_lang,
                                                                   profissional(i_prof.id,
                                                                                i_prof.institution,
                                                                                t_ti_log.get_epis_type_soft(i_lang,
                                                                                                            i_prof,
                                                                                                            e.id_epis_type,
                                                                                                            m.flg_status,
                                                                                                            m.id_monitorization,
                                                                                                            pk_alert_constant.g_ti_type_mn)),
                                                                   'IMAGE_T009') || ')') task_description
                      FROM monitorization m
                     INNER JOIN monitorization_vs mvs
                        ON mvs.id_monitorization = m.id_monitorization
                     INNER JOIN episode e
                        ON e.id_episode = m.id_episode
                     WHERE e.id_visit = i_visit
                       AND m.id_monitorization = i_monitorization
                     ORDER BY task_description)
        
        LOOP
        
            -- verify if string length will be greater than max buffer length
            IF (l_len_str + length(rec.task_description) + l_len_separator > 1000)
            THEN
            
                -- truncate string length
                l_concat_str := substr(l_concat_str, 1, 997) || '...';
                RETURN l_concat_str;
            ELSE
                -- concatenate task description
                l_concat_str := l_concat_str || rec.task_description || l_separator;
            
                --increment string length
                l_len_str := l_len_str + length(rec.task_description) + l_len_separator;
            END IF;
        
        END LOOP;
    
        -- remove last separator from concatenate string
        l_concat_str := substr(l_concat_str, 0, length(l_concat_str) - l_len_separator);
    
        RETURN l_concat_str;
    
    END concat_monit_vs;

    /**********************************************************************************************
    * create monitorization detail
    *
    * @param          i_lang                   preferred language id for this professional
    * @param          i_prof                   professional type
    * @param          i_commit_data            data shall be commit internal or not
    * @param          io_monit                 monitorization type
    * @param          o_error                  error message
    *
    * @value          i_commit_data            {*} 'Y' shall be commit
    *                                          {*} 'N' shall not be commit
    *
    * @return         boolean                  true on success, otherwise false
    *
    * @author                                  Filipe Machado
    * @version                                 2.5.0.7.3
    * @since                                   2009/11/17
    **********************************************************************************************/
    FUNCTION create_monitor_req
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_commit_data IN VARCHAR2,
        io_monit      IN OUT NOCOPY monit,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        l_exception EXCEPTION;
    
        next_id_mvs monitorization_vs.id_monitorization_vs%TYPE;
    
        l_prof_cat_type category.flg_type%TYPE;
    
        l_commit_data BOOLEAN;
    
        l_rowids     table_varchar := table_varchar();
        l_rowids_aux table_varchar;
    
        l_id_request         table_number := table_number();
        l_id_task            table_number := table_number();
        l_id_icnp_sug_interv table_number := table_number();
        l_symbol_pos         PLS_INTEGER;
        l_seconds            PLS_INTEGER;
    
        g_exception EXCEPTION;
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        l_symbol_pos := interval_has_hour_symbol(io_monit.interval);
    
        IF l_symbol_pos > 0
        THEN
            l_seconds         := get_format_interval_to_seconds(i_lang, i_prof, io_monit.interval);
            io_monit.interval := to_char(l_seconds);
        END IF;
    
        IF NOT validate_monitor_req(i_lang, i_prof, io_monit, o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF NOT create_monitor(i_lang, i_prof, io_monit, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        io_monit.flg_monitorization_action := pk_monitorization.g_order_action;
        --create co-sign task
        IF NOT set_cosign(i_lang => i_lang, i_prof => i_prof, io_monit => io_monit, o_error => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- ---- MONITORIZATION DETAIL ----
        FOR i IN 1 .. io_monit.id_vs.count
        LOOP
        
            -- Monitorization Vital Sign (monitorization_vs)
            IF NOT create_monitor_vs(i_lang, i_prof, i, io_monit, next_id_mvs, l_rowids_aux, o_error)
            
            THEN
                RAISE l_exception;
            ELSE
                l_rowids := l_rowids MULTISET UNION DISTINCT l_rowids_aux;
            
                l_id_request.extend;
                l_id_request(l_id_request.count) := next_id_mvs;
                l_id_task.extend;
                l_id_task(l_id_task.count) := io_monit.id_vs(i);
            
            END IF;
        
            -- Monitorization Planning (monitorization_vs_plan)
            IF NOT create_monitor_vs_plan(i_lang, i_prof, next_id_mvs, io_monit, o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        END LOOP;
    
        IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                 i_prof                 => i_prof,
                                 i_episode              => io_monit.id_epis,
                                 i_task_type            => pk_alert_constant.g_task_type_monitorization,
                                 i_task_request         => io_monit.id_monit,
                                 i_task_start_timestamp => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_timestamp => io_monit.dt_begin_final_str,
                                                                                         i_timezone  => NULL),
                                 o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- ---/ END MONITORIZATION DETAIL ----
    
        -- ALERT® Data Governance
    
        l_prof_cat_type := pk_prof_utils.get_category(i_lang, i_prof => i_prof);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION_VS',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => io_monit.id_epis,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => l_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
        
            RETURN FALSE;
        END IF;
    
        IF NOT create_alert_vital_sign(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       i_monitorization => io_monit.id_monit,
                                       o_error          => o_error)
        THEN
            IF l_commit_data
            THEN
                pk_utils.undo_changes;
            END IF;
        
            RETURN FALSE;
        END IF;
    
        pk_icnp_fo_api_db.create_suggs(i_lang               => i_lang,
                                       i_prof               => i_prof,
                                       i_id_episode         => io_monit.id_epis,
                                       i_request_ids        => l_id_request,
                                       i_task_ids           => l_id_task,
                                       i_task_type_id       => pk_alert_constant.g_task_monitoring,
                                       i_sysdate_tstz       => l_sysdate_tstz,
                                       o_id_icnp_sug_interv => l_id_icnp_sug_interv);
    
        IF l_commit_data
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    END create_monitor_req;

    /******************************************************************************
       OBJECTIVO:   Criar requisições de leituras de sinais vitais
       PARAMETROS:  Entrada:  I_LANG - Língua registada como preferência do profissional
                  I_EPISODE - ID do Episódio
                      I_PROF - Profissional que regista a requisição da leitura dos sinais vitais
                  I_DT_BEGIN - Data a partir da qual é pedida a leitura
                  I_INTERVAL - Intervalo de tempo entre leituras
                  I_DT_END - Data até à qual é pedida a leitura dos SV
                  I_NOTES - Notas da requisição
                  I_FLG_TIME - Realização: E - neste episódio;
                                   N - próximo episódio;
                               B - entre episódios
                  I_ID_VS - Array de IDs de sinais vitais
                  I_NOTES_DETAIL - Array de notas de detalhe de requisição de leituras
                 I_PROF_CAT_TYPE - Tipo de categoria do profissional, tal
                           como é retornada em PK_LOGIN.GET_PROF_PREF
                    i_prof_order - id do profissional que pediu a requisição
                    i_dt_order_str - momento em que a ordem foi pedida
                    i_order_type - tipo de ordem (telefone, verbal, etc)    
                    i_commit_data - Flag que indica se a função deve fazer o commit dos dados    
    
              Saida:  O_ID_MONITORIZATION Identificador da monitorização criada 
                      O_ERROR - erro
    
      CRIAÇÃO: RB 2005/05/19
      ALTERAÇÕES: CRS 2005/07/27
                 LG 2007/07/29 Added input vars i_prof_order, i_dt_order, i_order_type
      NOTAS: Se é requisitado p/ fora do episódio, cria agendamento, para facilitar a
           pesquisa pela grelha
    *********************************************************************************/
    FUNCTION create_monitor_req
    (
        i_lang              IN language.id_language%TYPE,
        i_episode           IN monitorization.id_episode%TYPE,
        i_prof              IN profissional,
        i_dt_begin_str      IN VARCHAR2,
        i_interval          IN VARCHAR2,
        i_dt_end_str        IN VARCHAR2,
        i_notes             IN CLOB,
        i_flg_time          IN monitorization.flg_time%TYPE,
        i_id_vs             IN table_number,
        i_notes_detail      IN table_varchar,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_prof_order        IN monitorization_vs.id_prof_order%TYPE := NULL,
        i_dt_order_str      IN VARCHAR2 := NULL,
        i_order_type        IN monitorization_vs.id_order_type%TYPE := NULL,
        i_commit_data       IN VARCHAR2,
        o_id_monitorization OUT monitorization.id_monitorization%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        io_monit monit;
    
    BEGIN
        io_monit := monit(id_monit                  => NULL,
                          id_prof                   => i_prof.id,
                          id_inst                   => i_prof.institution,
                          id_soft                   => i_prof.software,
                          id_epis                   => i_episode,
                          notes                     => i_notes,
                          flg_time                  => i_flg_time,
                          dt_order_str              => i_dt_order_str,
                          dt_begin_str              => i_dt_begin_str,
                          dt_end_str                => i_dt_end_str,
                          dt_begin_final_str        => NULL,
                          INTERVAL                  => i_interval,
                          interval_final            => NULL,
                          id_vs                     => i_id_vs,
                          notes_detail              => i_notes_detail,
                          flg_status                => pk_alert_constant.g_monitor_vs_exec,
                          flg_status_det            => pk_alert_constant.g_monitor_vs_exec,
                          id_order_type             => i_order_type,
                          id_prof_order             => i_prof_order,
                          flg_monitorization_action => pk_monitorization.g_order_action,
                          id_co_sign_order          => NULL,
                          id_co_sign_cancel         => NULL);
    
        IF NOT create_monitor_req(i_lang        => i_lang,
                                  i_prof        => i_prof,
                                  i_commit_data => i_commit_data,
                                  io_monit      => io_monit,
                                  o_error       => o_error)
        THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        END IF;
    
        o_id_monitorization := io_monit.id_monit;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'CREATE_MONITOR_REQ',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END create_monitor_req;

    /**********************************************************************************************
    * It retrieves the id professional that ordered the monitorization
    *
    * @param        id_monitorization        monitorization ID
    *
    * @return       id_professional          professional ID
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 11-Mar-2010
    **********************************************************************************************/

    FUNCTION get_prof_ordered_by(id_monit IN monitorization.id_monitorization%TYPE)
        RETURN professional.id_professional%TYPE IS
    
        id_prof professional.id_professional%TYPE;
    BEGIN
    
        SELECT m.id_prof_order id_professional
          INTO id_prof
          FROM monitorization_vs m
         WHERE m.id_monitorization = id_monit
           AND rownum = 1;
    
        RETURN id_prof;
    
    END get_prof_ordered_by;

    /**********************************************************************************************
    * It retrieves the monitorization professional ID (the prof order or last prof performeced)
    *
    * @param        id_monitorization        monitorization ID
    *
    * @return       id_professional          professional ID
    *                        
    * @author                                Vanessa Barsottelli
    * @version                               1.0
    * @since                                 01-12-2016
    **********************************************************************************************/

    FUNCTION get_monit_prof(i_id_monitorization IN monitorization.id_monitorization%TYPE)
        RETURN professional.id_professional%TYPE IS
    
        l_id_prof professional.id_professional%TYPE;
    BEGIN
    
        SELECT decode(t.flg_status,
                      pk_alert_constant.g_monitor_vs_inte,
                      t.id_prof_cancel,
                      pk_alert_constant.g_monitor_vs_canc,
                      t.id_prof_cancel,
                      nvl(t.id_prof_performed, t.id_professional))
          INTO l_id_prof
          FROM (SELECT m.id_professional,
                       mvsp.id_prof_performed,
                       m.flg_status,
                       m.id_prof_cancel,
                       row_number() over(ORDER BY mvsp.start_time DESC, mvsp.end_time DESC) rn
                  FROM monitorization m
                  JOIN monitorization_vs mvs
                    ON mvs.id_monitorization = m.id_monitorization
                  LEFT JOIN monitorization_vs_plan mvsp
                    ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                   AND mvsp.id_prof_performed IS NOT NULL
                 WHERE m.id_monitorization = i_id_monitorization) t
         WHERE t.rn = 1;
    
        RETURN l_id_prof;
    
    END get_monit_prof;

    /**********************************************************************************************
    * CPOE - Computerized physician order entry
    * This function only is used for CPOE feature without timing filters
    * It retrieves the monitorizations list in order to show in CPOE grid 
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_patient                patient id
    * @param        i_episode                episode id
    * @param        i_task_request           array of task request (if null, return all tasks as usual)
    * @param        i_flg_report             required in all get_task_list APIs
    * @param        o_grid                   array with monitorizations list
    * @param        o_error                  Error message
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 2009/11/18
    **********************************************************************************************/
    FUNCTION get_task_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_patient      IN patient.id_patient%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        i_flg_report   IN VARCHAR2 DEFAULT 'N',
        o_grid         OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN AS
        l_dummy pk_types.cursor_type;
    BEGIN
    
        RETURN get_task_list(i_lang          => i_lang,
                             i_prof          => i_prof,
                             i_patient       => i_patient,
                             i_episode       => i_episode,
                             i_task_request  => i_task_request,
                             i_filter_tstz   => NULL,
                             i_filter_status => NULL,
                             i_flg_report    => i_flg_report,
                             i_dt_begin      => NULL,
                             i_dt_end        => NULL,
                             o_plan_list     => l_dummy,
                             o_grid          => o_grid,
                             o_error         => o_error);
    
    END get_task_list;

    /**********************************************************************************************
    * CPOE - Computerized physician order entry
    * This function only is used for CPOE feature
    * It retrieves the monitorizations list in order to show in CPOE grid with timing filters
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_patient                patient id
    * @param        i_episode                episode id
    * @param        i_task_request           array of task request (if null, return all tasks as usual)
    * @param        i_flg_report             required in all get_task_list APIs
    * @param        o_grid                   array with monitorizations list
    * @param        o_error                  Error message
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 12-Jul-2010
    **********************************************************************************************/
    FUNCTION get_task_list
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_patient       IN patient.id_patient%TYPE,
        i_episode       IN episode.id_episode%TYPE,
        i_task_request  IN table_number,
        i_filter_tstz   IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_filter_status IN table_varchar,
        i_flg_report    IN VARCHAR2 DEFAULT 'N',
        i_dt_begin      IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_dt_end        IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_plan_list     OUT pk_types.cursor_type,
        o_grid          OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_message debug_msg;
        l_exception EXCEPTION;
        l_id_visit     visit.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
    
        g_other_exception EXCEPTION;
    
        l_cancelled_task_filter_interval sys_config.value%TYPE := pk_sysconfig.get_config('CPOE_CANCELLED_TASK_FILTER_INTERVAL',
                                                                                          i_prof);
        l_cancelled_task_filter_tstz     TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
    
        l_cancelled_task_filter_tstz := current_timestamp -
                                        numtodsinterval(to_number(l_cancelled_task_filter_interval), 'DAY');
    
        IF NOT get_visit(i_lang, i_episode, l_id_visit, l_id_epis_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_message := 'GET CURSOR';
        OPEN o_grid FOR
            SELECT task_type,
                   task_description,
                   id_professional,
                   icon_warning,
                   status_string,
                   id_request,
                   start_date_tstz,
                   end_date_tstz,
                   creation_date_tstz,
                   flg_status,
                   flg_cancel,
                   flg_conflict,
                   NULL id_task,
                   --New Fields for CPOE API in Reports
                   --ALERT-202996 (AN)
                   task_title,
                   task_instructions,
                   pk_translation.get_translation_trs(task_notes_code) task_notes,
                   NULL drug_dose,
                   NULL drug_route,
                   NULL drug_take_in_case,
                   task_status,
                   NULL AS instr_bg_color,
                   NULL AS instr_bg_alpha,
                   NULL AS task_icon,
                   pk_alert_constant.g_no AS flg_need_ack,
                   NULL AS edit_icon,
                   NULL AS action_desc,
                   NULL AS previous_status,
                   pk_alert_constant.g_task_monitoring AS id_task_type_source,
                   NULL AS id_task_dependency,
                   decode(flg_status,
                          pk_alert_constant.g_monitor_vs_canc,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_rep_cancel,
                   NULL flg_prn_conditional
              FROM (
                    --retrieve all tasks (in (i_task_request) OR into (i_filter_status AND dt_end >= i_filter_tstz))
                    SELECT DISTINCT pk_alert_constant.g_task_type_monitorization task_type,
                                     concat_monit_vs(i_lang, i_prof, l_id_visit, l_id_epis_type, mea.id_monitorization) ||
                                     decode(i_flg_report,
                                            pk_alert_constant.g_no,
                                            chr(10) || get_monit_instructions(i_lang, i_prof, mea.id_monitorization, 'SIE')) AS task_description,
                                     get_monit_prof(mea.id_monitorization) id_professional,
                                     NULL icon_warning,
                                     -- gets first active monit_vs status string
                                     first_value(pk_utils.get_status_string(i_lang,
                                                                            i_prof,
                                                                            mea.status_str,
                                                                            mea.status_msg,
                                                                            mea.status_icon,
                                                                            mea.status_flg)) over(PARTITION BY mea.id_monitorization ORDER BY decode(mea.flg_status, 'C', 2, 1)) AS status_string,
                                     mea.id_monitorization id_request,
                                     mea.dt_begin start_date_tstz,
                                     mea.dt_end end_date_tstz,
                                     nvl(mea.dt_dg_last_update, mea.dt_order) creation_date_tstz, -- ALERT-283519
                                     mea.flg_status flg_status,
                                     decode(mea.flg_status,
                                            pk_alert_constant.g_monitor_vs_exec,
                                            pk_alert_constant.g_yes,
                                            pk_alert_constant.g_monitor_vs_pend,
                                            pk_alert_constant.g_yes,
                                            pk_alert_constant.g_no) flg_cancel,
                                     pk_alert_constant.g_no flg_conflict,
                                     pk_sysdomain.get_rank(i_lang,
                                                           'MONITORIZATION.FLG_STATUS',
                                                           decode(mea.flg_time,
                                                                  pk_alert_constant.g_flg_time_n,
                                                                  mea.flg_status,
                                                                  decode(mea.flg_status,
                                                                         pk_alert_constant.g_monitor_vs_canc,
                                                                         mea.flg_status,
                                                                         pk_alert_constant.g_monitor_vs_fini,
                                                                         mea.flg_status,
                                                                         decode(least(mea.dt_plan, l_sysdate_tstz),
                                                                                mea.dt_plan,
                                                                                pk_alert_constant.g_monitor_vs_exec,
                                                                                mea.flg_status)))) AS rank,
                                     --New Fields for CPOE API in Reports
                                     --ALERT-202996 (AN)
                                     decode(i_flg_report,
                                            pk_alert_constant.g_yes,
                                            (get_vs_desc(i_lang, m.id_monitorization, i_prof) ||
                                            nvl2(m.id_prev_episode,
                                                  ' - (' || pk_message.get_message(i_lang,
                                                                                   profissional(i_prof.id,
                                                                                                i_prof.institution,
                                                                                                pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                                                   FROM episode e
                                                                                                                                  WHERE e.id_episode =
                                                                                                                                        m.id_prev_episode),
                                                                                                                                 i_prof.institution)),
                                                                                   'IMAGE_T009') || ')',
                                                  '')),
                                            concat_monit_vs(i_lang,
                                                            i_prof,
                                                            l_id_visit,
                                                            l_id_epis_type,
                                                            mea.id_monitorization)) task_title,
                                     decode(i_flg_report,
                                            pk_alert_constant.g_yes,
                                            get_interval_desc(i_lang, i_prof, m.id_monitorization)) task_instructions,
                                     decode(i_flg_report, pk_alert_constant.g_yes, mvs.code_notes) task_notes_code,
                                     decode(i_flg_report,
                                            pk_alert_constant.g_yes,
                                            pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS', m.flg_status, i_lang)) task_status
                      FROM monitorizations_ea mea
                     INNER JOIN episode epi
                        ON mea.id_episode = epi.id_episode
                     INNER JOIN monitorization m
                        ON mea.id_monitorization = m.id_monitorization
                     INNER JOIN monitorization_vs mvs
                        ON m.id_monitorization = mvs.id_monitorization
                     WHERE epi.id_visit = l_id_visit
                       AND (mea.id_monitorization IN (SELECT *
                                                        FROM TABLE(i_task_request)) OR i_task_request IS NULL)
                       AND (i_task_request IS NULL OR
                           mea.id_monitorization IN (SELECT /*+ OPT_ESTIMATE (TABLE d ROWS=1)*/
                                                       d.column_value
                                                        FROM TABLE(i_task_request) d))
                       AND (mea.flg_status NOT IN (SELECT /*+ OPT_ESTIMATE (TABLE t ROWS=1)*/
                                                    t.column_value
                                                     FROM TABLE(i_filter_status) t) OR
                           (mea.dt_end > i_filter_tstz AND m.dt_cancel_tstz IS NULL) OR
                           (m.dt_cancel_tstz IS NOT NULL AND m.dt_cancel_tstz > l_cancelled_task_filter_tstz))
                    UNION ALL
                    -- retrieve drafts
                    SELECT t.task_type,
                            t.task_description,
                            t.id_professional,
                            t.icon_warning,
                            pk_utils.get_status_string_immediate(i_lang,
                                                                 i_prof,
                                                                 pk_alert_constant.g_display_type_icon,
                                                                 t.flg_status,
                                                                 NULL,
                                                                 NULL,
                                                                 'MONITORIZATION.FLG_STATUS',
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 NULL,
                                                                 l_sysdate_tstz) AS status_string,
                            t.id_request,
                            t.start_date_tstz,
                            t.end_date_tstz,
                            t.creation_date_tstz,
                            t.flg_status,
                            t.flg_cancel,
                            t.flg_conflict,
                            t.rank,
                            t.task_title,
                            t.task_instructions,
                            t.task_notes_code,
                            t.task_status
                      FROM (SELECT DISTINCT pk_alert_constant.g_task_type_monitorization task_type,
                                             concat_monit_vs(i_lang,
                                                             i_prof,
                                                             l_id_visit,
                                                             l_id_epis_type,
                                                             m.id_monitorization) ||
                                             decode(i_flg_report,
                                                    pk_alert_constant.g_no,
                                                    chr(10) ||
                                                    get_monit_instructions(i_lang, i_prof, m.id_monitorization, 'SIE')) AS task_description,
                                             nvl(get_prof_ordered_by(m.id_monitorization), m.id_professional) id_professional,
                                             NULL icon_warning,
                                             m.id_monitorization id_request,
                                             m.dt_begin_tstz start_date_tstz,
                                             m.dt_end_tstz end_date_tstz,
                                             m.dt_monitorization_tstz creation_date_tstz,
                                             m.flg_status flg_status,
                                             decode(m.flg_status,
                                                    pk_alert_constant.g_monitor_vs_exec,
                                                    pk_alert_constant.g_yes,
                                                    pk_alert_constant.g_monitor_vs_pend,
                                                    pk_alert_constant.g_yes,
                                                    pk_alert_constant.g_no) flg_cancel,
                                             decode(validate_monitor_req2(i_lang, i_prof, m.id_monitorization),
                                                    pk_alert_constant.g_yes,
                                                    pk_alert_constant.g_yes,
                                                    -- verify if dt_end is lower than current timestamp (conflict verified just for draft monits)
                                                    decode(pk_date_utils.compare_dates_tsz(i_prof,
                                                                                           m.dt_end_tstz,
                                                                                           l_sysdate_tstz),
                                                           pk_alert_constant.g_date_lower,
                                                           pk_alert_constant.g_yes,
                                                           pk_alert_constant.g_no)) flg_conflict,
                                             pk_sysdomain.get_rank(i_lang,
                                                                   'MONITORIZATION.FLG_STATUS',
                                                                   decode(m.flg_time,
                                                                          pk_alert_constant.g_flg_time_n,
                                                                          m.flg_status,
                                                                          decode(m.flg_status,
                                                                                 pk_alert_constant.g_monitor_vs_canc,
                                                                                 m.flg_status,
                                                                                 pk_alert_constant.g_monitor_vs_fini,
                                                                                 m.flg_status))) AS rank,
                                             --New Fields for CPOE API in Reports
                                             --ALERT-202996 (AN)
                                             decode(i_flg_report,
                                                    pk_alert_constant.g_yes,
                                                    (get_vs_desc(i_lang, m.id_monitorization, i_prof) ||
                                                    nvl2(m.id_prev_episode,
                                                          ' - (' || pk_message.get_message(i_lang,
                                                                                           profissional(i_prof.id,
                                                                                                        i_prof.institution,
                                                                                                        pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                                                           FROM episode e
                                                                                                                                          WHERE e.id_episode =
                                                                                                                                                m.id_prev_episode),
                                                                                                                                         i_prof.institution)),
                                                                                           'IMAGE_T009') || ')',
                                                          '')),
                                                    concat_monit_vs(i_lang,
                                                                    i_prof,
                                                                    l_id_visit,
                                                                    l_id_epis_type,
                                                                    m.id_monitorization)) task_title,
                                             decode(i_flg_report,
                                                    pk_alert_constant.g_yes,
                                                    get_interval_desc(i_lang, i_prof, m.id_monitorization)) task_instructions,
                                             decode(i_flg_report, pk_alert_constant.g_yes, mvs.code_notes) task_notes_code,
                                             decode(i_flg_report,
                                                    pk_alert_constant.g_yes,
                                                    pk_sysdomain.get_domain('MONITORIZATION.FLG_STATUS',
                                                                            m.flg_status,
                                                                            i_lang)) task_status
                               FROM monitorization m
                              INNER JOIN episode e
                                 ON e.id_episode = m.id_episode
                              INNER JOIN monitorization_vs mvs
                                 ON m.id_monitorization = mvs.id_monitorization
                              WHERE e.id_visit = l_id_visit
                                AND (m.id_monitorization IN (SELECT *
                                                               FROM TABLE(i_task_request)) OR i_task_request IS NULL)
                                AND m.flg_status = pk_alert_constant.g_monitor_vs_draft) t)
            
             ORDER BY rank, start_date_tstz;
    
        IF i_flg_report = pk_alert_constant.g_yes
        THEN
        
            IF NOT get_order_plan_report(i_lang          => i_lang,
                                         i_prof          => i_prof,
                                         i_episode       => i_episode,
                                         i_task_request  => i_task_request,
                                         i_cpoe_dt_begin => i_dt_begin,
                                         i_cpoe_dt_end   => i_dt_end,
                                         o_plan_rep      => o_plan_list,
                                         o_error         => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_TASK_LIST',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_grid);
            RETURN FALSE;
    END get_task_list;

    /**********************************************************************************************
    * It retrieves the monitorization VS details (CPOE purpose) 
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_monitorization         monitorization id
    * @param        o_monit_vs               array with monitorizations vs list
    * @param        o_error                  Error message
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               2.5.0.7.5
    * @since                                 2009/12/04
    **********************************************************************************************/
    FUNCTION get_monit_vs_det
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_monitorization IN monitorization.id_monitorization%TYPE,
        o_monit_vs       OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        OPEN o_monit_vs FOR
            SELECT mvs.id_monitorization_vs, mvs.id_monitorization, mvs.id_vital_sign, mvs.flg_status
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = i_monitorization;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_MONIT_VS_DET',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_monit_vs);
            RETURN FALSE;
    END get_monit_vs_det;

    /*
    * Provide list of ongoing MONITORIZATION tasks for the patient death feature. All the monits in this list must be possible to cancel.
    *
    * @param   I_LANG               language associated to the professional executing the request
    * @param   I_PROF               Professional type
    * @param   I_ID_PATIENT         Patient ID
    *
    * @RETURN  tf_tasks_list (table of tr_tasks_list)
    * @author  Rui de Sousa Neves
    * @version 2.6.0.3
    * @since   11-MAY-2010
    *
    */
    FUNCTION get_ongoing_tasks_monit
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN patient.id_patient%TYPE
    ) RETURN tf_tasks_list IS
    
        t tf_tasks_list;
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'get_ongoing_tasks_monit';
    
        l_dbg_msg debug_msg;
    
    BEGIN
    
        l_dbg_msg := 'SELECT';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        SELECT tr_tasks_list(id_task, desc_task, epis_type, dt_task)
          BULK COLLECT
          INTO t
          FROM (SELECT m.id_monitorization id_task,
                       pk_monitorization.concat_monit_vs(i_lang,
                                                         i_prof,
                                                         epi.id_visit,
                                                         epi.id_epis_type,
                                                         m.id_monitorization) desc_task,
                       pk_translation.get_translation(i_lang, et.code_epis_type) epis_type,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, m.dt_monitorization_tstz, i_prof) dt_task
                  FROM monitorization m
                 INNER JOIN episode epi
                    ON epi.id_episode = m.id_episode
                 INNER JOIN epis_type et
                    ON et.id_epis_type = epi.id_epis_type
                 WHERE epi.id_patient = i_id_patient
                      -- status canceled or interrupted are already canceled. Finished are also not suspendable.
                   AND m.flg_status NOT IN (pk_alert_constant.g_monitor_vs_canc,
                                            pk_alert_constant.g_monitor_vs_inte,
                                            pk_alert_constant.g_monitor_vs_fini,
                                            pk_alert_constant.g_monitor_vs_draft)
                 ORDER BY dt_task DESC);
    
        RETURN t;
    
    END get_ongoing_tasks_monit;

    /*
    * Provide list of MONITORIZATION tasks for a given status
    *
    * @param   I_LANG               language associated to the professional executing the request
    * @param   I_PROF               Professional type
    * @param   I_ID_SUSP_ACTION     Corresponding ID_SUSP_ACTION
    * @param   I_WF_STATUS          Status for tasks
    *
    * @RETURN  tf_tasks_list (table of tr_tasks_list)
    * @author  Rui de Sousa Neves
    * @version 2.6.0.3
    * @since   18-MAY-2010
    *
    */
    FUNCTION get_wfstatus_tasks_monit
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_susp_action IN susp_task.id_susp_action%TYPE,
        i_wfstatus       IN susp_task.flg_status%TYPE
    ) RETURN tf_tasks_react_list IS
    
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'get_wfstatus_tasks_monit';
        t tf_tasks_react_list;
        l_code_epis_type CONSTANT VARCHAR2(30 CHAR) := 'EPIS_TYPE.CODE_EPIS_TYPE.';
    
        l_dbg_msg debug_msg;
    
    BEGIN
    
        l_dbg_msg := 'SELECT';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        SELECT tr_tasks_react_list(id_task, id_susp_task, desc_task, epis_type, dt_task)
          BULK COLLECT
          INTO t
          FROM (SELECT stm.id_monitorization id_task,
                       st.id_susp_task,
                       pk_monitorization.concat_monit_vs(i_lang,
                                                         i_prof,
                                                         e.id_visit,
                                                         e.id_epis_type,
                                                         stm.id_monitorization) desc_task,
                       pk_translation.get_translation(i_lang, l_code_epis_type || e.id_epis_type) epis_type,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, m.dt_monitorization_tstz, i_prof) dt_task
                  FROM susp_task st
                 INNER JOIN susp_task_monitoring stm
                    ON stm.id_susp_task = st.id_susp_task
                 INNER JOIN monitorization m
                    ON m.id_monitorization = stm.id_monitorization
                 INNER JOIN episode e
                    ON m.id_episode = e.id_episode
                 WHERE st.id_susp_action = i_id_susp_action
                   AND st.flg_status = i_wfstatus
                 ORDER BY dt_task DESC);
    
        RETURN t;
    
    END get_wfstatus_tasks_monit;

    /*
    * Suspend the ongoing tasks - Monitorization
    *
    * @param   I_LANG               language associated to the professional executing the request
    * @param   I_PROF               Professional type
    * @param   I_TASK               ID from the corresponding task
    * @param   I_FLG_REASON         Reason for the WF suspension: 'D' (Death)
    * @param   O_MSG_ERROR          Message to send to the UX in case one of the functions has some kind of error
    * @param   O_ERROR              warning/error message
    *
    * @RETURN  TRUE if success, FALSE otherwise
    * @author  Rui de Sousa Neves
    * @version 2.6.0.3
    * @since   13-MAY-2010
    *
    */
    FUNCTION suspend_task_monit
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_task       IN NUMBER,
        i_flg_reason IN VARCHAR2,
        o_msg_error  OUT VARCHAR2,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'suspend_task_monit';
        l_dbg_msg debug_msg;
    
        l_mess_error CONSTANT sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                      i_code_mess => 'MONITOR_M011');
        l_prof_cat_type  category.flg_type%TYPE;
        l_flg_status     monitorization.flg_status%TYPE;
        l_flg_status_arr table_varchar;
        l_id_monit_arr   table_number;
        l_flg_status_mvp monitorization_vs_plan.flg_status%TYPE;
        l_id_monit_mvp   monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_rows           table_varchar := table_varchar();
    
        CURSOR c_monit(pin_id_monit monitorization.id_monitorization%TYPE) IS
            SELECT m.flg_status
              FROM monitorization m
             WHERE m.id_monitorization = pin_id_monit;
    
        CURSOR c_monit_vs(pin_id_monit monitorization.id_monitorization%TYPE) IS
            SELECT mvs.flg_status, mvs.id_monitorization_vs
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = pin_id_monit;
    
        CURSOR c_monit_vs_plan(pin_id_monit monitorization_vs.id_monitorization_vs%TYPE) IS
            SELECT mvp.flg_status, mvp.id_monitorization_vs_plan
              FROM monitorization_vs_plan mvp
             WHERE mvp.id_monitorization_vs = pin_id_monit;
    
    BEGIN
    
        l_dbg_msg := 'CASE I_FLG_REASON';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        -- Saves on FLG_STATUS_PREV the last FLG_STATUS before cancelling the event on tables: monitorization, monitorization_vs, monitorization_vs_plan  
        l_dbg_msg := 'OPEN c_monit';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        OPEN c_monit(i_task);
        FETCH c_monit
            INTO l_flg_status;
        CLOSE c_monit;
    
        -- Updates Flg_status on Monitorization
        l_dbg_msg := 'UPD flg_status_prev Monitorization';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        ts_monitorization.upd(id_monitorization_in => i_task, flg_status_prev_in => l_flg_status, rows_out => l_rows);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rows,
                                      o_error      => o_error);
        -- gets all monitorization_vs for a certain monitorization
        l_dbg_msg := 'OPEN c_monit_vs';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        OPEN c_monit_vs(i_task);
        FETCH c_monit_vs BULK COLLECT
            INTO l_flg_status_arr, l_id_monit_arr;
        CLOSE c_monit_vs;
    
        -- runs every monitorization_vs
        l_dbg_msg := 'FOR i IN 1 .. l_flg_status_arr.COUNT';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        FOR i IN 1 .. l_flg_status_arr.count
        LOOP
        
            -- Updates Flg_status on Monitorization_vs
            l_dbg_msg := 'UPD flg_status_prev Monitorization Vital Sign';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            ts_monitorization_vs.upd(id_monitorization_vs_in => l_id_monit_arr(i),
                                     flg_status_prev_in      => l_flg_status_arr(i),
                                     rows_out                => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        
            -- gets monitorization_vs_plan for a certain monitorization_vs
            l_dbg_msg := 'OPEN c_monit_vs_plan';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            OPEN c_monit_vs_plan(l_id_monit_arr(i));
            FETCH c_monit_vs_plan
                INTO l_flg_status_mvp, l_id_monit_mvp;
            CLOSE c_monit_vs_plan;
        
            -- Updates Flg_status on Monitorization_vs_plan
            l_dbg_msg := 'UPD flg_status_prev Monitorization Plan';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            ts_monitorization_vs_plan.upd(id_monitorization_vs_plan_in => l_id_monit_mvp,
                                          flg_status_prev_in           => l_flg_status_mvp,
                                          rows_out                     => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS_PLAN',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        END LOOP;
    
        -- get professional category
        l_dbg_msg := 'GET Category';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        l_prof_cat_type := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
    
        -- cancel monitorization
        l_dbg_msg := 'CANCEL Monitorization';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        IF NOT pk_monitorization.cancel_monitor_req(i_lang              => i_lang,
                                                    i_id_monitorization => i_task,
                                                    i_prof              => i_prof,
                                                    i_prof_cat_type     => l_prof_cat_type,
                                                    i_notes             => NULL,
                                                    i_commit_data       => pk_alert_constant.g_no,
                                                    i_id_cancel_reason  => pk_cancel_reason.c_reason_patient_death,
                                                    o_error             => o_error)
        THEN
            -- returns error message
            o_msg_error := REPLACE(l_mess_error,
                                   '@1',
                                   pk_monitorization.get_vs_desc(i_lang           => i_lang,
                                                                 i_monitorization => i_task,
                                                                 i_prof           => i_prof));
            l_dbg_msg   := 'ERROR CANCEL Monitorization ' || o_msg_error;
            pk_alertlog.log_error(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    END suspend_task_monit;

    /*
    * Reactivate the ongoing tasks - Monitorization
    *
    * @param   I_LANG               language associated to the professional executing the request
    * @param   I_PROF               Professional type
    * @param   I_TASK               ID from the corresponding task
    * @param   O_MSG_ERROR          Message to send to the UX in case one of the functions has some kind of error
    * @param   O_ERROR              warning/error message
    *
    * @RETURN  TRUE if success, FALSE otherwise
    * @author  Rui de Sousa Neves
    * @version 2.6.0.3
    * @since   21-MAY-2010
    *
    */
    FUNCTION reactivate_task_monit
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_task      IN NUMBER,
        o_msg_error OUT VARCHAR2,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'reactivate_task_monit';
        l_dbg_msg debug_msg;
    
        l_sysdate_tstz CONSTANT TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        l_mess_error CONSTANT sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                      i_code_mess => 'MONITOR_M012');
        l_prof_cat_type   category.flg_type%TYPE;
        l_flg_status      monitorization.flg_status%TYPE;
        l_flg_status_arr  table_varchar;
        l_id_monit_vs_arr table_number;
        l_flg_status_mvp  monitorization_vs_plan.flg_status%TYPE;
        l_id_monit_mvp    monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_id_episode      episode.id_episode%TYPE;
        l_dt_begin_str    VARCHAR2(100);
        l_dt_end_str      VARCHAR2(100);
        l_notes           CLOB;
        l_flg_time        monitorization.flg_time%TYPE;
        l_interval        monitorization.interval%TYPE;
        l_prof            monitorization.id_professional%TYPE;
        l_notes_arr       table_varchar;
        l_rows            table_varchar := table_varchar();
        l_mvs             monitorization_vs%ROWTYPE;
    
        CURSOR c_monit(pin_id_monit monitorization.id_monitorization%TYPE) IS
            SELECT m.flg_status_prev,
                   m.id_episode,
                   m.dt_begin_tstz,
                   m.dt_end_tstz,
                   pk_translation.get_translation_trs(m.code_notes) notes,
                   m.flg_time,
                   m.interval,
                   m.id_professional
              FROM monitorization m
             WHERE m.id_monitorization = pin_id_monit;
    
        CURSOR c_monit_vs(pin_id_monit monitorization.id_monitorization%TYPE) IS
            SELECT mvs.flg_status_prev,
                   mvs.id_monitorization_vs,
                   pk_translation.get_translation_trs(mvs.code_notes) notes
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization = pin_id_monit;
    
        CURSOR c_monit_vs_plan(pin_id_monit monitorization_vs.id_monitorization_vs%TYPE) IS
            SELECT mvp.flg_status_prev, mvp.id_monitorization_vs_plan
              FROM monitorization_vs_plan mvp
             WHERE mvp.id_monitorization_vs = pin_id_monit;
    
    BEGIN
    
        -- Puts FLG_STATUS_PREV as FLG_STATUS on the following tables: MONITORIZATION, MONITORIZATION_VS_PLAN and MONITORIZATION_VS.  
        l_dbg_msg := 'OPEN c_monit';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        OPEN c_monit(i_task);
        FETCH c_monit
            INTO l_flg_status, l_id_episode, l_dt_begin_str, l_dt_end_str, l_notes, l_flg_time, l_interval, l_prof;
        CLOSE c_monit;
    
        -- updates flg_status on monitorization
        l_dbg_msg := 'UPD flg_status Monitorization';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        ts_monitorization.upd(id_monitorization_in => i_task,
                              flg_status_in        => l_flg_status,
                              id_prof_cancel_in    => NULL,
                              id_prof_cancel_nin   => FALSE,
                              dt_cancel_tstz_in    => NULL,
                              dt_cancel_tstz_nin   => FALSE,
                              rows_out             => l_rows);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'MONITORIZATION',
                                      i_rowids     => l_rows,
                                      o_error      => o_error);
        -- gets all monitorization_vs for a certain monitorization
        l_dbg_msg := 'OPEN c_monit_vs';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        OPEN c_monit_vs(i_task);
        FETCH c_monit_vs BULK COLLECT
            INTO l_flg_status_arr, l_id_monit_vs_arr, l_notes_arr;
        CLOSE c_monit_vs;
    
        l_dbg_msg := 'FOR';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
    
        FOR i IN 1 .. l_id_monit_vs_arr.count
        LOOP
        
            -- updates flg_status on monitorization_vs
            l_dbg_msg := 'UPD flg_status Monitorization Vital Sign';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
            ts_monitorization_vs.upd(id_monitorization_vs_in => l_id_monit_vs_arr(i),
                                     flg_status_in           => l_flg_status_arr(i),
                                     id_prof_cancel_in       => NULL,
                                     id_prof_cancel_nin      => FALSE,
                                     dt_cancel_tstz_in       => NULL,
                                     dt_cancel_tstz_nin      => FALSE,
                                     rows_out                => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
            -- gets all monitorization_vs_plan for a certain monitorization_vs
            l_dbg_msg := 'OPEN c_monit_vs_plan';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            OPEN c_monit_vs_plan(l_id_monit_vs_arr(i));
            FETCH c_monit_vs_plan
                INTO l_flg_status_mvp, l_id_monit_mvp;
            CLOSE c_monit_vs_plan;
        
            -- updates flg_status on monitorization_vs_plan
            l_dbg_msg := 'UPD flg_status Monitorization Planning';
            alertlog.pk_alertlog.log_info(text            => l_dbg_msg,
                                          object_name     => c_package_name,
                                          sub_object_name => l_func_name);
        
            ts_monitorization_vs_plan.upd(id_monitorization_vs_plan_in => l_id_monit_mvp,
                                          flg_status_in                => l_flg_status_mvp,
                                          rows_out                     => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'MONITORIZATION_VS_PLAN',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        
            SELECT mvs.*
              INTO l_mvs
              FROM monitorization_vs mvs
             WHERE mvs.id_monitorization_vs = l_id_monit_vs_arr(i);
        
        END LOOP;
    
        -- CPOE synch
        l_dbg_msg := 'CPOE SYNC';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                 i_prof                 => i_prof,
                                 i_episode              => l_id_episode,
                                 i_task_type            => pk_alert_constant.g_task_type_monitorization,
                                 i_task_request         => i_task,
                                 i_task_start_timestamp => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_timestamp => l_dt_begin_str,
                                                                                         i_timezone  => NULL),
                                 o_error                => o_error)
        THEN
            o_msg_error := REPLACE(l_mess_error,
                                   '@1',
                                   pk_monitorization.get_vs_desc(i_lang           => i_lang,
                                                                 i_monitorization => i_task,
                                                                 i_prof           => i_prof));
            l_dbg_msg   := 'ERROR CPOE SYNCH ' || o_msg_error;
            pk_alertlog.log_error(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        
            RETURN FALSE;
        END IF;
    
        -- updates set_first_obs
        l_dbg_msg := 'SET First OBS';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        l_prof_cat_type := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_id_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => l_prof_cat_type,
                                      i_dt_last_interaction => l_sysdate_tstz,
                                      i_dt_first_obs        => l_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            o_msg_error := REPLACE(l_mess_error,
                                   '@1',
                                   pk_monitorization.get_vs_desc(i_lang           => i_lang,
                                                                 i_monitorization => i_task,
                                                                 i_prof           => i_prof));
            l_dbg_msg   := 'ERROR SET First OBS' || o_msg_error;
            pk_alertlog.log_error(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
            RETURN FALSE;
        END IF;
    
        -- updates alerts
        l_dbg_msg := 'UPD Alerts';
        alertlog.pk_alertlog.log_info(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        IF NOT
            create_alert_vital_sign(i_lang => i_lang, i_prof => i_prof, i_monitorization => i_task, o_error => o_error)
        THEN
            o_msg_error := REPLACE(l_mess_error,
                                   '@1',
                                   pk_monitorization.get_vs_desc(i_lang           => i_lang,
                                                                 i_monitorization => i_task,
                                                                 i_prof           => i_prof));
            l_dbg_msg   := 'ERROR UPD Alerts' || o_msg_error;
            pk_alertlog.log_error(text => l_dbg_msg, object_name => c_package_name, sub_object_name => l_func_name);
        
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    END reactivate_task_monit;

    /**********************************************************************************************
    *
    * This function only is used for CPOE feature
    * get tasks status based in their request
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_episode                episode id
    * @param        i_task_request           array of task request
    * @param        o_task_status            cursor with all requested tast status
    * @param        o_error                  error structure for exception handling
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 14-Sep-2010
    **********************************************************************************************/
    FUNCTION get_task_status
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN table_number,
        o_task_status  OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
        l_exception EXCEPTION;
        l_id_visit     visit.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
    
    BEGIN
        IF NOT get_visit(i_lang, i_episode, l_id_visit, l_id_epis_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_message := 'GET CURSOR o_task_status';
        OPEN o_task_status FOR
            SELECT DISTINCT pk_alert_constant.g_task_type_monitorization task_type,
                            mea.id_monitorization                        id_request,
                            mea.flg_status                               flg_status
              FROM monitorizations_ea mea, episode epi
             WHERE mea.id_episode = epi.id_episode
               AND epi.id_visit = l_id_visit
               AND (mea.id_monitorization IN (SELECT *
                                                FROM TABLE(i_task_request)) OR i_task_request IS NULL)
            UNION ALL
            -- retrieve drafts
            SELECT pk_alert_constant.g_task_type_monitorization task_type,
                   m.id_monitorization                          id_request,
                   m.flg_status                                 flg_status
              FROM monitorization m
             INNER JOIN episode e
                ON e.id_episode = m.id_episode
             WHERE e.id_visit = l_id_visit
               AND (m.id_monitorization IN (SELECT *
                                              FROM TABLE(i_task_request)) OR i_task_request IS NULL)
               AND m.flg_status = pk_alert_constant.g_monitor_vs_draft;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'GET_TASK_STATUS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_task_status);
            RETURN FALSE;
    END get_task_status;

    /**********************************************************************************************
    * 
    * This function only is used for CPOE feature
    * cancel all draft tasks
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_episode                episode id
    * @param        o_error                  error structure for exception handling
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Filipe Machado
    * @version                               1.0
    * @since                                 14-Sep-2010
    **********************************************************************************************/
    FUNCTION cancel_all_drafts
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
        l_id_visit     visit.id_visit%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
        l_message      debug_msg;
    
        CURSOR c_drafts(i_visit episode.id_visit%TYPE) IS
            SELECT m.id_monitorization
              FROM monitorization m
              JOIN episode e
                ON e.id_episode = m.id_episode
             WHERE m.flg_status = pk_alert_constant.g_monitor_vs_draft
               AND e.id_visit = i_visit;
    
        l_monit_drafts table_number;
    
    BEGIN
        IF NOT get_visit(i_lang, i_episode, l_id_visit, l_id_epis_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        l_message := 'cursor cancel_all_drafts';
        pk_alertlog.log_debug(l_message, c_package_name);
    
        OPEN c_drafts(l_id_visit);
        FETCH c_drafts BULK COLLECT
            INTO l_monit_drafts;
        CLOSE c_drafts;
    
        IF l_monit_drafts.count > 0
        THEN
            IF NOT cancel_draft(i_lang    => i_lang,
                                i_prof    => i_prof,
                                i_episode => i_episode,
                                i_draft   => l_monit_drafts,
                                o_error   => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'CANCEL_ALL_DRAFTS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_all_drafts;

    /**********************************************************************************************
    * Returns information about a given request
    *
    * @param i_lang                  Language ID
    * @param i_prof                  Professional
    * @param i_id_request            Request ID
    * @param o_description           Description
    * @param o_instructions          Instructions
    * @param o_flg_status            Flg_status
    *                        
    * @author                        Filipe Machado
    * @version                       v2.5.1.3
    * @since                         02-Feb-2011
    **********************************************************************************************/
    PROCEDURE get_therapeutic_status
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_request   IN NUMBER,
        o_description  OUT VARCHAR2,
        o_instructions OUT VARCHAR2,
        o_flg_status   OUT VARCHAR2
    ) IS
    BEGIN
    
        SELECT pk_vital_sign.get_vs_desc(i_lang, mvs.id_vital_sign),
               get_instructions(i_lang, i_prof, mvs.id_monitorization_vs),
               decode(mvs.flg_status,
                      pk_alert_constant.g_monitor_vs_canc,
                      pk_alert_constant.g_no,
                      decode(mvs.flg_status,
                             pk_alert_constant.g_monitor_vs_inte,
                             pk_alert_constant.g_no,
                             pk_alert_constant.g_yes),
                      pk_alert_constant.g_yes)
          INTO o_description, o_instructions, o_flg_status
          FROM monitorization_vs mvs
          JOIN monitorization m
            ON m.id_monitorization = mvs.id_monitorization
         WHERE mvs.id_monitorization_vs = i_id_request;
    END get_therapeutic_status;

    /**********************************************************************************************
    * Returns the instructions for a procedure request according to the passed format, using 
    * combinations of the following values: T (type), N (requirement date), I (interval), S 
    * (start date), E (end date).
    *
    * @param i_lang                ID language
    * @param i_prof                Professional
    * @param i_id_monit_vs         Moniutorization_vs ID
    * @param i_format              Output string format (optional)
    *
    * @return                      Instructions for this monitoring
    *                        
    * @author                      Filipe Machado
    * @version                     2.5.1.3
    * @since                       02-Feb-2011
    **********************************************************************************************/
    FUNCTION get_instructions
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_id_monit_vs IN monitorization_vs.id_monitorization_vs%TYPE,
        i_format      IN VARCHAR2 DEFAULT 'TNISE'
    ) RETURN VARCHAR2 IS
        l_type     VARCHAR2(4000);
        l_interval VARCHAR2(4000);
        l_start    VARCHAR2(4000);
        l_end      VARCHAR2(4000);
        l_ret      VARCHAR2(4000);
        l_req      VARCHAR2(4000);
    
        l_void VARCHAR2(3) := '---';
    
        l_interval_mess VARCHAR2(4000);
        l_dt_start_mess VARCHAR2(4000);
        l_dt_end_mess   VARCHAR2(4000);
        l_dt_req_mess   VARCHAR2(4000);
    
        PROCEDURE add_to_ret
        (
            i_add      IN VARCHAR2,
            i_original IN OUT VARCHAR2
        ) IS
        BEGIN
            IF i_original IS NULL
            THEN
                i_original := i_add;
            ELSE
                i_original := i_original || '; ' || nvl(i_add, l_void);
            END IF;
        END add_to_ret;
    
    BEGIN
    
        l_dt_start_mess := pk_message.get_message(i_lang, i_prof, 'MONITOR_T002');
        l_dt_end_mess   := pk_message.get_message(i_lang, i_prof, 'MONITOR_T004');
        l_interval_mess := pk_message.get_message(i_lang, i_prof, 'MONITOR_T003');
        l_dt_req_mess   := pk_message.get_message(i_lang, i_prof, 'MONITOR_T012');
    
        SELECT DISTINCT pk_vital_sign.get_vs_desc(i_lang, mvs.id_vital_sign) desc_vs,
                        (pk_date_utils.date_char_hour_tsz(i_lang,
                                                          mvs.dt_monitorization_vs_tstz,
                                                          i_prof.institution,
                                                          i_prof.software) || ' ' ||
                        pk_date_utils.dt_chr_tsz(i_lang, mvs.dt_monitorization_vs_tstz, i_prof)) dt_req,
                        
                        (decode(m.flg_time,
                                pk_alert_constant.g_flg_time_n,
                                pk_message.get_message(i_lang, 'COMMON_M018'),
                                pk_date_utils.date_char_hour_tsz(i_lang,
                                                                 nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                                 i_prof.institution,
                                                                 i_prof.software)) || ' ' ||
                        decode(m.flg_time,
                                pk_alert_constant.g_flg_time_n,
                                NULL,
                                pk_date_utils.dt_chr_tsz(i_lang, nvl(m.dt_begin_tstz, m.dt_monitorization_tstz), i_prof))) dt_begin,
                        
                        (decode(m.flg_time,
                                pk_alert_constant.g_flg_time_n,
                                pk_message.get_message(i_lang, 'COMMON_M018'),
                                pk_date_utils.date_char_hour_tsz(i_lang,
                                                                 m.dt_end_tstz,
                                                                 i_prof.institution,
                                                                 i_prof.software)) || ' ' ||
                        decode(m.flg_time,
                                pk_alert_constant.g_flg_time_n,
                                NULL,
                                pk_date_utils.dt_chr_tsz(i_lang, m.dt_end_tstz, i_prof))) dt_end,
                        get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval
          INTO l_type, l_req, l_start, l_end, l_interval
          FROM monitorization m, monitorization_vs mvs, monitorization_vs_plan mvsp
         WHERE m.id_monitorization = mvs.id_monitorization
           AND mvs.id_monitorization_vs = i_id_monit_vs
           AND mvs.id_monitorization_vs = mvs.id_monitorization_vs
           AND mvs.id_monitorization_vs = mvsp.id_monitorization_vs;
    
        FOR i IN 1 .. length(i_format)
        LOOP
            CASE substr(i_format, i, 1)
                WHEN 'T' THEN
                    add_to_ret(l_type, l_ret);
                WHEN 'N' THEN
                    add_to_ret(l_dt_req_mess || ': ' || l_req, l_ret);
                WHEN 'I' THEN
                    add_to_ret(l_interval_mess || ': ' || l_interval, l_ret);
                WHEN 'S' THEN
                    add_to_ret(l_dt_start_mess || ': ' || l_start, l_ret);
                WHEN 'E' THEN
                    IF l_end IS NOT NULL
                    THEN
                        add_to_ret(l_dt_end_mess || ': ' || l_end, l_ret);
                    END IF;
                ELSE
                    NULL;
            END CASE;
        END LOOP;
    
        RETURN l_ret;
    END get_instructions;

    /**********************************************************************************************
    * Returns the instructions for a monitorization request according to the passed format, using 
    * combinations of the following values: N (requirement date), I (interval), S 
    * (start date), E (end date).
    *
    * @param i_lang                ID language
    * @param i_prof                Professional
    * @param i_id_monit            Monitorization ID
    * @param i_format              Output string format (optional)
    *
    * @return                      Instructions for this monitoring
    *                        
    * @author                      Tiago silva
    * @since                       19-Sep-2014
    **********************************************************************************************/
    FUNCTION get_monit_instructions_clob
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_id_monit IN monitorization.id_monitorization%TYPE,
        i_format   IN VARCHAR2 DEFAULT 'NISE'
    ) RETURN CLOB IS
        l_interval VARCHAR2(4000);
        l_start    VARCHAR2(4000);
        l_end      VARCHAR2(4000);
        l_ret      CLOB;
        l_req      VARCHAR2(4000);
    
        l_void VARCHAR2(3) := '---';
    
        l_interval_mess VARCHAR2(4000);
        l_dt_start_mess VARCHAR2(4000);
        l_dt_end_mess   VARCHAR2(4000);
        l_dt_req_mess   VARCHAR2(4000);
    
        PROCEDURE add_to_ret
        (
            i_add      IN CLOB,
            i_original IN OUT CLOB
        ) IS
        BEGIN
            IF i_original IS NULL
            THEN
                i_original := i_add;
            ELSE
                i_original := i_original || '; ' || nvl(i_add, l_void);
            END IF;
        END add_to_ret;
    
    BEGIN
    
        l_dt_start_mess := pk_message.get_message(i_lang, i_prof, 'MONITOR_T002');
        l_dt_end_mess   := pk_message.get_message(i_lang, i_prof, 'MONITOR_T004');
        l_interval_mess := pk_message.get_message(i_lang, i_prof, 'MONITOR_T003');
        l_dt_req_mess   := pk_message.get_message(i_lang, i_prof, 'MONITOR_T012');
    
        SELECT (pk_date_utils.date_char_hour_tsz(i_lang, m.dt_monitorization_tstz, i_prof.institution, i_prof.software) || ' ' ||
               pk_date_utils.dt_chr_tsz(i_lang, m.dt_monitorization_tstz, i_prof)) dt_req,
               (decode(m.flg_time,
                       pk_alert_constant.g_flg_time_n,
                       pk_message.get_message(i_lang, 'COMMON_M018'),
                       pk_date_utils.date_char_hour_tsz(i_lang,
                                                        nvl(m.dt_begin_tstz, m.dt_monitorization_tstz),
                                                        i_prof.institution,
                                                        i_prof.software)) || ' ' ||
               decode(m.flg_time,
                       pk_alert_constant.g_flg_time_n,
                       NULL,
                       pk_date_utils.dt_chr_tsz(i_lang, nvl(m.dt_begin_tstz, m.dt_begin_tstz), i_prof))) dt_begin,
               
               (decode(m.flg_time,
                       pk_alert_constant.g_flg_time_n,
                       pk_message.get_message(i_lang, 'COMMON_M018'),
                       pk_date_utils.date_char_hour_tsz(i_lang, m.dt_end_tstz, i_prof.institution, i_prof.software)) || ' ' ||
               decode(m.flg_time,
                       pk_alert_constant.g_flg_time_n,
                       NULL,
                       pk_date_utils.dt_chr_tsz(i_lang, m.dt_end_tstz, i_prof))) dt_end,
               get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval
          INTO l_req, l_start, l_end, l_interval
          FROM monitorization m
         WHERE m.id_monitorization = i_id_monit;
    
        FOR i IN 1 .. length(i_format)
        LOOP
            CASE substr(i_format, i, 1)
                WHEN 'N' THEN
                    add_to_ret(l_dt_req_mess || ': ' || l_req, l_ret);
                WHEN 'S' THEN
                    add_to_ret(l_dt_start_mess || ': ' || l_start, l_ret);
                WHEN 'I' THEN
                    add_to_ret(l_interval_mess || ': ' || l_interval, l_ret);
                WHEN 'E' THEN
                    IF TRIM(l_end) IS NOT NULL
                    THEN
                        add_to_ret(l_dt_end_mess || ': ' || l_end, l_ret);
                    END IF;
                ELSE
                    NULL;
            END CASE;
        END LOOP;
    
        RETURN l_ret;
    END get_monit_instructions_clob;

    FUNCTION get_monit_instructions
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_id_monit IN monitorization.id_monitorization%TYPE,
        i_format   IN VARCHAR2 DEFAULT 'NISE'
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN pk_string_utils.clob_to_varchar2(i_clob            => get_monit_instructions_clob(i_lang     => i_lang,
                                                                                                 i_prof     => i_prof,
                                                                                                 i_id_monit => i_id_monit,
                                                                                                 i_format   => i_format),
                                                i_maxlenght_bytes => pk_alert_constant.g_sql_varchar2_maxsize);
    END get_monit_instructions;

    /**********************************************************************************************
    * 
    * This function only is used for H AND P feature
    * get the the monitoring description
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_monitorization      Monitoring ID
    * @param        o_desc                   Monitoring description
    * @param        o_error                  error structure for exception handling
    *
    * @return       boolean                  TRUE if sucess, FALSE otherwise
    *                        
    * @author                                Sofia Mendes
    * @version                               v2.6.1.2
    * @since                                 20-Set-2011
    **********************************************************************************************/
    FUNCTION get_monitor_description
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_flg_only_active   IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        o_desc              OUT CLOB,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_message debug_msg;
    BEGIN
    
        l_message := 'GET description. i_id_monitorization: ' || i_id_monitorization;
        pk_alertlog.log_debug(l_message);
    
        SELECT desc_vs || CASE
                    WHEN desc_interval IS NOT NULL THEN
                     ': ' || desc_interval
                END
          INTO o_desc
          FROM (SELECT get_interval_desc(i_lang, i_prof, m.id_monitorization) desc_interval,
                       (pk_monitorization.get_vs_desc(i_lang, m.id_monitorization, i_prof, i_flg_only_active) ||
                       nvl2(m.id_prev_episode,
                             ' - (' || pk_message.get_message(i_lang,
                                                              profissional(i_prof.id,
                                                                           i_prof.institution,
                                                                           pk_episode.get_soft_by_epis_type((SELECT e.id_epis_type
                                                                                                              FROM episode e
                                                                                                             WHERE e.id_episode =
                                                                                                                   m.id_prev_episode),
                                                                                                            i_prof.institution)),
                                                              'IMAGE_T009') || ')',
                             '')) desc_vs
                
                  FROM monitorization m
                 WHERE m.id_monitorization = i_id_monitorization) t;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_message,
                                              c_package_owner,
                                              c_package_name,
                                              'get_monitor_description',
                                              o_error);
            RETURN FALSE;
    END get_monitor_description;

    /**********************************************************************************************
    * Return date interval
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   Profissional ID
    * @param i_interval               Monotorization's interval
    *
    * @param o_error                  error message
    *
    * @return varchar                 Return format hour/minute interval 
    *
    * @author                         Filipe Silva
    * @version                        2.6.1.2
    * @since                          2011/07/07
    **********************************************************************************************/
    FUNCTION get_format_monit_interval
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_interval IN monitorization.interval%TYPE
    ) RETURN VARCHAR IS
    
        l_hours   NUMBER;
        l_minutes NUMBER;
        l_desc    VARCHAR2(1000 CHAR);
        l_message debug_msg;
    
    BEGIN
    
        l_message := 'extract hours and minutes for interval: ' || i_interval;
        pk_alertlog.log_debug(l_message);
    
        SELECT extract(hour FROM numtodsinterval(i_interval, 'second')) +
               (extract(DAY FROM numtodsinterval(i_interval, 'second')) * 24) hours,
               to_char(trunc(SYSDATE) + numtodsinterval(i_interval, 'second'), 'mi') minutes
          INTO l_hours, l_minutes
          FROM dual;
    
        l_desc := pk_inp_util.get_format_interval(i_lang => i_lang, i_hours => l_hours, i_minutes => l_minutes);
    
        RETURN l_desc;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
        
    END get_format_monit_interval;

    /**********************************************************************************************
    * Return interval description
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   Profissional ID
    * @param i_id_monitorization      Monitorization ID
    *
    * @return varchar                 Return format hour/minute interval 
    *
    * @author                         Filipe Silva
    * @version                        2.6.1.2
    * @since                          2011/07/07
    **********************************************************************************************/
    FUNCTION get_interval_desc
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE
    ) RETURN VARCHAR IS
    
        l_not_applicable_msg sys_message.code_message%TYPE := pk_message.get_message(i_lang, 'COMMON_M018');
        l_day_msg            sys_message.code_message%TYPE := pk_message.get_message(i_lang, 'MONITORIZATION_M001');
        l_days_msg           sys_message.code_message%TYPE := pk_message.get_message(i_lang, 'MONITORIZATION_M002');
        l_desc_interval      VARCHAR2(1000 CHAR);
        l_message            debug_msg;
    
    BEGIN
    
        l_message := 'Calcule the interval for monitorization id ' || i_id_monitorization;
        pk_alertlog.log_debug(l_message);
        BEGIN
            SELECT decode(m.interval,
                          NULL,
                          l_not_applicable_msg,
                          decode(m.flg_time,
                                 pk_alert_constant.g_flg_time_b,
                                 (to_char(trunc(nvl(m.interval, 0) / 86400)) || ' ' ||
                                 decode(m.interval, 86400, l_day_msg, l_days_msg)),
                                 get_format_monit_interval(i_lang, i_prof, nvl(m.interval, 0)))) desc_interval
              INTO l_desc_interval
              FROM monitorization m
             WHERE m.id_monitorization = i_id_monitorization;
        EXCEPTION
            WHEN no_data_found THEN
                l_desc_interval := NULL;
        END;
    
        RETURN l_desc_interval;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_interval_desc;

    /**********************************************************************************************
    * Format interval (HH:MM) to seconds
    *
    * @param i_lang                   preferred language id for this professional
    * @param i_prof                   Profissional ID
    * @param i_interval               Interval defined with this format (HH:MM)
    *
    * @return number                 Return interval in seconds 
    *
    * @author                         Filipe Silva
    * @version                        2.6.1.2
    * @since                          2011/07/07
    **********************************************************************************************/

    FUNCTION get_format_interval_to_seconds
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_interval IN VARCHAR
    ) RETURN NUMBER IS
    
        l_string  table_varchar := table_varchar();
        l_hours   PLS_INTEGER;
        l_minutes PLS_INTEGER;
        l_message debug_msg;
    
    BEGIN
    
        l_message := 'Split interval in hours and seconds ' || i_interval;
        pk_alertlog.log_debug(l_message);
        --split the interval in hours and minutes
        BEGIN
            SELECT pk_utils.str_split_l(i_interval, ':')
              INTO l_string
              FROM dual;
        EXCEPTION
            WHEN no_data_found THEN
                l_string := table_varchar();
        END;
    
        IF l_string IS NOT NULL
           AND l_string.count > 0
        THEN
        
            l_message := 'Convert hours: ' || l_string(1) || ' to seconds';
            pk_alertlog.log_debug(l_message);
            -- convert hours to seconds
            l_hours := nvl(to_number(l_string(1)), 0) * 60 * 60;
        
            l_message := 'Convert minutes: ' || l_string(2) || ' to seconds';
            pk_alertlog.log_debug(l_message);
            -- convert minutes to seconds
            l_minutes := nvl(to_number(l_string(2)), 0) * 60;
        
        END IF;
    
        RETURN l_hours + l_minutes;
    
    END get_format_interval_to_seconds;

    /**********************************************************************************************
    * Checks if monitorization has permission to execute 
    *
    * @param        i_lang                  Preferred language id for this professional
    * @param        i_prof                  Profissional ID
    * @param        i_episode               Episode ID
    * @param        i_id_monitorization     Monitorization Episode Identifier
    * @param        i_flg_time              Flag time of monitorization
    * @param        i_flg_status            Flag status of monitorization
    * @param        i_dt_begin_tstz         Begin date of monitorization
    * @param        i_flg_check_actions     Flag whether to check on action permissions or not (Y/N)
    *
    * @return                               Has permission or not (Y/N)
    *                        
    * @author                               António Neto
    * @version                              2.5.1.8.1
    * @since                                19-Oct-2011
    **********************************************************************************************/
    FUNCTION check_exec_monit
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_episode           IN episode.id_episode%TYPE,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_flg_time          IN monitorization.flg_time%TYPE,
        i_flg_status        IN monitorization.flg_status%TYPE,
        i_dt_begin_tstz     IN monitorization.dt_begin_tstz%TYPE,
        i_flg_check_actions IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN VARCHAR2 IS
        l_exec_permissions VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    
        l_num_exec PLS_INTEGER;
    
        l_dt_server TIMESTAMP(6) WITH LOCAL TIME ZONE := current_timestamp;
    
        l_monit_exec_before_date CONSTANT VARCHAR2(22 CHAR) := 'MONIT_EXEC_BEFORE_DATE';
    BEGIN
        --check permissions for active status
        CASE
            WHEN i_flg_status IN (pk_alert_constant.g_monitor_vs_canc,
                                  pk_alert_constant.g_monitor_vs_inte,
                                  pk_alert_constant.g_monitor_vs_fini) THEN
                l_exec_permissions := pk_alert_constant.g_no;
            WHEN i_flg_status = pk_alert_constant.g_monitor_vs_expire THEN
                l_exec_permissions := check_extra_take(i_lang         => i_lang,
                                                       i_prof         => i_prof,
                                                       i_episode      => i_episode,
                                                       i_task_request => i_id_monitorization);
            WHEN i_flg_time = pk_alert_constant.g_flg_time_n THEN
                l_exec_permissions := pk_alert_constant.g_no;
            WHEN i_flg_status = pk_alert_constant.g_monitor_vs_pend THEN
                IF i_dt_begin_tstz <= l_dt_server
                THEN
                    l_exec_permissions := pk_alert_constant.g_yes;
                ELSE
                    l_exec_permissions := pk_sysconfig.get_config(i_code_cf => l_monit_exec_before_date,
                                                                  i_prof    => i_prof);
                END IF;
            WHEN i_flg_status = pk_alert_constant.g_monitor_vs_exec THEN
                l_exec_permissions := pk_alert_constant.g_yes;
            WHEN i_flg_status = pk_alert_constant.g_monitor_vs_draft THEN
                l_exec_permissions := pk_alert_constant.g_no;
            ELSE
                l_exec_permissions := pk_alert_constant.g_no;
        END CASE;
    
        IF i_flg_check_actions = pk_alert_constant.g_yes
           AND l_exec_permissions = pk_alert_constant.g_yes
        THEN
            --check action permissions for execution (Draft, Expire, Pening)
            BEGIN
                SELECT COUNT(1)
                  INTO l_num_exec
                  FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, c_action_monitorization, i_flg_status)) act
                 WHERE to_state IN (pk_alert_constant.g_monitor_vs_pend,
                                    pk_alert_constant.g_monitor_vs_expire,
                                    pk_alert_constant.g_monitor_vs_exec);
            
                IF l_num_exec > 0
                THEN
                    l_exec_permissions := pk_alert_constant.g_yes;
                ELSE
                    l_exec_permissions := pk_alert_constant.g_no;
                END IF;
            EXCEPTION
                WHEN no_data_found THEN
                    l_exec_permissions := pk_alert_constant.g_no;
            END;
        END IF;
    
        RETURN l_exec_permissions;
    END check_exec_monit;

    /**********************************************************************************************
    * Checks if monitorization has permission to cancel 
    *
    * @param        i_lang                  Preferred language id for this professional
    * @param        i_prof                  Profissional ID
    * @param        i_flg_time              Flag time of monitorization
    * @param        i_flg_status            Flag status of monitorization
    * @param        i_flg_check_actions     Flag whether to check on action permissions or not (Y/N)
    *
    * @return                               Has permission or not (Y/N)
    *                        
    * @author                               António Neto
    * @version                              2.5.1.8.1
    * @since                                20-Oct-2011
    **********************************************************************************************/
    FUNCTION check_cancel_monit
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_flg_time          IN monitorization.flg_time%TYPE,
        i_flg_status        IN monitorization.flg_status%TYPE,
        i_flg_check_actions IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN VARCHAR2 IS
        l_canc_permissions VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    
        l_num_canc PLS_INTEGER;
    BEGIN
        --check permissions for active status
        CASE
            WHEN i_flg_status IN (pk_alert_constant.g_monitor_vs_canc,
                                  pk_alert_constant.g_monitor_vs_inte,
                                  pk_alert_constant.g_monitor_vs_fini,
                                  pk_alert_constant.g_monitor_vs_expire) THEN
                l_canc_permissions := pk_alert_constant.g_no;
            WHEN i_flg_time = pk_alert_constant.g_flg_time_n THEN
                l_canc_permissions := pk_alert_constant.g_yes;
            WHEN i_flg_status IN (pk_alert_constant.g_monitor_vs_pend,
                                  pk_alert_constant.g_monitor_vs_exec,
                                  pk_alert_constant.g_monitor_vs_draft) THEN
                l_canc_permissions := pk_alert_constant.g_yes;
            ELSE
                l_canc_permissions := pk_alert_constant.g_no;
        END CASE;
    
        IF i_flg_check_actions = pk_alert_constant.g_yes
           AND l_canc_permissions = pk_alert_constant.g_yes
        THEN
            --check action permissions for execution (Draft, Expire, Pening)
            BEGIN
                SELECT COUNT(1)
                  INTO l_num_canc
                  FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, c_action_monitorization, i_flg_status)) act
                 WHERE to_state IN (pk_alert_constant.g_monitor_vs_canc);
            
                IF l_num_canc > 0
                THEN
                    l_canc_permissions := pk_alert_constant.g_yes;
                ELSE
                    l_canc_permissions := pk_alert_constant.g_no;
                END IF;
            EXCEPTION
                WHEN no_data_found THEN
                    l_canc_permissions := pk_alert_constant.g_no;
            END;
        END IF;
    
        RETURN l_canc_permissions;
    END check_cancel_monit;

    /**********************************************************************************************
    * Checks if monitorization has permission to see Detail screen 
    *
    * @param        i_flg_status            Flag status of monitorization
    *
    * @return                               Has permission or not (Y/N)
    *                        
    * @author                               António Neto
    * @version                              2.5.1.8.1
    * @since                                20-Oct-2011
    **********************************************************************************************/
    FUNCTION check_detail_monit(i_flg_status IN monitorization.flg_status%TYPE) RETURN VARCHAR2 IS
    BEGIN
        IF i_flg_status IS NOT NULL
        THEN
            RETURN pk_alert_constant.g_yes;
        ELSE
            RETURN pk_alert_constant.g_no;
        END IF;
    END check_detail_monit;

    /**********************************************************************************************
    * Check the possibility to be recorded in the system an execution after the task was expired.
    * It was defined that it should be possible to record in the system the last execution made after the task expiration.
    * It should not be possible to record more than one excecution after the task was expired. 
    *
    * @param       i_lang                    Professional preferred language
    * @param       i_prof                    Professional identification and its context (institution and software)
    * @param       i_episode                 Episode ID
    * @param       i_task_request            Task request ID (ID_MONITORIZATION)
    * @param       o_error                   Error information
    *
    * @return                                'Y' An execution is allowed. 'N' No execution is allowed (or the task has not expired).
    *
    * @author                                António Neto
    * @version                               2.5.1.8
    * @since                                 13-Sep-2011
    **********************************************************************************************/
    FUNCTION check_extra_take
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        i_task_request IN cpoe_process_task.id_task_request%TYPE
    ) RETURN VARCHAR IS
        co_function_name CONSTANT VARCHAR2(30 CHAR) := 'CHECK_EXTRA_TAKE';
        l_error                   t_error_out;
        l_execution_allowed       VARCHAR2(1 CHAR);
        l_status                  monitorization.flg_status%TYPE;
        l_dt_expire               monitorization.dt_cancel_tstz%TYPE;
        l_post_expired_executions NUMBER;
        l_message                 debug_msg;
    
    BEGIN
        -- By default assumes the execution is not allowed
        l_execution_allowed := pk_alert_constant.g_no;
    
        -- Check if the task has expired
        l_message := 'Get status';
        SELECT m.flg_status, m.dt_cancel_tstz
          INTO l_status, l_dt_expire
          FROM monitorization m
         WHERE m.id_monitorization = i_task_request;
    
        -- Hidrics expired 
        IF l_status = pk_alert_constant.g_monitor_vs_expire
        THEN
        
            -- Check if already exists one execution after the task was expired
            l_message := 'Counting post-expired executions';
            SELECT COUNT(*)
              INTO l_post_expired_executions
              FROM monitorization_vs_plan mvsp
             INNER JOIN monitorization_vs mvs
                ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
             INNER JOIN monitorization m
                ON mvs.id_monitorization = m.id_monitorization
             WHERE m.id_monitorization = i_task_request
               AND mvsp.flg_status <> pk_alert_constant.g_monitor_vs_canc
               AND (trunc(mvsp.start_time, 'MI') >= trunc(l_dt_expire, 'MI') OR
                   trunc(mvsp.end_time, 'MI') >= trunc(l_dt_expire, 'MI'));
        
            -- If there is not one execution after the task has been expired, then execution is allowed
            IF l_post_expired_executions = 0
            THEN
                l_execution_allowed := pk_alert_constant.g_yes;
            END IF;
        
        END IF;
    
        RETURN l_execution_allowed;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => l_message,
                                              i_owner    => c_package_owner,
                                              i_package  => c_package_name,
                                              i_function => co_function_name,
                                              o_error    => l_error);
            RAISE;
    END check_extra_take;
    --
    /**********************************************************************************************
    * get the monitoring description
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_monitorization      Monitoring ID
    *
    * @return       Monitoring description
    *                        
    * @author                                Alexandre Santos
    * @version                               v2.6.4
    * @since                                 23-Dec-2014
    **********************************************************************************************/
    FUNCTION get_monitor_description
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_id_co_sign_hist   IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN CLOB IS
        l_func_name CONSTANT VARCHAR2(32 CHAR) := 'GET_MONITOR_DESCRIPTION';
        --
        l_debug_msg debug_msg;
        --
        l_error t_error_out;
        l_ret   CLOB;
    BEGIN
        l_debug_msg := 'CALL PK_MONITORIZATION.GET_MONITOR_DESCRIPTION';
        pk_alertlog.log_debug(text => l_debug_msg, object_name => c_package_name, sub_object_name => l_func_name);
        IF NOT pk_monitorization.get_monitor_description(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_monitorization => i_id_monitorization,
                                                         i_flg_only_active   => pk_alert_constant.get_no,
                                                         o_desc              => l_ret,
                                                         o_error             => l_error)
        THEN
            l_debug_msg := 'ERROR CALLING PK_MONITORIZATION.GET_MONITOR_DESCRIPTION';
            pk_alertlog.log_error(text => l_debug_msg, object_name => c_package_name, sub_object_name => l_func_name);
            l_ret := NULL;
        END IF;
    
        RETURN l_ret;
    END get_monitor_description;

    /**********************************************************************************************
    * get the monitoring description
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_monitorization      Monitoring ID
    *
    * @return       Monitoring start date
    *                        
    * @author                                Nuno Alves
    * @version                               v2.6.5
    * @since                                 14-10-2015
    **********************************************************************************************/
    FUNCTION get_monitor_start_date
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_id_co_sign_hist   IN co_sign_hist.id_co_sign_hist%TYPE DEFAULT NULL
    ) RETURN TIMESTAMP
        WITH LOCAL TIME ZONE IS
        l_func_name CONSTANT VARCHAR2(32 CHAR) := 'GET_MONITOR_DESCRIPTION';
        --
        l_debug_msg debug_msg;
        --
        l_error t_error_out;
        l_ret   monitorization.dt_begin_tstz%TYPE;
    BEGIN
        l_debug_msg := 'GET DT_BEGIN_TSTZ FOR ID_MONITORIZATION' || i_id_monitorization;
        pk_alertlog.log_debug(l_func_name || ' | ' || l_debug_msg);
        SELECT decode(m.flg_time, pk_alert_constant.g_flg_time_n, NULL, nvl(m.dt_begin_tstz, m.dt_monitorization_tstz))
          INTO l_ret
          FROM monitorization m
         WHERE m.id_monitorization = i_id_monitorization;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_monitor_start_date;

    --
    /**********************************************************************************************
    * get the monitoring instructions
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_monitorization      Monitoring ID
    *
    * @return       Monitoring instructions
    *                        
    * @author                                Alexandre Santos
    * @version                               v2.6.4
    * @since                                 23-Dec-2014
    **********************************************************************************************/
    FUNCTION get_monitor_instructions
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_id_co_sign_hist   IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN CLOB IS
    BEGIN
        RETURN get_monit_instructions_clob(i_lang     => i_lang,
                                           i_prof     => i_prof,
                                           i_id_monit => i_id_monitorization,
                                           i_format   => 'SIE');
    END get_monitor_instructions;

    /**********************************************************************************************
    * get monitorization action description
    *
    * @param        i_lang                   the id language
    * @param        i_prof                   professional, software and institution ids
    * @param        i_id_co_sign             Co-sign ID
    *
    * @return       Monitoring action description
    *                        
    * @author                                Vanessa Barsottelli
    * @version                               v2.6.4
    * @since                                 14-Jan-2015
    **********************************************************************************************/
    FUNCTION get_monitor_action_desc
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_monitorization IN monitorization.id_monitorization%TYPE,
        i_id_action         IN action.id_action%TYPE,
        i_id_co_sign_hist   IN co_sign_hist.id_co_sign_hist%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(25 CHAR) := 'GET_MONITOR_ACTION_DESC';
    
        l_sm_action_order       sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                        i_prof      => i_prof,
                                                                                        i_code_mess => 'MONITOR_T023');
        l_sm_action_cancel      sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                        i_prof      => i_prof,
                                                                                        i_code_mess => 'MONITOR_M019');
        l_sm_action_discontinue sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                        i_prof      => i_prof,
                                                                                        i_code_mess => 'MONITOR_M020');
        l_description           sys_message.desc_message%TYPE;
        l_message               debug_msg;
    
        l_id_action_add    action.id_action%TYPE;
        l_id_action_cancel action.id_action%TYPE;
    BEGIN
    
        IF i_id_monitorization IS NULL
           OR i_id_monitorization IS NULL
        THEN
            RETURN NULL;
        END IF;
    
        l_id_action_add    := pk_co_sign.get_id_action(i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_add,
                                                       i_action                 => NULL);
        l_id_action_cancel := pk_co_sign.get_id_action(i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_cancel,
                                                       i_action                 => NULL);
    
        l_message := 'GET ACTION DESCRIPTION FOR i_id_monitorization = ' || i_id_monitorization || ', i_id_action = ' ||
                     i_id_action;
        SELECT CASE i_id_action
                   WHEN l_id_action_add THEN
                    l_sm_action_order
                   WHEN l_id_action_cancel THEN
                    CASE m.flg_status
                        WHEN pk_alert_constant.g_monitor_vs_canc THEN
                         l_sm_action_cancel
                        WHEN pk_alert_constant.g_monitor_vs_inte THEN
                         l_sm_action_discontinue
                    END
                   ELSE
                    NULL
               END
          INTO l_description
          FROM monitorization m
         WHERE m.id_monitorization = i_id_monitorization;
    
        RETURN l_description;
    
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error t_error_out;
            BEGIN
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  l_message,
                                                  c_package_owner,
                                                  c_package_name,
                                                  l_func_name,
                                                  l_error);
                RETURN NULL;
            END;
    END get_monitor_action_desc;

    FUNCTION inactivate_monitorztn_tasks
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_inst        IN institution.id_institution%TYPE,
        i_ids_exclude IN OUT table_number,
        o_has_error   OUT BOOLEAN,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_cancel_cfg sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'INACTIVATE_CANCEL_REASON',
                                                                      i_prof    => i_prof);
    
        l_descontinued_cfg sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'INACTIVATE_DISCONTINUED_REASON',
                                                                            i_prof    => i_prof);
    
        l_cancel_id cancel_reason.id_cancel_reason%TYPE := pk_cancel_reason.get_id_by_content(i_lang,
                                                                                              i_prof,
                                                                                              l_cancel_cfg);
    
        l_descontinued_id cancel_reason.id_cancel_reason%TYPE := pk_cancel_reason.get_id_by_content(i_lang,
                                                                                                    i_prof,
                                                                                                    l_descontinued_cfg);
    
        l_tbl_config t_tbl_config_table := pk_core_config.get_values_by_mkt_inst_sw(i_lang => NULL,
                                                                                    i_prof => profissional(0, i_inst, 0),
                                                                                    i_area => 'MONITORIZATION_INACTIVATE');
    
        l_max_rows sys_config.value%TYPE := pk_sysconfig.get_config(i_prof    => i_prof,
                                                                    i_code_cf => 'INACTIVATE_TASKS_MAX_NUMBER_ROWS');
    
        l_monitorization_req table_number;
        l_final_status       table_varchar;
    
        l_error t_error_out;
        g_other_exception EXCEPTION;
    
        l_tbl_error_ids table_number := table_number();
    
        --The cursor will not fetch the records for the ids (id_monitorization) sent in i_ids_exclude        
        CURSOR c_monitorization_req(ids_exclude IN table_number) IS
            SELECT m.id_monitorization, cfg.field_04
              FROM monitorization m
             INNER JOIN episode e
                ON e.id_episode = m.id_episode
              LEFT JOIN episode prev_e
                ON prev_e.id_prev_episode = e.id_episode
               AND e.id_visit = prev_e.id_visit
             INNER JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                          *
                           FROM TABLE(l_tbl_config) t) cfg
                ON cfg.field_01 = m.flg_status
              LEFT JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                          t.column_value
                           FROM TABLE(i_ids_exclude) t) t_ids
                ON t_ids.column_value = m.id_monitorization
             WHERE e.id_institution = i_inst
               AND e.dt_end_tstz IS NOT NULL
               AND (prev_e.id_episode IS NULL OR prev_e.flg_status = pk_alert_constant.g_inactive)
               AND pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                    i_timestamp => (pk_date_utils.add_to_ltstz(i_timestamp => e.dt_end_tstz,
                                                                                               i_amount    => cfg.field_02,
                                                                                               i_unit      => cfg.field_03))) <=
                   pk_date_utils.trunc_insttimezone(i_prof => i_prof, i_timestamp => current_timestamp)
               AND rownum <= l_max_rows
               AND t_ids.column_value IS NULL;
    
    BEGIN
    
        o_has_error := FALSE;
    
        OPEN c_monitorization_req(i_ids_exclude);
        FETCH c_monitorization_req BULK COLLECT
            INTO l_monitorization_req, l_final_status;
        CLOSE c_monitorization_req;
    
        IF l_monitorization_req.count > 0
        THEN
            FOR i IN 1 .. l_monitorization_req.count
            LOOP
                IF l_final_status(i) IN (pk_alert_constant.g_monitor_vs_inte, pk_alert_constant.g_monitor_vs_canc)
                THEN
                    SAVEPOINT init_cancel;
                    IF NOT pk_monitorization.cancel_monitor_req(i_lang              => i_lang,
                                                           i_id_monitorization => l_monitorization_req(i),
                                                           i_prof              => i_prof,
                                                           i_notes             => NULL,
                                                           i_prof_cat_type     => NULL,
                                                           i_commit_data       => pk_alert_constant.get_no,
                                                           i_id_cancel_reason  => CASE
                                                                                      WHEN l_final_status(i) =
                                                                                           pk_alert_constant.g_monitor_vs_inte THEN
                                                                                       l_descontinued_id
                                                                                      ELSE
                                                                                       l_cancel_id
                                                                                  END,
                                                           o_error             => l_error)
                    THEN
                        ROLLBACK TO init_cancel;
                    
                        --If, for the given id_monitorization, an error is generated, o_has_error is set as TRUE,
                        --this way, the loop cicle may continue, but the system will know that at least one error has happened
                        o_has_error := TRUE;
                    
                        --A log for the id_monitorization that raised the error must be generated 
                        pk_alert_exceptions.reset_error_state;
                        l_error.err_desc := 'ERROR CALLING PK_MONITORIZATION.CANCEL_MONITOR_REQ FOR RECORD ' ||
                                            l_monitorization_req(i);
                        pk_alert_exceptions.process_error(i_lang,
                                                          SQLCODE,
                                                          SQLERRM,
                                                          l_error.err_desc,
                                                          c_package_owner,
                                                          c_package_name,
                                                          'INACTIVATE_MONITORZTN_TASKS',
                                                          o_error);
                    
                        --The array for the ids (id_monitorization) that raised the error is incremented
                        l_tbl_error_ids.extend();
                        l_tbl_error_ids(l_tbl_error_ids.count) := l_monitorization_req(i);
                    
                        CONTINUE;
                    END IF;
                END IF;
            END LOOP;
        
            --When the number of error ids match the max number of rows that can be processed for each call,
            --it means that no id_monitorization has been inactivated.
            --The next time the Job would be executed, the cursor would fetch the same set fetched on the previous call,
            --and therefore, from this point on, no more records would be inactivated.
            IF l_tbl_error_ids.count = l_max_rows
            THEN
                FOR i IN l_tbl_error_ids.first .. l_tbl_error_ids.last
                LOOP
                    --i_ids_exclude is an IN OUT parameter, and is incremented with the ids (id_monitorization) that could not
                    --be inactivated with the current call of the function
                    i_ids_exclude.extend();
                    i_ids_exclude(i_ids_exclude.count) := l_tbl_error_ids(i);
                END LOOP;
            
                --Since no inactivations were performed with the current call, a new call to this function is performed,
                --however, this time, the array i_ids_exclude will include a list of ids that cannot be fetched by the cursor
                --on the next call. The recursion will be perfomed until at least one record is inactivated, or the cursor
                --has no more records to fetch.
                --Note: i_ids_exclude is incremented and is an IN OUT parameter, therefore, 
                --it will hold all the ids that were not inactivated from ALL calls.            
                IF NOT pk_monitorization.inactivate_monitorztn_tasks(i_lang        => i_lang,
                                                                     i_prof        => i_prof,
                                                                     i_inst        => i_inst,
                                                                     i_ids_exclude => i_ids_exclude,
                                                                     o_has_error   => o_has_error,
                                                                     o_error       => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error.err_desc,
                                              c_package_owner,
                                              c_package_name,
                                              'INACTIVATE_MONITORZTN_TASKS',
                                              l_error);
            RETURN FALSE;
    END inactivate_monitorztn_tasks;

    FUNCTION get_order_plan_report
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_task_request  IN table_number,
        i_cpoe_dt_begin IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_cpoe_dt_end   IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_plan_rep      OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_order_plan_rep       t_tbl_order_recurr_plan;
        l_order_plan_rep_union t_tbl_order_recurr_plan := t_tbl_order_recurr_plan();
        l_tbl_interv_presc_det table_number;
        l_tbl_ipd_dt_begin     table_timestamp_tstz;
        l_last_reached         VARCHAR2(20 CHAR);
        l_order_recurrence     order_recurr_plan.id_order_recurr_plan%TYPE;
        l_t_order_recurr       table_number;
        l_cp_begin             TIMESTAMP WITH LOCAL TIME ZONE;
        l_cp_end               TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_interv_presc_plan_last interv_presc_plan.id_interv_presc_plan%TYPE;
        l_interv_presc_plan_next interv_presc_plan.id_interv_presc_plan%TYPE;
    
        l_tbl_monitorization table_number;
        l_id_monit_vs        monitorization_vs.id_monitorization_vs%TYPE;
    
        l_tbl_rec_exec_static t_tbl_cpoe_execution;
        l_tbl_rec_exec_final  t_tbl_cpoe_execution := t_tbl_cpoe_execution();
        l_last_date           monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_interval            monitorization.interval%TYPE;
        l_calc_last_date      monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_dt_end              monitorization.dt_end_tstz%TYPE;
    
        l_flg_status_m monitorization.flg_status%TYPE;
    
        l_error t_error_out;
    BEGIN
    
        IF i_cpoe_dt_begin IS NULL
        THEN
            IF NOT pk_episode.get_epis_dt_begin_tstz(i_lang          => i_lang,
                                                     i_prof          => i_prof,
                                                     i_id_episode    => i_episode,
                                                     o_dt_begin_tstz => l_cp_begin,
                                                     o_error         => o_error)
            THEN
                l_cp_begin := current_timestamp;
            END IF;
        ELSE
            l_cp_begin := i_cpoe_dt_begin;
        END IF;
    
        IF i_cpoe_dt_end IS NULL
        THEN
            l_cp_end := nvl(pk_date_utils.add_days_to_tstz(i_timestamp => l_cp_begin, i_days => 1), current_timestamp);
        ELSE
            l_cp_end := i_cpoe_dt_end;
        END IF;
    
        SELECT a.id_monitorization
          BULK COLLECT
          INTO l_tbl_monitorization
          FROM monitorization a
         WHERE a.id_episode = i_episode
           AND a.flg_status NOT IN ('E', 'R', 'C');
    
        FOR i IN 1 .. l_tbl_monitorization.count
        LOOP
            SELECT a.id_monitorization_vs
              INTO l_id_monit_vs
              FROM monitorization_vs a
             WHERE a.id_monitorization = l_tbl_monitorization(i)
               AND rownum = 1;
        
            SELECT t_rec_cpoe_execution(id_task_type    => NULL,
                                         id_prescription => t.id_monit,
                                         planned_date    => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                        i_date => t.dt_plan,
                                                                                        i_prof => i_prof),
                                         exec_date       => CASE
                                                                WHEN t.dt_start_time IS NULL THEN
                                                                 NULL
                                                                ELSE
                                                                 pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => t.dt_start_time, i_prof => i_prof)
                                                            END,
                                         exec_notes      => NULL,
                                         out_of_period   => t.out_of_period)
              BULK COLLECT
              INTO l_tbl_rec_exec_static
              FROM (SELECT b.id_monitorization id_monit,
                           a.dt_plan_tstz dt_plan,
                           a.start_time dt_start_time,
                           'N' out_of_period
                      FROM monitorization_vs_plan a
                     INNER JOIN monitorization_vs b
                        ON a.id_monitorization_vs = b.id_monitorization_vs
                     WHERE a.id_monitorization_vs = l_id_monit_vs
                          --AND a.flg_status = pk_monitorization.g_monit_vs_plan_final
                       AND a.dt_plan_tstz BETWEEN l_cp_begin AND l_cp_end
                    UNION ALL
                    SELECT z.id_monit, z.dt_plan, z.dt_start_time, z.out_of_period
                      FROM (SELECT b.id_monitorization id_monit,
                                   a.dt_plan_tstz dt_plan,
                                   a.start_time dt_start_time,
                                   'Y' out_of_period
                              FROM monitorization_vs_plan a
                             INNER JOIN monitorization_vs b
                                ON a.id_monitorization_vs = b.id_monitorization_vs
                             WHERE a.id_monitorization_vs = l_id_monit_vs
                               AND a.dt_plan_tstz < l_cp_begin
                               AND a.flg_status = pk_monitorization.g_monit_vs_plan_final
                             ORDER BY a.dt_plan_tstz DESC) z
                     WHERE rownum = 1) t;
        
            BEGIN
                SELECT DISTINCT a.dt_plan_tstz
                  INTO l_last_date
                  FROM monitorization_vs_plan a
                 WHERE a.id_monitorization_vs = l_id_monit_vs
                   AND a.flg_status != pk_monitorization.g_monit_vs_plan_final
                 ORDER BY a.dt_plan_tstz DESC;
            EXCEPTION
                WHEN OTHERS THEN
                    l_last_date := NULL;
            END;
        
            IF l_last_date IS NOT NULL
               AND l_last_date <= l_cp_end
            THEN
            
                SELECT m.interval, m.dt_end_tstz
                  INTO l_interval, l_dt_end
                  FROM monitorization m
                 WHERE m.id_monitorization = l_tbl_monitorization(i);
            
                SELECT m.flg_status
                  INTO l_flg_status_m
                  FROM monitorization m
                 WHERE m.id_monitorization = l_tbl_monitorization(i);
            
                IF l_flg_status_m != 'I'
                THEN
                    --It is possible to order a monitorization with a frequency of 00h:00m, which
                    --means there are no real planed dates for execution. For these cases, the monitorization
                    --will be stored with an interval of 0, and in the application, after an execution, 
                    --the monitorization will automatically be again set as 'delayed'.
                    --Therefore, for these cases, the function will no longer return the planned executions.
                    IF l_interval IS NOT NULL
                       AND l_interval > 0
                    THEN
                        l_calc_last_date := l_last_date + numtodsinterval(l_interval, 'SECOND');
                    
                        WHILE l_calc_last_date < l_cp_end
                              AND (l_calc_last_date <= l_dt_end OR l_dt_end IS NULL)
                        LOOP
                            IF l_calc_last_date >= l_cp_begin
                            THEN
                                l_tbl_rec_exec_static.extend;
                                l_tbl_rec_exec_static(l_tbl_rec_exec_static.count) := t_rec_cpoe_execution(id_task_type    => NULL,
                                                                                                           id_prescription => l_tbl_monitorization(i),
                                                                                                           planned_date    => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                                                          i_date => l_calc_last_date,
                                                                                                                                                          i_prof => i_prof),
                                                                                                           exec_date       => NULL,
                                                                                                           exec_notes      => NULL,
                                                                                                           out_of_period   => pk_alert_constant.g_no);
                            END IF;
                            l_calc_last_date := l_calc_last_date + numtodsinterval(l_interval, 'SECOND');
                        
                        END LOOP;
                    END IF;
                END IF;
            END IF;
            l_tbl_rec_exec_final := l_tbl_rec_exec_final MULTISET UNION l_tbl_rec_exec_static;
        END LOOP;
    
        OPEN o_plan_rep FOR
            SELECT t.id_prescription, t.planned_date, t.exec_date, t.exec_notes, t.out_of_period
              FROM TABLE(l_tbl_rec_exec_final) t;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error.err_desc,
                                              c_package_owner,
                                              c_package_name,
                                              'INACTIVATE_MONITORZTN_TASKS',
                                              l_error);
            pk_types.open_my_cursor(o_plan_rep);
            RETURN FALSE;
        
    END get_order_plan_report;

--
-- INITIALIZATION SECTION
-- 

BEGIN
    -- Initializes log context
    pk_alertlog.log_init(object_name => c_package_name);

END pk_monitorization;
/
