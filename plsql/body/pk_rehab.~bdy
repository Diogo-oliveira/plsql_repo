/*-- Last Change Revision: $Rev: 2054215 $*/
/*-- Last Change by: $Author: diogo.oliveira $*/
/*-- Date of last change: $Date: 2023-01-06 09:49:21 +0000 (sex, 06 jan 2023) $*/

CREATE OR REPLACE PACKAGE BODY pk_rehab IS

    /***************************************************************************************************
    * Private declarations
    ***************************************************************************************************/
    g_cfg_needs_schedule CONSTANT sys_config.id_sys_config%TYPE := 'REHAB_NEEDS_SCHEDULE';
    g_colon              CONSTANT sys_message.desc_message%TYPE := ':';
    g_retval BOOLEAN;
    g_temporary_patient CONSTANT VARCHAR2(1 CHAR) := 'T';

    FUNCTION set_rehab_session_hist
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_rehab_session      IN table_number,
        i_dt_rehab_session_hist IN rehab_session_hist.dt_rehab_session_hist%TYPE DEFAULT NULL,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN;

    FUNCTION set_rehab_presc_hist
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_rehab_presc      IN rehab_presc.id_rehab_presc%TYPE,
        i_dt_rehab_presc_hist IN rehab_presc_hist.dt_rehab_presc_hist%TYPE DEFAULT NULL,
        i_commit              IN VARCHAR2 DEFAULT pk_alert_constant.get_yes(),
        i_id_rehab_presc_hist IN rehab_presc_hist.id_rehab_presc_hist%TYPE DEFAULT NULL,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN;

    FUNCTION set_rehab_sch_need_hist
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_id_rehab_sch_need      IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_dt_rehab_sch_need_hist IN rehab_sch_need_hist.dt_rehab_sch_need_hist%TYPE DEFAULT NULL,
        i_commit                 IN VARCHAR2 DEFAULT pk_alert_constant.get_yes(),
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN;

    FUNCTION cancel_rehab_sch_need_nocommit
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_id_cancel_reason  IN rehab_sch_need.id_cancel_reason%TYPE DEFAULT NULL,
        i_notes             IN rehab_sch_need.notes_cancel%TYPE DEFAULT NULL,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN;

    FUNCTION check_rehab_plan
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_patient        IN rehab_plan.id_patient%TYPE,
        i_id_episode_origin IN rehab_plan.id_episode_origin%TYPE,
        i_commit            IN VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN;

    FUNCTION check_sch_need_session_type
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_sch_needs  IN table_number,
        o_new_rowids OUT table_varchar,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN;

    FUNCTION check_prof_can_modify
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional
    ) RETURN BOOLEAN;

    /**********************************************************************************************
    * Finds all the rehab areas parameterized for an institution
    *
    * %param i_id_institution         id_institution
    *
    * @return                         t_rehab_areas
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION find_inst_rehab_areas
    (
        i_id_institution IN institution.id_institution%TYPE,
        i_id_rehab_area  IN rehab_area.id_rehab_area%TYPE DEFAULT NULL
    ) RETURN t_rehab_areas
        PIPELINED IS
    BEGIN
        FOR row_i IN (SELECT ra.id_rehab_area, ra.code_rehab_area, rai.id_rehab_area_inst
                        FROM rehab_area ra
                        JOIN (SELECT id_rehab_area_inst,
                                    id_rehab_area,
                                    row_number() over(PARTITION BY id_rehab_area ORDER BY id_institution DESC) AS rn
                               FROM rehab_area_inst
                              WHERE id_institution IN (0, i_id_institution)
                                AND flg_add_remove = 'A'
                                AND (i_id_rehab_area IS NULL OR id_rehab_area = i_id_rehab_area)
                                AND id_rehab_area NOT IN (SELECT /*+ no_unnest */
                                                           id_rehab_area
                                                            FROM rehab_area_inst
                                                           WHERE id_institution IN (0, i_id_institution)
                                                             AND flg_add_remove = 'R')) rai
                          ON ra.id_rehab_area = rai.id_rehab_area
                       WHERE rai.rn = 1)
        LOOP
            PIPE ROW(t_rehab_area(row_i.id_rehab_area, row_i.code_rehab_area, row_i.id_rehab_area_inst));
        END LOOP;
    
        RETURN;
    
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END find_inst_rehab_areas;

    /**********************************************************************************************
    * Finds all the rehab areas parameterized for a professional in a institution
    *
    * %param i_id_professional        id_professional
    * %param i_id_institution         id_institution
    *
    * @return                         t_prof_rehab_areas
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION find_prof_rehab_areas
    (
        i_id_professional IN professional.id_professional%TYPE,
        i_id_institution  IN institution.id_institution%TYPE
    ) RETURN t_prof_rehab_areas
        PIPELINED IS
        l_id_category prof_cat.id_category%TYPE;
    BEGIN
        l_id_category := pk_prof_utils.get_id_category(i_lang => NULL,
                                                       i_prof => profissional(i_id_professional, i_id_institution, NULL));
        IF l_id_category = g_category_registrar
        THEN
            FOR row_i IN (SELECT /*+ opt_estimate(table x rows=1) */
                          DISTINCT x.id_rehab_area_inst, x.id_rehab_area, x.code_rehab_area
                            FROM TABLE(pk_rehab.find_inst_rehab_areas(i_id_institution)) x
                            JOIN rehab_area_inst_prof raip
                              ON raip.id_rehab_area_inst = x.id_rehab_area_inst)
            LOOP
                PIPE ROW(t_prof_rehab_area(row_i.id_rehab_area, row_i.code_rehab_area, row_i.id_rehab_area_inst));
            END LOOP;
        ELSE
            FOR row_i IN (SELECT /*+ opt_estimate(table x rows=1) */
                          DISTINCT x.id_rehab_area_inst, x.id_rehab_area, x.code_rehab_area
                            FROM TABLE(pk_rehab.find_inst_rehab_areas(i_id_institution)) x
                            JOIN rehab_area_inst_prof raip
                              ON raip.id_rehab_area_inst = x.id_rehab_area_inst
                             AND raip.id_professional = i_id_professional)
            LOOP
                PIPE ROW(t_prof_rehab_area(row_i.id_rehab_area, row_i.code_rehab_area, row_i.id_rehab_area_inst));
            END LOOP;
        END IF;
    
        RETURN;
    
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END find_prof_rehab_areas;

    /**********************************************************************************************
    * Finds all the rehab procedures parameterized for the professional's institution
    *
    * %param i_id_institution         id_institution
    * %param i_id_software            id_software
    *
    * @return                         t_prof_rehab_areas
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION find_rehab_interv
    (
        i_id_institution IN institution.id_institution%TYPE,
        i_id_software    IN software.id_software%TYPE
    ) RETURN t_rehab_intervs
        PIPELINED IS
    
    BEGIN
        FOR row_i IN (SELECT rai.id_rehab_area_interv,
                             i.id_intervention,
                             i.id_intervention_parent,
                             i.code_intervention,
                             i.flg_has_children,
                             rai.id_rehab_area,
                             ris.id_rehab_session_type,
                             rst.code_rehab_session_type,
                             ris.id_exec_institution AS id_exec_institution
                        FROM rehab_area_interv rai
                        JOIN (SELECT id_intervention,
                                    id_intervention_parent,
                                    code_intervention,
                                    decode(connect_by_isleaf, 1, 'N', 'Y') flg_has_children,
                                    flg_status
                               FROM (SELECT *
                                       FROM intervention
                                      WHERE flg_status = 'A')
                              START WITH id_intervention_parent IS NULL
                             CONNECT BY PRIOR id_intervention = id_intervention_parent) i
                          ON i.id_intervention = rai.id_intervention
                        JOIN (SELECT id_rehab_area_interv, id_rehab_session_type, rise.id_exec_institution
                               FROM (SELECT id_rehab_inst_soft,
                                            id_rehab_area_interv,
                                            id_rehab_session_type,
                                            flg_execute,
                                            row_number() over(PARTITION BY id_rehab_area_interv ORDER BY id_institution DESC, id_software DESC) AS rn
                                       FROM rehab_inst_soft
                                      WHERE id_institution IN (0, i_id_institution)
                                        AND id_software IN (0, i_id_software)
                                        AND flg_add_remove = 'A'
                                        AND id_rehab_area_interv NOT IN
                                            (SELECT id_rehab_area_interv
                                               FROM rehab_inst_soft
                                              WHERE id_institution IN (0, i_id_institution)
                                                AND id_software IN (0, i_id_software)
                                                AND flg_add_remove = 'R')) x
                               LEFT JOIN rehab_inst_soft_ext rise
                                 ON rise.id_rehab_inst_soft = x.id_rehab_inst_soft
                              WHERE rn = 1) ris
                          ON rai.id_rehab_area_interv = ris.id_rehab_area_interv
                        LEFT JOIN rehab_session_type rst
                          ON rst.id_rehab_session_type = ris.id_rehab_session_type)
        LOOP
            PIPE ROW(t_rehab_interv(row_i.id_rehab_area_interv,
                                    row_i.id_intervention,
                                    row_i.id_intervention_parent,
                                    row_i.code_intervention,
                                    row_i.id_rehab_area,
                                    row_i.id_rehab_session_type,
                                    row_i.code_rehab_session_type,
                                    row_i.flg_has_children,
                                    row_i.id_exec_institution));
        END LOOP;
    
        RETURN;
    
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END find_rehab_interv;

    /**********************************************************************************************
    * Returns the episode that is to used to aggregate the treatments
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_episode             Current episode to find the origin
    * %param i_id_schedule            Current schedule to find the origin episode
    * %param o_id_episode_origin      Origin episode
    * %param o_id_schedule            schedule id if exists
    * %param o_id_epis_type           type of origin episode
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_origin_episode
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_episode        IN episode.id_episode%TYPE,
        i_id_schedule       IN epis_info.id_schedule%TYPE,
        o_id_episode_origin OUT rehab_plan.id_episode_origin%TYPE,
        o_id_schedule       OUT rehab_schedule.id_schedule%TYPE,
        o_id_epis_type      OUT episode.id_epis_type%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_ORIGIN_EPISODE';
    BEGIN
        g_error := 'i_id_episode=' || i_id_episode || ', i_id_schedule=' || i_id_schedule;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        o_id_schedule := i_id_schedule;
    
        IF i_id_schedule IS NOT NULL
        THEN
            g_error := 'get by id_schedule';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            -- episódio de internamento ou consulta externa com agendamento
            SELECT rsn.id_episode_origin
              INTO o_id_episode_origin
              FROM rehab_schedule rs
              JOIN rehab_sch_need rsn
                ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
             WHERE rs.id_rehab_schedule = i_id_schedule;
        
        ELSIF i_id_episode IS NOT NULL
        THEN
            g_error := 'get by new id_episode ';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            BEGIN
            
                SELECT ree.id_episode_origin
                  INTO o_id_episode_origin
                  FROM rehab_epis_encounter ree
                 WHERE ree.id_episode_rehab = i_id_episode;
            EXCEPTION
                WHEN no_data_found THEN
                    o_id_episode_origin := i_id_episode;
            END;
        
            SELECT id_epis_type
              INTO o_id_epis_type
              FROM episode e
             WHERE e.id_episode = o_id_episode_origin;
        
        ELSE
            g_error := 'i_id_episode and i_id_schedule are null';
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN no_data_found THEN
            -- log_error but return true
            pk_alertlog.log_error('no data found for i_id_episode=' || i_id_episode || ', i_id_schedule=' ||
                                  i_id_schedule || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            o_id_episode_origin := NULL;
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_episode=' || i_id_episode || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_origin_episode;

    /**********************************************************************************************
    * Returns the list of all the rehab areas and procedures parameterized for the current institution/software
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_rehab_area             which rehab_area or NULL for everything
    * %param i_intervention_parent    which id_intervention or NULL for everything
    * %param o_areas                  list of rehab areas
    * %param o_list                   list of interventions
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_interv_all
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_rehab_area          IN rehab_area.id_rehab_area%TYPE,
        i_intervention_parent IN intervention.id_intervention_parent%TYPE,
        i_id_codification     IN interv_codification.id_codification%TYPE,
        o_areas               OUT pk_types.cursor_type,
        o_list                OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_INTERV_SEARCH';
    BEGIN
        g_error := 'FETCH AREAS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_areas FOR
            SELECT *
              FROM (SELECT ra.id_rehab_area, pk_translation.get_translation(i_lang, ra.code_rehab_area) desc_area
                      FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                     WHERE ra.id_rehab_area IN
                           (SELECT i.id_rehab_area
                              FROM TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i))
             WHERE desc_area IS NOT NULL
             ORDER BY desc_area;
    
        g_error := 'FETCH PROCEDURES';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_list FOR
            SELECT *
              FROM (SELECT DISTINCT i.id_rehab_area_interv, -- distinct because find_rehab_interv can return the same intervention executable in several institutions
                                    i.id_intervention,
                                    i.id_intervention_parent,
                                    i.id_rehab_area,
                                    pk_translation.get_translation(i_lang, ra.code_rehab_area) AS desc_rehab_area,
                                    pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) ||
                                    decode(tc.id_codification,
                                           NULL,
                                           NULL,
                                           decode(tc.flg_show_codification,
                                                  'Y',
                                                  ' (' || pk_translation.get_translation(i_lang,
                                                                                         'CODIFICATION.CODE_CODIFICATION.' ||
                                                                                         tc.id_codification) || ')',
                                                  NULL)) desc_interv,
                                    i.flg_has_children,
                                    i.id_rehab_session_type,
                                    pk_translation.get_translation(i_lang, i.code_rehab_session_type) AS desc_rehab_session_type,
                                    tc.id_codification,
                                    pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', i.id_intervention) flg_laterality_mcdt
                      FROM TABLE(find_inst_rehab_areas(i_prof.institution, i_rehab_area)) ra
                      JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                        ON i.id_rehab_area = ra.id_rehab_area
                      LEFT JOIN (SELECT ic.id_intervention,
                                       ic.id_codification,
                                       ic.id_interv_codification,
                                       ic.flg_show_codification
                                  FROM codification c, codification_instit_soft cis, interv_codification ic
                                 WHERE c.id_codification = cis.id_codification
                                   AND cis.id_institution = i_prof.institution
                                   AND cis.id_software = i_prof.software
                                   AND c.id_codification = ic.id_codification
                                   AND ic.flg_available = 'Y') tc
                        ON tc.id_intervention = i.id_intervention
                     WHERE (i_rehab_area IS NULL OR ra.id_rehab_area = i_rehab_area)
                       AND (i_intervention_parent IS NULL OR i.id_intervention_parent = i_intervention_parent)
                       AND (i_id_codification IS NULL OR (tc.id_codification = i_id_codification)))
            
             WHERE desc_interv IS NOT NULL
               AND desc_rehab_area IS NOT NULL
             ORDER BY desc_interv;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_rehab_area=' || i_rehab_area || ',i_intervention_parent=' ||
                                  i_intervention_parent || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_types.open_my_cursor(o_areas);
            pk_types.open_my_cursor(o_list);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_interv_all;

    FUNCTION get_rehab_interv_list
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_rehab_area          IN rehab_area.id_rehab_area%TYPE,
        i_intervention_parent IN intervention.id_intervention_parent%TYPE,
        i_id_codification     IN interv_codification.id_codification%TYPE,
        o_areas               OUT pk_types.cursor_type,
        o_list                OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_INTERV_LIST';
    BEGIN
        g_error := 'FETCH AREAS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        IF i_rehab_area IS NULL
        THEN
            OPEN o_areas FOR
                SELECT DISTINCT t.id_rehab_area,
                                t.desc_area,
                                NULL id_intervention_parent,
                                decode(t.count_children, 0, pk_alert_constant.g_no, pk_alert_constant.g_yes) flg_has_children
                  FROM (WITH int_codification AS (SELECT ic.id_intervention,
                                                         ic.id_codification,
                                                         ic.id_interv_codification,
                                                         ic.flg_show_codification
                                                    FROM codification             c,
                                                         codification_instit_soft cis,
                                                         interv_codification      ic
                                                   WHERE c.id_codification = cis.id_codification
                                                     AND cis.id_institution = i_prof.institution
                                                     AND cis.id_software = i_prof.software
                                                     AND c.id_codification = ic.id_codification
                                                     AND ic.flg_available = 'Y')
                           SELECT ra.id_rehab_area,
                                  pk_translation.get_translation(i_lang, ra.code_rehab_area) desc_area,
                                  (SELECT COUNT(1)
                                     FROM rehab_area_interv rai
                                     JOIN intervention i
                                       ON i.id_intervention = rai.id_intervention
                                     JOIN intervention i_child
                                       ON i.id_intervention = i_child.id_intervention_parent
                                     LEFT JOIN int_codification tc
                                       ON tc.id_intervention = i.id_intervention
                                    WHERE rai.id_rehab_area_interv IN
                                          (SELECT id_rehab_area_interv
                                             FROM rehab_inst_soft
                                            WHERE id_institution IN (0, i_prof.institution)
                                              AND id_software IN (0, i_prof.software)
                                              AND flg_add_remove = 'A'
                                              AND id_rehab_area_interv NOT IN
                                                  (SELECT id_rehab_area_interv
                                                     FROM rehab_inst_soft
                                                    WHERE id_institution IN (0, i_prof.institution)
                                                      AND id_software IN (0, i_prof.software)
                                                      AND flg_add_remove = 'R'))
                                      AND rai.id_rehab_area = ra.id_rehab_area
                                      AND i.flg_status = pk_alert_constant.g_active
                                      AND i_child.flg_status = pk_alert_constant.g_active
                                      AND (i_id_codification IS NULL OR (tc.id_codification = i_id_codification))) count_children
                             FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                             JOIN rehab_area_interv rai
                               ON rai.id_rehab_area = ra.id_rehab_area
                             JOIN intervention i
                               ON i.id_intervention = rai.id_intervention
                             LEFT JOIN int_codification tc
                               ON tc.id_intervention = i.id_intervention
                            WHERE ra.id_rehab_area IN
                                  (SELECT i.id_rehab_area
                                     FROM TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i)
                              AND (i_id_codification IS NULL OR (tc.id_codification = i_id_codification))) t
                            WHERE t.desc_area IS NOT NULL
                            ORDER BY desc_area;
        
        
        ELSE
            OPEN o_areas FOR
                SELECT t.id_rehab_area, t.desc_area, t.id_intervention_parent, t.flg_has_children
                  FROM (WITH rehab_config AS (SELECT id_rehab_inst_soft,
                                                     id_rehab_area_interv,
                                                     id_rehab_session_type,
                                                     flg_execute,
                                                     row_number() over(PARTITION BY id_rehab_area_interv ORDER BY id_institution DESC, id_software DESC) AS rn
                                                FROM rehab_inst_soft ris
                                               WHERE ris.id_institution IN (0, i_prof.institution)
                                                 AND ris.id_software IN (0, i_prof.software)
                                                 AND ris.flg_add_remove = 'A'
                                                 AND ris.id_rehab_area_interv NOT IN
                                                     (SELECT id_rehab_area_interv
                                                        FROM rehab_inst_soft
                                                       WHERE id_institution IN (0, i_prof.institution)
                                                         AND id_software IN (0, i_prof.software)
                                                         AND flg_add_remove = 'R'))
                           SELECT rai.id_rehab_area,
                                  pk_translation.get_translation(i_lang, i.code_intervention) desc_area,
                                  i.id_intervention id_intervention_parent,
                                  nvl2(i_child.id_intervention, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_has_elements,
                                  nvl2(i_grand_child.id_intervention, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_has_children
                             FROM rehab_area_interv rai
                             JOIN rehab_config
                               ON rai.id_rehab_area_interv = rehab_config.id_rehab_area_interv
                             JOIN intervention i
                               ON i.id_intervention = rai.id_intervention
                              AND i.flg_status = pk_alert_constant.g_active
                             LEFT JOIN intervention i_child
                               ON i_child.id_intervention_parent = i.id_intervention
                              AND i_child.flg_status = pk_alert_constant.g_active
                             LEFT JOIN intervention i_grand_child
                               ON i_grand_child.id_intervention_parent = i_child.id_intervention
                              AND i_grand_child.flg_status = pk_alert_constant.g_active
                             LEFT JOIN rehab_session_type rst
                               ON rst.id_rehab_session_type = rehab_config.id_rehab_session_type
                             LEFT JOIN (SELECT ic.id_intervention,
                                               ic.id_codification,
                                               ic.id_interv_codification,
                                               ic.flg_show_codification
                                          FROM codification c, codification_instit_soft cis, interv_codification ic
                                         WHERE c.id_codification = cis.id_codification
                                           AND cis.id_institution = i_prof.institution
                                           AND cis.id_software = i_prof.software
                                           AND c.id_codification = ic.id_codification
                                           AND ic.flg_available = 'Y') tc
                               ON tc.id_intervention = i.id_intervention
                            WHERE (i_intervention_parent IS NULL OR i.id_intervention_parent = i_intervention_parent)
                              AND (i_id_codification IS NULL OR (tc.id_codification = i_id_codification))
                              AND (rai.id_rehab_area = i_rehab_area OR i_rehab_area IS NULL)) t
                            WHERE desc_area IS NOT NULL
                              AND (t.flg_has_elements = pk_alert_constant.g_yes)
                            ORDER BY t.desc_area;
        
        
        END IF;
    
        g_error := 'FETCH PROCEDURES';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_list FOR
            SELECT *
              FROM (SELECT DISTINCT i.id_rehab_area_interv, -- distinct because find_rehab_interv can return the same intervention executable in several institutions
                                    i.id_intervention,
                                    i.id_intervention_parent,
                                    i.id_rehab_area,
                                    pk_translation.get_translation(i_lang, ra.code_rehab_area) AS desc_rehab_area,
                                    pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) ||
                                    decode(tc.id_codification,
                                           NULL,
                                           NULL,
                                           decode(tc.flg_show_codification,
                                                  'Y',
                                                  ' (' || pk_translation.get_translation(i_lang,
                                                                                         'CODIFICATION.CODE_CODIFICATION.' ||
                                                                                         tc.id_codification) || ')',
                                                  NULL)) desc_interv,
                                    i.flg_has_children,
                                    i.id_rehab_session_type,
                                    pk_translation.get_translation(i_lang, i.code_rehab_session_type) AS desc_rehab_session_type,
                                    tc.id_codification,
                                    pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', i.id_intervention) flg_laterality_mcdt,
                                    decode(iq.id_intervention, NULL, pk_alert_constant.g_no, pk_alert_constant.g_yes) flg_clinical_question
                      FROM TABLE(find_inst_rehab_areas(i_prof.institution, i_rehab_area)) ra
                      JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                        ON i.id_rehab_area = ra.id_rehab_area
                      LEFT JOIN (SELECT ic.id_intervention,
                                       ic.id_codification,
                                       ic.id_interv_codification,
                                       ic.flg_show_codification
                                  FROM codification c, codification_instit_soft cis, interv_codification ic
                                 WHERE c.id_codification = cis.id_codification
                                   AND cis.id_institution = i_prof.institution
                                   AND cis.id_software = i_prof.software
                                   AND c.id_codification = ic.id_codification
                                   AND ic.flg_available = 'Y') tc
                        ON tc.id_intervention = i.id_intervention
                      LEFT JOIN (SELECT id_intervention
                                  FROM (SELECT DISTINCT id_intervention, flg_mandatory
                                          FROM interv_questionnaire
                                         WHERE flg_time = 'O'
                                           AND id_institution = i_prof.institution
                                           AND flg_available = pk_alert_constant.g_yes)
                                 GROUP BY id_intervention) iq
                        ON iq.id_intervention = i.id_intervention
                     WHERE (ra.id_rehab_area = i_rehab_area)
                       AND (i_intervention_parent IS NULL OR i.id_intervention_parent = i_intervention_parent)
                       AND (i_id_codification IS NULL OR (tc.id_codification = i_id_codification)))
             WHERE desc_interv IS NOT NULL
               AND desc_rehab_area IS NOT NULL
               AND flg_has_children = pk_alert_constant.g_no
             ORDER BY desc_interv;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_rehab_area=' || i_rehab_area || ',i_intervention_parent=' ||
                                  i_intervention_parent || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_types.open_my_cursor(o_areas);
            pk_types.open_my_cursor(o_list);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_interv_list;

    /**********************************************************************************************
    * Returns the list of rehab procedures parameterized for the current institution/software 
    * that match the search expression
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_keyword                Word to search
    * %param i_id_codification        id_codification
    * %param o_list                   list of matches
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_interv_search
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_keyword         IN VARCHAR2,
        i_id_codification IN interv_codification.id_codification%TYPE,
        o_list            OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_INTERV_SEARCH';
        l_search_limit sys_config.value%TYPE;
        l_count        PLS_INTEGER;
    
        l_no_results EXCEPTION;
        l_over_limit EXCEPTION;
        l_column_name  VARCHAR2(4000);
        l_column_name2 VARCHAR2(4000);
        l_id_category  category.id_category%TYPE;
    
    BEGIN
        g_error := 'GET SEARCH RESULT LIMIT';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        l_search_limit := pk_sysconfig.get_config('NUM_RECORD_SEARCH', i_prof);
    
        g_error       := 'CALL pk_prof_utils.get_id_category';
        l_id_category := pk_prof_utils.get_id_category(i_lang, i_prof);
    
        g_error := 'Call pk_translation.format_column_name l_column_name';
        SELECT pk_translation.format_column_name(i.code_intervention)
          INTO l_column_name
          FROM intervention i
         WHERE rownum < 2;
        g_error := 'Call pk_translation.format_column_name l_column_name2';
        BEGIN
            SELECT pk_translation.format_column_name(ia.code_intervention_alias)
              INTO l_column_name2
              FROM intervention_alias ia
             WHERE rownum < 2;
        EXCEPTION
            WHEN no_data_found THEN
                l_column_name2 := NULL;
        END;
    
        g_error := 'COUNT RESULTS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        SELECT COUNT(*)
          INTO l_count
          FROM (SELECT t.desc_translation desc_interv
                  FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                  JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                    ON i.id_rehab_area = ra.id_rehab_area
                  JOIN TABLE(pk_translation.get_search_translation(i_lang, i_keyword, l_column_name)) t
                    ON t.code_translation = i.code_intervention
                  LEFT JOIN interv_codification ic
                    ON ic.id_intervention = i.id_intervention
                 WHERE t.desc_translation IS NOT NULL
                   AND (i_id_codification IS NULL OR (ic.id_codification = i_id_codification AND ic.flg_available = 'Y'))
                UNION
                SELECT t.desc_translation desc_interv
                  FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                  JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                    ON i.id_rehab_area = ra.id_rehab_area
                  JOIN intervention_alias ia
                    ON ia.id_intervention = i.id_intervention
                  JOIN TABLE(pk_translation.get_search_translation(i_lang, i_keyword, l_column_name2)) t
                    ON t.code_translation = ia.code_intervention_alias
                  LEFT JOIN interv_codification ic
                    ON ic.id_intervention = i.id_intervention
                 WHERE t.desc_translation IS NOT NULL
                   AND nvl(ia.id_professional, 0) IN (i_prof.id, 0)
                   AND nvl(ia.id_institution, 0) IN (i_prof.institution, 0)
                   AND nvl(ia.id_software, 0) IN (i_prof.software, 0)
                   AND nvl(ia.id_category, 0) IN (l_id_category, 0)
                   AND (i_id_codification IS NULL OR (ic.id_codification = i_id_codification AND ic.flg_available = 'Y')));
    
        IF l_count = 0
        THEN
            RAISE l_no_results;
        ELSIF l_count > l_search_limit
        THEN
            RAISE l_over_limit;
        END IF;
    
        g_error := 'SEARCH PROCEDURES';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_list FOR
            SELECT id_rehab_area_interv,
                   id_intervention,
                   id_intervention_parent,
                   id_rehab_area,
                   desc_rehab_area,
                   pk_procedures_api_db.get_alias_translation(i_lang, i_prof, code_interv, NULL) ||
                   decode(id_codification,
                          NULL,
                          NULL,
                          decode(flg_show_codification,
                                 'Y',
                                 ' (' ||
                                 pk_translation.get_translation(i_lang,
                                                                'CODIFICATION.CODE_CODIFICATION.' || id_codification) || ')',
                                 NULL)) desc_interv,
                   flg_has_children,
                   id_rehab_session_type,
                   desc_rehab_session_type,
                   pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', id_intervention) flg_laterality_mcdt,
                   id_codification
              FROM (SELECT i.id_rehab_area_interv,
                           i.id_intervention,
                           i.id_intervention_parent,
                           i.id_rehab_area,
                           pk_translation.get_translation(i_lang, ra.code_rehab_area) AS desc_rehab_area,
                           i.code_intervention code_interv,
                           i.flg_has_children,
                           i.id_rehab_session_type,
                           pk_translation.get_translation(i_lang, i.code_rehab_session_type) AS desc_rehab_session_type,
                           ic.id_codification AS id_codification,
                           ic.flg_show_codification AS flg_show_codification
                      FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                      JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                        ON (i.id_rehab_area = ra.id_rehab_area)
                      JOIN TABLE(pk_translation.get_search_translation(i_lang, i_keyword, l_column_name)) t
                        ON (t.code_translation = i.code_intervention)
                      LEFT JOIN interv_codification ic
                        ON ic.id_intervention = i.id_intervention
                     WHERE t.desc_translation IS NOT NULL
                       AND (i_id_codification IS NULL OR
                           (ic.id_codification = i_id_codification AND ic.flg_available = 'Y'))
                    UNION
                    -- Synonyms search
                    SELECT i.id_rehab_area_interv,
                           i.id_intervention,
                           i.id_intervention_parent,
                           i.id_rehab_area,
                           pk_translation.get_translation(i_lang, ra.code_rehab_area) AS desc_rehab_area,
                           i.code_intervention code_interv,
                           i.flg_has_children,
                           i.id_rehab_session_type,
                           pk_translation.get_translation(i_lang, i.code_rehab_session_type) AS desc_rehab_session_type,
                           ic.id_codification AS id_codification,
                           ic.flg_show_codification
                      FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                      JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                        ON i.id_rehab_area = ra.id_rehab_area
                      JOIN intervention_alias ia
                        ON ia.id_intervention = i.id_intervention
                      JOIN TABLE(pk_translation.get_search_translation(i_lang, i_keyword, l_column_name2)) t
                        ON t.code_translation = ia.code_intervention_alias
                      LEFT JOIN interv_codification ic
                        ON ic.id_intervention = i.id_intervention
                     WHERE t.desc_translation IS NOT NULL
                       AND nvl(ia.id_professional, 0) IN (i_prof.id, 0)
                       AND nvl(ia.id_institution, 0) IN (i_prof.institution, 0)
                       AND nvl(ia.id_software, 0) IN (i_prof.software, 0)
                       AND nvl(ia.id_category, 0) IN (l_id_category, 0)
                       AND (i_id_codification IS NULL OR
                           (ic.id_codification = i_id_codification AND ic.flg_available = 'Y')))
             ORDER BY desc_interv;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_no_results THEN
            pk_alertlog.log_error('Parameters: i_keyword=' || i_keyword || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_types.open_my_cursor(o_list);
            RETURN pk_search.noresult_handler(i_lang     => i_lang,
                                              i_prof     => i_prof,
                                              i_pck_name => g_package_name,
                                              i_unitname => l_func_name,
                                              o_error    => o_error);
        
        WHEN l_over_limit THEN
            pk_alertlog.log_error('Parameters: i_keyword=' || i_keyword || ' @' || g_error);
            pk_types.open_my_cursor(o_list);
            RETURN pk_search.overlimit_handler(i_lang     => i_lang,
                                               i_prof     => i_prof,
                                               i_pck_name => g_package_name,
                                               i_unitname => l_func_name,
                                               o_error    => o_error);
        
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_keyword=' || i_keyword || ' @' || g_error);
            pk_types.open_my_cursor(o_list);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_interv_search;

    FUNCTION tf_get_rehab_interv_search
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_keyword         IN VARCHAR2,
        i_id_codification IN interv_codification.id_codification%TYPE
    ) RETURN t_tbl_rehab_interv_search IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_INTERV_SEARCH';
        l_search_limit sys_config.value%TYPE;
        l_count        PLS_INTEGER;
    
        l_no_results EXCEPTION;
        l_over_limit EXCEPTION;
        l_column_name  VARCHAR2(4000);
        l_column_name2 VARCHAR2(4000);
        l_id_category  category.id_category%TYPE;
    
        l_ret t_tbl_rehab_interv_search := t_tbl_rehab_interv_search();
    
        l_error t_error_out;
    BEGIN
    
        g_error := 'GET SEARCH RESULT LIMIT';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        l_search_limit := pk_sysconfig.get_config('NUM_RECORD_SEARCH', i_prof);
    
        g_error       := 'CALL pk_prof_utils.get_id_category';
        l_id_category := pk_prof_utils.get_id_category(i_lang, i_prof);
    
        g_error := 'Call pk_translation.format_column_name l_column_name';
        SELECT pk_translation.format_column_name(i.code_intervention)
          INTO l_column_name
          FROM intervention i
         WHERE rownum < 2;
        g_error := 'Call pk_translation.format_column_name l_column_name2';
        BEGIN
            SELECT pk_translation.format_column_name(ia.code_intervention_alias)
              INTO l_column_name2
              FROM intervention_alias ia
             WHERE rownum < 2;
        EXCEPTION
            WHEN no_data_found THEN
                l_column_name2 := NULL;
        END;
    
        g_error := 'COUNT RESULTS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        SELECT COUNT(*)
          INTO l_count
          FROM (SELECT t.desc_translation desc_interv
                  FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                  JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                    ON i.id_rehab_area = ra.id_rehab_area
                  JOIN TABLE(pk_translation.get_search_translation(i_lang, i_keyword, l_column_name)) t
                    ON t.code_translation = i.code_intervention
                  LEFT JOIN interv_codification ic
                    ON ic.id_intervention = i.id_intervention
                 WHERE t.desc_translation IS NOT NULL
                   AND (i_id_codification IS NULL OR (ic.id_codification = i_id_codification AND ic.flg_available = 'Y'))
                UNION
                SELECT t.desc_translation desc_interv
                  FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                  JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                    ON i.id_rehab_area = ra.id_rehab_area
                  JOIN intervention_alias ia
                    ON ia.id_intervention = i.id_intervention
                  JOIN TABLE(pk_translation.get_search_translation(i_lang, i_keyword, l_column_name2)) t
                    ON t.code_translation = ia.code_intervention_alias
                  LEFT JOIN interv_codification ic
                    ON ic.id_intervention = i.id_intervention
                 WHERE t.desc_translation IS NOT NULL
                   AND nvl(ia.id_professional, 0) IN (i_prof.id, 0)
                   AND nvl(ia.id_institution, 0) IN (i_prof.institution, 0)
                   AND nvl(ia.id_software, 0) IN (i_prof.software, 0)
                   AND nvl(ia.id_category, 0) IN (l_id_category, 0)
                   AND (i_id_codification IS NULL OR (ic.id_codification = i_id_codification AND ic.flg_available = 'Y')));
    
        IF l_count = 0
        THEN
            RAISE l_no_results;
        ELSIF l_count > l_search_limit
        THEN
            RAISE l_over_limit;
        END IF;
    
        g_error := 'SEARCH PROCEDURES';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        SELECT t_rehab_interv_search(id_rehab_area_interv    => t.id_rehab_area_interv,
                                     id_intervention         => t.id_intervention,
                                     id_intervention_parent  => t.id_intervention_parent,
                                     id_rehab_area           => t.id_rehab_area,
                                     desc_rehab_area         => t.desc_rehab_area,
                                     desc_interv             => t.desc_interv,
                                     flg_has_children        => t.flg_has_children,
                                     id_rehab_session_type   => t.id_rehab_session_type,
                                     desc_rehab_session_type => t.desc_rehab_session_type,
                                     flg_laterality_mcdt     => t.flg_laterality_mcdt,
                                     id_codification         => t.id_codification)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT id_rehab_area_interv,
                       id_intervention,
                       id_intervention_parent,
                       id_rehab_area,
                       desc_rehab_area,
                       pk_procedures_api_db.get_alias_translation(i_lang, i_prof, code_interv, NULL) ||
                       decode(id_codification,
                              NULL,
                              NULL,
                              decode(flg_show_codification,
                                     'Y',
                                     ' (' ||
                                     pk_translation.get_translation(i_lang,
                                                                    'CODIFICATION.CODE_CODIFICATION.' || id_codification) || ')',
                                     NULL)) desc_interv,
                       flg_has_children,
                       id_rehab_session_type,
                       desc_rehab_session_type,
                       pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', id_intervention) flg_laterality_mcdt,
                       id_codification
                  FROM (SELECT i.id_rehab_area_interv,
                               i.id_intervention,
                               i.id_intervention_parent,
                               i.id_rehab_area,
                               pk_translation.get_translation(i_lang, ra.code_rehab_area) desc_rehab_area,
                               i.code_intervention code_interv,
                               i.flg_has_children,
                               i.id_rehab_session_type,
                               pk_translation.get_translation(i_lang, i.code_rehab_session_type) desc_rehab_session_type,
                               ic.id_codification,
                               ic.flg_show_codification
                          FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                          JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                            ON (i.id_rehab_area = ra.id_rehab_area)
                          JOIN TABLE(pk_translation.get_search_translation(i_lang, i_keyword, l_column_name)) t
                            ON (t.code_translation = i.code_intervention)
                          LEFT JOIN interv_codification ic
                            ON ic.id_intervention = i.id_intervention
                         WHERE t.desc_translation IS NOT NULL
                           AND (i_id_codification IS NULL OR
                               (ic.id_codification = i_id_codification AND ic.flg_available = 'Y'))
                        UNION
                        -- Synonyms search
                        SELECT i.id_rehab_area_interv,
                               i.id_intervention,
                               i.id_intervention_parent,
                               i.id_rehab_area,
                               pk_translation.get_translation(i_lang, ra.code_rehab_area) desc_rehab_area,
                               i.code_intervention code_interv,
                               i.flg_has_children,
                               i.id_rehab_session_type,
                               pk_translation.get_translation(i_lang, i.code_rehab_session_type) desc_rehab_session_type,
                               ic.id_codification,
                               ic.flg_show_codification
                          FROM TABLE(find_inst_rehab_areas(i_prof.institution)) ra
                          JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) i
                            ON i.id_rehab_area = ra.id_rehab_area
                          JOIN intervention_alias ia
                            ON ia.id_intervention = i.id_intervention
                          JOIN TABLE(pk_translation.get_search_translation(i_lang, i_keyword, l_column_name2)) t
                            ON t.code_translation = ia.code_intervention_alias
                          LEFT JOIN interv_codification ic
                            ON ic.id_intervention = i.id_intervention
                         WHERE t.desc_translation IS NOT NULL
                           AND nvl(ia.id_professional, 0) IN (i_prof.id, 0)
                           AND nvl(ia.id_institution, 0) IN (i_prof.institution, 0)
                           AND nvl(ia.id_software, 0) IN (i_prof.software, 0)
                           AND nvl(ia.id_category, 0) IN (l_id_category, 0)
                           AND (i_id_codification IS NULL OR
                               (ic.id_codification = i_id_codification AND ic.flg_available = 'Y')))
                 ORDER BY desc_interv) t;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN l_no_results THEN
            pk_alertlog.log_error('Parameters: i_keyword=' || i_keyword || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            RETURN t_tbl_rehab_interv_search();
        
        WHEN l_over_limit THEN
            pk_alertlog.log_error('Parameters: i_keyword=' || i_keyword || ' @' || g_error);
            RETURN t_tbl_rehab_interv_search();
        
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_keyword=' || i_keyword || ' @' || g_error);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN t_tbl_rehab_interv_search();
    END tf_get_rehab_interv_search;

    /**********************************************************************************************
    * Returns a list of rehab areas that the professional is or can be allocated to in a given institution
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_institution         institution
    * %param o_areas                  list of rehab areas
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_area_prof
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_institution IN institution.id_institution%TYPE,
        o_areas          OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_AREA_PROF';
    BEGIN
        g_error := 'OPEN o_areas for id_professional=' || i_prof.id || ', id_institution=' || i_id_institution;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_areas FOR
            SELECT *
              FROM (SELECT i_id_institution AS id_institution,
                           rai.id_rehab_area,
                           pk_translation.get_translation(i_lang, rai.code_rehab_area) desc_area,
                           nvl2(raip.id_rehab_area_inst, pk_alert_constant.g_yes, pk_alert_constant.g_no) AS flg_selected
                      FROM TABLE(find_inst_rehab_areas(i_id_institution)) rai
                      LEFT JOIN rehab_area_inst_prof raip
                        ON rai.id_rehab_area_inst = raip.id_rehab_area_inst
                       AND raip.id_professional = i_prof.id)
             WHERE desc_area IS NOT NULL
             ORDER BY desc_area;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_institution=' || i_id_institution || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_types.open_my_cursor(o_areas);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_area_prof;

    /**********************************************************************************************
    * Sets the list of rehab areas that the professional is allocated to, in one or more institutions
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_institution            list of institutions to alloc the professional
    * %param i_rehab_area             for each institution a list of rehab areas to alloc the professional
    * %param i_test                   if is to test the remove of the groups of areas not selected
    * %param o_flg_show               show message? Y/N
    * %param o_msg_title              the title of message
    * %param o_msg_result             the body of the message
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION set_rehab_area_prof
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_institution IN table_number,
        i_rehab_area  IN table_table_number,
        i_test        IN VARCHAR2,
        o_flg_show    OUT VARCHAR2,
        o_msg_title   OUT VARCHAR2,
        o_msg_result  OUT VARCHAR2,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_AREA_PROF';
        l_groups               pk_types.cursor_type;
        l_rehab_group_areas    table_number := table_number();
        l_dummy                VARCHAR2(4000);
        l_extra_rehab_area_ids table_number := table_number();
        l_rehab_area           rehab_area.id_rehab_area%TYPE;
        l_flg_selected         VARCHAR2(10);
    
        l_tbl_extra_rehab_desc table_varchar;
    
    BEGIN
        o_flg_show := pk_alert_constant.g_no;
    
        -- verifica se o profissional pertence a algum grupo que pertença a uma área não selecionada
        g_error := 'get_rehab_groups_prof';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        IF NOT get_rehab_groups_prof(i_lang => i_lang, i_prof => i_prof, o_groups => l_groups, o_error => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'l_groups loop';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        LOOP
            FETCH l_groups
                INTO l_dummy, l_dummy, l_dummy, l_rehab_area, l_dummy, l_flg_selected;
        
            EXIT WHEN l_groups%NOTFOUND;
        
            IF l_flg_selected = pk_alert_constant.g_yes
            THEN
                l_rehab_group_areas.extend();
                l_rehab_group_areas(l_rehab_group_areas.last) := l_rehab_area;
            END IF;
        END LOOP;
    
        g_error := 'test if there are group areas that now don''t belong to the professional';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        IF l_rehab_group_areas.count > 0
        THEN
            FOR i IN 1 .. i_institution.count
            LOOP
                SELECT column_value
                  BULK COLLECT
                  INTO l_extra_rehab_area_ids
                  FROM (SELECT column_value
                          FROM TABLE(l_rehab_group_areas)
                        MINUS
                        SELECT column_value
                          FROM TABLE(i_rehab_area(i)));
            END LOOP;
        END IF;
    
        g_error := 'test if there are group areas that now don''t belong to the professional';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        IF l_extra_rehab_area_ids.count() > 0
           AND i_test = pk_alert_constant.g_yes
        THEN
            g_error := 'show confirmation message';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            o_flg_show  := pk_alert_constant.g_yes;
            o_msg_title := pk_message.get_message(i_lang, 'REHAB_T108');
        
            SELECT a.description
              BULK COLLECT
              INTO l_tbl_extra_rehab_desc
              FROM rehab_group a
              JOIN rehab_group_prof rgp
                ON rgp.id_rehab_group = a.id_rehab_group
               AND rgp.id_professional = i_prof.id
             WHERE a.id_rehab_area IN (SELECT column_value
                                         FROM TABLE(l_extra_rehab_area_ids));
        
            o_msg_result := REPLACE(pk_message.get_message(i_lang, 'REHAB_T109'),
                                    '@1',
                                    pk_utils.concat_table(l_tbl_extra_rehab_desc, ', '));
            RETURN TRUE;
        ELSIF l_extra_rehab_area_ids.count() > 0
              AND i_test = pk_alert_constant.g_no
        THEN
        
            --send event to intf_alert: delete professional from a group
            FOR i IN (SELECT rgp.id_rehab_group, rgp.id_professional
                        FROM rehab_group_prof rgp
                        JOIN rehab_group rg
                          ON rg.id_rehab_group = rgp.id_rehab_group
                        JOIN rehab_area ra
                          ON ra.id_rehab_area = rg.id_rehab_area
                       WHERE rgp.id_professional = i_prof.id
                         AND rg.id_institution = i_prof.institution
                         AND ra.id_rehab_area IN (SELECT column_value
                                                    FROM TABLE(l_extra_rehab_area_ids)))
            LOOP
            
                pk_alertlog.log_debug('Send event to intf_alert: update rehab group: i_id_institution = ' ||
                                      i_prof.institution || ', i_id_rehab_group = ' || i.id_rehab_group);
                pk_ia_event_rehabilitation.rehab_group_update(i_id_institution => i_prof.institution,
                                                              i_id_rehab_group => i.id_rehab_group);
            
            END LOOP;
        
            g_error := 'delete group associations';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            DELETE FROM rehab_group_prof rgp
             WHERE (id_rehab_group, id_professional) IN
                   (SELECT rgp.id_rehab_group, rgp.id_professional
                      FROM rehab_group_prof rgp
                      JOIN rehab_group rg
                        ON rg.id_rehab_group = rgp.id_rehab_group
                      JOIN rehab_area ra
                        ON ra.id_rehab_area = rg.id_rehab_area
                     WHERE rgp.id_professional = i_prof.id
                       AND rg.id_institution = i_prof.institution
                       AND ra.id_rehab_area IN (SELECT column_value
                                                  FROM TABLE(l_extra_rehab_area_ids)));
        
        END IF;
    
        FOR x IN 1 .. i_institution.count
        LOOP
            g_error := 'Delete rehab_areas not in ';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            DELETE FROM rehab_area_inst_prof raip
             WHERE raip.id_professional = i_prof.id
               AND raip.id_rehab_area_inst NOT IN
                   (SELECT rai.id_rehab_area_inst
                      FROM TABLE(find_inst_rehab_areas(i_institution(x))) rai
                     WHERE rai.id_rehab_area IN (SELECT /*+opt_estimate (table t rows=1)*/
                                                  column_value
                                                   FROM TABLE(i_rehab_area(x)) t))
               AND raip.id_rehab_area_inst IN
                   (SELECT rai.id_rehab_area_inst
                      FROM TABLE(find_inst_rehab_areas(i_institution(x))) rai
                     WHERE rai.id_rehab_area NOT IN (SELECT /*+opt_estimate (table t rows=1)*/
                                                      column_value
                                                       FROM TABLE(i_rehab_area(x)) t));
        END LOOP;
    
        g_error := 'for each institution';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        FOR i IN 1 .. i_institution.count
        LOOP
            g_error := 'insert ' || ' minus already there';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            INSERT INTO rehab_area_inst_prof
                (id_rehab_area_inst, id_professional)
                SELECT id_rehab_area_inst, i_prof.id
                  FROM (SELECT rai.id_rehab_area_inst
                          FROM TABLE(find_inst_rehab_areas(i_institution(i))) rai
                         WHERE rai.id_rehab_area IN (SELECT column_value
                                                       FROM TABLE(i_rehab_area(i)))
                        MINUS
                        SELECT id_rehab_area_inst
                          FROM rehab_area_inst_prof raip
                         WHERE raip.id_professional = i_prof.id);
        END LOOP;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_rehab_area_prof;

    /**********************************************************************************************
    * Creates a new rehab group
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_short_name             name of group
    * %param i_description            description
    * %param i_flg_status             Active or Inactive
    * %param i_id_rehab_area          belongg to which rehab area
    * %param o_id_rehab_group         the id of the group created
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION create_rehab_group
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_short_name     IN VARCHAR2,
        i_description    IN VARCHAR2,
        i_flg_status     IN VARCHAR2,
        i_id_rehab_area  IN NUMBER,
        o_id_rehab_group OUT rehab_group.id_rehab_group%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CREATE_REHAB_GROUP';
        l_next_key  rehab_group.id_rehab_group%TYPE;
        l_rowids    table_varchar;
        l_same_desc NUMBER;
        duplicate_values EXCEPTION;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        SELECT nvl(COUNT(*), 0)
          INTO l_same_desc
          FROM rehab_group rg
          JOIN rehab_area ra
            ON ra.id_rehab_area = rg.id_rehab_area
         WHERE rg.id_institution = i_prof.institution
           AND (upper(rg.name) = upper(i_short_name) OR upper(rg.description) = upper(i_description));
    
        IF l_same_desc > 0
        THEN
            g_error := pk_message.get_message(i_lang, 'REHAB_M100');
            raise_application_error(-20002, pk_message.get_message(i_lang, 'REHAB_M100'));
        END IF;
    
        g_error := 'GET NEXT KEY';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        l_next_key := ts_rehab_group.next_key;
    
        g_error := 'INSERT GROUP';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_group.ins(id_rehab_group_in  => l_next_key,
                           name_in            => i_short_name,
                           description_in     => i_description,
                           flg_status_in      => i_flg_status,
                           id_professional_in => i_prof.id,
                           id_institution_in  => i_prof.institution,
                           dt_rehab_group_in  => g_sysdate_tstz,
                           id_rehab_area_in   => i_id_rehab_area,
                           rows_out           => l_rowids);
    
        g_error := 't_data_gov_mnt.process_insert';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_GROUP',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        o_id_rehab_group := l_next_key;
    
        pk_alertlog.log_debug('Send event to intf_alert: create rehab group: i_id_institution = ' ||
                              i_prof.institution || ', i_id_rehab_group = ' || o_id_rehab_group);
        pk_ia_event_rehabilitation.rehab_group_new(i_id_institution => i_prof.institution,
                                                   i_id_rehab_group => o_id_rehab_group);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN duplicate_values THEN
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              pk_message.get_message(i_lang, 'REHAB_M100'),
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_short_name=' || i_short_name || ', i_description=' || i_description ||
                                  ', i_flg_status=' || i_flg_status || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END create_rehab_group;

    /**********************************************************************************************
    * Returns a list of rehab groups for the professional's institution
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param o_groups                 list of groups the professional belongs
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_groups
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        o_groups OUT pk_types.cursor_type,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name              CONSTANT VARCHAR2(30) := 'GET_REHAB_GROUPS';
        l_rehab_group_flg_status CONSTANT sys_domain.code_domain%TYPE := 'REHAB_GROUP.FLG_STATUS';
    
    BEGIN
        g_error := 'o_groups';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_groups FOR
            SELECT rg.id_rehab_group,
                   rg.name,
                   rg.description,
                   pk_sysdomain.get_domain(l_rehab_group_flg_status, rg.flg_status, i_lang) status_desc,
                   rg.flg_status,
                   pk_sysdomain.get_rank(i_lang, l_rehab_group_flg_status, rg.flg_status) rank,
                   ra.id_rehab_area id_rehab_area,
                   pk_translation.get_translation(i_lang, ra.code_rehab_area) rehab_area
              FROM rehab_group rg
              JOIN rehab_area ra
                ON ra.id_rehab_area = rg.id_rehab_area
             WHERE rg.id_institution = i_prof.institution
             ORDER BY rank, rg.name, rehab_area, rg.description;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_short_name=' || ' @' || g_error, g_package_name, l_func_name);
            pk_types.open_my_cursor(o_groups);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_groups;

    /**********************************************************************************************
    * Updates a rehab group details
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_group         id of the group
    * %param i_short_name             name of group
    * %param i_description            description
    * %param i_flg_status             Active or Inactive
    * %param i_id_rehab_area          belongg to which rehab area
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION update_rehab_group
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_group IN rehab_group.id_rehab_group%TYPE,
        i_short_name     IN VARCHAR2,
        i_description    IN VARCHAR2,
        i_flg_status     IN VARCHAR2,
        i_id_rehab_area  IN NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'UPDATE_REHAB_GROUP';
        l_rowids table_varchar;
    
    BEGIN
        g_error := 'UPDATE STATUS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_group.upd(id_rehab_group_in => i_id_rehab_group,
                           name_in           => i_short_name,
                           name_nin          => TRUE,
                           description_in    => i_description,
                           description_nin   => TRUE,
                           flg_status_in     => i_flg_status,
                           flg_status_nin    => TRUE,
                           id_rehab_area_in  => i_id_rehab_area,
                           id_rehab_area_nin => TRUE,
                           rows_out          => l_rowids);
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_GROUP',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        --send event to intf_alert: update all professionals from a group
        pk_alertlog.log_debug('Send event to intf_alert: update rehab group: i_id_institution = ' ||
                              i_prof.institution || ', i_id_rehab_group = ' || i_id_rehab_group);
        pk_ia_event_rehabilitation.rehab_group_update(i_id_institution => i_prof.institution,
                                                      i_id_rehab_group => i_id_rehab_group);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_group=' || i_id_rehab_group || ', i_short_name=' ||
                                  i_short_name || ', i_description=' || i_description || ', i_flg_status=' ||
                                  i_flg_status || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END update_rehab_group;

    /**********************************************************************************************
    * Returns a list of rehab groups for the professional in the current institution
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param o_groups                 list of rehab groups
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_groups_prof
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        o_groups OUT pk_types.cursor_type,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_GROUPS_PROF';
    BEGIN
        g_error := 'GROUPS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_groups FOR
            SELECT rg.id_rehab_group,
                   rg.name,
                   rg.description,
                   ra.id_rehab_area id_rehab_area,
                   pk_translation.get_translation(i_lang, ra.code_rehab_area) rehab_area,
                   nvl2(rgp.id_professional, pk_alert_constant.g_yes, pk_alert_constant.g_no) AS flg_selected
              FROM rehab_group rg
              LEFT JOIN rehab_group_prof rgp
                ON rgp.id_rehab_group = rg.id_rehab_group
               AND rgp.id_professional = i_prof.id
              JOIN rehab_area ra
                ON ra.id_rehab_area = rg.id_rehab_area
              JOIN (SELECT rai.id_rehab_area
                      FROM TABLE(pk_rehab.find_inst_rehab_areas(i_prof.institution)) rai
                      JOIN rehab_area_inst_prof raip
                        ON raip.id_rehab_area_inst = rai.id_rehab_area_inst
                       AND raip.id_professional = i_prof.id) x
                ON x.id_rehab_area = rg.id_rehab_area
             WHERE rg.id_institution = i_prof.institution
               AND rg.flg_status = pk_alert_constant.g_active
             ORDER BY rg.name, rg.description;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: ' || ' @' || g_error, g_package_name, l_func_name);
            pk_types.open_my_cursor(o_groups);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_groups_prof;

    --  
    /**********************************************************************************************
    * Sets the list of rehab groups that the professional is allocated to
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_groups                 list of rehab_groups
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION set_rehab_groups_prof
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        i_groups IN table_number,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_GROUPS_PROF';
    BEGIN
        g_error := 'DELETE for id_professiona=' || i_prof.id;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        --
        FOR i IN (SELECT rgp.id_rehab_group
                    FROM rehab_group_prof rgp
                   WHERE rgp.id_professional = i_prof.id)
        LOOP
            pk_alertlog.log_debug('Send event to intf_alert: update rehab group: i_id_institution = ' ||
                                  i_prof.institution || ', i_id_rehab_group = ' || i.id_rehab_group);
            pk_ia_event_rehabilitation.rehab_group_update(i_id_institution => i_prof.institution,
                                                          i_id_rehab_group => i.id_rehab_group);
        
        END LOOP;
    
        DELETE FROM rehab_group_prof rgp
         WHERE rgp.id_professional = i_prof.id;
    
        g_error := 'INSERT';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        FOR i IN 1 .. i_groups.count
        LOOP
            INSERT INTO rehab_group_prof
                (id_rehab_group, id_professional)
            VALUES
                (i_groups(i), i_prof.id);
        
            pk_alertlog.log_debug('Send event to intf_alert: create rehab group: i_id_institution = ' ||
                                  i_prof.institution || ', i_id_rehab_group = ' || i_groups(i));
            pk_ia_event_rehabilitation.rehab_group_new(i_id_institution => i_prof.institution,
                                                       i_id_rehab_group => i_groups(i));
        
        END LOOP;
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_groups=' || pk_utils.concat_table(i_groups) || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_rehab_groups_prof;

    /**********************************************************************************************
    * Returns a list of rehab needs open (waiting for scheduling) in this MFR plan
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_episode_origin      origin episode
    * %param o_sch_needs              list of cheduling needs waiting for scheduling
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_sch_existing
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_episode_origin IN rehab_sch_need.id_episode_origin%TYPE,
        o_sch_needs         OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_SCH_EXISTING';
    BEGIN
        g_sysdate_tstz := systimestamp;
    
        g_error := 'o_sch_needs';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_sch_needs FOR
            SELECT rsn.id_rehab_sch_need, get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) desc_instructions
              FROM rehab_sch_need rsn
             WHERE rsn.id_episode_origin = i_id_episode_origin
               AND rsn.flg_status = g_rehab_sch_need_wait_sch
            UNION ALL
            SELECT -1, pk_message.get_message(i_lang, 'REHAB_T120')
              FROM dual
             ORDER BY id_rehab_sch_need DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_episode_origin=' || i_id_episode_origin || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_types.open_my_cursor(o_sch_needs);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_sch_existing;

    /**********************************************************************************************
    * return the icon to be used in sessions
    *
    * %param i_lang                   id_language
    * %param i_id_rehab_sch_need      
    * %param i_sessions 
    * %param i_flg_status 
    *
    * @return                         icon name
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rsn_icon
    (
        i_lang              IN language.id_language%TYPE,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_sessions          IN rehab_sch_need.sessions%TYPE,
        i_flg_status        IN rehab_sch_need.flg_status%TYPE
    ) RETURN VARCHAR2 IS
        l_flg_status rehab_sch_need.flg_status%TYPE := i_flg_status;
        l_count      NUMBER;
        l_icon       sys_domain.img_name%TYPE;
        l_count_disc NUMBER;
    BEGIN
        IF i_sessions IS NOT NULL
           AND i_flg_status != g_rehab_sch_need_cancel
        THEN
            SELECT COUNT(*)
              INTO l_count
              FROM rehab_schedule rs
             WHERE rs.id_rehab_sch_need = i_id_rehab_sch_need
               AND rs.flg_status = pk_alert_constant.g_active;
        
            -- responsável é o grupo           
            IF l_count = 0
            THEN
                SELECT COUNT(*)
                  INTO l_count
                  FROM sch_rehab_group srg
                 INNER JOIN rehab_sch_need rsn
                    ON rsn.id_rehab_sch_need = srg.id_rehab_sch_need
                 WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need
                   AND srg.flg_status = pk_alert_constant.g_active;
            END IF;
        
            IF l_count < i_sessions
            THEN
                -- se o número de sessões agendadas é menor que número requisitado o icon é igual ao do por agendar
            
                SELECT COUNT(*)
                  INTO l_count_disc
                  FROM rehab_presc a
                 WHERE a.id_rehab_sch_need = i_id_rehab_sch_need
                   AND a.flg_status = g_rehab_presc_discontinued;
                IF l_count_disc > 0
                THEN
                    l_icon := 'SCH_ScheduledPauseIcon';
                ELSE
                
                    l_flg_status := g_rehab_sch_need_wait_sch;
                    l_icon       := pk_sysdomain.get_img(i_lang, g_rehab_sch_need_flg_status, l_flg_status);
                END IF;
            ELSIF l_count = i_sessions
            THEN
                l_flg_status := g_rehab_sch_need_scheduled;
                l_icon       := pk_sysdomain.get_img(i_lang, g_rehab_sch_need_flg_status, l_flg_status);
            END IF;
        
        END IF;
    
        RETURN l_icon;
    END get_rsn_icon;

    /**********************************************************************************************
    * return the text to be used in sessions icons
    *
    * %param i_lang                   id_language
    * %param i_id_rehab_sch_need 
    * %param i_flg_status 
    * %param i_sessions 
    *
    * @return                         icon label
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rsn_icon_label
    (
        i_lang              IN language.id_language%TYPE,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_flg_status        IN rehab_sch_need.flg_status%TYPE,
        i_sessions          IN rehab_sch_need.sessions%TYPE
    ) RETURN VARCHAR2 IS
        l_ret   VARCHAR2(20) := '';
        l_count NUMBER;
    BEGIN
        IF i_sessions IS NOT NULL
           AND i_flg_status != g_rehab_sch_need_cancel
        THEN
            SELECT COUNT(*)
              INTO l_count
              FROM rehab_schedule rs
             WHERE rs.id_rehab_sch_need = i_id_rehab_sch_need
               AND rs.flg_status = 'A';
        
            IF l_count = 0
            THEN
                SELECT COUNT(*)
                  INTO l_count
                  FROM sch_rehab_group srg
                 INNER JOIN rehab_sch_need rsn
                    ON rsn.id_rehab_sch_need = srg.id_rehab_sch_need
                 WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need
                   AND srg.flg_status = pk_alert_constant.g_active;
            END IF;
        
            IF l_count = 0
            THEN
                -- ainda não foi agendada nenhuma sessão
                l_ret := i_sessions || '/' || i_sessions;
            ELSIF l_count = i_sessions
            THEN
                -- todas as sessões agendadas
                l_ret := '  ' || i_sessions;
            ELSIF l_count > i_sessions
            THEN
                -- agendadas mais sessões do que as originalmente pedidas
                l_ret := '  ' || l_count;
            ELSE
                l_ret := (i_sessions - l_count) || '/' || i_sessions;
            END IF;
        END IF;
    
        RETURN l_ret;
    END get_rsn_icon_label;

    /**********************************************************************************************
    * return the icon to be used in treatments
    *
    * %param i_lang                   id_language
    * %param i_id_rehab_presc 
    * %param i_sessions 
    * %param i_flg_status 
    *
    * @return                         icon name
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rp_icon
    (
        i_lang              IN language.id_language%TYPE,
        i_id_rehab_presc    IN rehab_presc.id_rehab_presc%TYPE,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_sessions          IN rehab_sch_need.sessions%TYPE,
        i_flg_status        IN rehab_presc.flg_status%TYPE
    ) RETURN VARCHAR2 IS
    
        l_flg_status rehab_sch_need.flg_status%TYPE := i_flg_status;
    
        l_flg_status_aux rehab_sch_need.flg_status%TYPE;
    
    BEGIN
        l_flg_status := i_flg_status;
    
        IF i_flg_status = pk_rehab.g_rehab_presc_begin
           AND (i_id_rehab_presc IS NOT NULL OR i_id_rehab_sch_need IS NOT NULL)
        THEN
            BEGIN
                SELECT rsn.flg_status
                  INTO l_flg_status_aux
                  FROM rehab_presc rp
                  JOIN rehab_sch_need rsn
                    ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                 WHERE (rp.id_rehab_presc = i_id_rehab_presc AND i_id_rehab_presc IS NOT NULL)
                    OR (rsn.id_rehab_sch_need = i_id_rehab_sch_need AND i_id_rehab_sch_need IS NOT NULL)
                   AND rownum = 1;
            EXCEPTION
                WHEN OTHERS THEN
                    l_flg_status_aux := NULL;
            END;
        
            IF l_flg_status_aux = pk_rehab.g_rehab_sch_need_no_sched --No schedule needed
            THEN
                RETURN pk_rehab.g_rehab_wait_icon;
            ELSIF l_flg_status_aux IS NOT NULL
            THEN
                RETURN pk_sysdomain.get_img(i_lang, g_rehab_sch_need_flg_status, l_flg_status_aux);
            ELSE
                RETURN pk_sysdomain.get_img(i_lang, g_rehab_presc_flg_status, l_flg_status);
            END IF;
        ELSE
            RETURN pk_sysdomain.get_img(i_lang, g_rehab_presc_flg_status, l_flg_status);
        END IF;
    END get_rp_icon;

    /**********************************************************************************************
    * return the text to be used in treatment icons
    *
    * %param i_lang                   id_language
    * %param i_id_rehab_presc 
    * %param i_sessions 
    *
    * @return                         icon label
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rp_icon_label
    (
        i_lang           IN language.id_language%TYPE,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_sessions       IN rehab_sch_need.sessions%TYPE,
        i_flg_status     IN rehab_presc.flg_status%TYPE
    ) RETURN VARCHAR2 IS
        l_ret   VARCHAR2(20) := '';
        l_count NUMBER;
    BEGIN
    
        IF i_sessions IS NOT NULL
           AND i_flg_status NOT IN (pk_alert_constant.g_flg_status_c,
                                    g_rehab_presc_referral, /*g_rehab_presc_begin,*/
                                    g_rehab_presc_not_order_reas)
        THEN
            SELECT COUNT(*)
              INTO l_count
              FROM rehab_session rs
             WHERE rs.id_rehab_presc = i_id_rehab_presc
               AND rs.flg_status <> g_rehab_session_canceled;
        
            IF l_count = 0
            THEN
                -- ainda não foi agendada nenhuma sessão
                l_ret := i_sessions || '/' || i_sessions;
            ELSIF l_count = i_sessions
            THEN
                -- todas as sessões agendadas
                l_ret := i_sessions;
            ELSE
                l_ret := l_count || '/' || i_sessions;
            END IF;
        END IF;
    
        RETURN l_ret;
    END get_rp_icon_label;

    /**********************************************************************************************
    * Returns the label to be shown on treatments request grid by counting the number of sessions
    * that have been concluded or are being executed.
    *
    * %param i_lang                   id_language
    * %param i_prof 
    * %param i_id_rehab_presc
    * %param i_sessions 
    * %param i_flg_status
    *
    * @return                         icon label
    **********************************************************************************************/
    FUNCTION get_rp_icon_label
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_sessions       IN rehab_sch_need.sessions%TYPE,
        i_flg_status     IN rehab_presc.flg_status%TYPE
    ) RETURN VARCHAR2 IS
        l_ret   VARCHAR2(20) := '';
        l_count NUMBER;
    
        l_flg_status_aux rehab_sch_need.flg_status%TYPE;
    BEGIN
    
        IF i_sessions IS NOT NULL
           AND
           i_flg_status NOT IN (pk_alert_constant.g_flg_status_c, g_rehab_presc_referral, g_rehab_presc_not_order_reas)
        THEN
            IF i_flg_status = pk_rehab.g_rehab_presc_begin
               AND i_id_rehab_presc IS NOT NULL
            THEN
                BEGIN
                    SELECT rsn.flg_status
                      INTO l_flg_status_aux
                      FROM rehab_presc rp
                      JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                     WHERE rp.id_rehab_presc = i_id_rehab_presc;
                EXCEPTION
                    WHEN OTHERS THEN
                        l_flg_status_aux := NULL;
                END;
            END IF;
        
            IF i_flg_status <> pk_rehab.g_rehab_presc_begin
            THEN
                SELECT COUNT(1)
                  INTO l_count
                  FROM rehab_epis_encounter ree
                  JOIN rehab_presc rp
                    ON rp.id_rehab_sch_need = ree.id_rehab_sch_need
                 WHERE rp.id_rehab_presc = i_id_rehab_presc
                   AND ree.flg_status IN (pk_rehab.g_rehab_epis_enc_status_o, pk_rehab.g_rehab_epis_enc_status_s)
                   AND rp.flg_status <> g_rehab_presc_cancel;
            
                l_ret := l_count || '/' || i_sessions;
            ELSIF i_flg_status = pk_rehab.g_rehab_presc_begin
                  AND (l_flg_status_aux <> pk_rehab.g_rehab_sch_need_no_sched OR l_flg_status_aux IS NULL)
            THEN
                SELECT COUNT(*)
                  INTO l_count
                  FROM rehab_schedule rs
                 WHERE rs.id_rehab_sch_need = (SELECT rp.id_rehab_sch_need
                                                 FROM rehab_presc rp
                                                WHERE rp.id_rehab_presc = i_id_rehab_presc)
                   AND rs.flg_status = 'A';
            
                IF l_count = 0
                THEN
                    SELECT COUNT(*)
                      INTO l_count
                      FROM sch_rehab_group srg
                     INNER JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = srg.id_rehab_sch_need
                     WHERE rsn.id_rehab_sch_need =
                           (SELECT rp.id_rehab_sch_need
                              FROM rehab_presc rp
                             WHERE rp.id_rehab_presc = i_id_rehab_presc)
                       AND srg.flg_status = pk_alert_constant.g_active;
                END IF;
            
                IF l_count = 0
                THEN
                    -- ainda não foi agendada nenhuma sessão
                    l_ret := i_sessions || '/' || i_sessions;
                ELSIF l_count = i_sessions
                THEN
                    -- todas as sessões agendadas
                    l_ret := '  ' || i_sessions;
                ELSIF l_count > i_sessions
                THEN
                    -- agendadas mais sessões do que as originalmente pedidas
                    l_ret := '  ' || l_count;
                ELSE
                    l_ret := (i_sessions - l_count) || '/' || i_sessions;
                END IF;
            END IF;
        END IF;
    
        RETURN l_ret;
    END get_rp_icon_label;

    FUNCTION get_rp_back_color
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_flg_status     IN rehab_presc.flg_status%TYPE
    ) RETURN VARCHAR2 IS
    
        l_flg_status_aux rehab_sch_need.flg_status%TYPE;
        l_dt_begin       rehab_sch_need.dt_begin%TYPE;
    
    BEGIN
    
        IF i_flg_status = pk_rehab.g_rehab_presc_begin
           AND i_id_rehab_presc IS NOT NULL
        THEN
            BEGIN
                SELECT rsn.flg_status
                  INTO l_flg_status_aux
                  FROM rehab_presc rp
                  JOIN rehab_sch_need rsn
                    ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                 WHERE rp.id_rehab_presc = i_id_rehab_presc;
            EXCEPTION
                WHEN OTHERS THEN
                    l_flg_status_aux := NULL;
            END;
        
            IF l_flg_status_aux = pk_rehab.g_rehab_sch_need_no_sched --No schedule needed
            THEN
                BEGIN
                    SELECT rsn.dt_begin
                      INTO l_dt_begin
                      FROM rehab_presc rp
                      JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                     WHERE rp.id_rehab_presc = i_id_rehab_presc;
                EXCEPTION
                    WHEN OTHERS THEN
                        l_dt_begin := NULL;
                END;
            
                IF l_dt_begin IS NOT NULL
                THEN
                    IF pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                       i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                   i_timestamp => current_timestamp,
                                                                                                   i_format    => 'DD'),
                                                       i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                   i_timestamp => l_dt_begin,
                                                                                                   i_format    => 'DD')) = 'L'
                    THEN
                        RETURN pk_alert_constant.g_color_green;
                    ELSE
                        RETURN pk_alert_constant.g_color_red;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        RETURN NULL;
    END get_rp_back_color;

    FUNCTION get_rp_icon_color
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_flg_status     IN rehab_presc.flg_status%TYPE
    ) RETURN VARCHAR2 IS
    
        l_flg_status_aux rehab_sch_need.flg_status%TYPE;
        l_dt_begin       rehab_sch_need.dt_begin%TYPE;
    
    BEGIN
    
        IF i_flg_status = pk_rehab.g_rehab_presc_begin
           AND i_id_rehab_presc IS NOT NULL
        THEN
            BEGIN
                SELECT rsn.flg_status
                  INTO l_flg_status_aux
                  FROM rehab_presc rp
                  JOIN rehab_sch_need rsn
                    ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                 WHERE rp.id_rehab_presc = i_id_rehab_presc;
            EXCEPTION
                WHEN OTHERS THEN
                    l_flg_status_aux := NULL;
            END;
        
            IF l_flg_status_aux = pk_rehab.g_rehab_sch_need_no_sched --No schedule needed
            THEN
                RETURN pk_alert_constant.g_color_icon_light_grey;
            END IF;
        ELSIF i_flg_status IN (pk_rehab.g_rehab_presc_cancel)
        THEN
            RETURN NULL;
        END IF;
    
        RETURN pk_alert_constant.g_color_icon_dark_grey;
    END get_rp_icon_color;

    /**********************************************************************************************
    * Returns the information about schedule needs and requested/ongoing treatments
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient id
    * %param i_id_episode             current episode
    * %param o_id_episode_origin      origin episode
    * %param o_sch_need               list of schedule needs
    * %param o_treat                  list of treatments
    * %param o_notes                  list of plan notes
    * %param o_labels                 labels used in the screen
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_treatment_plan_int
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_patient        IN rehab_plan.id_patient%TYPE,
        i_id_episode        IN rehab_plan.id_episode_origin%TYPE,
        i_reports           IN VARCHAR2,
        o_id_episode_origin OUT rehab_plan.id_episode_origin%TYPE,
        o_sch_need          OUT pk_types.cursor_type,
        o_treat             OUT pk_types.cursor_type,
        o_notes             OUT pk_types.cursor_type,
        o_labels            OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name      CONSTANT VARCHAR2(30) := 'GET_REHAB_TREATMENT_PLAN';
        l_type_session   CONSTANT VARCHAR2(30) := 'S';
        l_type_treatment CONSTANT VARCHAR2(30) := 'T';
        l_has_notes         sys_message.desc_message%TYPE;
        l_dt_begin          TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end            TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_id_schedule       rehab_schedule.id_schedule%TYPE;
        l_id_epis_type      episode.id_epis_type%TYPE;
        l_prof_cat          category.id_category%TYPE;
        l_all_epis          table_number;
        l_cancel_reason     sys_message.desc_message%TYPE;
        l_reason_notes      sys_message.desc_message%TYPE;
        l_id_episode_origin NUMBER;
    BEGIN
        g_error := 'BEGIN i_id_patient=' || i_id_patient;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
    
        l_has_notes     := pk_message.get_message(i_lang, i_prof, 'COMMON_M097');
        l_cancel_reason := pk_message.get_message(i_lang, 'DETAIL_COMMON_M006');
        l_reason_notes  := pk_message.get_message(i_lang, 'COMMON_M073');
    
        g_error    := 'Call pk_prof_utils.get_categoyr i_prof.id=' || i_prof.id;
        l_prof_cat := pk_prof_utils.get_id_category(i_lang => i_lang, i_prof => i_prof);
    
        l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
        l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
    
        g_error := 'Before get_origin_episode';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        -- precisa-se do episódio de origem
        IF NOT get_origin_episode(i_lang              => i_lang,
                                  i_prof              => i_prof,
                                  i_id_episode        => i_id_episode,
                                  i_id_schedule       => NULL,
                                  o_id_episode_origin => l_id_episode_origin,
                                  o_id_schedule       => l_id_schedule,
                                  o_id_epis_type      => l_id_epis_type,
                                  o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        o_id_episode_origin := l_id_episode_origin;
        -- para os assistentes sociais poderem ver o deep_nav da reabilitação
        g_error := 'L_ALL_EPIS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        SELECT DISTINCT (id_episode)
          BULK COLLECT
          INTO l_all_epis
          FROM episode epis
         WHERE epis.id_visit = pk_episode.get_id_visit(i_id_episode);
    
        g_error := 'SCHEDULE NEEDS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_sch_need FOR
            SELECT DISTINCT l_type_session AS rec_type,
                            rsn.id_rehab_sch_need,
                            rsn.id_rehab_sch_need,
                            rst.id_rehab_session_type,
                            pk_translation.get_translation(i_lang, rst.code_rehab_session_type) desc_session_type,
                            get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) instructions,
                            pk_prof_utils.get_nickname(i_lang, nvl(rsn.id_cancel_professional, rsn.id_professional)) prof_last_update,
                            rsn.id_professional,
                            pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                               nvl(rsn.dt_cancel, rsn.dt_rehab_sch_need),
                                                               i_prof) dt_last_update,
                            pk_date_utils.get_timestamp_str(i_lang,
                                                            i_prof,
                                                            nvl(rsn.dt_cancel, rsn.dt_rehab_sch_need),
                                                            NULL) dt_last_update_str,
                            get_rsn_icon(i_lang, rsn.id_rehab_sch_need, rsn.sessions, rsn.flg_status) icon,
                            get_rsn_icon_label(i_lang, rsn.id_rehab_sch_need, rsn.flg_status, rsn.sessions) AS icon_label,
                            rsn.flg_status,
                            nvl2(rsn.notes, l_has_notes, NULL) AS has_notes,
                            rpres.notes AS notes,
                            pk_sysdomain.get_domain('REHAB_SCH_NEED.FLG_STATUS', rsn.flg_status, i_lang) flg_status_description,
                            --'EXECUTION_LOCAL' EXECUTION_LOCAL,
                            pk_prof_utils.get_name(i_lang, nvl(rsn.id_cancel_professional, rsn.id_professional)) prof_name_last_update,
                            pk_prof_utils.get_spec_signature(i_lang,
                                                             i_prof,
                                                             nvl(rsn.id_cancel_professional, rsn.id_professional),
                                                             nvl(rsn.dt_cancel, rsn.dt_rehab_sch_need),
                                                             rsn.id_episode_origin) prof_speciality_last_update,
                            pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                               nvl(rsn.dt_cancel, rsn.dt_rehab_sch_need),
                                                               i_prof) dt_time_last_update,
                            pk_prof_utils.get_name(i_lang, rp.id_professional) prof_name_requested,
                            pk_prof_utils.get_spec_signature(i_lang,
                                                             i_prof,
                                                             nvl(rsn.id_cancel_professional, rsn.id_professional),
                                                             nvl(rsn.dt_cancel, rsn.dt_rehab_sch_need),
                                                             rsn.id_episode_origin) prof_speciality_requested,
                            pk_date_utils.dt_chr_date_hour_tsz(i_lang, rsn.dt_begin, i_prof) dt_time_requested
              FROM rehab_sch_need rsn
              JOIN rehab_session_type rst
                ON rst.id_rehab_session_type = rsn.id_rehab_session_type
              JOIN rehab_presc rpres
                ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
              LEFT JOIN rehab_plan rp
                ON rp.id_episode_origin = rsn.id_episode_origin
             WHERE ((rsn.id_episode_origin = o_id_episode_origin AND l_prof_cat <> 25) OR
                   (rsn.id_episode_origin IN ((SELECT column_value
                                                 FROM TABLE(l_all_epis))) AND l_prof_cat = 25))
               AND ((i_reports = pk_alert_constant.g_yes AND rsn.flg_status <> g_rehab_sch_need_dummy AND
                   rpres.flg_status <> g_rehab_presc_cancel) OR
                   (i_reports = pk_alert_constant.g_no AND
                   rsn.flg_status NOT IN (g_rehab_sch_need_dummy, g_rehab_sch_need_no_sched)))
             ORDER BY decode(rsn.flg_status, g_rehab_sch_need_cancel, 10, g_rehab_sch_need_scheduled, 20, 100) DESC;
    
        g_error := 'TREATMENTS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_treat FOR
            SELECT *
              FROM (SELECT rec_type,
                           id_rehab_presc,
                           id_rehab_sch_need,
                           id_rehab_area_interv,
                           id_intervention,
                           desc_interv,
                           desc_area,
                           id_rehab_area,
                           prof_requested,
                           id_prof_requested,
                           dt_requested_str,
                           dt_requested,
                           icon,
                           icon_label,
                           icon_color,
                           back_color,
                           flg_status,
                           id_exec_institution,
                           exec_institution,
                           instructions,
                           has_notes,
                           notes,
                           flg_status_description,
                           session_type,
                           execution_local,
                           prof_name_requested,
                           prof_speciality_requested,
                           cancel_reason_desc,
                           cancel_reason_notes,
                           label_cancel_reason,
                           label_reason_notes,
                           flg_laterality,
                           desc_laterality,
                           flg_laterality_mcdt,
                           id_codification,
                           codification,
                           id_mcdt_codification,
                           flg_priority,
                           not_order_reason_desc,
                           pk_rehab.get_diagnosis(i_lang, i_prof, id_rehab_presc) clinical_indication,
                           flg_clinical_question
                      FROM TABLE(pk_rehab.get_rehab_treat_plan_all(i_lang              => i_lang,
                                                                   i_prof              => i_prof,
                                                                   i_id_patient        => i_id_patient,
                                                                   i_id_episode        => table_number(i_id_episode),
                                                                   i_id_episode_origin => l_id_episode_origin)) xtbl) t
             ORDER BY pk_rehab.order_by_treat(i_flg_status => t.flg_status) DESC;
    
        g_error := 'NOTES';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_notes FOR
            SELECT pk_prof_utils.get_nickname(i_lang, rn.id_professional) prof_nickname,
                   pk_prof_utils.get_prof_speciality(i_lang, i_prof) prof_speciality,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, rn.dt_rehab_notes, i_prof) date_inserted,
                   rn.notes
              FROM rehab_notes rn
              JOIN rehab_plan rp
                ON rp.id_episode_origin = rn.id_episode_origin
             WHERE ((rp.id_episode_origin = o_id_episode_origin AND l_prof_cat <> 25) OR
                   ((rp.id_episode_origin IN ((SELECT column_value
                                                 FROM TABLE(l_all_epis))) AND l_prof_cat = 25)))
             ORDER BY rn.dt_rehab_notes DESC;
    
        g_error := 'LABELS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_labels FOR
            SELECT pk_message.get_message(i_lang, 'REHAB_T031') AS sessions,
                   pk_message.get_message(i_lang, 'REHAB_T073') AS treatments,
                   pk_message.get_message(i_lang, 'REHAB_T034') AS notes
              FROM dual;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_types.open_cursor_if_closed(o_sch_need);
            pk_types.open_cursor_if_closed(o_treat);
            pk_types.open_cursor_if_closed(o_notes);
            pk_types.open_cursor_if_closed(o_labels);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_treatment_plan_int;

    /**********************************************************************************************
    * Returns the information about schedule needs and requested/ongoing treatments
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient id
    * %param i_id_episode             current episode
    * %param o_id_episode_origin      origin episode
    * %param o_sch_need               list of schedule needs
    * %param o_treat                  list of treatments
    * %param o_notes                  list of plan notes
    * %param o_labels                 labels used in the screen
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_treatment_plan
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_patient        IN rehab_plan.id_patient%TYPE,
        i_id_episode        IN rehab_plan.id_episode_origin%TYPE,
        o_id_episode_origin OUT rehab_plan.id_episode_origin%TYPE,
        o_sch_need          OUT pk_types.cursor_type,
        o_treat             OUT pk_types.cursor_type,
        o_notes             OUT pk_types.cursor_type,
        o_labels            OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        RETURN get_rehab_treatment_plan_int(i_lang              => i_lang,
                                            i_prof              => i_prof,
                                            i_id_patient        => i_id_patient,
                                            i_id_episode        => i_id_episode,
                                            i_reports           => pk_alert_constant.g_no,
                                            o_id_episode_origin => o_id_episode_origin,
                                            o_sch_need          => o_sch_need,
                                            o_treat             => o_treat,
                                            o_notes             => o_notes,
                                            o_labels            => o_labels,
                                            o_error             => o_error);
    END get_rehab_treatment_plan;

    /**********************************************************************************************
    * Returns a list of labels used in scheduling instructions
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param o_label                  list of labels
    * %param o_frequency              list of frequency values
    * %param o_priority               list of priority values
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_instructions_cfg
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        o_label     OUT pk_types.cursor_type,
        o_frequency OUT pk_types.cursor_type,
        o_priority  OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_INSTRUCTIONS_CFG';
        l_label     table_table_varchar := table_table_varchar();
        l_mandatory sys_config.value%TYPE;
    BEGIN
        g_sysdate_tstz := systimestamp;
    
        g_error := 'sessions';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        l_label.extend;
        l_mandatory := nvl(pk_sysconfig.get_config('REHAB_MANDATORY_SESSIONS', i_prof), pk_alert_constant.get_no);
        IF l_mandatory = pk_alert_constant.get_yes
        THEN
            l_label(l_label.last) := table_varchar(pk_message.get_message(i_lang, 'REHAB_T001'), l_mandatory);
        ELSE
            l_label(l_label.last) := table_varchar(pk_message.get_message(i_lang, 'REHAB_T002'), l_mandatory);
        END IF;
    
        g_error := 'frequency';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        l_label.extend;
        l_mandatory := nvl(pk_sysconfig.get_config('REHAB_MANDATORY_FREQUENCY', i_prof), pk_alert_constant.get_no);
        IF l_mandatory = pk_alert_constant.get_yes
        THEN
            l_label(l_label.last) := table_varchar(pk_message.get_message(i_lang, 'REHAB_T003'), l_mandatory);
        ELSE
            l_label(l_label.last) := table_varchar(pk_message.get_message(i_lang, 'REHAB_T004'), l_mandatory);
        END IF;
    
        g_error := 'priority';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        l_label.extend;
        l_label(l_label.last) := table_varchar(pk_message.get_message(i_lang, 'REHAB_T006'), pk_alert_constant.get_no);
    
        g_error := 'begin date';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        l_label.extend;
        l_label(l_label.last) := table_varchar(pk_message.get_message(i_lang, 'REHAB_T007'), pk_alert_constant.get_no);
    
        g_error := 'notas';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        l_label.extend;
        l_label(l_label.last) := table_varchar(pk_message.get_message(i_lang, 'REHAB_T093'), pk_alert_constant.get_no);
    
        g_error := 'o_label';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_label FOR
            SELECT *
              FROM TABLE(l_label);
    
        g_error := 'o_frequency';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_frequency FOR
            SELECT sd.desc_val AS label,
                   sd.val AS id,
                   CASE rownum
                       WHEN 1 THEN
                        'Y'
                       ELSE
                        'N'
                   END AS flg_default
              FROM sys_domain sd
             WHERE sd.code_domain = 'REHAB_SCH_NEED.FLG_FREQUENCY'
               AND sd.flg_available = pk_alert_constant.g_available
               AND sd.domain_owner = pk_sysdomain.k_default_schema
               AND sd.id_language = i_lang
             ORDER BY sd.rank;
    
        g_error := 'o_priority';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_priority FOR
            SELECT sd.desc_val AS label,
                   sd.val AS data,
                   CASE rownum
                       WHEN 1 THEN
                        'Y'
                       ELSE
                        'N'
                   END AS flg_default
              FROM sys_domain sd
             WHERE sd.code_domain = 'REHAB_SCH_NEED.FLG_PRIORITY'
               AND sd.domain_owner = pk_sysdomain.k_default_schema
               AND sd.flg_available = pk_alert_constant.g_available
               AND sd.id_language = i_lang
             ORDER BY sd.rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: ' || ' @' || g_error, g_package_name, l_func_name);
            pk_alertlog.log_error(g_error);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_rehab_instructions_cfg;

    /**********************************************************************************************
    * Returns the instructions' string for a given schedule need
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_sch_need 
    * %param i_format 
    *
    * @return                         string with instructions
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_instructions
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_format            IN VARCHAR2 DEFAULT 'PFSDN'
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_INSTRUCTIONS';
        l_one       CONSTANT NUMBER := 1;
    
        l_prty                 VARCHAR2(4000);
        l_prty_val             rehab_sch_need.flg_priority%TYPE;
        l_freq                 VARCHAR2(4000);
        l_freq_val             rehab_sch_need.frequency%TYPE;
        l_take                 VARCHAR2(4000);
        l_take_val             rehab_sch_need.sessions%TYPE;
        l_start                VARCHAR2(4000);
        l_start_val            rehab_sch_need.dt_begin%TYPE;
        l_notes                VARCHAR2(4000);
        l_notes_val            rehab_sch_need.notes%TYPE;
        l_ret                  VARCHAR2(4000);
        l_one_time_msg         sys_message.desc_message%TYPE;
        l_several_times_msg    sys_message.desc_message%TYPE;
        l_one_session_msg      sys_message.desc_message%TYPE;
        l_several_sessions_msg sys_message.desc_message%TYPE;
        l_since_date_msg       sys_message.desc_message%TYPE;
    
        PROCEDURE add_to_ret
        (
            i_add      IN VARCHAR2,
            i_original IN OUT VARCHAR2
        ) IS
        BEGIN
            IF i_original IS NULL
            THEN
                i_original := i_add;
            ELSIF i_add IS NOT NULL
            THEN
                i_original := i_original || '; ' || i_add;
            END IF;
        END add_to_ret;
    
    BEGIN
        pk_alertlog.log_debug('Begin', g_package_name, l_func_name);
    
        g_error                := 'get_message';
        l_one_time_msg         := pk_message.get_message(i_lang, i_prof, 'REHAB_M005');
        l_several_times_msg    := pk_message.get_message(i_lang, i_prof, 'REHAB_M006');
        l_one_session_msg      := pk_message.get_message(i_lang, i_prof, 'REHAB_M003');
        l_several_sessions_msg := pk_message.get_message(i_lang, i_prof, 'REHAB_M004');
        l_since_date_msg       := pk_message.get_message(i_lang, i_prof, 'REHAB_M007');
    
        g_error := 'GET DATA';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        SELECT rsn.flg_priority AS prty_val,
               pk_sysdomain.get_domain('REHAB_SCH_NEED.FLG_PRIORITY', rsn.flg_priority, i_lang) AS priority,
               rsn.frequency AS freq_val,
               rsn.frequency || ' ' || decode(rsn.frequency, l_one, l_one_time_msg, l_several_times_msg) || ' ' ||
               pk_sysdomain.get_domain('REHAB_SCH_NEED.FLG_FREQUENCY', rsn.flg_frequency, i_lang) AS frequency,
               rsn.sessions AS sess_val,
               rsn.sessions || decode(rsn.sessions, l_one, l_one_session_msg, l_several_sessions_msg) AS sessions,
               rsn.dt_begin AS dt_val,
               decode(rsn.dt_begin,
                      NULL,
                      NULL,
                      l_since_date_msg || ' ' || pk_date_utils.dt_chr_tsz(i_lang, rsn.dt_begin, i_prof)) start_date,
               rsn.notes notes_val,
               decode(rsn.notes, NULL, NULL, rsn.notes) notes
          INTO l_prty_val, l_prty, l_freq_val, l_freq, l_take_val, l_take, l_start_val, l_start, l_notes_val, l_notes
          FROM rehab_sch_need rsn
          JOIN rehab_session_type rst
            ON rst.id_rehab_session_type = rsn.id_rehab_session_type
         WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need;
    
        g_error := 'FOR LOOP';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        FOR i IN 1 .. length(i_format)
        LOOP
            CASE substr(i_format, i, 1)
                WHEN 'P' THEN
                    IF l_prty_val IS NOT NULL
                    THEN
                        add_to_ret(l_prty, l_ret);
                    END IF;
                WHEN 'F' THEN
                    IF l_freq_val IS NOT NULL
                    THEN
                        add_to_ret(l_freq, l_ret);
                    END IF;
                WHEN 'S' THEN
                    IF l_take_val IS NOT NULL
                    THEN
                        add_to_ret(l_take, l_ret);
                    END IF;
                WHEN 'D' THEN
                    IF l_start_val IS NOT NULL
                    THEN
                        add_to_ret(l_start, l_ret);
                    END IF;
                WHEN 'N' THEN
                    IF l_notes_val IS NOT NULL
                    THEN
                        add_to_ret(l_notes, l_ret);
                    END IF;
                ELSE
                    NULL;
            END CASE;
        END LOOP;
    
        RETURN l_ret;
    END get_instructions;

    /**********************************************************************************************
    * Returns the name of a given rehab area
    *
    * %param i_lang                   id_language
    * %param i_id_rehab_area          rehab_area id
    *
    * @return                         area name
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_area_name
    (
        i_lang          IN language.id_language%TYPE,
        i_id_rehab_area IN rehab_area.id_rehab_area%TYPE
    ) RETURN pk_translation.t_desc_translation IS
        l_ret pk_translation.t_desc_translation;
    BEGIN
        SELECT pk_translation.get_translation(i_lang, ra.code_rehab_area)
          INTO l_ret
          FROM rehab_area ra
         WHERE ra.id_rehab_area = i_id_rehab_area;
    
        RETURN l_ret;
    
    END get_rehab_area_name;

    -- returns the name of the episode type
    /**********************************************************************************************
    * Returns the episode that is to used to aggregate the treatments
    *
    * %param i_lang                   id_language
    * %param i_id_epis_type           epis_type
    *
    * @return                         epis_type translation
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_desc_epis_type
    (
        i_lang         IN language.id_language%TYPE,
        i_id_epis_type IN episode.id_epis_type%TYPE
    ) RETURN VARCHAR2 IS
        l_desc_epis_type pk_translation.t_desc_translation;
    BEGIN
        SELECT pk_translation.get_translation(i_lang, et.code_epis_type)
          INTO l_desc_epis_type
          FROM epis_type et
         WHERE et.id_epis_type = i_id_epis_type;
    
        RETURN l_desc_epis_type;
    END get_desc_epis_type;

    /**********************************************************************************************
    * returns the name of the group
    *
    * %param i_id_rehab_group         rehab group
    *
    * @return                         name of rehab group
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_desc_rehab_group(i_id_rehab_group IN rehab_group.id_rehab_group%TYPE) RETURN VARCHAR2 IS
        l_name rehab_group.name%TYPE;
    BEGIN
        IF i_id_rehab_group IS NOT NULL
        THEN
            SELECT rg.name
              INTO l_name
              FROM rehab_group rg
             WHERE rg.id_rehab_group = i_id_rehab_group;
        ELSE
            l_name := NULL;
        END IF;
    
        RETURN l_name;
    END get_desc_rehab_group;

    /**********************************************************************************************
    * returns the name of the responsible professional or group
    *
    * %param i_lang                   id_language
    * %param i_id_professional        professional
    * %param i_id_rehab_group         rehab group
    *
    * @return                         name of responsible
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_sch_need_resp
    (
        i_lang            IN language.id_language%TYPE,
        i_id_professional IN professional.id_professional%TYPE,
        i_id_rehab_group  IN rehab_group.id_rehab_group%TYPE
    ) RETURN VARCHAR2 IS
    BEGIN
        RETURN nvl(pk_prof_utils.get_nickname(i_lang, i_id_professional), get_desc_rehab_group(i_id_rehab_group));
    END get_rehab_sch_need_resp;

    /**********************************************************************************************
    * return list of treatments of a scheduling need
    *
    * %param i_lang                   id_language
    * %param i_id_rehab_sch_need      
    *
    * @return                         list of treatments separated by comma
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_presc_list
    (
        i_lang              IN language.id_language%TYPE,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE
    ) RETURN VARCHAR2 IS
        l_list VARCHAR2(4000);
    BEGIN
        SELECT rtrim(concatenate(pk_translation.get_translation(i_lang, i.code_intervention) || ', '), ', ')
          INTO l_list
          FROM rehab_presc rp
          JOIN rehab_area_interv rai
            ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
          JOIN intervention i
            ON i.id_intervention = rai.id_intervention
         WHERE rp.id_rehab_sch_need = i_id_rehab_sch_need;
    
        RETURN l_list;
    END get_rehab_presc_list;

    /**********************************************************************************************
    * Returns a list of rehab needs open (waiting for scheduling) in this MFR plan
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_episode_origin      origin episode
    * %param o_needs_instructions     if the instructions are mandatory
    * %param o_list                   list of rehabilitation schedule
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_pending_sch_needs
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_episode_origin  IN rehab_sch_need.id_episode_origin%TYPE,
        o_needs_instructions OUT VARCHAR2,
        o_list               OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PENDING_SCH_NEEDS';
    BEGIN
    
        g_error := 'before get_sysconfig';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        -- needs only one to be true
        o_needs_instructions := nvl(pk_sysconfig.get_config('REHAB_MANDATORY_SESSIONS', i_prof),
                                    pk_alert_constant.get_no);
        IF o_needs_instructions != pk_alert_constant.get_yes()
        THEN
            o_needs_instructions := nvl(pk_sysconfig.get_config('REHAB_MANDATORY_FREQUENCY', i_prof),
                                        pk_alert_constant.get_no);
        END IF;
    
        g_error := 'before open o_list';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        OPEN o_list FOR
            SELECT rsn.id_rehab_sch_need, get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) desc_instructions
              FROM rehab_sch_need rsn
             WHERE rsn.id_episode_origin = i_id_episode_origin
               AND rsn.flg_status = g_rehab_sch_need_wait_sch
               AND rsn.id_rehab_sch_need IN (SELECT t.id_rehab_sch_need
                                               FROM (SELECT rsn_i.id_rehab_sch_need,
                                                            row_number() over(PARTITION BY rsn_i.sessions, rsn_i.frequency, rsn_i.flg_frequency, rsn_i.flg_priority, rsn_i.dt_begin, rsn_i.notes ORDER BY rsn_i.id_rehab_sch_need ASC) AS rn
                                                       FROM rehab_sch_need rsn_i
                                                      WHERE rsn_i.id_episode_origin = i_id_episode_origin
                                                        AND rsn_i.flg_status = g_rehab_sch_need_wait_sch) t
                                              WHERE t.rn = 1)
            UNION ALL
            SELECT -1, pk_message.get_message(i_lang, 'REHAB_T120')
              FROM dual
             ORDER BY id_rehab_sch_need DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: ' || ' @' || g_error, g_package_name, l_func_name);
            pk_types.open_my_cursor(o_list);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_pending_sch_needs;

    /**********************************************************************************************
    * Returns a list of rehab needs open (waiting for scheduling) in this MFR plan
    * to be used in the grid pag.18
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param o_list                   list of rehabilitation needs
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_pending_sch_needs_grid
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_list  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PENDING_SCH_NEEDS_GRID';
        l_id_category       prof_cat.id_category%TYPE;
        l_prof_rehab_groups table_number;
        l_dt_begin          TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end            TIMESTAMP(6) WITH LOCAL TIME ZONE;
    BEGIN
        g_sysdate_tstz := systimestamp;
        l_dt_begin     := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
        l_dt_end       := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
    
        g_error       := 'get profissional ' || i_prof.id || ' category';
        l_id_category := pk_prof_utils.get_id_category(i_lang => i_lang, i_prof => i_prof);
    
        g_error := 'get profissional groups ';
        SELECT id_rehab_group
          BULK COLLECT
          INTO l_prof_rehab_groups
          FROM rehab_group_prof rgp
         WHERE rgp.id_professional = i_prof.id;
    
        g_error := 'open o_list';
        OPEN o_list FOR
        -- os que estão à espera de serem agendados
            SELECT *
              FROM (SELECT /*+ opt_estimate(table x rows=1) */
                     e.id_patient,
                     pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode) AS patient_name,
                     pk_patphoto.get_pat_photo(i_lang, i_prof, e.id_patient, e.id_episode, NULL) AS photo,
                     pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) AS pat_age,
                     pk_patient.get_pat_gender(e.id_patient) AS gender,
                     pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) AS pat_ndo,
                     pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) AS pat_nd_icon,
                     e.id_episode AS id_episode,
                     get_desc_epis_type(i_lang, e.id_epis_type) AS epis_type,
                     pk_translation.get_translation(i_lang, d.code_department) department,
                     pk_translation.get_translation(i_lang, cs.code_clinical_service) AS service,
                     pk_prof_utils.get_nickname(i_lang, rsn.id_professional) AS request_prof,
                     nvl(rsn.id_resp_professional, rsn.id_resp_rehab_group) AS id_responsible,
                     get_rehab_sch_need_resp(i_lang, rsn.id_resp_professional, rsn.id_resp_rehab_group) AS responsible,
                     decode(rsn.id_resp_professional,
                            NULL,
                            decode(rsn.id_resp_rehab_group, NULL, NULL, g_list_type_group_abbr),
                            g_list_type_prof_abbr) AS responsible_type,
                     get_rehab_presc_list(i_lang, rsn.id_rehab_sch_need) AS treatments,
                     get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) AS instructions,
                     rsn.sessions AS num_sessions,
                     (SELECT rsn.sessions - COUNT(*)
                        FROM rehab_schedule rs
                       WHERE rs.id_rehab_sch_need = rsn.id_rehab_sch_need
                         AND rs.flg_status = 'A') AS num_sessions_pending,
                     rsn.frequency AS frequency_num,
                     rsn.flg_frequency AS frequency_time_unit,
                     pk_date_utils.dt_chr_tsz(i_lang, rsn.dt_begin, i_prof) AS dt_begin_desc,
                     pk_date_utils.get_timestamp_str(i_lang, i_prof, rsn.dt_begin, NULL) AS dt_begin_str,
                     rsn.notes AS session_notes,
                     cr.num_clin_record,
                     rst.id_rehab_session_type,
                     pk_translation.get_translation(i_lang, rst.code_rehab_session_type) AS session_type,
                     get_rsn_icon(i_lang, rsn.id_rehab_sch_need, rsn.sessions, rsn.flg_status) icon,
                     get_rsn_icon_label(i_lang, rsn.id_rehab_sch_need, rsn.flg_status, rsn.sessions) AS icon_label,
                     rsn.flg_status,
                     rsn.id_rehab_sch_need,
                     (SELECT DISTINCT CAST(COLLECT(ra.id_rehab_area) AS table_number)
                        FROM rehab_area ra
                        JOIN rehab_area_interv rai
                          ON rai.id_rehab_area = ra.id_rehab_area
                        JOIN rehab_presc rp
                          ON rp.id_rehab_area_interv = rai.id_rehab_area_interv
                       WHERE rp.id_rehab_sch_need = rsn.id_rehab_sch_need) AS tbl_id_rehab_area,
                     rsn.id_professional AS request_id_prof
                      FROM rehab_sch_need rsn
                      JOIN (SELECT DISTINCT rsn.id_rehab_sch_need id_rehab_sch_needd
                             FROM rehab_presc rp
                             JOIN rehab_sch_need rsn
                               ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                            WHERE rp.id_institution = rp.id_exec_institution
                              AND rp.id_institution = i_prof.institution) rp
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_needd
                      JOIN rehab_presc rpres
                        ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                      JOIN rehab_area_interv rai
                        ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
                      JOIN TABLE(find_prof_rehab_areas(i_prof.id, i_prof.institution)) x
                        ON x.id_rehab_area = rai.id_rehab_area
                      JOIN rehab_session_type rst
                        ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                      JOIN episode e
                        ON e.id_episode = rsn.id_episode_origin
                      JOIN clinical_service cs
                        ON cs.id_clinical_service = e.id_cs_requested
                      JOIN epis_info ei
                        ON ei.id_episode = e.id_episode
                      LEFT JOIN room r
                        ON r.id_room = ei.id_room
                      LEFT JOIN department d
                        ON d.id_department = r.id_department
                      LEFT JOIN clin_record cr
                        ON cr.id_episode = e.id_episode
                    -- os que estão à espera de serem agendados
                     WHERE rsn.flg_status = g_rehab_sch_need_wait_sch
                          --to assure that there are no repeated records
                       AND rpres.id_rehab_presc IN (SELECT rpc.id_rehab_presc
                                                      FROM rehab_presc rpc
                                                     WHERE rpc.id_rehab_sch_need = rsn.id_rehab_sch_need
                                                       AND rpc.flg_status <> pk_alert_constant.g_cancelled
                                                       AND rownum = 1)
                          -- **** quando é coordenador  
                       AND (l_id_category = g_category_registrar OR
                           (l_id_category = g_category_coordinator OR
                           -- ou o profissional responsável sou eu
                           (rsn.id_resp_professional IS NOT NULL AND rsn.id_resp_professional = i_prof.id) OR
                           -- ou o meu grupo
                           (rsn.id_resp_rehab_group IS NOT NULL AND
                           rsn.id_resp_rehab_group IN
                           (SELECT /*+opt_estimate(table t rows=1)*/
                                column_value
                                 FROM TABLE(l_prof_rehab_groups) t))))
                    UNION ALL
                    -- union all com agendados mas count diferente do numero de sessoes e que não tenham sido agendados hoje
                    SELECT /*+ opt_estimate(table x rows=1) */
                     e.id_patient,
                     pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode) AS patient_name,
                     pk_patphoto.get_pat_photo(i_lang, i_prof, e.id_patient, e.id_episode, NULL) AS photo,
                     pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) AS pat_age,
                     pk_patient.get_pat_gender(e.id_patient) AS gender,
                     pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) AS pat_ndo,
                     pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) AS pat_nd_icon,
                     e.id_episode AS id_episode,
                     get_desc_epis_type(i_lang, e.id_epis_type) AS epis_type,
                     pk_translation.get_translation(i_lang, d.code_department) AS department,
                     pk_translation.get_translation(i_lang, cs.code_clinical_service) AS service,
                     pk_prof_utils.get_nickname(i_lang, rsn.id_professional) AS request_prof,
                     nvl(rsn.id_resp_professional, rsn.id_resp_rehab_group) AS id_responsible,
                     get_rehab_sch_need_resp(i_lang, rsn.id_resp_professional, rsn.id_resp_rehab_group) AS responsible,
                     decode(rsn.id_resp_professional,
                            NULL,
                            decode(rsn.id_resp_rehab_group, NULL, NULL, g_list_type_group_abbr),
                            g_list_type_prof_abbr) AS responsible_type,
                     get_rehab_presc_list(i_lang, rsn.id_rehab_sch_need) AS treatments,
                     get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) AS instructions,
                     rsn.sessions AS num_sessions,
                     (SELECT rsn.sessions - COUNT(*)
                        FROM rehab_schedule rs
                       WHERE rs.id_rehab_sch_need = rsn.id_rehab_sch_need
                         AND rs.flg_status = 'A') AS num_sessions_pending,
                     rsn.frequency AS frequency_num,
                     rsn.flg_frequency AS frequency_time_unit,
                     pk_date_utils.dt_chr_tsz(i_lang, rsn.dt_begin, i_prof) AS dt_begin_desc,
                     pk_date_utils.get_timestamp_str(i_lang, i_prof, rsn.dt_begin, NULL) AS dt_begin_str,
                     rsn.notes AS session_notes,
                     cr.num_clin_record,
                     rst.id_rehab_session_type,
                     pk_translation.get_translation(i_lang, rst.code_rehab_session_type) AS session_type,
                     get_rsn_icon(i_lang, rsn.id_rehab_sch_need, rsn.sessions, rsn.flg_status) icon,
                     get_rsn_icon_label(i_lang, rsn.id_rehab_sch_need, rsn.flg_status, rsn.sessions) AS icon_label,
                     rsn.flg_status,
                     rsn.id_rehab_sch_need,
                     (SELECT DISTINCT CAST(COLLECT(ra.id_rehab_area) AS table_number)
                        FROM rehab_area ra
                        JOIN rehab_area_interv rai
                          ON rai.id_rehab_area = ra.id_rehab_area
                        JOIN rehab_presc rp
                          ON rp.id_rehab_area_interv = rai.id_rehab_area_interv
                       WHERE rp.id_rehab_sch_need = rsn.id_rehab_sch_need) AS tbl_id_rehab_area,
                     rsn.id_professional AS request_id_prof
                      FROM rehab_sch_need rsn
                      JOIN (SELECT DISTINCT rsn.id_rehab_sch_need id_rehab_sch_needd
                             FROM rehab_presc rp
                             JOIN rehab_sch_need rsn
                               ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                            WHERE rp.id_institution = rp.id_exec_institution
                              AND rp.id_institution = i_prof.institution) rp
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_needd
                      JOIN rehab_presc rpres
                        ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                      JOIN rehab_area_interv rai
                        ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
                      JOIN TABLE(find_prof_rehab_areas(i_prof.id, i_prof.institution)) x
                        ON x.id_rehab_area = rai.id_rehab_area
                      JOIN rehab_session_type rst
                        ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                      JOIN episode e
                        ON e.id_episode = rsn.id_episode_origin
                      JOIN clinical_service cs
                        ON cs.id_clinical_service = e.id_cs_requested
                      JOIN epis_info ei
                        ON ei.id_episode = e.id_episode
                      LEFT JOIN room r
                        ON r.id_room = ei.id_room
                      LEFT JOIN department d
                        ON d.id_department = r.id_department
                      LEFT JOIN clin_record cr
                        ON cr.id_episode = e.id_episode
                    -- AND cr.id_instit_enroled = rp.id_institution
                    -- AND cr.id_institution = rp.id_institution
                     WHERE rsn.flg_status = g_rehab_sch_need_scheduled
                       AND rsn.sessions > (SELECT COUNT(*)
                                             FROM rehab_schedule rs
                                            WHERE rs.id_rehab_sch_need = rsn.id_rehab_sch_need)
                          --to assure that there are no repeated records
                       AND rpres.id_rehab_presc IN (SELECT rpc.id_rehab_presc
                                                      FROM rehab_presc rpc
                                                     WHERE rpc.id_rehab_sch_need = rsn.id_rehab_sch_need
                                                       AND rpc.flg_status <> pk_alert_constant.g_cancelled
                                                       AND rownum = 1)
                       AND NOT EXISTS
                     (SELECT 1
                              FROM schedule s
                             WHERE s.dt_schedule_tstz BETWEEN l_dt_begin AND l_dt_end
                               AND s.id_schedule IN
                                   (SELECT rs.id_schedule
                                      FROM rehab_schedule rs
                                     WHERE rs.id_rehab_sch_need = rsn.id_rehab_sch_need))
                          -- **** quando é coordenador  
                       AND (l_id_category = g_category_registrar OR
                           (l_id_category = g_category_coordinator OR
                           -- ou o profissional responsável sou eu
                           (rsn.id_resp_professional IS NOT NULL AND rsn.id_resp_professional = i_prof.id) OR
                           -- ou o meu grupo
                           (rsn.id_resp_rehab_group IS NOT NULL AND
                           rsn.id_resp_rehab_group IN
                           (SELECT /*+opt_estimate(table t rows=1)*/
                                column_value
                                 FROM TABLE(l_prof_rehab_groups) t))))
                    
                    UNION ALL
                    --union all com os agendados hoje
                    SELECT /*+ opt_estimate(table x rows=1) */
                     e.id_patient,
                     pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode) AS patient_name,
                     pk_patphoto.get_pat_photo(i_lang, i_prof, e.id_patient, e.id_episode, NULL) AS photo,
                     pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) AS pat_age,
                     pk_patient.get_pat_gender(e.id_patient) AS gender,
                     pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) AS pat_ndo,
                     pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) AS pat_nd_icon,
                     e.id_episode AS id_episode,
                     get_desc_epis_type(i_lang, e.id_epis_type) AS epis_type,
                     pk_translation.get_translation(i_lang, d.code_department) AS department,
                     pk_translation.get_translation(i_lang, cs.code_clinical_service) AS service,
                     pk_prof_utils.get_nickname(i_lang, rsn.id_professional) AS request_prof,
                     nvl(rsn.id_resp_professional, rsn.id_resp_rehab_group) AS id_responsible,
                     get_rehab_sch_need_resp(i_lang, rsn.id_resp_professional, rsn.id_resp_rehab_group) AS responsible,
                     decode(rsn.id_resp_professional,
                            NULL,
                            decode(rsn.id_resp_rehab_group, NULL, NULL, g_list_type_group_abbr),
                            g_list_type_prof_abbr) AS responsible_type,
                     get_rehab_presc_list(i_lang, rsn.id_rehab_sch_need) AS treatments,
                     get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) AS instructions,
                     rsn.sessions AS num_sessions,
                     (SELECT rsn.sessions - COUNT(*)
                        FROM rehab_schedule rs
                       WHERE rs.id_rehab_sch_need = rsn.id_rehab_sch_need
                         AND rs.flg_status = 'A') AS num_sessions_pending,
                     rsn.frequency AS frequency_num,
                     rsn.flg_frequency AS frequency_time_unit,
                     pk_date_utils.dt_chr_tsz(i_lang, rsn.dt_begin, i_prof) AS dt_begin_desc,
                     pk_date_utils.get_timestamp_str(i_lang, i_prof, rsn.dt_begin, NULL) AS dt_begin_str,
                     rsn.notes AS session_notes,
                     cr.num_clin_record,
                     rst.id_rehab_session_type,
                     pk_translation.get_translation(i_lang, rst.code_rehab_session_type) AS session_type,
                     get_rsn_icon(i_lang, rsn.id_rehab_sch_need, rsn.sessions, rsn.flg_status) icon,
                     get_rsn_icon_label(i_lang, rsn.id_rehab_sch_need, rsn.flg_status, rsn.sessions) AS icon_label,
                     rsn.flg_status,
                     rsn.id_rehab_sch_need,
                     (SELECT DISTINCT CAST(COLLECT(ra.id_rehab_area) AS table_number)
                        FROM rehab_area ra
                        JOIN rehab_area_interv rai
                          ON rai.id_rehab_area = ra.id_rehab_area
                        JOIN rehab_presc rp
                          ON rp.id_rehab_area_interv = rai.id_rehab_area_interv
                       WHERE rp.id_rehab_sch_need = rsn.id_rehab_sch_need) AS tbl_id_rehab_area,
                     rsn.id_professional AS request_id_prof
                      FROM rehab_sch_need rsn
                      JOIN (SELECT DISTINCT rsn.id_rehab_sch_need id_rehab_sch_needd
                             FROM rehab_presc rp
                             JOIN rehab_sch_need rsn
                               ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                            WHERE rp.id_institution = rp.id_exec_institution
                              AND rp.id_institution = i_prof.institution) rp
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_needd
                      JOIN rehab_presc rpres
                        ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                      JOIN rehab_area_interv rai
                        ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
                      JOIN TABLE(find_prof_rehab_areas(i_prof.id, i_prof.institution)) x
                        ON x.id_rehab_area = rai.id_rehab_area
                      JOIN rehab_session_type rst
                        ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                      JOIN episode e
                        ON e.id_episode = rsn.id_episode_origin
                      JOIN clinical_service cs
                        ON cs.id_clinical_service = e.id_cs_requested
                      JOIN epis_info ei
                        ON ei.id_episode = e.id_episode
                      LEFT JOIN room r
                        ON r.id_room = ei.id_room
                      LEFT JOIN department d
                        ON d.id_department = r.id_department
                      LEFT JOIN clin_record cr
                        ON cr.id_episode = e.id_episode
                    -- AND cr.id_instit_enroled = rp.id_institution
                    -- AND cr.id_institution = rp.id_institution
                     WHERE rsn.flg_status = g_rehab_sch_need_scheduled
                       AND EXISTS (SELECT 1
                              FROM schedule s
                             WHERE s.dt_schedule_tstz BETWEEN l_dt_begin AND l_dt_end
                               AND s.id_schedule IN
                                   (SELECT rs.id_schedule
                                      FROM rehab_schedule rs
                                     WHERE rs.id_rehab_sch_need = rsn.id_rehab_sch_need))
                          --to assure that there are no repeated records
                       AND rpres.id_rehab_presc IN (SELECT rpc.id_rehab_presc
                                                      FROM rehab_presc rpc
                                                     WHERE rpc.id_rehab_sch_need = rsn.id_rehab_sch_need
                                                       AND rpc.flg_status <> pk_alert_constant.g_cancelled
                                                       AND rownum = 1)
                          -- **** quando é coordenador  
                       AND (l_id_category = g_category_registrar OR
                           (l_id_category = g_category_coordinator OR
                           -- ou o profissional responsável sou eu
                           (rsn.id_resp_professional IS NOT NULL AND rsn.id_resp_professional = i_prof.id) OR
                           -- ou o meu grupo
                           (rsn.id_resp_rehab_group IS NOT NULL AND
                           rsn.id_resp_rehab_group IN
                           (SELECT /*+opt_estimate(table t rows=1)*/
                                column_value
                                 FROM TABLE(l_prof_rehab_groups) t)))))
             ORDER BY decode(flg_status,
                             g_rehab_sch_need_wait_sch,
                             1,
                             g_rehab_sch_need_scheduled,
                             2,
                             g_rehab_sch_need_cancel,
                             3),
                      patient_name;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: ' || ' @' || g_error, g_package_name, l_func_name);
            pk_types.open_my_cursor(o_list);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_pending_sch_needs_grid;

    /**********************************************************************************************
    * Creates a new rehab treatments prescription
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient id
    * %param i_id_episode             current episode
    * %param i_id_rehab_area_interv   list of interventions
    * %param i_id_rehab_sch_need      list of schedule needs
    * %param i_id_exec_institution    list of institution where to execute
    * %param i_exec_per_session       list of number of executions per treeatment
    * %param i_presc_notes            list of treatment notes
    * %param i_sessions               list of sessions
    * %param i_frequency              list of frequencies
    * %param i_flg_frequency          list of frequency units
    * %param i_flg_priority           list of priorities
    * %param i_date_begin             list of begin date
    * %param i_session_notes          list of session notes
    * %param i_session_type           list of session types
    * %param o_id_rehab_presc         list of rehab prescriptions created
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION create_rehab_presc
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_patient           IN rehab_plan.id_patient%TYPE,
        i_id_episode           IN episode.id_episode%TYPE,
        i_id_rehab_area_interv IN table_number,
        i_id_rehab_sch_need    IN table_number,
        i_id_exec_institution  IN table_number,
        i_exec_per_session     IN table_number,
        i_presc_notes          IN table_varchar,
        i_sessions             IN table_number,
        i_frequency            IN table_number,
        i_flg_frequency        IN table_varchar,
        i_flg_priority         IN table_varchar,
        i_date_begin           IN table_varchar,
        i_session_notes        IN table_varchar,
        i_session_type         IN table_varchar,
        i_id_codification      IN table_number,
        i_flg_laterality       IN table_varchar,
        i_id_not_order_reason  IN table_number DEFAULT NULL,
        o_id_rehab_presc       OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CREATE_REHAB_PRESC';
    BEGIN
    
        g_error := 'CALL create_rehab_presc_internal';
        IF NOT create_rehab_presc_internal(i_lang                 => i_lang,
                                           i_prof                 => i_prof,
                                           i_id_patient           => i_id_patient,
                                           i_id_episode           => i_id_episode,
                                           i_id_rehab_area_interv => i_id_rehab_area_interv,
                                           i_id_rehab_sch_need    => i_id_rehab_sch_need,
                                           i_id_exec_institution  => i_id_exec_institution,
                                           i_exec_per_session     => i_exec_per_session,
                                           i_presc_notes          => i_presc_notes,
                                           i_sessions             => i_sessions,
                                           i_frequency            => i_frequency,
                                           i_flg_frequency        => i_flg_frequency,
                                           i_flg_priority         => i_flg_priority,
                                           i_date_begin           => i_date_begin,
                                           i_session_notes        => i_session_notes,
                                           i_session_type         => i_session_type,
                                           i_id_codification      => i_id_codification,
                                           i_flg_laterality       => i_flg_laterality,
                                           i_id_not_order_reason  => i_id_not_order_reason,
                                           o_id_rehab_presc       => o_id_rehab_presc,
                                           o_error                => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END create_rehab_presc;

    FUNCTION create_rehab_presc
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_episode           IN nurse_tea_req.id_episode%TYPE,
        i_id_patient           IN patient.id_patient%TYPE,
        i_root_name            IN VARCHAR2,
        i_tbl_records          IN table_number,
        i_tbl_ds_internal_name IN table_varchar,
        i_tbl_real_val         IN table_table_varchar,
        i_tbl_val_mea          IN table_table_varchar,
        i_tbl_val_clob         IN table_table_clob DEFAULT NULL,
        i_tbl_val_array        IN tt_table_varchar DEFAULT NULL,
        i_tbl_val_array_desc   IN tt_table_varchar DEFAULT NULL,
        i_codification         IN rehab_presc.id_codification%TYPE,
        i_flg_action           IN VARCHAR2,
        i_clinical_question_pk IN table_number,
        i_clinical_question    IN table_varchar,
        i_response             IN table_table_varchar,
        o_id_rehab_presc       OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CREATE_REHAB_PRESC';
    
        l_id_rehab_area_interv       table_number := table_number();
        l_id_rehab_sch_need          table_number := table_number();
        l_id_exec_institution        table_number := table_number();
        l_exec_per_session           table_number := table_number();
        l_presc_notes                table_varchar := table_varchar();
        l_sessions                   table_number := table_number();
        l_frequency                  table_number := table_number();
        l_flg_frequency              table_varchar := table_varchar();
        l_flg_priority               table_varchar := table_varchar();
        l_date_begin                 table_varchar := table_varchar();
        l_session_notes              table_varchar := table_varchar();
        l_session_type               table_varchar := table_varchar();
        l_flg_laterality             table_varchar := table_varchar();
        l_id_not_order_reason        table_number := table_number();
        l_tbl_codification           table_number := table_number();
        l_tbl_diagnosis_notes        table_varchar := table_varchar();
        l_tbl_clinical_purpose       table_number := table_number();
        l_tbl_clinical_purpose_notes table_varchar := table_varchar();
        l_tbl_id_pat_exemption       table_number := table_number();
        l_tbl_health_plan            table_number := table_number();
        l_tbl_icf                    table_table_number := table_table_number();
    
        l_count            PLS_INTEGER := 0;
        l_id_pat_exemption pat_isencao.id_pat_isencao%TYPE;
    
        --Diagnosis structures
        l_tbl_id_diagnosis       table_number := table_number();
        l_tbl_id_alert_diagnosis table_number := table_number();
        l_tbl_diagnoses          table_clob := table_clob();
        l_tbl_epis_diagnosis     pk_edis_types.table_in_epis_diagnosis;
        l_tbl_diagnosis_desc     table_varchar := table_varchar();
    
        --Clinical questions
        l_tbl_cq                  tbl_rehab_question_response := tbl_rehab_question_response();
        l_tbl_cq_response         tbl_cq_response := tbl_cq_response();
        l_clinical_question       table_table_number := table_table_number();
        l_response                table_table_number := table_table_number();
        l_clinical_question_notes table_table_varchar := table_table_varchar();
    BEGIN
    
        FOR i IN i_tbl_ds_internal_name.first .. i_tbl_ds_internal_name.last
        LOOP
            IF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_id_record
               AND i_flg_action = 'N'
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_id_rehab_area_interv.extend();
                    l_id_rehab_area_interv(l_id_rehab_area_interv.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_id_record
            THEN
                FOR j IN i_tbl_records.first .. i_tbl_records.last
                LOOP
                    l_id_rehab_area_interv.extend();
                    SELECT rp.id_rehab_area_interv
                      INTO l_id_rehab_area_interv(l_id_rehab_area_interv.count)
                      FROM rehab_presc rp
                     WHERE rp.id_rehab_presc = i_tbl_records(j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_place_service
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_id_exec_institution.extend();
                    l_id_exec_institution(j) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_executions_sessions
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_exec_per_session.extend();
                    l_exec_per_session(j) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_additional_notes
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_session_notes.extend();
                    l_session_notes(j) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_notes
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_presc_notes.extend();
                    l_presc_notes(j) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_number_sessions
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_sessions.extend();
                    l_sessions(j) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_frequency_sessions
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_frequency.extend();
                    l_frequency(j) := to_number(i_tbl_real_val(i) (j));
                
                    l_flg_frequency.extend();
                
                    IF to_number(i_tbl_val_mea(i) (j)) = 10375
                    THEN
                        l_flg_frequency(j) := 'W';
                    ELSIF to_number(i_tbl_val_mea(i) (j)) = 1127
                    THEN
                        l_flg_frequency(j) := 'M';
                    ELSE
                        l_flg_frequency(j) := 'D';
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_priority
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_flg_priority.extend();
                    l_flg_priority(j) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_start_date_medium
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_date_begin.extend();
                    l_date_begin(j) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_laterality
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_flg_laterality.extend();
                    l_flg_laterality(j) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_reason_not_ordering
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_id_not_order_reason.extend();
                    l_id_not_order_reason(j) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_indication_ft
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_diagnosis_notes.extend();
                    l_tbl_diagnosis_notes(j) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_purpose
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_clinical_purpose.extend();
                    l_tbl_clinical_purpose(j) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_purpose_ft
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_clinical_purpose_notes.extend();
                    l_tbl_clinical_purpose_notes(j) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_icf
            THEN
                IF i_tbl_val_array(i).exists(1)
                THEN
                    FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                    LOOP
                        l_tbl_icf.extend();
                        l_tbl_icf(j) := table_number();
                        IF i_tbl_val_array(i)(j).exists(1)
                        THEN
                            FOR k IN i_tbl_val_array(i)(j).first .. i_tbl_val_array(i)(j).last
                            LOOP
                                l_tbl_icf(j).extend();
                                l_tbl_icf(j)(k) := to_number(i_tbl_val_array(i) (j) (k));
                            END LOOP;
                        END IF;
                    END LOOP;
                END IF;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_indication_mw
            THEN
                FOR j IN i_tbl_records.first .. i_tbl_records.last
                LOOP
                
                    l_tbl_id_diagnosis       := table_number();
                    l_tbl_id_alert_diagnosis := table_number();
                    l_tbl_diagnosis_desc     := table_varchar();
                
                    SELECT ad.id_diagnosis, ad.id_alert_diagnosis, t_descriptions.column_value
                      BULK COLLECT
                      INTO l_tbl_id_diagnosis, l_tbl_id_alert_diagnosis, l_tbl_diagnosis_desc
                      FROM alert_diagnosis ad
                      JOIN (SELECT t.column_value, rownum AS rn
                              FROM TABLE(i_tbl_val_array(i) (j)) t) t_ids
                        ON ad.id_alert_diagnosis = t_ids.column_value
                      JOIN (SELECT t.column_value, rownum AS rn
                              FROM TABLE(i_tbl_val_array_desc(i) (j)) t) t_descriptions
                        ON t_descriptions.rn = t_ids.rn;
                
                    l_tbl_diagnoses.extend();
                    l_tbl_diagnoses(l_tbl_diagnoses.count) := pk_orders_utils.get_diagnosis_xml(i_lang                   => i_lang,
                                                                                                i_prof                   => i_prof,
                                                                                                i_id_patient             => i_id_patient,
                                                                                                i_id_episode             => i_id_episode,
                                                                                                i_tbl_id_diagnosis       => l_tbl_id_diagnosis,
                                                                                                i_tbl_id_alert_diagnosis => l_tbl_id_alert_diagnosis,
                                                                                                i_tbl_diagnosis_desc     => l_tbl_diagnosis_desc);
                
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_exemption
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_id_pat_exemption.extend();
                    l_tbl_id_pat_exemption(j) := i_tbl_real_val(i) (j);
                
                    IF l_tbl_id_pat_exemption(l_tbl_id_pat_exemption.count) IS NOT NULL
                    THEN
                        SELECT COUNT(1)
                          INTO l_count
                          FROM pat_isencao pi
                         WHERE pi.id_pat_isencao = l_tbl_id_pat_exemption(l_tbl_id_pat_exemption.count);
                    
                        IF l_count = 0
                        THEN
                            IF NOT pk_adt_core.set_pat_isencao(i_lang           => i_lang,
                                                               i_prof           => i_prof,
                                                               i_patient        => i_id_patient,
                                                               i_id_isencao     => l_tbl_id_pat_exemption(l_tbl_id_pat_exemption.count),
                                                               o_id_pat_isencao => l_id_pat_exemption,
                                                               o_error          => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            l_tbl_id_pat_exemption(l_tbl_id_pat_exemption.count) := l_id_pat_exemption;
                        END IF;
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_health_coverage_plan
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_health_plan.extend();
                    l_tbl_health_plan(l_tbl_health_plan.count) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            END IF;
        END LOOP;
    
        FOR i IN i_tbl_records.first .. i_tbl_records.last
        LOOP
            l_id_rehab_sch_need.extend;
            l_id_rehab_sch_need(i) := NULL;
        
            l_tbl_codification.extend();
            l_tbl_codification(i) := i_codification;
        END LOOP;
    
        --Clinical questions
        IF i_clinical_question_pk.count > 0
        THEN
            FOR i IN i_response.first .. i_response.last
            LOOP
                FOR j IN i_response(i).first .. i_response(i).last
                LOOP
                    l_tbl_cq_response.extend;
                    l_tbl_cq_response(l_tbl_cq_response.count) := t_cq_response(response => i_response(i) (j), rn => i);
                END LOOP;
            END LOOP;
        
            SELECT t_rehab_question_response(id_intervention  => t.id_intervention,
                                              id_questionnaire => t.id_questionnaire,
                                              id_response      => CASE
                                                                      WHEN rq.flg_type IS NULL THEN
                                                                       to_number(t.response)
                                                                      ELSE
                                                                       rq.id_response
                                                                  END,
                                              notes            => CASE
                                                                      WHEN rq.flg_type IS NOT NULL THEN
                                                                       t.response
                                                                  END,
                                              rank             => rq.rank)
              BULK COLLECT
              INTO l_tbl_cq
              FROM (SELECT to_number(t_questionnaire.id_questionnaire) id_questionnaire,
                           (t_intervention.id_pk - to_number(t_questionnaire.id_questionnaire)) id_intervention,
                           t_response.response
                      FROM (SELECT column_value AS id_questionnaire, rownum AS rn
                              FROM TABLE(i_clinical_question)) t_questionnaire
                      JOIN (SELECT column_value AS id_pk, rownum AS rn
                             FROM TABLE(i_clinical_question_pk)) t_intervention
                        ON t_intervention.rn = t_questionnaire.rn
                      JOIN (SELECT response, rn
                             FROM TABLE(l_tbl_cq_response)) t_response
                        ON t_response.rn = t_questionnaire.rn) t
              LEFT JOIN interv_questionnaire rq
                ON rq.id_intervention = t.id_intervention
               AND rq.id_questionnaire = t.id_questionnaire
               AND rq.flg_time = 'O'
               AND rq.flg_available = pk_alert_constant.g_yes
               AND rq.id_institution = i_prof.institution
               AND rq.flg_type IN ('T', 'D');
        
            FOR i IN l_id_rehab_area_interv.first .. l_id_rehab_area_interv.last
            LOOP
                l_clinical_question.extend();
                l_response.extend();
                l_clinical_question_notes.extend();
            
                SELECT t.id_questionnaire, t.id_response, t.notes
                  BULK COLLECT
                  INTO l_clinical_question(i), l_response(i), l_clinical_question_notes(i)
                  FROM rehab_area_interv rai
                  JOIN TABLE(l_tbl_cq) t
                    ON t.id_intervention = rai.id_intervention
                 WHERE rai.id_rehab_area_interv = l_id_rehab_area_interv(i);
            END LOOP;
        END IF;
    
        IF i_flg_action = 'N'
        THEN
            FOR i IN l_id_rehab_area_interv.first .. l_id_rehab_area_interv.last
            LOOP
            
                l_session_type.extend();
                BEGIN
                    SELECT r.id_rehab_session_type
                      INTO l_session_type(i)
                      FROM rehab_inst_soft r
                     WHERE r.id_rehab_area_interv = l_id_rehab_area_interv(i)
                       AND r.id_institution = i_prof.institution
                       AND r.id_software = i_prof.software
                       AND r.flg_add_remove = 'A';
                EXCEPTION
                    WHEN OTHERS THEN
                        l_session_type(i) := NULL;
                END;
            END LOOP;
        ELSE
            FOR i IN i_tbl_records.first .. i_tbl_records.last
            LOOP
                l_session_type.extend();
                BEGIN
                    SELECT r.id_rehab_session_type
                      INTO l_session_type(i)
                      FROM rehab_inst_soft r
                      JOIN rehab_presc rp
                        ON rp.id_rehab_area_interv = r.id_rehab_area_interv
                     WHERE r.id_institution = i_prof.institution
                       AND r.id_software = i_prof.software
                       AND r.flg_add_remove = 'A'
                       AND rp.id_rehab_presc = i_tbl_records(i);
                EXCEPTION
                    WHEN OTHERS THEN
                        l_session_type(i) := NULL;
                        l_id_rehab_area_interv(i) := NULL;
                END;
            END LOOP;
        END IF;
    
        IF i_flg_action = 'N' --NEW RECORD
        THEN
            g_error := 'CALL create_rehab_presc_internal';
            IF NOT create_rehab_presc_internal(i_lang                    => i_lang,
                                               i_prof                    => i_prof,
                                               i_id_patient              => i_id_patient,
                                               i_id_episode              => i_id_episode,
                                               i_id_rehab_area_interv    => l_id_rehab_area_interv,
                                               i_id_rehab_sch_need       => l_id_rehab_sch_need,
                                               i_id_exec_institution     => l_id_exec_institution,
                                               i_exec_per_session        => l_exec_per_session,
                                               i_presc_notes             => l_presc_notes,
                                               i_sessions                => l_sessions,
                                               i_frequency               => l_frequency,
                                               i_flg_frequency           => l_flg_frequency,
                                               i_flg_priority            => l_flg_priority,
                                               i_date_begin              => l_date_begin,
                                               i_session_notes           => l_session_notes,
                                               i_session_type            => l_session_type,
                                               i_id_codification         => l_tbl_codification,
                                               i_flg_laterality          => l_flg_laterality,
                                               i_id_not_order_reason     => l_id_not_order_reason,
                                               i_id_pat_health_plan      => l_tbl_health_plan,
                                               i_id_pat_exemption        => l_tbl_id_pat_exemption,
                                               i_diagnosis_notes         => l_tbl_diagnosis_notes,
                                               i_diagnosis               => pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                                                                      i_prof   => i_prof,
                                                                                                      i_params => l_tbl_diagnoses),
                                               i_clinical_purpose        => l_tbl_clinical_purpose,
                                               i_clinical_purpose_notes  => l_tbl_clinical_purpose_notes,
                                               i_clinical_question       => l_clinical_question,
                                               i_response                => l_response,
                                               i_clinical_question_notes => l_clinical_question_notes,
                                               i_tbl_icf                 => l_tbl_icf,
                                               o_id_rehab_presc          => o_id_rehab_presc,
                                               o_error                   => o_error)
            THEN
                RAISE g_exception;
            END IF;
        ELSIF i_flg_action = 'U' --UPDATE
        THEN
        
            l_tbl_epis_diagnosis := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                              i_prof   => i_prof,
                                                              i_params => l_tbl_diagnoses);
        
            g_error := 'CALL SET_REHAB_PRESC: i_id_rehab_presc = ' || i_tbl_records(1);
            pk_alertlog.log_debug(g_error);
            IF NOT pk_rehab.set_rehab_presc(i_lang                    => i_lang,
                                       i_prof                    => i_prof,
                                       i_id_patient              => i_id_patient,
                                       i_id_episode              => i_id_episode,
                                       i_id_rehab_presc          => i_tbl_records(1),
                                       i_id_rehab_area_interv    => l_id_rehab_area_interv(1),
                                       i_id_rehab_sch_need       => l_id_rehab_sch_need(1),
                                       i_id_exec_institution     => l_id_exec_institution(1),
                                       i_exec_per_session        => l_exec_per_session(1),
                                       i_presc_notes             => l_presc_notes(1),
                                       i_sessions                => l_sessions(1),
                                       i_frequency               => l_frequency(1),
                                       i_flg_frequency           => l_flg_frequency(1),
                                       i_flg_priority            => l_flg_priority(1),
                                       i_date_begin              => l_date_begin(1),
                                       i_session_notes           => l_session_notes(1),
                                       i_session_type            => l_session_type(1),
                                       i_flg_laterality          => l_flg_laterality(1),
                                       i_id_not_order_reason     => CASE
                                                                        WHEN l_id_not_order_reason.exists(1) THEN
                                                                         l_id_not_order_reason(1)
                                                                    END,
                                       i_flg_commit              => pk_alert_constant.g_no,
                                       i_id_pat_health_plan      => l_tbl_health_plan(1),
                                       i_id_pat_exemption        => l_tbl_id_pat_exemption(1),
                                       i_diagnosis_notes         => l_tbl_diagnosis_notes(1),
                                       i_diagnosis               => CASE
                                                                        WHEN l_tbl_epis_diagnosis.exists(1) THEN
                                                                         l_tbl_epis_diagnosis(1)
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                       i_clinical_purpose        => l_tbl_clinical_purpose(1),
                                       i_clinical_purpose_notes  => l_tbl_clinical_purpose_notes(1),
                                       i_clinical_question       => CASE
                                                                        WHEN l_clinical_question.exists(1) THEN
                                                                         l_clinical_question(1)
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                       i_response                => CASE
                                                                        WHEN l_response.exists(1) THEN
                                                                         l_response(1)
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                       i_clinical_question_notes => CASE
                                                                        WHEN l_clinical_question_notes.exists(1) THEN
                                                                         l_clinical_question_notes(1)
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                       i_tbl_icf                 => CASE
                                                                        WHEN l_tbl_icf.exists(1) THEN
                                                                         l_tbl_icf(1)
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                       o_id_rehab_presc          => o_id_rehab_presc,
                                       o_error                   => o_error)
            THEN
                RETURN FALSE;
            END IF;
        ELSIF i_flg_action = 'D' --Duplicate record
        THEN
            SELECT rp.id_rehab_area_interv
              BULK COLLECT
              INTO l_id_rehab_area_interv
              FROM rehab_presc rp
             WHERE rp.id_rehab_presc = i_tbl_records(1);
        
            g_error := 'CALL create_rehab_presc_internal';
            IF NOT create_rehab_presc_internal(i_lang                   => i_lang,
                                               i_prof                   => i_prof,
                                               i_id_patient             => i_id_patient,
                                               i_id_episode             => i_id_episode,
                                               i_id_rehab_area_interv   => l_id_rehab_area_interv,
                                               i_id_rehab_sch_need      => l_id_rehab_sch_need,
                                               i_id_exec_institution    => l_id_exec_institution,
                                               i_exec_per_session       => l_exec_per_session,
                                               i_presc_notes            => l_presc_notes,
                                               i_sessions               => l_sessions,
                                               i_frequency              => l_frequency,
                                               i_flg_frequency          => l_flg_frequency,
                                               i_flg_priority           => l_flg_priority,
                                               i_date_begin             => l_date_begin,
                                               i_session_notes          => l_session_notes,
                                               i_session_type           => l_session_type,
                                               i_id_codification        => l_tbl_codification,
                                               i_flg_laterality         => l_flg_laterality,
                                               i_id_not_order_reason    => l_id_not_order_reason,
                                               i_id_pat_health_plan     => l_tbl_health_plan,
                                               i_id_pat_exemption       => l_tbl_id_pat_exemption,
                                               i_diagnosis_notes        => l_tbl_diagnosis_notes,
                                               i_diagnosis              => pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                                                                     i_prof   => i_prof,
                                                                                                     i_params => l_tbl_diagnoses),
                                               i_clinical_purpose       => l_tbl_clinical_purpose,
                                               i_clinical_purpose_notes => l_tbl_clinical_purpose_notes,
                                               o_id_rehab_presc         => o_id_rehab_presc,
                                               o_error                  => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END create_rehab_presc;

    FUNCTION manage_most_frequent_rehab_dept
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_rehab_area_interv IN rehab_area_interv.id_rehab_area_interv%TYPE,
        i_dept                 IN clinical_service.id_clinical_service%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN AS
        l_hash  NUMBER(24);
        l_count NUMBER(24);
    BEGIN
        l_hash := get_rehab_area_interv_hash(i_lang, i_prof, i_id_rehab_area_interv);
    
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_most_frequent rf
         WHERE rf.id_rehab_area_interv = i_id_rehab_area_interv
           AND rf.id_universe = 10
           AND rf.rehab_interv_hash = l_hash;
    
        IF l_count > 0
        THEN
            UPDATE rehab_most_frequent
               SET rank = rank + 1
             WHERE id_rehab_area_interv = i_id_rehab_area_interv
               AND rehab_interv_hash = l_hash;
        ELSE
            INSERT INTO rehab_most_frequent
                (id_rehab_most_frequent, id_universe, id_value, id_rehab_area_interv, rehab_interv_hash, rank)
            VALUES
                (seq_rehab_most_frequent.nextval, 10, i_dept, i_id_rehab_area_interv, l_hash, 1);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'MANAGE_MOST_FREQUENT_REHAB_DEPT',
                                              o_error);
            RETURN FALSE;
    END manage_most_frequent_rehab_dept;

    /**********************************************************************************************
    * Creates a new rehab treatments prescription
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient id
    * %param i_id_episode             current episode
    * %param i_id_rehab_area_interv   list of interventions
    * %param i_id_rehab_sch_need      list of schedule needs
    * %param i_id_exec_institution    list of institution where to execute
    * %param i_exec_per_session       list of number of executions per treeatment
    * %param i_presc_notes            list of treatment notes
    * %param i_sessions               list of sessions
    * %param i_frequency              list of frequencies
    * %param i_flg_frequency          list of frequency units
    * %param i_flg_priority           list of priorities
    * %param i_date_begin             list of begin date
    * %param i_session_notes          list of session notes
    * %param i_session_type           list of session types
    * %param o_id_rehab_presc         list of rehab prescriptions created
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION create_rehab_presc_internal
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_id_patient              IN rehab_plan.id_patient%TYPE,
        i_id_episode              IN episode.id_episode%TYPE,
        i_id_rehab_area_interv    IN table_number,
        i_id_rehab_sch_need       IN table_number,
        i_id_exec_institution     IN table_number,
        i_exec_per_session        IN table_number,
        i_presc_notes             IN table_varchar,
        i_sessions                IN table_number,
        i_frequency               IN table_number,
        i_flg_frequency           IN table_varchar,
        i_flg_priority            IN table_varchar,
        i_date_begin              IN table_varchar,
        i_session_notes           IN table_varchar,
        i_session_type            IN table_varchar,
        i_id_codification         IN table_number,
        i_flg_laterality          IN table_varchar,
        i_id_not_order_reason     IN table_number DEFAULT NULL,
        i_id_pat_health_plan      IN table_number DEFAULT NULL,
        i_id_pat_exemption        IN table_number DEFAULT NULL,
        i_diagnosis_notes         IN table_varchar DEFAULT NULL,
        i_diagnosis               IN pk_edis_types.table_in_epis_diagnosis DEFAULT NULL,
        i_clinical_purpose        IN table_number DEFAULT NULL,
        i_clinical_purpose_notes  IN table_varchar DEFAULT NULL,
        i_clinical_question       IN table_table_number DEFAULT NULL,
        i_response                IN table_table_number DEFAULT NULL,
        i_clinical_question_notes IN table_table_varchar DEFAULT NULL,
        i_tbl_icf                 IN table_table_number DEFAULT NULL,
        o_id_rehab_presc          OUT table_number,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CREATE_REHAB_PRESC_INTERNAL';
        l_tmp_rows              table_varchar;
        l_rowids_rp             table_varchar;
        l_rowids_rsn            table_varchar;
        l_id_rehab_sch_need     rehab_sch_need.id_rehab_sch_need%TYPE;
        l_rsn_updated           table_number := table_number();
        l_cfg_needs_schedule    sys_config.value%TYPE;
        l_rehab_sch_need_status rehab_sch_need.flg_status%TYPE;
        l_ref_external_inst     sys_config.value%TYPE;
        l_rehab_presc_status    rehab_presc.flg_status%TYPE := g_rehab_presc_begin;
        l_id_episode_origin     rehab_plan.id_episode_origin%TYPE;
        l_id_schedule           rehab_schedule.id_schedule%TYPE;
        l_id_epis_type          episode.id_epis_type%TYPE;
        l_error                 t_error_out;
        l_not_order_reason      not_order_reason.id_not_order_reason%TYPE;
        l_lst_not_order_reason  table_number;
        l_id_rehab_session_type rehab_session_type.id_rehab_session_type%TYPE;
        l_sessions              rehab_sch_need.sessions%TYPE;
        l_frequency             rehab_sch_need.frequency%TYPE;
        l_flg_frequency         rehab_sch_need.flg_frequency%TYPE;
        l_flg_priority          rehab_sch_need.flg_priority%TYPE;
        l_date_begin            rehab_sch_need.dt_begin%TYPE;
        l_notes                 rehab_sch_need.notes%TYPE;
    
        l_id_rehab_presc_hist rehab_presc_hist.id_rehab_presc_hist%TYPE;
        l_dt_rehab_presc_icf  rehab_presc_icf.dt_rehab_presc_icf%TYPE;
    
        l_id_rehab_question_response rehab_question_response.id_rehab_question_response %TYPE;
        l_id_department              department.id_department%TYPE;
    BEGIN
        g_error := 'Begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        o_id_rehab_presc       := table_number();
        l_rowids_rp            := table_varchar();
        l_lst_not_order_reason := coalesce(i_id_not_order_reason, table_number());
    
        g_error := 'Checking the configuration that defines if scheduling is needed in this institution';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        l_cfg_needs_schedule := pk_sysconfig.get_config(i_code_cf => g_cfg_needs_schedule, i_prof => i_prof);
        --Referral inst parameterization
        l_ref_external_inst := pk_sysconfig.get_config('REF_EXTERNAL_INST', i_prof);
        --
        IF l_cfg_needs_schedule = pk_alert_constant.g_yes
        THEN
            l_rehab_sch_need_status := g_rehab_sch_need_wait_sch;
        ELSE
            l_rehab_sch_need_status := g_rehab_sch_need_no_sched;
        END IF;
    
        IF NOT pk_rehab.get_origin_episode(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_id_episode        => i_id_episode,
                                           i_id_schedule       => NULL,
                                           o_id_episode_origin => l_id_episode_origin,
                                           o_id_schedule       => l_id_schedule,
                                           o_id_epis_type      => l_id_epis_type,
                                           o_error             => l_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'DELETE TBL_TEMP';
        DELETE FROM tbl_temp;
    
        g_error := 'Before FOR';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        FOR i IN 1 .. i_id_rehab_area_interv.count
        LOOP
            --referral
            IF i_id_exec_institution(i) = l_ref_external_inst
            THEN
                l_rehab_sch_need_status := g_rehab_sch_need_no_sched;
                l_rehab_presc_status    := g_rehab_presc_referral;
            END IF;
        
            -- getting not order reason id                                              
            IF l_lst_not_order_reason.count > 0
            THEN
                IF l_lst_not_order_reason(i) IS NOT NULL
                THEN
                    -- if the state is 'Not Order Reason' does not have scheduling
                    l_rehab_sch_need_status := g_rehab_sch_need_no_sched;
                    l_rehab_presc_status    := g_rehab_presc_not_order_reas;
                
                    g_error := 'Call set_not_order_reason: ';
                    g_error := g_error || ' i_not_order_reason_ea = ' ||
                               coalesce(to_char(l_lst_not_order_reason(i)), '<null>');
                    pk_alertlog.log_debug(g_error);
                    IF NOT pk_not_order_reason_db.set_not_order_reason(i_lang                => i_lang,
                                                                       i_prof                => i_prof,
                                                                       i_not_order_reason_ea => l_lst_not_order_reason(i),
                                                                       o_id_not_order_reason => l_not_order_reason,
                                                                       o_error               => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                END IF;
            END IF;
        
            IF i_id_rehab_sch_need(i) IS NULL
            THEN
                g_error := 'Before get_rehab_plan';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                -- verifica se este episódio já existe na rehab_plan, caso não exista cria
                IF NOT check_rehab_plan(i_lang              => i_lang,
                                        i_prof              => i_prof,
                                        i_id_patient        => i_id_patient,
                                        i_id_episode_origin => l_id_episode_origin,
                                        i_commit            => pk_alert_constant.get_no(),
                                        o_error             => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                BEGIN
                    SELECT tt.num_3
                      INTO l_id_rehab_sch_need
                      FROM tbl_temp tt
                     WHERE tt.vc_1 = 'REHAB_SCH_NEED'
                       AND nvl(tt.num_1, 0) = nvl(i_sessions(i), nvl(tt.num_1, 0))
                       AND nvl(tt.num_2, 0) = nvl(i_frequency(i), nvl(tt.num_2, 0))
                       AND nvl(tt.vc_2, 'X') = nvl(i_flg_frequency(i), nvl(tt.vc_2, 'X'))
                       AND nvl(tt.vc_3, 'X') = nvl(i_flg_priority(i), nvl(tt.vc_3, 'X'))
                       AND nvl(tt.vc_4, 'X') = nvl(i_date_begin(i), nvl(tt.vc_4, 'X'))
                       AND nvl(tt.vc_5, 'X') = nvl(i_session_notes(i), nvl(tt.vc_5, 'X'))
                       AND tt.vc_6 = i_session_type(i);
                EXCEPTION
                    WHEN no_data_found THEN
                        l_id_rehab_sch_need := NULL;
                END;
            
                IF l_id_rehab_sch_need IS NULL
                THEN
                
                    g_error := 'Before ts_rehab_sch_need.ins i_flg_priority(i)=' || i_flg_priority(i) || '#';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                
                    -- se i_id_rehab_sch_need(i) é null tem de se criar uma nova necessidade
                    l_id_rehab_sch_need := ts_rehab_sch_need.next_key();
                    ts_rehab_sch_need.ins(id_rehab_sch_need_in => l_id_rehab_sch_need,
                                          id_episode_origin_in => l_id_episode_origin,
                                          
                                          sessions_in              => i_sessions(i),
                                          frequency_in             => i_frequency(i),
                                          flg_frequency_in         => i_flg_frequency(i),
                                          flg_priority_in          => i_flg_priority(i),
                                          dt_begin_in              => pk_date_utils.get_string_tstz(i_lang,
                                                                                                    i_prof,
                                                                                                    i_date_begin(i),
                                                                                                    NULL),
                                          flg_status_in            => l_rehab_sch_need_status,
                                          id_professional_in       => i_prof.id,
                                          dt_rehab_sch_need_in     => g_sysdate_tstz,
                                          id_rehab_session_type_in => i_session_type(i),
                                          notes_in                 => i_session_notes(i),
                                          rows_out                 => l_tmp_rows);
                
                    l_rowids_rsn := l_rowids_rsn MULTISET UNION l_tmp_rows;
                
                    --l_id_rehab_sch_need_hist := ts_rehab_sch_need_hist.next_key();
                    IF NOT set_rehab_sch_need_hist(i_lang              => i_lang,
                                                   i_prof              => i_prof,
                                                   i_id_rehab_sch_need => l_id_rehab_sch_need,
                                                   i_commit            => pk_alert_constant.get_no(),
                                                   o_error             => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    INSERT INTO tbl_temp
                        (vc_1, num_3, num_1, num_2, vc_2, vc_3, vc_4, vc_5, vc_6)
                    VALUES
                        ('REHAB_SCH_NEED',
                         l_id_rehab_sch_need,
                         i_sessions(i),
                         i_frequency(i),
                         i_flg_frequency(i),
                         i_flg_priority(i),
                         i_date_begin(i),
                         i_session_notes(i),
                         i_session_type(i));
                END IF;
            
            ELSE
                SELECT rsn.id_rehab_session_type
                  INTO l_id_rehab_session_type
                  FROM rehab_sch_need rsn
                 WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need(i);
            
                --CHECK IF SUGESTED SCH_NEED IS OF THE SAME TYPE OF THE CURRENT REQUEST
                IF l_id_rehab_session_type = i_session_type(i)
                THEN
                    l_id_rehab_sch_need := i_id_rehab_sch_need(i);
                ELSE
                
                    g_error := 'Before get_rehab_plan';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                
                    -- verifica se este episódio já existe na rehab_plan, caso não exista cria
                    IF NOT check_rehab_plan(i_lang              => i_lang,
                                            i_prof              => i_prof,
                                            i_id_patient        => i_id_patient,
                                            i_id_episode_origin => l_id_episode_origin,
                                            i_commit            => pk_alert_constant.get_no(),
                                            o_error             => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    SELECT rsn.sessions, rsn.frequency, rsn.flg_frequency, rsn.flg_priority, rsn.dt_begin, rsn.notes
                      INTO l_sessions, l_frequency, l_flg_frequency, l_flg_priority, l_date_begin, l_notes
                      FROM rehab_sch_need rsn
                     WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need(i);
                
                    --CHECK IF THERE IS ALREADY A SCH_NEED OF THE SAME TYPE OF THE CURRENT REQUEST AND WITH THE SAME INSTRUCTIONS
                    BEGIN
                        SELECT rsn.id_rehab_sch_need
                          INTO l_id_rehab_sch_need
                          FROM rehab_sch_need rsn
                         WHERE rsn.id_rehab_session_type = i_session_type(i)
                           AND rsn.sessions = l_sessions
                           AND rsn.frequency = l_frequency
                           AND rsn.flg_frequency = l_flg_frequency
                           AND flg_priority = l_flg_priority
                           AND rsn.dt_begin = l_date_begin
                           AND rsn.notes = l_notes
                           AND rsn.flg_status = g_rehab_sch_need_wait_sch
                           AND rsn.id_episode_origin IN
                               (SELECT rsn_i.id_episode_origin
                                  FROM rehab_sch_need rsn_i
                                 WHERE rsn_i.id_rehab_sch_need = i_id_rehab_sch_need(i));
                    EXCEPTION
                        WHEN OTHERS THEN
                            l_id_rehab_sch_need := NULL;
                    END;
                
                    IF l_id_rehab_sch_need IS NULL
                    THEN
                        g_error := 'Before ts_rehab_sch_need.ins i_flg_priority(i)=' || l_flg_priority || '#';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    
                        -- se i_id_rehab_sch_need(i) é null tem de se criar uma nova necessidade
                        l_id_rehab_sch_need := ts_rehab_sch_need.next_key();
                        ts_rehab_sch_need.ins(id_rehab_sch_need_in => l_id_rehab_sch_need,
                                              id_episode_origin_in => l_id_episode_origin,
                                              
                                              sessions_in              => l_sessions,
                                              frequency_in             => l_frequency,
                                              flg_frequency_in         => l_flg_frequency,
                                              flg_priority_in          => l_flg_priority,
                                              dt_begin_in              => l_date_begin,
                                              flg_status_in            => l_rehab_sch_need_status,
                                              id_professional_in       => i_prof.id,
                                              dt_rehab_sch_need_in     => g_sysdate_tstz,
                                              id_rehab_session_type_in => i_session_type(i),
                                              notes_in                 => l_notes,
                                              rows_out                 => l_tmp_rows);
                    
                        l_rowids_rsn := l_rowids_rsn MULTISET UNION l_tmp_rows;
                    
                        --l_id_rehab_sch_need_hist := ts_rehab_sch_need_hist.next_key();
                        IF NOT set_rehab_sch_need_hist(i_lang              => i_lang,
                                                       i_prof              => i_prof,
                                                       i_id_rehab_sch_need => l_id_rehab_sch_need,
                                                       i_commit            => pk_alert_constant.get_no(),
                                                       o_error             => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    END IF;
                END IF;
            END IF;
        
            g_error := 'add rehab_sch_need to list';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            -- guarda os ids para mais tarde se verificar se existem tratamentos 
            -- de diferentes áreas na mesma necessidade de agendamento
            l_rsn_updated.extend();
            l_rsn_updated(l_rsn_updated.last) := l_id_rehab_sch_need;
        
            g_error := 'Before ts_rehab_presc.ins';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            o_id_rehab_presc.extend;
            o_id_rehab_presc(i) := ts_rehab_presc.next_key;
        
            -- TODO: Change the history function!
            ts_rehab_presc.ins(id_rehab_presc_in         => o_id_rehab_presc(i),
                               id_rehab_area_interv_in   => i_id_rehab_area_interv(i),
                               id_professional_in        => i_prof.id,
                               id_institution_in         => i_prof.institution,
                               id_rehab_sch_need_in      => l_id_rehab_sch_need,
                               id_exec_institution_in    => i_id_exec_institution(i),
                               exec_per_session_in       => i_exec_per_session(i),
                               notes_in                  => i_presc_notes(i),
                               flg_status_in             => l_rehab_presc_status,
                               dt_rehab_presc_in         => g_sysdate_tstz,
                               id_codification_in        => i_id_codification(i),
                               flg_laterality_in         => CASE
                                                                WHEN i_flg_laterality IS NOT NULL
                                                                     AND i_flg_laterality.count > 0 THEN
                                                                 i_flg_laterality(i)
                                                                ELSE
                                                                 NULL
                                                            END,
                               id_not_order_reason_in    => l_not_order_reason,
                               id_pat_health_plan_in     => CASE
                                                                WHEN i_id_pat_health_plan.exists(i) THEN
                                                                 i_id_pat_health_plan(i)
                                                                ELSE
                                                                 NULL
                                                            END,
                               id_pat_exemption_in       => CASE
                                                                WHEN i_id_pat_exemption.exists(i) THEN
                                                                 i_id_pat_exemption(i)
                                                                ELSE
                                                                 NULL
                                                            END,
                               diagnosis_notes_in        => CASE
                                                                WHEN i_diagnosis_notes.exists(i) THEN
                                                                 i_diagnosis_notes(i)
                                                                ELSE
                                                                 NULL
                                                            END,
                               id_clinical_purpose_in    => CASE
                                                                WHEN i_clinical_purpose.exists(i) THEN
                                                                 i_clinical_purpose(i)
                                                                ELSE
                                                                 NULL
                                                            END,
                               clinical_purpose_notes_in => CASE
                                                                WHEN i_clinical_purpose_notes.exists(i) THEN
                                                                 i_clinical_purpose_notes(i)
                                                                ELSE
                                                                 NULL
                                                            END,
                               rows_out                  => l_tmp_rows);
        
            --This date must be saved because the history function (set_rehab_presc_hist) resets g_sysdate_tstz
            l_dt_rehab_presc_icf := g_sysdate_tstz;
        
            l_rowids_rp := l_rowids_rp MULTISET UNION l_tmp_rows;
        
            --The history id is generated here in order to inject it in pk_diagnosis.set_mcdt_req_diag_no_commit
            l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key();
        
            --insert in rehab_presc_hist
            IF NOT set_rehab_presc_hist(i_lang                => i_lang,
                                        i_prof                => i_prof,
                                        i_id_rehab_presc      => o_id_rehab_presc(i),
                                        i_commit              => pk_alert_constant.get_no(),
                                        i_id_rehab_presc_hist => l_id_rehab_presc_hist,
                                        o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            --ICF
            IF i_tbl_icf.exists(i)
            THEN
                IF i_tbl_icf(i).count > 0
                THEN
                    FOR j IN i_tbl_icf(i).first .. i_tbl_icf(i).last
                    LOOP
                        g_error := 'INSERT INTO rehab_presc_icf';
                        INSERT INTO rehab_presc_icf
                            (id_rehab_presc_icf, id_rehab_presc, id_rehab_diagnosis, flg_status, dt_rehab_presc_icf)
                        VALUES
                            (seq_rehab_presc_icf.nextval,
                             o_id_rehab_presc(i),
                             i_tbl_icf(i) (j),
                             pk_alert_constant.g_active,
                             l_dt_rehab_presc_icf);
                    
                        g_error := 'INSERT INTO rehab_presc_icf_hist';
                        INSERT INTO rehab_presc_icf_hist
                            (id_rehab_presc_icf_hist,
                             id_rehab_presc,
                             id_rehab_diagnosis,
                             dt_rehab_presc_icf_hist,
                             dt_rehab_presc_icf)
                        VALUES
                            (seq_rehab_presc_icf_hist.nextval,
                             o_id_rehab_presc(i),
                             i_tbl_icf(i) (j),
                             g_sysdate_tstz,
                             l_dt_rehab_presc_icf);
                    END LOOP;
                END IF;
            END IF;
        
            g_error := 'CALL TO PK_DIAGNOSIS.SET_MCDT_REQ_DIAG_NO_COMMIT';
            IF i_diagnosis.exists(i)
            THEN
                IF i_diagnosis(i).tbl_diagnosis IS NOT NULL
                    AND i_diagnosis(i).tbl_diagnosis.count != 0
                THEN
                    IF NOT pk_diagnosis.set_mcdt_req_diag_no_commit(i_lang             => i_lang,
                                                                    i_prof             => i_prof,
                                                                    i_epis             => i_id_episode,
                                                                    i_diag             => i_diagnosis(i),
                                                                    i_exam_req         => NULL,
                                                                    i_analysis_req     => NULL,
                                                                    i_interv_presc     => NULL,
                                                                    i_exam_req_det     => NULL,
                                                                    i_analysis_req_det => NULL,
                                                                    i_interv_presc_det => NULL,
                                                                    i_rehab_presc      => o_id_rehab_presc(i),
                                                                    i_rehab_presc_hist => l_id_rehab_presc_hist,
                                                                    o_error            => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                END IF;
            END IF;
        
            --Clinical questions
            IF i_clinical_question.exists(i)
            THEN
                IF i_clinical_question(i).count != 0
                THEN
                    FOR j IN i_clinical_question(i).first .. i_clinical_question(i).last
                    LOOP
                        IF i_clinical_question(i) (j) IS NOT NULL
                        THEN
                            IF i_response(i) (j) IS NOT NULL
                            THEN
                                SELECT nvl(MAX(rqr.id_rehab_question_response), 0) + 1
                                  INTO l_id_rehab_question_response
                                  FROM rehab_question_response rqr;
                            
                                g_error := 'INSERT INTO rehab_question_response';
                                INSERT INTO rehab_question_response
                                    (id_rehab_question_response,
                                     id_rehab_presc,
                                     id_questionnaire,
                                     id_response,
                                     notes,
                                     flg_time,
                                     id_episode,
                                     id_prof_last_update,
                                     dt_last_update_tstz)
                                VALUES
                                    (l_id_rehab_question_response,
                                     o_id_rehab_presc(i),
                                     i_clinical_question(i) (j),
                                     i_response(i) (j),
                                     coalesce(i_clinical_question_notes(i) (j),
                                              pk_mcdt.get_response_alias(i_lang,
                                                                         i_prof,
                                                                         'RESPONSE.CODE_RESPONSE.' || i_response(i) (j))),
                                     pk_blood_products_constant.g_bp_cq_on_order,
                                     i_id_episode,
                                     i_prof.id,
                                     g_sysdate_tstz);
                            ELSE
                                SELECT nvl(MAX(rqr.id_rehab_question_response), 0) + 1
                                  INTO l_id_rehab_question_response
                                  FROM rehab_question_response rqr;
                            
                                g_error := 'INSERT INTO rehab_question_response';
                                INSERT INTO rehab_question_response
                                    (id_rehab_question_response,
                                     id_rehab_presc,
                                     id_questionnaire,
                                     id_response,
                                     notes,
                                     flg_time,
                                     id_episode,
                                     id_prof_last_update,
                                     dt_last_update_tstz)
                                VALUES
                                    (l_id_rehab_question_response,
                                     o_id_rehab_presc(i),
                                     i_clinical_question(i) (j),
                                     NULL,
                                     i_clinical_question_notes(i) (j),
                                     pk_blood_products_constant.g_bp_cq_on_order,
                                     i_id_episode,
                                     i_prof.id,
                                     g_sysdate_tstz);
                            END IF;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        
            l_id_rehab_session_type := NULL;
            l_sessions              := NULL;
            l_frequency             := NULL;
            l_flg_frequency         := NULL;
            l_flg_priority          := NULL;
            l_date_begin            := NULL;
        END LOOP;
    
        -- verificar se nas necessidades de agendamentos modificadas (inseridas ou adicionados tratamentos)
        -- se existe só um único tipo de sessão, caso contrário cria outra igual.
        IF NOT check_sch_need_session_type(i_lang       => i_lang,
                                           i_prof       => i_prof,
                                           i_sch_needs  => l_rsn_updated,
                                           o_new_rowids => l_tmp_rows,
                                           o_error      => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 't_data_gov_mnt.process_insert REHAB_SCH_NEED';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SCH_NEED',
                                      i_rowids     => l_rowids_rsn,
                                      o_error      => o_error);
    
        g_error := 't_data_gov_mnt.process_insert REHAB_PRESC';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC',
                                      i_rowids     => l_rowids_rp,
                                      o_error      => o_error);
    
        g_error := 'CALL TO PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_id_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => pk_prof_utils.get_category(i_lang, i_prof),
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        l_id_department := pk_complaint.get_id_department(i_lang, i_prof, i_id_episode) (1);
    
        FOR i IN 1 .. i_id_rehab_area_interv.count
        LOOP
            IF NOT manage_most_frequent_rehab(i_lang                 => i_lang,
                                              i_prof                 => i_prof,
                                              i_id_rehab_area_interv => i_id_rehab_area_interv(i),
                                              o_error                => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            IF NOT manage_most_frequent_rehab_dept(i_lang                 => i_lang,
                                                   i_prof                 => i_prof,
                                                   i_id_rehab_area_interv => i_id_rehab_area_interv(i),
                                                   i_dept                 => l_id_department,
                                                   o_error                => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END create_rehab_presc_internal;

    -- list of reasons when a patient miss a session
    FUNCTION get_reasons_miss_session
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        o_reasons OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REASONS_MISS_SESSION';
    
    BEGIN
        pk_alertlog.log_debug('Begin', g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'o_reasons';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_reasons FOR
            SELECT sd.desc_val AS label,
                   NULL AS data,
                   CASE rownum
                       WHEN 1 THEN
                        'Y'
                       ELSE
                        'N'
                   END AS flg_default
              FROM sys_domain sd
             WHERE sd.code_domain = g_rehab_schedule_flg_status
               AND sd.domain_owner = pk_sysdomain.k_default_schema
               AND sd.val IN (g_rehab_schedule_justified, g_rehab_schedule_injustified)
               AND sd.id_language = i_lang
             ORDER BY sd.desc_val;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_reasons);
            RETURN FALSE;
    END get_reasons_miss_session;

    -- list of reasons possible to cancel a treatment
    FUNCTION get_reasons_cancel_treat
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        o_reasons OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REASONS_CANCEL_TREAT';
    
    BEGIN
        pk_alertlog.log_debug('Begin', g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        IF NOT pk_cancel_reason.get_cancel_reason_list(i_lang, i_prof, 'REHAB', o_reasons, o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_reasons);
            RETURN FALSE;
    END get_reasons_cancel_treat;

    /**********************************************************************************************
    * Cancels a rehab_schedule
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_schedule      rehab schedule
    * %param i_id_cancel_reason       id cancel reason
    * %param i_notes                  cancel notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION cancel_rehab_schedule
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_schedule IN rehab_schedule.id_rehab_schedule%TYPE,
        i_id_cancel_reason  IN rehab_schedule.id_cancel_reason%TYPE,
        i_notes             IN rehab_schedule.notes%TYPE DEFAULT NULL,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'UPDATE_REHAB_SCHEDULE';
        l_rowids table_varchar;
    
    BEGIN
        g_error        := 'begin';
        g_sysdate_tstz := systimestamp;
    
        g_error := 'UPDATE STATUS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_schedule.upd(id_rehab_schedule_in => i_id_rehab_schedule,
                              flg_status_in        => g_rehab_schedule_cancel,
                              notes_in             => i_notes,
                              dt_cancel_in         => g_sysdate_tstz,
                              id_cancel_reason_in  => i_id_cancel_reason,
                              id_cancel_prof_in    => i_prof.id,
                              rows_out             => l_rowids);
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SCHEDULE',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_schedule=' || i_id_rehab_schedule || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END cancel_rehab_schedule;

    /**********************************************************************************************
    * Marks a rehab_schedule as missed
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_schedule      schedule to mark as missed
    * %param i_id_missed_reason       reason
    * %param i_notes                  notes entered
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION missed_rehab_schedule
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_schedule IN rehab_schedule.id_rehab_schedule%TYPE,
        i_id_missed_reason  IN rehab_schedule.flg_status%TYPE,
        i_notes             IN rehab_schedule.notes%TYPE DEFAULT NULL,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'UPDATE_REHAB_SCHEDULE';
        l_rowids table_varchar;
    
    BEGIN
        g_error        := 'begin';
        g_sysdate_tstz := systimestamp;
    
        g_error := 'UPDATE STATUS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_schedule.upd(id_rehab_schedule_in => i_id_rehab_schedule,
                              flg_status_in        => i_id_missed_reason,
                              id_cancel_reason_in  => i_id_missed_reason,
                              notes_in             => i_notes,
                              dt_cancel_in         => g_sysdate_tstz,
                              id_cancel_prof_in    => i_prof.id,
                              rows_out             => l_rowids);
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SCHEDULE',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_schedule=' || i_id_rehab_schedule || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END missed_rehab_schedule;

    /**********************************************************************************************
    * Adds notes to a treatment plan
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_episode             episode
    * %param i_id_patient             patient
    * %param i_notes                  notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION set_treatment_plan_notes
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN rehab_notes.id_episode%TYPE,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        i_notes      IN rehab_notes.notes%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_TREATMENT_PLAN_NOTES';
        l_id_episode_origin rehab_plan.id_episode_origin%TYPE;
        l_id_rehab_notes    NUMBER;
        l_rowids            table_varchar;
        l_id_schedule       rehab_schedule.id_schedule%TYPE;
        l_id_epis_type      episode.id_epis_type%TYPE;
    
    BEGIN
        g_error        := 'begin';
        g_sysdate_tstz := systimestamp;
    
        g_error := 'Before get_origin_episode';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        -- precisa-se do episódio de origem
        IF NOT get_origin_episode(i_lang              => i_lang,
                                  i_prof              => i_prof,
                                  i_id_episode        => i_id_episode,
                                  i_id_schedule       => NULL,
                                  o_id_episode_origin => l_id_episode_origin,
                                  o_id_schedule       => l_id_schedule,
                                  o_id_epis_type      => l_id_epis_type,
                                  o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'Before get_rehab_plan';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        -- verifica se este episódio já existe na rehab_plan, caso não exista cria
        IF NOT check_rehab_plan(i_lang              => i_lang,
                                i_prof              => i_prof,
                                i_id_patient        => i_id_patient,
                                i_id_episode_origin => l_id_episode_origin,
                                i_commit            => pk_alert_constant.get_no(),
                                o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'insert notes for id_episode_origin=' || l_id_episode_origin;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        l_id_rehab_notes := ts_rehab_notes.next_key();
        ts_rehab_notes.ins(id_rehab_notes_in    => l_id_rehab_notes,
                           id_episode_in        => i_id_episode,
                           id_episode_origin_in => l_id_episode_origin,
                           id_professional_in   => i_prof.id,
                           dt_rehab_notes_in    => g_sysdate_tstz,
                           notes_in             => i_notes,
                           rows_out             => l_rowids);
    
        g_error := 't_data_gov_mnt.process_insert REHAB_NOTES';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_NOTES',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        COMMIT;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_episode=' || i_id_episode || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_treatment_plan_notes;

    /**********************************************************************************************
    * executa um tratamento com ou sem prescrição
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient
    * %param i_id_rehab_presc         prescription
    * %param i_id_episode             episode
    * %param i_id_rehab_area_interv   intervention
    * %param i_id_rehab_session_type  session type
    * %param i_id_exec_prof           professional that executed
    * %param i_dt_begin               begin date
    * %param i_dt_end                 end date
    * %param i_duration               duration
    * %param i_notes                  notes
    * %param o_id_rehab_session       the execution id created
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION create_rehab_session
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_patient            IN rehab_plan.id_patient%TYPE,
        i_id_rehab_presc        IN table_number,
        i_id_episode            IN rehab_session.id_episode%TYPE,
        i_id_rehab_area_interv  IN table_number,
        i_id_rehab_session_type IN table_varchar,
        i_id_exec_prof          IN rehab_session.id_professional%TYPE,
        i_dt_begin              IN VARCHAR2,
        i_dt_end                IN VARCHAR2,
        i_duration              IN NUMBER,
        i_notes                 IN VARCHAR2,
        o_id_rehab_session      OUT table_number,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CREATE_REHAB_SESSION';
        l_id_rehab_sch_need rehab_sch_need.id_rehab_sch_need%TYPE;
        l_id_rehab_presc    rehab_session.id_rehab_presc%TYPE;
        l_id_rehab_session  rehab_session.id_rehab_session%TYPE;
        l_id_episode_origin rehab_plan.id_episode_origin%TYPE;
        l_id_schedule       rehab_schedule.id_schedule%TYPE;
        l_rowids            table_varchar;
        l_rowids_rsn        table_varchar;
        l_rowids_rp         table_varchar;
        l_rowids_rs         table_varchar;
        l_id_epis_type      episode.id_epis_type%TYPE;
        l_flg_status        rehab_presc.flg_status%TYPE;
        l_id_rehab_sessions table_number := table_number();
        l_count_sessions    NUMBER;
        l_count             NUMBER;
    
    BEGIN
        g_error        := 'begin';
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'count i_id_rehab_presc';
        pk_alertlog.log_debug('count i_id_rehab_presc=' || i_id_rehab_presc.count(), g_package_name, l_func_name);
    
        FOR i IN 1 .. i_id_rehab_presc.count()
        LOOP
            g_error := 'if i_id_rehab_presc';
            pk_alertlog.log_debug('i_id_rehab_presc=' || i_id_rehab_presc(i), g_package_name, l_func_name);
        
            IF i_id_rehab_presc(i) IS NULL
            THEN
            
                IF i_id_rehab_session_type(i) IS NOT NULL
                THEN
                    g_error := 'Before get_origin_episode';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                
                    -- precisa-se do episódio de origem
                    IF NOT get_origin_episode(i_lang              => i_lang,
                                              i_prof              => i_prof,
                                              i_id_episode        => i_id_episode,
                                              i_id_schedule       => NULL,
                                              o_id_episode_origin => l_id_episode_origin,
                                              o_id_schedule       => l_id_schedule,
                                              o_id_epis_type      => l_id_epis_type,
                                              o_error             => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    g_error := 'check_rehab_plan';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                
                    IF NOT check_rehab_plan(i_lang              => i_lang,
                                            i_prof              => i_prof,
                                            i_id_patient        => i_id_patient,
                                            i_id_episode_origin => l_id_episode_origin,
                                            i_commit            => pk_alert_constant.get_no(),
                                            o_error             => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    g_error := 'insert rehab_sch_need';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                
                    --create dummy sch_need for treatments without instructions
                    l_id_rehab_sch_need := ts_rehab_sch_need.next_key();
                    ts_rehab_sch_need.ins(id_rehab_sch_need_in     => l_id_rehab_sch_need,
                                          dt_rehab_sch_need_in     => g_sysdate_tstz,
                                          id_professional_in       => i_prof.id,
                                          id_rehab_session_type_in => i_id_rehab_session_type(i),
                                          sessions_in              => 1,
                                          flg_status_in            => g_rehab_sch_need_dummy,
                                          id_episode_origin_in     => l_id_episode_origin,
                                          rows_out                 => l_rowids);
                
                    l_rowids_rsn := l_rowids_rsn MULTISET UNION l_rowids;
                END IF;
            
                g_error := 'insert rehab_presc';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                -- não tem requesição. cria-se uma fechada
                l_id_rehab_presc := ts_rehab_presc.next_key;
                ts_rehab_presc.ins(id_rehab_presc_in       => l_id_rehab_presc,
                                   dt_rehab_presc_in       => g_sysdate_tstz,
                                   id_rehab_area_interv_in => i_id_rehab_area_interv(i),
                                   id_professional_in      => i_prof.id,
                                   id_institution_in       => i_prof.institution,
                                   id_rehab_sch_need_in    => l_id_rehab_sch_need,
                                   id_exec_institution_in  => i_prof.institution,
                                   exec_per_session_in     => 1,
                                   notes_in                => NULL,
                                   flg_status_in           => g_rehab_presc_finished,
                                   rows_out                => l_rowids);
            
                l_rowids_rp := l_rowids_rp MULTISET UNION l_rowids;
            
                g_error := 'set_rehab_presc_hist for id_rehab_presc=' || l_id_rehab_presc;
                IF NOT set_rehab_presc_hist(i_lang => i_lang,
                                            
                                            i_prof           => i_prof,
                                            i_id_rehab_presc => l_id_rehab_presc,
                                            i_commit         => pk_alert_constant.get_no(),
                                            o_error          => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
            ELSE
                -- tem requesição
                l_id_rehab_presc := i_id_rehab_presc(i);
            
            END IF;
        
            g_error := '';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            -- colocar em ongoing o rehab_presc se estiver em begin
            SELECT flg_status
              INTO l_flg_status
              FROM rehab_presc rp
             WHERE rp.id_rehab_presc = l_id_rehab_presc;
        
            IF l_flg_status = g_rehab_presc_begin
            THEN
                ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                   flg_status_in     => g_rehab_presc_ongoing,
                                   rows_out          => l_rowids);
            
                l_rowids_rp := l_rowids_rp MULTISET UNION l_rowids;
            
                g_error := 'set_rehab_presc_hist for id_rehab_presc=' || l_id_rehab_presc;
                IF NOT set_rehab_presc_hist(i_lang => i_lang,
                                            
                                            i_prof           => i_prof,
                                            i_id_rehab_presc => l_id_rehab_presc,
                                            i_commit         => pk_alert_constant.get_no(),
                                            o_error          => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
            END IF;
        
            g_error := 'insert rehab_session';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            l_id_rehab_session := ts_rehab_session.next_key();
            ts_rehab_session.ins(id_rehab_session_in     => l_id_rehab_session,
                                 dt_rehab_session_in     => g_sysdate_tstz,
                                 id_rehab_presc_in       => l_id_rehab_presc,
                                 id_professional_in      => i_prof.id,
                                 id_episode_in           => i_id_episode,
                                 flg_status_in           => g_rehab_session_executed,
                                 id_exec_professional_in => i_id_exec_prof,
                                 dt_begin_in             => nvl(pk_date_utils.get_string_tstz(i_lang,
                                                                                              i_prof,
                                                                                              i_dt_begin,
                                                                                              NULL),
                                                                g_sysdate_tstz),
                                 dt_end_in               => nvl(pk_date_utils.get_string_tstz(i_lang,
                                                                                              i_prof,
                                                                                              i_dt_end,
                                                                                              NULL),
                                                                NULL),
                                 duration_in             => i_duration,
                                 notes_in                => i_notes,
                                 rows_out                => l_rowids,
                                 handle_error_in         => FALSE);
        
            l_id_rehab_sessions.extend();
            l_id_rehab_sessions(l_id_rehab_sessions.last) := l_id_rehab_session;
            l_rowids_rs := l_rowids_rs MULTISET UNION l_rowids;
        
        END LOOP;
    
        g_error := 'insert rehab_session_hist';
    
        --Send new records to history table
        IF NOT set_rehab_session_hist(i_lang                  => i_lang,
                                      i_prof                  => i_prof,
                                      i_id_rehab_session      => l_id_rehab_sessions,
                                      i_dt_rehab_session_hist => g_sysdate_tstz,
                                      o_error                 => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        -- se já foram executadas todas as sessões colocar o tratamento como finalizado    
        g_error := 'get count sessions';
        SELECT sessions
          INTO l_count_sessions
          FROM rehab_sch_need rsn
          JOIN rehab_presc rp
            ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
         WHERE rp.id_rehab_presc = l_id_rehab_presc;
    
        g_error := 'get count executions';
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_session rs
         WHERE rs.id_rehab_presc = l_id_rehab_presc
           AND rs.flg_status != g_rehab_session_canceled;
    
        IF l_count >= l_count_sessions
        THEN
            g_error := 'update rehab_presc to finished';
            ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                               flg_status_in     => g_rehab_presc_finished,
                               rows_out          => l_rowids);
        
            l_rowids_rp := l_rowids_rp MULTISET UNION l_rowids;
        END IF;
    
        -- process all the data gov events
        g_error := 't_data_gov_mnt.process_insert REHAB_SCH_NEED';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SCH_NEED',
                                      i_rowids     => l_rowids_rp,
                                      o_error      => o_error);
    
        g_error := 't_data_gov_mnt.process_insert REHAB_PRESC';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC',
                                      i_rowids     => l_rowids_rp,
                                      o_error      => o_error);
    
        g_error := 't_data_gov_mnt.process_insert REHAB_SESSION';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SESSION',
                                      i_rowids     => l_rowids_rs,
                                      o_error      => o_error);
    
        o_id_rehab_session := l_id_rehab_sessions;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alertlog.log_error('Parameters: i_id_rehab_presc=' || pk_utils.concat_table(i_id_rehab_presc) ||
                                  '; i_id_rehab_area_interv=' || pk_utils.concat_table(i_id_rehab_area_interv) || ' @' ||
                                  g_error,
                                  g_package_name,
                                  l_func_name);
        
            RETURN FALSE;
    END create_rehab_session;

    /**
    * Edits the execution data of treatment session
    *
    * @param   i_lang              Professional preferred language
    * @param   i_prof              Professional identification and its context (institution and software)
    * @param   i_id_rehab_session  List of executions to edit        
    * @param   i_id_episode        Episode ID
    * @param   i_id_exec_prof      Profissional ID who execute the session
    * @param   i_dt_begin          Begin date
    * @param   i_dt_end            End dete
    * @param   i_duration          Elapsed time
    * @param   i_notes             Notes
    *
    * @param   o_error        Error information
    *
    * @return  True or False on success or error
    *
    * @author  ARIEL.MACHADO
    * @version 2.6.0.3
    * @since   26-Jul-10
    */
    FUNCTION set_rehab_session
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_rehab_session IN table_number,
        i_id_episode       IN rehab_session.id_episode%TYPE,
        i_id_exec_prof     IN rehab_session.id_professional%TYPE,
        i_dt_begin         IN VARCHAR2,
        i_dt_end           IN VARCHAR2,
        i_duration         IN NUMBER,
        i_notes            IN VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_SESSION';
        e_function_call_error EXCEPTION;
    
        l_sysdate_tstz TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_begin     rehab_session.dt_begin%TYPE;
        l_dt_end       rehab_session.dt_end%TYPE;
        l_rowids       table_varchar;
    BEGIN
        l_sysdate_tstz := current_timestamp;
        l_dt_begin     := nvl(pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_begin, NULL), l_sysdate_tstz);
        l_dt_end       := nvl(pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_end, NULL), l_sysdate_tstz);
    
        g_error := 'Updating session executions through calls to ts_rehab_session.upd';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        FOR idx IN 1 .. i_id_rehab_session.count
        LOOP
            ts_rehab_session.upd(id_rehab_session_in     => i_id_rehab_session(idx),
                                 dt_rehab_session_in     => l_sysdate_tstz,
                                 id_professional_in      => i_prof.id,
                                 id_exec_professional_in => i_id_exec_prof,
                                 dt_begin_in             => l_dt_begin,
                                 dt_end_in               => l_dt_end,
                                 duration_in             => i_duration,
                                 notes_in                => i_notes,
                                 rows_out                => l_rowids);
        
        END LOOP;
    
        g_error := 'Processing updated records in REHAB_SESSION throught t_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SESSION',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        g_error := 'Sending updated records to history table throught set_rehab_session_hist';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        IF NOT set_rehab_session_hist(i_lang                  => i_lang,
                                      i_prof                  => i_prof,
                                      i_id_rehab_session      => i_id_rehab_session,
                                      i_dt_rehab_session_hist => l_sysdate_tstz,
                                      o_error                 => o_error)
        THEN
            RAISE e_function_call_error;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_function_call_error THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => o_error.ora_sqlcode,
                                              i_sqlerrm  => o_error.ora_sqlerrm,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_rehab_session;

    /**
    * Copies executions of treatment in a session to history table
    *
    * @param   i_lang              Professional preferred language
    * @param   i_prof              Professional identification and its context (institution and software)
    * @param   i_id_rehab_session  List of rehab sessions to send to history
    *
    * @param   o_error             Error information
    *
    * @return  True or False on success or error
    *
    * @author  ARIEL.MACHADO
    * @version 2.6.0.3
    * @since   24-Jul-10
    */
    FUNCTION set_rehab_session_hist
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_rehab_session      IN table_number,
        i_dt_rehab_session_hist IN rehab_session_hist.dt_rehab_session_hist%TYPE DEFAULT NULL,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_SESSION_HIST';
        l_data         ts_rehab_session_hist.rehab_session_hist_tc;
        l_rowids_rsh   table_varchar;
        l_sysdate_tstz TIMESTAMP WITH LOCAL TIME ZONE;
    BEGIN
        g_error        := 'begin';
        l_sysdate_tstz := nvl(i_dt_rehab_session_hist, current_timestamp);
    
        g_error := 'select rehab_session';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        SELECT ts_rehab_session_hist.next_key() id_rehab_session_hist,
               l_sysdate_tstz dt_rehab_session_hist,
               i_prof.id id_professional_hist,
               id_rehab_session,
               dt_rehab_session,
               id_rehab_presc,
               id_professional,
               id_episode,
               flg_status,
               id_exec_professional,
               dt_begin,
               dt_end,
               duration,
               notes,
               id_cancel_reason,
               dt_cancel,
               id_cancel_professional,
               notes_cancel,
               NULL create_user,
               NULL create_time,
               NULL create_institution,
               NULL update_user,
               NULL update_time,
               NULL update_institution
          BULK COLLECT
          INTO l_data
          FROM rehab_session rs
         WHERE rs.id_rehab_session IN (SELECT /*+opt_estimate(table t rows=1)*/
                                        column_value
                                         FROM TABLE(i_id_rehab_session) t);
    
        g_error := 'Insert history records';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_session_hist.ins(rows_in => l_data, rows_out => l_rowids_rsh);
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SESSION_HIST',
                                      i_rowids     => l_rowids_rsh,
                                      o_error      => o_error);
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_rehab_session_hist;

    /**
    * Returns the detail of executions in a treatment session
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_id_rehab_presc     Prescribed treatment ID
    * @param   o_rehab_session_rec  Cursor with record info
    * @param   o_rehab_session_val  Cursor with session's executions info
    *
    * @param   o_error              Error information
    *
    * @return  True or False on success or error
    *
    * @author  ARIEL.MACHADO
    * @version 2.6.0.3
    * @since   27-Jul-10
    */
    FUNCTION get_rehab_session_detail
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_rehab_presc       IN rehab_session.id_rehab_presc%TYPE,
        o_rehab_session_detail OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_function_name CONSTANT VARCHAR2(30) := 'GET_REHAB_SESSION_DETAIL';
    
        TYPE t_code_messages IS TABLE OF sys_message.desc_message%TYPE INDEX BY sys_message.code_message%TYPE;
    
        aa_code_messages t_code_messages;
        va_code_messages table_varchar := table_varchar('REHAB_M012', --'Status:'
                                                        'REHAB_M018', --'Executed by:'
                                                        'REHAB_M019', --'Begin:',
                                                        'REHAB_M020', --'Duration:',
                                                        'REHAB_M021', --'End:',
                                                        'REHAB_M011', --'Notes:'
                                                        'REHAB_M016', --'Cancel reason:',
                                                        'REHAB_M015', --'Cancel notes:',
                                                        'REHAB_M017', --'Editado',
                                                        'REHAB_M022' --'Execução:',
                                                        );
    
        l_hour_fmt sys_config.value%TYPE;
    
    BEGIN
        -- get all messages
        g_error := 'GET MESSAGES';
        FOR i IN va_code_messages.first .. va_code_messages.last
        LOOP
            aa_code_messages(va_code_messages(i)) := pk_message.get_message(i_lang, va_code_messages(i));
        END LOOP;
    
        l_hour_fmt := nvl(pk_sysconfig.get_config('HOUR_FORMAT', i_prof.institution, i_prof.software), 'hh24:mi');
    
        g_error := 'OPEN o_rehab_session_detail';
        OPEN o_rehab_session_detail FOR
            SELECT table_varchar(aa_code_messages('REHAB_M022'),
                                 (SELECT COUNT(*)
                                    FROM rehab_session rs
                                   WHERE rs.id_rehab_presc = a.id_rehab_presc
                                     AND rs.id_rehab_session <= a.id_rehab_session)) nr_exec_desc,
                   table_varchar(aa_code_messages('REHAB_M018'),
                                 decode(lag(exec_prof_name) over(PARTITION BY id_rehab_session ORDER BY rank_status DESC,
                                             dt_orderby,
                                             dt_rehab_session_hist,
                                             flg_history DESC),
                                        exec_prof_name,
                                        NULL,
                                        exec_prof_name)) lbl_exec_prof,
                   table_varchar(aa_code_messages('REHAB_M019'),
                                 decode(lag(date_begin_str) over(PARTITION BY id_rehab_session ORDER BY rank_status DESC,
                                             dt_orderby,
                                             dt_rehab_session_hist,
                                             flg_history DESC),
                                        date_begin_str,
                                        NULL,
                                        date_begin_str)) lbl_date_begin,
                   table_varchar(aa_code_messages('REHAB_M020'),
                                 decode(lag(duration) over(PARTITION BY id_rehab_session ORDER BY rank_status DESC,
                                             dt_orderby,
                                             dt_rehab_session_hist,
                                             flg_history DESC),
                                        duration,
                                        NULL,
                                        duration)) lbl_duration,
                   table_varchar(aa_code_messages('REHAB_M021'),
                                 decode(lag(date_end_str) over(PARTITION BY id_rehab_session ORDER BY rank_status DESC,
                                             dt_orderby,
                                             dt_rehab_session_hist,
                                             flg_history DESC),
                                        date_end_str,
                                        NULL,
                                        date_end_str)) lbl_date_end,
                   table_varchar(aa_code_messages('REHAB_M011'),
                                 decode(lag(notes) over(PARTITION BY id_rehab_session ORDER BY rank_status DESC,
                                             dt_orderby,
                                             dt_rehab_session_hist,
                                             flg_history DESC),
                                        notes,
                                        NULL,
                                        notes)) lbl_notes,
                   table_varchar(aa_code_messages('REHAB_M016'),
                                 decode(lag(cancel_reason) over(PARTITION BY id_rehab_session ORDER BY rank_status DESC,
                                             dt_orderby,
                                             dt_rehab_session_hist,
                                             flg_history DESC),
                                        cancel_reason,
                                        NULL,
                                        cancel_reason)) lbl_cancel_reason,
                   table_varchar(aa_code_messages('REHAB_M015'),
                                 decode(lag(cancel_notes) over(PARTITION BY id_rehab_session ORDER BY rank_status DESC,
                                             dt_orderby,
                                             dt_rehab_session_hist,
                                             flg_history DESC),
                                        cancel_notes,
                                        NULL,
                                        cancel_notes)) lbl_cancel_notes,
                   id_rehab_session,
                   id_rehab_session_hist id,
                   flg_history
              FROM (SELECT dt_last_update,
                           prof_last_update,
                           prof_spec_signature,
                           desc_status,
                           id_rehab_session,
                           flg_status,
                           dt_orderby,
                           exec_prof_name,
                           date_begin_str,
                           duration,
                           date_end_str,
                           notes,
                           cancel_reason,
                           cancel_notes,
                           flg_history,
                           dt_rehab_session_hist,
                           1 AS rank_status,
                           id_rehab_presc,
                           id_rehab_session_hist
                      FROM (SELECT pk_date_utils.date_char_tsz(i_lang,
                                                               rsh.dt_rehab_session_hist,
                                                               i_prof.institution,
                                                               i_prof.software) dt_last_update,
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, rsh.id_professional_hist) prof_last_update,
                                   pk_string_utils.surround(pk_prof_utils.get_spec_signature(i_lang,
                                                                                             i_prof,
                                                                                             rsh.id_professional_hist,
                                                                                             rsh.dt_rehab_session_hist,
                                                                                             rsh.id_episode),
                                                            pk_string_utils.g_pattern_parenthesis) prof_spec_signature,
                                   --Status:
                                   pk_sysdomain.get_domain('REHAB_SESSION.FLG_STATUS', rsh.flg_status, i_lang) desc_status,
                                   --Executed by:
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, rsh.id_exec_professional) exec_prof_name,
                                   --Begin:
                                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, rsh.dt_begin, i_prof) date_begin_str,
                                   --Duration:
                                   --rsh.duration duration,
                                   to_char(to_date(lpad(trunc(rsh.duration * 60), 5, 0), 'sssss'), l_hour_fmt) duration,
                                   --End:
                                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, rsh.dt_end, i_prof) date_end_str,
                                   --Notes:
                                   rsh.notes notes,
                                   --'Cancel reason:',
                                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, rsh.id_cancel_reason) cancel_reason,
                                   -- 'Cancel notes:',
                                   rsh.notes_cancel cancel_notes,
                                   rsh.id_rehab_session,
                                   rsh.flg_status,
                                   MAX(rsh.dt_rehab_session_hist) over(PARTITION BY rsh.id_rehab_session ORDER BY rsh.dt_rehab_session_hist DESC) dt_orderby,
                                   rsh.dt_rehab_session_hist,
                                   decode((rank()
                                           over(PARTITION BY rsh.id_rehab_session ORDER BY rsh.dt_rehab_session_hist DESC)),
                                          1,
                                          pk_alert_constant.g_no,
                                          pk_alert_constant.g_yes) flg_history,
                                   id_rehab_presc,
                                   id_rehab_session_hist
                              FROM rehab_session_hist rsh
                             WHERE rsh.id_rehab_presc = i_id_rehab_presc)) a
             ORDER BY dt_last_update DESC, id_rehab_session DESC, dt_rehab_session_hist DESC, flg_history;
    
        RETURN TRUE;
    EXCEPTION
        WHEN no_data_found THEN
            pk_types.open_my_cursor(o_rehab_session_detail);
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_function_name,
                                              o_error);
            pk_types.open_my_cursor(o_rehab_session_detail);
            RETURN FALSE;
    END get_rehab_session_detail;

    /**********************************************************************************************
    * Cancels a rehab_session
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_session       execution to cancel
    * %param i_id_cancel_reason       cancel reason
    * %param i_notes                  notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION cancel_rehab_session
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_rehab_session IN table_number,
        i_id_cancel_reason IN rehab_session.id_cancel_reason%TYPE,
        i_notes            IN rehab_session.notes_cancel%TYPE DEFAULT NULL,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_REHAB_SESSION';
        l_rowids             table_varchar;
        l_rowids_rs          table_varchar;
        l_count              NUMBER;
        l_count_sessions     NUMBER;
        l_id_rehab_presc     rehab_presc.id_rehab_presc%TYPE;
        l_tbl_id_rehab_presc table_number := table_number();
    
    BEGIN
        g_error        := 'begin cancel_rehab_session';
        g_sysdate_tstz := current_timestamp;
    
        FOR i IN 1 .. i_id_rehab_session.count
        LOOP
            g_error := 'UPDATE STATUS';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            ts_rehab_session.upd(id_rehab_session_in       => i_id_rehab_session(i),
                                 flg_status_in             => g_rehab_session_canceled,
                                 notes_cancel_in           => i_notes,
                                 dt_cancel_in              => g_sysdate_tstz,
                                 id_cancel_reason_in       => i_id_cancel_reason,
                                 id_cancel_professional_in => i_prof.id,
                                 rows_out                  => l_rowids);
        
            l_rowids_rs := l_rowids_rs MULTISET UNION l_rowids;
        
            g_error := 'get id of prescription without schedule i_id_rehab_session=' || i_id_rehab_session(i);
        
            -- se for uma execução de um tratamento não prescrito cancelar a requisição
            BEGIN
                SELECT COUNT(*), rp.id_rehab_presc
                  INTO l_count, l_id_rehab_presc
                  FROM rehab_session rs
                  JOIN rehab_presc rp
                    ON rp.id_rehab_presc = rs.id_rehab_presc
                  JOIN rehab_sch_need rsn
                    ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                 WHERE rs.id_rehab_session = i_id_rehab_session(i)
                   AND rsn.flg_status = g_rehab_sch_need_dummy
                 GROUP BY rp.id_rehab_presc;
            
                g_error := 'cancel_rehab_presc_nocommit';
                IF NOT cancel_rehab_presc_nocommit(i_lang             => i_lang,
                                                   i_prof             => i_prof,
                                                   i_id_rehab_presc   => l_id_rehab_presc,
                                                   i_id_cancel_reason => i_id_cancel_reason,
                                                   i_notes            => i_notes,
                                                   o_error            => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
            EXCEPTION
                WHEN no_data_found THEN
                    NULL;
            END;
        END LOOP;
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SESSION',
                                      i_rowids     => l_rowids_rs,
                                      o_error      => o_error);
    
        g_error := 'set_rehab_session_hist';
    
        --Send changed records to history table
        IF NOT set_rehab_session_hist(i_lang                  => i_lang,
                                      i_prof                  => i_prof,
                                      i_id_rehab_session      => i_id_rehab_session,
                                      i_dt_rehab_session_hist => g_sysdate_tstz,
                                      o_error                 => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'get all the treatments';
    
        SELECT DISTINCT id_rehab_presc
          BULK COLLECT
          INTO l_tbl_id_rehab_presc
          FROM rehab_session rs
         WHERE rs.id_rehab_session IN (SELECT /*+opt_estimate(table t rows=1)*/
                                        column_value
                                         FROM TABLE(i_id_rehab_session) t);
    
        g_error := 'loop all id_rehab_presc';
    
        FOR i IN 1 .. l_tbl_id_rehab_presc.count
        LOOP
        
            g_error := 'count executions of id_rehab_presc=' || l_tbl_id_rehab_presc(i);
        
            --if all the executions are cancelled put the treatment in begin status
            SELECT COUNT(*)
              INTO l_count
              FROM rehab_presc rp, rehab_session rs
             WHERE rp.id_rehab_presc = l_tbl_id_rehab_presc(i)
               AND rp.id_rehab_presc = rs.id_rehab_presc
               AND rs.flg_status != g_rehab_session_canceled;
        
            g_error := 'get sessions';
        
            SELECT sessions
              INTO l_count_sessions
              FROM rehab_sch_need rsn
              JOIN rehab_presc rp
                ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
             WHERE rp.id_rehab_presc = l_tbl_id_rehab_presc(i);
        
            IF l_count = 0
            THEN
                g_error := 'ts_rehab_presc.upd 1';
                ts_rehab_presc.upd(id_rehab_presc_in => l_tbl_id_rehab_presc(i),
                                   flg_status_in     => g_rehab_presc_begin,
                                   rows_out          => l_rowids);
            
                g_error := 't_data_gov_mnt.process_update rehab_presc 1';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'REHAB_PRESC',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            
            ELSIF l_count < l_count_sessions
            THEN
                g_error := 'ts_rehab_presc.upd 2';
                ts_rehab_presc.upd(id_rehab_presc_in => l_tbl_id_rehab_presc(i),
                                   flg_status_in     => g_rehab_presc_ongoing,
                                   rows_out          => l_rowids);
            
                g_error := 't_data_gov_mnt.process_update rehab_presc 2';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'REHAB_PRESC',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            
            END IF;
        END LOOP;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_session=' || pk_utils.concat_table(i_id_rehab_session) || ' @' ||
                                  g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END cancel_rehab_session;

    -- Copies a rehab_presc to history table
    -- private
    FUNCTION set_rehab_presc_hist
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_rehab_presc      IN rehab_presc.id_rehab_presc%TYPE,
        i_dt_rehab_presc_hist IN rehab_presc_hist.dt_rehab_presc_hist%TYPE DEFAULT NULL,
        i_commit              IN VARCHAR2 DEFAULT pk_alert_constant.get_yes(),
        i_id_rehab_presc_hist IN rehab_presc_hist.id_rehab_presc_hist%TYPE DEFAULT NULL,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_PRESC_HIST_NOCOMMIT';
        l_rehab_presc_row     rehab_presc%ROWTYPE;
        l_rowids              table_varchar;
        l_id_rehab_presc_hist rehab_presc_hist.id_rehab_presc_hist%TYPE;
    BEGIN
        g_error        := 'begin';
        g_sysdate_tstz := nvl(i_dt_rehab_presc_hist, systimestamp);
    
        g_error := 'select rehab_presc';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        SELECT *
          INTO l_rehab_presc_row
          FROM rehab_presc rp
         WHERE rp.id_rehab_presc = i_id_rehab_presc;
    
        g_error := 'insert rehab_presc_hist';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        ts_rehab_presc_hist.ins(id_rehab_presc_hist_in    => coalesce(i_id_rehab_presc_hist,
                                                                      ts_rehab_presc_hist.next_key()),
                                id_rehab_presc_in         => l_rehab_presc_row.id_rehab_presc,
                                id_rehab_area_interv_in   => l_rehab_presc_row.id_rehab_area_interv,
                                flg_status_in             => l_rehab_presc_row.flg_status,
                                id_rehab_sch_need_in      => l_rehab_presc_row.id_rehab_sch_need,
                                id_exec_institution_in    => l_rehab_presc_row.id_exec_institution,
                                exec_per_session_in       => l_rehab_presc_row.exec_per_session,
                                notes_in                  => l_rehab_presc_row.notes,
                                dt_rehab_presc_in         => l_rehab_presc_row.dt_rehab_presc,
                                id_professional_in        => l_rehab_presc_row.id_professional,
                                id_cancel_reason_in       => l_rehab_presc_row.id_cancel_reason,
                                notes_cancel_in           => l_rehab_presc_row.notes_cancel,
                                dt_cancel_in              => l_rehab_presc_row.dt_cancel,
                                id_cancel_professional_in => l_rehab_presc_row.id_cancel_professional,
                                dt_rehab_presc_hist_in    => g_sysdate_tstz,
                                id_professional_hist_in   => i_prof.id,
                                notes_change_in           => l_rehab_presc_row.notes_change,
                                flg_laterality_in         => l_rehab_presc_row.flg_laterality,
                                id_not_order_reason_in    => l_rehab_presc_row.id_not_order_reason,
                                flg_referral_in           => l_rehab_presc_row.flg_referral,
                                id_pat_health_plan_in     => l_rehab_presc_row.id_pat_health_plan,
                                id_pat_exemption_in       => l_rehab_presc_row.id_pat_exemption,
                                diagnosis_notes_in        => l_rehab_presc_row.diagnosis_notes,
                                id_clinical_purpose_in    => l_rehab_presc_row.id_clinical_purpose,
                                clinical_purpose_notes_in => l_rehab_presc_row.clinical_purpose_notes,
                                rows_out                  => l_rowids);
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC_HIST',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        IF nvl(i_commit, 'N') = 'Y'
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_presc=' || i_id_rehab_presc || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            IF nvl(i_commit, 'N') = 'Y'
            THEN
                pk_utils.undo_changes();
            END IF;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END set_rehab_presc_hist;

    /**********************************************************************************************
    * Cancels a rehab_presc without commit
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_presc         prescription
    * %param i_id_cancel_reason       cancel reason
    * %param i_notes                  notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION cancel_rehab_presc_nocommit
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_rehab_presc   IN rehab_presc.id_rehab_presc%TYPE,
        i_id_cancel_reason IN rehab_presc.id_cancel_reason%TYPE,
        i_notes            IN rehab_presc.notes_cancel%TYPE DEFAULT NULL,
        i_flg_discontinue  IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_auto_cancel  IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_dt_cancel        IN VARCHAR2 DEFAULT NULL,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_REHAB_PRESC_NOCOMMIT';
        l_rowids            table_varchar;
        l_count_sess        NUMBER;
        l_count_rp          NUMBER;
        l_id_schedule       table_number;
        l_id_rehab_sch_need rehab_presc.id_rehab_sch_need%TYPE;
        l_transaction_id    VARCHAR2(4000);
        l_func_exception EXCEPTION;
        l_id_cancel_reason sch_cancel_reason.id_sch_cancel_reason%TYPE := 28;
        l_flg_status       rehab_presc.flg_status%TYPE;
        l_dt_cancel        TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
        g_error        := 'begin cancel_rehab_presc_nocommit';
        g_sysdate_tstz := systimestamp;
    
        IF i_dt_cancel IS NOT NULL
        THEN
            l_dt_cancel := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_cancel, NULL);
        ELSE
            l_dt_cancel := g_sysdate_tstz;
        END IF;
    
        --só pode ser cancelado se não tiver execuções ou se todas as execuções estiverem canceladas
        SELECT COUNT(*)
          INTO l_count_sess
          FROM rehab_session rs
         WHERE rs.id_rehab_presc = i_id_rehab_presc
           AND rs.flg_status = g_rehab_session_executed;
    
        -- se for o único tratamento desta necessidade de agendamento
        -- cancela-se também a necessidade de agendamento
        SELECT COUNT(*)
          INTO l_count_rp
          FROM rehab_presc rp
         WHERE rp.id_rehab_sch_need = (SELECT id_rehab_sch_need
                                         FROM rehab_presc rp2
                                        WHERE rp2.id_rehab_presc = i_id_rehab_presc)
           AND rp.flg_status != pk_alert_constant.g_cancelled;
    
        SELECT rp.flg_status
          INTO l_flg_status
          FROM rehab_presc rp
         WHERE rp.id_rehab_presc = i_id_rehab_presc;
    
        IF l_flg_status = pk_rehab.g_rehab_presc_cancel
        THEN
            RETURN TRUE;
        END IF;
    
        --não se deixa cancelar
        IF l_count_sess = 0
           OR i_flg_auto_cancel = pk_alert_constant.g_yes
        THEN
        
            -- cancel rehab_presc
            g_error := 'update status in rehab_presc';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            ts_rehab_presc.upd(id_rehab_presc_in         => i_id_rehab_presc,
                               flg_status_in             => CASE
                                                                WHEN i_flg_discontinue = pk_alert_constant.g_no THEN
                                                                 g_rehab_presc_cancel
                                                                ELSE
                                                                 pk_rehab.g_rehab_presc_discontinued
                                                            END,
                               notes_cancel_in           => i_notes,
                               dt_cancel_in              => l_dt_cancel,
                               id_cancel_reason_in       => i_id_cancel_reason,
                               id_cancel_professional_in => i_prof.id,
                               rows_out                  => l_rowids);
        
            g_error := 't_data_gov_mnt.process_update';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_PRESC',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
            --insert in rehab_presc_hist
            g_error := 'insert in rehab_presc_hist';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            IF NOT set_rehab_presc_hist(i_lang           => i_lang,
                                        i_prof           => i_prof,
                                        i_id_rehab_presc => i_id_rehab_presc,
                                        i_commit         => pk_alert_constant.get_no(),
                                        o_error          => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'count rehab_presc=' || l_count_rp;
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            IF l_count_rp = 1
            THEN
                -- necessidade de agendamento vazia
                g_error := 'get id_rehab_sch_need';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                SELECT id_rehab_sch_need
                  INTO l_id_rehab_sch_need
                  FROM rehab_presc rp
                 WHERE rp.id_rehab_presc = i_id_rehab_presc;
            
                g_error := 'cancel id_rehab_sch_need';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                IF NOT cancel_rehab_sch_need_nocommit(i_lang              => i_lang,
                                                      i_prof              => i_prof,
                                                      i_id_rehab_sch_need => l_id_rehab_sch_need,
                                                      i_id_cancel_reason  => i_id_cancel_reason,
                                                      i_notes             => i_notes,
                                                      o_error             => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            -- valida se tem agendamentos, se sim, cancela-os todos
            SELECT rs.id_schedule
              BULK COLLECT
              INTO l_id_schedule
              FROM rehab_schedule rs
             WHERE rs.id_rehab_sch_need = (SELECT id_rehab_sch_need
                                             FROM rehab_presc rp2
                                            WHERE rp2.id_rehab_presc = i_id_rehab_presc)
               AND rs.flg_status != g_rehab_presc_cancel;
        
            g_error := 'count rehab_schedule=' || l_id_schedule.count;
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            IF l_id_schedule.count > 0
            THEN
                FOR i IN 1 .. l_id_schedule.count
                LOOP
                    -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
                    g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                    l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(NULL, i_prof);
                
                    IF NOT pk_schedule_api_upstream.cancel_schedule(i_lang             => i_lang,
                                                                    i_prof             => i_prof,
                                                                    i_id_schedule      => l_id_schedule(i),
                                                                    i_id_cancel_reason => l_id_cancel_reason,
                                                                    i_cancel_notes     => NULL,
                                                                    i_transaction_id   => l_transaction_id,
                                                                    o_error            => o_error)
                    THEN
                        RAISE l_func_exception;
                    END IF;
                
                    IF l_transaction_id IS NOT NULL
                    THEN
                        pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
                    END IF;
                
                END LOOP;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_func_exception THEN
            pk_utils.undo_changes;
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_presc=' || i_id_rehab_presc || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END cancel_rehab_presc_nocommit;

    /**********************************************************************************************
    * Cancels a rehab_presc
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_presc         prescription
    * %param i_id_cancel_reason       cancel reason
    * %param i_notes                  notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION cancel_rehab_presc
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_rehab_presc   IN table_number,
        i_id_cancel_reason IN rehab_presc.id_cancel_reason%TYPE,
        i_notes            IN rehab_presc.notes_cancel%TYPE DEFAULT NULL,
        i_flg_discontinue  IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_auto_cancel  IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_commit       IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_REHAB_PRESC';
    
        l_flg_status rehab_presc.flg_status%TYPE;
    BEGIN
        g_error := 'begin';
    
        FOR i IN 1 .. i_id_rehab_presc.count
        LOOP
            g_error := 'Fetching flg_status for i_id_rehab_presc=' || i_id_rehab_presc(i);
            SELECT rp.flg_status
              INTO l_flg_status
              FROM rehab_presc rp
             WHERE rp.id_rehab_presc = i_id_rehab_presc(i);
        
            IF l_flg_status IN ('S', 'O')
            THEN
                IF NOT pk_rehab.update_rehab_presc_status(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          i_id_rehab_presc => table_number(i_id_rehab_presc(i)),
                                                          i_to_state       => 'E',
                                                          i_notes          => i_notes,
                                                          o_error          => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            ELSE
                g_error := 'cancel_rehab_presc_nocommit for i_id_rehab_presc=' || i_id_rehab_presc(i);
                IF NOT cancel_rehab_presc_nocommit(i_lang             => i_lang,
                                                   i_prof             => i_prof,
                                                   i_id_rehab_presc   => i_id_rehab_presc(i),
                                                   i_id_cancel_reason => i_id_cancel_reason,
                                                   i_notes            => i_notes,
                                                   i_flg_discontinue  => i_flg_discontinue,
                                                   i_flg_auto_cancel  => i_flg_auto_cancel,
                                                   o_error            => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        END LOOP;
    
        IF i_flg_commit = pk_alert_constant.g_yes
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END cancel_rehab_presc;

    -- Copies a rehab_sch_need to history table
    -- private
    FUNCTION set_rehab_sch_need_hist
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_id_rehab_sch_need      IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_dt_rehab_sch_need_hist IN rehab_sch_need_hist.dt_rehab_sch_need_hist%TYPE DEFAULT NULL,
        i_commit                 IN VARCHAR2 DEFAULT pk_alert_constant.get_yes(),
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_SCH_NEED_HIST_NOCOM';
        l_rehab_sch_need_row rehab_sch_need%ROWTYPE;
        l_rowids             table_varchar;
    BEGIN
        g_error        := 'begin';
        g_sysdate_tstz := nvl(i_dt_rehab_sch_need_hist, systimestamp);
    
        g_error := 'select rehab_presc';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        SELECT *
          INTO l_rehab_sch_need_row
          FROM rehab_sch_need rsn
         WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need;
    
        g_error := 'insert rehab_sch_need_hist';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        ts_rehab_sch_need_hist.ins(id_rehab_sch_need_hist_in => ts_rehab_sch_need_hist.next_key(),
                                   dt_rehab_sch_need_hist_in => g_sysdate_tstz,
                                   id_professional_hist_in   => i_prof.id,
                                   id_rehab_sch_need_in      => l_rehab_sch_need_row.id_rehab_sch_need,
                                   id_rehab_session_type_in  => l_rehab_sch_need_row.id_rehab_session_type,
                                   dt_rehab_sch_need_in      => l_rehab_sch_need_row.dt_rehab_sch_need,
                                   id_episode_origin_in      => l_rehab_sch_need_row.id_episode_origin,
                                   id_professional_in        => l_rehab_sch_need_row.id_professional,
                                   sessions_in               => l_rehab_sch_need_row.sessions,
                                   frequency_in              => l_rehab_sch_need_row.frequency,
                                   flg_frequency_in          => l_rehab_sch_need_row.flg_frequency,
                                   flg_priority_in           => l_rehab_sch_need_row.flg_priority,
                                   dt_begin_in               => l_rehab_sch_need_row.dt_begin,
                                   flg_status_in             => l_rehab_sch_need_row.flg_status,
                                   id_resp_professional_in   => l_rehab_sch_need_row.id_resp_professional,
                                   id_resp_rehab_group_in    => l_rehab_sch_need_row.id_resp_rehab_group,
                                   notes_in                  => l_rehab_sch_need_row.notes,
                                   id_cancel_reason_in       => l_rehab_sch_need_row.id_cancel_reason,
                                   dt_cancel_in              => l_rehab_sch_need_row.dt_cancel,
                                   id_cancel_professional_in => l_rehab_sch_need_row.id_cancel_professional,
                                   notes_cancel_in           => l_rehab_sch_need_row.notes_cancel,
                                   handle_error_in           => FALSE,
                                   rows_out                  => l_rowids);
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC_HIST',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_sch_need=' || i_id_rehab_sch_need || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END set_rehab_sch_need_hist;

    /**********************************************************************************************
    * Cancels a rehab_sch_need without commit
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_sch_need      schedule need
    * %param i_id_cancel_reason       cancel reason
    * %param i_notes                  notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION cancel_rehab_sch_need_nocommit
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_id_cancel_reason  IN rehab_sch_need.id_cancel_reason%TYPE DEFAULT NULL,
        i_notes             IN rehab_sch_need.notes_cancel%TYPE DEFAULT NULL,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_REHAB_SCH_NEED_NOCOMMIT';
        l_rowids     table_varchar;
        l_flg_status rehab_sch_need.flg_status%TYPE;
    
    BEGIN
        g_error        := 'begin';
        g_sysdate_tstz := systimestamp;
    
        SELECT flg_status
          INTO l_flg_status
          FROM rehab_sch_need rsn
         WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need;
    
        IF l_flg_status NOT IN (g_rehab_sch_need_dummy, g_rehab_sch_need_no_sched)
        THEN
        
            g_error := 'UPDATE STATUS';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            ts_rehab_sch_need.upd(id_rehab_sch_need_in      => i_id_rehab_sch_need,
                                  flg_status_in             => g_rehab_sch_need_cancel,
                                  notes_cancel_in           => i_notes,
                                  dt_cancel_in              => g_sysdate_tstz,
                                  id_cancel_reason_in       => i_id_cancel_reason,
                                  id_cancel_professional_in => i_prof.id,
                                  rows_out                  => l_rowids);
        
            g_error := 't_data_gov_mnt.process_update';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_SCH_NEED',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
            g_error := 'insert in rehab_sch_need_hist';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            IF NOT set_rehab_sch_need_hist(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_id_rehab_sch_need => i_id_rehab_sch_need,
                                           i_commit            => pk_alert_constant.get_no(),
                                           o_error             => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_sch_need=' || i_id_rehab_sch_need || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END cancel_rehab_sch_need_nocommit;

    /**********************************************************************************************
    * Cancels a rehab_sch_need
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_sch_need      schedule need
    * %param i_id_cancel_reason       cancel reason
    * %param i_notes                  notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION cancel_rehab_sch_need
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_id_cancel_reason  IN rehab_sch_need.id_cancel_reason%TYPE,
        i_notes             IN rehab_sch_need.notes_cancel%TYPE DEFAULT NULL,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_REHAB_SCH_NEED_NOCOMMIT';
    
    BEGIN
    
        IF NOT cancel_rehab_sch_need_nocommit(i_lang              => i_lang,
                                              i_prof              => i_prof,
                                              i_id_rehab_sch_need => i_id_rehab_sch_need,
                                              i_id_cancel_reason  => i_id_cancel_reason,
                                              i_notes             => i_notes,
                                              o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_sch_need=' || i_id_rehab_sch_need || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END cancel_rehab_sch_need;

    /**********************************************************************************************
    * updates a rehab_sch_need
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_sch_need      schedule need
    * %param i_sessions               number of sessions
    * %param i_frequency              frequency of the sessions
    * %param i_flg_frequency          unit of frequency
    * %param i_flg_priority           priority
    * %param i_date_begin             begin date
    * %param i_flg_status             status
    * %param i_id_session_type        session type
    * %param i_id_resp_professional   responsible professional
    * %param i_id_resp_rehab_group    responsible group
    * %param i_notes                  notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION update_rehab_sch_need
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_rehab_sch_need    IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_sessions             IN rehab_sch_need.sessions%TYPE,
        i_frequency            IN rehab_sch_need.frequency%TYPE,
        i_flg_frequency        IN rehab_sch_need.flg_frequency%TYPE,
        i_flg_priority         IN rehab_sch_need.flg_priority%TYPE,
        i_date_begin           IN rehab_sch_need.dt_begin%TYPE,
        i_flg_status           IN rehab_sch_need.flg_status%TYPE,
        i_id_session_type      IN rehab_sch_need.id_rehab_session_type%TYPE,
        i_id_resp_professional IN rehab_sch_need.id_resp_professional%TYPE,
        i_id_resp_rehab_group  IN rehab_sch_need.id_resp_rehab_group%TYPE,
        i_notes                IN rehab_sch_need.notes%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'UPDATE_REHAB_SCH_NEED';
        l_rowids table_varchar;
    
    BEGIN
        g_sysdate_tstz := systimestamp;
    
        g_error := 'copy to history i_id_rehab_sch_need=' || i_id_rehab_sch_need;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        IF NOT set_rehab_sch_need_hist(i_lang              => i_lang,
                                       i_prof              => i_prof,
                                       i_id_rehab_sch_need => i_id_rehab_sch_need,
                                       i_commit            => pk_alert_constant.get_no(),
                                       o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'update i_id_rehab_sch_need=' || i_id_rehab_sch_need;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        ts_rehab_sch_need.upd(id_rehab_sch_need_in     => i_id_rehab_sch_need,
                              sessions_in              => i_sessions,
                              frequency_in             => i_frequency,
                              flg_frequency_in         => i_flg_frequency,
                              flg_priority_in          => i_flg_priority,
                              dt_begin_in              => pk_date_utils.get_string_tstz(i_lang,
                                                                                        i_prof,
                                                                                        i_date_begin,
                                                                                        NULL),
                              flg_status_in            => i_flg_status,
                              id_professional_in       => i_prof.id,
                              dt_rehab_sch_need_in     => g_sysdate_tstz,
                              id_rehab_session_type_in => i_id_session_type,
                              id_resp_professional_in  => i_id_resp_professional,
                              id_resp_rehab_group_in   => i_id_resp_rehab_group,
                              notes_in                 => i_notes,
                              rows_out                 => l_rowids);
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SCH_NEED',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_sch_need=' || i_id_rehab_sch_need || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END update_rehab_sch_need;

    /**********************************************************************************************
    * retorna todos os tratamentos de uma necessidade de agendamento
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_episode             episode
    * %param i_id_schedule            schedule
    * %param o_session                sessions cursor
    * %param o_treats                 treatments cursor
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_sch_need_treats
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_id_episode  IN rehab_sch_need.id_episode_origin%TYPE,
        i_id_schedule IN rehab_schedule.id_schedule %TYPE,
        o_session     OUT pk_types.cursor_type,
        o_treats      OUT pk_types.cursor_type,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_SCH_NEED_TREATS';
        l_id_episode_origin rehab_sch_need.id_episode_origin%TYPE;
        l_id_rehab_sch_need table_number;
    
        l_dt_start_op opinion_prof.dt_opinion_prof_tstz%TYPE;
    
    BEGIN
        g_error := 'Before get_origin_episode';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        IF i_id_schedule IS NOT NULL
        THEN
            -- com agendamento
            SELECT rs.id_rehab_sch_need
              BULK COLLECT
              INTO l_id_rehab_sch_need
              FROM rehab_schedule rs
             WHERE rs.id_schedule = i_id_schedule;
        ELSE
            -- sem agendamento
            BEGIN
                SELECT re.id_episode_origin
                  INTO l_id_episode_origin
                  FROM rehab_epis_encounter re
                 WHERE re.id_episode_rehab = i_id_episode;
            EXCEPTION
                WHEN no_data_found THEN
                    l_id_episode_origin := NULL;
            END;
        
            SELECT rsn.id_rehab_sch_need
              BULK COLLECT
              INTO l_id_rehab_sch_need
              FROM rehab_sch_need rsn
             WHERE rsn.id_episode_origin IN (l_id_episode_origin, i_id_episode);
        
        END IF;
    
        g_error := 'open o_session';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        OPEN o_session FOR
            SELECT rsn.id_rehab_sch_need,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, rsn.dt_rehab_sch_need, i_prof) AS dt_rehab_sch_need,
                   pk_prof_utils.get_nickname(i_lang, rsn.id_professional) AS professional,
                   pk_prof_utils.get_prof_speciality(i_lang, profissional(rsn.id_professional, NULL, NULL)) AS speciality,
                   -- instituição aonde foi criada a sch_need?
                   i_prof.institution AS institution,
                   rsn.id_rehab_session_type,
                   decode((SELECT COUNT(*)
                            FROM (SELECT DISTINCT rst1.code_rehab_session_type
                                    FROM rehab_sch_need rsn1
                                    JOIN rehab_presc rp1
                                      ON rp1.id_rehab_sch_need = rsn1.id_rehab_sch_need
                                    JOIN rehab_session_type rst1
                                      ON rst1.id_rehab_session_type = rsn1.id_rehab_session_type
                                   WHERE rsn1.id_episode_origin IN (l_id_episode_origin, i_id_episode))),
                          1,
                          pk_translation.get_translation(i_lang, rst.code_rehab_session_type),
                          pk_message.get_message(i_lang, 'REHAB_T013')) desc_session_type,
                   decode((SELECT COUNT(*)
                            FROM (SELECT DISTINCT get_instructions(i_lang, i_prof, rsn1.id_rehab_sch_need)
                                    FROM rehab_sch_need rsn1
                                    JOIN rehab_presc rp1
                                      ON rp1.id_rehab_sch_need = rsn1.id_rehab_sch_need
                                   WHERE rsn1.id_episode_origin IN (l_id_episode_origin, i_id_episode))),
                          1,
                          get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need),
                          pk_message.get_message(i_lang, 'REHAB_T013')) AS instructions,
                   decode((SELECT COUNT(*)
                            FROM (SELECT DISTINCT rsn1.notes
                                    FROM rehab_sch_need rsn1
                                    JOIN rehab_presc rp1
                                      ON rp1.id_rehab_sch_need = rsn1.id_rehab_sch_need
                                   WHERE rsn1.id_episode_origin IN (l_id_episode_origin, i_id_episode))),
                          1,
                          rsn.notes,
                          pk_message.get_message(i_lang, 'REHAB_T013')) AS notes,
                   decode((SELECT COUNT(*)
                            FROM (SELECT DISTINCT get_rehab_sch_need_resp(i_lang,
                                                                          rsn1.id_resp_professional,
                                                                          rsn1.id_resp_rehab_group)
                                    FROM rehab_sch_need rsn1
                                    JOIN rehab_presc rp1
                                      ON rp1.id_rehab_sch_need = rsn1.id_rehab_sch_need
                                   WHERE rsn1.id_episode_origin IN (l_id_episode_origin, i_id_episode))),
                          1,
                          get_rehab_sch_need_resp(i_lang, rsn.id_resp_professional, rsn.id_resp_rehab_group),
                          pk_message.get_message(i_lang, 'REHAB_T013')) AS responsible,
                   (SELECT COUNT(*)
                      FROM rehab_session rs
                     WHERE rs.id_rehab_presc = rp.id_rehab_presc
                       AND rs.flg_status = g_rehab_session_executed) AS session_count
              FROM rehab_sch_need rsn
              JOIN rehab_session_type rst
                ON rst.id_rehab_session_type = rsn.id_rehab_session_type
              JOIN rehab_presc rp
                ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
              JOIN TABLE(l_id_rehab_sch_need) t
                ON rsn.id_rehab_sch_need = t.column_value;
    
        g_error := 'open o_treats';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        OPEN o_treats FOR
            SELECT id_rehab_presc,
                   id_rehab_area_interv,
                   id_rehab_area,
                   desc_intervention,
                   flg_execute,
                   notes,
                   execution_count,
                   pk_sysdomain.get_img(i_lang, g_rehab_presc_flg_status, status) AS icon,
                   exec_per_session,
                   treat_instructions,
                   session_type,
                   flg_status,
                   flg_status_description,
                   prof_last_update,
                   prof_speciality_last_update,
                   dt_last_update
              FROM (SELECT rp.id_rehab_presc,
                           rp.id_rehab_area_interv,
                           rai.id_rehab_area,
                           pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) AS desc_intervention,
                           decode(rp.flg_status,
                                  g_rehab_presc_cancel,
                                  pk_alert_constant.g_no,
                                  g_rehab_presc_discontinued,
                                  pk_alert_constant.g_no,
                                  g_rehab_presc_suspend,
                                  pk_alert_constant.g_no,
                                  pk_alert_constant.g_yes) flg_execute,
                           rp.notes,
                           (SELECT COUNT(*)
                              FROM rehab_session rs
                             WHERE rs.id_rehab_presc = rp.id_rehab_presc
                               AND rs.flg_status = g_rehab_session_executed
                            --AND rs.id_episode = i_id_episode
                            ) AS execution_count,
                           rp.flg_status status,
                           rp.exec_per_session,
                           get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) treat_instructions,
                           pk_translation.get_translation(i_lang, rst.code_rehab_session_type) session_type,
                           rp.flg_status flg_status,
                           pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', rp.flg_status, i_lang) flg_status_description,
                           pk_prof_utils.get_name(i_lang, rp.id_professional) prof_last_update,
                           pk_prof_utils.get_spec_signature(i_lang,
                                                            i_prof,
                                                            rp.id_professional,
                                                            rp.dt_rehab_presc,
                                                            rsn.id_episode_origin) prof_speciality_last_update,
                           pk_date_utils.dt_chr_date_hour_tsz(i_lang, rp.dt_rehab_presc, i_prof) dt_last_update
                      FROM rehab_sch_need rsn
                      JOIN rehab_presc rp
                        ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                    -- desc_interv
                      JOIN rehab_area_interv rai
                        ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                      JOIN intervention i
                        ON i.id_intervention = rai.id_intervention
                      JOIN rehab_area ra
                        ON ra.id_rehab_area = rai.id_rehab_area
                      JOIN TABLE(l_id_rehab_sch_need) t
                        ON rsn.id_rehab_sch_need = t.column_value
                      LEFT JOIN rehab_session_type rst
                        ON (rst.id_rehab_session_type = rsn.id_rehab_session_type)
                     WHERE rp.flg_status <> g_rehab_presc_not_order_reas
                       AND rsn.flg_status <> g_rehab_sch_need_dummy)
            UNION ALL
            --Executions of treatments not prescribed
            SELECT rp.id_rehab_presc,
                   rp.id_rehab_area_interv,
                   rai.id_rehab_area,
                   pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) AS desc_intervention,
                   decode(rp.flg_status,
                          g_rehab_presc_cancel,
                          pk_alert_constant.g_no,
                          g_rehab_presc_discontinued,
                          pk_alert_constant.g_no,
                          g_rehab_presc_suspend,
                          pk_alert_constant.g_no,
                          pk_alert_constant.g_yes) flg_execute,
                   rp.notes,
                   (SELECT COUNT(*)
                      FROM rehab_session rs1
                     WHERE rs1.id_rehab_presc = rp.id_rehab_presc
                       AND rs1.flg_status = g_rehab_session_executed
                       AND rs1.id_episode = i_id_episode) AS execution_count,
                   pk_sysdomain.get_img(i_lang, g_rehab_presc_flg_status, rp.flg_status) AS icon,
                   rp.exec_per_session,
                   get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) treat_instructions,
                   pk_translation.get_translation(i_lang, rst.code_rehab_session_type) session_type,
                   rp.flg_status flg_status,
                   pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', rp.flg_status, i_lang) flg_status_description,
                   pk_prof_utils.get_name(i_lang, rp.id_professional) prof_last_update,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    rp.id_professional,
                                                    rp.dt_rehab_presc,
                                                    rsn.id_episode_origin) prof_speciality_last_update,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, rp.dt_rehab_presc, i_prof) dt_last_update
              FROM rehab_presc rp
              JOIN rehab_sch_need rsn
                ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
              JOIN rehab_area_interv rai
                ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
              JOIN intervention i
                ON i.id_intervention = rai.id_intervention
              LEFT JOIN rehab_session_type rst
                ON (rst.id_rehab_session_type = rsn.id_rehab_session_type)
             WHERE rsn.flg_status = g_rehab_sch_need_dummy --dummy sch_need for treatments without instructions
               AND EXISTS (SELECT 0
                      FROM rehab_session rs
                     WHERE rs.id_rehab_presc = rp.id_rehab_presc
                       AND rs.id_episode = i_id_episode -- show execution of treatments not prescribed just for current episode
                    )
             ORDER BY id_rehab_presc;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_episode=' || i_id_episode || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            pk_types.open_cursor_if_closed(o_session);
            pk_types.open_cursor_if_closed(o_treats);
            RETURN FALSE;
    END get_rehab_sch_need_treats;

    FUNCTION get_dt_init
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        o_dt_init OUT VARCHAR2,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN
    
     IS
        l_dt_start_op opinion_prof.dt_opinion_prof_tstz%TYPE;
    
    BEGIN
    
        BEGIN
            SELECT opf.dt_opinion_prof_tstz
              INTO l_dt_start_op
              FROM episode e
             INNER JOIN opinion op
                ON e.id_episode = op.id_episode
             INNER JOIN opinion_prof opf
                ON opf.id_opinion = op.id_opinion
             WHERE op.id_opinion_type = 6
               AND op.flg_state = pk_opinion.g_status_accepted
               AND opf.flg_type = pk_opinion.g_opinion_prof_accept
               AND e.id_episode = i_episode;
        EXCEPTION
            WHEN OTHERS THEN
                BEGIN
                    SELECT z.dt_creation
                      INTO l_dt_start_op
                      FROM (SELECT a.dt_creation, rownum rn
                              FROM rehab_epis_encounter a
                             WHERE a.id_episode_rehab = i_episode
                             ORDER BY a.dt_creation DESC NULLS LAST) z
                     WHERE z.rn = 1;
                EXCEPTION
                    WHEN OTHERS THEN
                        pk_alert_exceptions.process_error(i_lang,
                                                          SQLCODE,
                                                          SQLERRM,
                                                          g_error,
                                                          g_package_owner,
                                                          g_package_name,
                                                          'GET_DT_INIT',
                                                          o_error);
                        l_dt_start_op := current_timestamp;
                END;
        END;
    
        o_dt_init := pk_date_utils.date_send_tsz(i_lang, l_dt_start_op, i_prof);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_DT_INIT',
                                              o_error);
        
            RETURN FALSE;
    END get_dt_init;

    /**********************************************************************************************
    * Updates a rehab presc details
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_presc         prescription
    * %param i_id_rehab_sch_need      schedule need
    * %param i_id_exec_institution    execution institution
    * %param i_exec_per_session       number of execution per session
    * %param i_notes                  notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION update_rehab_presc
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_rehab_presc      IN rehab_presc.id_rehab_presc%TYPE,
        i_id_rehab_sch_need   IN rehab_presc.id_rehab_sch_need%TYPE,
        i_id_exec_institution IN rehab_presc.id_exec_institution%TYPE,
        i_exec_per_session    IN rehab_presc.exec_per_session%TYPE,
        i_notes               IN rehab_presc.notes%TYPE,
        i_flg_laterality      IN rehab_presc.flg_laterality%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'UPDATE_REHAB_PRESC';
        l_rowids table_varchar;
    
    BEGIN
        g_sysdate_tstz := systimestamp;
    
        g_error := 'create history for i_id_rehab_presc=' || i_id_rehab_presc;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_error := 'update i_id_rehab_presc=' || i_id_rehab_presc;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_presc.upd(id_rehab_presc_in      => i_id_rehab_presc,
                           id_rehab_sch_need_in   => i_id_rehab_sch_need,
                           id_exec_institution_in => i_id_exec_institution,
                           exec_per_session_in    => i_exec_per_session,
                           notes_in               => i_notes,
                           dt_rehab_presc_in      => g_sysdate_tstz,
                           id_professional_in     => i_prof.id,
                           flg_laterality_in      => i_flg_laterality,
                           rows_out               => l_rowids);
    
        g_error := 't_data_gov_mnt.process_update';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        g_error := 'set_rehab_presc_hist';
        IF NOT set_rehab_presc_hist(i_lang           => i_lang,
                                    i_prof           => i_prof,
                                    i_id_rehab_presc => i_id_rehab_presc,
                                    i_commit         => pk_alert_constant.get_no(),
                                    o_error          => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        -- COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_presc=' || i_id_rehab_presc || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END update_rehab_presc;

    -- get rehabilitation plan for this patient, if not found create it
    /**********************************************************************************************
    * Cancels a rehab_schedule
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient
    * %param i_id_episode_origin      episode
    * %param i_commit                 Y/N for commit
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION check_rehab_plan
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_patient        IN rehab_plan.id_patient%TYPE,
        i_id_episode_origin IN rehab_plan.id_episode_origin%TYPE,
        i_commit            IN VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_PLAN';
        l_tmp    NUMBER;
        l_rowids table_varchar;
    
    BEGIN
        g_sysdate_tstz := systimestamp;
    
        g_error := 'get rehab_plan for i_id_patient=' || i_id_patient || ', i_id_episode_origin=' ||
                   i_id_episode_origin;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        SELECT COUNT(*)
          INTO l_tmp
          FROM rehab_plan rp
         WHERE rp.id_episode_origin = i_id_episode_origin
           AND rp.flg_status = g_rehab_plan_active;
    
        g_error := 'depois do select l_tmp=' || l_tmp;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        IF l_tmp = 0
        THEN
            -- não existe nenhuma entrada para este episódio
            g_error := 'create new rehab_plan';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            ts_rehab_plan.ins(id_episode_origin_in => i_id_episode_origin,
                              dt_rehab_plan_in     => g_sysdate_tstz,
                              id_professional_in   => i_prof.id,
                              id_patient_in        => i_id_patient,
                              flg_status_in        => g_rehab_plan_active,
                              rows_out             => l_rowids);
        
            g_error := 't_data_gov_mnt.process_insert';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_PLAN',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
        END IF;
    
        IF nvl(i_commit, pk_alert_constant.get_no()) = pk_alert_constant.get_yes()
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            IF nvl(i_commit, pk_alert_constant.get_no()) = pk_alert_constant.get_yes()
            THEN
                pk_utils.undo_changes;
            END IF;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END check_rehab_plan;

    -- get list of professionals and groups allocated to the areas
    FUNCTION get_prof_group_list_internal
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_rehab_area IN table_number,
        i_only_prof     IN VARCHAR2 DEFAULT 'N',
        o_prof_list     OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PROF_GROUP_LIST_INTERNAL';
    
    BEGIN
    
        OPEN o_prof_list FOR
            SELECT z.id_professional AS data,
                   pk_prof_utils.get_nickname(i_lang, z.id_professional) AS label,
                   g_list_type_prof_abbr AS TYPE,
                   1 AS rank
              FROM TABLE(pk_rehab.find_inst_rehab_areas(i_prof.institution)) x
              JOIN rehab_area_inst_prof z
                ON z.id_rehab_area_inst = x.id_rehab_area_inst
             WHERE i_id_rehab_area IS NULL
                OR x.id_rehab_area IN (SELECT /*+opt_estimate(table t rows=1)*/
                                        column_value
                                         FROM TABLE(i_id_rehab_area) t)
               AND z.id_professional != i_prof.id
            UNION -- não colocar union all para não aparecer o profissional repetido
            SELECT i_prof.id,
                   pk_prof_utils.get_nickname(i_lang, i_prof.id) prof_name,
                   g_list_type_prof_abbr AS TYPE,
                   1 AS rank
              FROM dual
            UNION
            SELECT rg.id_rehab_group, rg.name, g_list_type_group_abbr AS TYPE, 2 AS rank
              FROM rehab_group rg
             WHERE i_id_rehab_area IS NULL
                OR rg.id_rehab_area IN (SELECT /*+opt_estimate(table t rows=1)*/
                                         column_value
                                          FROM TABLE(i_id_rehab_area) t)
               AND i_only_prof = 'N'
               AND rg.flg_status = 'A' --ACTIVE
               AND rg.id_institution IN (0, i_prof.institution);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_area=' || pk_utils.concat_table(i_id_rehab_area) || ' @' ||
                                  g_error,
                                  g_package_name,
                                  l_func_name);
            pk_types.open_my_cursor(o_prof_list);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_prof_group_list_internal;

    /**********************************************************************************************
    * get list of professionals and groups allocated to the areas
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_area          rehab area
    * %param o_prof_list              list of professionals
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_prof_group_list
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_rehab_area IN table_number,
        o_prof_list     OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        --l_func_name CONSTANT VARCHAR2(30) := 'GET_PROF_LIST';
    
    BEGIN
        RETURN get_prof_group_list_internal(i_lang, i_prof, i_id_rehab_area, 'N', o_prof_list, o_error);
    END get_prof_group_list;

    /**********************************************************************************************
    * get list of professionals allocated to the areas
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_area          rehab area
    * %param o_prof_list              list of professionals
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_prof_list
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_rehab_area IN table_number,
        o_prof_list     OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        --l_func_name CONSTANT VARCHAR2(30) := 'GET_PROF_LIST';
    
    BEGIN
        RETURN get_prof_group_list_internal(i_lang, i_prof, i_id_rehab_area, 'Y', o_prof_list, o_error);
    END get_prof_list;

    /**********************************************************************************************
    * retorna todas as execuções de uma necessidade de agendamento
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_sch_need      necessidade de agendamento
    * %param o_executions             numero de execuções
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_sch_need_exec
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        o_executions        OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_SCH_NEED_EXEC';
    
    BEGIN
        g_error := 'open o_session';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        OPEN o_executions FOR
            SELECT rp.id_rehab_presc,
                   rs.id_rehab_session,
                   pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) AS desc_intervention,
                   COUNT(*) over(PARTITION BY rs.id_rehab_presc) AS execution_count,
                   row_number() over(PARTITION BY rs.id_rehab_presc ORDER BY rs.dt_begin) AS execution_number,
                   pk_prof_utils.get_nickname(i_lang, rs.id_exec_professional) exec_prof_name,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, rs.dt_begin, i_prof) dt_last_update,
                   rs.notes,
                   get_rp_icon(i_lang, rp.id_rehab_presc, NULL, rsn.sessions, rp.flg_status) AS icon
              FROM rehab_session rs
              JOIN rehab_presc rp
                ON rp.id_rehab_sch_need = rs.id_rehab_presc
              JOIN rehab_sch_need rsn
                ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
            -- desc_interv
              JOIN rehab_area_interv rai
                ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
              JOIN intervention i
                ON i.id_intervention = rai.id_intervention
             WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need
             ORDER BY rp.id_rehab_presc;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_sch_need=' || i_id_rehab_sch_need || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            pk_types.open_cursor_if_closed(o_executions);
            RETURN FALSE;
    END get_rehab_sch_need_exec;

    /**********************************************************************************************
    * retorna todas as execuções de uma lista de requisições
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_presc         list of treatments
    * %param o_executions             number of executions for each treatment
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_rehab_presc_exec
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN table_number,
        o_executions     OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_PRESC_EXEC';
    BEGIN
        g_error := 'before call';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        OPEN o_executions FOR
            SELECT id_rehab_presc,
                   id_rehab_session,
                   desc_intervention || ' (' || COUNT(*) over(PARTITION BY id_rehab_presc) || ')' AS desc_header,
                   desc_intervention,
                   execution_count,
                   execution_number,
                   id_exec_professional,
                   exec_prof_name,
                   dt_last_update,
                   dt_begin_str,
                   dt_end_str,
                   duration,
                   notes,
                   icon,
                   flg_status
              FROM (SELECT rp.id_rehab_presc,
                           rs.id_rehab_session,
                           pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) AS desc_intervention,
                           COUNT(*) over(PARTITION BY rs.id_rehab_presc) AS execution_count,
                           row_number() over(PARTITION BY rs.id_rehab_presc ORDER BY rs.dt_rehab_session) AS execution_number,
                           rs.id_exec_professional,
                           pk_prof_utils.get_nickname(i_lang, rs.id_exec_professional) exec_prof_name,
                           pk_date_utils.dt_chr_date_hour_tsz(i_lang, rs.dt_begin, i_prof) dt_last_update,
                           pk_date_utils.date_send_tsz(i_lang, rs.dt_begin, i_prof) dt_begin_str,
                           pk_date_utils.date_send_tsz(i_lang, rs.dt_end, i_prof) dt_end_str,
                           rs.duration,
                           rs.notes,
                           pk_sysdomain.get_img(i_lang, g_rehab_presc_flg_status, rp.flg_status) AS icon,
                           rp.flg_status,
                           rs.flg_status AS rs_flg_status
                      FROM rehab_presc rp
                      JOIN rehab_session rs
                        ON rp.id_rehab_presc = rs.id_rehab_presc
                      JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                    -- desc_interv
                      JOIN rehab_area_interv rai
                        ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                      JOIN intervention i
                        ON i.id_intervention = rai.id_intervention
                     WHERE rp.id_rehab_presc IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                  column_value
                                                   FROM TABLE(i_id_rehab_presc) t)
                       AND rs.flg_status IN (g_rehab_session_executed)) x
             WHERE x.rs_flg_status = g_rehab_session_executed
             ORDER BY x.id_rehab_presc, x.execution_number;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters:  @' || g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            pk_types.open_cursor_if_closed(o_executions);
            RETURN FALSE;
    END get_rehab_presc_exec;

    /**********************************************************************************************
    * get list of time units hora(s), minuto(s)
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param o_units                  list of units
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_time_units
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_units OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_TIME_UNITS';
    BEGIN
        g_error := 'before call';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        OPEN o_units FOR
            SELECT pk_message.get_message(i_lang, 'REHAB_T121')
              FROM dual
            UNION ALL
            SELECT pk_message.get_message(i_lang, 'REHAB_T122')
              FROM dual;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_time_units;

    /**********************************************************************************************
    * verificar se nas necessidades de agendamentos modificadas (inseridas ou adicionados tratamentos)
    * se existe só um único tipo de sessão, caso contrário cria outra igual.
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_sch_needs              list of schedule needs
    * %param o_new_rowids             rows inserted
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION check_sch_need_session_type
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_sch_needs  IN table_number,
        o_new_rowids OUT table_varchar,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_SCH_NEED_SESSION_TYPE';
    BEGIN
        g_error := 'before call';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END check_sch_need_session_type;

    FUNCTION get_grid_lock
    (
        i_lang     language.id_language%TYPE,
        i_prof     profissional,
        i_tab_name VARCHAR2,
        i_id       NUMBER
    ) RETURN NUMBER IS
        l_id_lock table_number;
    BEGIN
    
        l_id_lock := pk_lock.get_lock_prints(i_func => table_varchar(i_tab_name), i_ids => table_number(i_id));
    
        RETURN l_id_lock(1);
    END get_grid_lock;

    /********************************************************************************************
    * Get the list of patients with rehab sessions for the day
    *
    * @param i_lang               Prefered language ID
    * @param i_prof               Professional type (ID, INST, SOFTWARE)
    * @param i_all_patients       Flag to indicate the screen (Y - All patients grid, N - My patients)
    * @param o_flg_show           Flag to indicate the screen to show
    * @param o_msg                Message to be displayed in the screen
    * @param o_msg_title          Message title to be displayed in the screen
    * @param o_button             Button to be displayed in the screen
    * @param o_patients           Patients list
    * @param o_error              Error
    *
    *
    * @return                      true or false on success or error
    *
    * @author                      JTS
    * @version                     0.1
    * @since                       2010/08/12
    ********************************************************************************************/
    FUNCTION get_patients_grid
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_all_patients IN VARCHAR2,
        o_flg_show     OUT VARCHAR2,
        o_msg          OUT VARCHAR2,
        o_msg_title    OUT VARCHAR2,
        o_button       OUT VARCHAR2,
        o_patients     OUT pk_types.cursor_type,
        o_error        OUT t_error_out
        
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PATIENTS_GRID';
    
        l_dt_begin                 TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end                   TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_count                    NUMBER;
        l_limit                    NUMBER;
        l_show_med_disch           sys_config.value%TYPE;
        l_session_with_schedule    sys_message.desc_message%TYPE;
        l_session_without_schedule sys_message.desc_message%TYPE;
        l_appointment              sys_message.desc_message%TYPE;
        l_prof_rehab_groups        table_number;
    
        l_flg_sch_type_cr    schedule.flg_sch_type%TYPE := 'CR'; --Rehab appointments
        l_epis_type_rehab_ap epis_type.id_epis_type%TYPE := 25; --epis_type Rehab appointments
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
        g_sysdate_char := pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof);
        l_dt_begin     := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
        l_dt_end       := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
    
        --
        l_show_med_disch := nvl(pk_sysconfig.get_config('SHOW_MEDICAL_DISCHARGED_GRID', i_prof),
                                pk_alert_constant.g_yes);
        --
    
        l_session_with_schedule    := pk_message.get_message(i_lang, i_prof, 'REHAB_T146');
        l_session_without_schedule := pk_message.get_message(i_lang, i_prof, 'REHAB_T147');
        l_appointment              := pk_message.get_message(i_lang, i_prof, 'REHAB_T148');
    
        g_error := 'get profissional groups ';
        SELECT id_rehab_group
          BULK COLLECT
          INTO l_prof_rehab_groups
          FROM rehab_group_prof rgp
         WHERE rgp.id_professional = i_prof.id;
    
        g_error := 'before call';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        IF i_all_patients = pk_alert_constant.g_no
        THEN
            --MY patients grid
            OPEN o_patients FOR
                SELECT *
                  FROM (SELECT DISTINCT rs.id_schedule id_schedule,
                                        (SELECT cr.num_clin_record
                                           FROM clin_record cr
                                          WHERE cr.id_patient = rp.id_patient
                                            AND cr.id_institution = i_prof.institution
                                            AND rownum < 2) num_clin_record,
                                        e.id_patient,
                                        e.id_episode id_episode_origin,
                                        nvl(re.id_episode_rehab, e.id_episode) id_episode,
                                        e.id_visit,
                                        pk_patient.get_pat_name(i_lang,
                                                                i_prof,
                                                                e.id_patient,
                                                                e.id_episode,
                                                                rs.id_schedule) name,
                                        pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) pat_ndo,
                                        pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) pat_nd_icon,
                                        pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) pat_age,
                                        pk_patient.get_pat_gender(e.id_patient) AS gender,
                                        pk_patphoto.get_pat_photo(i_lang,
                                                                  i_prof,
                                                                  e.id_patient,
                                                                  e.id_episode,
                                                                  rs.id_schedule) photo,
                                        get_rehab_sch_need_resp(i_lang,
                                                                rsn.id_resp_professional,
                                                                rsn.id_resp_rehab_group) nick_name,
                                        pk_date_utils.date_char_hour_tsz(i_lang,
                                                                         decode(re.id_episode_rehab,
                                                                                NULL,
                                                                                NULL,
                                                                                re.dt_creation),
                                                                         i_prof.institution,
                                                                         i_prof.software) dt_efectiv,
                                        pk_date_utils.dt_chr_hour_tsz(i_lang,
                                                                      s.dt_begin_tstz,
                                                                      i_prof.institution,
                                                                      i_prof.software) dt_target,
                                        g_sysdate_char dt_server,
                                        get_grid_workflow_icon(i_lang,
                                                               i_prof,
                                                               g_workflow_type_s,
                                                               nvl(re.flg_status, g_rehab_epis_enc_status_a)) new_icon_name,
                                        1442 shortcut,
                                        pk_date_utils.date_send_tsz(i_lang, s.dt_schedule_tstz, i_prof) AS dt_exec,
                                        nvl(re.flg_status, g_rehab_epis_enc_status_a) AS flg_status,
                                        g_workflow_type_s AS flg_type,
                                        1 AS id_schedule_type,
                                        l_session_with_schedule AS desc_schedule_type,
                                        pk_translation.get_translation(i_lang, rst.code_rehab_session_type) AS desc_session_type,
                                        decode(bd.code_bed,
                                               NULL,
                                               NULL,
                                               nvl(pk_translation.get_translation(i_lang, dpt.abbreviation),
                                                   pk_translation.get_translation(i_lang, dpt.code_department))) desc_service,
                                        nvl(nvl(ro.desc_room_abbreviation,
                                                pk_translation.get_translation(i_lang, ro.code_abbreviation)),
                                            nvl(ro.desc_room, pk_translation.get_translation(i_lang, ro.code_room))) desc_room,
                                        nvl(bd.desc_bed, pk_translation.get_translation(i_lang, bd.code_bed)) desc_bed,
                                        re.id_rehab_epis_encounter id_rehab_grid,
                                        rsn.id_rehab_sch_need id_rehab_presc,
                                        rs.id_rehab_schedule id_rehab_schedule,
                                        pk_sysdomain.get_domain('EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC',
                                                                ei.id_software,
                                                                i_lang) origin,
                                        pk_adt.is_contact(i_lang, i_prof, e.id_patient) flg_contact,
                                        decode(pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                       e.id_episode,
                                                                                       ei.id_schedule),
                                               pk_alert_constant.g_no,
                                               pk_alert_constant.g_yes,
                                               pk_alert_constant.g_no) prof_follow_add,
                                        pk_prof_follow.get_follow_episode_by_me(i_prof, e.id_episode, ei.id_schedule) prof_follow_remove,
                                        s.id_schedule id_lock_uq_value,
                                        'REHAB_GRID_SCHED' lock_func,
                                        get_grid_lock(i_lang, i_prof, 'REHAB_GRID_SCHED', s.id_schedule) id_lock
                          FROM rehab_schedule rs
                          JOIN schedule s
                            ON s.id_schedule = rs.id_schedule
                          JOIN rehab_sch_need rsn
                            ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
                          JOIN rehab_presc rpres
                            ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                          JOIN rehab_session_type rst
                            ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                          JOIN rehab_plan rp
                            ON rp.id_episode_origin = rsn.id_episode_origin
                          JOIN episode e
                            ON e.id_episode = rsn.id_episode_origin -- falta este episódio
                          JOIN rehab_environment r
                            ON r.id_epis_type = e.id_epis_type
                           AND r.id_institution = i_prof.institution
                           AND r.id_rehab_environment IN
                               (SELECT rep.id_rehab_environment
                                  FROM rehab_environment_prof rep
                                 WHERE rep.id_professional = i_prof.id)
                          JOIN epis_info ei
                            ON ei.id_episode = e.id_episode
                          LEFT JOIN bed bd
                            ON bd.id_bed = ei.id_bed
                          LEFT JOIN room ro
                            ON (ro.id_room = s.id_room OR ro.id_room = bd.id_room)
                          LEFT JOIN department dpt
                            ON dpt.id_department = ro.id_department
                          LEFT JOIN rehab_epis_encounter re
                            ON (re.id_episode_origin = e.id_episode AND re.id_rehab_sch_need = rsn.id_rehab_sch_need AND
                               re.dt_creation BETWEEN l_dt_begin AND l_dt_end)
                          JOIN rehab_area_interv rai
                            ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
                          JOIN TABLE(find_prof_rehab_areas(i_prof.id, i_prof.institution)) x
                            ON x.id_rehab_area = rai.id_rehab_area
                         WHERE s.dt_begin_tstz BETWEEN l_dt_begin AND l_dt_end
                           AND rs.flg_status = g_rehab_schedule_scheduled
                           AND s.flg_status != pk_schedule.g_sched_status_temporary
                           AND s.id_instit_requested = i_prof.institution
                           AND s.flg_status != pk_schedule.g_sched_status_cache
                           AND rpres.flg_status NOT IN (pk_alert_constant.g_cancelled, g_rehab_presc_discontinued)
                           AND ((e.flg_status = pk_alert_constant.g_active AND
                               pk_sysconfig.get_config(i_prof => i_prof, i_code_cf => 'REHAB_NEEDS_SCHEDULE') =
                               pk_alert_constant.g_no) OR
                               (pk_sysconfig.get_config(i_prof => i_prof, i_code_cf => 'REHAB_NEEDS_SCHEDULE') =
                               pk_alert_constant.g_yes) AND s.id_schedule IS NOT NULL)
                              -- ou o profissional responsável sou eu
                           AND ((rsn.id_resp_professional IS NOT NULL AND rsn.id_resp_professional = i_prof.id) OR
                               -- ou o meu grupo
                               (rsn.id_resp_rehab_group IS NOT NULL AND
                               rsn.id_resp_rehab_group IN
                               (SELECT /*+opt_estimate(table t rows=1)*/
                                   column_value
                                    FROM TABLE(l_prof_rehab_groups) t)))
                           AND e.id_epis_type != pk_alert_constant.g_epis_type_rehab_appointment
                        UNION ALL
                        -- pacientes com tratamentos sem agendamento
                        SELECT id_schedule,
                               num_clin_record,
                               id_patient,
                               id_episode_origin,
                               id_episode,
                               id_visit,
                               name,
                               pat_ndo,
                               pat_nd_icon,
                               pat_age,
                               gender,
                               photo,
                               nick_name,
                               dt_efectiv,
                               dt_target,
                               dt_server,
                               new_icon_name,
                               shortcut,
                               dt_exec,
                               flg_status,
                               flg_type,
                               id_schedule_type,
                               desc_schedule_type,
                               desc_session_type,
                               desc_service,
                               desc_room,
                               desc_bed,
                               id_rehab_grid,
                               id_rehab_presc,
                               id_rehab_schedule,
                               origin,
                               flg_contact,
                               prof_follow_add,
                               prof_follow_remove,
                               id_lock_uq_value,
                               lock_func,
                               id_lock
                          FROM (SELECT DISTINCT NULL id_schedule,
                                                (SELECT cr.num_clin_record
                                                   FROM clin_record cr
                                                  WHERE cr.id_patient = rbp.id_patient
                                                    AND cr.id_institution = i_prof.institution
                                                    AND rownum < 2) num_clin_record,
                                                e.id_patient,
                                                e.id_episode id_episode_origin,
                                                nvl(re.id_episode_rehab, e.id_episode) id_episode,
                                                e.id_visit,
                                                pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode, NULL) name,
                                                pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) pat_ndo,
                                                pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) pat_nd_icon,
                                                pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) pat_age,
                                                pk_patient.get_pat_gender(e.id_patient) AS gender,
                                                pk_patphoto.get_pat_photo(i_lang,
                                                                          i_prof,
                                                                          e.id_patient,
                                                                          e.id_episode,
                                                                          NULL) photo,
                                                get_rehab_sch_need_resp(i_lang,
                                                                        rsn.id_resp_professional,
                                                                        rsn.id_resp_rehab_group) nick_name,
                                                pk_date_utils.date_char_hour_tsz(i_lang,
                                                                                 re.dt_creation,
                                                                                 i_prof.institution,
                                                                                 i_prof.software) dt_efectiv,
                                                pk_date_utils.dt_chr_hour_tsz(i_lang,
                                                                              NULL,
                                                                              i_prof.institution,
                                                                              i_prof.software) dt_target,
                                                g_sysdate_char dt_server,
                                                get_grid_workflow_icon(i_lang,
                                                                       i_prof,
                                                                       g_workflow_type_w,
                                                                       nvl(re.flg_status, g_rehab_epis_enc_status_e)) new_icon_name,
                                                1442 shortcut,
                                                pk_date_utils.date_send_tsz(i_lang, NULL, i_prof) AS dt_exec,
                                                nvl(re.flg_status, g_rehab_epis_enc_status_e) AS flg_status,
                                                g_workflow_type_w AS flg_type,
                                                1 AS id_schedule_type,
                                                l_session_without_schedule AS desc_schedule_type,
                                                pk_translation.get_translation(i_lang, rst.code_rehab_session_type) AS desc_session_type,
                                                decode(bd.code_bed,
                                                       NULL,
                                                       NULL,
                                                       nvl(pk_translation.get_translation(i_lang, dpt.abbreviation),
                                                           pk_translation.get_translation(i_lang, dpt.code_department))) desc_service,
                                                nvl(nvl(ro.desc_room_abbreviation,
                                                        pk_translation.get_translation(i_lang, ro.code_abbreviation)),
                                                    nvl(ro.desc_room, pk_translation.get_translation(i_lang, ro.code_room))) desc_room,
                                                nvl(bd.desc_bed, pk_translation.get_translation(i_lang, bd.code_bed)) desc_bed,
                                                re.id_rehab_epis_encounter id_rehab_grid,
                                                rsn.id_rehab_sch_need id_rehab_presc,
                                                NULL id_rehab_schedule,
                                                pk_sysdomain.get_domain('EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC',
                                                                        ei.id_software,
                                                                        i_lang) origin,
                                                pk_adt.is_contact(i_lang, i_prof, e.id_patient) flg_contact,
                                                decode(pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                               e.id_episode,
                                                                                               ei.id_schedule),
                                                       pk_alert_constant.g_no,
                                                       pk_alert_constant.g_yes,
                                                       pk_alert_constant.g_no) prof_follow_add,
                                                pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                        e.id_episode,
                                                                                        ei.id_schedule) prof_follow_remove,
                                                rank() over(PARTITION BY e.id_patient, rst.id_rehab_session_type ORDER BY rp.id_rehab_presc DESC) precedence_level,
                                                rp.id_rehab_presc id_lock_uq_value,
                                                'REHAB_GRID_PRESC' lock_func,
                                                get_grid_lock(i_lang, i_prof, 'REHAB_GRID_PRESC', rp.id_rehab_presc) id_lock
                                  FROM rehab_presc rp
                                  JOIN rehab_sch_need rsn
                                    ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                                  JOIN rehab_session_type rst
                                    ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                                  JOIN rehab_plan rbp
                                    ON rbp.id_episode_origin = rsn.id_episode_origin
                                  JOIN episode e
                                    ON e.id_episode = rsn.id_episode_origin -- falta este episódio
                                  JOIN rehab_environment r
                                    ON r.id_epis_type = e.id_epis_type
                                   AND r.id_institution = i_prof.institution
                                   AND r.id_rehab_environment IN
                                       (SELECT rep.id_rehab_environment
                                          FROM rehab_environment_prof rep
                                         WHERE rep.id_professional = i_prof.id)
                                  LEFT JOIN epis_info ei
                                    ON ei.id_episode = e.id_episode
                                  LEFT JOIN bed bd
                                    ON bd.id_bed = ei.id_bed
                                  LEFT JOIN room ro
                                    ON ro.id_room = bd.id_room
                                  LEFT JOIN department dpt
                                    ON dpt.id_department = ro.id_department
                                  LEFT JOIN rehab_epis_encounter re
                                    ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND
                                       l_dt_end AND re.id_rehab_sch_need = rsn.id_rehab_sch_need)
                                --para as areas em que está alocado
                                  JOIN rehab_area_interv rai
                                    ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                                  JOIN TABLE(find_prof_rehab_areas(i_prof.id, i_prof.institution)) x
                                    ON x.id_rehab_area = rai.id_rehab_area
                                 WHERE rsn.flg_status = g_rehab_sch_need_no_sched
                                   AND rp.flg_status NOT IN (g_rehab_presc_referral,
                                                             g_rehab_presc_not_order_reas,
                                                             pk_alert_constant.g_cancelled,
                                                             g_rehab_presc_discontinued)
                                   AND (re.flg_status IS NULL OR
                                       re.flg_status NOT IN (pk_rehab.g_rehab_epis_enc_status_o,
                                                              pk_rehab.g_rehab_epis_enc_status_c,
                                                              pk_rehab.g_rehab_epis_enc_status_f))
                                      --epis_origin activo
                                   AND e.flg_status = pk_alert_constant.g_active
                                   AND rp.id_institution = i_prof.institution
                                   AND (rsn.dt_begin IS NULL OR
                                       (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= 0 OR
                                       (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= -1 AND
                                       extract(DAY FROM(current_timestamp)) >= extract(DAY FROM(rsn.dt_begin)))))
                                      --For non scheduled sessions it is necessary to stop showing on the grid
                                      --requests that have a total of concluded sessions (or sessions started, but no concluded, over 24 hours ago)
                                      --equal to the number of requested sessions                                      
                                   AND (rsn.sessions >
                                       (SELECT COUNT(1)
                                           FROM rehab_epis_encounter ree_c
                                          WHERE ree_c.id_episode_origin = rsn.id_episode_origin
                                            AND ree_c.id_rehab_sch_need = rsn.id_rehab_sch_need
                                            AND (ree_c.flg_status IN (pk_rehab.g_rehab_epis_enc_status_o) OR
                                                (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_s AND
                                                ree_c.dt_creation < pk_date_utils.add_days_to_tstz(l_dt_begin, -1)) OR
                                                (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_f AND
                                                ree_c.flg_rehab_workflow_type = pk_rehab.g_workflow_type_s))))
                                   AND e.id_epis_type != pk_alert_constant.g_epis_type_rehab_appointment) t
                         WHERE t.precedence_level = 1
                        --Rehab_appointments
                        UNION ALL
                        SELECT DISTINCT s.id_schedule id_schedule,
                                        (SELECT cr.num_clin_record
                                           FROM clin_record cr
                                          WHERE cr.id_patient = e.id_patient
                                            AND cr.id_institution = i_prof.institution
                                            AND rownum < 2) num_clin_record,
                                        e.id_patient,
                                        e.id_episode id_episode_origin,
                                        nvl(re.id_episode_rehab, e.id_episode) id_episode,
                                        e.id_visit,
                                        pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode, NULL) name,
                                        pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) pat_ndo,
                                        pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) pat_nd_icon,
                                        pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) pat_age,
                                        (SELECT pk_sysdomain.get_domain('PATIENT.GENDER.ABBR', pat.gender, i_lang) gender
                                           FROM patient pat
                                          WHERE sg.id_patient = pat.id_patient) AS gender,
                                        pk_patphoto.get_pat_photo(i_lang, i_prof, e.id_patient, e.id_episode, NULL) photo,
                                        pk_prof_utils.get_name(i_lang, ei.id_professional) nick_name,
                                        pk_date_utils.date_char_hour_tsz(i_lang,
                                                                         re.dt_creation,
                                                                         i_prof.institution,
                                                                         i_prof.software) dt_efectiv,
                                        pk_date_utils.dt_chr_hour_tsz(i_lang,
                                                                      s.dt_begin_tstz,
                                                                      i_prof.institution,
                                                                      i_prof.software) dt_target,
                                        g_sysdate_char dt_server,
                                        pk_rehab.get_grid_workflow_icon(i_lang,
                                                                        i_prof,
                                                                        g_workflow_type_a,
                                                                        nvl(re.flg_status, g_rehab_epis_enc_status_a)) new_icon_name,
                                        1442 shortcut,
                                        pk_date_utils.date_send_tsz(i_lang, NULL, i_prof) AS dt_exec,
                                        get_rehab_app_status(i_lang, i_prof, e.id_patient, re.flg_status) AS flg_status,
                                        g_workflow_type_a AS flg_type,
                                        sp.id_epis_type AS id_schedule_type,
                                        l_appointment AS desc_schedule_type,
                                        NULL AS desc_session_type,
                                        NULL AS desc_service,
                                        NULL AS desc_room,
                                        NULL AS desc_bed,
                                        re.id_rehab_epis_encounter id_rehab_grid,
                                        NULL id_rehab_presc,
                                        NULL id_rehab_schedule,
                                        pk_sysdomain.get_domain('EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC',
                                                                ei.id_software,
                                                                i_lang) origin,
                                        pk_adt.is_contact(i_lang, i_prof, e.id_patient) flg_contact,
                                        decode(pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                       e.id_episode,
                                                                                       ei.id_schedule),
                                               pk_alert_constant.g_no,
                                               pk_alert_constant.g_yes,
                                               pk_alert_constant.g_no) prof_follow_add,
                                        pk_prof_follow.get_follow_episode_by_me(i_prof, e.id_episode, ei.id_schedule) prof_follow_remove,
                                        s.id_schedule id_lock_uq_value,
                                        'REHAB_GRID_SCHED' lock_func,
                                        get_grid_lock(i_lang, i_prof, 'REHAB_GRID_SCHED', s.id_schedule) id_lock
                          FROM schedule_outp sp
                          JOIN schedule s
                            ON s.id_schedule = sp.id_schedule
                          JOIN sch_group sg
                            ON sg.id_schedule = s.id_schedule
                          JOIN epis_info ei
                            ON s.id_schedule = ei.id_schedule
                          JOIN sch_prof_outp spo
                            ON spo.id_schedule_outp = sp.id_schedule_outp
                          JOIN sch_resource scr
                            ON s.id_schedule = scr.id_schedule
                          JOIN epis_type et
                            ON sp.id_epis_type = et.id_epis_type
                          JOIN episode e
                            ON ei.id_episode = e.id_episode
                          LEFT JOIN rehab_epis_encounter re
                            ON re.id_episode_origin = e.id_episode
                          JOIN rehab_environment r
                            ON r.id_epis_type = e.id_epis_type
                           AND r.id_institution = i_prof.institution
                           AND r.id_rehab_environment IN
                               (SELECT rep.id_rehab_environment
                                  FROM rehab_environment_prof rep
                                 WHERE rep.id_professional = i_prof.id)
                         WHERE s.flg_sch_type = l_flg_sch_type_cr
                           AND s.flg_status != pk_schedule.g_sched_status_cache -- agendamentos temporários (SCH 3.0)
                           AND pk_grid.get_schedule_real_state(sp.flg_state, e.flg_ehr) != pk_grid_amb.g_sched_adm_disch
                           AND s.flg_status != pk_alert_constant.g_flg_status_c
                           AND s.id_instit_requested = i_prof.institution
                           AND scr.id_professional = i_prof.id
                           AND sp.id_epis_type = l_epis_type_rehab_ap
                           AND sp.dt_target_tstz BETWEEN l_dt_begin AND l_dt_end
                           AND (l_show_med_disch = pk_alert_constant.g_yes OR
                               (l_show_med_disch = pk_alert_constant.g_no AND
                               pk_grid.get_schedule_real_state(sp.flg_state, e.flg_ehr) !=
                               pk_grid_amb.g_sched_med_disch))
                           AND e.id_epis_type != pk_alert_constant.g_epis_type_rehab_appointment
                        UNION ALL
                        -- planos de reabilitacao
                        SELECT DISTINCT NULL id_schedule,
                                        (SELECT cr.num_clin_record
                                           FROM clin_record cr
                                          WHERE cr.id_patient = e.id_patient
                                            AND cr.id_institution = i_prof.institution
                                            AND rownum < 2) num_clin_record,
                                        e.id_patient,
                                        e.id_episode id_episode_origin,
                                        nvl(re.id_episode_rehab, e.id_episode) id_episode,
                                        e.id_visit,
                                        pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode, NULL) name,
                                        pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) pat_ndo,
                                        pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) pat_nd_icon,
                                        pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) pat_age,
                                        pk_patient.get_pat_gender(e.id_patient) AS gender,
                                        pk_patphoto.get_pat_photo(i_lang, i_prof, e.id_patient, e.id_episode, NULL) photo,
                                        pk_prof_utils.get_name(i_lang, rep.id_prof_create) nick_name,
                                        pk_date_utils.date_char_hour_tsz(i_lang,
                                                                         rep.dt_rehab_epis_plan,
                                                                         i_prof.institution,
                                                                         i_prof.software) dt_efectiv,
                                        pk_date_utils.dt_chr_hour_tsz(i_lang, NULL, i_prof.institution, i_prof.software) dt_target,
                                        g_sysdate_char dt_server,
                                        get_grid_workflow_icon(i_lang,
                                                               i_prof,
                                                               g_workflow_type_w,
                                                               nvl(re.flg_status, g_rehab_epis_enc_status_e)) new_icon_name,
                                        1442 shortcut,
                                        pk_date_utils.date_send_tsz(i_lang, NULL, i_prof) AS dt_exec,
                                        nvl(re.flg_status, g_rehab_epis_enc_status_e) AS flg_status,
                                        g_workflow_type_w AS flg_type,
                                        1 AS id_schedule_type,
                                        l_session_without_schedule AS desc_schedule_type,
                                        pk_message.get_message(i_lang, 'REHAB_M050') AS desc_session_type,
                                        decode(bd.code_bed,
                                               NULL,
                                               NULL,
                                               nvl(pk_translation.get_translation(i_lang, dpt.abbreviation),
                                                   pk_translation.get_translation(i_lang, dpt.code_department))) desc_service,
                                        nvl(nvl(ro.desc_room_abbreviation,
                                                pk_translation.get_translation(i_lang, ro.code_abbreviation)),
                                            nvl(ro.desc_room, pk_translation.get_translation(i_lang, ro.code_room))) desc_room,
                                        nvl(bd.desc_bed, pk_translation.get_translation(i_lang, bd.code_bed)) desc_bed,
                                        NULL id_rehab_grid,
                                        NULL id_rehab_presc,
                                        NULL id_rehab_schedule,
                                        pk_sysdomain.get_domain('EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC',
                                                                ei.id_software,
                                                                i_lang) origin,
                                        pk_adt.is_contact(i_lang, i_prof, e.id_patient) flg_contact,
                                        decode(pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                       e.id_episode,
                                                                                       ei.id_schedule),
                                               pk_alert_constant.g_no,
                                               pk_alert_constant.g_yes,
                                               pk_alert_constant.g_no) prof_follow_add,
                                        pk_prof_follow.get_follow_episode_by_me(i_prof, e.id_episode, ei.id_schedule) prof_follow_remove,
                                        rep.id_rehab_epis_plan id_lock_uq_value,
                                        'REHAB_GRID_PLAN' lock_func,
                                        get_grid_lock(i_lang, i_prof, 'REHAB_GRID_PLAN', rep.id_rehab_epis_plan) id_lock
                          FROM rehab_epis_plan rep
                          JOIN rehab_epis_plan_team rept
                            ON (rept.id_rehab_epis_plan = rep.id_rehab_epis_plan AND rept.flg_status = 'Y')
                          JOIN prof_cat pc
                            ON (rept.id_prof_cat = pc.id_prof_cat AND pc.id_professional = i_prof.id)
                          JOIN episode e
                            ON (e.id_episode = nvl((SELECT DISTINCT ree.id_episode_origin
                                                     FROM rehab_epis_encounter ree
                                                    WHERE ree.id_episode_rehab = rep.id_episode),
                                                   rep.id_episode) AND e.id_institution = i_prof.institution)
                          JOIN rehab_environment r
                            ON r.id_epis_type = e.id_epis_type
                           AND r.id_institution = i_prof.institution
                           AND r.id_rehab_environment IN
                               (SELECT rep.id_rehab_environment
                                  FROM rehab_environment_prof rep
                                 WHERE rep.id_professional = i_prof.id)
                          LEFT JOIN epis_info ei
                            ON ei.id_episode = e.id_episode
                          LEFT JOIN bed bd
                            ON bd.id_bed = ei.id_bed
                          LEFT JOIN room ro
                            ON ro.id_room = bd.id_room
                          LEFT JOIN department dpt
                            ON dpt.id_department = ro.id_department
                          LEFT JOIN rehab_epis_encounter re
                            ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND l_dt_end)
                         WHERE e.id_episode NOT IN (SELECT rsn.id_episode_origin
                                                      FROM rehab_sch_need rsn)
                           AND rep.flg_status = 'O'
                           AND e.id_epis_type != pk_alert_constant.g_epis_type_rehab_appointment)
                 ORDER BY pk_sysdomain.get_rank(i_lang, g_rehab_epis_enc_flg_status, flg_status), dt_target, name;
        ELSE
            --All patients
            OPEN o_patients FOR
                SELECT *
                  FROM (SELECT DISTINCT rs.id_schedule id_schedule,
                                        (SELECT cr.num_clin_record
                                           FROM clin_record cr
                                          WHERE cr.id_patient = rp.id_patient
                                            AND cr.id_institution = i_prof.institution
                                            AND rownum < 2) num_clin_record,
                                        e.id_patient,
                                        e.id_episode id_episode_origin,
                                        nvl(re.id_episode_rehab, e.id_episode) id_episode,
                                        e.id_visit,
                                        pk_patient.get_pat_name(i_lang,
                                                                i_prof,
                                                                e.id_patient,
                                                                e.id_episode,
                                                                rs.id_schedule) name,
                                        pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) pat_ndo,
                                        pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) pat_nd_icon,
                                        pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) pat_age,
                                        pk_patient.get_pat_gender(e.id_patient) AS gender,
                                        pk_patphoto.get_pat_photo(i_lang,
                                                                  i_prof,
                                                                  e.id_patient,
                                                                  e.id_episode,
                                                                  rs.id_schedule) photo,
                                        get_rehab_sch_need_resp(i_lang,
                                                                rsn.id_resp_professional,
                                                                rsn.id_resp_rehab_group) nick_name,
                                        pk_date_utils.date_char_hour_tsz(i_lang,
                                                                         decode(re.id_episode_rehab,
                                                                                NULL,
                                                                                NULL,
                                                                                re.dt_creation),
                                                                         i_prof.institution,
                                                                         i_prof.software) dt_efectiv,
                                        pk_date_utils.dt_chr_hour_tsz(i_lang,
                                                                      s.dt_begin_tstz,
                                                                      i_prof.institution,
                                                                      i_prof.software) dt_target,
                                        g_sysdate_char dt_server,
                                        get_grid_workflow_icon(i_lang,
                                                               i_prof,
                                                               g_workflow_type_s,
                                                               nvl(re.flg_status, 'A')) new_icon_name,
                                        -1 shortcut,
                                        pk_date_utils.date_send_tsz(i_lang, s.dt_schedule_tstz, i_prof) AS dt_exec,
                                        nvl(re.flg_status, 'A') AS flg_status,
                                        g_workflow_type_s AS flg_type,
                                        1 AS id_schedule_type,
                                        l_session_without_schedule AS desc_schedule_type,
                                        pk_translation.get_translation(i_lang, rst.code_rehab_session_type) AS desc_session_type,
                                        decode(bd.code_bed,
                                               NULL,
                                               NULL,
                                               nvl(pk_translation.get_translation(i_lang, dpt.abbreviation),
                                                   pk_translation.get_translation(i_lang, dpt.code_department))) desc_service,
                                        nvl(nvl(ro.desc_room_abbreviation,
                                                pk_translation.get_translation(i_lang, ro.code_abbreviation)),
                                            nvl(ro.desc_room, pk_translation.get_translation(i_lang, ro.code_room))) desc_room,
                                        nvl(bd.desc_bed, pk_translation.get_translation(i_lang, bd.code_bed)) desc_bed,
                                        re.id_rehab_epis_encounter id_rehab_grid,
                                        rsn.id_rehab_sch_need id_rehab_presc,
                                        rs.id_rehab_schedule id_rehab_schedule,
                                        pk_sysdomain.get_domain('EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC',
                                                                ei.id_software,
                                                                i_lang) origin,
                                        pk_adt.is_contact(i_lang, i_prof, e.id_patient) flg_contact,
                                        decode(pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                       e.id_episode,
                                                                                       ei.id_schedule),
                                               pk_alert_constant.g_no,
                                               pk_alert_constant.g_yes,
                                               pk_alert_constant.g_no) prof_follow_add,
                                        pk_prof_follow.get_follow_episode_by_me(i_prof, e.id_episode, ei.id_schedule) prof_follow_remove,
                                        s.id_schedule id_lock_uq_value,
                                        'REHAB_GRID_SCHED' lock_func,
                                        get_grid_lock(i_lang, i_prof, 'REHAB_GRID_SCHED', rs.id_schedule) id_lock
                          FROM rehab_schedule rs
                          JOIN schedule s
                            ON s.id_schedule = rs.id_schedule
                          JOIN rehab_sch_need rsn
                            ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
                          JOIN rehab_session_type rst
                            ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                          JOIN rehab_presc rpres
                            ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                          JOIN rehab_plan rp
                            ON rp.id_episode_origin = rsn.id_episode_origin
                          JOIN episode e
                            ON e.id_episode = rsn.id_episode_origin -- falta este episódio
                          JOIN rehab_environment r
                            ON r.id_epis_type = e.id_epis_type
                           AND r.id_institution = i_prof.institution
                           AND r.id_rehab_environment IN
                               (SELECT rep.id_rehab_environment
                                  FROM rehab_environment_prof rep
                                 WHERE rep.id_professional = i_prof.id)
                          JOIN epis_info ei
                            ON ei.id_episode = e.id_episode
                          LEFT JOIN bed bd
                            ON bd.id_bed = ei.id_bed
                          LEFT JOIN room ro
                            ON (ro.id_room = s.id_room OR ro.id_room = bd.id_room)
                          LEFT JOIN department dpt
                            ON dpt.id_department = ro.id_department
                          LEFT JOIN rehab_epis_encounter re
                            ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND l_dt_end AND
                               re.id_rehab_sch_need = rsn.id_rehab_sch_need)
                         WHERE s.dt_begin_tstz BETWEEN l_dt_begin AND l_dt_end
                           AND rs.flg_status = g_rehab_schedule_scheduled
                           AND s.id_instit_requested = i_prof.institution
                           AND s.flg_status != pk_schedule.g_sched_status_temporary
                           AND s.flg_status != pk_schedule.g_sched_status_cache
                           AND rpres.flg_status NOT IN (pk_alert_constant.g_cancelled, g_rehab_presc_discontinued)
                              --epis_origin activo
                           AND ((e.flg_status = pk_alert_constant.g_active AND
                               pk_sysconfig.get_config(i_prof => i_prof, i_code_cf => 'REHAB_NEEDS_SCHEDULE') =
                               pk_alert_constant.g_no) OR
                               (pk_sysconfig.get_config(i_prof => i_prof, i_code_cf => 'REHAB_NEEDS_SCHEDULE') =
                               pk_alert_constant.g_yes) AND s.id_schedule IS NOT NULL)
                           AND e.id_epis_type != pk_alert_constant.g_epis_type_rehab_appointment
                        --se estiver alocado à área de reabilitação
                        
                        UNION ALL
                        -- pacientes com tratamentos sem agendamento
                        SELECT id_schedule,
                               num_clin_record,
                               id_patient,
                               id_episode_origin,
                               id_episode,
                               id_visit,
                               name,
                               pat_ndo,
                               pat_nd_icon,
                               pat_age,
                               gender,
                               photo,
                               nick_name,
                               dt_efectiv,
                               dt_target,
                               dt_server,
                               new_icon_name,
                               shortcut,
                               dt_exec,
                               flg_status,
                               flg_type,
                               id_schedule_type,
                               desc_schedule_type,
                               desc_session_type,
                               desc_service,
                               desc_room,
                               desc_bed,
                               id_rehab_grid,
                               id_rehab_presc,
                               id_rehab_schedule,
                               origin,
                               flg_contact,
                               prof_follow_add,
                               prof_follow_remove,
                               id_lock_uq_value,
                               lock_func,
                               id_lock
                          FROM (SELECT DISTINCT NULL id_schedule,
                                                (SELECT cr.num_clin_record
                                                   FROM clin_record cr
                                                  WHERE cr.id_patient = rbp.id_patient
                                                    AND cr.id_institution = i_prof.institution
                                                    AND rownum < 2) num_clin_record,
                                                e.id_patient,
                                                e.id_episode id_episode_origin,
                                                nvl(re.id_episode_rehab, e.id_episode) id_episode,
                                                e.id_visit,
                                                pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode, NULL) name,
                                                pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) pat_ndo,
                                                pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) pat_nd_icon,
                                                pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) pat_age,
                                                pk_patient.get_pat_gender(e.id_patient) AS gender,
                                                pk_patphoto.get_pat_photo(i_lang,
                                                                          i_prof,
                                                                          e.id_patient,
                                                                          e.id_episode,
                                                                          NULL) photo,
                                                get_rehab_sch_need_resp(i_lang,
                                                                        rsn.id_resp_professional,
                                                                        rsn.id_resp_rehab_group) nick_name,
                                                pk_date_utils.date_char_hour_tsz(i_lang,
                                                                                 re.dt_creation,
                                                                                 i_prof.institution,
                                                                                 i_prof.software) dt_efectiv,
                                                pk_date_utils.dt_chr_hour_tsz(i_lang,
                                                                              NULL,
                                                                              i_prof.institution,
                                                                              i_prof.software) dt_target,
                                                g_sysdate_char dt_server,
                                                get_grid_workflow_icon(i_lang, i_prof, 'W', nvl(re.flg_status, 'E')) new_icon_name,
                                                -1 shortcut,
                                                pk_date_utils.date_send_tsz(i_lang, NULL, i_prof) AS dt_exec,
                                                nvl(re.flg_status, 'E') AS flg_status,
                                                g_workflow_type_w AS flg_type,
                                                1 AS id_schedule_type,
                                                l_session_without_schedule AS desc_schedule_type,
                                                pk_translation.get_translation(i_lang, rst.code_rehab_session_type) AS desc_session_type,
                                                decode(bd.code_bed,
                                                       NULL,
                                                       NULL,
                                                       nvl(pk_translation.get_translation(i_lang, dpt.abbreviation),
                                                           pk_translation.get_translation(i_lang, dpt.code_department))) desc_service,
                                                nvl(nvl(ro.desc_room_abbreviation,
                                                        pk_translation.get_translation(i_lang, ro.code_abbreviation)),
                                                    nvl(ro.desc_room, pk_translation.get_translation(i_lang, ro.code_room))) desc_room,
                                                nvl(bd.desc_bed, pk_translation.get_translation(i_lang, bd.code_bed)) desc_bed,
                                                re.id_rehab_epis_encounter id_rehab_grid,
                                                rsn.id_rehab_sch_need id_rehab_presc,
                                                NULL id_rehab_schedule,
                                                pk_sysdomain.get_domain('EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC',
                                                                        ei.id_software,
                                                                        i_lang) origin,
                                                pk_adt.is_contact(i_lang, i_prof, e.id_patient) flg_contact,
                                                decode(pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                               e.id_episode,
                                                                                               ei.id_schedule),
                                                       pk_alert_constant.g_no,
                                                       pk_alert_constant.g_yes,
                                                       pk_alert_constant.g_no) prof_follow_add,
                                                pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                        e.id_episode,
                                                                                        ei.id_schedule) prof_follow_remove,
                                                rank() over(PARTITION BY e.id_patient, rst.id_rehab_session_type ORDER BY rp.id_rehab_presc DESC) precedence_level,
                                                rp.id_rehab_presc id_lock_uq_value,
                                                'REHAB_GRID_PRESC' lock_func,
                                                get_grid_lock(i_lang, i_prof, 'REHAB_GRID_PRESC', rp.id_rehab_presc) id_lock
                                  FROM rehab_presc rp
                                  JOIN rehab_sch_need rsn
                                    ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                                  JOIN rehab_session_type rst
                                    ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                                  JOIN rehab_plan rbp
                                    ON rbp.id_episode_origin = rsn.id_episode_origin
                                  JOIN episode e
                                    ON e.id_episode = rsn.id_episode_origin -- falta este episódio
                                  JOIN rehab_environment r
                                    ON r.id_epis_type = e.id_epis_type
                                   AND r.id_institution = i_prof.institution
                                   AND r.id_rehab_environment IN
                                       (SELECT rep.id_rehab_environment
                                          FROM rehab_environment_prof rep
                                         WHERE rep.id_professional = i_prof.id)
                                  LEFT JOIN epis_info ei
                                    ON ei.id_episode = e.id_episode
                                  LEFT JOIN rehab_epis_encounter re
                                    ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND
                                       l_dt_end AND re.id_rehab_sch_need = rsn.id_rehab_sch_need)
                                  LEFT JOIN bed bd
                                    ON bd.id_bed = ei.id_bed
                                  LEFT JOIN room ro
                                    ON ro.id_room = bd.id_room
                                  LEFT JOIN department dpt
                                    ON dpt.id_department = ro.id_department
                                 WHERE rsn.flg_status = g_rehab_sch_need_no_sched
                                   AND rp.flg_status NOT IN (g_rehab_presc_referral,
                                                             g_rehab_presc_not_order_reas,
                                                             pk_alert_constant.g_cancelled,
                                                             g_rehab_presc_discontinued)
                                   AND (re.flg_status IS NULL OR
                                       re.flg_status NOT IN (pk_rehab.g_rehab_epis_enc_status_o,
                                                              pk_rehab.g_rehab_epis_enc_status_c,
                                                              pk_rehab.g_rehab_epis_enc_status_f))
                                      --epis_origin activo
                                   AND e.flg_status = pk_alert_constant.g_active
                                   AND rp.id_institution = i_prof.institution
                                   AND (rsn.dt_begin IS NULL OR
                                       (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= 0 OR
                                       (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= -1 AND
                                       extract(DAY FROM(current_timestamp)) >= extract(DAY FROM(rsn.dt_begin)))))
                                      --For non scheduled sessions it is necessary to stop showing on the grid
                                      --requests that have a total of concluded sessions (or sessions started, but no concluded, over 24 hours ago)
                                      --equal to the number of requested sessions                                         
                                   AND (rsn.sessions >
                                       (SELECT COUNT(1)
                                           FROM rehab_epis_encounter ree_c
                                          WHERE ree_c.id_episode_origin = rsn.id_episode_origin
                                            AND ree_c.id_rehab_sch_need = rsn.id_rehab_sch_need
                                            AND (ree_c.flg_status IN (pk_rehab.g_rehab_epis_enc_status_o) OR
                                                (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_s AND
                                                ree_c.dt_creation < pk_date_utils.add_days_to_tstz(l_dt_begin, -1)) OR
                                                (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_f AND
                                                ree_c.flg_rehab_workflow_type = pk_rehab.g_workflow_type_s))))
                                   AND e.id_epis_type != pk_alert_constant.g_epis_type_rehab_appointment) t
                         WHERE t.precedence_level = 1
                        --Rehab_appointments
                        UNION ALL
                        SELECT DISTINCT s.id_schedule id_schedule,
                                        (SELECT cr.num_clin_record
                                           FROM clin_record cr
                                          WHERE cr.id_patient = e.id_patient
                                            AND cr.id_institution = i_prof.institution
                                            AND rownum < 2) num_clin_record,
                                        e.id_patient,
                                        e.id_episode id_episode_origin,
                                        nvl(re.id_episode_rehab, e.id_episode) id_episode,
                                        e.id_visit,
                                        pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode, NULL) name,
                                        pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) pat_ndo,
                                        pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) pat_nd_icon,
                                        pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) pat_age,
                                        (SELECT pk_sysdomain.get_domain('PATIENT.GENDER.ABBR', pat.gender, i_lang) gender
                                           FROM patient pat
                                          WHERE sg.id_patient = pat.id_patient) AS gender,
                                        pk_patphoto.get_pat_photo(i_lang, i_prof, e.id_patient, e.id_episode, NULL) photo,
                                        pk_prof_utils.get_name(i_lang, ei.id_professional) nick_name,
                                        pk_date_utils.date_char_hour_tsz(i_lang,
                                                                         re.dt_creation,
                                                                         i_prof.institution,
                                                                         i_prof.software) dt_efectiv,
                                        pk_date_utils.dt_chr_hour_tsz(i_lang,
                                                                      s.dt_begin_tstz,
                                                                      i_prof.institution,
                                                                      i_prof.software) dt_target,
                                        g_sysdate_char dt_server,
                                        pk_rehab.get_grid_workflow_icon(i_lang,
                                                                        i_prof,
                                                                        g_workflow_type_a,
                                                                        nvl(re.flg_status, g_rehab_epis_enc_status_a)) new_icon_name,
                                        1442 shortcut,
                                        pk_date_utils.date_send_tsz(i_lang, NULL, i_prof) AS dt_exec,
                                        get_rehab_app_status(i_lang, i_prof, e.id_patient, re.flg_status) AS flg_status,
                                        g_workflow_type_a AS flg_type,
                                        sp.id_epis_type AS id_schedule_type,
                                        l_appointment AS desc_schedule_type,
                                        NULL AS desc_session_type,
                                        NULL AS desc_service,
                                        NULL AS desc_room,
                                        NULL AS desc_bed,
                                        re.id_rehab_epis_encounter id_rehab_grid,
                                        NULL id_rehab_presc,
                                        NULL id_rehab_schedule,
                                        pk_sysdomain.get_domain('EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC',
                                                                ei.id_software,
                                                                i_lang) origin,
                                        pk_adt.is_contact(i_lang, i_prof, e.id_patient) flg_contact,
                                        decode(pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                       e.id_episode,
                                                                                       ei.id_schedule),
                                               pk_alert_constant.g_no,
                                               pk_alert_constant.g_yes,
                                               pk_alert_constant.g_no) prof_follow_add,
                                        pk_prof_follow.get_follow_episode_by_me(i_prof, e.id_episode, ei.id_schedule) prof_follow_remove,
                                        s.id_schedule id_lock_uq_value,
                                        'REHAB_GRID_SCHED' lock_func,
                                        get_grid_lock(i_lang, i_prof, 'REHAB_GRID_SCHED', s.id_schedule) id_lock
                          FROM schedule_outp sp
                          JOIN schedule s
                            ON s.id_schedule = sp.id_schedule
                          JOIN sch_group sg
                            ON sg.id_schedule = s.id_schedule
                          JOIN epis_info ei
                            ON s.id_schedule = ei.id_schedule
                          JOIN epis_type et
                            ON sp.id_epis_type = et.id_epis_type
                          JOIN episode e
                            ON ei.id_episode = e.id_episode
                          LEFT JOIN rehab_epis_encounter re
                            ON re.id_episode_origin = e.id_episode
                          JOIN rehab_environment r
                            ON r.id_epis_type = e.id_epis_type
                           AND r.id_institution = i_prof.institution
                           AND r.id_rehab_environment IN
                               (SELECT rep.id_rehab_environment
                                  FROM rehab_environment_prof rep
                                 WHERE rep.id_professional = i_prof.id)
                         WHERE s.flg_sch_type = l_flg_sch_type_cr
                           AND s.flg_status != pk_schedule.g_sched_status_cache -- agendamentos temporários (SCH 3.0)
                           AND pk_grid.get_schedule_real_state(sp.flg_state, e.flg_ehr) != pk_grid_amb.g_sched_adm_disch
                           AND s.flg_status != pk_alert_constant.g_flg_status_c
                           AND s.id_instit_requested = i_prof.institution
                           AND sp.id_epis_type = l_epis_type_rehab_ap
                           AND sp.dt_target_tstz BETWEEN l_dt_begin AND l_dt_end
                           AND (l_show_med_disch = pk_alert_constant.g_yes OR
                               (l_show_med_disch = pk_alert_constant.g_no AND
                               pk_grid.get_schedule_real_state(sp.flg_state, e.flg_ehr) !=
                               pk_grid_amb.g_sched_med_disch))
                           AND e.id_epis_type != pk_alert_constant.g_epis_type_rehab_appointment
                        UNION ALL
                        -- planos de reabilitacao
                        SELECT DISTINCT NULL id_schedule,
                                        (SELECT cr.num_clin_record
                                           FROM clin_record cr
                                          WHERE cr.id_patient = e.id_patient
                                            AND cr.id_institution = i_prof.institution
                                            AND rownum < 2) num_clin_record,
                                        e.id_patient,
                                        e.id_episode id_episode_origin,
                                        nvl(re.id_episode_rehab, e.id_episode) id_episode,
                                        e.id_visit,
                                        pk_patient.get_pat_name(i_lang, i_prof, e.id_patient, e.id_episode, NULL) name,
                                        pk_adt.get_pat_non_disc_options(i_lang, i_prof, e.id_patient) pat_ndo,
                                        pk_adt.get_pat_non_disclosure_icon(i_lang, i_prof, e.id_patient) pat_nd_icon,
                                        pk_patient.get_pat_age(i_lang, e.id_patient, i_prof) pat_age,
                                        pk_patient.get_pat_gender(e.id_patient) AS gender,
                                        pk_patphoto.get_pat_photo(i_lang, i_prof, e.id_patient, e.id_episode, NULL) photo,
                                        pk_prof_utils.get_name(i_lang, rep.id_prof_create) nick_name,
                                        pk_date_utils.date_char_hour_tsz(i_lang,
                                                                         rep.dt_rehab_epis_plan,
                                                                         i_prof.institution,
                                                                         i_prof.software) dt_efectiv,
                                        pk_date_utils.dt_chr_hour_tsz(i_lang, NULL, i_prof.institution, i_prof.software) dt_target,
                                        g_sysdate_char dt_server,
                                        get_grid_workflow_icon(i_lang,
                                                               i_prof,
                                                               g_workflow_type_w,
                                                               nvl(re.flg_status, g_rehab_epis_enc_status_e)) new_icon_name,
                                        1442 shortcut,
                                        pk_date_utils.date_send_tsz(i_lang, NULL, i_prof) AS dt_exec,
                                        --rs.flg_status 
                                        nvl(re.flg_status, g_rehab_epis_enc_status_e) AS flg_status,
                                        g_workflow_type_w AS flg_type,
                                        1 AS id_schedule_type,
                                        l_session_without_schedule AS desc_schedule_type,
                                        pk_message.get_message(i_lang, 'REHAB_M050') AS desc_session_type,
                                        decode(bd.code_bed,
                                               NULL,
                                               NULL,
                                               nvl(pk_translation.get_translation(i_lang, dpt.abbreviation),
                                                   pk_translation.get_translation(i_lang, dpt.code_department))) desc_service,
                                        nvl(nvl(ro.desc_room_abbreviation,
                                                pk_translation.get_translation(i_lang, ro.code_abbreviation)),
                                            nvl(ro.desc_room, pk_translation.get_translation(i_lang, ro.code_room))) desc_room,
                                        nvl(bd.desc_bed, pk_translation.get_translation(i_lang, bd.code_bed)) desc_bed,
                                        NULL id_rehab_grid,
                                        NULL id_rehab_presc,
                                        NULL id_rehab_schedule,
                                        pk_sysdomain.get_domain('EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC',
                                                                ei.id_software,
                                                                i_lang) origin,
                                        pk_adt.is_contact(i_lang, i_prof, e.id_patient) flg_contact,
                                        decode(pk_prof_follow.get_follow_episode_by_me(i_prof,
                                                                                       e.id_episode,
                                                                                       ei.id_schedule),
                                               pk_alert_constant.g_no,
                                               pk_alert_constant.g_yes,
                                               pk_alert_constant.g_no) prof_follow_add,
                                        pk_prof_follow.get_follow_episode_by_me(i_prof, e.id_episode, ei.id_schedule) prof_follow_remove,
                                        rep.id_rehab_epis_plan id_lock_uq_value,
                                        'REHAB_GRID_PLAN' lock_func,
                                        get_grid_lock(i_lang, i_prof, 'REHAB_GRID_PLAN', rep.id_rehab_epis_plan) id_lock
                          FROM rehab_epis_plan rep
                          JOIN episode e
                            ON (e.id_episode = nvl((SELECT DISTINCT ree.id_episode_origin
                                                     FROM rehab_epis_encounter ree
                                                    WHERE ree.id_episode_rehab = rep.id_episode),
                                                   rep.id_episode) AND e.id_institution = i_prof.institution)
                          JOIN rehab_environment r
                            ON r.id_epis_type = e.id_epis_type
                           AND r.id_institution = i_prof.institution
                           AND r.id_rehab_environment IN
                               (SELECT rep.id_rehab_environment
                                  FROM rehab_environment_prof rep
                                 WHERE rep.id_professional = i_prof.id)
                          LEFT JOIN epis_info ei
                            ON ei.id_episode = e.id_episode
                          LEFT JOIN bed bd
                            ON bd.id_bed = ei.id_bed
                          LEFT JOIN room ro
                            ON ro.id_room = bd.id_room
                          LEFT JOIN department dpt
                            ON dpt.id_department = ro.id_department
                          LEFT JOIN rehab_epis_encounter re
                            ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND l_dt_end)
                         WHERE e.id_episode NOT IN (SELECT rsn.id_episode_origin
                                                      FROM rehab_sch_need rsn)
                           AND rep.flg_status = 'O'
                           AND e.id_epis_type != pk_alert_constant.g_epis_type_rehab_appointment)
                 ORDER BY pk_sysdomain.get_rank(i_lang, g_rehab_epis_enc_flg_status, flg_status), dt_target, name;
        END IF;
        g_error := 'TOO MANY RESULTS';
        IF l_count > l_limit
        THEN
            o_flg_show  := 'Y';
            o_button    := 'R';
            o_msg       := pk_search.get_overlimit_message(i_lang => i_lang, i_prof => i_prof, i_flg_has_action => 'Y');
            o_msg_title := pk_message.get_message(i_lang, 'SEARCH_CRITERIA_T011');
        
            g_error := 'NO RESULTS';
        ELSIF l_count = 0
        THEN
            o_flg_show  := 'Y';
            o_button    := 'R';
            o_msg       := pk_message.get_message(i_lang, 'COMMON_M015');
            o_msg_title := pk_message.get_message(i_lang, 'SEARCH_CRITERIA_T019');
        ELSE
            g_error := 'OPEN CURSOR';
        END IF;
    
        pk_types.open_cursor_if_closed(o_patients);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_types.open_cursor_if_closed(o_patients);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_patients_grid;

    /**********************************************************************************************
    * aloca um profissional ou um grupo a uma necessidade de agendamento
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_sch_need      schedule need
    * %param i_id_resp                responsible professional or group
    * %param i_type                   type of responsible H-professional G-Group
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION set_alloc_prof_sch_need
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_id_resp           IN NUMBER,
        i_type              IN VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_ALLOC_PROF_SCH_NEED';
        l_rowids table_varchar;
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_error := 'copy to history i_id_rehab_sch_need=' || i_id_rehab_sch_need || ',i_id_resp=' || i_id_resp ||
                   ',i_type=' || i_type;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        IF NOT set_rehab_sch_need_hist(i_lang              => i_lang,
                                       i_prof              => i_prof,
                                       i_id_rehab_sch_need => i_id_rehab_sch_need,
                                       i_commit            => pk_alert_constant.get_no(),
                                       o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'update i_id_rehab_sch_need=' || i_id_rehab_sch_need;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        ts_rehab_sch_need.upd(id_rehab_sch_need_in     => i_id_rehab_sch_need,
                              id_resp_professional_in  => CASE i_type
                                                              WHEN g_list_type_prof_abbr THEN
                                                               i_id_resp
                                                              ELSE
                                                               NULL
                                                          END,
                              id_resp_professional_nin => FALSE,
                              id_resp_rehab_group_in   => CASE i_type
                                                              WHEN g_list_type_group_abbr THEN
                                                               i_id_resp
                                                              ELSE
                                                               NULL
                                                          END,
                              id_resp_rehab_group_nin  => FALSE,
                              flg_status_in            => g_rehab_sch_need_scheduled,
                              rows_out                 => l_rowids);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_utils.undo_changes();
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_alloc_prof_sch_need;
    --
    /********************************************************************************************
    * Get the detail for the Rehabilitation treatments
    *
    * @param i_lang                   Preferred language ID for this professional 
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_id_rehab_presc         Rehabilitaion prescription ID
    * @param o_rehab_treatment        Treatments details
    * @param o_rehab_treatment_prof   Professional details
    * @param o_rehab_session_detail
    *
    * @param o_error                  Error
    *
    * @return                         true or false on success or error
    *
    * @author                          Orlando Antunes
    * @version                         2.6.0.3
    * @since                           2010/07/
    **********************************************************************************************/
    FUNCTION get_rehab_treatment_detail
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_rehab_presc       IN rehab_presc.id_rehab_presc%TYPE,
        o_rehab_treatment      OUT pk_types.cursor_type,
        o_rehab_treatment_prof OUT pk_types.cursor_type,
        o_rehab_session_detail OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_TREATMENT_DETAIL';
    BEGIN
        --
        g_error := 'GET_REHAB_TREATMENT_DETAIL: i_id_rehab_presc = ' || i_id_rehab_presc;
        pk_alertlog.log_debug(g_error);
    
        --
        IF i_id_rehab_presc IS NULL
        THEN
            --
            raise_application_error(-20100, 'Invalid Input Parameters');
        ELSE
            g_error := 'OPEN o_rehab_treatment CURSOR';
            OPEN o_rehab_treatment FOR
                SELECT rp_id_rehab_presc_hist id,
                       --name
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_T074') || g_colon,
                                     nvl2(id_prev_hist,
                                          NULL,
                                          pk_procedures_api_db.get_alias_translation(i_lang,
                                                                                     i_prof,
                                                                                     x_code_intervention,
                                                                                     NULL))) treatment_name,
                       --desc_laterality                                          
                       table_varchar(pk_message.get_message(i_lang, 'ELECTR_PRESC_T002'),
                                     decode(rp_flg_laterality,
                                            (SELECT flg_laterality
                                               FROM rehab_presc_hist
                                              WHERE id_rehab_presc_hist = id_prev_hist),
                                            NULL,
                                            pk_sysdomain.get_domain('REHAB_PRESC_HIST.FLG_LATERALITY',
                                                                    rp_flg_laterality,
                                                                    i_lang))) AS desc_laterality,
                       --instructions
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_T104'),
                                     decode(rp_flg_status,
                                            g_rehab_presc_cancel,
                                            NULL,
                                            g_rehab_presc_chg_rejected,
                                            NULL,
                                            g_rehab_presc_suspend,
                                            NULL,
                                            g_rehab_presc_discontinued,
                                            NULL,
                                            decode(get_instructions(i_lang, i_prof, rsn_id_rehab_sch_need),
                                                   get_instructions(i_lang,
                                                                    i_prof,
                                                                    (SELECT id_rehab_sch_need
                                                                       FROM rehab_presc_hist
                                                                      WHERE id_rehab_presc_hist = id_prev_hist)),
                                                   NULL,
                                                   get_instructions(i_lang, i_prof, rsn_id_rehab_sch_need)))) treatment_inst,
                       --area
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_T030') || g_colon,
                                     decode(rp_flg_status,
                                            g_rehab_presc_cancel,
                                            NULL,
                                            g_rehab_presc_chg_rejected,
                                            NULL,
                                            g_rehab_presc_suspend,
                                            NULL,
                                            g_rehab_presc_discontinued,
                                            NULL,
                                            nvl2(id_prev_hist, NULL, get_rehab_area_name(i_lang, x_id_rehab_area)))) rehab_area,
                       --session type
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_T114'),
                                     decode(rp_flg_status,
                                            g_rehab_presc_cancel,
                                            NULL,
                                            g_rehab_presc_chg_rejected,
                                            NULL,
                                            g_rehab_presc_suspend,
                                            NULL,
                                            g_rehab_presc_discontinued,
                                            NULL,
                                            nvl2(id_prev_hist, NULL, get_rehab_area_name(i_lang, x_id_rehab_area)))) session_type,
                       --exec_place
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_T112'),
                                     decode(rp_flg_status,
                                            g_rehab_presc_cancel,
                                            NULL,
                                            g_rehab_presc_chg_rejected,
                                            NULL,
                                            g_rehab_presc_suspend,
                                            NULL,
                                            g_rehab_presc_discontinued,
                                            NULL,
                                            decode(rp_id_exec_institution,
                                                   (SELECT id_exec_institution
                                                      FROM rehab_presc_hist
                                                     WHERE id_rehab_presc_hist = id_prev_hist),
                                                   NULL,
                                                   pk_utils.get_institution_name(i_lang, rp_id_exec_institution)))) exec_place,
                       --exec_per_session
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_T113'),
                                     decode(rp_flg_status,
                                            g_rehab_presc_cancel,
                                            NULL,
                                            g_rehab_presc_chg_rejected,
                                            NULL,
                                            g_rehab_presc_suspend,
                                            NULL,
                                            g_rehab_presc_discontinued,
                                            NULL,
                                            decode(rp_exec_per_session,
                                                   (SELECT exec_per_session
                                                      FROM rehab_presc_hist
                                                     WHERE id_rehab_presc_hist = id_prev_hist),
                                                   NULL,
                                                   rp_exec_per_session))) exec_per_session,
                       --notas
                       table_varchar(pk_message.get_message(i_lang, 'COMMON_M044'),
                                     decode(rp_notes,
                                            (SELECT notes
                                               FROM rehab_presc_hist
                                              WHERE id_rehab_presc_hist = id_prev_hist),
                                            NULL,
                                            nvl(rp_notes, ' '))) notes,
                       --cancel_reason
                       table_varchar(pk_message.get_message(i_lang, 'COMMON_M072') || g_colon,
                                     decode(rp_flg_status,
                                            g_rehab_presc_chg_rejected,
                                            NULL,
                                            pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, rp_id_cancel_reason))) cancel_reason,
                       --cancel_notes
                       table_varchar(pk_message.get_message(i_lang, 'COMMON_M073') || g_colon,
                                     decode(rp_flg_status, g_rehab_presc_chg_rejected, NULL, rp_notes_cancel)) cancel_notes,
                       --change notes
                       table_varchar(pk_message.get_message(i_lang, 'COMMON_M044'),
                                     decode(rp_flg_status, g_rehab_presc_cancel, NULL, rp_notes_change)) AS change_notes,
                       --not order reason     
                       table_varchar(pk_message.get_message(i_lang, pk_not_order_reason_db.g_mcode_reas_not_order),
                                     decode(rp_flg_status,
                                            g_rehab_presc_not_order_reas,
                                            pk_not_order_reason_db.get_not_order_reason_desc(i_lang             => i_lang,
                                                                                             i_not_order_reason => rp_id_not_order_reason),
                                            NULL)) AS desc_not_order_reason,
                       --change status              
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_M012'),
                                     decode(rp_flg_status,
                                            (SELECT flg_status
                                               FROM rehab_presc_hist
                                              WHERE id_rehab_presc_hist = id_prev_hist),
                                            NULL,
                                            pk_sysdomain.get_domain('REHAB_PRESC_HIST.FLG_STATUS', rp_flg_status, i_lang))) AS change_status
                
                  FROM (SELECT rp.id_rehab_presc_hist rp_id_rehab_presc_hist,
                               rp.flg_status rp_flg_status,
                               rp.notes_cancel rp_notes_cancel,
                               rp.notes_change rp_notes_change,
                               rp.notes rp_notes,
                               rp.id_cancel_reason rp_id_cancel_reason,
                               rp.exec_per_session rp_exec_per_session,
                               rp.id_exec_institution rp_id_exec_institution,
                               x.id_rehab_area x_id_rehab_area,
                               x.code_intervention x_code_intervention,
                               rsn.id_rehab_sch_need rsn_id_rehab_sch_need,
                               (SELECT MAX(r.id_rehab_presc_hist)
                                  FROM rehab_presc_hist r
                                 WHERE r.id_rehab_presc = rp.id_rehab_presc
                                   AND (r.id_rehab_presc_hist < rp.id_rehab_presc_hist)) id_prev_hist,
                               rp.flg_laterality rp_flg_laterality,
                               rp.id_not_order_reason rp_id_not_order_reason
                          FROM rehab_presc_hist rp
                          JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) x
                            ON x.id_rehab_area_interv = rp.id_rehab_area_interv
                          JOIN rehab_sch_need rsn
                            ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                         WHERE rp.id_rehab_presc = i_id_rehab_presc
                         ORDER BY rp.dt_rehab_presc_hist DESC);
        
            g_error := 'OPEN o_rehab_treatment_prof CURSOR';
            OPEN o_rehab_treatment_prof FOR
                SELECT id, date_str, prof_sign, flg_status, desc_title
                  FROM (SELECT rp.id_rehab_presc_hist id,
                               pk_date_utils.dt_chr_date_hour_tsz(i_lang, rp.dt_rehab_presc_hist, i_prof) date_str,
                               pk_tools.get_prof_description(i_lang, i_prof, rp.id_professional_hist, NULL, NULL) prof_sign,
                               rp.flg_status flg_status,
                               CASE
                                    WHEN rp.flg_status = 'B' THEN
                                     decode((SELECT COUNT(*)
                                              FROM rehab_presc_hist rp1
                                             WHERE rp1.id_rehab_presc = i_id_rehab_presc
                                               AND rp1.dt_rehab_presc_hist < rp.dt_rehab_presc_hist),
                                            0,
                                            pk_message.get_message(i_lang, 'REHAB_T158'),
                                            pk_message.get_message(i_lang, 'REHAB_T159'))
                                    WHEN rp.flg_status = 'O' THEN
                                     decode((SELECT COUNT(*)
                                              FROM rehab_presc_hist rp1
                                             WHERE rp1.id_rehab_presc = i_id_rehab_presc
                                               AND rp1.dt_rehab_presc_hist < rp.dt_rehab_presc_hist),
                                            0,
                                            pk_message.get_message(i_lang, 'REHAB_T158'),
                                            pk_message.get_message(i_lang, 'REHAB_T159'))
                                    WHEN rp.flg_status = 'X'
                                         AND rp.flg_referral IS NOT NULL THEN
                                     pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL', rp.flg_referral, i_lang)
                                    ELSE
                                     pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', rp.flg_status, i_lang)
                                END desc_title,
                               rp.dt_rehab_presc_hist dt_hist,
                               1 ord
                          FROM (SELECT *
                                  FROM rehab_presc_hist rp
                                 WHERE rp.id_rehab_presc = i_id_rehab_presc
                                MINUS
                                SELECT *
                                  FROM rehab_presc_hist rp
                                 WHERE rp.id_rehab_presc = i_id_rehab_presc
                                   AND (rp.flg_status = 'O' AND
                                       pk_rehab.get_prev_status_rph_int(i_lang, i_prof, rp.id_rehab_presc_hist) = 'B')) rp
                        UNION
                        SELECT rsh.id_rehab_session_hist id,
                               pk_date_utils.dt_chr_date_hour_tsz(i_lang, rsh.dt_rehab_session_hist, i_prof) date_str,
                               pk_tools.get_prof_description(i_lang, i_prof, rsh.id_professional_hist, NULL, NULL) prof_sign,
                               rsh.flg_status flg_status,
                               decode(rsh.flg_status,
                                      'C',
                                      pk_message.get_message(i_lang, 'REHAB_T160'),
                                      decode((SELECT 1
                                               FROM rehab_session_hist r
                                              WHERE r.id_rehab_presc = i_id_rehab_presc
                                                AND r.id_rehab_session = rsh.id_rehab_session
                                                AND r.id_rehab_session_hist < rsh.id_rehab_session_hist
                                                AND rownum = 1),
                                             1,
                                             pk_message.get_message(i_lang, 'REHAB_T161'),
                                             pk_sysdomain.get_domain('REHAB_SESSION.FLG_STATUS', rsh.flg_status, i_lang))) desc_title,
                               rsh.dt_rehab_session_hist dt_hist,
                               2 ord
                          FROM rehab_session_hist rsh
                         WHERE rsh.id_rehab_presc = i_id_rehab_presc)
                 ORDER BY dt_hist DESC, ord DESC;
        
            IF NOT pk_rehab.get_rehab_session_detail(i_lang                 => i_lang,
                                                     i_prof                 => i_prof,
                                                     i_id_rehab_presc       => i_id_rehab_presc,
                                                     o_rehab_session_detail => o_rehab_session_detail,
                                                     o_error                => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        END IF;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_rehab_treatment);
            pk_types.open_my_cursor(o_rehab_treatment_prof);
            pk_types.open_my_cursor(o_rehab_session_detail);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
    END get_rehab_treatment_detail;

    FUNCTION get_count_and_rank
    (
        i_lang              IN language.id_language%TYPE,
        i_id_schedule       IN schedule.id_schedule%TYPE,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        o_count             OUT NUMBER,
        o_rank              OUT NUMBER,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(32) := 'GET_COUNT_AND_RANK';
    BEGIN
    
        -- output value o_count
        g_error := 'GET OUTPUT VALUE O_COUNT';
        SELECT COUNT(*)
          INTO o_count
          FROM rehab_schedule rs
         WHERE rs.id_rehab_sch_need = i_id_rehab_sch_need
           AND rs.flg_status = g_rehab_schedule_scheduled;
    
        -- output value o_rank    
        g_error := 'GET OUTPUT VALUE O_RANK';
        SELECT rn
          INTO o_rank
          FROM (SELECT rownum rn, subq.id_schedule
                  FROM (SELECT sch.id_schedule
                          FROM schedule sch
                         INNER JOIN rehab_schedule rs
                            ON sch.id_schedule = rs.id_schedule
                         WHERE rs.id_rehab_sch_need = i_id_rehab_sch_need
                           AND sch.flg_status = g_workflow_type_a
                         ORDER BY sch.dt_begin_tstz) subq)
         WHERE id_schedule = i_id_schedule;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: ' || ' @' || g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_count_and_rank;

    FUNCTION get_count_and_rank
    (
        i_lang              IN language.id_language%TYPE,
        i_id_schedule       IN schedule.id_schedule%TYPE,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE
    ) RETURN VARCHAR2 IS
        l_count NUMBER;
        l_rank  NUMBER;
        o_error t_error_out;
        ret_val VARCHAR2(200) := ' ';
    BEGIN
        IF get_count_and_rank(i_lang              => i_lang,
                              i_id_schedule       => i_id_schedule,
                              i_id_rehab_sch_need => i_id_rehab_sch_need,
                              o_count             => l_count,
                              o_rank              => l_rank,
                              o_error             => o_error)
        THEN
            ret_val := l_rank || '/' || l_count;
        END IF;
    
        RETURN ret_val;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN ret_val;
        
    END get_count_and_rank;

    FUNCTION get_rehab_sch_sessions
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE
    ) RETURN VARCHAR2 IS
    
        l_table_ret table_varchar := table_varchar();
        l_ret_sched VARCHAR2(4000) := NULL;
    
    BEGIN
    
        IF i_id_rehab_sch_need IS NOT NULL
        THEN
            g_error := 'OPEN o_rehab_treatment CURSOR';
            SELECT decode(s.flg_status,
                          g_rehab_schedule_cancel,
                          NULL,
                          '(' || get_count_and_rank(i_lang              => i_lang,
                                                    i_id_schedule       => s.id_schedule,
                                                    i_id_rehab_sch_need => rsn.id_rehab_sch_need) || ') ') ||
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, s.dt_begin_tstz, i_prof) sess
              BULK COLLECT
              INTO l_table_ret
              FROM schedule s
             INNER JOIN rehab_schedule rs
                ON rs.id_schedule = s.id_schedule
             INNER JOIN rehab_sch_need rsn
                ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
             WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need;
        
            FOR i IN 1 .. l_table_ret.count
            LOOP
                l_ret_sched := l_ret_sched || l_table_ret(i);
                IF i <> l_table_ret.count
                THEN
                    l_ret_sched := l_ret_sched || '; ';
                END IF;
            END LOOP;
        END IF;
    
        RETURN l_ret_sched;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END;
    /********************************************************************************************
    * Get the detail for the Rehabilitation sessions
    *
    * @param i_lang                   Preferred language ID for this professional 
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_id_rehab_sch_need      Rehabilitaion session ID
    * @param o_rehab_treatment        Treatments details
    * @param o_rehab_treatment_prof   Professional details
    
    * @param o_error                  Error
    *
    * @return                         true or false on success or error
    *
    * @author                          Orlando Antunes
    * @version                         2.6.0.3
    * @since                           2010/07/
    **********************************************************************************************/
    FUNCTION get_rehab_sch_need_detail
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_rehab_sch_need  IN rehab_sch_need.id_rehab_sch_need%TYPE,
        o_rehab_session      OUT pk_types.cursor_type,
        o_rehab_session_prof OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_SCH_NEED_DETAIL';
        l_table_ret table_varchar := table_varchar();
        l_ret_sched VARCHAR2(4000);
    BEGIN
        --
        g_error := 'GET_REHAB_SCH_NEED_DETAIL: i_id_rehab_sch_need = ' || i_id_rehab_sch_need;
        pk_alertlog.log_debug(g_error);
    
        --
        IF i_id_rehab_sch_need IS NULL
        THEN
            raise_application_error(-20100, 'Invalid Input Parameters');
        ELSE
        
            l_ret_sched := pk_rehab.get_rehab_sch_sessions(i_lang              => i_lang,
                                                           i_prof              => i_prof,
                                                           i_id_rehab_sch_need => i_id_rehab_sch_need);
        
            OPEN o_rehab_session FOR
                SELECT rsn.id_rehab_sch_need id,
                       --session_type
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_T114'),
                                     pk_translation.get_translation(i_lang, rst.code_rehab_session_type)) session_type,
                       --instructions
                       table_varchar(pk_message.get_message(i_lang, 'REHAB_T104'),
                                     get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need)) session_inst,
                       --state --> sessions scheduled rank/total 
                       table_varchar(pk_message.get_message(i_lang, 'PROCEDURES_MFR_T075') || ':', l_ret_sched) state,
                       --treatments --> terapeuta
                       table_varchar(pk_message.get_message(i_lang, 'PROCEDURES_MFR_M031') || ':',
                                     get_rehab_sch_need_resp(i_lang, rsn.id_resp_professional, rsn.id_resp_rehab_group)) treatments,
                       table_varchar(pk_message.get_message(1, 'REHAB_M011'), rsn.notes) notas
                  FROM rehab_sch_need rsn
                  JOIN rehab_session_type rst
                    ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                 WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need;
        
            --
            g_error := 'OPEN o_rehab_treatment_prof CURSOR';
            OPEN o_rehab_session_prof FOR
                SELECT rsn.id_rehab_sch_need id,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, nvl(rsn.dt_cancel, rsn.dt_rehab_sch_need), i_prof) date_str,
                       pk_tools.get_prof_description(i_lang,
                                                     i_prof,
                                                     nvl(rsn.id_cancel_professional, rsn.id_professional),
                                                     NULL,
                                                     NULL) prof_sign,
                       pk_sysdomain.get_domain('REHAB_SCH_NEED.FLG_STATUS', rsn.flg_status, i_lang) desc_title,
                       rsn.dt_rehab_sch_need dt,
                       rsn.flg_status flg_status
                  FROM rehab_sch_need rsn
                 WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need;
        END IF;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_rehab_session);
            pk_types.open_my_cursor(o_rehab_session_prof);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
    END get_rehab_sch_need_detail;
    --

    /********************************************************************************************
    * Get the list of treatments for a given session
    *
    * @param i_lang                   Preferred language ID for this professional 
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_id_rehab_sch_need      Rehabilitaion session ID
    *
    *
    * @return                         Array with list of treatments
    *
    * @author                          Orlando Antunes
    * @version                         2.6.0.3
    * @since                           2010/07/
    **********************************************************************************************/
    FUNCTION get_session_treatments
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE
    ) RETURN table_varchar IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_SESSION_TREATMENTS';
        l_error           t_error_out;
        l_treatments_list table_varchar := table_varchar();
    BEGIN
        --
        g_error := 'GET_SESSION_TREATMENTS: i_id_rehab_sch_need = ' || i_id_rehab_sch_need;
        pk_alertlog.log_debug(g_error);
    
        --
    
        --
        RETURN l_treatments_list;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
        
    END get_session_treatments;
    --

    /********************************************************************************************
    * Get the list of treatments for a given session
    *
    * @param i_lang                   Preferred language ID for this professional 
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_id_rehab_sch_need      Rehabilitaion session ID
    *
    *
    * @return                         Array with list of treatments
    *
    * @author                          Orlando Antunes
    * @version                         2.6.0.3
    * @since                           2010/07/
    **********************************************************************************************/
    FUNCTION get_treatments_edit
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_rehab_presc  IN rehab_presc.id_rehab_presc%TYPE,
        o_rehab_treatment OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_TREATMENTS_EDIT';
        l_error t_error_out;
    
    BEGIN
        --
        g_error := 'get_treatments_edit: i_id_rehab_presc = ' || i_id_rehab_presc;
        pk_alertlog.log_debug(g_error);
        --
    
        OPEN o_rehab_treatment FOR
            SELECT rp.id_rehab_presc id,
                   rp.id_rehab_area_interv id_rehab_area_interv,
                   pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) desc_interv,
                   rst.id_rehab_session_type,
                   pk_translation.get_translation(i_lang, rst.code_rehab_session_type) desc_rehab_session_type,
                   rsn.id_rehab_sch_need id_rehab_sch_need,
                   get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) instructions_desc,
                   rsn.sessions num_sessions,
                   get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need, 'S') num_sessions_desc,
                   rsn.frequency frequency_num,
                   rsn.flg_frequency frequency_time_unit,
                   get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need, 'F') frequency_desc,
                   rsn.flg_priority AS priority_data,
                   get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need, 'P') priority_desc,
                   pk_date_utils.date_send_tsz(i_lang, rsn.dt_begin, i_prof) dt_begin,
                   pk_date_utils.dt_chr_tsz(i_lang, rsn.dt_begin, i_prof) dt_begin_desc,
                   rsn.notes session_notes,
                   rp.exec_per_session exec_session_desc,
                   rp.exec_per_session exec_session_data,
                   rp.id_exec_institution exec_institution_data, --
                   decode(i_prof.institution,
                          rp.id_exec_institution,
                          pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                          pk_translation.get_translation(i_lang,
                                                         'AB_INSTITUTION.CODE_INSTITUTION.' || rp.id_exec_institution)) exec_institution_desc, --
                   rp.notes notes,
                   i.id_intervention,
                   rp.flg_laterality,
                   pk_sysdomain.get_domain('REHAB_PRESC.FLG_LATERALITY', rp.flg_laterality, i_lang) desc_laterality,
                   pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', i.id_intervention) flg_laterality_mcdt,
                   pk_not_order_reason_db.get_not_order_reason_id(i_lang                => i_lang,
                                                                  i_id_not_order_reason => rp.id_not_order_reason) not_order_reason_data,
                   pk_not_order_reason_db.get_not_order_reason_desc(i_lang             => i_lang,
                                                                    i_not_order_reason => rp.id_not_order_reason) not_order_reason_desc,
                   rp.diagnosis_notes,
                   (SELECT (CAST(MULTISET (SELECT t.column_value
                                    FROM TABLE(pk_diagnosis.concat_diag_id(i_lang                   => i_lang,
                                                                           i_exam_req_det           => NULL,
                                                                           i_analysis_req_det       => NULL,
                                                                           i_interv_presc_det       => NULL,
                                                                           i_prof                   => i_prof,
                                                                           i_type                   => 'S', --To fetch id_alert_diagnosis (aka id_concept_term)                                                                           
                                                                           i_rehab_presc            => rp.id_rehab_presc,
                                                                           i_flg_terminology_server => 'Y')) t) AS
                                 table_number))
                      FROM dual) id_alert_diagnosis,
                   (SELECT (CAST(MULTISET (SELECT t.column_value
                                    FROM TABLE(pk_diagnosis.concat_diag_id(i_lang                   => i_lang,
                                                                           i_exam_req_det           => NULL,
                                                                           i_analysis_req_det       => NULL,
                                                                           i_interv_presc_det       => NULL,
                                                                           i_prof                   => i_prof,
                                                                           i_type                   => 'T', --To fetch id_alert_diagnosis (aka id_concept_term)                                                                           
                                                                           i_rehab_presc            => rp.id_rehab_presc,
                                                                           i_flg_terminology_server => 'Y')) t) AS
                                 table_varchar))
                      FROM dual) tbl_diagnosis_desc,
                   rp.id_clinical_purpose,
                   rp.clinical_purpose_notes,
                   (SELECT (CAST(MULTISET (SELECT rpi.id_rehab_diagnosis
                                    FROM rehab_presc_icf rpi
                                   WHERE rpi.id_rehab_presc = rp.id_rehab_presc
                                     AND rpi.flg_status = pk_alert_constant.g_active) AS table_number))
                      FROM dual) AS tbl_id_rehab_diagnosis,
                   (SELECT (CAST(MULTISET
                                 (SELECT regexp_replace((SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                                                          FROM icf i
                                                         WHERE i.id_icf = rd.id_icf
                                                           AND i.flg_available = pk_alert_constant.g_yes
                                                        CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                                                         START WITH i.id_icf IN
                                                                    (SELECT id_icf
                                                                       FROM icf
                                                                      WHERE flg_type = pk_interv_mfr.g_flg_icf_component)),
                                                        '^(\s-\s*)$',
                                                        NULL) ||
                                         regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                          FROM icf_qualif_scale_rel iqsr
                                                         WHERE iqsr.id_icf_qualification = rd.id_iq_initial_incapacity
                                                           AND iqsr.id_icf_qualification_scale =
                                                               rd.id_iqs_initial_incapacity),
                                                        '^(\s*)$',
                                                        NULL) ||
                                         regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                          FROM icf_qualif_scale_rel iqsr
                                                         WHERE iqsr.id_icf_qualification = rd.id_iq_expected_result
                                                           AND iqsr.id_icf_qualification_scale =
                                                               rd.id_iqs_expected_result),
                                                        '^(\s*)$',
                                                        NULL) ||
                                         regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                          FROM icf_qualif_scale_rel iqsr
                                                         WHERE iqsr.id_icf_qualification = rd.id_iq_active_incapacity
                                                           AND iqsr.id_icf_qualification_scale =
                                                               rd.id_iqs_active_incapacity),
                                                        '^(\s*)$',
                                                        NULL) || ' - ' ||
                                         pk_translation.get_translation(i_lang, i.code_icf)
                                    FROM rehab_diagnosis rd
                                   INNER JOIN icf i
                                      ON rd.id_icf = i.id_icf
                                    JOIN rehab_presc_icf rpi
                                      ON rpi.id_rehab_diagnosis = rd.id_rehab_diagnosis
                                   WHERE rpi.id_rehab_presc = rp.id_rehab_presc
                                     AND rpi.flg_status = pk_alert_constant.g_active) AS table_varchar))
                      FROM dual) AS tbl_rehab_diagnosis_desc,
                   (SELECT listagg(regexp_replace((SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                                                    FROM icf i
                                                   WHERE i.id_icf = rd.id_icf
                                                     AND i.flg_available = pk_alert_constant.g_yes
                                                  CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                                                   START WITH i.id_icf IN
                                                              (SELECT id_icf
                                                                 FROM icf
                                                                WHERE flg_type = pk_interv_mfr.g_flg_icf_component)),
                                                  '^(\s-\s*)$',
                                                  NULL) ||
                                   regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                    FROM icf_qualif_scale_rel iqsr
                                                   WHERE iqsr.id_icf_qualification = rd.id_iq_initial_incapacity
                                                     AND iqsr.id_icf_qualification_scale = rd.id_iqs_initial_incapacity),
                                                  '^(\s*)$',
                                                  NULL) ||
                                   regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                    FROM icf_qualif_scale_rel iqsr
                                                   WHERE iqsr.id_icf_qualification = rd.id_iq_expected_result
                                                     AND iqsr.id_icf_qualification_scale = rd.id_iqs_expected_result),
                                                  '^(\s*)$',
                                                  NULL) ||
                                   regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                    FROM icf_qualif_scale_rel iqsr
                                                   WHERE iqsr.id_icf_qualification = rd.id_iq_active_incapacity
                                                     AND iqsr.id_icf_qualification_scale = rd.id_iqs_active_incapacity),
                                                  '^(\s*)$',
                                                  NULL) || ' - ' || pk_translation.get_translation(i_lang, i.code_icf),
                                   ', ') within GROUP(ORDER BY rpi.id_rehab_presc_icf ASC)
                      FROM rehab_diagnosis rd
                     INNER JOIN icf i
                        ON rd.id_icf = i.id_icf
                      JOIN rehab_presc_icf rpi
                        ON rpi.id_rehab_diagnosis = rd.id_rehab_diagnosis
                     WHERE rpi.id_rehab_presc = rp.id_rehab_presc
                       AND rpi.flg_status = pk_alert_constant.g_active) AS rehab_diagnosis_desc_concat,
                   rai.id_rehab_area,
                   pk_rehab.get_diagnosis(i_lang, i_prof, rp.id_rehab_presc) diagnosis_desc,
                   rp.flg_status,
                   pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', rp.flg_status, i_lang) status_desc,
                   pk_rehab.get_rehab_sch_sessions(i_lang, i_prof, rp.id_rehab_sch_need) scheduled_sessions,
                   pk_rehab.get_rehab_sch_need_resp(i_lang, rsn.id_resp_professional, rsn.id_resp_rehab_group) therapist,
                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, rp.id_cancel_reason) cancel_reason_desc,
                   rp.notes_cancel cancel_reason_notes,
                   rp.id_pat_health_plan,
                   rp.id_pat_exemption,
                   hpe.id_health_plan_entity,
                   CASE
                        WHEN rp.id_pat_health_plan IS NOT NULL THEN
                         pk_adt.get_pat_health_plan_info(i_lang, i_prof, rp.id_pat_health_plan, 'N')
                    END num_health_plan,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, rp.id_professional) ||
                   decode(pk_prof_utils.get_spec_signature(i_lang,
                                                           i_prof,
                                                           rp.id_professional,
                                                           rp.dt_rehab_presc,
                                                           rsn.id_episode_origin),
                          NULL,
                          '; ',
                          ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                   i_prof,
                                                                   rp.id_professional,
                                                                   rp.dt_rehab_presc,
                                                                   rsn.id_episode_origin) || '); ') ||
                   pk_date_utils.date_char_tsz(i_lang, rp.dt_rehab_presc, i_prof.institution, i_prof.software) registry
              FROM rehab_presc rp
              JOIN rehab_sch_need rsn
                ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
              JOIN rehab_session_type rst
                ON rst.id_rehab_session_type = rsn.id_rehab_session_type
              JOIN rehab_area_interv rai
                ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
              JOIN intervention i
                ON i.id_intervention = rai.id_intervention
              LEFT JOIN pat_health_plan php
                ON php.id_pat_health_plan = rp.id_pat_health_plan
              LEFT JOIN health_plan hp
                ON php.id_health_plan = hp.id_health_plan
              LEFT JOIN health_plan_entity hpe
                ON hp.id_health_plan_entity = hpe.id_health_plan_entity
             WHERE rp.id_rehab_presc = i_id_rehab_presc;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     g_package_owner,
                                                     g_package_name,
                                                     l_func_name,
                                                     l_error);
        
    END get_treatments_edit;

    /**********************************************************************************************
    * Creates a new rehab treatments prescription
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient
    * %param i_id_episode             episode
    * %param i_id_rehab_presc         prescription
    * %param i_id_rehab_area_interv   intervention
    * %param i_id_rehab_sch_need      schedule need
    * %param i_id_exec_institution    execution institution
    * %param i_exec_per_session       executions per session
    * %param i_presc_notes            notes of prescription
    * %param i_sessions               number of sessions
    * %param i_frequency              frequency
    * %param i_flg_frequency          frequency unit
    * %param i_flg_priority           priority
    * %param i_date_begin             begin date
    * %param i_session_notes          session notes
    * %param i_session_type           session type
    * %param o_id_rehab_presc         prescriptions created
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION set_rehab_presc
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        i_id_episode IN episode.id_episode%TYPE,
        --
        i_id_rehab_presc          IN rehab_presc.id_rehab_presc%TYPE,
        i_id_rehab_area_interv    IN rehab_presc.id_rehab_area_interv%TYPE,
        i_id_rehab_sch_need       IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_id_exec_institution     IN rehab_presc.id_exec_institution%TYPE,
        i_exec_per_session        IN rehab_presc.exec_per_session%TYPE,
        i_presc_notes             IN rehab_presc.notes%TYPE,
        i_sessions                IN rehab_sch_need.sessions%TYPE,
        i_frequency               IN rehab_sch_need.frequency%TYPE,
        i_flg_frequency           IN rehab_sch_need.flg_frequency%TYPE,
        i_flg_priority            IN rehab_sch_need.flg_priority%TYPE,
        i_date_begin              IN VARCHAR2,
        i_session_notes           IN rehab_sch_need.notes%TYPE,
        i_session_type            IN rehab_sch_need.id_rehab_session_type%TYPE,
        i_flg_laterality          IN rehab_presc.flg_laterality%TYPE,
        i_id_not_order_reason     IN rehab_presc.id_not_order_reason%TYPE DEFAULT NULL,
        i_flg_commit              IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        i_id_pat_health_plan      IN rehab_presc.id_pat_health_plan%TYPE DEFAULT NULL,
        i_id_pat_exemption        IN rehab_presc.id_pat_exemption%TYPE DEFAULT NULL,
        i_diagnosis_notes         IN rehab_presc.diagnosis_notes%TYPE DEFAULT NULL,
        i_diagnosis               IN pk_edis_types.rec_in_epis_diagnosis DEFAULT NULL,
        i_clinical_purpose        IN rehab_presc.id_clinical_purpose%TYPE DEFAULT NULL,
        i_clinical_purpose_notes  IN rehab_presc.clinical_purpose_notes%TYPE DEFAULT NULL,
        i_clinical_question       IN table_number DEFAULT NULL,
        i_response                IN table_number DEFAULT NULL,
        i_clinical_question_notes IN table_varchar DEFAULT NULL,
        i_tbl_icf                 IN table_number DEFAULT NULL,
        --
        o_id_rehab_presc OUT table_number,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_PRESC';
        l_tmp_rows              table_varchar;
        l_id_rehab_sch_need     rehab_sch_need.id_rehab_sch_need%TYPE;
        l_rsn_updated           table_number := table_number();
        l_cfg_needs_schedule    sys_config.value%TYPE;
        l_rehab_sch_need_status rehab_sch_need.flg_status%TYPE;
        l_ref_external_inst     sys_config.value%TYPE;
        l_rehab_presc_status    rehab_presc.flg_status%TYPE := g_rehab_presc_begin;
        l_old_rehab_sch_need    rehab_presc.id_rehab_sch_need%TYPE;
        l_sch_need_used         NUMBER;
        l_count                 NUMBER;
        l_id_episode_origin     rehab_plan.id_episode_origin%TYPE;
        l_id_schedule           rehab_schedule.id_schedule%TYPE;
        l_id_epis_type          episode.id_epis_type%TYPE;
        l_not_order_reason      not_order_reason.id_not_order_reason%TYPE;
        l_error                 t_error_out;
    
        --Diagnosis variables
        l_diagnosis           table_number;
        l_tbl_alert_diagnosis table_number := table_number();
        l_tbl_diag_desc       table_varchar := table_varchar();
        l_epis_diagnosis      table_varchar := table_varchar();
        l_diagnosis_new       table_number := table_number();
        l_id_rehab_presc_hist rehab_presc_hist.id_rehab_presc_hist%TYPE;
    
        --Clinical questions
        l_id_rehab_question_response rehab_question_response.id_rehab_question_response%TYPE;
        l_rehab_question_response    rehab_question_response%ROWTYPE;
    
        l_dt_rehab_presc_icf rehab_presc_icf.dt_rehab_presc_icf%TYPE;
        l_tbl_icf_to_outdate table_number;
    
        FUNCTION get_sub_diag_table
        (
            i_tbl_diagnosis IN pk_edis_types.rec_in_epis_diagnosis,
            i_sub_diag_list IN table_number
        ) RETURN pk_edis_types.rec_in_epis_diagnosis IS
            l_ret      pk_edis_types.rec_in_epis_diagnosis;
            l_tbl_diag pk_edis_types.table_in_diagnosis;
        BEGIN
            l_ret := i_tbl_diagnosis;
        
            IF i_sub_diag_list.exists(1)
            THEN
                l_tbl_diag          := l_ret.tbl_diagnosis;
                l_ret.tbl_diagnosis := pk_edis_types.table_in_diagnosis();
            
                IF l_tbl_diag.exists(1)
                THEN
                    FOR j IN i_sub_diag_list.first .. i_sub_diag_list.last
                    LOOP
                        FOR i IN l_tbl_diag.first .. l_tbl_diag.last
                        LOOP
                            IF l_tbl_diag(i).id_diagnosis = i_sub_diag_list(j)
                            THEN
                                l_ret.tbl_diagnosis.extend;
                                l_ret.tbl_diagnosis(l_ret.tbl_diagnosis.count) := l_tbl_diag(i);
                                EXIT;
                            END IF;
                        END LOOP;
                    END LOOP;
                END IF;
            END IF;
        
            RETURN l_ret;
        END get_sub_diag_table;
    BEGIN
        g_error := 'SET_REHAB_PRESC: i_id_rehab_presc = ' || i_id_rehab_presc;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := nvl(g_sysdate_tstz, current_timestamp);
    
        o_id_rehab_presc := table_number();
    
        l_cfg_needs_schedule := pk_sysconfig.get_config(i_code_cf => g_cfg_needs_schedule, i_prof => i_prof);
    
        IF NOT pk_rehab.get_origin_episode(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_id_episode        => i_id_episode,
                                           i_id_schedule       => NULL,
                                           o_id_episode_origin => l_id_episode_origin,
                                           o_id_schedule       => l_id_schedule,
                                           o_id_epis_type      => l_id_epis_type,
                                           o_error             => l_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --Referral inst parameterization
        l_ref_external_inst := pk_sysconfig.get_config('REF_EXTERNAL_INST', i_prof);
        IF l_cfg_needs_schedule = pk_alert_constant.g_yes
        THEN
            l_rehab_sch_need_status := g_rehab_sch_need_wait_sch;
        ELSE
            l_rehab_sch_need_status := pk_rehab.g_rehab_sch_need_no_sched;
        END IF;
    
        --referral
        IF i_id_exec_institution = l_ref_external_inst
        THEN
            l_rehab_sch_need_status := g_rehab_sch_need_no_sched;
            --
            l_rehab_presc_status := g_rehab_presc_referral;
        END IF;
    
        -- getting not order reason id                                              
        IF i_id_not_order_reason IS NOT NULL
        THEN
            l_rehab_sch_need_status := g_rehab_sch_need_no_sched;
            l_rehab_presc_status    := g_rehab_presc_not_order_reas;
        
            g_error := 'Call set_not_order_reason: ';
            g_error := g_error || ' i_not_order_reason_ea = ' || coalesce(to_char(i_id_not_order_reason), '<null>');
            pk_alertlog.log_debug(g_error);
            IF NOT pk_not_order_reason_db.set_not_order_reason(i_lang                => i_lang,
                                                               i_prof                => i_prof,
                                                               i_not_order_reason_ea => i_id_not_order_reason,
                                                               o_id_not_order_reason => l_not_order_reason,
                                                               o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        --validate if the intructions already exists, and if not create the new ones
        IF i_id_rehab_sch_need IS NULL
           OR i_id_not_order_reason IS NOT NULL
        THEN
            g_error := 'Before count rehab_presc';
        
            -- se for o único tratamento desta necessidade de agendamento
            -- cancela-se também a necessidade de agendamento
            SELECT COUNT(*)
              INTO l_count
              FROM rehab_presc rp
             WHERE rp.id_rehab_sch_need = (SELECT id_rehab_sch_need
                                             FROM rehab_presc rp2
                                            WHERE rp2.id_rehab_presc = i_id_rehab_presc)
               AND rp.flg_status != g_rehab_presc_cancel;
        
            g_error := 'count rehab_presc=' || l_count;
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            IF l_count = 1
            THEN
                -- correspondência 1 para 1
                -- update rehab_presc former rehab_sch_need to cancel if it's unique
                -- maybe there is a need to create a new status for this <--------------
                g_error := 'get id_rehab_sch_need';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                SELECT id_rehab_sch_need
                  INTO l_id_rehab_sch_need
                  FROM rehab_presc rp
                 WHERE rp.id_rehab_presc = i_id_rehab_presc;
            
                g_error := 'cancel id_rehab_sch_need';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                IF NOT cancel_rehab_sch_need_nocommit(i_lang              => i_lang,
                                                      i_prof              => i_prof,
                                                      i_id_rehab_sch_need => l_id_rehab_sch_need,
                                                      --i_id_cancel_reason  => 300,
                                                      i_notes => '',
                                                      o_error => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            pk_alertlog.log_debug('CREATE A NEW INSTRUCTIONS!');
            -- verifica se este episódio já existe na rehab_plan, caso não exista cria
            --TODO - not done
            IF NOT check_rehab_plan(i_lang              => i_lang,
                                    i_prof              => i_prof,
                                    i_id_patient        => i_id_patient,
                                    i_id_episode_origin => l_id_episode_origin,
                                    i_commit            => pk_alert_constant.get_no(),
                                    o_error             => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'Before ts_rehab_sch_need.ins i_flg_priority(i)=' || i_flg_priority || '#';
            pk_alertlog.log_debug(g_error);
        
            -- se i_id_rehab_sch_need(i) é null tem de se criar uma nova necessidade
            l_id_rehab_sch_need := ts_rehab_sch_need.next_key();
            ts_rehab_sch_need.ins(id_rehab_sch_need_in     => l_id_rehab_sch_need,
                                  id_episode_origin_in     => l_id_episode_origin,
                                  sessions_in              => i_sessions,
                                  frequency_in             => i_frequency,
                                  flg_frequency_in         => i_flg_frequency,
                                  flg_priority_in          => i_flg_priority,
                                  dt_begin_in              => pk_date_utils.get_string_tstz(i_lang,
                                                                                            i_prof,
                                                                                            i_date_begin,
                                                                                            NULL),
                                  flg_status_in            => l_rehab_sch_need_status,
                                  id_professional_in       => i_prof.id,
                                  dt_rehab_sch_need_in     => g_sysdate_tstz,
                                  id_rehab_session_type_in => i_session_type,
                                  notes_in                 => i_session_notes,
                                  rows_out                 => l_tmp_rows);
        
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_SCH_NEED',
                                          i_rowids     => l_tmp_rows,
                                          o_error      => o_error);
        
            IF NOT set_rehab_sch_need_hist(i_lang                   => i_lang,
                                           i_prof                   => i_prof,
                                           i_id_rehab_sch_need      => l_id_rehab_sch_need,
                                           i_dt_rehab_sch_need_hist => g_sysdate_tstz,
                                           i_commit                 => pk_alert_constant.g_no,
                                           o_error                  => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        ELSE
            l_id_rehab_sch_need := i_id_rehab_sch_need;
        END IF;
    
        --
        IF i_id_rehab_presc IS NULL
        THEN
            --NOT Implemented
            NULL;
        
        ELSE
            g_error := 'Before ts_rehab_presc.ins';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            g_error := 'Get previous schedule need before update';
            SELECT id_rehab_sch_need
              INTO l_old_rehab_sch_need
              FROM rehab_presc
             WHERE id_rehab_presc = i_id_rehab_presc;
        
            o_id_rehab_presc.extend;
            o_id_rehab_presc(1) := i_id_rehab_presc;
        
            ts_rehab_presc.upd(id_rehab_presc_in          => i_id_rehab_presc,
                               id_rehab_area_interv_in    => i_id_rehab_area_interv,
                               id_institution_in          => i_prof.institution,
                               id_rehab_sch_need_in       => l_id_rehab_sch_need,
                               id_exec_institution_in     => i_id_exec_institution,
                               exec_per_session_in        => i_exec_per_session,
                               exec_per_session_nin       => FALSE,
                               notes_in                   => i_presc_notes,
                               notes_nin                  => FALSE,
                               flg_status_in              => l_rehab_presc_status,
                               dt_rehab_presc_in          => g_sysdate_tstz,
                               flg_laterality_in          => i_flg_laterality,
                               flg_laterality_nin         => FALSE,
                               id_not_order_reason_in     => l_not_order_reason,
                               id_pat_health_plan_in      => i_id_pat_health_plan,
                               id_pat_health_plan_nin     => FALSE,
                               id_pat_exemption_in        => i_id_pat_exemption,
                               id_pat_exemption_nin       => FALSE,
                               diagnosis_notes_in         => i_diagnosis_notes,
                               diagnosis_notes_nin        => FALSE,
                               id_clinical_purpose_in     => i_clinical_purpose,
                               id_clinical_purpose_nin    => FALSE,
                               clinical_purpose_notes_in  => i_clinical_purpose_notes,
                               clinical_purpose_notes_nin => FALSE,
                               rows_out                   => l_tmp_rows);
        
            l_dt_rehab_presc_icf := g_sysdate_tstz;
        
            g_error := 'CALL TO PROCESS_UPDATE';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_PRESC',
                                          i_rowids     => l_tmp_rows,
                                          o_error      => o_error);
        
            l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key();
        
            IF NOT set_rehab_presc_hist(i_lang                => i_lang,
                                        i_prof                => i_prof,
                                        i_id_rehab_presc      => i_id_rehab_presc,
                                        i_dt_rehab_presc_hist => g_sysdate_tstz,
                                        i_commit              => pk_alert_constant.g_no,
                                        i_id_rehab_presc_hist => l_id_rehab_presc_hist,
                                        o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            --ICF
            IF i_tbl_icf.exists(1)
            THEN
                IF i_tbl_icf.count > 0
                THEN
                    FOR i IN i_tbl_icf.first .. i_tbl_icf.last
                    LOOP
                        SELECT COUNT(1)
                          INTO l_count
                          FROM rehab_presc_icf rpi
                         WHERE rpi.id_rehab_presc = id_rehab_presc
                           AND rpi.flg_status = pk_alert_constant.g_active
                           AND rpi.id_rehab_diagnosis = i_tbl_icf(i);
                    
                        IF l_count = 0
                        THEN
                            g_error := 'INSERT INTO rehab_presc_icf';
                            INSERT INTO rehab_presc_icf
                                (id_rehab_presc_icf,
                                 id_rehab_presc,
                                 id_rehab_diagnosis,
                                 flg_status,
                                 dt_rehab_presc_icf)
                            VALUES
                                (seq_rehab_presc_icf.nextval,
                                 i_id_rehab_presc,
                                 i_tbl_icf(i),
                                 pk_alert_constant.g_active,
                                 l_dt_rehab_presc_icf);
                        END IF;
                    
                        g_error := 'INSERT INTO rehab_presc_icf_hist';
                        INSERT INTO rehab_presc_icf_hist
                            (id_rehab_presc_icf_hist,
                             id_rehab_presc,
                             id_rehab_diagnosis,
                             dt_rehab_presc_icf_hist,
                             dt_rehab_presc_icf)
                        VALUES
                            (seq_rehab_presc_icf_hist.nextval,
                             i_id_rehab_presc,
                             i_tbl_icf(i),
                             g_sysdate_tstz,
                             l_dt_rehab_presc_icf);
                    END LOOP;
                
                    SELECT rpi.id_rehab_presc_icf
                      BULK COLLECT
                      INTO l_tbl_icf_to_outdate
                      FROM rehab_presc_icf rpi
                     WHERE rpi.id_rehab_presc = id_rehab_presc
                       AND rpi.flg_status = pk_alert_constant.g_active
                       AND rpi.id_rehab_diagnosis NOT IN (SELECT /*+opt_estimate(table act rows=1)*/
                                                           *
                                                            FROM TABLE(i_tbl_icf) t);
                
                    UPDATE rehab_presc_icf rpi
                       SET rpi.flg_status = pk_alert_constant.g_outdated
                     WHERE rpi.id_rehab_presc_icf IN (SELECT /*+opt_estimate(table act rows=1)*/
                                                       *
                                                        FROM TABLE(l_tbl_icf_to_outdate) t);
                END IF;
            ELSE
                UPDATE rehab_presc_icf rpi
                   SET rpi.flg_status = pk_alert_constant.g_outdated
                 WHERE rpi.id_rehab_presc = i_id_rehab_presc
                   AND rpi.flg_status = pk_alert_constant.g_active;
            END IF;
        
            --UPDATE DIAGNOSIS
            IF NOT pk_diagnosis.update_mcdt_req_diag_no_commit(i_lang              => i_lang,
                                                               i_prof              => i_prof,
                                                               i_epis              => i_id_episode,
                                                               i_diagnosis         => i_diagnosis,
                                                               i_exam_req          => NULL,
                                                               i_analysis_req      => NULL,
                                                               i_interv_presc      => NULL,
                                                               i_exam_req_det      => NULL,
                                                               i_analysis_req_det  => NULL,
                                                               i_interv_presc_det  => NULL,
                                                               i_blood_product_req => NULL,
                                                               i_blood_product_det => NULL,
                                                               i_rehab_presc       => i_id_rehab_presc,
                                                               i_rehab_presc_hist  => l_id_rehab_presc_hist,
                                                               i_dt_tstz           => g_sysdate_tstz,
                                                               o_error             => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'Check if schedule need is still used';
            SELECT COUNT(*)
              INTO l_sch_need_used
              FROM rehab_presc
             WHERE id_rehab_sch_need = l_old_rehab_sch_need;
        
            IF l_old_rehab_sch_need IS NOT NULL
               AND l_old_rehab_sch_need != l_id_rehab_sch_need
               AND l_sch_need_used = 0
            THEN
                IF NOT cancel_rehab_sch_need_nocommit(i_lang              => i_lang,
                                                      i_prof              => i_prof,
                                                      i_id_rehab_sch_need => l_old_rehab_sch_need,
                                                      o_error             => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            --Clinical questions
            IF i_clinical_question.exists(1)
            THEN
                IF i_clinical_question.count != 0
                THEN
                    FOR i IN i_clinical_question.first .. i_clinical_question.last
                    LOOP
                        IF i_clinical_question(i) IS NOT NULL
                        THEN
                            IF i_response(i) IS NOT NULL
                            THEN
                                SELECT nvl(MAX(rqr.id_rehab_question_response), 0) + 1
                                  INTO l_id_rehab_question_response
                                  FROM rehab_question_response rqr;
                            
                                SELECT COUNT(*)
                                  INTO l_count
                                  FROM (SELECT rqr.*,
                                               row_number() over(PARTITION BY rqr.id_questionnaire ORDER BY rqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                          FROM rehab_question_response rqr
                                         WHERE rqr.id_rehab_presc = i_id_rehab_presc
                                           AND rqr.id_questionnaire = i_clinical_question(i)
                                           AND (rqr.id_response = i_response(i))
                                            OR dbms_lob.substr(rqr.notes, 3800) = i_clinical_question_notes(i))
                                 WHERE rn = 1;
                            
                                IF l_count = 0
                                THEN
                                    g_error := 'INSERT INTO rehab_question_response';
                                    INSERT INTO rehab_question_response
                                        (id_rehab_question_response,
                                         id_rehab_presc,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         flg_time,
                                         id_episode,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (l_id_rehab_question_response,
                                         i_id_rehab_presc,
                                         i_clinical_question(i),
                                         i_response(i),
                                         coalesce(i_clinical_question_notes(i),
                                                  pk_mcdt.get_response_alias(i_lang,
                                                                             i_prof,
                                                                             'RESPONSE.CODE_RESPONSE.' || i_response(i))),
                                         pk_blood_products_constant.g_bp_cq_on_order,
                                         i_id_episode,
                                         i_prof.id,
                                         g_sysdate_tstz);
                                ELSE
                                    SELECT t.id_rehab_question_response,
                                           t.id_rehab_presc,
                                           t.id_questionnaire,
                                           t.id_response,
                                           t.notes,
                                           t.flg_time,
                                           t.id_episode,
                                           t.id_prof_last_update,
                                           t.dt_last_update_tstz,
                                           t.create_user,
                                           t.create_time,
                                           t.create_institution,
                                           t.update_user,
                                           t.update_time,
                                           t.update_institution
                                      INTO l_rehab_question_response
                                      FROM (SELECT rqr.*,
                                                   row_number() over(PARTITION BY rqr.id_questionnaire ORDER BY rqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                              FROM rehab_question_response rqr
                                             WHERE rqr.id_rehab_presc = i_id_rehab_presc
                                               AND rqr.id_questionnaire = i_clinical_question(i)
                                               AND (rqr.id_response = i_response(i))
                                                OR dbms_lob.substr(rqr.notes, 3800) =
                                                   to_char(i_clinical_question_notes(i))) t
                                     WHERE t.rn = 1;
                                
                                    g_error := 'INSERT INTO rehab_question_response_hist';
                                    INSERT INTO rehab_question_response_hist
                                        (dt_rehab_question_resp_hist,
                                         id_rehab_question_response,
                                         id_episode,
                                         id_rehab_presc,
                                         flg_time,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (g_sysdate_tstz,
                                         l_rehab_question_response.id_rehab_question_response,
                                         l_rehab_question_response.id_episode,
                                         l_rehab_question_response.id_rehab_presc,
                                         l_rehab_question_response.flg_time,
                                         l_rehab_question_response.id_questionnaire,
                                         l_rehab_question_response.id_response,
                                         l_rehab_question_response.notes,
                                         l_rehab_question_response.id_prof_last_update,
                                         l_rehab_question_response.dt_last_update_tstz);
                                
                                    g_error := 'INSERT INTO REHAB_QUESTION_RESPONSE';
                                    INSERT INTO rehab_question_response
                                        (id_rehab_question_response,
                                         id_rehab_presc,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         flg_time,
                                         id_episode,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (l_id_rehab_question_response,
                                         i_id_rehab_presc,
                                         i_clinical_question(i),
                                         i_response(i),
                                         coalesce(i_clinical_question_notes(i),
                                                  pk_mcdt.get_response_alias(i_lang,
                                                                             i_prof,
                                                                             'RESPONSE.CODE_RESPONSE.' || i_response(i))),
                                         pk_blood_products_constant.g_bp_cq_on_order,
                                         i_id_episode,
                                         i_prof.id,
                                         g_sysdate_tstz);
                                END IF;
                            ELSE
                                SELECT nvl(MAX(rqr.id_rehab_question_response), 0) + 1
                                  INTO l_id_rehab_question_response
                                  FROM rehab_question_response rqr;
                            
                                SELECT COUNT(*)
                                  INTO l_count
                                  FROM (SELECT rqr.*,
                                               row_number() over(PARTITION BY rqr.id_questionnaire ORDER BY rqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                          FROM rehab_question_response rqr
                                         WHERE rqr.id_rehab_presc = i_id_rehab_presc
                                           AND rqr.id_questionnaire = i_clinical_question(i)
                                           AND (rqr.id_response = i_response(i))
                                            OR dbms_lob.substr(rqr.notes, 3800) = i_clinical_question_notes(i))
                                 WHERE rn = 1;
                            
                                IF l_count = 0
                                THEN
                                    g_error := 'INSERT INTO BP_QUESTION_RESPONSE';
                                    g_error := 'INSERT INTO rehab_question_response';
                                    INSERT INTO rehab_question_response
                                        (id_rehab_question_response,
                                         id_rehab_presc,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         flg_time,
                                         id_episode,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (l_id_rehab_question_response,
                                         i_id_rehab_presc,
                                         i_clinical_question(i),
                                         NULL,
                                         i_clinical_question_notes(i),
                                         pk_blood_products_constant.g_bp_cq_on_order,
                                         i_id_episode,
                                         i_prof.id,
                                         g_sysdate_tstz);
                                ELSE
                                    SELECT t.id_rehab_question_response,
                                           t.id_rehab_presc,
                                           t.id_questionnaire,
                                           t.id_response,
                                           t.notes,
                                           t.flg_time,
                                           t.id_episode,
                                           t.id_prof_last_update,
                                           t.dt_last_update_tstz,
                                           t.create_user,
                                           t.create_time,
                                           t.create_institution,
                                           t.update_user,
                                           t.update_time,
                                           t.update_institution
                                      INTO l_rehab_question_response
                                      FROM (SELECT rqr.*,
                                                   row_number() over(PARTITION BY rqr.id_questionnaire ORDER BY rqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                              FROM rehab_question_response rqr
                                             WHERE rqr.id_rehab_presc = i_id_rehab_presc
                                               AND rqr.id_questionnaire = i_clinical_question(i)
                                               AND (rqr.id_response = i_response(i))
                                                OR dbms_lob.substr(rqr.notes, 3800) = i_clinical_question_notes(i)) t
                                     WHERE t.rn = 1;
                                
                                    g_error := 'INSERT INTO rehab_question_response_hist';
                                    INSERT INTO rehab_question_response_hist
                                        (dt_rehab_question_resp_hist,
                                         id_rehab_question_response,
                                         id_episode,
                                         id_rehab_presc,
                                         flg_time,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (g_sysdate_tstz,
                                         l_rehab_question_response.id_rehab_question_response,
                                         l_rehab_question_response.id_episode,
                                         l_rehab_question_response.id_rehab_presc,
                                         l_rehab_question_response.flg_time,
                                         l_rehab_question_response.id_questionnaire,
                                         l_rehab_question_response.id_response,
                                         l_rehab_question_response.notes,
                                         l_rehab_question_response.id_prof_last_update,
                                         l_rehab_question_response.dt_last_update_tstz);
                                
                                    g_error := 'INSERT INTO rehab_question_response';
                                    INSERT INTO rehab_question_response
                                        (id_rehab_question_response,
                                         id_rehab_presc,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         flg_time,
                                         id_episode,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (l_id_rehab_question_response,
                                         i_id_rehab_presc,
                                         i_clinical_question(i),
                                         NULL,
                                         i_clinical_question_notes(i),
                                         pk_blood_products_constant.g_bp_cq_on_order,
                                         i_id_episode,
                                         i_prof.id,
                                         g_sysdate_tstz);
                                END IF;
                            END IF;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        END IF;
    
        l_rsn_updated.extend();
        l_rsn_updated(l_rsn_updated.last) := l_id_rehab_sch_need;
    
        -- verificar se nas necessidades de agendamentos modificadas (inseridas ou adicionados tratamentos)
        -- se existe só um único tipo de sessão, caso contrário cria outra igual.
        IF NOT check_sch_need_session_type(i_lang       => i_lang,
                                           i_prof       => i_prof,
                                           i_sch_needs  => l_rsn_updated,
                                           o_new_rowids => l_tmp_rows,
                                           o_error      => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_id_episode_origin,
                                      i_pat                 => i_id_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF i_flg_commit = pk_alert_constant.g_yes
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_rehab_presc;

    FUNCTION set_rehab_presc_nocommit
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        i_id_episode IN episode.id_episode%TYPE,
        --
        i_id_rehab_presc       IN rehab_presc.id_rehab_presc%TYPE,
        i_id_rehab_area_interv IN rehab_presc.id_rehab_area_interv%TYPE,
        i_id_rehab_sch_need    IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_id_exec_institution  IN rehab_presc.id_exec_institution%TYPE,
        i_exec_per_session     IN rehab_presc.exec_per_session%TYPE,
        i_presc_notes          IN rehab_presc.notes%TYPE,
        i_sessions             IN rehab_sch_need.sessions%TYPE,
        i_frequency            IN rehab_sch_need.frequency%TYPE,
        i_flg_frequency        IN rehab_sch_need.flg_frequency%TYPE,
        i_flg_priority         IN rehab_sch_need.flg_priority%TYPE,
        i_date_begin           IN VARCHAR2,
        i_session_notes        IN rehab_sch_need.notes%TYPE,
        i_session_type         IN rehab_sch_need.id_rehab_session_type%TYPE,
        i_flg_laterality       IN rehab_presc.flg_laterality%TYPE,
        i_id_not_order_reason  IN rehab_presc.id_not_order_reason%TYPE DEFAULT NULL,
        --
        o_id_rehab_presc OUT table_number,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_PRESC_NOCOMMIT';
        l_tmp_rows              table_varchar;
        l_id_rehab_sch_need     rehab_sch_need.id_rehab_sch_need%TYPE;
        l_rsn_updated           table_number := table_number();
        l_cfg_needs_schedule    sys_config.value%TYPE;
        l_rehab_sch_need_status rehab_sch_need.flg_status%TYPE;
        l_ref_external_inst     sys_config.value%TYPE;
        l_rehab_presc_status    rehab_presc.flg_status%TYPE := g_rehab_presc_begin;
        l_old_rehab_sch_need    rehab_presc.id_rehab_sch_need%TYPE;
        l_sch_need_used         NUMBER;
        l_count                 NUMBER;
        l_id_episode_origin     rehab_plan.id_episode_origin%TYPE;
        l_id_schedule           rehab_schedule.id_schedule%TYPE;
        l_id_epis_type          episode.id_epis_type%TYPE;
        l_not_order_reason      not_order_reason.id_not_order_reason%TYPE;
        l_error                 t_error_out;
    BEGIN
        g_error := 'SET_REHAB_PRESC: i_id_rehab_presc = ' || i_id_rehab_presc;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        o_id_rehab_presc := table_number();
    
        l_cfg_needs_schedule := pk_sysconfig.get_config(i_code_cf => g_cfg_needs_schedule, i_prof => i_prof);
    
        IF NOT pk_rehab.get_origin_episode(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_id_episode        => i_id_episode,
                                           i_id_schedule       => NULL,
                                           o_id_episode_origin => l_id_episode_origin,
                                           o_id_schedule       => l_id_schedule,
                                           o_id_epis_type      => l_id_epis_type,
                                           o_error             => l_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --Referral inst parameterization
        l_ref_external_inst := pk_sysconfig.get_config('REF_EXTERNAL_INST', i_prof);
        IF l_cfg_needs_schedule = pk_alert_constant.g_yes
        THEN
            l_rehab_sch_need_status := g_rehab_sch_need_wait_sch;
        ELSE
            l_rehab_sch_need_status := pk_rehab.g_rehab_sch_need_no_sched;
        END IF;
    
        --referral
        IF i_id_exec_institution = l_ref_external_inst
        THEN
            l_rehab_sch_need_status := g_rehab_sch_need_no_sched;
            --
            l_rehab_presc_status := g_rehab_presc_referral;
        END IF;
    
        -- getting not order reason id                                              
        IF i_id_not_order_reason IS NOT NULL
        THEN
            l_rehab_sch_need_status := g_rehab_sch_need_no_sched;
            l_rehab_presc_status    := g_rehab_presc_not_order_reas;
        
            g_error := 'Call set_not_order_reason: ';
            g_error := g_error || ' i_not_order_reason_ea = ' || coalesce(to_char(i_id_not_order_reason), '<null>');
            pk_alertlog.log_debug(g_error);
            IF NOT pk_not_order_reason_db.set_not_order_reason(i_lang                => i_lang,
                                                               i_prof                => i_prof,
                                                               i_not_order_reason_ea => i_id_not_order_reason,
                                                               o_id_not_order_reason => l_not_order_reason,
                                                               o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        --validate if the intructions already exists, and if not create the new ones
        IF i_id_rehab_sch_need IS NULL
           OR i_id_not_order_reason IS NOT NULL
        THEN
            g_error := 'Before count rehab_presc';
        
            -- se for o único tratamento desta necessidade de agendamento
            -- cancela-se também a necessidade de agendamento
            SELECT COUNT(*)
              INTO l_count
              FROM rehab_presc rp
             WHERE rp.id_rehab_sch_need = (SELECT id_rehab_sch_need
                                             FROM rehab_presc rp2
                                            WHERE rp2.id_rehab_presc = i_id_rehab_presc)
               AND rp.flg_status != g_rehab_presc_cancel;
        
            g_error := 'count rehab_presc=' || l_count;
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            IF l_count = 1
            THEN
                -- correspondência 1 para 1
                -- update rehab_presc former rehab_sch_need to cancel if it's unique
                -- maybe there is a need to create a new status for this <--------------
                g_error := 'get id_rehab_sch_need';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                SELECT id_rehab_sch_need
                  INTO l_id_rehab_sch_need
                  FROM rehab_presc rp
                 WHERE rp.id_rehab_presc = i_id_rehab_presc;
            
                g_error := 'cancel id_rehab_sch_need';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                IF NOT cancel_rehab_sch_need_nocommit(i_lang              => i_lang,
                                                      i_prof              => i_prof,
                                                      i_id_rehab_sch_need => l_id_rehab_sch_need,
                                                      --i_id_cancel_reason  => 300,
                                                      i_notes => '',
                                                      o_error => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            pk_alertlog.log_debug('CREATE A NEW INSTRUCTIONS!');
            -- verifica se este episódio já existe na rehab_plan, caso não exista cria
            --TODO - not done
            IF NOT check_rehab_plan(i_lang              => i_lang,
                                    i_prof              => i_prof,
                                    i_id_patient        => i_id_patient,
                                    i_id_episode_origin => l_id_episode_origin,
                                    i_commit            => pk_alert_constant.get_no(),
                                    o_error             => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'Before ts_rehab_sch_need.ins i_flg_priority(i)=' || i_flg_priority || '#';
            pk_alertlog.log_debug(g_error);
        
            -- se i_id_rehab_sch_need(i) é null tem de se criar uma nova necessidade
            l_id_rehab_sch_need := ts_rehab_sch_need.next_key();
            ts_rehab_sch_need.ins(id_rehab_sch_need_in     => l_id_rehab_sch_need,
                                  id_episode_origin_in     => l_id_episode_origin,
                                  sessions_in              => i_sessions,
                                  frequency_in             => i_frequency,
                                  flg_frequency_in         => i_flg_frequency,
                                  flg_priority_in          => i_flg_priority,
                                  dt_begin_in              => pk_date_utils.get_string_tstz(i_lang,
                                                                                            i_prof,
                                                                                            i_date_begin,
                                                                                            NULL),
                                  flg_status_in            => l_rehab_sch_need_status,
                                  id_professional_in       => i_prof.id,
                                  dt_rehab_sch_need_in     => g_sysdate_tstz,
                                  id_rehab_session_type_in => i_session_type,
                                  notes_in                 => i_session_notes,
                                  rows_out                 => l_tmp_rows);
        
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_SCH_NEED',
                                          i_rowids     => l_tmp_rows,
                                          o_error      => o_error);
        
            IF NOT set_rehab_sch_need_hist(i_lang                   => i_lang,
                                           i_prof                   => i_prof,
                                           i_id_rehab_sch_need      => l_id_rehab_sch_need,
                                           i_dt_rehab_sch_need_hist => g_sysdate_tstz,
                                           i_commit                 => pk_alert_constant.g_no,
                                           o_error                  => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        ELSE
            l_id_rehab_sch_need := i_id_rehab_sch_need;
        END IF;
    
        --
        IF i_id_rehab_presc IS NULL
        THEN
            --NOT Implemented
            NULL;
        
        ELSE
            g_error := 'Before ts_rehab_presc.ins';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        
            g_error := 'Get previous schedule need before update';
            SELECT id_rehab_sch_need
              INTO l_old_rehab_sch_need
              FROM rehab_presc
             WHERE id_rehab_presc = i_id_rehab_presc;
        
            o_id_rehab_presc.extend;
            o_id_rehab_presc(1) := i_id_rehab_presc;
        
            ts_rehab_presc.upd(id_rehab_presc_in       => i_id_rehab_presc,
                               id_rehab_area_interv_in => i_id_rehab_area_interv,
                               id_institution_in       => i_prof.institution,
                               id_rehab_sch_need_in    => l_id_rehab_sch_need,
                               id_exec_institution_in  => i_id_exec_institution,
                               exec_per_session_in     => i_exec_per_session,
                               exec_per_session_nin    => FALSE,
                               notes_in                => i_presc_notes,
                               notes_nin               => FALSE,
                               flg_status_in           => l_rehab_presc_status,
                               dt_rehab_presc_in       => g_sysdate_tstz,
                               flg_laterality_in       => i_flg_laterality,
                               id_not_order_reason_in  => l_not_order_reason,
                               rows_out                => l_tmp_rows);
        
            g_error := 'CALL TO PROCESS_UPDATE';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_PRESC',
                                          i_rowids     => l_tmp_rows,
                                          o_error      => o_error);
        
            IF NOT set_rehab_presc_hist(i_lang                => i_lang,
                                        i_prof                => i_prof,
                                        i_id_rehab_presc      => i_id_rehab_presc,
                                        i_dt_rehab_presc_hist => g_sysdate_tstz,
                                        i_commit              => pk_alert_constant.g_no,
                                        o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'Check if schedule need is still used';
            SELECT COUNT(*)
              INTO l_sch_need_used
              FROM rehab_presc
             WHERE id_rehab_sch_need = l_old_rehab_sch_need;
        
            IF l_old_rehab_sch_need IS NOT NULL
               AND l_old_rehab_sch_need != l_id_rehab_sch_need
               AND l_sch_need_used = 0
            THEN
                IF NOT cancel_rehab_sch_need_nocommit(i_lang              => i_lang,
                                                      i_prof              => i_prof,
                                                      i_id_rehab_sch_need => l_old_rehab_sch_need,
                                                      o_error             => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
        END IF;
    
        l_rsn_updated.extend();
        l_rsn_updated(l_rsn_updated.last) := l_id_rehab_sch_need;
    
        -- verificar se nas necessidades de agendamentos modificadas (inseridas ou adicionados tratamentos)
        -- se existe só um único tipo de sessão, caso contrário cria outra igual.
        IF NOT check_sch_need_session_type(i_lang       => i_lang,
                                           i_prof       => i_prof,
                                           i_sch_needs  => l_rsn_updated,
                                           o_new_rowids => l_tmp_rows,
                                           o_error      => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_id_episode_origin,
                                      i_pat                 => i_id_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_rehab_presc_nocommit;

    /**********************************************************************************************
    * retorna os pacientes com tratamentos para hoje
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_type                   A-appointments S-Scheduled else NonScheduled
    * %param i_status                 from state
    * %param o_status                 List of to states
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_grid_workflow_status
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        i_type   IN VARCHAR2,
        i_status IN VARCHAR2,
        o_status OUT pk_types.cursor_type,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_GRID_WORKFLOW_STATUS';
    
    BEGIN
    
        IF i_type = 'A'
        THEN
            --appointments
            IF NOT pk_action.get_actions_with_exceptions(i_lang       => i_lang,
                                                         i_prof       => i_prof,
                                                         i_subject    => 'REHAB_WORKFLOW_APPOINTMENT',
                                                         i_from_state => i_status,
                                                         o_actions    => o_status,
                                                         o_error      => o_error)
            THEN
                RETURN NULL;
            END IF;
        
        ELSIF i_type = 'S'
        THEN
            --treatments scheduling
            IF NOT pk_action.get_actions_with_exceptions(i_lang       => i_lang,
                                                         i_prof       => i_prof,
                                                         i_subject    => 'REHAB_WORKFLOW_APPOINTMENT',
                                                         i_from_state => i_status,
                                                         o_actions    => o_status,
                                                         o_error      => o_error)
            THEN
                RETURN NULL;
            END IF;
        ELSIF i_type = g_workflow_type_h
        THEN
            --appointments
            IF NOT pk_action.get_actions_with_exceptions(i_lang       => i_lang,
                                                         i_prof       => i_prof,
                                                         i_subject    => 'HHC_WORKFLOW_APPOINTMENT',
                                                         i_from_state => i_status,
                                                         o_actions    => o_status,
                                                         o_error      => o_error)
            THEN
                RETURN NULL;
            END IF;
        ELSE
            --no scheduling need
            IF NOT pk_action.get_actions_with_exceptions(i_lang       => i_lang,
                                                         i_prof       => i_prof,
                                                         i_subject    => 'REHAB_WORKFLOW_W_SCHEDULE',
                                                         i_from_state => i_status,
                                                         o_actions    => o_status,
                                                         o_error      => o_error)
            THEN
                RETURN NULL;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     g_package_owner,
                                                     g_package_name,
                                                     l_func_name,
                                                     o_error);
        
    END get_grid_workflow_status;

    --
    FUNCTION get_grid_workflow_icon
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        i_type   IN VARCHAR2,
        i_status IN VARCHAR2
        
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_GRID_WORKFLOW_STATUS';
        l_icon   sys_domain.img_name%TYPE;
        l_error  t_error_out;
        l_status VARCHAR2(200 CHAR);
    BEGIN
    
        IF i_type = g_workflow_type_a
           OR i_type = g_workflow_type_s
           OR i_type = g_workflow_type_w
        THEN
        
            l_icon := pk_sysdomain.get_img(i_lang, 'REHAB_EPIS_ENCOUNTER.FLG_STATUS', i_status);
        
        ELSIF i_type = g_workflow_type_h
        THEN
            --   l_status := pk_grid.get_schedule_real_state(i_status, l_flg_ehr);
            l_status := i_status;
            IF i_status = g_sched_adm_disch
            THEN
                l_status := g_sched_hhc_disch;
            END IF;
            l_icon := pk_sysdomain.get_img(i_lang, 'SCHEDULE_OUTP.FLG_STATE', l_status);
        ELSE
            l_icon := NULL;
        END IF;
    
        RETURN l_icon;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
        
    END get_grid_workflow_icon;

    /**************************************************************************
    * Auxiliary function to validate the lenght of table_number arrays        *
    *                                                                         *
    * @param i_tbl_in     Arrays containing all number arrays to validate     *
    *                                                                         *
    * @return                         Returns boolean                         *
    *                                                                         *
    * @author                         Gustavo Serrano                         *
    * @version                        1.0                                     *
    * @since                          2010/07/20                              *
    **************************************************************************/
    FUNCTION check_tbl_count
    (
        i_tbl_nr_in IN table_table_number,
        i_tbl_vc_in IN table_table_varchar
    ) RETURN BOOLEAN IS
        l_return BOOLEAN := TRUE;
        l_count  NUMBER := 0;
    BEGIN
        IF i_tbl_nr_in.count > 0
        THEN
            l_count := i_tbl_nr_in(1).count;
        END IF;
    
        FOR i IN 2 .. i_tbl_nr_in.count
        LOOP
            IF l_count != i_tbl_nr_in(i).count
            THEN
                l_return := FALSE;
                EXIT;
            END IF;
        END LOOP;
    
        FOR i IN 1 .. i_tbl_vc_in.count
        LOOP
            IF l_count != i_tbl_vc_in(i).count
            THEN
                l_return := FALSE;
                EXIT;
            END IF;
        END LOOP;
    
        RETURN l_return;
    END check_tbl_count;

    /**************************************************************************
    * Creates rehabilitation diagnosis associated to the patient episode      *
    *                                                                         *
    * @param i_lang                   language id                             *
    * @param i_prof                   professional, software and              *
    *                                 institution ids                         *
    * @param i_episode                Episode id                              *
    * @param i_patient                Patient id                              *
    * @param i_icf                    List of ID of ICF component             *
    * @param i_iq_initial_incapacity  List of ID of the qualifier for initial *
    *                                 incapacity                              *
    * @param i_iqs_initial_incapacity List of ID of qualification scale for   *
    *                                 initial incapacity                      *
    * @param i_iq_expected_result     List of ID of the qualifier for expected*
    *                                 result                                  *
    * @param i_iqs_expected_result    List of ID of qualification scale for   *
    *                                 expected result                         *
    * @param i_iq_active_incapacity   List of ID of the qualifier for active  *
    *                                 incapacity                              *
    * @param i_iqs_active_incapacity  List of ID of qualification scale for   *
    *                                 active incapacity                       *       
    *                                                                         *
    * @param o_error                  Error message                           *
    * @param o_id_rehab_diagnosis     List of generated rehab diagnosis       *
    *                                 requests                                *
    *                                                                         *
    * @return                         Returns boolean                         *
    *                                                                         *
    * @author                         Gustavo Serrano                         *
    * @version                        1.0                                     *
    * @since                          2010/07/16                              *
    **************************************************************************/
    FUNCTION create_rehab_diag
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_episode                IN episode.id_episode%TYPE,
        i_patient                IN patient.id_patient%TYPE,
        i_icf                    IN table_number,
        i_iq_initial_incapacity  IN table_number,
        i_iqs_initial_incapacity IN table_number,
        i_iq_expected_result     IN table_number,
        i_iqs_expected_result    IN table_number,
        i_iq_active_incapacity   IN table_number,
        i_iqs_active_incapacity  IN table_number,
        i_notes                  IN table_varchar,
        o_id_rehab_diagnosis     OUT table_number,
        o_flg_show               OUT VARCHAR2,
        o_msg                    OUT VARCHAR2,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CREATE_REHAB_DIAG';
    
        l_id_rehab_diagnosis rehab_diagnosis.id_rehab_diagnosis%TYPE;
        l_id_episode_origin  rehab_diagnosis.id_episode_origin%TYPE;
        l_id_schedule        schedule.id_schedule%TYPE;
        l_id_epis_type       epis_type.id_epis_type%TYPE;
        l_id_icf             icf.id_icf%TYPE;
    
        l_rowids_rd table_varchar;
        l_error     t_error_out;
    
        l_edit_rehab NUMBER;
    
        l_exception EXCEPTION;
    BEGIN
        g_error := 'Begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
        o_flg_show     := pk_alert_constant.g_no;
        o_msg          := NULL;
    
        g_error := 'Fetch origin episode';
        IF NOT pk_rehab.get_origin_episode(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_id_episode        => i_episode,
                                           i_id_schedule       => NULL,
                                           o_id_episode_origin => l_id_episode_origin,
                                           o_id_schedule       => l_id_schedule,
                                           o_id_epis_type      => l_id_epis_type,
                                           o_error             => l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'Check strutures';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        IF NOT check_tbl_count(table_table_number(i_icf,
                                                  i_iq_initial_incapacity,
                                                  i_iqs_initial_incapacity,
                                                  i_iq_expected_result,
                                                  i_iqs_expected_result,
                                                  i_iq_active_incapacity,
                                                  i_iqs_active_incapacity),
                               table_table_varchar(i_notes))
        THEN
            RAISE l_exception;
        END IF;
    
        l_rowids_rd          := table_varchar();
        o_id_rehab_diagnosis := table_number();
    
        g_error := 'Insert records';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        FOR i IN 1 .. i_icf.count
        LOOP
        
            SELECT COUNT(*)
              INTO l_edit_rehab
              FROM rehab_diagnosis a
             WHERE a.id_icf = i_icf(i)
               AND a.id_episode_origin = l_id_episode_origin
               AND a.id_patient = i_patient;
        
            IF l_edit_rehab = 0
            THEN
                g_error := 'Fetch sequence id for iteration - ' || i;
                SELECT seq_rehab_diagnosis.nextval
                  INTO l_id_rehab_diagnosis
                  FROM dual;
            
                o_id_rehab_diagnosis.extend;
                o_id_rehab_diagnosis(i) := l_id_rehab_diagnosis;
            
                l_id_icf := i_icf(i);
            
                g_error := 'Insert record for iteration - ' || i;
                ts_rehab_diagnosis.ins(id_rehab_diagnosis_in        => l_id_rehab_diagnosis,
                                       id_icf_in                    => i_icf(i),
                                       id_episode_origin_in         => l_id_episode_origin,
                                       id_episode_in                => i_episode,
                                       id_patient_in                => i_patient,
                                       id_iq_initial_incapacity_in  => i_iq_initial_incapacity(i),
                                       id_iqs_initial_incapacity_in => i_iqs_initial_incapacity(i),
                                       id_iq_expected_result_in     => i_iq_expected_result(i),
                                       id_iqs_expected_result_in    => i_iqs_expected_result(i),
                                       id_iq_active_incapacity_in   => i_iq_active_incapacity(i),
                                       id_iqs_active_incapacity_in  => i_iqs_active_incapacity(i),
                                       flg_status_in                => g_rehab_diag_flg_status_t,
                                       notes_in                     => i_notes(i),
                                       id_prof_last_update_in       => i_prof.id,
                                       dt_last_update_in            => g_sysdate_tstz,
                                       handle_error_in              => FALSE,
                                       rows_out                     => l_rowids_rd);
            
                g_error := 't_data_gov_mnt.process_insert';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'REHAB_DIAGNOSIS',
                                              i_rowids     => l_rowids_rd,
                                              o_error      => o_error);
            
            ELSE
            
                SELECT a.id_rehab_diagnosis
                  INTO l_id_rehab_diagnosis
                  FROM rehab_diagnosis a
                 WHERE a.id_icf = i_icf(i)
                   AND a.id_episode_origin = l_id_episode_origin
                   AND a.id_patient = i_patient;
            
                o_id_rehab_diagnosis.extend;
                o_id_rehab_diagnosis(i) := l_id_rehab_diagnosis;
            
                l_id_icf := i_icf(i);
            
                ts_rehab_diagnosis.upd(id_rehab_diagnosis_in        => l_id_rehab_diagnosis,
                                       id_icf_in                    => i_icf(i),
                                       id_episode_origin_in         => l_id_episode_origin,
                                       id_episode_in                => i_episode,
                                       id_patient_in                => i_patient,
                                       id_iq_initial_incapacity_in  => i_iq_initial_incapacity(i),
                                       id_iqs_initial_incapacity_in => i_iqs_initial_incapacity(i),
                                       id_iq_expected_result_in     => i_iq_expected_result(i),
                                       id_iqs_expected_result_in    => i_iqs_expected_result(i),
                                       id_iq_active_incapacity_in   => i_iq_active_incapacity(i),
                                       id_iqs_active_incapacity_in  => i_iqs_active_incapacity(i),
                                       flg_status_in                => g_rehab_diag_flg_status_t,
                                       notes_in                     => i_notes(i),
                                       id_prof_last_update_in       => i_prof.id,
                                       dt_last_update_in            => g_sysdate_tstz,
                                       handle_error_in              => FALSE,
                                       rows_out                     => l_rowids_rd);
            
                g_error := 't_data_gov_mnt.process_insert';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'REHAB_DIAGNOSIS',
                                              i_rowids     => l_rowids_rd,
                                              o_error      => o_error);
            
            END IF;
        END LOOP;
    
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN dup_val_on_index THEN
            DECLARE
                l_coding VARCHAR2(4000);
                l_msg    VARCHAR2(4000);
            BEGIN
                SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                  INTO l_coding
                  FROM icf i
                 WHERE i.id_icf = l_id_icf
                   AND i.flg_available = pk_alert_constant.g_yes
                CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                 START WITH i.id_icf IN (SELECT id_icf
                                           FROM icf
                                          WHERE flg_type = pk_interv_mfr.g_flg_icf_component);
                l_msg := regexp_replace(l_coding || ' - ' ||
                                        pk_translation.get_translation(i_lang, 'ICF.CODE_ICF.' || l_id_icf),
                                        '^(\s-\s*)$',
                                        NULL);
            
                o_flg_show := pk_alert_constant.g_yes;
                o_msg      := REPLACE(pk_message.get_message(i_lang, 'REHAB_M023'), '@1', l_msg);
            
                RETURN TRUE;
            END;
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              l_error.ora_sqlcode,
                                              l_error.ora_sqlerrm,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END create_rehab_diag;

    /**************************************************************************
    * Edits rehabilitation diagnosis data associated to the patient episode   *
    *                                                                         *
    * @param i_lang                   language id                             *
    * @param i_prof                   professional, software and              *
    *                                 institution ids                         *
    * @param i_id_rehab_diagnosis     list of rehab dianossis identifiers to  *
    *                                 cancel                                  *
    * @param i_episode                Episode id                              *
    * @param i_icf                    List of ID of ICF component             *
    * @param i_iq_initial_incapacity  List of ID of the qualifier for initial *
    *                                 incapacity                              *
    * @param i_iqs_initial_incapacity List of ID of qualification scale for   *
    *                                 initial incapacity                      *
    * @param i_iq_expected_result     List of ID of the qualifier for expected*
    *                                 result                                  *
    * @param i_iqs_expected_result    List of ID of qualification scale for   *
    *                                 expected result                         *
    * @param i_iq_active_incapacity   List of ID of the qualifier for active  *
    *                                 incapacity                              *
    * @param i_iqs_active_incapacity  List of ID of qualification scale for   *
    *                                 active incapacity                       *       
    *                                                                         *
    * @param o_error                  Error message                           *
    * @param o_id_rehab_diagnosis     List of generated rehab diagnosis       *
    *                                 requests                                *
    *                                                                         *
    * @return                         Returns boolean                         *
    *                                                                         *
    * @author                         Gustavo Serrano                         *
    * @version                        1.0                                     *
    * @since                          2010/07/16                              *
    **************************************************************************/
    FUNCTION set_rehab_diag
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_id_rehab_diagnosis     IN table_number,
        i_episode                IN episode.id_episode%TYPE,
        i_icf                    IN table_number,
        i_iq_initial_incapacity  IN table_number,
        i_iqs_initial_incapacity IN table_number,
        i_iq_expected_result     IN table_number,
        i_iqs_expected_result    IN table_number,
        i_iq_active_incapacity   IN table_number,
        i_iqs_active_incapacity  IN table_number,
        i_status                 IN table_varchar,
        i_notes                  IN table_varchar,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_DIAG';
    
        l_rowids_rd  table_varchar;
        l_rowids_rdh table_varchar;
        l_error      t_error_out;
        l_data       ts_rehab_diagnosis_hist.rehab_diagnosis_hist_tc;
    
        l_exception EXCEPTION;
    
    BEGIN
        g_error := 'Begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'Check strutures';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        IF NOT check_tbl_count(table_table_number(i_id_rehab_diagnosis,
                                                  i_icf,
                                                  i_iq_initial_incapacity,
                                                  i_iqs_initial_incapacity,
                                                  i_iq_expected_result,
                                                  i_iqs_expected_result,
                                                  i_iq_active_incapacity,
                                                  i_iqs_active_incapacity),
                               table_table_varchar(i_status, i_notes))
        THEN
            RAISE l_exception;
        END IF;
    
        SELECT g_sysdate_tstz            dt_rehab_diagnosis_hist,
               id_rehab_diagnosis,
               id_icf,
               id_iq_initial_incapacity,
               id_iqs_initial_incapacity,
               id_iq_expected_result,
               id_iqs_expected_result,
               id_iq_active_incapacity,
               id_iqs_active_incapacity,
               flg_status,
               id_episode_origin,
               id_episode,
               id_patient,
               notes,
               id_cancel_reason,
               notes_cancel,
               id_prof_last_update,
               dt_last_update,
               NULL                      create_user,
               NULL                      create_time,
               NULL                      create_institution,
               NULL                      update_user,
               NULL                      update_time,
               NULL                      update_institution
          BULK COLLECT
          INTO l_data
          FROM rehab_diagnosis rd
         WHERE rd.id_rehab_diagnosis IN (SELECT /*+opt_estimate(table t rows=1)*/
                                          *
                                           FROM TABLE(i_id_rehab_diagnosis) t);
    
        l_rowids_rdh := table_varchar();
    
        g_error := 'Insert history records';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_diagnosis_hist.ins(rows_in => l_data, rows_out => l_rowids_rdh);
    
        l_rowids_rd := table_varchar();
    
        g_error := 'Insert records';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        FOR i IN 1 .. i_id_rehab_diagnosis.count
        LOOP
            g_error := 'Update record for iteration - ' || i;
            ts_rehab_diagnosis.upd(id_icf_in                    => i_icf(i),
                                   id_iq_initial_incapacity_in  => i_iq_initial_incapacity(i),
                                   id_iqs_initial_incapacity_in => i_iqs_initial_incapacity(i),
                                   id_iq_expected_result_in     => i_iq_expected_result(i),
                                   id_iqs_expected_result_in    => i_iqs_expected_result(i),
                                   id_iq_active_incapacity_in   => i_iq_active_incapacity(i),
                                   id_iqs_active_incapacity_in  => i_iqs_active_incapacity(i),
                                   id_episode_in                => i_episode,
                                   notes_in                     => i_notes(i),
                                   flg_status_in                => i_status(i),
                                   id_prof_last_update_in       => i_prof.id,
                                   dt_last_update_in            => g_sysdate_tstz,
                                   where_in                     => 'id_rehab_diagnosis = ' || i_id_rehab_diagnosis(i),
                                   rows_out                     => l_rowids_rd);
        END LOOP;
    
        g_error := 't_data_gov_mnt.process_insert history';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_DIAGNOSIS_HIST',
                                      i_rowids     => l_rowids_rdh,
                                      o_error      => o_error);
    
        g_error := 't_data_gov_mnt.process_insert';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_DIAGNOSIS',
                                      i_rowids     => l_rowids_rd,
                                      o_error      => o_error);
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              l_error.ora_sqlcode,
                                              l_error.ora_sqlerrm,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_rehab_diag;

    /**************************************************************************
    * Cancels rehabilitation diagnosis data associated to the patient episode *
    *                                                                         *
    * @param i_lang                   language id                             *
    * @param i_prof                   professional, software and              *
    *                                 institution ids                         *
    * @param i_id_rehab_diagnosis     list of rehab dianossis identifiers to  *
    *                                 cancel                                  *
    * @param i_episode                Episode id                              *
    *                                                                         *
    * @param o_error                  Error message                           *
    *                                                                         *
    * @return                         Returns boolean                         *
    *                                                                         *
    * @author                         Gustavo Serrano                         *
    * @version                        1.0                                     *
    * @since                          2010/07/21                              *
    **************************************************************************/
    FUNCTION cancel_rehab_diag
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_rehab_diagnosis IN table_number,
        i_episode            IN episode.id_episode%TYPE,
        i_id_cancel_reason   IN cancel_reason.id_cancel_reason%TYPE,
        i_cancel_notes       IN rehab_diagnosis.notes_cancel%TYPE,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_REHAB_DIAG';
    
        l_rowids_rd  table_varchar;
        l_rowids_rdh table_varchar;
        l_error      t_error_out;
        l_data       ts_rehab_diagnosis_hist.rehab_diagnosis_hist_tc;
    
        l_exception EXCEPTION;
    
    BEGIN
        g_error := 'Begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'Fetch records to archive';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        SELECT g_sysdate_tstz            dt_rehab_diagnosis_hist,
               id_rehab_diagnosis,
               id_icf,
               id_iq_initial_incapacity,
               id_iqs_initial_incapacity,
               id_iq_expected_result,
               id_iqs_expected_result,
               id_iq_active_incapacity,
               id_iqs_active_incapacity,
               flg_status,
               id_episode_origin,
               id_episode,
               id_patient,
               notes,
               id_cancel_reason,
               notes_cancel,
               id_prof_last_update,
               dt_last_update,
               NULL                      create_user,
               NULL                      create_time,
               NULL                      create_institution,
               NULL                      update_user,
               NULL                      update_time,
               NULL                      update_institution
          BULK COLLECT
          INTO l_data
          FROM rehab_diagnosis rd
         WHERE rd.id_rehab_diagnosis IN (SELECT /*+opt_estimate(table t rows=1)*/
                                          *
                                           FROM TABLE(i_id_rehab_diagnosis) t);
    
        l_rowids_rdh := table_varchar();
    
        g_error := 'Insert history records';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_diagnosis_hist.ins(rows_in => l_data, rows_out => l_rowids_rdh);
    
        l_rowids_rd := table_varchar();
    
        g_error := 'Insert records';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        FOR i IN 1 .. i_id_rehab_diagnosis.count
        LOOP
            g_error := 'Update record for iteration - ' || i;
            ts_rehab_diagnosis.upd(flg_status_in          => g_rehab_diag_flg_status_c,
                                   id_cancel_reason_in    => i_id_cancel_reason,
                                   notes_cancel_in        => i_cancel_notes,
                                   id_episode_in          => i_episode,
                                   id_prof_last_update_in => i_prof.id,
                                   dt_last_update_in      => g_sysdate_tstz,
                                   where_in               => 'id_rehab_diagnosis = ' || i_id_rehab_diagnosis(i),
                                   rows_out               => l_rowids_rd);
        END LOOP;
    
        g_error := 't_data_gov_mnt.process_insert history';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_DIAGNOSIS_HIST',
                                      i_rowids     => l_rowids_rdh,
                                      o_error      => o_error);
    
        g_error := 't_data_gov_mnt.process_insert';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_DIAGNOSIS',
                                      i_rowids     => l_rowids_rd,
                                      o_error      => o_error);
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              l_error.ora_sqlcode,
                                              l_error.ora_sqlerrm,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END cancel_rehab_diag;

    /**************************************************************************
    * Lists rehabilitation diagnosis data associated to the patient episode   *
    *                                                                         *
    * @param i_lang                   language id                             *
    * @param i_prof                   professional, software and              *
    *                                 institution ids                         *
    * @param i_episode                Episode id                              *
    *                                                                         *
    * @param o_error                  Error message                           *
    * @param o_rehab_diag             Output cursor                           *
    *                                                                         *
    * @return                         Returns boolean                         *
    *                                                                         *
    * @author                         Gustavo Serrano                         *
    * @version                        1.0                                     *
    * @since                          2010/07/21                              *
    **************************************************************************/
    FUNCTION get_rehab_diag_list
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_episode    IN episode.id_episode%TYPE,
        o_rehab_diag OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_DIAG_LIST';
    
        l_id_episode_origin rehab_diagnosis.id_episode_origin%TYPE;
        l_id_schedule       schedule.id_schedule%TYPE;
        l_id_epis_type      epis_type.id_epis_type%TYPE;
    
        l_notes_lbl sys_message.desc_message%TYPE;
        l_error     t_error_out;
    
        l_exception EXCEPTION;
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_error := 'Fetch origin episode';
        IF NOT pk_rehab.get_origin_episode(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_id_episode        => i_episode,
                                           i_id_schedule       => NULL,
                                           o_id_episode_origin => l_id_episode_origin,
                                           o_id_schedule       => l_id_schedule,
                                           o_id_epis_type      => l_id_epis_type,
                                           o_error             => l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error     := 'Fetch label notes';
        l_notes_lbl := pk_message.get_message(i_lang, 'REHAB_M013');
    
        OPEN o_rehab_diag FOR
            SELECT rd.id_rehab_diagnosis,
                   rd.id_icf,
                   pk_translation.get_translation(i_lang, 'ICF.CODE_ICF.' || rd.id_icf) desc_icf,
                   (SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                      FROM icf i
                     WHERE i.id_icf = rd.id_icf
                       AND i.flg_available = pk_alert_constant.g_yes
                    CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                     START WITH i.id_icf IN (SELECT id_icf
                                               FROM icf
                                              WHERE flg_type = pk_interv_mfr.g_flg_icf_component)) icf_coding,
                   pk_date_utils.date_chr_short_read_tsz(i_lang, rd.dt_last_update, i_prof.institution, i_prof.software) dt_last_update,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, rd.id_prof_last_update) prof_last_update,
                   decode(rd.notes, NULL, NULL, l_notes_lbl) lbl_notes,
                   rd.notes,
                   rd.id_iq_initial_incapacity incapacity_initial_data,
                   rd.id_iqs_initial_incapacity incapacity_initial_scale,
                   pk_translation.get_translation(i_lang,
                                                  'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                  rd.id_iq_initial_incapacity) incapacity_initial_desc,
                   (SELECT iqsr.flg_code || iqsr.value
                      FROM icf_qualif_scale_rel iqsr
                     WHERE iqsr.id_icf_qualification = rd.id_iq_initial_incapacity
                       AND iqsr.id_icf_qualification_scale = rd.id_iqs_initial_incapacity) incapacity_initial_calc,
                   rd.id_iq_expected_result expected_result_data,
                   rd.id_iqs_expected_result expected_result_scale,
                   pk_translation.get_translation(i_lang,
                                                  'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                  rd.id_iq_expected_result) expected_result_desc,
                   (SELECT iqsr.flg_code || iqsr.value
                      FROM icf_qualif_scale_rel iqsr
                     WHERE iqsr.id_icf_qualification = rd.id_iq_expected_result
                       AND iqsr.id_icf_qualification_scale = rd.id_iqs_expected_result) expected_result_calc,
                   rd.id_iq_active_incapacity incapacity_actual_data,
                   rd.id_iqs_active_incapacity incapacity_actual_scale,
                   pk_translation.get_translation(i_lang,
                                                  'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                  rd.id_iq_active_incapacity) incapacity_actual_desc,
                   (SELECT iqsr.flg_code || iqsr.value
                      FROM icf_qualif_scale_rel iqsr
                     WHERE iqsr.id_icf_qualification = rd.id_iq_active_incapacity
                       AND iqsr.id_icf_qualification_scale = rd.id_iqs_active_incapacity) incapacity_actual_calc,
                   pk_sysdomain.get_img(i_lang, 'REHAB_DIAGNOSIS.FLG_STATUS', rd.flg_status) status_icon,
                   rd.flg_status,
                   --Status flag (E - Executing, R - Resolved, T - Confirmed, C - Cancelled)
                   CASE rd.flg_status
                       WHEN g_rehab_diag_flg_status_e THEN
                        20
                       WHEN g_rehab_diag_flg_status_r THEN
                        30
                       WHEN g_rehab_diag_flg_status_t THEN
                        10
                       WHEN g_rehab_diag_flg_status_c THEN
                        40
                   END status_rank,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, rd.id_prof_last_update) prof_name_last_update,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    rd.id_prof_last_update,
                                                    rd.dt_last_update,
                                                    rd.id_episode_origin) prof_speciality_last_update,
                   pk_date_utils.dt_chr_date_hour_tsz(i_lang, rd.dt_last_update, i_prof) dt_time_last_update,
                   pk_sysdomain.get_domain('REHAB_DIAGNOSIS.FLG_STATUS', rd.flg_status, i_lang) flg_status_description
              FROM rehab_diagnosis rd
             WHERE rd.id_episode_origin = l_id_episode_origin
             ORDER BY status_rank, rd.dt_last_update DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              l_error.ora_sqlcode,
                                              l_error.ora_sqlerrm,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_cursor_if_closed(o_rehab_diag);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            pk_types.open_cursor_if_closed(o_rehab_diag);
            RETURN FALSE;
    END get_rehab_diag_list;

    /**************************************************************************
    * Returns information to put in the Rehab Diagnosis Detail screen         *
    *                                                                         *
    * @param i_lang                   language id                             *
    * @param i_prof                   professional, software and              *
    *                                 institution ids                         *
    * @param i_rehab_diagnosis        Rehab diagnosis Id                      *
    *                                                                         *
    * @param o_error                  Error message                           *
    * @param o_rehab_diag_detail      Cursor with rehab diagnosis detail info *
    *                                                                         *
    * @return                         Returns boolean                         *
    *                                                                         *
    * @author                         Gustavo Serrano                         *
    * @version                        1.0                                     *
    * @since                          2010/07/22                              *
    **************************************************************************/
    FUNCTION get_rehab_diag_detail
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_rehab_diagnosis   IN rehab_diagnosis.id_rehab_diagnosis%TYPE,
        o_rehab_diag_detail OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_function_name VARCHAR2(30) := 'GET_REHAB_DIAG_DETAIL';
        TYPE t_code_messages IS TABLE OF sys_message.desc_message%TYPE INDEX BY sys_message.code_message%TYPE;
    
        aa_code_messages t_code_messages;
        va_code_messages table_varchar := table_varchar('REHAB_M008', --Incapacidade inicial:'
                                                        'REHAB_M009', --'Resultado esperado:'
                                                        'REHAB_M010', --'Incapacidade actual:'
                                                        'REHAB_M011', --'Notas:'
                                                        'REHAB_M014', --'Código - diagnóstico:'
                                                        'REHAB_M015', --'Notas de cancelamento:'
                                                        'REHAB_M016', --'Motivo de cancelamento:'
                                                        'REHAB_M017', --'Editado'
                                                        'REHAB_M012' --'Estado:'
                                                        );
    BEGIN
    
        -- get all messages
        g_error := 'GET MESSAGES';
        FOR i IN va_code_messages.first .. va_code_messages.last
        LOOP
            aa_code_messages(va_code_messages(i)) := pk_message.get_message(i_lang, va_code_messages(i));
        END LOOP;
    
        g_error := 'OPEN o_rehab_diag_detail';
        OPEN o_rehab_diag_detail FOR
            SELECT table_varchar(dt_last_update,
                                 prof_last_update,
                                 prof_spec_signature,
                                 lag(aa_code_messages('REHAB_M017'), 1, status_desc)
                                 over(PARTITION BY flg_status ORDER BY dt_orderby NULLS LAST)) action_desc,
                   table_varchar(aa_code_messages('REHAB_M014'),
                                 decode(lag(aux_icf_desc) over(ORDER BY flg_history DESC, dt_orderby),
                                        aux_icf_desc,
                                        NULL,
                                        aux_icf_desc)) icf_desc,
                   table_varchar(aa_code_messages('REHAB_M008'),
                                 decode(lag(aux_incapacity_initial_desc) over(ORDER BY flg_history DESC, dt_orderby),
                                        aux_incapacity_initial_desc,
                                        NULL,
                                        aux_incapacity_initial_desc)) incapacity_initial_desc,
                   table_varchar(aa_code_messages('REHAB_M009'),
                                 decode(lag(aux_expected_result_desc) over(ORDER BY flg_history DESC, dt_orderby),
                                        aux_expected_result_desc,
                                        NULL,
                                        aux_expected_result_desc)) expected_result_desc,
                   table_varchar(aa_code_messages('REHAB_M010'),
                                 decode(lag(aux_incapacity_actual_desc) over(ORDER BY flg_history DESC, dt_orderby),
                                        aux_incapacity_actual_desc,
                                        NULL,
                                        aux_incapacity_actual_desc)) incapacity_actual_desc,
                   table_varchar(aa_code_messages('REHAB_M012'),
                                 decode(lag(flg_status) over(ORDER BY flg_history DESC, dt_orderby),
                                        flg_status,
                                        NULL,
                                        status_desc)) final_status_desc,
                   table_varchar(aa_code_messages('REHAB_M011'),
                                 decode(lag(aux_notes_desc) over(ORDER BY flg_history DESC, dt_orderby),
                                        aux_notes_desc,
                                        NULL,
                                        aux_notes_desc)) notes_desc,
                   table_varchar(aa_code_messages('REHAB_M015'),
                                 decode(lag(aux_cancel_reason_desc) over(ORDER BY flg_history DESC, dt_orderby),
                                        aux_cancel_reason_desc,
                                        NULL,
                                        aux_cancel_reason_desc)) cancel_reason_desc,
                   table_varchar(aa_code_messages('REHAB_M016'),
                                 decode(lag(aux_notes_cancel_desc) over(ORDER BY flg_history DESC, dt_orderby),
                                        aux_notes_cancel_desc,
                                        NULL,
                                        aux_notes_cancel_desc)) notes_cancel_desc
              FROM (SELECT pk_date_utils.date_char_tsz(i_lang, rd.dt_last_update, i_prof.institution, i_prof.software) dt_last_update,
                           pk_prof_utils.get_name_signature(i_lang, i_prof, rd.id_prof_last_update) prof_last_update,
                           pk_string_utils.surround(pk_prof_utils.get_spec_signature(i_lang,
                                                                                     i_prof,
                                                                                     rd.id_prof_last_update,
                                                                                     rd.dt_last_update,
                                                                                     rd.id_episode),
                                                    pk_string_utils.g_pattern_parenthesis) prof_spec_signature,
                           pk_sysdomain.get_domain('REHAB_DIAGNOSIS.FLG_STATUS', rd.flg_status, i_lang) status_desc,
                           --
                           --rd.id_icf, 
                           regexp_replace((SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                                             FROM icf i
                                            WHERE i.id_icf = rd.id_icf
                                              AND i.flg_available = pk_alert_constant.g_yes
                                           CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                                            START WITH i.id_icf IN
                                                       (SELECT id_icf
                                                          FROM icf
                                                         WHERE flg_type = pk_interv_mfr.g_flg_icf_component)) || ' - ' ||
                                          pk_translation.get_translation(i_lang, 'ICF.CODE_ICF.' || rd.id_icf),
                                          '^(\s-\s*)$',
                                          NULL) aux_icf_desc,
                           --rd.id_iq_initial_incapacity
                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                             FROM icf_qualif_scale_rel iqsr
                                            WHERE iqsr.id_icf_qualification = rd.id_iq_initial_incapacity
                                              AND iqsr.id_icf_qualification_scale = rd.id_iqs_initial_incapacity) || ' ' ||
                                          pk_translation.get_translation(i_lang,
                                                                         'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                                         rd.id_iq_initial_incapacity),
                                          '^(\s*)$',
                                          NULL) aux_incapacity_initial_desc,
                           --rd.id_iq_expected_result
                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                             FROM icf_qualif_scale_rel iqsr
                                            WHERE iqsr.id_icf_qualification = rd.id_iq_expected_result
                                              AND iqsr.id_icf_qualification_scale = rd.id_iqs_expected_result) || ' ' ||
                                          pk_translation.get_translation(i_lang,
                                                                         'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                                         rd.id_iq_expected_result),
                                          '^(\s*)$',
                                          NULL) aux_expected_result_desc,
                           --rd.id_iq_active_incapacity
                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                             FROM icf_qualif_scale_rel iqsr
                                            WHERE iqsr.id_icf_qualification = rd.id_iq_active_incapacity
                                              AND iqsr.id_icf_qualification_scale = rd.id_iqs_active_incapacity) || ' ' ||
                                          pk_translation.get_translation(i_lang,
                                                                         'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                                         rd.id_iq_active_incapacity),
                                          '^(\s*)$',
                                          NULL) aux_incapacity_actual_desc,
                           --notas
                           regexp_replace(rd.notes, '^(\s*)$', NULL) aux_notes_desc,
                           --motivo de cancelamento
                           pk_translation.get_translation(i_lang,
                                                          'CANCEL_REASON.CODE_CANCEL_REASON.' || rd.id_cancel_reason) aux_cancel_reason_desc,
                           --notas cancelamento
                           rd.notes_cancel        aux_notes_cancel_desc,
                           rd.flg_status,
                           rd.dt_last_update      dt_orderby,
                           pk_alert_constant.g_no flg_history
                      FROM rehab_diagnosis rd
                     WHERE rd.id_rehab_diagnosis = i_rehab_diagnosis
                    UNION ALL
                    SELECT pk_date_utils.date_char_tsz(i_lang, rdh.dt_last_update, i_prof.institution, i_prof.software) dt_last_update,
                           pk_prof_utils.get_name_signature(i_lang, i_prof, rdh.id_prof_last_update) prof_last_update,
                           pk_string_utils.surround(pk_prof_utils.get_spec_signature(i_lang,
                                                                                     i_prof,
                                                                                     rdh.id_prof_last_update,
                                                                                     rdh.dt_last_update,
                                                                                     rdh.id_episode),
                                                    pk_string_utils.g_pattern_parenthesis) prof_spec_signature,
                           pk_sysdomain.get_domain('REHAB_DIAGNOSIS.FLG_STATUS', rdh.flg_status, i_lang) status_desc,
                           --
                           --rdh.id_icf, 
                           regexp_replace((SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                                             FROM icf i
                                            WHERE i.id_icf = rdh.id_icf
                                              AND i.flg_available = pk_alert_constant.g_yes
                                           CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                                            START WITH i.id_icf IN
                                                       (SELECT id_icf
                                                          FROM icf
                                                         WHERE flg_type = pk_interv_mfr.g_flg_icf_component)) || ' - ' ||
                                          pk_translation.get_translation(i_lang, 'ICF.CODE_ICF.' || rdh.id_icf),
                                          '^(\s-\s*)$',
                                          NULL) aux_icf_desc,
                           --rdh.id_iq_initial_incapacity
                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                             FROM icf_qualif_scale_rel iqsr
                                            WHERE iqsr.id_icf_qualification = rdh.id_iq_initial_incapacity
                                              AND iqsr.id_icf_qualification_scale = rdh.id_iqs_initial_incapacity) || ' ' ||
                                          pk_translation.get_translation(i_lang,
                                                                         'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                                         rdh.id_iq_initial_incapacity),
                                          '^(\s*)$',
                                          NULL) aux_incapacity_initial_desc,
                           --rdh.id_iq_expected_result
                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                             FROM icf_qualif_scale_rel iqsr
                                            WHERE iqsr.id_icf_qualification = rdh.id_iq_expected_result
                                              AND iqsr.id_icf_qualification_scale = rdh.id_iqs_expected_result) || ' ' ||
                                          pk_translation.get_translation(i_lang,
                                                                         'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                                         rdh.id_iq_expected_result),
                                          '^(\s*)$',
                                          NULL) aux_expected_result_desc,
                           --rdh.id_iq_active_incapacity
                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                             FROM icf_qualif_scale_rel iqsr
                                            WHERE iqsr.id_icf_qualification = rdh.id_iq_active_incapacity
                                              AND iqsr.id_icf_qualification_scale = rdh.id_iqs_active_incapacity) || ' ' ||
                                          pk_translation.get_translation(i_lang,
                                                                         'ICF_QUALIFICATION.CODE_ICF_QUALIFICATION.' ||
                                                                         rdh.id_iq_active_incapacity),
                                          '^(\s*)$',
                                          NULL) aux_incapacity_actual_desc,
                           --notas
                           regexp_replace(rdh.notes, '^(\s*)$', NULL) aux_notes_desc,
                           --motivo de cancelamento
                           pk_translation.get_translation(i_lang,
                                                          'CANCEL_REASON.CODE_CANCEL_REASON.' || rdh.id_cancel_reason) aux_cancel_reason_desc,
                           --notas cancelamento
                           rdh.notes_cancel        aux_notes_cancel_desc,
                           rdh.flg_status,
                           rdh.dt_last_update      dt_orderby,
                           pk_alert_constant.g_yes flg_history
                      FROM rehab_diagnosis_hist rdh
                     WHERE rdh.id_rehab_diagnosis = i_rehab_diagnosis)
             ORDER BY flg_history, dt_orderby DESC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN no_data_found THEN
            pk_types.open_my_cursor(o_rehab_diag_detail);
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_function_name,
                                              o_error);
            pk_types.open_my_cursor(o_rehab_diag_detail);
            RETURN FALSE;
    END get_rehab_diag_detail;

    /**********************************************************************************************
    * This function can be used to edit a given treatment (WITH COMMIT)
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient
    * %param i_workflow_type          W, S, other
    * %param i_from_state             current status
    * %param i_to_state               destination status
    * %param i_id_rehab_grid          
    * %param i_id_rehab_presc         prescription
    * %param i_id_epis_origin         origin episode
    * %param i_id_rehab_schedule      schedule
    * %param i_id_cancel_reason       cancel reason
    * %param i_cancel_notes           cancel notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION set_rehab_workflow_change
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        --
        i_workflow_type  IN VARCHAR2,
        i_from_state     IN VARCHAR2,
        i_to_state       IN VARCHAR2,
        i_id_rehab_grid  IN NUMBER,
        i_id_rehab_presc IN rehab_sch_need.id_rehab_sch_need%TYPE,
        --create_visit
        i_id_epis_origin    IN episode.id_episode%TYPE,
        i_id_rehab_schedule IN rehab_schedule.id_rehab_schedule%TYPE,
        i_id_schedule       IN schedule.id_schedule%TYPE,
        --
        i_id_cancel_reason IN rehab_schedule.id_cancel_reason%TYPE,
        i_cancel_notes     IN rehab_schedule.notes%TYPE DEFAULT NULL,
        --
        i_transaction_id IN VARCHAR2,
        o_id_episode     OUT episode.id_episode%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_WORKFLOW_CHANGE';
    BEGIN
    
        IF NOT pk_rehab.set_rehab_wf_change_nocommit(i_lang              => i_lang,
                                                     i_prof              => i_prof,
                                                     i_id_patient        => i_id_patient,
                                                     i_workflow_type     => i_workflow_type,
                                                     i_from_state        => i_from_state,
                                                     i_to_state          => i_to_state,
                                                     i_id_rehab_grid     => i_id_rehab_grid,
                                                     i_id_rehab_presc    => i_id_rehab_presc,
                                                     i_id_epis_origin    => i_id_epis_origin,
                                                     i_id_rehab_schedule => i_id_rehab_schedule,
                                                     i_id_schedule       => i_id_schedule,
                                                     i_id_cancel_reason  => i_id_cancel_reason,
                                                     i_cancel_notes      => i_cancel_notes,
                                                     i_transaction_id    => i_transaction_id,
                                                     o_id_episode        => o_id_episode,
                                                     o_error             => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        COMMIT;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END;

    /**
    * Get a professional's default dep_clin_serv.
    *
    * @param i_prof           logged professional structure
    *
    * @return                 dep_clin_serv identifier
    *
    * @author                 Pedro Carneiro
    * @version                 2.6.0.1
    * @since                  2010/07/01
    */
    FUNCTION get_prof_def_dcs(i_prof IN profissional) RETURN dep_clin_serv.id_dep_clin_serv%TYPE IS
        l_dep_clin_serv dep_clin_serv.id_dep_clin_serv%TYPE := NULL;
        l_software      software.id_software%TYPE := NULL;
        l_found         BOOLEAN;
    
        CURSOR c_prof_def_dcs(l_software software.id_software%TYPE) IS
            SELECT dcs.id_dep_clin_serv
              FROM dep_clin_serv dcs
              JOIN prof_dep_clin_serv pdcs
                ON dcs.id_dep_clin_serv = pdcs.id_dep_clin_serv
              JOIN department d
                ON dcs.id_department = d.id_department
              JOIN software_dept sd
                ON d.id_dept = sd.id_dept
             WHERE dcs.flg_available = pk_alert_constant.g_yes
               AND pdcs.id_professional = i_prof.id
               AND pdcs.flg_status = pk_alert_constant.g_status_selected
               AND pdcs.flg_default = pk_alert_constant.g_yes
               AND d.id_institution = i_prof.institution
               AND d.flg_available = pk_alert_constant.g_yes
               AND sd.id_software IN (i_prof.software, l_software)
               AND rownum = 1
             ORDER BY sd.id_software DESC;
    BEGIN
        --ACTIVITY THERAPIST episodes should be associated with INPATIENT dep_clin_serv
        IF i_prof.software = pk_alert_constant.g_soft_rehab
        THEN
            l_software := pk_alert_constant.g_soft_inpatient;
        ELSIF i_prof.software = pk_alert_constant.g_soft_adt
        THEN
            l_software := pk_alert_constant.g_soft_rehab;
        ELSE
            l_software := i_prof.software;
        END IF;
    
        g_error := 'OPEN c_prof_def_dcs';
        OPEN c_prof_def_dcs(l_software);
        FETCH c_prof_def_dcs
            INTO l_dep_clin_serv;
        l_found := c_prof_def_dcs%FOUND;
        CLOSE c_prof_def_dcs;
    
        IF NOT l_found
        THEN
            l_dep_clin_serv := NULL;
        END IF;
    
        RETURN l_dep_clin_serv;
    END get_prof_def_dcs;

    /**********************************************************************************************
    * This function can be used to edit a given treatment
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient
    * %param i_workflow_type          W, S, other
    * %param i_from_state             current status
    * %param i_to_state               destination status
    * %param i_id_rehab_grid          
    * %param i_id_rehab_presc         prescription
    * %param i_id_epis_origin         origin episode
    * %param i_id_rehab_schedule      schedule
    * %param i_id_cancel_reason       cancel reason
    * %param i_cancel_notes           cancel notes
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION set_rehab_wf_change_cmf
    --    FUNCTION set_rehab_wf_change_nocommit
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        --
        i_workflow_type  IN VARCHAR2,
        i_from_state     IN VARCHAR2,
        i_to_state       IN VARCHAR2,
        i_id_rehab_grid  IN NUMBER,
        i_id_rehab_presc IN rehab_sch_need.id_rehab_sch_need%TYPE,
        --create_visit
        i_id_epis_origin    IN episode.id_episode%TYPE,
        i_id_rehab_schedule IN rehab_schedule.id_rehab_schedule%TYPE,
        i_id_schedule       IN schedule.id_schedule%TYPE,
        --
        i_id_cancel_reason IN rehab_schedule.id_cancel_reason%TYPE,
        i_cancel_notes     IN rehab_schedule.notes%TYPE DEFAULT NULL,
        --
        i_transaction_id IN VARCHAR2,
        o_id_episode     OUT episode.id_episode%TYPE,
        o_error          OUT t_error_out
        
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_WORKFLOW_CHANGE';
        l_id_visit      visit.id_visit%TYPE;
        l_epis_type     epis_type.id_epis_type%TYPE := 15;
        l_dep_clin_serv dep_clin_serv.id_dep_clin_serv%TYPE := NULL;
        l_room          epis_type_room.id_room%TYPE;
    
        -- SCH 3.0 variable
        l_transaction_id VARCHAR2(4000);
    
        l_new_episode        episode.id_episode%TYPE;
        l_epis_type_rehab_ap epis_type.id_epis_type%TYPE := 25; --epis_type Rehab appointments
    
        CURSOR c_visit(i_id_episode episode.id_episode%TYPE) IS
            SELECT e.id_visit
              FROM episode e
             WHERE e.id_episode = i_id_episode;
    
        l_rows                        table_varchar := table_varchar();
        l_id_rehab_epis_encounter     rehab_epis_encounter.id_rehab_epis_encounter%TYPE;
        l_id_rehab_epis_encounter_aux rehab_epis_encounter.id_rehab_epis_encounter%TYPE; -- Used for rehab plans
        l_id_rehab_epis_enc_hist      rehab_epis_enc_hist.id_rehab_epis_enc_hist%TYPE;
        l_id_epis_encounter           rehab_epis_encounter.id_rehab_epis_encounter%TYPE;
        l_id_schedule                 rehab_schedule.id_schedule%TYPE;
        l_id_rehab_presc              rehab_presc.id_rehab_presc%TYPE; --Different meaning from i_id_rehab_presc
        l_id_rehab_presc_hist         rehab_presc_hist.id_rehab_presc_hist%TYPE;
        l_dt_rehab_presc              rehab_presc.dt_rehab_presc%TYPE;
        l_id_rehab_area_interv        rehab_presc.id_rehab_area_interv%TYPE;
    
        l_id_cs            clinical_service.id_clinical_service%TYPE;
        l_id_dep_clin_serv schedule.id_dcs_requested%TYPE;
        l_id_dcs_requested schedule.id_dcs_requested%TYPE;
    
        l_exist    NUMBER;
        l_error_in t_error_in := t_error_in();
        l_ret      BOOLEAN;
        l_common_exception EXCEPTION;
        l_error_message sys_message.desc_message%TYPE;
    
        --Variable to check for requests of the same type (ALERT-284707)
        l_tbl_sch_needs            table_number := table_number();
        l_id_epis_origin           episode.id_episode%TYPE;
        l_tbl_rehab_epis_encounter table_table_number := table_table_number();
    
        FUNCTION check_concluded_plan(i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE) RETURN BOOLEAN IS
        
            l_count      NUMBER := 0;
            l_n_sessions rehab_sch_need.sessions%TYPE;
            l_dt_begin   TIMESTAMP(6) WITH LOCAL TIME ZONE;
        
        BEGIN
        
            l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
        
            SELECT COUNT(1)
              INTO l_count
              FROM rehab_epis_encounter ree
             WHERE ree.id_rehab_sch_need = i_id_rehab_sch_need
               AND (ree.flg_status IN (pk_rehab.g_rehab_epis_enc_status_o) OR
                   (ree.flg_status = pk_rehab.g_rehab_epis_enc_status_s AND
                   ree.dt_creation < pk_date_utils.add_days_to_tstz(l_dt_begin, -1)) OR
                   (ree.flg_status = pk_rehab.g_rehab_epis_enc_status_f AND
                   ree.flg_rehab_workflow_type = pk_rehab.g_workflow_type_s));
        
            SELECT rsn.sessions
              INTO l_n_sessions
              FROM rehab_sch_need rsn
             WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need;
        
            IF l_n_sessions = l_count
            THEN
                RETURN TRUE;
            ELSE
                RETURN FALSE;
            END IF;
        
        END check_concluded_plan;
    
        FUNCTION get_same_type_requests
        (
            i_prof              IN profissional,
            i_id_patient        IN patient.id_patient%TYPE,
            i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
            o_sch_needs         OUT table_number
        ) RETURN BOOLEAN IS
            l_dt_begin TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_dt_end   TIMESTAMP(6) WITH LOCAL TIME ZONE;
        BEGIN
        
            l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
            l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
        
            SELECT DISTINCT rsn.id_rehab_sch_need
              BULK COLLECT
              INTO o_sch_needs
              FROM rehab_presc rp
              JOIN rehab_sch_need rsn
                ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
              JOIN episode e
                ON e.id_episode = rsn.id_episode_origin
              LEFT JOIN rehab_epis_encounter re
                ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND l_dt_end AND
                   re.id_rehab_sch_need = rsn.id_rehab_sch_need)
             WHERE e.id_patient = i_id_patient
               AND rsn.id_rehab_session_type IN
                   (SELECT rsn_i.id_rehab_session_type
                      FROM rehab_sch_need rsn_i
                     WHERE rsn_i.id_rehab_sch_need = i_id_rehab_sch_need)
               AND rsn.flg_status = g_rehab_sch_need_no_sched
               AND rp.flg_status NOT IN (g_rehab_presc_referral,
                                         g_rehab_presc_not_order_reas,
                                         pk_alert_constant.g_cancelled,
                                         g_rehab_presc_discontinued)
               AND (re.flg_status IS NULL OR
                   re.flg_status NOT IN (pk_rehab.g_rehab_epis_enc_status_o,
                                          pk_rehab.g_rehab_epis_enc_status_c,
                                          pk_rehab.g_rehab_epis_enc_status_f))
               AND e.flg_status = pk_alert_constant.g_active
               AND rp.id_institution = i_prof.institution
               AND (rsn.dt_begin IS NULL OR (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= 0 OR
                   (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= -1 AND
                   extract(DAY FROM(current_timestamp)) >= extract(DAY FROM(rsn.dt_begin)))))
               AND (rsn.sessions >
                   (SELECT COUNT(1)
                       FROM rehab_epis_encounter ree_c
                      WHERE ree_c.id_episode_origin = rsn.id_episode_origin
                        AND ree_c.id_rehab_sch_need = rsn.id_rehab_sch_need
                        AND (ree_c.flg_status IN (pk_rehab.g_rehab_epis_enc_status_o) OR
                            (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_s AND
                            ree_c.dt_creation < pk_date_utils.add_days_to_tstz(l_dt_begin, -1)) OR
                            (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_f AND
                            ree_c.flg_rehab_workflow_type = pk_rehab.g_workflow_type_s))));
        
            RETURN TRUE;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN FALSE;
        END get_same_type_requests;
    
        FUNCTION get_same_type_epis_encounter
        (
            i_prof                    IN profissional,
            i_id_patient              IN patient.id_patient%TYPE,
            i_id_rehab_epis_encounter IN rehab_epis_encounter.id_rehab_epis_encounter%TYPE,
            o_rehab_epis_encounters   OUT table_table_number
        ) RETURN BOOLEAN IS
            l_dt_begin TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_dt_end   TIMESTAMP(6) WITH LOCAL TIME ZONE;
        BEGIN
        
            l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
            l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
        
            SELECT table_number(t.id_rehab_epis_encounter, t.id_rehab_sch_need)
              BULK COLLECT
              INTO o_rehab_epis_encounters
              FROM (SELECT DISTINCT re.id_rehab_epis_encounter, rsn.id_rehab_sch_need
                      FROM rehab_presc rp
                      JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                      JOIN episode e
                        ON e.id_episode = rsn.id_episode_origin
                      JOIN rehab_epis_encounter re
                        ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND l_dt_end AND
                           re.id_rehab_sch_need = rsn.id_rehab_sch_need)
                     WHERE e.id_patient = i_id_patient
                       AND rsn.id_rehab_session_type IN
                           (SELECT rsn_i.id_rehab_session_type
                              FROM rehab_sch_need rsn_i
                             WHERE rsn_i.id_rehab_sch_need = id_rehab_sch_need)
                       AND rsn.flg_status = g_rehab_sch_need_no_sched
                       AND rp.flg_status NOT IN (g_rehab_presc_referral,
                                                 g_rehab_presc_not_order_reas,
                                                 pk_alert_constant.g_cancelled,
                                                 g_rehab_presc_discontinued)
                       AND (re.flg_status IS NULL OR
                           re.flg_status NOT IN (pk_rehab.g_rehab_epis_enc_status_o,
                                                  pk_rehab.g_rehab_epis_enc_status_c,
                                                  pk_rehab.g_rehab_epis_enc_status_f))
                       AND e.flg_status = pk_alert_constant.g_active
                       AND rp.id_institution = i_prof.institution
                       AND (rsn.dt_begin IS NULL OR
                           (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= 0 OR
                           (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= -1 AND
                           extract(DAY FROM(current_timestamp)) >= extract(DAY FROM(rsn.dt_begin)))))) t;
        
            RETURN TRUE;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN FALSE;
        END get_same_type_epis_encounter;
    
        FUNCTION get_plan_epis_encounter
        (
            i_prof              IN profissional,
            i_id_episode_origin IN episode.id_episode%TYPE,
            i_state             IN rehab_epis_encounter.flg_status%TYPE
        ) RETURN rehab_epis_encounter.id_rehab_epis_encounter%TYPE IS
            l_dt_begin                TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_dt_end                  TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_id_rehab_epis_encounter rehab_epis_encounter.id_rehab_epis_encounter%TYPE;
        BEGIN
            l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
            l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
        
            SELECT ree.id_rehab_epis_encounter
              INTO l_id_rehab_epis_encounter
              FROM rehab_epis_encounter ree
             WHERE ree.id_episode_origin = i_id_episode_origin
               AND ree.flg_status = i_state
               AND (ree.dt_creation BETWEEN l_dt_begin AND l_dt_end)
               AND ree.id_rehab_sch_need IS NULL;
        
            RETURN l_id_rehab_epis_encounter;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN NULL;
        END get_plan_epis_encounter;
    
    BEGIN
        g_error := 'SET_REHAB_WORKFLOW_CHANGE: i_id_patient = ' || i_id_patient;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        IF i_workflow_type = g_workflow_type_w
        THEN
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_s THEN
                
                    --Check if it is a rehabilitation plan (i_id_rehab_presc is sent as null)
                    IF i_id_rehab_presc IS NULL
                    THEN
                        l_tbl_sch_needs.extend(1);
                        l_tbl_sch_needs(1) := NULL;
                    ELSE
                        --Check if there are more rehab sessions of the same type for this patient for today
                        --because the patients grid agregates sessions of the same type for a given patient.
                        IF NOT get_same_type_requests(i_prof              => i_prof,
                                                      i_id_patient        => i_id_patient,
                                                      i_id_rehab_sch_need => i_id_rehab_presc,
                                                      o_sch_needs         => l_tbl_sch_needs)
                        THEN
                            l_tbl_sch_needs.extend(1);
                            l_tbl_sch_needs(1) := i_id_rehab_presc;
                        END IF;
                    END IF;
                
                    FOR i IN l_tbl_sch_needs.first .. l_tbl_sch_needs.last
                    LOOP
                    
                        l_exist          := 0;
                        l_id_rehab_presc := NULL;
                    
                        BEGIN
                            SELECT 1
                              INTO l_exist
                              FROM rehab_epis_encounter ree
                             WHERE pk_date_utils.dt_chr_tsz(1, ree.dt_creation, NULL, NULL) =
                                   pk_date_utils.dt_chr_tsz(1, current_timestamp, NULL, NULL)
                               AND ree.id_rehab_sch_need = l_tbl_sch_needs(i);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_exist := 0;
                        END;
                    
                        BEGIN
                            SELECT rp.id_rehab_presc, rp.dt_rehab_presc, rp.id_rehab_area_interv
                              INTO l_id_rehab_presc, l_dt_rehab_presc, l_id_rehab_area_interv
                              FROM rehab_presc rp
                             WHERE rp.id_rehab_sch_need = l_tbl_sch_needs(i)
                               AND rownum() = 1;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_id_rehab_presc := NULL;
                        END;
                    
                        IF l_exist = 0
                        THEN
                            --create episode:
                            g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                            l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(NULL, i_prof);
                        
                            BEGIN
                                SELECT rsn.id_episode_origin
                                  INTO l_id_epis_origin
                                  FROM rehab_sch_need rsn
                                 WHERE rsn.id_rehab_sch_need = l_tbl_sch_needs(i);
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_id_epis_origin := i_id_epis_origin;
                            END;
                        
                            OPEN c_visit(l_id_epis_origin);
                            FETCH c_visit
                                INTO l_id_visit;
                            CLOSE c_visit;
                        
                            -- get the professional's default dep_clin_serv
                            g_error         := 'CALL get_prof_def_dcs';
                            l_dep_clin_serv := get_prof_def_dcs(i_prof => i_prof);
                        
                            IF l_dep_clin_serv IS NULL
                            THEN
                                -- if the default dep_clin_serv is not set, warn the user                           
                                l_error_message := pk_message.get_message(i_lang      => i_lang,
                                                                          i_prof      => i_prof,
                                                                          i_code_mess => 'CONSULT_REQUEST_M003');
                                RAISE l_common_exception;
                            END IF;
                        
                            IF NOT pk_visit.create_episode(i_lang                 => i_lang,
                                                           i_id_visit             => l_id_visit,
                                                           i_id_professional      => i_prof,
                                                           i_id_sched             => NULL,
                                                           i_id_episode           => NULL,
                                                           i_health_plan          => NULL,
                                                           i_epis_type            => l_epis_type,
                                                           i_dep_clin_serv        => l_dep_clin_serv,
                                                           i_sysdate              => NULL,
                                                           i_sysdate_tstz         => NULL,
                                                           i_flg_ehr              => pk_visit.g_flg_ehr_n,
                                                           i_flg_appointment_type => pk_visit.g_null_appointment_type,
                                                           i_transaction_id       => l_transaction_id,
                                                           o_episode              => l_new_episode,
                                                           o_error                => o_error)
                            THEN
                                l_error_message := o_error.err_action;
                                RAISE l_common_exception;
                            END IF;
                        
                            --use the same room that in epis_origin
                            g_error := 'UPDATE EPIS_INFO ROOM';
                            IF i_id_rehab_schedule IS NULL
                               AND l_id_epis_origin IS NOT NULL
                            THEN
                                BEGIN
                                    SELECT id_room
                                      INTO l_room
                                      FROM epis_info ei
                                     WHERE ei.id_episode = l_id_epis_origin;
                                EXCEPTION
                                    WHEN no_data_found THEN
                                        l_room := NULL;
                                END;
                            
                                g_error := 'UPDATE EPIS_INFO ROOM';
                                ts_epis_info.upd(id_room_in  => l_room,
                                                 id_room_nin => FALSE,
                                                 where_in    => 'id_episode = ' || l_new_episode,
                                                 rows_out    => l_rows);
                            
                                g_error := 'UPDATE EPIS_INFO ROOM';
                                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'EPIS_INFO',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            
                            END IF;
                        
                            IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                           i_id_episode => l_new_episode,
                                                           i_prof       => i_prof,
                                                           o_error      => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            g_error := 'CALL ts_episode.upd';
                            ts_episode.upd(id_episode_in       => l_new_episode,
                                           id_prev_episode_in  => l_id_epis_origin,
                                           id_prev_episode_nin => FALSE,
                                           rows_out            => l_rows);
                        
                            g_error := 'CALL t_data_gov_mnt.process_update I';
                            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                          i_prof         => i_prof,
                                                          i_table_name   => 'EPISODE',
                                                          i_rowids       => l_rows,
                                                          o_error        => o_error,
                                                          i_list_columns => table_varchar('ID_PREV_EPISODE'));
                        
                            l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                            ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                        id_episode_origin_in       => l_id_epis_origin,
                                                        id_episode_rehab_in        => l_new_episode,
                                                        flg_status_in              => i_to_state,
                                                        flg_rehab_workflow_type_in => i_workflow_type,
                                                        dt_creation_in             => g_sysdate_tstz,
                                                        dt_last_update_in          => g_sysdate_tstz,
                                                        id_prof_creation_in        => i_prof.id,
                                                        id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                        rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                            ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                       id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                       id_episode_origin_in       => l_id_epis_origin,
                                                       id_episode_rehab_in        => l_new_episode,
                                                       flg_status_in              => i_to_state,
                                                       flg_rehab_workflow_type_in => i_workflow_type,
                                                       dt_creation_in             => g_sysdate_tstz,
                                                       dt_last_update_in          => g_sysdate_tstz,
                                                       id_prof_creation_in        => i_prof.id,
                                                       id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                       rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            IF l_id_rehab_presc IS NOT NULL
                            THEN
                                ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                                   flg_status_in     => g_rehab_presc_ongoing);
                            
                                l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                                ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                        dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                        id_professional_hist_in => i_prof.id,
                                                        id_rehab_presc_in       => l_id_rehab_presc,
                                                        dt_rehab_presc_in       => l_dt_rehab_presc,
                                                        id_professional_in      => i_prof.id,
                                                        id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                        id_rehab_sch_need_in    => l_tbl_sch_needs(i),
                                                        id_exec_institution_in  => i_prof.institution,
                                                        flg_status_in           => g_rehab_presc_ongoing);
                            END IF;
                        END IF;
                    END LOOP;
                WHEN g_rehab_epis_enc_status_c THEN
                
                    IF i_id_rehab_grid IS NULL
                    THEN
                        IF i_id_rehab_presc IS NULL
                        THEN
                            l_tbl_sch_needs.extend(1);
                            l_tbl_sch_needs(1) := NULL;
                        ELSE
                            IF NOT get_same_type_requests(i_prof              => i_prof,
                                                          i_id_patient        => i_id_patient,
                                                          i_id_rehab_sch_need => i_id_rehab_presc,
                                                          o_sch_needs         => l_tbl_sch_needs)
                            THEN
                                l_tbl_sch_needs.extend(1);
                                l_tbl_sch_needs(1) := i_id_rehab_presc;
                            END IF;
                        END IF;
                    
                        FOR i IN l_tbl_sch_needs.first .. l_tbl_sch_needs.last
                        LOOP
                            BEGIN
                                SELECT rsn.id_episode_origin
                                  INTO l_id_epis_origin
                                  FROM rehab_sch_need rsn
                                 WHERE rsn.id_rehab_sch_need = l_tbl_sch_needs(i);
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_id_epis_origin := i_id_epis_origin;
                            END;
                        
                            l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                            ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                        id_episode_origin_in       => l_id_epis_origin,
                                                        id_episode_rehab_in        => NULL,
                                                        flg_status_in              => i_to_state,
                                                        flg_rehab_workflow_type_in => i_workflow_type,
                                                        dt_creation_in             => g_sysdate_tstz,
                                                        dt_last_update_in          => g_sysdate_tstz,
                                                        id_prof_creation_in        => i_prof.id,
                                                        id_cancel_reason_in        => i_id_cancel_reason,
                                                        dt_cancel_in               => g_sysdate_tstz,
                                                        cancel_notes_in            => i_cancel_notes,
                                                        id_prof_cancel_in          => i_prof.id,
                                                        id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                        rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                            ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                       id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                       id_episode_origin_in       => l_id_epis_origin,
                                                       id_episode_rehab_in        => l_new_episode,
                                                       flg_status_in              => i_to_state,
                                                       flg_rehab_workflow_type_in => i_workflow_type,
                                                       dt_creation_in             => g_sysdate_tstz,
                                                       dt_last_update_in          => g_sysdate_tstz,
                                                       id_prof_creation_in        => i_prof.id,
                                                       id_cancel_reason_in        => i_id_cancel_reason,
                                                       dt_cancel_in               => g_sysdate_tstz,
                                                       cancel_notes_in            => i_cancel_notes,
                                                       id_prof_cancel_in          => i_prof.id,
                                                       id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                       rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        END LOOP;
                    ELSE
                    
                        IF i_id_rehab_presc IS NULL
                        THEN
                            l_tbl_rehab_epis_encounter.extend(1);
                            l_tbl_rehab_epis_encounter(1) := table_number(i_id_rehab_grid, NULL);
                        ELSE
                            IF NOT
                                get_same_type_epis_encounter(i_prof                    => i_prof,
                                                             i_id_patient              => i_id_patient,
                                                             i_id_rehab_epis_encounter => i_id_rehab_grid,
                                                             o_rehab_epis_encounters   => l_tbl_rehab_epis_encounter)
                            THEN
                                l_tbl_rehab_epis_encounter.extend(1);
                                l_tbl_rehab_epis_encounter(1) := table_number(i_id_rehab_grid, i_id_rehab_presc);
                            END IF;
                        END IF;
                    
                        FOR i IN l_tbl_rehab_epis_encounter.first .. l_tbl_rehab_epis_encounter.last
                        LOOP
                            g_error := 'CALL rehab_epis_encounter.upd';
                            ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                        flg_status_in              => i_to_state,
                                                        dt_last_update_in          => g_sysdate_tstz,
                                                        id_cancel_reason_in        => i_id_cancel_reason,
                                                        dt_cancel_in               => g_sysdate_tstz,
                                                        cancel_notes_in            => i_cancel_notes,
                                                        id_prof_cancel_in          => i_prof.id,
                                                        rows_out                   => l_rows);
                        
                            g_error := 'CALL t_data_gov_mnt.process_update I';
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            BEGIN
                                SELECT rsn.id_episode_origin
                                  INTO l_id_epis_origin
                                  FROM rehab_sch_need rsn
                                 WHERE rsn.id_rehab_sch_need = l_tbl_rehab_epis_encounter(i) (2);
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_id_epis_origin := i_id_epis_origin;
                            END;
                        
                            l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                            ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                       id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                       id_episode_origin_in       => l_id_epis_origin, -------
                                                       id_episode_rehab_in        => l_new_episode,
                                                       flg_status_in              => i_to_state,
                                                       flg_rehab_workflow_type_in => i_workflow_type,
                                                       dt_creation_in             => g_sysdate_tstz,
                                                       dt_last_update_in          => g_sysdate_tstz,
                                                       id_prof_creation_in        => i_prof.id,
                                                       id_cancel_reason_in        => i_id_cancel_reason,
                                                       dt_cancel_in               => g_sysdate_tstz,
                                                       cancel_notes_in            => i_cancel_notes,
                                                       id_prof_cancel_in          => i_prof.id,
                                                       rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                        END LOOP;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_o THEN
                
                    IF i_id_rehab_presc IS NULL
                    THEN
                        --REHAB PLAN without i_id_rehab_presc
                        l_tbl_rehab_epis_encounter.extend(1);
                        l_id_rehab_epis_encounter_aux := get_plan_epis_encounter(i_prof              => i_prof,
                                                                                 i_id_episode_origin => i_id_epis_origin,
                                                                                 i_state             => i_from_state);
                        l_tbl_rehab_epis_encounter(1) := table_number(l_id_rehab_epis_encounter_aux, i_id_rehab_presc);
                    
                    ELSE
                        IF NOT get_same_type_epis_encounter(i_prof                    => i_prof,
                                                            i_id_patient              => i_id_patient,
                                                            i_id_rehab_epis_encounter => i_id_rehab_grid,
                                                            o_rehab_epis_encounters   => l_tbl_rehab_epis_encounter)
                        THEN
                            l_tbl_rehab_epis_encounter.extend(1);
                            l_tbl_rehab_epis_encounter(1) := table_number(i_id_rehab_grid, i_id_rehab_presc);
                        END IF;
                    END IF;
                
                    FOR i IN l_tbl_rehab_epis_encounter.first .. l_tbl_rehab_epis_encounter.last
                    LOOP
                    
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                        BEGIN
                            SELECT s.id_episode_rehab
                              INTO l_new_episode
                              FROM rehab_epis_encounter s
                             WHERE s.id_rehab_epis_encounter = l_tbl_rehab_epis_encounter(i) (1);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_new_episode := NULL;
                        END;
                    
                        IF l_new_episode IS NOT NULL
                        THEN
                        
                            g_error := 'CALL ts_episode.upd';
                            ts_episode.upd(id_episode_in   => l_new_episode,
                                           flg_status_in   => g_epis_flg_status_inactive,
                                           dt_end_tstz_in  => g_sysdate_tstz,
                                           dt_end_tstz_nin => FALSE,
                                           rows_out        => l_rows);
                            g_error := 'CALL t_data_gov_mnt.process_update';
                            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                          i_prof         => i_prof,
                                                          i_table_name   => 'EPISODE',
                                                          i_rowids       => l_rows,
                                                          o_error        => o_error,
                                                          i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
                        END IF;
                    
                        BEGIN
                            SELECT rsn.id_episode_origin
                              INTO l_id_epis_origin
                              FROM rehab_sch_need rsn
                             WHERE rsn.id_rehab_sch_need = l_tbl_rehab_epis_encounter(i) (2);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_id_epis_origin := i_id_epis_origin;
                        END;
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                   id_episode_origin_in       => l_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        --Inserts the event EPISODE_APPOINTMENT_END         
                        pk_ia_event_common.episode_appointment_end(i_id_institution => i_prof.institution,
                                                                   i_id_episode     => nvl(l_new_episode,
                                                                                           l_id_epis_origin));
                    
                        IF i_id_rehab_presc IS NOT NULL
                        THEN
                            --Check if this is the last session of the rehab prescription
                            --If it is, sets the record in rehab_presc as finished                        
                            IF check_concluded_plan(l_tbl_rehab_epis_encounter(i) (2))
                            THEN
                                g_error := 'CALL rehab_epis_encounter.upd';
                            
                                BEGIN
                                    SELECT rp.id_rehab_presc, rp.dt_rehab_presc, rp.id_rehab_area_interv
                                      INTO l_id_rehab_presc, l_dt_rehab_presc, l_id_rehab_area_interv
                                      FROM rehab_presc rp
                                     WHERE rp.id_rehab_sch_need = l_tbl_rehab_epis_encounter(i) (2)
                                       AND rownum() = 1;
                                EXCEPTION
                                    WHEN no_data_found THEN
                                        l_id_rehab_presc := NULL;
                                END;
                            
                                IF l_id_rehab_presc IS NOT NULL
                                THEN
                                    ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                                       flg_status_in     => g_rehab_presc_finished);
                                
                                    l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                                    ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                            dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                            id_professional_hist_in => i_prof.id,
                                                            id_rehab_presc_in       => l_id_rehab_presc,
                                                            dt_rehab_presc_in       => l_dt_rehab_presc,
                                                            id_professional_in      => i_prof.id,
                                                            id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                            id_rehab_sch_need_in    => l_tbl_rehab_epis_encounter(i) (2),
                                                            id_exec_institution_in  => i_prof.institution,
                                                            flg_status_in           => g_rehab_presc_finished);
                                END IF;
                            END IF;
                        END IF;
                    END LOOP;
                
                WHEN g_rehab_epis_enc_status_f THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        IF i_id_rehab_presc IS NULL
                        THEN
                            --REHAB PLAN
                            l_id_rehab_epis_encounter_aux := get_plan_epis_encounter(i_prof              => i_prof,
                                                                                     i_id_episode_origin => i_id_epis_origin,
                                                                                     i_state             => i_to_state);
                        
                            l_tbl_sch_needs.extend(1);
                            l_tbl_sch_needs(1) := NULL;
                        
                            l_tbl_rehab_epis_encounter.extend(1);
                            l_id_rehab_epis_encounter_aux := get_plan_epis_encounter(i_prof              => i_prof,
                                                                                     i_id_episode_origin => i_id_epis_origin,
                                                                                     i_state             => i_from_state);
                            l_tbl_rehab_epis_encounter(1) := table_number(l_id_rehab_epis_encounter_aux,
                                                                          i_id_rehab_presc);
                        
                        ELSE
                            IF NOT get_same_type_requests(i_prof              => i_prof,
                                                          i_id_patient        => i_id_patient,
                                                          i_id_rehab_sch_need => i_id_rehab_presc,
                                                          o_sch_needs         => l_tbl_sch_needs)
                            THEN
                                l_tbl_sch_needs.extend(1);
                                l_tbl_sch_needs(1) := i_id_rehab_presc;
                            END IF;
                        END IF;
                    
                        IF i_id_rehab_presc IS NOT NULL
                           OR l_id_rehab_epis_encounter_aux IS NULL
                        THEN
                            FOR i IN l_tbl_sch_needs.first .. l_tbl_sch_needs.last
                            LOOP
                                BEGIN
                                    SELECT rsn.id_episode_origin
                                      INTO l_id_epis_origin
                                      FROM rehab_sch_need rsn
                                     WHERE rsn.id_rehab_sch_need = l_tbl_sch_needs(i);
                                EXCEPTION
                                    WHEN no_data_found THEN
                                        l_id_epis_origin := i_id_epis_origin;
                                END;
                            
                                l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                                ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                            id_episode_origin_in       => l_id_epis_origin,
                                                            id_episode_rehab_in        => NULL,
                                                            flg_status_in              => i_to_state,
                                                            flg_rehab_workflow_type_in => i_workflow_type,
                                                            dt_creation_in             => g_sysdate_tstz,
                                                            dt_last_update_in          => g_sysdate_tstz,
                                                            id_prof_creation_in        => i_prof.id,
                                                            id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                            rows_out                   => l_rows);
                            
                                g_error := 't_data_gov_mnt.process_insert';
                                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            
                                l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                                ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                           id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                           id_episode_origin_in       => l_id_epis_origin,
                                                           id_episode_rehab_in        => l_new_episode,
                                                           flg_status_in              => i_to_state,
                                                           flg_rehab_workflow_type_in => i_workflow_type,
                                                           dt_creation_in             => g_sysdate_tstz,
                                                           dt_last_update_in          => g_sysdate_tstz,
                                                           id_prof_creation_in        => i_prof.id,
                                                           id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                           rows_out                   => l_rows);
                            
                                g_error := 't_data_gov_mnt.process_insert';
                                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            END LOOP;
                        ELSE
                            --REHABPLAN WITH EXECUTED SESSIONS  
                            FOR i IN l_tbl_rehab_epis_encounter.first .. l_tbl_rehab_epis_encounter.last
                            LOOP
                                g_error := 'CALL rehab_epis_encounter.upd';
                                ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                            flg_status_in              => i_to_state,
                                                            dt_last_update_in          => g_sysdate_tstz,
                                                            rows_out                   => l_rows);
                            
                                g_error := 'CALL t_data_gov_mnt.process_update I';
                                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            
                                BEGIN
                                    SELECT rsn.id_episode_origin
                                      INTO l_id_epis_origin
                                      FROM rehab_sch_need rsn
                                     WHERE rsn.id_rehab_sch_need = l_tbl_rehab_epis_encounter(i) (2);
                                EXCEPTION
                                    WHEN no_data_found THEN
                                        l_id_epis_origin := i_id_epis_origin;
                                END;
                            
                                l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                                ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                           id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                           id_episode_origin_in       => l_id_epis_origin,
                                                           id_episode_rehab_in        => l_new_episode,
                                                           flg_status_in              => i_to_state,
                                                           flg_rehab_workflow_type_in => i_workflow_type,
                                                           dt_creation_in             => g_sysdate_tstz,
                                                           dt_last_update_in          => g_sysdate_tstz,
                                                           id_prof_creation_in        => i_prof.id,
                                                           rows_out                   => l_rows);
                            
                                g_error := 't_data_gov_mnt.process_insert';
                                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            END LOOP;
                        
                        END IF;
                    ELSE
                        IF i_id_rehab_presc IS NULL
                        THEN
                            --REHAB PLAN without i_id_rehab_presc
                            l_tbl_rehab_epis_encounter.extend(1);
                            l_id_rehab_epis_encounter_aux := get_plan_epis_encounter(i_prof              => i_prof,
                                                                                     i_id_episode_origin => i_id_epis_origin,
                                                                                     i_state             => i_from_state);
                            l_tbl_rehab_epis_encounter(1) := table_number(l_id_rehab_epis_encounter_aux,
                                                                          i_id_rehab_presc);
                        ELSE
                            IF NOT
                                get_same_type_epis_encounter(i_prof                    => i_prof,
                                                             i_id_patient              => i_id_patient,
                                                             i_id_rehab_epis_encounter => i_id_rehab_grid,
                                                             o_rehab_epis_encounters   => l_tbl_rehab_epis_encounter)
                            THEN
                                l_tbl_rehab_epis_encounter.extend(1);
                                l_tbl_rehab_epis_encounter(1) := table_number(i_id_rehab_grid, i_id_rehab_presc);
                            END IF;
                        END IF;
                    
                        FOR i IN l_tbl_rehab_epis_encounter.first .. l_tbl_rehab_epis_encounter.last
                        LOOP
                            g_error := 'CALL rehab_epis_encounter.upd';
                            ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                        flg_status_in              => i_to_state,
                                                        dt_last_update_in          => g_sysdate_tstz,
                                                        rows_out                   => l_rows);
                        
                            g_error := 'CALL t_data_gov_mnt.process_update I';
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            BEGIN
                                SELECT rsn.id_episode_origin
                                  INTO l_id_epis_origin
                                  FROM rehab_sch_need rsn
                                 WHERE rsn.id_rehab_sch_need = l_tbl_rehab_epis_encounter(i) (2);
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_id_epis_origin := i_id_epis_origin;
                            END;
                        
                            l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                            ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                       id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                       id_episode_origin_in       => l_id_epis_origin,
                                                       id_episode_rehab_in        => l_new_episode,
                                                       flg_status_in              => i_to_state,
                                                       flg_rehab_workflow_type_in => i_workflow_type,
                                                       dt_creation_in             => g_sysdate_tstz,
                                                       dt_last_update_in          => g_sysdate_tstz,
                                                       id_prof_creation_in        => i_prof.id,
                                                       rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        END LOOP;
                    END IF;
                ELSE
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        
        ELSIF i_workflow_type = g_workflow_type_s
        THEN
        
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_b THEN
                    BEGIN
                        SELECT 1
                          INTO l_exist
                          FROM epis_info ei
                         WHERE ei.id_schedule = i_id_schedule;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_exist := 0;
                    END;
                
                    BEGIN
                        SELECT rp.id_rehab_presc, rp.dt_rehab_presc, rp.id_rehab_area_interv
                          INTO l_id_rehab_presc, l_dt_rehab_presc, l_id_rehab_area_interv
                          FROM rehab_presc rp
                         WHERE rp.id_rehab_sch_need = i_id_rehab_presc
                           AND rownum() = 1;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_id_rehab_presc := NULL;
                    END;
                
                    IF l_exist = 0
                    THEN
                        --create episode:
                        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
                    
                        -- Telmo 31-01-2011
                        IF i_id_rehab_schedule IS NOT NULL
                        THEN
                            SELECT id_schedule
                              INTO l_id_schedule
                              FROM rehab_schedule r
                             WHERE r.id_rehab_schedule = i_id_rehab_schedule;
                        END IF;
                    
                        OPEN c_visit(i_id_epis_origin);
                        FETCH c_visit
                            INTO l_id_visit;
                        CLOSE c_visit;
                    
                        -- get the professional's default dep_clin_serv
                        g_error         := 'CALL get_prof_def_dcs';
                        l_dep_clin_serv := get_prof_def_dcs(i_prof => i_prof);
                    
                        IF l_dep_clin_serv IS NULL
                        THEN
                            -- if the default dep_clin_serv is not set, warn the user
                            l_error_message := pk_message.get_message(i_lang      => i_lang,
                                                                      i_prof      => i_prof,
                                                                      i_code_mess => 'CONSULT_REQUEST_M003');
                            RAISE l_common_exception;
                        END IF;
                    
                        IF NOT pk_visit.create_episode(i_lang                 => i_lang,
                                                       i_id_visit             => l_id_visit,
                                                       i_id_professional      => i_prof,
                                                       i_id_sched             => l_id_schedule,
                                                       i_id_episode           => NULL,
                                                       i_health_plan          => NULL,
                                                       i_epis_type            => l_epis_type,
                                                       i_dep_clin_serv        => l_dep_clin_serv,
                                                       i_sysdate              => NULL,
                                                       i_sysdate_tstz         => NULL,
                                                       i_flg_ehr              => pk_visit.g_flg_ehr_n,
                                                       i_flg_appointment_type => pk_visit.g_null_appointment_type,
                                                       i_transaction_id       => l_transaction_id,
                                                       o_episode              => l_new_episode,
                                                       o_error                => o_error)
                        THEN
                            l_error_message := o_error.err_action;
                            RAISE l_common_exception;
                        END IF;
                    
                        g_error := 'CALL ts_episode.upd';
                        ts_episode.upd(id_episode_in       => l_new_episode,
                                       id_prev_episode_in  => i_id_epis_origin,
                                       id_prev_episode_nin => FALSE,
                                       rows_out            => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPISODE',
                                                      i_rowids       => l_rows,
                                                      o_error        => o_error,
                                                      i_list_columns => table_varchar('ID_PREV_EPISODE'));
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => l_new_episode,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_rehab_sch_need_in       => i_id_rehab_presc,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_rehab_sch_need_in       => i_id_rehab_presc,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        IF l_id_rehab_presc IS NOT NULL
                        THEN
                            ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                               flg_status_in     => g_rehab_presc_ongoing);
                        
                            l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                            ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                    dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                    id_professional_hist_in => i_prof.id,
                                                    id_rehab_presc_in       => l_id_rehab_presc,
                                                    dt_rehab_presc_in       => l_dt_rehab_presc,
                                                    id_professional_in      => i_prof.id,
                                                    id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                    id_rehab_sch_need_in    => i_id_rehab_presc,
                                                    id_exec_institution_in  => i_prof.institution,
                                                    flg_status_in           => g_rehab_presc_ongoing);
                        END IF;
                    END IF;
                WHEN g_rehab_epis_enc_status_c THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    id_rehab_sch_need_in       => i_id_rehab_presc,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   id_rehab_sch_need_in       => i_id_rehab_presc,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_o THEN
                    g_error := 'CALL rehab_epis_encounter.upd';
                    ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                flg_status_in              => i_to_state,
                                                dt_last_update_in          => g_sysdate_tstz,
                                                rows_out                   => l_rows);
                
                    g_error := 'CALL t_data_gov_mnt.process_update I';
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    BEGIN
                        SELECT s.id_episode_rehab
                          INTO l_new_episode
                          FROM rehab_epis_encounter s
                         WHERE s.id_rehab_epis_encounter = i_id_rehab_grid;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_new_episode := NULL;
                    END;
                
                    IF l_new_episode IS NOT NULL
                    THEN
                        g_error := 'CALL ts_episode.upd';
                        ts_episode.upd(id_episode_in   => l_new_episode,
                                       flg_status_in   => g_epis_flg_status_inactive,
                                       dt_end_tstz_in  => g_sysdate_tstz,
                                       dt_end_tstz_nin => FALSE,
                                       rows_out        => l_rows);
                        g_error := 'CALL t_data_gov_mnt.process_update';
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPISODE',
                                                      i_rowids       => l_rows,
                                                      o_error        => o_error,
                                                      i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
                    END IF;
                
                    l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                    ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                               id_rehab_epis_encounter_in => i_id_rehab_grid,
                                               id_episode_origin_in       => i_id_epis_origin,
                                               id_episode_rehab_in        => l_new_episode,
                                               flg_status_in              => i_to_state,
                                               flg_rehab_workflow_type_in => i_workflow_type,
                                               dt_creation_in             => g_sysdate_tstz,
                                               dt_last_update_in          => g_sysdate_tstz,
                                               id_prof_creation_in        => i_prof.id,
                                               rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    --Inserts the event EPISODE_APPOINTMENT_END         
                    pk_ia_event_common.episode_appointment_end(i_id_institution => i_prof.institution,
                                                               i_id_episode     => i_id_epis_origin);
                
                    --Check if this is the last session of the rehab prescription
                    --If it is, sets the record in rehab_presc as finished
                    IF check_concluded_plan(i_id_rehab_presc)
                    THEN
                        g_error := 'CALL rehab_epis_encounter.upd';
                    
                        BEGIN
                            SELECT rp.id_rehab_presc, rp.dt_rehab_presc, rp.id_rehab_area_interv
                              INTO l_id_rehab_presc, l_dt_rehab_presc, l_id_rehab_area_interv
                              FROM rehab_presc rp
                             WHERE rp.id_rehab_sch_need = i_id_rehab_presc
                               AND rownum() = 1;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_id_rehab_presc := NULL;
                        END;
                    
                        IF l_id_rehab_presc IS NOT NULL
                        THEN
                            ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                               flg_status_in     => g_rehab_presc_finished);
                        
                            l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                            ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                    dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                    id_professional_hist_in => i_prof.id,
                                                    id_rehab_presc_in       => l_id_rehab_presc,
                                                    dt_rehab_presc_in       => l_dt_rehab_presc,
                                                    id_professional_in      => i_prof.id,
                                                    id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                    id_rehab_sch_need_in    => i_id_rehab_presc,
                                                    id_exec_institution_in  => i_prof.institution,
                                                    flg_status_in           => g_rehab_presc_finished);
                        END IF;
                    
                    END IF;
                
                WHEN g_rehab_epis_enc_status_e THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_s THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                    
                        IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                       i_id_episode => i_id_epis_origin,
                                                       i_prof       => i_prof,
                                                       o_error      => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        SELECT id_episode_rehab
                          INTO l_id_epis_encounter
                          FROM rehab_epis_encounter
                         WHERE id_rehab_epis_encounter = i_id_rehab_grid;
                    
                        IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                       i_id_episode => l_id_epis_encounter,
                                                       i_prof       => i_prof,
                                                       o_error      => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_f THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_rehab_sch_need_in       => i_id_rehab_presc,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_rehab_sch_need_in       => i_id_rehab_presc,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                ELSE
                
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        ELSIF i_workflow_type = g_workflow_type_a
        THEN
        
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_b THEN
                    IF i_id_rehab_schedule IS NOT NULL
                    THEN
                        BEGIN
                            SELECT 1
                              INTO l_exist
                              FROM epis_info ei
                             WHERE ei.id_schedule = (SELECT id_schedule
                                                       FROM rehab_schedule r
                                                      WHERE r.id_rehab_schedule = i_id_rehab_schedule)
                               AND ei.id_episode IS NOT NULL;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_exist := 0;
                        END;
                    ELSE
                        BEGIN
                            SELECT 1
                              INTO l_exist
                              FROM epis_info ei
                              JOIN rehab_epis_encounter ree
                                ON ei.id_episode = ree.id_episode_origin
                             WHERE ei.id_schedule = i_id_schedule
                               AND ree.flg_status = i_to_state
                               AND ei.id_episode IS NOT NULL;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_exist := 0;
                        END;
                    END IF;
                    IF l_exist = 0
                    THEN
                    
                        --create episode:
                        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
                    
                        -- Telmo 31-01-2011
                        IF i_id_rehab_schedule IS NOT NULL
                        THEN
                            SELECT id_schedule
                              INTO l_id_schedule
                              FROM rehab_schedule r
                             WHERE r.id_rehab_schedule = i_id_rehab_schedule;
                        END IF;
                    
                        OPEN c_visit(i_id_epis_origin);
                        FETCH c_visit
                            INTO l_id_visit;
                        CLOSE c_visit;
                    
                        -- get the professional's default dep_clin_serv
                        g_error         := 'CALL get_prof_def_dcs';
                        l_dep_clin_serv := get_prof_def_dcs(i_prof => i_prof);
                    
                        IF l_dep_clin_serv IS NULL
                        THEN
                            -- if the default dep_clin_serv is not set, warn the user
                            l_error_in.set_all(i_id_lang       => i_lang,
                                               i_sqlcode       => NULL,
                                               i_sqlerrm       => pk_message.get_message(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_code_mess => 'CONSULT_REQUEST_M003'),
                                               i_user_err      => g_error,
                                               i_owner         => g_package_owner,
                                               i_pck_name      => g_package_name,
                                               i_function_name => 'SET_REQUEST_ANSWER',
                                               i_action        => NULL,
                                               i_flg_action    => 'U',
                                               i_msg_title     => pk_message.get_message(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_code_mess => 'OPINION_M011'));
                            l_ret := pk_alert_exceptions.process_error(i_error_in => l_error_in, i_error_out => o_error);
                            RAISE g_exception;
                        END IF;
                    
                        g_error := 'CALL ts_episode.upd';
                    
                        ts_episode.upd(id_episode_in           => i_id_epis_origin,
                                       flg_ehr_in              => pk_visit.g_flg_ehr_n,
                                       dt_begin_tstz_in        => g_sysdate_tstz,
                                       flg_appointment_type_in => pk_visit.g_null_appointment_type,
                                       rows_out                => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPISODE',
                                                      i_rowids       => l_rows,
                                                      o_error        => o_error,
                                                      i_list_columns => table_varchar('ID_PREV_EPISODE'));
                    
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => i_id_epis_origin,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_rehab_sch_need_in       => i_id_rehab_presc,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => i_id_epis_origin,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_rehab_sch_need_in       => i_id_rehab_presc,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        g_error := 'CALL PK_SCHEDULE_API_UPSTREAM.REGISTER_SCHEDULE. i_id_schedule: ' || i_id_schedule ||
                                   ' i_id_patient: ' || i_id_patient;
                        pk_alertlog.log_debug(g_error);
                        IF NOT pk_schedule_api_upstream.register_schedule(i_lang           => i_lang,
                                                                          i_prof           => i_prof,
                                                                          i_id_schedule    => i_id_schedule,
                                                                          i_id_patient     => i_id_patient,
                                                                          i_transaction_id => l_transaction_id,
                                                                          o_error          => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        g_error := 'UPDATE SCHEDULE_OUTP';
                        IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                                   i_prof           => i_prof,
                                                                                   i_id_schedule    => i_id_schedule,
                                                                                   i_flg_state      => 'E',
                                                                                   i_id_patient     => i_id_patient,
                                                                                   i_transaction_id => l_transaction_id,
                                                                                   o_error          => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                    END IF;
                WHEN g_rehab_epis_enc_status_c THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'I',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_o THEN
                    g_error := 'CALL rehab_epis_encounter.upd';
                    ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                flg_status_in              => i_to_state,
                                                dt_last_update_in          => g_sysdate_tstz,
                                                rows_out                   => l_rows);
                
                    g_error := 'CALL t_data_gov_mnt.process_update I';
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    BEGIN
                        SELECT s.id_episode_rehab
                          INTO l_new_episode
                          FROM rehab_epis_encounter s
                         WHERE s.id_rehab_epis_encounter = i_id_rehab_grid;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_new_episode := NULL;
                    END;
                
                    IF l_new_episode IS NOT NULL
                    THEN
                        l_rows  := table_varchar();
                        g_error := 'CALL ts_episode.upd';
                        ts_episode.upd(id_episode_in   => l_new_episode,
                                       flg_status_in   => g_epis_flg_status_inactive,
                                       dt_end_tstz_in  => g_sysdate_tstz,
                                       dt_end_tstz_nin => FALSE,
                                       rows_out        => l_rows);
                        g_error := 'CALL t_data_gov_mnt.process_update';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'EPISODE',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                    l_rows                   := table_varchar();
                    l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                    ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                               id_rehab_epis_encounter_in => i_id_rehab_grid,
                                               id_episode_origin_in       => i_id_epis_origin,
                                               id_episode_rehab_in        => l_new_episode,
                                               flg_status_in              => i_to_state,
                                               flg_rehab_workflow_type_in => i_workflow_type,
                                               dt_creation_in             => g_sysdate_tstz,
                                               dt_last_update_in          => g_sysdate_tstz,
                                               id_prof_creation_in        => i_prof.id,
                                               rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    --Inserts the event EPISODE_APPOINTMENT_END         
                    pk_ia_event_common.episode_appointment_end(i_id_institution => i_prof.institution,
                                                               i_id_episode     => nvl(l_new_episode, i_id_epis_origin));
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'S',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_e THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'T',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_s THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                    
                        IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                       i_id_episode => i_id_epis_origin,
                                                       i_prof       => i_prof,
                                                       o_error      => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        SELECT id_episode_rehab
                          INTO l_id_epis_encounter
                          FROM rehab_epis_encounter
                         WHERE id_rehab_epis_encounter = i_id_rehab_grid;
                    
                        IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                       i_id_episode => l_id_epis_encounter,
                                                       i_prof       => i_prof,
                                                       o_error      => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'T',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_f THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'B',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                ELSE
                
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        ELSIF i_workflow_type = g_workflow_type_h
        THEN
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_f THEN
                
                    g_error := 'CALL TO pk_schedule_api_ui.set_patient_no_show';
                    IF NOT pk_schedule_api_ui.set_patient_no_show(i_lang             => i_lang,
                                                                  i_prof             => i_prof,
                                                                  i_id_schedule      => i_id_schedule,
                                                                  i_id_patient       => i_id_patient,
                                                                  i_id_cancel_reason => i_id_cancel_reason,
                                                                  i_notes            => i_cancel_notes,
                                                                  o_error            => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                ELSE
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        ELSE
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_b THEN
                
                    -- Telmo 31-01-2011
                    IF i_id_rehab_schedule IS NOT NULL
                    THEN
                        SELECT id_schedule
                          INTO l_id_schedule
                          FROM rehab_schedule r
                         WHERE r.id_rehab_schedule = i_id_rehab_schedule;
                    END IF;
                
                    --create episode:
                    g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                    l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
                
                    IF NOT pk_visit.create_visit(i_lang            => i_lang,
                                                 i_id_pat          => i_id_patient,
                                                 i_id_institution  => i_prof.institution,
                                                 i_id_sched        => l_id_schedule,
                                                 i_id_professional => i_prof,
                                                 i_id_episode      => NULL,
                                                 i_external_cause  => NULL,
                                                 i_health_plan     => NULL,
                                                 i_epis_type       => 15,
                                                 i_dep_clin_serv   => NULL,
                                                 i_origin          => NULL,
                                                 i_flg_ehr         => 'N',
                                                 i_transaction_id  => l_transaction_id,
                                                 o_episode         => l_new_episode,
                                                 o_error           => o_error)
                    
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                   i_id_episode => l_new_episode,
                                                   i_prof       => i_prof,
                                                   o_error      => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                    ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                id_episode_origin_in       => l_new_episode,
                                                id_episode_rehab_in        => l_new_episode,
                                                flg_status_in              => i_to_state,
                                                flg_rehab_workflow_type_in => i_workflow_type,
                                                dt_creation_in             => g_sysdate_tstz,
                                                dt_last_update_in          => g_sysdate_tstz,
                                                id_prof_creation_in        => i_prof.id,
                                                rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                
                    l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                    ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                               id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                               id_episode_origin_in       => l_new_episode,
                                               id_episode_rehab_in        => l_new_episode,
                                               flg_status_in              => i_to_state,
                                               flg_rehab_workflow_type_in => i_workflow_type,
                                               dt_creation_in             => g_sysdate_tstz,
                                               dt_last_update_in          => g_sysdate_tstz,
                                               id_prof_creation_in        => i_prof.id,
                                               rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                WHEN g_rehab_epis_enc_status_c THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_o THEN
                    g_error := 'CALL rehab_epis_encounter.upd';
                    ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                flg_status_in              => i_to_state,
                                                dt_last_update_in          => g_sysdate_tstz,
                                                rows_out                   => l_rows);
                
                    g_error := 'CALL t_data_gov_mnt.process_update I';
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                
                    BEGIN
                        SELECT s.id_episode_rehab
                          INTO l_new_episode
                          FROM rehab_epis_encounter s
                         WHERE s.id_rehab_epis_encounter = i_id_rehab_grid;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_new_episode := NULL;
                    END;
                
                    ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                               id_rehab_epis_encounter_in => i_id_rehab_grid,
                                               id_episode_origin_in       => i_id_epis_origin,
                                               id_episode_rehab_in        => l_new_episode,
                                               flg_status_in              => i_to_state,
                                               flg_rehab_workflow_type_in => i_workflow_type,
                                               dt_creation_in             => g_sysdate_tstz,
                                               dt_last_update_in          => g_sysdate_tstz,
                                               id_prof_creation_in        => i_prof.id,
                                               rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    --Inserts the event EPISODE_APPOINTMENT_END         
                    pk_ia_event_common.episode_appointment_end(i_id_institution => i_prof.institution,
                                                               i_id_episode     => nvl(l_new_episode, i_id_epis_origin));
                WHEN g_rehab_epis_enc_status_e THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_s THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_f THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                ELSE
                
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        END IF;
    
        IF i_transaction_id IS NULL
           AND l_transaction_id IS NOT NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
    
        o_id_episode := l_new_episode;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_common_exception THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   'SET_REQUEST_ANSWER',
                                   NULL,
                                   'U',
                                   pk_message.get_message(i_lang      => i_lang,
                                                          i_prof      => i_prof,
                                                          i_code_mess => 'OPINION_M011'));
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_alert_exceptions.reset_error_state();
            
                pk_utils.undo_changes; -- ROLLBACK
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_rehab_wf_change_cmf;
    --    end set_rehab_wf_change_nocommit

    FUNCTION get_epis_origin_by_sch_need
    (
        i_epis_origin IN NUMBER,
        i_sch_need    IN NUMBER
    ) RETURN NUMBER IS
        tbl_epis_origin table_number;
        l_return        NUMBER;
    BEGIN
    
        SELECT rsn.id_episode_origin
          BULK COLLECT
          INTO tbl_epis_origin
          FROM rehab_sch_need rsn
         WHERE rsn.id_rehab_sch_need = i_sch_need;
    
        IF tbl_epis_origin.count > 0
        THEN
            l_return := tbl_epis_origin(1);
        ELSE
            l_return := i_epis_origin;
        END IF;
    
        RETURN l_return;
    
    END get_epis_origin_by_sch_need;

    --****************************************
    FUNCTION set_rehab_wf_change_nocommit
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        --
        i_workflow_type  IN VARCHAR2,
        i_from_state     IN VARCHAR2,
        i_to_state       IN VARCHAR2,
        i_id_rehab_grid  IN NUMBER,
        i_id_rehab_presc IN rehab_sch_need.id_rehab_sch_need%TYPE,
        --create_visit
        i_id_epis_origin    IN episode.id_episode%TYPE,
        i_id_rehab_schedule IN rehab_schedule.id_rehab_schedule%TYPE,
        i_id_schedule       IN schedule.id_schedule%TYPE,
        --
        i_id_cancel_reason IN rehab_schedule.id_cancel_reason%TYPE,
        i_cancel_notes     IN rehab_schedule.notes%TYPE DEFAULT NULL,
        --
        i_transaction_id IN VARCHAR2,
        o_id_episode     OUT episode.id_episode%TYPE,
        o_error          OUT t_error_out
        
    ) RETURN BOOLEAN IS
        l_bool BOOLEAN;
        l_func_name CONSTANT VARCHAR2(30) := 'SET_REHAB_WORKFLOW_CHANGE';
        l_id_visit      visit.id_visit%TYPE;
        l_epis_type     epis_type.id_epis_type%TYPE := 15;
        l_dep_clin_serv dep_clin_serv.id_dep_clin_serv%TYPE := NULL;
        l_room          epis_type_room.id_room%TYPE;
    
        -- SCH 3.0 variable
        l_transaction_id VARCHAR2(4000);
    
        l_new_episode        episode.id_episode%TYPE;
        l_epis_type_rehab_ap epis_type.id_epis_type%TYPE := 25; --epis_type Rehab appointments
    
        CURSOR c_visit(i_id_episode episode.id_episode%TYPE) IS
            SELECT e.id_visit
              FROM episode e
             WHERE e.id_episode = i_id_episode;
    
        l_rows                        table_varchar := table_varchar();
        l_id_rehab_epis_encounter     rehab_epis_encounter.id_rehab_epis_encounter%TYPE;
        l_id_rehab_epis_encounter_aux rehab_epis_encounter.id_rehab_epis_encounter%TYPE; -- Used for rehab plans
        l_id_rehab_epis_enc_hist      rehab_epis_enc_hist.id_rehab_epis_enc_hist%TYPE;
        l_id_epis_encounter           rehab_epis_encounter.id_rehab_epis_encounter%TYPE;
        l_id_schedule                 rehab_schedule.id_schedule%TYPE;
        l_id_rehab_presc              rehab_presc.id_rehab_presc%TYPE; --Different meaning from i_id_rehab_presc
        l_id_rehab_presc_hist         rehab_presc_hist.id_rehab_presc_hist%TYPE;
        l_dt_rehab_presc              rehab_presc.dt_rehab_presc%TYPE;
        l_id_rehab_area_interv        rehab_presc.id_rehab_area_interv%TYPE;
    
        l_id_cs            clinical_service.id_clinical_service%TYPE;
        l_id_dep_clin_serv schedule.id_dcs_requested%TYPE;
        l_id_dcs_requested schedule.id_dcs_requested%TYPE;
    
        l_exist    NUMBER;
        l_error_in t_error_in := t_error_in();
        l_ret      BOOLEAN;
        l_common_exception EXCEPTION;
        l_error_message sys_message.desc_message%TYPE;
    
        --Variable to check for requests of the same type (ALERT-284707)
        l_tbl_sch_needs            table_number := table_number();
        l_id_epis_origin           episode.id_episode%TYPE;
        l_tbl_rehab_epis_encounter table_table_number := table_table_number();
    
        --**************************************************************
        FUNCTION check_concluded_plan(i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE) RETURN BOOLEAN IS
        
            l_count      NUMBER;
            l_n_sessions rehab_sch_need.sessions%TYPE;
            l_dt_begin   TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_bool       BOOLEAN;
        
        BEGIN
        
            l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
        
            SELECT COUNT(1)
              INTO l_count
              FROM rehab_epis_encounter ree
             WHERE ree.id_rehab_sch_need = i_id_rehab_sch_need
               AND (ree.flg_status IN (pk_rehab.g_rehab_epis_enc_status_o) OR
                   (ree.flg_status = pk_rehab.g_rehab_epis_enc_status_s AND
                   ree.dt_creation < pk_date_utils.add_days_to_tstz(l_dt_begin, -1)) OR
                   (ree.flg_status = pk_rehab.g_rehab_epis_enc_status_f AND
                   ree.flg_rehab_workflow_type = pk_rehab.g_workflow_type_s));
        
            SELECT rsn.sessions
              INTO l_n_sessions
              FROM rehab_sch_need rsn
             WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need;
        
            l_bool := l_n_sessions = l_count;
        
            RETURN l_bool;
        
        END check_concluded_plan;
    
        --********************************************
        FUNCTION get_same_type_requests
        (
            i_prof              IN profissional,
            i_id_patient        IN patient.id_patient%TYPE,
            i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
            o_sch_needs         OUT table_number
        ) RETURN BOOLEAN IS
            l_dt_begin TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_dt_end   TIMESTAMP(6) WITH LOCAL TIME ZONE;
        BEGIN
        
            l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
            l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
        
            SELECT DISTINCT rsn.id_rehab_sch_need
              BULK COLLECT
              INTO o_sch_needs
              FROM rehab_presc rp
              JOIN rehab_sch_need rsn
                ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
              JOIN episode e
                ON e.id_episode = rsn.id_episode_origin
              LEFT JOIN rehab_epis_encounter re
                ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND l_dt_end AND
                   re.id_rehab_sch_need = rsn.id_rehab_sch_need)
             WHERE e.id_patient = i_id_patient
               AND rsn.id_rehab_session_type IN
                   (SELECT rsn_i.id_rehab_session_type
                      FROM rehab_sch_need rsn_i
                     WHERE rsn_i.id_rehab_sch_need = i_id_rehab_sch_need)
               AND rsn.flg_status = g_rehab_sch_need_no_sched
               AND rp.flg_status NOT IN (g_rehab_presc_referral,
                                         g_rehab_presc_not_order_reas,
                                         pk_alert_constant.g_cancelled,
                                         g_rehab_presc_discontinued)
               AND (re.flg_status IS NULL OR
                   re.flg_status NOT IN (pk_rehab.g_rehab_epis_enc_status_o,
                                          pk_rehab.g_rehab_epis_enc_status_c,
                                          pk_rehab.g_rehab_epis_enc_status_f))
               AND e.flg_status = pk_alert_constant.g_active
               AND rp.id_institution = i_prof.institution
               AND (rsn.dt_begin IS NULL OR (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= 0 OR
                   (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= -1 AND
                   extract(DAY FROM(current_timestamp)) >= extract(DAY FROM(rsn.dt_begin)))))
               AND (rsn.sessions >
                   (SELECT COUNT(1)
                       FROM rehab_epis_encounter ree_c
                      WHERE ree_c.id_episode_origin = rsn.id_episode_origin
                        AND ree_c.id_rehab_sch_need = rsn.id_rehab_sch_need
                        AND (ree_c.flg_status IN (pk_rehab.g_rehab_epis_enc_status_o) OR
                            (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_s AND
                            ree_c.dt_creation < pk_date_utils.add_days_to_tstz(l_dt_begin, -1)) OR
                            (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_f AND
                            ree_c.flg_rehab_workflow_type = pk_rehab.g_workflow_type_s))));
        
            RETURN TRUE;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN FALSE;
        END get_same_type_requests;
    
        --************************************************
        FUNCTION get_same_type_epis_encounter
        (
            i_prof                    IN profissional,
            i_id_patient              IN patient.id_patient%TYPE,
            i_id_rehab_epis_encounter IN rehab_epis_encounter.id_rehab_epis_encounter%TYPE,
            o_rehab_epis_encounters   OUT table_table_number
        ) RETURN BOOLEAN IS
            l_dt_begin TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_dt_end   TIMESTAMP(6) WITH LOCAL TIME ZONE;
        BEGIN
        
            l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
            l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
        
            SELECT table_number(t.id_rehab_epis_encounter, t.id_rehab_sch_need)
              BULK COLLECT
              INTO o_rehab_epis_encounters
              FROM (SELECT DISTINCT re.id_rehab_epis_encounter, rsn.id_rehab_sch_need
                      FROM rehab_presc rp
                      JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                      JOIN episode e
                        ON e.id_episode = rsn.id_episode_origin
                      JOIN rehab_epis_encounter re
                        ON (re.id_episode_origin = e.id_episode
                           -- CMF
                           --AND re.dt_creation BETWEEN l_dt_begin AND l_dt_end 
                           AND re.id_rehab_sch_need = rsn.id_rehab_sch_need)
                     WHERE e.id_patient = i_id_patient
                       AND rsn.id_rehab_session_type IN
                           (SELECT rsn_i.id_rehab_session_type
                              FROM rehab_sch_need rsn_i
                             WHERE rsn_i.id_rehab_sch_need = id_rehab_sch_need)
                       AND rsn.flg_status = g_rehab_sch_need_no_sched
                       AND rp.flg_status NOT IN (g_rehab_presc_referral,
                                                 g_rehab_presc_not_order_reas,
                                                 pk_alert_constant.g_cancelled,
                                                 g_rehab_presc_discontinued)
                       AND (re.flg_status IS NULL OR
                           re.flg_status NOT IN (pk_rehab.g_rehab_epis_enc_status_o,
                                                  pk_rehab.g_rehab_epis_enc_status_c,
                                                  pk_rehab.g_rehab_epis_enc_status_f))
                       AND e.flg_status = pk_alert_constant.g_active
                       AND rp.id_institution = i_prof.institution
                       AND (rsn.dt_begin IS NULL OR
                           (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= 0 OR
                           (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= -1 AND
                           extract(DAY FROM(current_timestamp)) >= extract(DAY FROM(rsn.dt_begin)))))) t;
        
            RETURN TRUE;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN FALSE;
        END get_same_type_epis_encounter;
    
        --**********************************************************
        FUNCTION get_plan_epis_encounter
        (
            i_prof              IN profissional,
            i_id_episode_origin IN episode.id_episode%TYPE,
            i_state             IN rehab_epis_encounter.flg_status%TYPE
        ) RETURN rehab_epis_encounter.id_rehab_epis_encounter%TYPE IS
            l_dt_begin                TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_dt_end                  TIMESTAMP(6) WITH LOCAL TIME ZONE;
            l_id_rehab_epis_encounter rehab_epis_encounter.id_rehab_epis_encounter%TYPE;
        BEGIN
            l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
            l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
        
            SELECT ree.id_rehab_epis_encounter
              INTO l_id_rehab_epis_encounter
              FROM rehab_epis_encounter ree
             WHERE ree.id_episode_origin = i_id_episode_origin
               AND ree.flg_status = i_state
               AND (ree.dt_creation BETWEEN l_dt_begin AND l_dt_end)
               AND ree.id_rehab_sch_need IS NULL;
        
            RETURN l_id_rehab_epis_encounter;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN NULL;
        END get_plan_epis_encounter;
    
        --*********************************************************************
        FUNCTION do_workflow_w RETURN BOOLEAN IS
        BEGIN
        
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_s THEN
                
                    --Check if it is a rehabilitation plan (i_id_rehab_presc is sent as null)
                    IF i_id_rehab_presc IS NULL
                    THEN
                        l_tbl_sch_needs.extend(1);
                        l_tbl_sch_needs(1) := NULL;
                    ELSE
                        --Check if there are more rehab sessions of the same type for this patient for today
                        --because the patients grid agregates sessions of the same type for a given patient.
                        IF NOT get_same_type_requests(i_prof              => i_prof,
                                                      i_id_patient        => i_id_patient,
                                                      i_id_rehab_sch_need => i_id_rehab_presc,
                                                      o_sch_needs         => l_tbl_sch_needs)
                        THEN
                            l_tbl_sch_needs.extend(1);
                            l_tbl_sch_needs(1) := i_id_rehab_presc;
                        END IF;
                    END IF;
                
                    FOR i IN l_tbl_sch_needs.first .. l_tbl_sch_needs.last
                    LOOP
                    
                        l_exist          := 0;
                        l_id_rehab_presc := NULL;
                    
                        DECLARE
                            l_today rehab_epis_encounter.dt_creation%TYPE := current_timestamp;
                        BEGIN
                        
                            l_today := CAST(pk_date_utils.trunc_insttimezone(i_prof, current_timestamp) AS TIMESTAMP WITH
                                            LOCAL TIME ZONE);
                        
                            SELECT COUNT(*)
                              INTO l_exist
                              FROM rehab_epis_encounter ree
                             WHERE ree.dt_creation BETWEEN l_today AND
                                   (l_today + numtodsinterval(1, 'day') - numtodsinterval(1, 'second'))
                               AND ree.id_rehab_sch_need = l_tbl_sch_needs(i);
                        END;
                    
                        BEGIN
                            SELECT rp.id_rehab_presc, rp.dt_rehab_presc, rp.id_rehab_area_interv
                              INTO l_id_rehab_presc, l_dt_rehab_presc, l_id_rehab_area_interv
                              FROM rehab_presc rp
                             WHERE rp.id_rehab_sch_need = l_tbl_sch_needs(i)
                               AND rownum = 1;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_id_rehab_presc := NULL;
                        END;
                    
                        IF l_exist = 0
                        THEN
                            --create episode:
                            g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                            l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(NULL, i_prof);
                        
                            l_id_epis_origin := get_epis_origin_by_sch_need(i_epis_origin => i_id_epis_origin,
                                                                            i_sch_need    => l_tbl_sch_needs(i));
                        
                            OPEN c_visit(l_id_epis_origin);
                            FETCH c_visit
                                INTO l_id_visit;
                            CLOSE c_visit;
                        
                            -- get the professional's default dep_clin_serv
                            g_error         := 'CALL get_prof_def_dcs';
                            l_dep_clin_serv := get_prof_def_dcs(i_prof => i_prof);
                        
                            IF l_dep_clin_serv IS NULL
                            THEN
                                -- if the default dep_clin_serv is not set, warn the user                           
                                l_error_message := pk_message.get_message(i_lang      => i_lang,
                                                                          i_prof      => i_prof,
                                                                          i_code_mess => 'CONSULT_REQUEST_M003');
                                RAISE l_common_exception;
                            END IF;
                        
                            IF NOT pk_visit.create_episode(i_lang                 => i_lang,
                                                           i_id_visit             => l_id_visit,
                                                           i_id_professional      => i_prof,
                                                           i_id_sched             => NULL,
                                                           i_id_episode           => NULL,
                                                           i_health_plan          => NULL,
                                                           i_epis_type            => l_epis_type,
                                                           i_dep_clin_serv        => l_dep_clin_serv,
                                                           i_sysdate              => NULL,
                                                           i_sysdate_tstz         => NULL,
                                                           i_flg_ehr              => pk_visit.g_flg_ehr_n,
                                                           i_flg_appointment_type => pk_visit.g_null_appointment_type,
                                                           i_transaction_id       => l_transaction_id,
                                                           o_episode              => l_new_episode,
                                                           o_error                => o_error)
                            THEN
                                l_error_message := o_error.err_action;
                                RAISE l_common_exception;
                            END IF;
                        
                            --use the same room that in epis_origin
                            g_error := 'UPDATE EPIS_INFO ROOM';
                            IF i_id_rehab_schedule IS NULL
                               AND l_id_epis_origin IS NOT NULL
                            THEN
                                BEGIN
                                    SELECT id_room
                                      INTO l_room
                                      FROM epis_info ei
                                     WHERE ei.id_episode = l_id_epis_origin;
                                EXCEPTION
                                    WHEN no_data_found THEN
                                        l_room := NULL;
                                END;
                            
                                g_error := 'UPDATE EPIS_INFO ROOM';
                                ts_epis_info.upd(id_room_in  => l_room,
                                                 id_room_nin => FALSE,
                                                 where_in    => 'id_episode = ' || l_new_episode,
                                                 rows_out    => l_rows);
                            
                                g_error := 'UPDATE EPIS_INFO ROOM';
                                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'EPIS_INFO',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            
                            END IF;
                        
                            IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                           i_id_episode => l_new_episode,
                                                           i_prof       => i_prof,
                                                           o_error      => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            g_error := 'CALL ts_episode.upd';
                            ts_episode.upd(id_episode_in       => l_new_episode,
                                           id_prev_episode_in  => l_id_epis_origin,
                                           id_prev_episode_nin => FALSE,
                                           rows_out            => l_rows);
                        
                            g_error := 'CALL t_data_gov_mnt.process_update I';
                            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                          i_prof         => i_prof,
                                                          i_table_name   => 'EPISODE',
                                                          i_rowids       => l_rows,
                                                          o_error        => o_error,
                                                          i_list_columns => table_varchar('ID_PREV_EPISODE'));
                        
                            l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                            ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                        id_episode_origin_in       => l_id_epis_origin,
                                                        id_episode_rehab_in        => l_new_episode,
                                                        flg_status_in              => i_to_state,
                                                        flg_rehab_workflow_type_in => i_workflow_type,
                                                        dt_creation_in             => g_sysdate_tstz,
                                                        dt_last_update_in          => g_sysdate_tstz,
                                                        id_prof_creation_in        => i_prof.id,
                                                        id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                        rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                            ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                       id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                       id_episode_origin_in       => l_id_epis_origin,
                                                       id_episode_rehab_in        => l_new_episode,
                                                       flg_status_in              => i_to_state,
                                                       flg_rehab_workflow_type_in => i_workflow_type,
                                                       dt_creation_in             => g_sysdate_tstz,
                                                       dt_last_update_in          => g_sysdate_tstz,
                                                       id_prof_creation_in        => i_prof.id,
                                                       id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                       rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            IF l_id_rehab_presc IS NOT NULL
                            THEN
                                ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                                   flg_status_in     => g_rehab_presc_ongoing);
                            
                                l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                                ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                        dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                        id_professional_hist_in => i_prof.id,
                                                        id_rehab_presc_in       => l_id_rehab_presc,
                                                        dt_rehab_presc_in       => l_dt_rehab_presc,
                                                        id_professional_in      => i_prof.id,
                                                        id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                        id_rehab_sch_need_in    => l_tbl_sch_needs(i),
                                                        id_exec_institution_in  => i_prof.institution,
                                                        flg_status_in           => g_rehab_presc_ongoing);
                            END IF;
                        END IF;
                    END LOOP;
                
                WHEN g_rehab_epis_enc_status_c THEN
                
                    IF i_id_rehab_grid IS NULL
                    THEN
                        IF i_id_rehab_presc IS NULL
                        THEN
                            l_tbl_sch_needs.extend(1);
                            l_tbl_sch_needs(1) := NULL;
                        ELSE
                            IF NOT get_same_type_requests(i_prof              => i_prof,
                                                          i_id_patient        => i_id_patient,
                                                          i_id_rehab_sch_need => i_id_rehab_presc,
                                                          o_sch_needs         => l_tbl_sch_needs)
                            THEN
                                l_tbl_sch_needs.extend(1);
                                l_tbl_sch_needs(1) := i_id_rehab_presc;
                            END IF;
                        END IF;
                    
                        <<lup_thru_need_01>>
                        FOR i IN l_tbl_sch_needs.first .. l_tbl_sch_needs.last
                        LOOP
                        
                            l_id_epis_origin := get_epis_origin_by_sch_need(i_id_epis_origin, l_tbl_sch_needs(i));
                        
                            l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                            ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                        id_episode_origin_in       => l_id_epis_origin,
                                                        id_episode_rehab_in        => NULL,
                                                        flg_status_in              => i_to_state,
                                                        flg_rehab_workflow_type_in => i_workflow_type,
                                                        dt_creation_in             => g_sysdate_tstz,
                                                        dt_last_update_in          => g_sysdate_tstz,
                                                        id_prof_creation_in        => i_prof.id,
                                                        id_cancel_reason_in        => i_id_cancel_reason,
                                                        dt_cancel_in               => g_sysdate_tstz,
                                                        cancel_notes_in            => i_cancel_notes,
                                                        id_prof_cancel_in          => i_prof.id,
                                                        id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                        rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                            ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                       id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                       id_episode_origin_in       => l_id_epis_origin,
                                                       id_episode_rehab_in        => l_new_episode,
                                                       flg_status_in              => i_to_state,
                                                       flg_rehab_workflow_type_in => i_workflow_type,
                                                       dt_creation_in             => g_sysdate_tstz,
                                                       dt_last_update_in          => g_sysdate_tstz,
                                                       id_prof_creation_in        => i_prof.id,
                                                       id_cancel_reason_in        => i_id_cancel_reason,
                                                       dt_cancel_in               => g_sysdate_tstz,
                                                       cancel_notes_in            => i_cancel_notes,
                                                       id_prof_cancel_in          => i_prof.id,
                                                       id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                       rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        END LOOP lup_thru_need_01;
                    ELSE
                    
                        IF i_id_rehab_presc IS NULL
                        THEN
                            l_tbl_rehab_epis_encounter.extend(1);
                            l_tbl_rehab_epis_encounter(1) := table_number(i_id_rehab_grid, NULL);
                        ELSE
                            IF NOT
                                get_same_type_epis_encounter(i_prof                    => i_prof,
                                                             i_id_patient              => i_id_patient,
                                                             i_id_rehab_epis_encounter => i_id_rehab_grid,
                                                             o_rehab_epis_encounters   => l_tbl_rehab_epis_encounter)
                            THEN
                                l_tbl_rehab_epis_encounter.extend(1);
                                l_tbl_rehab_epis_encounter(1) := table_number(i_id_rehab_grid, i_id_rehab_presc);
                            END IF;
                        END IF;
                    
                        IF l_tbl_rehab_epis_encounter.count > 0
                        THEN
                        
                            <<lup_thru_encounter_02>>
                            FOR i IN l_tbl_rehab_epis_encounter.first .. l_tbl_rehab_epis_encounter.last
                            LOOP
                                g_error := 'CALL rehab_epis_encounter.upd';
                                ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                            flg_status_in              => i_to_state,
                                                            dt_last_update_in          => g_sysdate_tstz,
                                                            id_cancel_reason_in        => i_id_cancel_reason,
                                                            dt_cancel_in               => g_sysdate_tstz,
                                                            cancel_notes_in            => i_cancel_notes,
                                                            id_prof_cancel_in          => i_prof.id,
                                                            rows_out                   => l_rows);
                            
                                g_error := 'CALL t_data_gov_mnt.process_update I';
                                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            
                                l_id_epis_origin := get_epis_origin_by_sch_need(i_id_epis_origin,
                                                                                l_tbl_rehab_epis_encounter(i) (2));
                            
                                l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                                ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                           id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                           id_episode_origin_in       => l_id_epis_origin, -------
                                                           id_episode_rehab_in        => l_new_episode,
                                                           flg_status_in              => i_to_state,
                                                           flg_rehab_workflow_type_in => i_workflow_type,
                                                           dt_creation_in             => g_sysdate_tstz,
                                                           dt_last_update_in          => g_sysdate_tstz,
                                                           id_prof_creation_in        => i_prof.id,
                                                           id_cancel_reason_in        => i_id_cancel_reason,
                                                           dt_cancel_in               => g_sysdate_tstz,
                                                           cancel_notes_in            => i_cancel_notes,
                                                           id_prof_cancel_in          => i_prof.id,
                                                           rows_out                   => l_rows);
                            
                                g_error := 't_data_gov_mnt.process_insert';
                                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            
                            END LOOP lup_thru_encounter_02;
                        END IF;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_o THEN
                
                    IF i_id_rehab_presc IS NULL
                    THEN
                        --REHAB PLAN without i_id_rehab_presc
                        l_tbl_rehab_epis_encounter.extend(1);
                        l_id_rehab_epis_encounter_aux := get_plan_epis_encounter(i_prof              => i_prof,
                                                                                 i_id_episode_origin => i_id_epis_origin,
                                                                                 i_state             => i_from_state);
                        l_tbl_rehab_epis_encounter(1) := table_number(l_id_rehab_epis_encounter_aux, i_id_rehab_presc);
                    
                    ELSE
                        IF NOT get_same_type_epis_encounter(i_prof                    => i_prof,
                                                            i_id_patient              => i_id_patient,
                                                            i_id_rehab_epis_encounter => i_id_rehab_grid,
                                                            o_rehab_epis_encounters   => l_tbl_rehab_epis_encounter)
                        THEN
                            l_tbl_rehab_epis_encounter.extend(1);
                            l_tbl_rehab_epis_encounter(1) := table_number(i_id_rehab_grid, i_id_rehab_presc);
                        END IF;
                    END IF;
                
                    --FOR i IN l_tbl_rehab_epis_encounter.first .. l_tbl_rehab_epis_encounter.last
                    <<lup_thru_encounter_03>>
                    FOR i IN 1 .. l_tbl_rehab_epis_encounter.count
                    LOOP
                    
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                        BEGIN
                            SELECT s.id_episode_rehab
                              INTO l_new_episode
                              FROM rehab_epis_encounter s
                             WHERE s.id_rehab_epis_encounter = l_tbl_rehab_epis_encounter(i) (1);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_new_episode := NULL;
                        END;
                    
                        IF l_new_episode IS NOT NULL
                        THEN
                        
                            g_error := 'CALL ts_episode.upd';
                            ts_episode.upd(id_episode_in   => l_new_episode,
                                           flg_status_in   => g_epis_flg_status_inactive,
                                           dt_end_tstz_in  => g_sysdate_tstz,
                                           dt_end_tstz_nin => FALSE,
                                           rows_out        => l_rows);
                            g_error := 'CALL t_data_gov_mnt.process_update';
                            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                          i_prof         => i_prof,
                                                          i_table_name   => 'EPISODE',
                                                          i_rowids       => l_rows,
                                                          o_error        => o_error,
                                                          i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
                        END IF;
                    
                        l_id_epis_origin := get_epis_origin_by_sch_need(i_id_epis_origin,
                                                                        l_tbl_rehab_epis_encounter(i) (2));
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                   id_episode_origin_in       => l_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        --Inserts the event EPISODE_APPOINTMENT_END         
                        pk_ia_event_common.episode_appointment_end(i_id_institution => i_prof.institution,
                                                                   i_id_episode     => nvl(l_new_episode,
                                                                                           l_id_epis_origin));
                    
                        IF i_id_rehab_presc IS NOT NULL
                        THEN
                            --Check if this is the last session of the rehab prescription
                            --If it is, sets the record in rehab_presc as finished                        
                            IF check_concluded_plan(l_tbl_rehab_epis_encounter(i) (2))
                            THEN
                                g_error := 'CALL rehab_epis_encounter.upd';
                            
                                BEGIN
                                    SELECT rp.id_rehab_presc, rp.dt_rehab_presc, rp.id_rehab_area_interv
                                      INTO l_id_rehab_presc, l_dt_rehab_presc, l_id_rehab_area_interv
                                      FROM rehab_presc rp
                                     WHERE rp.id_rehab_sch_need = l_tbl_rehab_epis_encounter(i) (2)
                                       AND rownum() = 1;
                                EXCEPTION
                                    WHEN no_data_found THEN
                                        l_id_rehab_presc := NULL;
                                END;
                            
                                IF l_id_rehab_presc IS NOT NULL
                                THEN
                                    ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                                       flg_status_in     => g_rehab_presc_finished);
                                
                                    l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                                    ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                            dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                            id_professional_hist_in => i_prof.id,
                                                            id_rehab_presc_in       => l_id_rehab_presc,
                                                            dt_rehab_presc_in       => l_dt_rehab_presc,
                                                            id_professional_in      => i_prof.id,
                                                            id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                            id_rehab_sch_need_in    => l_tbl_rehab_epis_encounter(i) (2),
                                                            id_exec_institution_in  => i_prof.institution,
                                                            flg_status_in           => g_rehab_presc_finished);
                                END IF;
                            END IF;
                        END IF;
                    END LOOP lup_thru_encounter_03;
                
                WHEN g_rehab_epis_enc_status_f THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        IF i_id_rehab_presc IS NULL
                        THEN
                            --REHAB PLAN
                            l_id_rehab_epis_encounter_aux := get_plan_epis_encounter(i_prof              => i_prof,
                                                                                     i_id_episode_origin => i_id_epis_origin,
                                                                                     i_state             => i_to_state);
                        
                            l_tbl_sch_needs.extend(1);
                            l_tbl_sch_needs(1) := NULL;
                        
                            l_tbl_rehab_epis_encounter.extend(1);
                            l_id_rehab_epis_encounter_aux := get_plan_epis_encounter(i_prof              => i_prof,
                                                                                     i_id_episode_origin => i_id_epis_origin,
                                                                                     i_state             => i_from_state);
                            l_tbl_rehab_epis_encounter(1) := table_number(l_id_rehab_epis_encounter_aux,
                                                                          i_id_rehab_presc);
                        
                        ELSE
                            IF NOT get_same_type_requests(i_prof              => i_prof,
                                                          i_id_patient        => i_id_patient,
                                                          i_id_rehab_sch_need => i_id_rehab_presc,
                                                          o_sch_needs         => l_tbl_sch_needs)
                            THEN
                                l_tbl_sch_needs.extend(1);
                                l_tbl_sch_needs(1) := i_id_rehab_presc;
                            END IF;
                        END IF;
                    
                        IF i_id_rehab_presc IS NOT NULL
                           OR l_id_rehab_epis_encounter_aux IS NULL
                        THEN
                        
                            <<lup_thru_need_04>>
                            FOR i IN l_tbl_sch_needs.first .. l_tbl_sch_needs.last
                            LOOP
                            
                                l_id_epis_origin := get_epis_origin_by_sch_need(i_id_epis_origin, l_tbl_sch_needs(i));
                            
                                l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                                ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                            id_episode_origin_in       => l_id_epis_origin,
                                                            id_episode_rehab_in        => NULL,
                                                            flg_status_in              => i_to_state,
                                                            flg_rehab_workflow_type_in => i_workflow_type,
                                                            dt_creation_in             => g_sysdate_tstz,
                                                            dt_last_update_in          => g_sysdate_tstz,
                                                            id_prof_creation_in        => i_prof.id,
                                                            id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                            rows_out                   => l_rows);
                            
                                g_error := 't_data_gov_mnt.process_insert';
                                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            
                                l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                                ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                           id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                           id_episode_origin_in       => l_id_epis_origin,
                                                           id_episode_rehab_in        => l_new_episode,
                                                           flg_status_in              => i_to_state,
                                                           flg_rehab_workflow_type_in => i_workflow_type,
                                                           dt_creation_in             => g_sysdate_tstz,
                                                           dt_last_update_in          => g_sysdate_tstz,
                                                           id_prof_creation_in        => i_prof.id,
                                                           id_rehab_sch_need_in       => l_tbl_sch_needs(i),
                                                           rows_out                   => l_rows);
                            
                                g_error := 't_data_gov_mnt.process_insert';
                                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            END LOOP lup_thru_need_04;
                        ELSE
                            --REHABPLAN WITH EXECUTED SESSIONS  
                            <<lup_thru_need_05>>
                            FOR i IN l_tbl_rehab_epis_encounter.first .. l_tbl_rehab_epis_encounter.last
                            LOOP
                                g_error := 'CALL rehab_epis_encounter.upd';
                                ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                            flg_status_in              => i_to_state,
                                                            dt_last_update_in          => g_sysdate_tstz,
                                                            rows_out                   => l_rows);
                            
                                g_error := 'CALL t_data_gov_mnt.process_update I';
                                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            
                                l_id_epis_origin := get_epis_origin_by_sch_need(i_id_epis_origin,
                                                                                l_tbl_rehab_epis_encounter(i) (2));
                            
                                l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                                ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                           id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                           id_episode_origin_in       => l_id_epis_origin,
                                                           id_episode_rehab_in        => l_new_episode,
                                                           flg_status_in              => i_to_state,
                                                           flg_rehab_workflow_type_in => i_workflow_type,
                                                           dt_creation_in             => g_sysdate_tstz,
                                                           dt_last_update_in          => g_sysdate_tstz,
                                                           id_prof_creation_in        => i_prof.id,
                                                           rows_out                   => l_rows);
                            
                                g_error := 't_data_gov_mnt.process_insert';
                                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                              i_rowids     => l_rows,
                                                              o_error      => o_error);
                            END LOOP lup_thru_need_05;
                        
                        END IF;
                    ELSE
                        IF i_id_rehab_presc IS NULL
                        THEN
                            --REHAB PLAN without i_id_rehab_presc
                            l_tbl_rehab_epis_encounter.extend(1);
                            l_id_rehab_epis_encounter_aux := get_plan_epis_encounter(i_prof              => i_prof,
                                                                                     i_id_episode_origin => i_id_epis_origin,
                                                                                     i_state             => i_from_state);
                            l_tbl_rehab_epis_encounter(1) := table_number(l_id_rehab_epis_encounter_aux,
                                                                          i_id_rehab_presc);
                        ELSE
                            IF NOT
                                get_same_type_epis_encounter(i_prof                    => i_prof,
                                                             i_id_patient              => i_id_patient,
                                                             i_id_rehab_epis_encounter => i_id_rehab_grid,
                                                             o_rehab_epis_encounters   => l_tbl_rehab_epis_encounter)
                            THEN
                                l_tbl_rehab_epis_encounter.extend(1);
                                l_tbl_rehab_epis_encounter(1) := table_number(i_id_rehab_grid, i_id_rehab_presc);
                            END IF;
                        END IF;
                    
                        <<lup_thru_encounter_06>>
                        FOR i IN l_tbl_rehab_epis_encounter.first .. l_tbl_rehab_epis_encounter.last
                        LOOP
                            g_error := 'CALL rehab_epis_encounter.upd';
                            ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                        flg_status_in              => i_to_state,
                                                        dt_last_update_in          => g_sysdate_tstz,
                                                        rows_out                   => l_rows);
                        
                            g_error := 'CALL t_data_gov_mnt.process_update I';
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        
                            l_id_epis_origin := get_epis_origin_by_sch_need(i_id_epis_origin,
                                                                            l_tbl_rehab_epis_encounter(i) (2));
                        
                            l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                            ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                       id_rehab_epis_encounter_in => l_tbl_rehab_epis_encounter(i) (1),
                                                       id_episode_origin_in       => l_id_epis_origin,
                                                       id_episode_rehab_in        => l_new_episode,
                                                       flg_status_in              => i_to_state,
                                                       flg_rehab_workflow_type_in => i_workflow_type,
                                                       dt_creation_in             => g_sysdate_tstz,
                                                       dt_last_update_in          => g_sysdate_tstz,
                                                       id_prof_creation_in        => i_prof.id,
                                                       rows_out                   => l_rows);
                        
                            g_error := 't_data_gov_mnt.process_insert';
                            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                          i_rowids     => l_rows,
                                                          o_error      => o_error);
                        END LOOP lup_thru_encounter_06;
                    END IF;
                ELSE
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        
            RETURN TRUE;
        
        END do_workflow_w;
    
        --***********************************
        FUNCTION do_workflow_s RETURN BOOLEAN IS
            l_tmp NUMBER;
        BEGIN
        
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_b THEN
                
                    SELECT COUNT(*)
                      INTO l_exist
                      FROM epis_info ei
                     WHERE ei.id_schedule = i_id_schedule;
                
                    BEGIN
                        SELECT rp.id_rehab_presc, rp.dt_rehab_presc, rp.id_rehab_area_interv
                          INTO l_id_rehab_presc, l_dt_rehab_presc, l_id_rehab_area_interv
                          FROM rehab_presc rp
                         WHERE rp.id_rehab_sch_need = i_id_rehab_presc
                           AND rownum() = 1;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_id_rehab_presc := NULL;
                    END;
                
                    --create episode:
                    g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                    l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
                
                    -- Telmo 31-01-2011
                    IF i_id_rehab_schedule IS NOT NULL
                    THEN
                        SELECT id_schedule
                          INTO l_id_schedule
                          FROM rehab_schedule r
                         WHERE r.id_rehab_schedule = i_id_rehab_schedule;
                    END IF;
                
                    IF l_exist = 0
                    THEN
                        l_tmp := i_id_epis_origin;
                    ELSE
                    
                        SELECT id_episode
                          INTO l_new_episode
                          FROM epis_info ei
                         WHERE ei.id_schedule = i_id_schedule;
                    
                        l_tmp := l_new_episode;
                    
                    END IF;
                
                    OPEN c_visit(l_tmp);
                    FETCH c_visit
                        INTO l_id_visit;
                    CLOSE c_visit;
                
                    -- get the professional's default dep_clin_serv
                    g_error         := 'CALL get_prof_def_dcs';
                    l_dep_clin_serv := get_prof_def_dcs(i_prof => i_prof);
                
                    IF l_dep_clin_serv IS NULL
                    THEN
                        -- if the default dep_clin_serv is not set, warn the user
                        l_error_message := pk_message.get_message(i_lang      => i_lang,
                                                                  i_prof      => i_prof,
                                                                  i_code_mess => 'CONSULT_REQUEST_M003');
                        RAISE l_common_exception;
                    END IF;
                
                    IF NOT pk_visit.create_episode(i_lang                 => i_lang,
                                                   i_id_visit             => l_id_visit,
                                                   i_id_professional      => i_prof,
                                                   i_id_sched             => l_id_schedule,
                                                   i_id_episode           => l_new_episode,
                                                   i_health_plan          => NULL,
                                                   i_epis_type            => l_epis_type,
                                                   i_dep_clin_serv        => l_dep_clin_serv,
                                                   i_sysdate              => NULL,
                                                   i_sysdate_tstz         => NULL,
                                                   i_flg_ehr              => pk_visit.g_flg_ehr_n,
                                                   i_flg_appointment_type => pk_visit.g_null_appointment_type,
                                                   i_transaction_id       => l_transaction_id,
                                                   o_episode              => l_new_episode,
                                                   o_error                => o_error)
                    THEN
                        l_error_message := o_error.err_action;
                        RAISE l_common_exception;
                    END IF;
                
                    IF l_exist = 0
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => l_new_episode,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_rehab_sch_need_in       => i_id_rehab_presc,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_rehab_sch_need_in       => i_id_rehab_presc,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        IF l_id_rehab_presc IS NOT NULL
                        THEN
                            ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                               flg_status_in     => g_rehab_presc_ongoing);
                        
                            l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                            ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                    dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                    id_professional_hist_in => i_prof.id,
                                                    id_rehab_presc_in       => l_id_rehab_presc,
                                                    dt_rehab_presc_in       => l_dt_rehab_presc,
                                                    id_professional_in      => i_prof.id,
                                                    id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                    id_rehab_sch_need_in    => i_id_rehab_presc,
                                                    id_exec_institution_in  => i_prof.institution,
                                                    flg_status_in           => g_rehab_presc_ongoing);
                        END IF;
                    END IF;
                    g_error := 'CALL ts_episode.upd';
                    ts_episode.upd(id_episode_in      => l_new_episode,
                                   id_prev_episode_in => i_id_epis_origin,
                                   dt_begin_tstz_in   => g_sysdate_tstz,
                                   --   flg_ehr_in         => pk_visit.g_flg_ehr_n,
                                   
                                   id_prev_episode_nin => FALSE,
                                   rows_out            => l_rows);
                
                    g_error := 'CALL t_data_gov_mnt.process_update I';
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'EPISODE',
                                                  i_rowids       => l_rows,
                                                  o_error        => o_error,
                                                  i_list_columns => table_varchar('ID_PREV_EPISODE'));
                
                    --
                    IF l_exist > 0
                    THEN
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    IF l_id_rehab_presc IS NOT NULL
                    THEN
                        ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                           flg_status_in     => g_rehab_presc_ongoing);
                    
                        l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                        ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                id_professional_hist_in => i_prof.id,
                                                id_rehab_presc_in       => l_id_rehab_presc,
                                                dt_rehab_presc_in       => l_dt_rehab_presc,
                                                id_professional_in      => i_prof.id,
                                                id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                id_rehab_sch_need_in    => i_id_rehab_presc,
                                                id_exec_institution_in  => i_prof.institution,
                                                flg_status_in           => g_rehab_presc_ongoing);
                    END IF;
                
                WHEN g_rehab_epis_enc_status_c THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    id_rehab_sch_need_in       => i_id_rehab_presc,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   id_rehab_sch_need_in       => i_id_rehab_presc,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'I',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                WHEN g_rehab_epis_enc_status_o THEN
                    g_error := 'CALL rehab_epis_encounter.upd';
                    ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                flg_status_in              => i_to_state,
                                                dt_last_update_in          => g_sysdate_tstz,
                                                rows_out                   => l_rows);
                
                    g_error := 'CALL t_data_gov_mnt.process_update I';
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    BEGIN
                        SELECT s.id_episode_rehab
                          INTO l_new_episode
                          FROM rehab_epis_encounter s
                         WHERE s.id_rehab_epis_encounter = i_id_rehab_grid;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_new_episode := NULL;
                    END;
                
                    IF l_new_episode IS NOT NULL
                    THEN
                        l_rows  := table_varchar();
                        g_error := 'CALL ts_episode.upd';
                        ts_episode.upd(id_episode_in   => l_new_episode,
                                       flg_status_in   => g_epis_flg_status_inactive,
                                       dt_end_tstz_in  => g_sysdate_tstz,
                                       dt_end_tstz_nin => FALSE,
                                       rows_out        => l_rows);
                        g_error := 'CALL t_data_gov_mnt.process_update';
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPISODE',
                                                      i_rowids       => l_rows,
                                                      o_error        => o_error,
                                                      i_list_columns => table_varchar('FLG_STATUS', 'DT_END_TSTZ'));
                    END IF;
                    l_rows                   := table_varchar();
                    l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                    ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                               id_rehab_epis_encounter_in => i_id_rehab_grid,
                                               id_episode_origin_in       => i_id_epis_origin,
                                               id_episode_rehab_in        => l_new_episode,
                                               flg_status_in              => i_to_state,
                                               flg_rehab_workflow_type_in => i_workflow_type,
                                               dt_creation_in             => g_sysdate_tstz,
                                               dt_last_update_in          => g_sysdate_tstz,
                                               id_prof_creation_in        => i_prof.id,
                                               rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    --Inserts the event EPISODE_APPOINTMENT_END         
                    pk_ia_event_common.episode_appointment_end(i_id_institution => i_prof.institution,
                                                               i_id_episode     => i_id_epis_origin);
                
                    --Check if this is the last session of the rehab prescription
                    --If it is, sets the record in rehab_presc as finished
                    IF check_concluded_plan(i_id_rehab_presc)
                    THEN
                        g_error := 'CALL rehab_epis_encounter.upd';
                    
                        BEGIN
                            SELECT rp.id_rehab_presc, rp.dt_rehab_presc, rp.id_rehab_area_interv
                              INTO l_id_rehab_presc, l_dt_rehab_presc, l_id_rehab_area_interv
                              FROM rehab_presc rp
                             WHERE rp.id_rehab_sch_need = i_id_rehab_presc
                               AND rownum() = 1;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_id_rehab_presc := NULL;
                        END;
                    
                        IF l_id_rehab_presc IS NOT NULL
                        THEN
                            ts_rehab_presc.upd(id_rehab_presc_in => l_id_rehab_presc,
                                               flg_status_in     => g_rehab_presc_finished);
                        
                            l_id_rehab_presc_hist := ts_rehab_presc_hist.next_key;
                            ts_rehab_presc_hist.ins(id_rehab_presc_hist_in  => l_id_rehab_presc_hist,
                                                    dt_rehab_presc_hist_in  => g_sysdate_tstz,
                                                    id_professional_hist_in => i_prof.id,
                                                    id_rehab_presc_in       => l_id_rehab_presc,
                                                    dt_rehab_presc_in       => l_dt_rehab_presc,
                                                    id_professional_in      => i_prof.id,
                                                    id_rehab_area_interv_in => l_id_rehab_area_interv,
                                                    id_rehab_sch_need_in    => i_id_rehab_presc,
                                                    id_exec_institution_in  => i_prof.institution,
                                                    flg_status_in           => g_rehab_presc_finished);
                        END IF;
                    
                    END IF;
                
                WHEN g_rehab_epis_enc_status_e THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_s THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                    
                        IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                       i_id_episode => i_id_epis_origin,
                                                       i_prof       => i_prof,
                                                       o_error      => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        SELECT id_episode_rehab
                          INTO l_id_epis_encounter
                          FROM rehab_epis_encounter
                         WHERE id_rehab_epis_encounter = i_id_rehab_grid;
                    
                        IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                       i_id_episode => l_id_epis_encounter,
                                                       i_prof       => i_prof,
                                                       o_error      => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_f THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_rehab_sch_need_in       => i_id_rehab_presc,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_rehab_sch_need_in       => i_id_rehab_presc,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                ELSE
                
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        
            RETURN TRUE;
        
        END do_workflow_s;
    
        --******************************************
        FUNCTION do_workflow_a RETURN BOOLEAN IS
            my_exception EXCEPTION;
        BEGIN
        
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_b THEN
                    IF i_id_rehab_schedule IS NOT NULL
                    THEN
                    
                        SELECT COUNT(*)
                          INTO l_exist
                          FROM epis_info ei
                         WHERE ei.id_schedule = (SELECT id_schedule
                                                   FROM rehab_schedule r
                                                  WHERE r.id_rehab_schedule = i_id_rehab_schedule)
                           AND ei.id_episode IS NOT NULL;
                    
                    ELSE
                    
                        SELECT COUNT(*)
                          INTO l_exist
                          FROM epis_info ei
                          JOIN rehab_epis_encounter ree
                            ON ei.id_episode = ree.id_episode_origin
                         WHERE ei.id_schedule = i_id_schedule
                           AND ree.flg_status = i_to_state
                           AND ei.id_episode IS NOT NULL;
                    
                    END IF;
                
                    IF l_exist = 0
                    THEN
                    
                        --create episode:
                        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
                    
                        -- Telmo 31-01-2011
                        IF i_id_rehab_schedule IS NOT NULL
                        THEN
                            SELECT id_schedule
                              INTO l_id_schedule
                              FROM rehab_schedule r
                             WHERE r.id_rehab_schedule = i_id_rehab_schedule;
                        END IF;
                    
                        OPEN c_visit(i_id_epis_origin);
                        FETCH c_visit
                            INTO l_id_visit;
                        CLOSE c_visit;
                    
                        -- get the professional's default dep_clin_serv
                        g_error         := 'CALL get_prof_def_dcs';
                        l_dep_clin_serv := get_prof_def_dcs(i_prof => i_prof);
                    
                        IF l_dep_clin_serv IS NULL
                        THEN
                            -- if the default dep_clin_serv is not set, warn the user
                            l_error_in.set_all(i_id_lang       => i_lang,
                                               i_sqlcode       => 'CONSULT_REQUEST_M003',
                                               i_sqlerrm       => pk_message.get_message(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_code_mess => 'CONSULT_REQUEST_M003'),
                                               i_user_err      => g_error,
                                               i_owner         => g_package_owner,
                                               i_pck_name      => g_package_name,
                                               i_function_name => 'SET_REQUEST_ANSWER',
                                               i_action        => NULL,
                                               i_flg_action    => 'U',
                                               i_msg_title     => pk_message.get_message(i_lang      => i_lang,
                                                                                         i_prof      => i_prof,
                                                                                         i_code_mess => 'OPINION_M011'));
                            l_ret := pk_alert_exceptions.process_error(i_error_in => l_error_in, i_error_out => o_error);
                        
                            RAISE my_exception;
                        
                        END IF;
                    
                        g_error := 'CALL ts_episode.upd';
                    
                        ts_episode.upd(id_episode_in           => i_id_epis_origin,
                                       flg_ehr_in              => pk_visit.g_flg_ehr_n,
                                       dt_begin_tstz_in        => g_sysdate_tstz,
                                       flg_appointment_type_in => pk_visit.g_null_appointment_type,
                                       rows_out                => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPISODE',
                                                      i_rowids       => l_rows,
                                                      o_error        => o_error,
                                                      i_list_columns => table_varchar('ID_PREV_EPISODE'));
                    
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => i_id_epis_origin,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_rehab_sch_need_in       => i_id_rehab_presc,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => i_id_epis_origin,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_rehab_sch_need_in       => i_id_rehab_presc,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        g_error := 'CALL PK_SCHEDULE_API_UPSTREAM.REGISTER_SCHEDULE. i_id_schedule: ' || i_id_schedule ||
                                   ' i_id_patient: ' || i_id_patient;
                        pk_alertlog.log_debug(g_error);
                        IF NOT pk_schedule_api_upstream.register_schedule(i_lang           => i_lang,
                                                                          i_prof           => i_prof,
                                                                          i_id_schedule    => i_id_schedule,
                                                                          i_id_patient     => i_id_patient,
                                                                          i_transaction_id => l_transaction_id,
                                                                          o_error          => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        g_error := 'UPDATE SCHEDULE_OUTP';
                        IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                                   i_prof           => i_prof,
                                                                                   i_id_schedule    => i_id_schedule,
                                                                                   i_flg_state      => 'E',
                                                                                   i_id_patient     => i_id_patient,
                                                                                   i_transaction_id => l_transaction_id,
                                                                                   o_error          => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                    END IF;
                WHEN g_rehab_epis_enc_status_c THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'I',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_o THEN
                    g_error := 'CALL rehab_epis_encounter.upd';
                    ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                flg_status_in              => i_to_state,
                                                dt_last_update_in          => g_sysdate_tstz,
                                                rows_out                   => l_rows);
                
                    g_error := 'CALL t_data_gov_mnt.process_update I';
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    BEGIN
                        SELECT s.id_episode_rehab
                          INTO l_new_episode
                          FROM rehab_epis_encounter s
                         WHERE s.id_rehab_epis_encounter = i_id_rehab_grid;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_new_episode := NULL;
                    END;
                
                    IF l_new_episode IS NOT NULL
                    THEN
                        l_rows  := table_varchar();
                        g_error := 'CALL ts_episode.upd';
                        ts_episode.upd(id_episode_in   => l_new_episode,
                                       flg_status_in   => g_epis_flg_status_inactive,
                                       dt_end_tstz_in  => g_sysdate_tstz,
                                       dt_end_tstz_nin => FALSE,
                                       rows_out        => l_rows);
                        g_error := 'CALL t_data_gov_mnt.process_update';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'EPISODE',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                    l_rows                   := table_varchar();
                    l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                    ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                               id_rehab_epis_encounter_in => i_id_rehab_grid,
                                               id_episode_origin_in       => i_id_epis_origin,
                                               id_episode_rehab_in        => l_new_episode,
                                               flg_status_in              => i_to_state,
                                               flg_rehab_workflow_type_in => i_workflow_type,
                                               dt_creation_in             => g_sysdate_tstz,
                                               dt_last_update_in          => g_sysdate_tstz,
                                               id_prof_creation_in        => i_prof.id,
                                               rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    --Inserts the event EPISODE_APPOINTMENT_END         
                    pk_ia_event_common.episode_appointment_end(i_id_institution => i_prof.institution,
                                                               i_id_episode     => nvl(l_new_episode, i_id_epis_origin));
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'S',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_e THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'T',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_s THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                    
                        IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                       i_id_episode => i_id_epis_origin,
                                                       i_prof       => i_prof,
                                                       o_error      => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        SELECT id_episode_rehab
                          INTO l_id_epis_encounter
                          FROM rehab_epis_encounter
                         WHERE id_rehab_epis_encounter = i_id_rehab_grid;
                    
                        IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                       i_id_episode => l_id_epis_encounter,
                                                       i_prof       => i_prof,
                                                       o_error      => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'T',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                WHEN g_rehab_epis_enc_status_f THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                
                    g_error := 'UPDATE SCHEDULE_OUTP';
                    IF NOT pk_schedule_api_upstream.set_schedule_consult_state(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_schedule    => i_id_schedule,
                                                                               i_flg_state      => 'B',
                                                                               i_id_patient     => i_id_patient,
                                                                               i_transaction_id => l_transaction_id,
                                                                               o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                ELSE
                
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        
            RETURN TRUE;
        
        EXCEPTION
            WHEN my_exception THEN
                pk_utils.undo_changes; -- ROLLBACK
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                RETURN FALSE;
        END do_workflow_a;
    
        ---*********************************
        FUNCTION do_workflow_h RETURN BOOLEAN IS
        BEGIN
        
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_f THEN
                
                    g_error := 'CALL TO pk_schedule_api_ui.set_patient_no_show';
                    IF NOT pk_schedule_api_ui.set_patient_no_show(i_lang             => i_lang,
                                                                  i_prof             => i_prof,
                                                                  i_id_schedule      => i_id_schedule,
                                                                  i_id_patient       => i_id_patient,
                                                                  i_id_cancel_reason => i_id_cancel_reason,
                                                                  i_notes            => i_cancel_notes,
                                                                  o_error            => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                ELSE
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        
            RETURN TRUE;
        
        END do_workflow_h;
    
        ---************************************************
        FUNCTION do_workflow_else RETURN BOOLEAN IS
        BEGIN
        
            CASE i_to_state
                WHEN g_rehab_epis_enc_status_b THEN
                
                    -- Telmo 31-01-2011
                    IF i_id_rehab_schedule IS NOT NULL
                    THEN
                        SELECT id_schedule
                          INTO l_id_schedule
                          FROM rehab_schedule r
                         WHERE r.id_rehab_schedule = i_id_rehab_schedule;
                    END IF;
                
                    --create episode:
                    g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                    l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
                
                    IF NOT pk_visit.create_visit(i_lang            => i_lang,
                                                 i_id_pat          => i_id_patient,
                                                 i_id_institution  => i_prof.institution,
                                                 i_id_sched        => l_id_schedule,
                                                 i_id_professional => i_prof,
                                                 i_id_episode      => NULL,
                                                 i_external_cause  => NULL,
                                                 i_health_plan     => NULL,
                                                 i_epis_type       => 15,
                                                 i_dep_clin_serv   => NULL,
                                                 i_origin          => NULL,
                                                 i_flg_ehr         => 'N',
                                                 i_transaction_id  => l_transaction_id,
                                                 o_episode         => l_new_episode,
                                                 o_error           => o_error)
                    
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    IF NOT pk_visit.set_visit_init(i_lang       => i_lang,
                                                   i_id_episode => l_new_episode,
                                                   i_prof       => i_prof,
                                                   o_error      => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                    ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                id_episode_origin_in       => l_new_episode,
                                                id_episode_rehab_in        => l_new_episode,
                                                flg_status_in              => i_to_state,
                                                flg_rehab_workflow_type_in => i_workflow_type,
                                                dt_creation_in             => g_sysdate_tstz,
                                                dt_last_update_in          => g_sysdate_tstz,
                                                id_prof_creation_in        => i_prof.id,
                                                rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                
                    l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                    ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                               id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                               id_episode_origin_in       => l_new_episode,
                                               id_episode_rehab_in        => l_new_episode,
                                               flg_status_in              => i_to_state,
                                               flg_rehab_workflow_type_in => i_workflow_type,
                                               dt_creation_in             => g_sysdate_tstz,
                                               dt_last_update_in          => g_sysdate_tstz,
                                               id_prof_creation_in        => i_prof.id,
                                               rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                WHEN g_rehab_epis_enc_status_c THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_cancel_reason_in        => i_id_cancel_reason,
                                                    dt_cancel_in               => g_sysdate_tstz,
                                                    cancel_notes_in            => i_cancel_notes,
                                                    id_prof_cancel_in          => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   id_cancel_reason_in        => i_id_cancel_reason,
                                                   dt_cancel_in               => g_sysdate_tstz,
                                                   cancel_notes_in            => i_cancel_notes,
                                                   id_prof_cancel_in          => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_o THEN
                    g_error := 'CALL rehab_epis_encounter.upd';
                    ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                flg_status_in              => i_to_state,
                                                dt_last_update_in          => g_sysdate_tstz,
                                                rows_out                   => l_rows);
                
                    g_error := 'CALL t_data_gov_mnt.process_update I';
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                
                    BEGIN
                        SELECT s.id_episode_rehab
                          INTO l_new_episode
                          FROM rehab_epis_encounter s
                         WHERE s.id_rehab_epis_encounter = i_id_rehab_grid;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_new_episode := NULL;
                    END;
                
                    ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                               id_rehab_epis_encounter_in => i_id_rehab_grid,
                                               id_episode_origin_in       => i_id_epis_origin,
                                               id_episode_rehab_in        => l_new_episode,
                                               flg_status_in              => i_to_state,
                                               flg_rehab_workflow_type_in => i_workflow_type,
                                               dt_creation_in             => g_sysdate_tstz,
                                               dt_last_update_in          => g_sysdate_tstz,
                                               id_prof_creation_in        => i_prof.id,
                                               rows_out                   => l_rows);
                
                    g_error := 't_data_gov_mnt.process_insert';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                    --Inserts the event EPISODE_APPOINTMENT_END         
                    pk_ia_event_common.episode_appointment_end(i_id_institution => i_prof.institution,
                                                               i_id_episode     => nvl(l_new_episode, i_id_epis_origin));
                WHEN g_rehab_epis_enc_status_e THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_s THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                WHEN g_rehab_epis_enc_status_f THEN
                    IF i_id_rehab_grid IS NULL
                    THEN
                        l_id_rehab_epis_encounter := ts_rehab_epis_encounter.next_key;
                        ts_rehab_epis_encounter.ins(id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                    id_episode_origin_in       => i_id_epis_origin,
                                                    id_episode_rehab_in        => NULL,
                                                    flg_status_in              => i_to_state,
                                                    flg_rehab_workflow_type_in => i_workflow_type,
                                                    dt_creation_in             => g_sysdate_tstz,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    id_prof_creation_in        => i_prof.id,
                                                    rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => l_id_rehab_epis_encounter,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'CALL rehab_epis_encounter.upd';
                        ts_rehab_epis_encounter.upd(id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                    flg_status_in              => i_to_state,
                                                    dt_last_update_in          => g_sysdate_tstz,
                                                    rows_out                   => l_rows);
                    
                        g_error := 'CALL t_data_gov_mnt.process_update I';
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENCOUNTER',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    
                        l_id_rehab_epis_enc_hist := ts_rehab_epis_enc_hist.next_key;
                        ts_rehab_epis_enc_hist.ins(id_rehab_epis_enc_hist_in  => l_id_rehab_epis_enc_hist,
                                                   id_rehab_epis_encounter_in => i_id_rehab_grid,
                                                   id_episode_origin_in       => i_id_epis_origin,
                                                   id_episode_rehab_in        => l_new_episode,
                                                   flg_status_in              => i_to_state,
                                                   flg_rehab_workflow_type_in => i_workflow_type,
                                                   dt_creation_in             => g_sysdate_tstz,
                                                   dt_last_update_in          => g_sysdate_tstz,
                                                   id_prof_creation_in        => i_prof.id,
                                                   rows_out                   => l_rows);
                    
                        g_error := 't_data_gov_mnt.process_insert';
                        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'REHAB_EPIS_ENC_HIST',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                ELSE
                
                    g_error := 'Invalid state transition';
                    pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
                    RAISE g_exception;
            END CASE;
        
            RETURN TRUE;
        
        END do_workflow_else;
    
    BEGIN
        g_error := 'SET_REHAB_WORKFLOW_CHANGE: i_id_patient = ' || i_id_patient;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        g_sysdate_tstz := current_timestamp;
    
        l_bool := TRUE;
    
        IF i_workflow_type = g_workflow_type_w
        THEN
            l_bool := do_workflow_w();
        
        ELSIF i_workflow_type = g_workflow_type_s
        THEN
        
            l_bool := do_workflow_s();
        
        ELSIF i_workflow_type = g_workflow_type_a
        THEN
            l_bool := do_workflow_a();
        
        ELSIF i_workflow_type = g_workflow_type_h
        THEN
        
            l_bool := do_workflow_h();
        
        ELSE
        
            l_bool := do_workflow_else();
        
        END IF;
    
        IF l_bool
        THEN
            IF i_transaction_id IS NULL
               AND l_transaction_id IS NOT NULL
            THEN
                pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
            END IF;
        ELSE
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
        END IF;
    
        o_id_episode := l_new_episode;
    
        RETURN l_bool;
    
    EXCEPTION
        WHEN l_common_exception THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            
            BEGIN
                l_error_in.set_all(i_lang,
                                   NULL,
                                   l_error_message,
                                   g_error,
                                   g_package_owner,
                                   g_package_name,
                                   'SET_REQUEST_ANSWER',
                                   NULL,
                                   'U',
                                   pk_message.get_message(i_lang      => i_lang,
                                                          i_prof      => i_prof,
                                                          i_code_mess => 'OPINION_M011'));
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
                pk_alert_exceptions.reset_error_state();
            
                pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
                pk_utils.undo_changes; -- ROLLBACK
                RETURN FALSE;
            END;
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
        
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_rehab_wf_change_nocommit;

    /**************************************************************************
    * Lists rehabilitation qualification by icf                               *
    *                                                                         *
    * @param i_lang                          language id                      *
    * @param i_prof                          professional, software and       *
    *                                        institution ids                  *
    * @param i_id_icf                        ICF identifier (can be null)     *
    * @param i_id_icf_qualification_scale    ICF qualification scale id       *
    * @param i_flg_level                     ICF Qualifier flg level          *
    *                                                                         *
    * @param o_error                  Error message                           *
    * @param o_qualif                 Output cursor                           *
    *                                                                         *
    * @return                         Returns boolean                         *
    *                                                                         *
    * @author                         Gustavo Serrano                         *
    * @version                        1.0                                     *
    * @since                          2010/08/03                              *
    **************************************************************************/
    FUNCTION get_rehab_icf_list
    (
        i_lang                       IN language.id_language%TYPE,
        i_prof                       IN profissional,
        i_id_icf                     IN icf_qualification_rel.id_icf%TYPE,
        i_id_icf_qualification_scale IN icf_qualification_rel.id_icf_qualification_scale%TYPE,
        i_flg_level                  IN icf_qualification_rel.flg_level%TYPE,
        o_qualif                     OUT pk_types.cursor_type,
        o_error                      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_ICF_LIST';
    
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_error := 'Fetch o_qualif';
        OPEN o_qualif FOR
            SELECT DISTINCT pk_translation.get_translation(i_lang, iq.code_icf_qualification) desc_qualif,
                            iqsr.flg_code || iqsr.value coding,
                            iq.id_icf_qualification id_qualif,
                            iqs.id_icf_qualification_scale,
                            iqsr.rank
              FROM icf_qualification_rel   iqr,
                   icf_qualification_scale iqs,
                   icf_qualification       iq,
                   icf_qualif_scale_rel    iqsr
             WHERE iqr.id_icf =
                   decode(i_id_icf, NULL, iqr.id_icf, pk_interv_mfr.get_top_id_icf(i_lang, i_prof, i_id_icf))
               AND iqr.id_icf_qualification_scale = i_id_icf_qualification_scale
               AND iqsr.flg_available = pk_alert_constant.g_yes
               AND iqsr.id_icf_qualification = iq.id_icf_qualification
               AND iqsr.id_icf_qualification_scale = iqs.id_icf_qualification_scale
               AND iqr.id_icf_qualification_scale = iqs.id_icf_qualification_scale
               AND iqr.flg_level = nvl(i_flg_level, iqr.flg_level)
             ORDER BY iqsr.rank ASC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            pk_types.open_cursor_if_closed(o_qualif);
            RETURN FALSE;
    END get_rehab_icf_list;

    /**********************************************************************************************
    * 
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_schedule_need schedule need
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION update_rsn_flg_status
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_id_rehab_schedule_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'UPDATE_RSN_FLG_STATUS';
        l_count  NUMBER;
        l_rowids table_varchar;
    
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_error := 'count records id_rehab_sch_need=' || i_id_rehab_schedule_need;
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_schedule rs
         WHERE rs.id_rehab_sch_need = i_id_rehab_schedule_need;
    
        g_error := 'before if l_count=' || l_count;
        IF l_count > 0
        THEN
        
            g_error := 'update rehab_sch_need';
            ts_rehab_sch_need.upd(id_rehab_sch_need_in => i_id_rehab_schedule_need,
                                  flg_status_in        => g_rehab_sch_need_scheduled,
                                  rows_out             => l_rowids);
        
            g_error := 't_data_gov_mnt.process_update';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_SCH_NEED',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END update_rsn_flg_status;

    FUNCTION get_prev_status_rph_int
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_rehab_presc_hist IN rehab_presc_hist.id_rehab_presc_hist%TYPE
    ) RETURN VARCHAR2 IS
        l_flg_status rehab_presc_hist.flg_status%TYPE;
    BEGIN
    
        SELECT rp.flg_status
          INTO l_flg_status
          FROM (SELECT t.flg_status, rownum num_row
                  FROM (SELECT rph.flg_status, rph.id_rehab_presc_hist
                          FROM rehab_presc_hist rph
                         WHERE rph.id_rehab_presc =
                               (SELECT rph.id_rehab_presc
                                  FROM rehab_presc_hist rph
                                 WHERE rph.id_rehab_presc_hist = i_id_rehab_presc_hist)
                           AND rph.id_rehab_presc_hist <= i_id_rehab_presc_hist
                         ORDER BY rph.id_rehab_presc_hist DESC) t) rp
         WHERE rp.num_row = 2;
    
        RETURN l_flg_status;
    END get_prev_status_rph_int;

    /**********************************************************************************************
    * Performs a search over active patients of Physical Medicine and Rehabilitation
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Professional's details
    * @param i_id_crit                Table with the criteria IDs
    * @param i_crit_cond              Criteria input
    * @param i_flg_state              Flag for Active (Y) or Inactive (N) patients
    * @param o_flg_show               Is there a message to be shown?
    * @param o_msg                    Message
    * @param o_msg_title              Message title
    * @param o_button                 Button to show with message
    * @param o_pat                    Patients list
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_patients_mfr
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_id_crit   IN table_number,
        i_crit_cond IN table_varchar,
        i_flg_state IN VARCHAR2,
        o_flg_show  OUT VARCHAR2,
        o_msg       OUT VARCHAR2,
        o_msg_title OUT VARCHAR2,
        o_button    OUT VARCHAR2,
        o_pat       OUT pk_types.cursor_type,
        o_error     OUT t_error_out
        
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PATIENTS_MFR';
        l_sql_header_1       VARCHAR2(10000);
        l_sql_body_1         VARCHAR2(10000);
        l_sql_header_2       VARCHAR2(10000);
        l_sql_body_2         VARCHAR2(10000);
        l_sql_header_3       VARCHAR2(10000);
        l_sql_body_3         VARCHAR2(10000);
        l_sql_header_4       VARCHAR2(10000);
        l_sql_body_4         VARCHAR2(10000);
        l_sql_header_5       VARCHAR2(10000);
        l_sql_body_5         VARCHAR2(10000);
        l_sql_header_6       VARCHAR2(10000);
        l_sql_body_6         VARCHAR2(10000);
        l_where              VARCHAR2(4000);
        l_where_cond         VARCHAR2(4000);
        l_count              PLS_INTEGER;
        l_limit              sys_config.value%TYPE;
        l_flg_sch_type_cr    schedule.flg_sch_type%TYPE := 'CR'; --Rehab appointments
        l_epis_type_rehab_ap epis_type.id_epis_type%TYPE := 25; --epis_type Rehab appointments
        l_show_med_disch     sys_config.value%TYPE;
        l_profile_template   NUMBER;
        l_et_access          table_number := table_number();
        --
        l_session_with_schedule    sys_message.desc_message%TYPE;
        l_session_without_schedule sys_message.desc_message%TYPE;
        l_appointment              sys_message.desc_message%TYPE;
        l_follow_ups               sys_message.desc_message%TYPE;
        --
        l_sched_status_cache VARCHAR2(1 CHAR) := 'V';
        l_sched_adm_disch    schedule_outp.flg_state%TYPE := 'M';
        l_flg_status_c       VARCHAR2(1 CHAR) := 'C';
        l_sched_med_disch    schedule_outp.flg_state%TYPE := 'D';
    
        l_flg_state VARCHAR2(1 CHAR);
    
        l_from VARCHAR2(32767);
        l_hint VARCHAR2(32767);
    
        l_dt_begin TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end   TIMESTAMP(6) WITH LOCAL TIME ZONE;
    
        l_follow_ups_mode    VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_search_assign_prof VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_assigned_prof      NUMBER := -1;
    
        k_crit_follow_ups_active   CONSTANT NUMBER := 254;
        k_crit_follow_ups_inactive CONSTANT NUMBER := 258;
        k_crit_assigned_therapist  CONSTANT NUMBER := 50;
    
        k_follow_up_mode CONSTANT VARCHAR2(1 CHAR) := 'F';
    
    BEGIN
        g_error        := 'begin';
        g_sysdate_tstz := current_timestamp;
        g_sysdate_char := pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof);
        l_dt_begin     := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
        l_dt_end       := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
        l_limit        := pk_sysconfig.get_config('NUM_RECORD_SEARCH', i_prof);
        o_flg_show     := 'N';
        l_where        := NULL;
    
        l_session_with_schedule    := pk_message.get_message(i_lang, i_prof, 'REHAB_T146');
        l_session_without_schedule := pk_message.get_message(i_lang, i_prof, 'REHAB_T147');
        l_appointment              := pk_message.get_message(i_lang, i_prof, 'REHAB_T148');
    
        pk_context_api.set_parameter(p_name => 'i_prof_id', p_value => i_prof.id);
        pk_context_api.set_parameter(p_name => 'i_prof_institution', p_value => i_prof.institution);
        pk_context_api.set_parameter(p_name => 'i_prof_software', p_value => i_prof.software);
        pk_context_api.set_parameter(p_name => 'SEARCH_P195', p_value => i_prof.id);
    
        l_show_med_disch := nvl(pk_sysconfig.get_config('SHOW_MEDICAL_DISCHARGED_GRID', i_prof),
                                pk_alert_constant.g_yes);
        pk_context_api.set_parameter(p_name  => 'ID_EXTERNAL_SYS',
                                     p_value => pk_sysconfig.get_config(i_code_cf => 'ID_EXTERNAL_SYS', i_prof => i_prof));
        pk_context_api.set_parameter(p_name  => 'EXTERNAL_SYSTEM_EXIST',
                                     p_value => pk_sysconfig.get_config(i_code_cf => 'EXTERNAL_SYSTEM_EXIST',
                                                                        i_prof    => i_prof));
    
        g_error := 'GET CRITERIA';
    
        IF i_flg_state = pk_alert_constant.g_yes
        THEN
            l_flg_state := pk_alert_constant.g_active;
        ELSE
            l_flg_state := pk_alert_constant.g_inactive;
        END IF;
    
        FOR i IN 1 .. i_id_crit.count
        LOOP
            l_where_cond := NULL;
            IF i_id_crit(i) IS NOT NULL
               AND i_crit_cond(i) != '-1'
            THEN
                IF NOT pk_search.get_criteria_condition(i_lang,
                                                        i_prof,
                                                        i_id_crit(i),
                                                        REPLACE(i_crit_cond(i), '''', '%'),
                                                        l_where_cond,
                                                        o_error)
                THEN
                    RAISE g_exception;
                END IF;
                l_where := l_where || l_where_cond;
            
                IF (i_id_crit(i) IN (k_crit_follow_ups_active, k_crit_follow_ups_inactive) AND
                   i_crit_cond(i) = k_follow_up_mode)
                THEN
                    l_follow_ups_mode := pk_alert_constant.g_yes;
                END IF;
            
                IF (i_id_crit(i) IN (k_crit_assigned_therapist))
                THEN
                    l_search_assign_prof := pk_alert_constant.g_yes;
                    l_assigned_prof      := to_number(i_crit_cond(i));
                END IF;
            
            END IF;
        END LOOP;
    
        IF (l_follow_ups_mode = pk_alert_constant.g_yes AND l_search_assign_prof = pk_alert_constant.g_yes)
        THEN
            l_where := REPLACE(l_where, 'nvl(rs.ID_PROFESSIONAL, ei.id_professional)', i_prof.id);
            l_where := REPLACE(l_where, '@PROF_QUEST', l_assigned_prof);
        ELSE
            l_where := REPLACE(l_where, '@PROF_QUEST', l_assigned_prof);
        END IF;
    
        IF (NOT pk_search.get_from(i_criteria => i_id_crit,
                                   i_crit_val => i_crit_cond,
                                   i_lang     => i_lang,
                                   i_prof     => i_prof,
                                   o_from     => l_from,
                                   o_hint     => l_hint))
        THEN
            l_from := NULL;
        END IF;
    
        pk_context_api.set_parameter('i_prof_id', i_prof.id);
        pk_context_api.set_parameter('i_prof_software', i_prof.software);
        pk_context_api.set_parameter('i_prof_institution', i_prof.institution);
    
        l_where := REPLACE(l_where, '@LANGUAGE', i_lang);
    
        l_profile_template := pk_prof_utils.get_prof_profile_template(i_prof);
    
        IF l_profile_template = g_cdc_prof_templ
        THEN
            l_flg_sch_type_cr    := 'PC'; --chemical dependency counselour appointments
            l_epis_type_rehab_ap := 28;
        ELSE
            l_flg_sch_type_cr    := 'CR'; --Rehab appointments
            l_epis_type_rehab_ap := 25; --epis_type Rehab appointments
        END IF;
    
        IF l_follow_ups_mode = pk_alert_constant.g_no
        THEN
            -- pacientes com tratamentos agendados
            l_sql_header_1 := '    
            SELECT  distinct ' || nvl(l_hint, ' NULL position, ') ||
                              ' rs.id_schedule id_schedule,
                            (select  (SELECT cr.num_clin_record
                               FROM clin_record cr
                              WHERE cr.id_patient = rp.id_patient
                                AND cr.id_institution = :i_prof_institution
                                AND rownum < 2) from dual) num_clin_record,
                            t.id_patient,
                            t.id_episode id_episode_origin,
                            nvl(re.id_episode_rehab, t.id_episode) id_episode,
                            t.id_visit,
                            (select pk_patient.get_pat_name(:i_lang, :i_prof, t.id_patient, t.id_episode, rs.id_schedule) from dual) name,
                            (select pk_adt.get_pat_non_disc_options(:i_lang, :i_prof, t.id_patient) from dual) pat_ndo,
                            (select pk_adt.get_pat_non_disclosure_icon(:i_lang, :i_prof, t.id_patient) from dual) pat_nd_icon,
                            (select pk_patient.get_pat_age(:i_lang, t.id_patient, :i_prof) from dual) pat_age,
                            (select pk_patient.get_pat_gender(t.id_patient) from dual) AS gender,
                            (select pk_patphoto.get_pat_photo(:i_lang, :i_prof, t.id_patient, t.id_episode, rs.id_schedule) from dual) photo,
                            (select pk_rehab.get_rehab_sch_need_resp(:i_lang, rsn.id_resp_professional, rsn.id_resp_rehab_group) from dual) nick_name,
                            (select pk_date_utils.date_char_hour_tsz(:i_lang,
                                                             decode(re.id_episode_rehab, NULL, NULL, re.dt_creation),
                                                             :i_prof_institution,
                                                             :i_prof_software) from dual) dt_efectiv,
                            (select pk_date_utils.dt_chr_hour_tsz(:i_lang, s.dt_begin_tstz,  :i_prof_institution, :i_prof_software) from dual) dt_target,
                            :g_sysdate_char dt_server,
                            (select pk_rehab.get_grid_workflow_icon(:i_lang, :i_prof, :g_workflow_type_s, nvl(re.flg_status, :g_rehab_epis_enc_status_a)) from dual) new_icon_name,
                            -- FIXME Shortcut is hardcoded!
                            1442 shortcut,
                            (select pk_date_utils.date_send_tsz(:i_lang, s.dt_schedule_tstz, :i_prof) from dual) AS dt_exec,
                            (select nvl(re.flg_status, :g_rehab_epis_enc_status_a) from dual) AS flg_status,
                            ''Y'' AS flg_available,
                            :g_workflow_type_s AS flg_type,
                            1 AS id_schedule_type,
                            --pk_sysdomain.get_domain(''SCHEDULE.FLG_SCH_TYPE'',s.flg_sch_type,i_lang) 
                            :l_session_with_schedule AS desc_schedule_type,
                            (select pk_translation.get_translation(:i_lang, rst.code_rehab_session_type) from dual) AS desc_session_type,
                            decode(bd.code_bed,
                                   NULL,
                                   NULL,
                                   (select nvl(pk_translation.get_translation(:i_lang, dpt.abbreviation),
                                       pk_translation.get_translation(:i_lang, dpt.code_department)) from dual)) desc_service,
                            (select nvl(nvl(ro.desc_room_abbreviation, pk_translation.get_translation(:i_lang, ro.code_abbreviation)),
                                nvl(ro.desc_room, pk_translation.get_translation(:i_lang, ro.code_room))) from dual) desc_room,
                            (select nvl(bd.desc_bed, pk_translation.get_translation(:i_lang, bd.code_bed)) from dual) desc_bed,
                            re.id_rehab_epis_encounter id_rehab_grid,
                            rsn.id_rehab_sch_need id_rehab_presc,
                            rs.id_rehab_schedule id_rehab_schedule,
                            (select pk_sysdomain.get_domain(''EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC'', ei.id_software, :i_lang) from dual) origin,
                            s.id_schedule id_lock_uq_value,
                            ''REHAB_GRID_SCHED'' lock_func,
                            pk_rehab.get_grid_lock(:i_lang,:i_prof, ''REHAB_GRID_SCHED'', s.id_schedule) id_lock';
            l_sql_body_1   := ' FROM rehab_schedule rs
                          JOIN schedule s
                            ON s.id_schedule = rs.id_schedule
                          JOIN rehab_sch_need rsn
                            ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
                          JOIN rehab_presc rpres
                            ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                          JOIN rehab_session_type rst
                            ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                          JOIN rehab_plan rp
                            ON rp.id_episode_origin = rsn.id_episode_origin
                          JOIN episode t
                            ON t.id_episode = rsn.id_episode_origin
                          JOIN epis_info ei
                            ON ei.id_episode = t.id_episode
                          LEFT JOIN bed bd
                            ON bd.id_bed = ei.id_bed
                          LEFT JOIN room ro
                            ON (ro.id_room = s.id_room OR ro.id_room = bd.id_room)  
                          LEFT JOIN department dpt
                            ON dpt.id_department = ro.id_department
                          LEFT JOIN epis_info eir
                            ON eir.id_schedule = rs.id_schedule
                          LEFT JOIN rehab_epis_encounter re
                            ON re.id_episode_rehab = eir.id_episode
                          JOIN rehab_area_interv rai
                            ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
                          LEFT JOIN ( select /*+ OPT_ESTIMATE(TABLE xinner ROWS=1) */ * from table(pk_rehab.find_prof_rehab_areas(:i_prof_id, :i_prof_institution)) xinner  ) x 
                            ON x.id_rehab_area = rai.id_rehab_area
                            -- pesquisa
                          /*JOIN patient pat
                            ON pat.id_patient = e.id_patient*/
                          ' ||
                              nvl(l_from,
                                  'JOIN patient pat
                            ON pat.id_patient = t.id_patient') ||
                              ' JOIN clin_record cr
                            ON cr.id_patient = pat.id_patient 
                            join intervention i
                               on i.id_intervention = rai.id_intervention 
                       LEFT JOIN episode e ON  re.id_episode_rehab= e.id_episode                                                           
                         WHERE rs.flg_status = :g_rehab_schedule_scheduled
                           AND s.flg_status != ''T''
                           AND s.flg_status != ''V''
                           AND RPRES.FLG_STATUS != ''C''  
                           AND cr.id_institution = :i_prof_institution
                           AND e.id_institution = :i_prof_institution
                           AND ((:l_flg_state =''A'' and nvl(RE.FLG_STATUS, ''A'') not in (''O'',''C'',''F'') AND nvl(e.flg_status,t.flg_status) in (''A'',''P'')) 
                           or (:l_flg_state =''I'' and (RE.FLG_STATUS in (''O'',''C'',''F'') OR nvl(e.flg_status,t.flg_status) = ''I'')) )' ||
                              l_where;
        
            -- pacientes com tratamentos sem agendamento
            l_sql_header_2 := '                          
                        SELECT     distinct  ' || nvl(l_hint, ' NULL position, ') ||
                              '  null id_schedule,
                                        (select (SELECT cr.num_clin_record
                                           FROM clin_record cr
                                          WHERE cr.id_patient = rp.id_patient
                                            AND cr.id_institution = :i_prof_institution
                                            AND rownum < 2) from dual) num_clin_record,
                                        e.id_patient,
                                        t.id_episode id_episode_origin,
                                        nvl(re.id_episode_rehab, t.id_episode) id_episode,
                                        t.id_visit,
                                        (select pk_patient.get_pat_name(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) name,
                                        (select pk_adt.get_pat_non_disc_options(:i_lang, :i_prof, t.id_patient) from dual) pat_ndo,
                                        (select pk_adt.get_pat_non_disclosure_icon(:i_lang, :i_prof, t.id_patient) from dual) pat_nd_icon,
                                        (select pk_patient.get_pat_age(:i_lang, t.id_patient, :i_prof) from dual) pat_age,
                                        (select pk_patient.get_pat_gender(t.id_patient) from dual) AS gender,
                                        (select pk_patphoto.get_pat_photo(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) photo,
                                        (select pk_rehab.get_rehab_sch_need_resp(:i_lang,
                                                                rsn.id_resp_professional,
                                                                rsn.id_resp_rehab_group) from dual) nick_name,
                                        (select pk_date_utils.date_char_hour_tsz(:i_lang,
                                                                         re.dt_creation,
                                                                         :i_prof_institution,
                                                                         :i_prof_software) from dual) dt_efectiv,
                                        (select pk_date_utils.dt_chr_hour_tsz(:i_lang, NULL, :i_prof_institution, :i_prof_software) from dual) dt_target,
                                        :g_sysdate_char dt_server,
                                        (select pk_rehab.get_grid_workflow_icon(:i_lang,
                                                               :i_prof,
                                                               :g_workflow_type_w,
                                                               nvl(re.flg_status, :g_rehab_epis_enc_status_e)) from dual) new_icon_name,
                                        -- FIXME Shortcut is hardcoded!
                                        1442 shortcut,
                                        (select pk_date_utils.date_send_tsz(:i_lang, NULL, :i_prof) from dual) AS dt_exec,
                                        (select nvl(re.flg_status, :g_rehab_epis_enc_status_e) from dual) AS flg_status,
                                        ''Y'' AS flg_available,
                                        :g_workflow_type_w AS flg_type,
                                        1 AS id_schedule_type,                                         
                                        :l_session_without_schedule AS desc_schedule_type,
                                        (select pk_translation.get_translation(:i_lang, rst.code_rehab_session_type) from dual) AS desc_session_type,
                                        decode(bd.code_bed,
                                               NULL,
                                               NULL,
                                               (select nvl(pk_translation.get_translation(:i_lang, dpt.abbreviation),
                                                   pk_translation.get_translation(:i_lang, dpt.code_department)) from dual)) desc_service,
                                        nvl(nvl(ro.desc_room_abbreviation, pk_translation.get_translation(:i_lang, ro.code_abbreviation)),
                                            nvl(ro.desc_room, pk_translation.get_translation(:i_lang, ro.code_room))) desc_room,
                                        (select nvl(bd.desc_bed, pk_translation.get_translation(:i_lang, bd.code_bed)) from dual) desc_bed,
                                        re.id_rehab_epis_encounter id_rehab_grid,
                                        rsn.id_rehab_sch_need      id_rehab_presc,
                                        NULL                       id_rehab_schedule,
                                        (select pk_sysdomain.get_domain(''EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC'', ei.id_software, :i_lang) from dual) origin,
                                        rpres.id_rehab_presc id_lock_uq_value,
                                        ''REHAB_GRID_PRESC'' lock_func,
                                        pk_rehab.get_grid_lock(:i_lang,:i_prof, ''REHAB_GRID_PRESC'', rpres.id_rehab_presc) id_lock';
        
            l_sql_body_2 := ' FROM rehab_presc rpres
                          JOIN rehab_sch_need rsn
                            ON rsn.id_rehab_sch_need = rpres.id_rehab_sch_need
                          JOIN rehab_session_type rst
                            ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                          JOIN rehab_plan rp
                            ON rp.id_episode_origin = rsn.id_episode_origin
                          JOIN episode t
                            ON t.id_episode = rsn.id_episode_origin -- falta este episódio
                          left JOIN epis_info ei ON ei.id_episode = t.id_episode
                          left JOIN bed bd ON bd.id_bed = ei.id_bed
                          left JOIN room ro ON ro.id_room = bd.id_room
                          left JOIN department dpt ON dpt.id_department = ro.id_department
                          LEFT JOIN rehab_epis_encounter re                          
                          ON re.id_episode_origin = t.id_episode AND re.dt_creation BETWEEN ''' ||
                            l_dt_begin || ''' AND
                                       ''' || l_dt_end || ''' AND re.id_rehab_sch_need = rsn.id_rehab_sch_need
                        --para as areas em que está alocado
                          JOIN rehab_area_interv rai
                            ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
                          LEFT JOIN ( select /*+ OPT_ESTIMATE(TABLE xinner ROWS=1) */ * from table(pk_rehab.find_prof_rehab_areas(:i_prof_id, :i_prof_institution)) xinner  ) x 
                            ON x.id_rehab_area = rai.id_rehab_area
                            -- pesquisa
                            ' ||
                            nvl(l_from,
                                'JOIN patient pat
                            ON pat.id_patient = t.id_patient') ||
                            ' JOIN clin_record cr
                            ON cr.id_patient = pat.id_patient                             
                          join intervention i
                               on i.id_intervention = rai.id_intervention
                          left join rehab_schedule rs
                              on rsn.id_rehab_sch_need = rs.id_rehab_sch_need
                          left JOIN schedule s
                              ON s.id_schedule = rs.id_schedule
                           left JOIN episode e ON e.id_episode = re.id_episode_rehab
                               AND t.id_institution = :i_prof_institution
                         WHERE rsn.flg_status = :g_rehab_sch_need_no_sched
                           AND rpres.flg_status <> :g_rehab_presc_referral
                           AND cr.id_institution = :i_prof_institution  
                           AND RPRES.flg_status NOT IN (''X'',
                                                        ''N'',
                                                        ''C'',
                                                        ''D'',
                                                        ''F'')                                             
                              --epis_origin activo
                            AND ((:l_flg_state =''A'' AND nvl(e.flg_status,t.flg_status) in (''A'',''P'')
                            and (nvl(RE.FLG_STATUS,''ZZZ'') not in (''O'',''C'',''F'') or re.id_rehab_epis_encounter is null)) 
                            or (:l_flg_state =''I'' 
                            and ((nvl(RE.FLG_STATUS,''ZZZ'') in (''O'',''C'',''F'') OR nvl(e.flg_status,t.flg_status) = ''I''))))' ||
                            l_where;
        
            -- pacientes sem tratamentos agendados
        
            l_sql_header_3 := ' SELECT distinct  ' || nvl(l_hint, ' NULL position, ') ||
                              '  s.id_schedule id_schedule,
        (select (SELECT cr.num_clin_record
           FROM clin_record cr
          WHERE cr.id_patient = t.id_patient
            AND cr.id_institution = :i_prof_institution
            AND rownum < 2) from dual) num_clin_record,
        t.id_patient,
        t.id_episode id_episode_origin,
        nvl(re.id_episode_rehab, t.id_episode) id_episode,
        t.id_visit,
        (select pk_patient.get_pat_name(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) name,
        (select pk_adt.get_pat_non_disc_options(:i_lang, :i_prof, t.id_patient) from dual) pat_ndo,
        (select pk_adt.get_pat_non_disclosure_icon(:i_lang, :i_prof, t.id_patient) from dual) pat_nd_icon,
        (select pk_patient.get_pat_age(:i_lang, t.id_patient, :i_prof) from dual) pat_age,
        (select pk_patient.get_pat_gender(t.id_patient) from dual) AS gender,
        (select pk_patphoto.get_pat_photo(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) photo,
        NULL nick_name,
        (select pk_date_utils.date_char_hour_tsz(:i_lang, re.dt_creation, :i_prof_institution, :i_prof_software) from dual) dt_efectiv,
        (select pk_date_utils.dt_chr_hour_tsz(:i_lang, s.dt_begin_tstz, :i_prof_institution, :i_prof_software) from dual) dt_target,
        :g_sysdate_char dt_server,
        (select pk_rehab.get_grid_workflow_icon(:i_lang,
                                        :i_prof,
                                        :g_workflow_type_a,
                                        nvl(re.flg_status, :g_rehab_epis_enc_status_a)) from dual) new_icon_name,
        1442 shortcut,
        (select pk_date_utils.date_send_tsz(:i_lang, NULL, :i_prof) from dual) AS dt_exec,
        (select nvl(re.flg_status, :g_rehab_epis_enc_status_a) from dual) AS flg_status,
        ''Y'' AS flg_available,
        :g_workflow_type_a AS flg_type,
        sp.id_epis_type AS id_schedule_type,
        :l_appointment AS desc_schedule_type,
        NULL AS desc_session_type,
        NULL AS desc_service,
        NULL AS desc_room,
        NULL AS desc_bed,
        re.id_rehab_epis_encounter id_rehab_grid,
        NULL id_rehab_presc,
        NULL id_rehab_schedule,
        (select (select pk_sysdomain.get_domain(''EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC'', ei.id_software, :i_lang) from dual) from dual) origin,
        s.id_schedule id_lock_uq_value,
        ''REHAB_GRID_SCHED'' lock_func,
        pk_rehab.get_grid_lock(:i_lang,:i_prof, ''REHAB_GRID_SCHED'', s.id_schedule) id_lock';
        
            l_sql_body_3 := ' FROM  schedule_outp sp
        JOIN schedule s ON s.id_schedule = sp.id_schedule
        JOIN sch_group sg ON sg.id_schedule = s.id_schedule
        JOIN epis_info ei ON s.id_schedule = ei.id_schedule
        JOIN epis_type et ON sp.id_epis_type = et.id_epis_type
        JOIN episode t ON ei.id_episode = t.id_episode        
        ' || nvl(l_from,
                                            'JOIN patient pat
                            ON pat.id_patient = t.id_patient') || ' 
        JOIN clin_record cr ON cr.id_patient = pat.id_patient         
        LEFT JOIN rehab_epis_encounter re ON re.id_episode_origin = t.id_episode 
        LEFT JOIN rehab_environment r ON r.id_epis_type = t.id_epis_type
        LEFT JOIN REHAB_SCH_NEED RSN ON RSN.ID_REHAB_SCH_NEED=RE.ID_REHAB_SCH_NEED        
        LEFT JOIN rehab_presc rpres ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
        LEFT JOIN rehab_area_interv rai ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
        LEFT join intervention i on i.id_intervention = rai.id_intervention 
        LEFT JOIN ( select /*+ OPT_ESTIMATE(TABLE xinner ROWS=1) */ * from table(pk_rehab.find_prof_rehab_areas(:i_prof_id, :i_prof_institution)) xinner  ) x ON x.id_rehab_area = rai.id_rehab_area  
        LEFT JOIN rehab_schedule rs ON rs.id_schedule = s.id_schedule
        JOIN clin_record cr ON cr.id_patient = pat.id_patient
        left JOIN episode e ON e.id_episode = re.id_episode_rehab
        WHERE s.flg_status != :l_sched_status_cache
        AND s.flg_status != :l_flg_status_c 
        AND (RPRES.FLG_STATUS != ''C'' OR RPRES.FLG_STATUS IS NULL)
        AND s.id_instit_requested = :i_prof_institution AND sp.id_epis_type IN (50, :l_epis_type_rehab_ap)
           AND cr.id_institution = :i_prof_institution 
         AND ((:l_flg_state =''A'' and nvl(RE.FLG_STATUS, ''A'') not in (''O'',''C'',''F'') AND (:l_show_med_disch  = ''Y'' OR  (:l_show_med_disch  = ''N'' AND pk_grid.get_schedule_real_state(sp.flg_state, t.flg_ehr) !=:l_sched_med_disch)) AND pk_grid.get_schedule_real_state(sp.flg_state, t.flg_ehr) !=:l_sched_adm_disch AND NOT EXISTS (SELECT 1 FROM discharge d WHERE d.id_episode = t.id_episode AND d.flg_status IN (''A'', ''P'')) AND nvl(e.flg_status,t.flg_status) in (''A'',''P''))
          or (:l_flg_state =''I'' and (RE.FLG_STATUS in (''O'',''C'',''F'') OR pk_grid.get_schedule_real_state(sp.flg_state, t.flg_ehr) IN (:l_sched_adm_disch,:l_sched_med_disch) OR nvl(e.flg_status,t.flg_status) = ''I'')) ) AND cr.id_institution = :i_prof_institution ' ||
                            l_where;
        
            -- pacientes com PLANO
            l_sql_header_4 := '                          
                        SELECT     distinct  ' || nvl(l_hint, ' NULL position, ') ||
                              '  null id_schedule,
                                        (select (SELECT cr.num_clin_record
                                           FROM clin_record cr
                                          WHERE cr.id_patient = t.id_patient
                                            AND cr.id_institution = :i_prof_institution
                                            AND rownum < 2) from dual) num_clin_record,
                                        t.id_patient,
                                        t.id_episode id_episode_origin,
                                        nvl(re.id_episode_rehab, t.id_episode) id_episode,
                                        t.id_visit,
                                        (select pk_patient.get_pat_name(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) name,
                                        (select pk_adt.get_pat_non_disc_options(:i_lang, :i_prof, t.id_patient) from dual) pat_ndo,
                                        (select pk_adt.get_pat_non_disclosure_icon(:i_lang, :i_prof, t.id_patient) from dual) pat_nd_icon,
                                        (select pk_patient.get_pat_age(:i_lang, t.id_patient, :i_prof) from dual) pat_age,
                                        (select pk_patient.get_pat_gender(t.id_patient) from dual) AS gender,
                                        (select pk_patphoto.get_pat_photo(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) photo,
                                         pk_prof_utils.get_name(:i_lang, rep.id_prof_create) nick_name,
                                        (select pk_date_utils.date_char_hour_tsz(:i_lang,
                                                                         rep.dt_rehab_epis_plan,
                                                                         :i_prof_institution,
                                                                         :i_prof_software) from dual) dt_efectiv,
                                        (select pk_date_utils.dt_chr_hour_tsz(:i_lang, NULL, :i_prof_institution, :i_prof_software) from dual) dt_target,
                                        :g_sysdate_char dt_server,
                                        (select pk_rehab.get_grid_workflow_icon(:i_lang,
                                                               :i_prof,
                                                               :g_workflow_type_w,
                                                               nvl(re.flg_status, :g_rehab_epis_enc_status_e)) from dual) new_icon_name,
                                        -- FIXME Shortcut is hardcoded!
                                        1442 shortcut,
                                        (select pk_date_utils.date_send_tsz(:i_lang, NULL, :i_prof) from dual) AS dt_exec,
                                        (select nvl(re.flg_status, :g_rehab_epis_enc_status_e) from dual) AS flg_status,
                                        ''Y'' AS flg_available,
                                        :g_workflow_type_w AS flg_type,
                                        1 AS id_schedule_type,                                         
                                        :l_session_without_schedule AS desc_schedule_type,
                                        pk_message.get_message(:i_lang, ''REHAB_M050'') AS desc_session_type,
                                        decode(bd.code_bed,
                                               NULL,
                                               NULL,
                                               (select nvl(pk_translation.get_translation(:i_lang, dpt.abbreviation),
                                                   pk_translation.get_translation(:i_lang, dpt.code_department)) from dual)) desc_service,
                                        nvl(nvl(ro.desc_room_abbreviation, 
                                                pk_translation.get_translation(:i_lang, ro.code_abbreviation)),
                                            nvl(ro.desc_room, pk_translation.get_translation(:i_lang, ro.code_room))) desc_room,
                                        (select nvl(bd.desc_bed, pk_translation.get_translation(:i_lang, bd.code_bed)) from dual) desc_bed,
                                        NULL id_rehab_grid,
                                        NULL id_rehab_presc,
                                        NULL id_rehab_schedule,
                                        (select pk_sysdomain.get_domain(''EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC'', ei.id_software, :i_lang) from dual) origin,
                                        rep.id_rehab_epis_plan id_lock_uq_value,
                                        ''REHAB_GRID_PLAN'' lock_func,
                                        pk_rehab.get_grid_lock(:i_lang,:i_prof, ''REHAB_GRID_PLAN'', rep.id_rehab_epis_plan) id_lock';
        
            l_sql_body_4 := ' FROM rehab_epis_plan rep
                          JOIN rehab_epis_plan_team rept
                            ON (rept.id_rehab_epis_plan = rep.id_rehab_epis_plan AND rept.flg_status = ''Y'')
                          LEFT JOIN prof_cat pc
                            ON (rept.id_prof_cat = pc.id_prof_cat AND pc.id_professional = :i_prof_id)
                          JOIN episode t
                            ON (t.id_episode = nvl((SELECT DISTINCT ree.id_episode_origin
                                                     FROM rehab_epis_encounter ree
                                                    WHERE ree.id_episode_rehab = rep.id_episode),
                                                   rep.id_episode) AND t.id_institution = :i_prof_institution)  
                          JOIN rehab_environment r
                            ON r.id_epis_type = t.id_epis_type
                           AND r.id_institution = :i_prof_institution
                           AND r.id_rehab_environment IN
                               (SELECT rep.id_rehab_environment
                                  FROM rehab_environment_prof rep
                                 WHERE rep.id_professional = :i_prof_id)
                          LEFT JOIN epis_info ei
                            ON ei.id_episode = t.id_episode
                          LEFT JOIN bed bd
                            ON bd.id_bed = ei.id_bed
                          LEFT JOIN room ro
                            ON ro.id_room = bd.id_room
                          LEFT JOIN department dpt
                            ON dpt.id_department = ro.id_department
                          LEFT JOIN rehab_epis_encounter re
                            ON re.id_episode_origin = t.id_episode 
                           
                          LEFT JOIN REHAB_SCH_NEED RSN ON RSN.ID_REHAB_SCH_NEED=RE.ID_REHAB_SCH_NEED        
                          LEFT JOIN rehab_schedule rs ON rs.ID_REHAB_SCH_NEED = RSN.ID_REHAB_SCH_NEED  
                          LEFT JOIN rehab_presc rpres ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                          LEFT JOIN rehab_area_interv rai ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
                          LEFT join intervention i on i.id_intervention = rai.id_intervention 
                          LEFT JOIN ( select /*+ OPT_ESTIMATE(TABLE xinner ROWS=1) */ * from table(pk_rehab.find_prof_rehab_areas(:i_prof_id, :i_prof_institution)) xinner  ) x ON x.id_rehab_area = rai.id_rehab_area  
                            -- pesquisa
                            ' ||
                            nvl(l_from,
                                'JOIN patient pat
                            ON pat.id_patient = t.id_patient') ||
                           
                            ' JOIN clin_record cr
                            ON cr.id_patient = pat.id_patient     
               WHERE t.id_episode NOT IN (SELECT rsn.id_episode_origin
                                                      FROM rehab_sch_need rsn)
                           AND rep.flg_status = ''O''
                           --epis_origin activo
                            AND ((:l_flg_state =''A'' 
                            and nvl(RE.FLG_STATUS,''ZZZ'') not in (''O'',''C'',''F'')) 
                            or (:l_flg_state =''I'' 
                            AND t.id_institution = :i_prof_institution 
                            and nvl(RE.FLG_STATUS,''ZZZ'') in (''O'',''C'',''F'')) )' ||
                            REPLACE(l_where, 'S.DT_BEGIN_TSTZ', 'REP.DT_REHAB_EPIS_PLAN');
        ELSIF l_follow_ups_mode = pk_alert_constant.g_yes
        THEN
        
            l_follow_ups := pk_message.get_message(i_lang, i_prof, 'SEARCH_CRITERIA_T029');
        
            -- pacientes com follow-up
            l_sql_header_6 := ' SELECT distinct  ' || nvl(l_hint, ' NULL position, ') ||
                              '  s.id_schedule id_schedule,
        (select (SELECT cr.num_clin_record
           FROM clin_record cr
          WHERE cr.id_patient = t.id_patient
            AND cr.id_institution = :i_prof_institution
            AND rownum < 2) from dual) num_clin_record,
        t.id_patient,
        t.id_episode id_episode_origin,
        t.id_episode, 
        t.id_visit,
        (select pk_patient.get_pat_name(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) name,
        (select pk_adt.get_pat_non_disc_options(:i_lang, :i_prof, t.id_patient) from dual) pat_ndo,
        (select pk_adt.get_pat_non_disclosure_icon(:i_lang, :i_prof, t.id_patient) from dual) pat_nd_icon,
        (select pk_patient.get_pat_age(:i_lang, t.id_patient, :i_prof) from dual) pat_age,
        (select pk_patient.get_pat_gender(t.id_patient) from dual) AS gender,
        (select pk_patphoto.get_pat_photo(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) photo,
        pk_prof_utils.get_name(:i_lang, ei.id_professional) nick_name,
        NULL dt_efectiv,
        (select pk_date_utils.dt_chr_hour_tsz(:i_lang, s.dt_begin_tstz, :i_prof_institution, :i_prof_software) from dual) dt_target,
        :g_sysdate_char dt_server,
        NULL new_icon_name,
        1442 shortcut,
        (select pk_date_utils.date_send_tsz(:i_lang, NULL, :i_prof) from dual) AS dt_exec,
        NULL flg_status,
        ''Y'' AS flg_available,
        :g_workflow_type_a AS flg_type,
        sp.id_epis_type AS id_schedule_type,
        :l_follow_ups AS desc_schedule_type,
        NULL AS desc_session_type,
        NULL AS desc_service,
        NULL AS desc_room,
        NULL AS desc_bed,
        NULL id_rehab_grid,
        NULL id_rehab_presc,
        NULL id_rehab_schedule,
        (select (select pk_sysdomain.get_domain(''EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC'', ei.id_software, :i_lang) from dual) from dual) origin,
        s.id_schedule id_lock_uq_value,
        ''REHAB_GRID_SCHED'' lock_func,
        pk_rehab.get_grid_lock(:i_lang,:i_prof, ''REHAB_GRID_SCHED'', s.id_schedule) id_lock';
        
            l_sql_body_6 := '  FROM epis_info ei
  JOIN episode t
    ON ei.id_episode = t.id_episode     
  JOIN clinical_service cs
    ON t.id_cs_requested = cs.id_clinical_service
  JOIN patient pat
    ON t.id_patient = pat.id_patient
  JOIN clin_record cr
    ON pat.id_patient = cr.id_patient
        ' || nvl(l_from,
                                            'JOIN patient pat
                            ON pat.id_patient = t.id_patient') || ' 
  LEFT JOIN professional p
    ON ei.id_professional = p.id_professional
  LEFT JOIN discharge d
    ON t.id_episode = d.id_episode
  LEFT JOIN schedule s
    ON ei.id_schedule = s.id_schedule
   AND ei.id_schedule > 0
  LEFT JOIN schedule_outp sp
    ON s.id_schedule = sp.id_schedule
  LEFT JOIN sch_prof_outp spo
    ON spo.id_schedule_outp = sp.id_schedule_outp
  LEFT JOIN sch_group sg
    ON s.id_schedule = sg.id_schedule
   AND t.id_patient = sg.id_patient
  LEFT JOIN disch_reas_dest drt
    ON d.id_disch_reas_dest = drt.id_disch_reas_dest
  LEFT JOIN institution inst
    ON drt.id_institution = inst.id_institution
  LEFT JOIN dep_clin_serv dcs2
    ON drt.id_dep_clin_serv = dcs2.id_dep_clin_serv
  LEFT JOIN department dep
    ON dcs2.id_department = dep.id_department
  LEFT JOIN clinical_service cs2
    ON dcs2.id_clinical_service = cs2.id_clinical_service
  LEFT JOIN discharge_dest ddn
    ON drt.id_discharge_dest = ddn.id_discharge_dest
  LEFT JOIN grid_task gt
    ON t.id_episode = gt.id_episode
 WHERE t.id_institution = :i_prof_institution 
   AND t.flg_ehr = :g_flg_ehr_n
   AND t.id_epis_type NOT IN (:g_epis_type_rad, :g_epis_type_exm, :g_epis_type_lab, :g_epis_type_interv)
   AND cr.id_institution = :i_prof_institution
   AND cr.flg_status = :g_clin_active
   AND (d.flg_status IS NULL OR d.flg_status NOT IN (:g_disch_status_cancel, :g_disch_status_reopen))
   AND (s.flg_status IS NULL OR s.flg_status NOT IN (:g_sched_cancel, :g_sched_status_cache)) 
   
  ' || l_where;
        
        ELSE
            g_error     := 'CALL get_epis_type_access';
            l_et_access := pk_search.get_epis_type_access(i_prof     => i_prof,
                                                          i_grp_inst => table_number(i_prof.institution));
        
            -- pacientes com follow-up para o Mental Therapist    
            l_sql_header_5 := ' SELECT distinct  ' || nvl(l_hint, ' NULL position, ') ||
                              '  s.id_schedule id_schedule,
        (select (SELECT cr.num_clin_record
           FROM clin_record cr
          WHERE cr.id_patient = t.id_patient
            AND cr.id_institution = :i_prof_institution
            AND rownum < 2) from dual) num_clin_record,
        t.id_patient,
        t.id_episode id_episode_origin,
        t.id_episode, 
        t.id_visit,
        (select pk_patient.get_pat_name(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) name,
        (select pk_adt.get_pat_non_disc_options(:i_lang, :i_prof, t.id_patient) from dual) pat_ndo,
        (select pk_adt.get_pat_non_disclosure_icon(:i_lang, :i_prof, t.id_patient) from dual) pat_nd_icon,
        (select pk_patient.get_pat_age(:i_lang, t.id_patient, :i_prof) from dual) pat_age,
        (select pk_patient.get_pat_gender(t.id_patient) from dual) AS gender,
        (select pk_patphoto.get_pat_photo(:i_lang, :i_prof, t.id_patient, t.id_episode, NULL) from dual) photo,
        NULL nick_name,
        NULL dt_efectiv,
        (select pk_date_utils.dt_chr_hour_tsz(:i_lang, s.dt_begin_tstz, :i_prof_institution, :i_prof_software) from dual) dt_target,
        :g_sysdate_char dt_server,
        NULL new_icon_name,
        1442 shortcut,
        (select pk_date_utils.date_send_tsz(:i_lang, NULL, :i_prof) from dual) AS dt_exec,
        O.FLG_STATE flg_status,
        ''Y'' AS flg_available,
        :g_workflow_type_a AS flg_type,
        sp.id_epis_type AS id_schedule_type,
        :l_session_without_schedule AS desc_schedule_type,
        NULL AS desc_session_type,
        NULL AS desc_service,
        NULL AS desc_room,
        NULL AS desc_bed,
        NULL id_rehab_grid,
        NULL id_rehab_presc,
        NULL id_rehab_schedule,
        (select (select pk_sysdomain.get_domain(''EPIS_EXT_SYS.EPIS_INFO_SOFT_DESC'', ei.id_software, :i_lang) from dual) from dual) origin,
        s.id_schedule id_lock_uq_value,
        ''REHAB_GRID_SCHED'' lock_func,
        pk_rehab.get_grid_lock(:i_lang,:i_prof, ''REHAB_GRID_SCHED'', s.id_schedule) id_lock';
        
            l_sql_body_5 := '  FROM epis_info ei
  JOIN episode t
    ON ei.id_episode = t.id_episode
  JOIN OPINION O 
    ON O.ID_EPISODE = t.ID_EPISODE
   AND O.ID_OPINION_TYPE = 9 
   AND O.FLG_STATE NOT IN (''C'',''X'',''N'')       
  JOIN clinical_service cs
    ON t.id_cs_requested = cs.id_clinical_service
  JOIN patient pat
    ON t.id_patient = pat.id_patient
  JOIN clin_record cr
    ON pat.id_patient = cr.id_patient
  JOIN (SELECT /*+opt_estimate(table t rows=1)*/
         t.column_value id_epis_type
          FROM TABLE(:l_et_access) t) eta
    ON t.id_epis_type = eta.id_epis_type
    OR eta.id_epis_type = 0     
        ' || nvl(l_from,
                                            'JOIN patient pat
                            ON pat.id_patient = t.id_patient') || ' 
  LEFT JOIN professional p
    ON ei.id_professional = p.id_professional
  LEFT JOIN discharge d
    ON t.id_episode = d.id_episode
  LEFT JOIN schedule s
    ON ei.id_schedule = s.id_schedule
   AND ei.id_schedule > 0
  LEFT JOIN schedule_outp sp
    ON s.id_schedule = sp.id_schedule
  LEFT JOIN sch_prof_outp spo
    ON spo.id_schedule_outp = sp.id_schedule_outp
  LEFT JOIN sch_group sg
    ON s.id_schedule = sg.id_schedule
   AND t.id_patient = sg.id_patient
  LEFT JOIN disch_reas_dest drt
    ON d.id_disch_reas_dest = drt.id_disch_reas_dest
  LEFT JOIN institution inst
    ON drt.id_institution = inst.id_institution
  LEFT JOIN dep_clin_serv dcs2
    ON drt.id_dep_clin_serv = dcs2.id_dep_clin_serv
  LEFT JOIN department dep
    ON dcs2.id_department = dep.id_department
  LEFT JOIN clinical_service cs2
    ON dcs2.id_clinical_service = cs2.id_clinical_service
  LEFT JOIN discharge_dest ddn
    ON drt.id_discharge_dest = ddn.id_discharge_dest
  LEFT JOIN grid_task gt
    ON t.id_episode = gt.id_episode 
  LEFT JOIN ( select ' || i_prof.id ||
                            ' AS ID_PROFESSIONAL, NULL AS CODE_REHAB_AREA FROM DUAL) x  --DUMMY_JOIN
    ON x.ID_PROFESSIONAL = p.id_professional
 WHERE t.id_institution = :i_prof_institution 
   AND t.flg_status NOT IN (:g_epis_inactive, :g_epis_canc)
   AND t.flg_ehr = :g_flg_ehr_n
   AND t.id_epis_type NOT IN (:g_epis_type_rad, :g_epis_type_exm, :g_epis_type_lab, :g_epis_type_interv)
   AND cr.id_institution = :i_prof_institution
   AND cr.flg_status = :g_clin_active
   AND (d.flg_status IS NULL OR d.flg_status NOT IN (:g_disch_status_cancel, :g_disch_status_reopen))
   AND (s.flg_status IS NULL OR s.flg_status NOT IN (:g_sched_cancel, :g_sched_status_cache)) 
   AND ((:l_flg_state = ''A'' AND t.flg_status NOT IN (''I'',''C'')) OR 
   (:l_flg_state = ''I'' AND t.flg_status IN (''I'',''C'')))' ||
                           --  AND ((sp.dt_target_tstz BETWEEN :l_date AND :l_date + INTERVAL ''1'' DAY) OR
                           --      (sp.dt_target_tstz IS NULL AND t.dt_begin_tstz IS NOT NULL))
                            l_where || '
   AND rownum <= :l_limit ';
        
        END IF;
        --DEBUG
        /*    DECLARE
            l_log     CLOB := NULL;
            l_log_aux VARCHAR2(2500);
        BEGIN      
            
        l_log := 'select * from (' || l_sql_header_4 || l_sql_body_4 || ')';
            FOR i IN 1 .. length(l_log)
            LOOP
                IF i = 1
                THEN
                  l_log_aux := substr(l_log, 1, 2000);
        
                  PK_ALERTLOG.log_error(l_log_aux);
                ELSIF MOD(i, 2000) = 0
                THEN
                    l_log_aux := substr(l_log, i, 2000);
        
                    PK_ALERTLOG.log_error(l_log_aux);
                END IF;
            END LOOP;
        END;*/
    
        IF l_follow_ups_mode = pk_alert_constant.g_no
        THEN
            g_error := 'OPEN CURSOR';
            OPEN o_pat FOR 'select * from (' || l_sql_header_1 || l_sql_body_1 || ' union all ' || l_sql_header_2 || l_sql_body_2 || ' union all ' || l_sql_header_3 || l_sql_body_3 || ' union all ' || l_sql_header_4 || l_sql_body_4 || ' ) where rownum <=' || l_limit || ' '
                USING -- primeira parte do union - tratamentos agendados
            i_prof.institution, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_lang, i_prof.institution, i_prof.software, i_lang, i_prof.institution, i_prof.software, g_sysdate_char, i_lang, i_prof, g_workflow_type_s, g_rehab_epis_enc_status_a, i_lang, i_prof, g_rehab_epis_enc_status_a, g_workflow_type_s, l_session_with_schedule, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_prof, i_prof.id, i_prof.institution, g_rehab_schedule_scheduled, i_prof.institution, i_prof.institution, l_flg_state, l_flg_state,
            -- segunda parte do union - tratamentos não agendados
            i_prof.institution, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_lang, i_prof.institution, i_prof.software, i_lang, i_prof.institution, i_prof.software, g_sysdate_char, i_lang, i_prof, g_workflow_type_w, g_rehab_epis_enc_status_e, i_lang, i_prof, g_rehab_epis_enc_status_e, g_workflow_type_w, l_session_without_schedule, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_prof, i_prof.id, i_prof.institution, i_prof.institution, g_rehab_sch_need_no_sched, g_rehab_presc_referral, i_prof.institution, l_flg_state, l_flg_state,
            -- terceira parte do union - consultas
            i_prof.institution, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof.institution, i_prof.software, i_lang, i_prof.institution, i_prof.software, g_sysdate_char, i_lang, i_prof, g_workflow_type_a, g_rehab_epis_enc_status_a, i_lang, i_prof, g_rehab_epis_enc_status_a, g_workflow_type_a, l_appointment, i_lang, i_lang, i_prof, i_prof.id, i_prof.institution, l_sched_status_cache, l_flg_status_c, i_prof.institution, l_epis_type_rehab_ap, i_prof.institution, l_flg_state, l_show_med_disch, l_show_med_disch, l_sched_med_disch, l_sched_adm_disch, l_flg_state, l_sched_adm_disch, l_sched_med_disch, i_prof.institution,
            --quarta parte do union - planos    
            i_prof.institution, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_lang, i_prof.institution, i_prof.software, i_lang, i_prof.institution, i_prof.software, g_sysdate_char, i_lang, i_prof, g_workflow_type_w, g_rehab_epis_enc_status_e, i_lang, i_prof, g_rehab_epis_enc_status_e, g_workflow_type_w, l_session_without_schedule, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_lang, i_prof, i_prof.id, i_prof.institution, i_prof.institution, i_prof.id, i_prof.id, i_prof.institution, l_flg_state, l_flg_state, i_prof.institution;
        
            DECLARE
                o_pat_count pk_types.cursor_type;
            BEGIN
                OPEN o_pat_count FOR 'select count(*) from (' || ' select DISTINCT RS.ID_REHAB_SCHEDULE AS ID ' || l_sql_body_1 || ' union all ' || ' select DISTINCT RPRES.ID_REHAB_PRESC AS ID ' || l_sql_body_2 || ' union all ' || ' select DISTINCT sp.Id_Schedule_Outp AS ID ' || l_sql_body_3 || ' union all ' || ' select DISTINCT REP.ID_REHAB_EPIS_PLAN AS ID ' || l_sql_body_4 || ' ) where rownum <=' || l_limit || ' '
                    USING -- primeira parte do union - tratamentos agendados
                i_prof.id, i_prof.institution, g_rehab_schedule_scheduled, i_prof.institution, i_prof.institution, l_flg_state, l_flg_state,
                -- segunda parte do union - tratamentos não agendados
                i_prof.id, i_prof.institution, i_prof.institution, g_rehab_sch_need_no_sched, g_rehab_presc_referral, i_prof.institution, l_flg_state, l_flg_state,
                -- terceira parte do union - consultas
                i_prof.id, i_prof.institution, l_sched_status_cache, l_flg_status_c, i_prof.institution, l_epis_type_rehab_ap, i_prof.institution, l_flg_state, l_show_med_disch, l_show_med_disch, l_sched_med_disch, l_sched_adm_disch, l_flg_state, l_sched_adm_disch, l_sched_med_disch, i_prof.institution,
                --quarta parte do union - planos    
                i_prof.id, i_prof.institution, i_prof.institution, i_prof.id, i_prof.id, i_prof.institution, l_flg_state, l_flg_state, i_prof.institution;
            
                FETCH o_pat_count
                    INTO l_count;
                CLOSE o_pat_count;
            
            END;
        ELSIF l_follow_ups_mode = pk_alert_constant.g_yes
        THEN
        
            g_error := 'OPEN CURSOR';
            OPEN o_pat FOR 'select * from (' || l_sql_header_6 || l_sql_body_6 || ' ) where rownum <=' || l_limit || ' '
                USING i_prof.institution, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, --10
            i_prof, i_lang, i_lang, i_prof.institution, i_prof.software, g_sysdate_char, i_lang, i_prof, g_workflow_type_w, l_follow_ups, i_lang, --20
            i_lang, i_prof, i_prof.institution, pk_visit.g_flg_ehr_n, pk_search.g_epis_type_rad, pk_search.g_epis_type_exm, --30
            pk_search.g_epis_type_lab, pk_search.g_epis_type_interv, i_prof.institution, pk_search.g_clin_active, pk_discharge_core.g_disch_status_cancel, --35
            pk_discharge_core.g_disch_status_reopen, pk_search.g_sched_cancel, pk_schedule.g_sched_status_cache;
        
            DECLARE
                o_pat_count pk_types.cursor_type;
            BEGIN
                OPEN o_pat_count FOR 'select count(*) from (' || ' select DISTINCT t.id_episode AS ID ' || l_sql_body_6 || ' ) where rownum <=' || l_limit || ' '
                    USING i_prof.institution, pk_visit.g_flg_ehr_n, pk_search.g_epis_type_rad, pk_search.g_epis_type_exm, --
                pk_search.g_epis_type_lab, pk_search.g_epis_type_interv, i_prof.institution, --
                pk_search.g_clin_active, pk_discharge_core.g_disch_status_cancel, --
                pk_discharge_core.g_disch_status_reopen, pk_search.g_sched_cancel, --
                pk_schedule.g_sched_status_cache;
                FETCH o_pat_count
                    INTO l_count;
                CLOSE o_pat_count;
            
            END;
        
        ELSE
            g_error := 'OPEN CURSOR';
            OPEN o_pat FOR 'select * from (' || l_sql_header_5 || l_sql_body_5 || ' ) where rownum <=' || l_limit || ' '
                USING i_prof.institution, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, i_prof, i_lang, --10
            i_prof, i_lang, i_prof.institution, i_prof.software, g_sysdate_char, i_lang, i_prof, g_workflow_type_w, l_session_without_schedule, i_lang, --20
            i_lang, i_prof, l_et_access, i_prof.institution, pk_search.g_epis_inactive, pk_search.g_epis_canc, pk_visit.g_flg_ehr_n, pk_search.g_epis_type_rad, pk_search.g_epis_type_exm, --30
            pk_search.g_epis_type_lab, pk_search.g_epis_type_interv, i_prof.institution, pk_search.g_clin_active, pk_discharge_core.g_disch_status_cancel, --35
            pk_discharge_core.g_disch_status_reopen, pk_search.g_sched_cancel, pk_schedule.g_sched_status_cache, l_flg_state, l_flg_state, l_limit;
        
            DECLARE
                o_pat_count pk_types.cursor_type;
            BEGIN
                OPEN o_pat_count FOR 'select count(*) from (' || ' select DISTINCT o.id_opinion AS ID ' || l_sql_body_5 || ' ) where rownum <=' || l_limit || ' '
                    USING l_et_access, i_prof.institution, pk_search.g_epis_inactive, pk_search.g_epis_canc, pk_visit.g_flg_ehr_n, pk_search.g_epis_type_rad, pk_search.g_epis_type_exm, --
                pk_search.g_epis_type_lab, pk_search.g_epis_type_interv, i_prof.institution, --
                pk_search.g_clin_active, pk_discharge_core.g_disch_status_cancel, --
                pk_discharge_core.g_disch_status_reopen, pk_search.g_sched_cancel, --
                pk_schedule.g_sched_status_cache, l_flg_state, l_flg_state, l_limit;
                FETCH o_pat_count
                    INTO l_count;
                CLOSE o_pat_count;
            
            END;
        END IF;
    
        g_error := 'TOO MANY RESULTS';
        IF l_count > l_limit
        THEN
            o_flg_show  := 'Y';
            o_button    := 'R';
            o_msg       := pk_search.get_overlimit_message(i_lang => i_lang, i_prof => i_prof, i_flg_has_action => 'Y');
            o_msg_title := pk_message.get_message(i_lang, 'SEARCH_CRITERIA_T011');
        ELSIF l_count = 0
        THEN
            o_flg_show  := 'Y';
            o_button    := 'R';
            o_msg       := pk_message.get_message(i_lang, 'COMMON_M015');
            o_msg_title := pk_message.get_message(i_lang, 'SEARCH_CRITERIA_T019');
        ELSE
            g_error := 'OPEN CURSOR';
        END IF;
    
        pk_types.open_cursor_if_closed(o_pat);
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_presc=' || ' @' || g_error, g_package_name, l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_patients_mfr;
    /**********************************************************************************************
    * returns the value of the next change
    *
    * %param i_lang                   id_language
    * %param i_id_rehab_presc         treatment prescription
    *
    * @return                         next id_change
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION get_next_rp_id_change(i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE) RETURN NUMBER IS
        l_count NUMBER;
    BEGIN
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_presc_change rpc
         WHERE rpc.id_rehab_presc = i_id_rehab_presc;
    
        RETURN l_count + 1;
    END get_next_rp_id_change;

    /**********************************************************************************************
    * Updates rehab_presc status when resuming, suspending or discontinuing a treatment
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_presc         treatment prescription
    * %param i_to_state               to state
    * %param i_notes                  notes about status change
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/

    --****************************************************************
    FUNCTION get_schedule_to_discontinue(i_rehab_sch_need IN NUMBER) RETURN table_number IS
        tbl_ids table_number;
    BEGIN
    
        SELECT rpc.id_schedule
          BULK COLLECT
          INTO tbl_ids
          FROM rehab_schedule rpc
          JOIN rehab_sch_need rsn
            ON rsn.id_rehab_sch_need = rpc.id_rehab_sch_need
          JOIN rehab_presc rp
            ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
          JOIN schedule s
            ON s.id_schedule = rpc.id_schedule
          JOIN epis_info ei
            ON ei.id_schedule = s.id_schedule
          JOIN episode e
            ON e.id_episode = ei.id_episode
          JOIN rehab_epis_encounter ree
            ON ree.id_rehab_sch_need = rsn.id_rehab_sch_need
           AND ree.id_episode_rehab = e.id_episode
         WHERE 0 = 0
           AND rpc.id_rehab_sch_need = i_rehab_sch_need
              --AND rp.id_rehab_presc = i_rehab_presc
           AND ree.flg_status = 'A'
           AND rpc.flg_status != 'C'
           AND e.flg_ehr = 'S'
           AND s.dt_begin_tstz > current_timestamp
         ORDER BY s.dt_begin_tstz;
    
        RETURN tbl_ids;
    
    END get_schedule_to_discontinue;

    FUNCTION update_rehab_presc_status
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN table_number,
        i_to_state       IN action.to_state%TYPE,
        i_notes          IN rehab_presc.notes%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'UPDATE_REHAB_PRESC_STATUS';
        l_rowids                    table_varchar;
        l_rehab_presc_status        rehab_presc.flg_status%TYPE;
        l_rehab_presc_status_change rehab_presc_change.flg_status%TYPE;
        l_id_change                 rehab_presc_change.id_change%TYPE;
        l_notes_change              rehab_presc.notes_change%TYPE;
        l_id_schedule               table_number;
        l_id_cancel_reason          sch_cancel_reason.id_sch_cancel_reason%TYPE := 28;
        l_transaction_id            VARCHAR2(4000);
        l_schedule_init             NUMBER;
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
    
        FOR i IN 1 .. i_id_rehab_presc.count
        LOOP
            g_error := 'i=' || i;
        
            l_rehab_presc_status_change := NULL;
        
            CASE i_to_state
            --Interrupt treatment
                WHEN 'E' THEN
                    l_rehab_presc_status := g_rehab_presc_discontinued;
                    --Stop treatment proposal
                WHEN 'P' THEN
                    l_rehab_presc_status        := g_rehab_presc_disc_prop;
                    l_rehab_presc_status_change := g_rehab_presc_discontinued;
                    --Hold treatment
                WHEN 'L' THEN
                    l_rehab_presc_status := g_rehab_presc_suspend;
                    --Hold treatment proposal
                WHEN 'J' THEN
                    l_rehab_presc_status        := g_rehab_presc_susp_prop;
                    l_rehab_presc_status_change := g_rehab_presc_suspend;
                    --Resume
                WHEN 'I' THEN
                    l_rehab_presc_status := g_rehab_presc_ongoing;
                    --Resume proposal
                WHEN 'D' THEN
                    l_rehab_presc_status        := g_rehab_presc_ongoing_prop;
                    l_rehab_presc_status_change := g_rehab_presc_ongoing;
                ELSE
                    g_error := 'Invalid i_to_state=' || i_to_state;
                    RAISE g_exception;
            END CASE;
        
            IF l_rehab_presc_status_change IS NOT NULL
            THEN
                -- only insert in change if it's a proposal
                l_notes_change := NULL;
            
                g_error     := 'get next id_change';
                l_id_change := get_next_rp_id_change(i_id_rehab_presc(i));
            
                g_error := 'ts_rehab_presc_change.ins';
                ts_rehab_presc_change.ins(id_rehab_presc_in    => i_id_rehab_presc(i),
                                          id_change_in         => l_id_change,
                                          dt_change_in         => g_sysdate_tstz,
                                          flg_status_in        => l_rehab_presc_status_change,
                                          flg_status_change_in => g_rehab_presc_chg_proposal,
                                          id_prof_req_in       => i_prof.id,
                                          dt_req_in            => g_sysdate_tstz,
                                          notes_change_in      => i_notes,
                                          handle_error_in      => FALSE,
                                          rows_out             => l_rowids);
            ELSE
                -- if isn't a proposal save directly to final table
                l_notes_change := i_notes;
            END IF;
        
            -- update status in rehab_presc
            g_error := 'ts_rehab_presc.upd';
            ts_rehab_presc.upd(id_rehab_presc_in => i_id_rehab_presc(i),
                               flg_status_in     => l_rehab_presc_status,
                               notes_change_in   => i_notes,
                               notes_change_nin  => FALSE,
                               rows_out          => l_rowids);
        
            g_error := 't_data_gov_mnt.process_update';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_PRESC',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
            g_error := 'set_rehab_presc_hist';
            IF NOT set_rehab_presc_hist(i_lang           => i_lang,
                                        i_prof           => i_prof,
                                        i_id_rehab_presc => i_id_rehab_presc(i),
                                        i_commit         => pk_alert_constant.get_no(),
                                        o_error          => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            IF i_to_state = 'E' -- Descontinuar
            THEN
                -- valida se tem agendamentos 
                /*
                SELECT rs.id_schedule
                  BULK COLLECT
                  INTO l_id_schedule
                  FROM rehab_schedule rs
                 WHERE rs.id_rehab_sch_need = (SELECT id_rehab_sch_need
                                                 FROM rehab_presc rp2
                                                WHERE rp2.id_rehab_presc = i_id_rehab_presc(i))
                   AND rs.flg_status != g_rehab_presc_cancel
                 ORDER BY rs.id_schedule;
                 */
            
                l_id_schedule := get_schedule_to_discontinue(i_id_rehab_presc(i));
            
                g_error := 'count rehab_schedule=' || l_id_schedule.count;
                pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            
                -- se sim, cancela apenas os que ainda não foram executados
                SELECT COUNT(*)
                  INTO l_schedule_init
                  FROM rehab_session rs
                 WHERE rs.id_rehab_presc = i_id_rehab_presc(i)
                   AND rs.flg_status = g_rehab_session_executed;
            
                IF l_id_schedule.count > 0
                THEN
                    --FOR i IN l_schedule_init + 1 .. l_id_schedule.count
                    FOR i IN 1 .. l_id_schedule.count
                    LOOP
                        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
                        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
                        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(NULL, i_prof);
                    
                        IF NOT pk_schedule_api_upstream.cancel_schedule(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_id_schedule      => l_id_schedule(i),
                                                                        i_id_cancel_reason => l_id_cancel_reason,
                                                                        i_cancel_notes     => NULL,
                                                                        i_transaction_id   => l_transaction_id,
                                                                        o_error            => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        IF l_transaction_id IS NOT NULL
                        THEN
                            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
                        END IF;
                    
                    END LOOP;
                END IF;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_presc=' || ' @' || g_error, g_package_name, l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END update_rehab_presc_status;

    /**********************************************************************************************
    * Returns true if the professional profile can change the status directly
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    *
    * @return                         TRUE if professional can change, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION check_prof_can_modify
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_PROF_CAN_MODIFY';
        l_count NUMBER;
        l_error t_error_out;
    BEGIN
        g_error := 'begin';
    
        SELECT COUNT(*)
          INTO l_count
          FROM prof_profile_template ppt
         WHERE ppt.id_professional = i_prof.id
           AND ppt.id_profile_template IN
               (SELECT pt.id_profile_template
                  FROM profile_template pt,
                       TABLE(pk_utils.str_split(pk_sysconfig.get_config('REHAB_PROF_CAN_MODIFY', i_prof), '|')) tab
                 WHERE pt.id_profile_template = tab.column_value
                    OR pt.id_parent = tab.column_value);
    
        IF l_count > 0
        THEN
            RETURN TRUE;
        ELSE
            RETURN FALSE;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_prof.id=' || i_prof.id || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
        
            RETURN FALSE;
        
    END check_prof_can_modify;

    --
    FUNCTION get_rehab_presc_hist_value
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_rehab_presc_hist IN rehab_presc_hist.id_rehab_presc_hist%TYPE,
        i_code                IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_ret VARCHAR2(4000);
    BEGIN
        SELECT decode(i_code,
                      'EXEC_PER_SESSION',
                      to_char(rph.exec_per_session),
                      'EXEC_INSTITUTION',
                      to_char(rph.id_exec_institution),
                      'NOTES',
                      rph.notes,
                      'NOTES_CHANGE',
                      rph.notes_change,
                      'PRIORITY',
                      rsn.flg_priority,
                      'FLG_FREQUENCY',
                      rsn.flg_frequency,
                      'FREQUENCY',
                      to_char(rsn.frequency),
                      'SESSIONS',
                      to_char(rsn.sessions),
                      'START_DATE',
                      pk_date_utils.get_timestamp_str(i_lang, i_prof, rsn.dt_begin, NULL))
          INTO l_ret
          FROM rehab_presc_hist rph
          JOIN rehab_sch_need rsn
            ON rsn.id_rehab_sch_need = rph.id_rehab_sch_need
         WHERE rph.id_rehab_presc_hist = i_id_rehab_presc_hist;
    
        RETURN l_ret;
    END get_rehab_presc_hist_value;

    /**********************************************************************************************
    * Accepts a rehab_presc proposal of suspension, discontinuation or edition
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_presc         treatment prescription
    * %param i_notes                  notes about status change
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION accept_rehab_presc_proposal
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_notes          IN rehab_presc.notes_change%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'ACCEPT_REHAB_PRESC_PROPOSAL';
        l_count       NUMBER;
        l_rowids      table_varchar;
        l_rpc_row     rehab_presc_change%ROWTYPE;
        l_prev_status rehab_presc.flg_status%TYPE;
        l_flg_status  rehab_presc.flg_status%TYPE;
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'is the id_rehab_presc=' || i_id_rehab_presc || ' in a proposal state?';
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_presc rp
         WHERE rp.flg_status IN
               (g_rehab_presc_susp_prop, g_rehab_presc_disc_prop, g_rehab_presc_edit_prop, g_rehab_presc_ongoing_prop)
           AND rp.id_rehab_presc = i_id_rehab_presc;
    
        IF l_count > 0
        THEN
            g_error := 'is in proposal state. accept it';
            SELECT rpc.*
              INTO l_rpc_row
              FROM rehab_presc_change rpc
             WHERE rpc.id_rehab_presc = i_id_rehab_presc
               AND rpc.flg_status_change = g_rehab_presc_chg_proposal
               AND rpc.id_change = (SELECT MAX(id_change)
                                      FROM rehab_presc_change rpc2
                                     WHERE rpc2.id_rehab_presc = i_id_rehab_presc);
        
            g_error := 'ts_rehab_presc_change.upd';
            ts_rehab_presc_change.upd(id_rehab_presc_in    => i_id_rehab_presc,
                                      id_change_in         => l_rpc_row.id_change,
                                      flg_status_change_in => g_rehab_presc_chg_accepted,
                                      id_prof_accept_in    => i_prof.id,
                                      dt_accept_in         => g_sysdate_tstz,
                                      rows_out             => l_rowids);
        
            IF l_rpc_row.flg_status = g_rehab_presc_edit_prop
            THEN
                g_error := 'Get previous FLG_STATUS';
                SELECT flg_status
                  INTO l_prev_status
                  FROM (SELECT rph.flg_status, rank() over(ORDER BY rph.id_rehab_presc_hist DESC) rn
                          FROM rehab_presc_hist rph
                         WHERE rph.id_rehab_presc = i_id_rehab_presc)
                 WHERE rn = 2;
                l_flg_status := l_prev_status;
            ELSE
                l_flg_status := l_rpc_row.flg_status;
            END IF;
        
            g_error := 'ts_rehab_presc.upd';
            ts_rehab_presc.upd(id_rehab_presc_in   => i_id_rehab_presc,
                               flg_status_in       => l_flg_status,
                               exec_per_session_in => l_rpc_row.exec_per_session,
                               notes_change_in     => i_notes,
                               notes_change_nin    => FALSE,
                               rows_out            => l_rowids);
        
            g_error := 't_data_gov_mnt.process_update';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_PRESC',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
            g_error := 'set_rehab_presc_hist';
            IF NOT set_rehab_presc_hist(i_lang           => i_lang,
                                        i_prof           => i_prof,
                                        i_id_rehab_presc => i_id_rehab_presc,
                                        o_error          => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: ' || ' @' || g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
        
    END accept_rehab_presc_proposal;

    /**********************************************************************************************
    * Rejects a rehab_presc proposal of suspension, discontinuation or edition
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_presc         treatment prescription
    * %param i_notes                  notes about status change
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Eduardo Reis
    * @version                        1.0
    * @since                          2010-08-21
    **********************************************************************************************/
    FUNCTION reject_rehab_presc_proposal
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_notes          IN rehab_presc.notes_change%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(30) := 'REJECT_REHAB_PRESC_PROPOSAL';
        l_count               NUMBER;
        l_rowids              table_varchar;
        l_id_change           rehab_presc_change.id_change%TYPE;
        l_rph_row             rehab_presc_hist%ROWTYPE;
        l_id_rehab_presc_hist rehab_presc_hist.id_rehab_presc_hist%TYPE;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'is the id_rehab_presc=' || i_id_rehab_presc || ' in a proposal state?';
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_presc rp
         WHERE rp.flg_status IN
               (g_rehab_presc_susp_prop, g_rehab_presc_disc_prop, g_rehab_presc_edit_prop, g_rehab_presc_ongoing_prop)
           AND rp.id_rehab_presc = i_id_rehab_presc;
    
        IF l_count > 0
        THEN
            g_error := 'is in proposal state. reject it';
            SELECT MAX(id_change)
              INTO l_id_change
              FROM rehab_presc_change rpc
             WHERE rpc.id_rehab_presc = i_id_rehab_presc
               AND rpc.flg_status_change = g_rehab_presc_chg_proposal;
        
            g_error := 'Get previous FLG_STATUS';
            SELECT id_rehab_presc_hist
              INTO l_id_rehab_presc_hist
              FROM (SELECT rph.id_rehab_presc_hist, rank() over(ORDER BY rph.id_rehab_presc_hist DESC) rn
                      FROM rehab_presc_hist rph
                     WHERE rph.id_rehab_presc = i_id_rehab_presc)
             WHERE rn = 2;
        
            SELECT rph.*
              INTO l_rph_row
              FROM rehab_presc_hist rph
             WHERE rph.id_rehab_presc_hist = l_id_rehab_presc_hist;
        
            g_error := 'ts_rehab_presc_change.upd';
            ts_rehab_presc_change.upd(id_rehab_presc_in    => i_id_rehab_presc,
                                      id_change_in         => l_id_change,
                                      flg_status_change_in => g_rehab_presc_chg_rejected,
                                      id_prof_decline_in   => i_prof.id,
                                      dt_decline_in        => g_sysdate_tstz,
                                      rows_out             => l_rowids);
        
            g_error := 'ts_rehab_presc.upd';
            ts_rehab_presc.upd(id_rehab_presc_in      => i_id_rehab_presc,
                               id_rehab_sch_need_in   => l_rph_row.id_rehab_sch_need,
                               id_exec_institution_in => l_rph_row.id_exec_institution,
                               exec_per_session_in    => l_rph_row.exec_per_session,
                               exec_per_session_nin   => FALSE,
                               flg_status_in          => l_rph_row.flg_status,
                               notes_in               => l_rph_row.notes,
                               notes_nin              => FALSE,
                               flg_laterality_in      => l_rph_row.flg_laterality,
                               notes_change_in        => NULL,
                               notes_change_nin       => FALSE,
                               rows_out               => l_rowids);
        
            g_error := 't_data_gov_mnt.process_update';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_PRESC',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
            g_error := 'set_rehab_presc_hist';
            IF NOT set_rehab_presc_hist(i_lang           => i_lang,
                                        i_prof           => i_prof,
                                        i_id_rehab_presc => i_id_rehab_presc,
                                        o_error          => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: ' || ' @' || g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
        
    END reject_rehab_presc_proposal;

    /**********************************************************************************************
    * Cancels a rehab_presc proposal of suspension, discontinuation or edition
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_rehab_presc         treatment prescription
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Joao Martins
    * @version                        v2.6.0.5.1.5
    * @since                          2011-02-10
    **********************************************************************************************/
    FUNCTION cancel_rehab_presc_proposal
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_REHAB_PRESC_PROPOSAL';
        l_count               NUMBER;
        l_rowids              table_varchar;
        l_id_change           rehab_presc_change.id_change%TYPE;
        l_rph_row             rehab_presc_hist%ROWTYPE;
        l_id_rehab_presc_hist rehab_presc_hist.id_rehab_presc_hist%TYPE;
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'is the id_rehab_presc=' || i_id_rehab_presc || ' in a proposal state?';
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_presc rp
         WHERE rp.flg_status IN
               (g_rehab_presc_susp_prop, g_rehab_presc_disc_prop, g_rehab_presc_edit_prop, g_rehab_presc_ongoing_prop)
           AND rp.id_rehab_presc = i_id_rehab_presc;
    
        IF l_count > 0
        THEN
            g_error := 'is in proposal state. cancel it';
            SELECT MAX(id_change)
              INTO l_id_change
              FROM rehab_presc_change rpc
             WHERE rpc.id_rehab_presc = i_id_rehab_presc
               AND rpc.flg_status_change = g_rehab_presc_chg_proposal;
        
            g_error := 'Get previous FLG_STATUS';
            SELECT id_rehab_presc_hist
              INTO l_id_rehab_presc_hist
              FROM (SELECT rph.id_rehab_presc_hist, rank() over(ORDER BY rph.id_rehab_presc_hist DESC) rn
                      FROM rehab_presc_hist rph
                     WHERE rph.id_rehab_presc = i_id_rehab_presc)
             WHERE rn = 2;
        
            SELECT rph.*
              INTO l_rph_row
              FROM rehab_presc_hist rph
             WHERE rph.id_rehab_presc_hist = l_id_rehab_presc_hist;
        
            g_error := 'ts_rehab_presc_change.upd';
            ts_rehab_presc_change.upd(id_rehab_presc_in    => i_id_rehab_presc,
                                      id_change_in         => l_id_change,
                                      flg_status_change_in => g_rehab_presc_chg_canceled,
                                      id_prof_decline_in   => i_prof.id,
                                      dt_decline_in        => g_sysdate_tstz,
                                      rows_out             => l_rowids);
        
            g_error := 'ts_rehab_presc.upd';
            ts_rehab_presc.upd(id_rehab_presc_in      => i_id_rehab_presc,
                               id_rehab_sch_need_in   => l_rph_row.id_rehab_sch_need,
                               id_exec_institution_in => l_rph_row.id_exec_institution,
                               exec_per_session_in    => l_rph_row.exec_per_session,
                               exec_per_session_nin   => FALSE,
                               flg_status_in          => l_rph_row.flg_status,
                               notes_in               => l_rph_row.notes,
                               notes_nin              => FALSE,
                               flg_laterality_in      => l_rph_row.flg_laterality,
                               notes_change_in        => NULL,
                               notes_change_nin       => FALSE,
                               rows_out               => l_rowids);
        
            g_error := 't_data_gov_mnt.process_update';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'REHAB_PRESC',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
            g_error := 'set_rehab_presc_hist';
            IF NOT set_rehab_presc_hist(i_lang           => i_lang,
                                        i_prof           => i_prof,
                                        i_id_rehab_presc => i_id_rehab_presc,
                                        o_error          => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: ' || ' @' || g_error, g_package_name, l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
        
    END cancel_rehab_presc_proposal;

    /**********************************************************************************************
    * Returns information about a given request
    *
    * @param i_lang                  Language ID
    * @param i_prof                  Professional
    * @param i_id_request            Request ID
    * @param o_description           Description
    * @param o_instructions          Instructions
    * @param o_flg_status            Flg_status
    *                        
    * @author                        Joao Martins
    * @version                       v2.5.1.3
    * @since                         2011/01/31
    **********************************************************************************************/
    PROCEDURE get_therapeutic_status
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_request   IN NUMBER,
        o_description  OUT VARCHAR2,
        o_instructions OUT VARCHAR2,
        o_flg_status   OUT VARCHAR2
    ) IS
    BEGIN
        g_error := 'Fetch everything!';
        SELECT pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL),
               pk_rehab.get_instructions(i_lang, i_prof, rp.id_rehab_sch_need),
               decode(rp.flg_status, 'C', pk_alert_constant.g_no, pk_alert_constant.g_yes)
          INTO o_description, o_instructions, o_flg_status
          FROM rehab_presc rp
          JOIN rehab_area_interv rai
            ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
          JOIN intervention i
            ON i.id_intervention = rai.id_intervention
         WHERE rp.id_rehab_presc = i_id_request;
    END get_therapeutic_status;

    /**********************************************************************************************
    * Returns a list of rehab environmentsthat the professional is or can be allocated to in a given institution
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_institution         institution
    * %param o_environment            list of rehab environments
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Nuno Neves
    * @version                        2.6.1
    * @since                          2011-03-02
    **********************************************************************************************/
    FUNCTION get_rehab_environment_prof
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_institution IN institution.id_institution%TYPE,
        o_environment    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'OPEN o_environment for id_professional=' || i_prof.id || ', id_institution=' || i_id_institution;
        OPEN o_environment FOR
            SELECT re.id_rehab_environment,
                   re.id_epis_type,
                   pk_translation.get_translation(i_lang, et.code_epis_type) name,
                   nvl2(rep.id_professional, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_selected
              FROM rehab_environment re
              JOIN epis_type et
                ON et.id_epis_type = re.id_epis_type
              LEFT JOIN rehab_environment_prof rep
                ON rep.id_rehab_environment = re.id_rehab_environment
               AND rep.id_professional = i_prof.id
             WHERE re.id_institution = i_id_institution
            UNION ALL
            SELECT re.id_rehab_environment,
                   re.id_epis_type,
                   pk_translation.get_translation(i_lang, et.code_epis_type) name,
                   nvl2(rep.id_professional, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_selected
              FROM rehab_environment re
              JOIN epis_type et
                ON et.id_epis_type = re.id_epis_type
              LEFT JOIN rehab_environment_prof rep
                ON rep.id_rehab_environment = re.id_rehab_environment
               AND rep.id_professional = i_prof.id
             WHERE re.id_institution = pk_alert_constant.g_inst_all
               AND NOT EXISTS (SELECT 1
                      FROM rehab_environment re1
                     WHERE re1.id_institution = i_id_institution)
             ORDER BY name;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_REHAB_ENVIRONMENT_PROF',
                                              o_error);
            pk_types.open_my_cursor(o_environment);
            RETURN FALSE;
    END get_rehab_environment_prof;

    /**********************************************************************************************
    * Sets the list of rehab environment that the professional is allocated to, in one or more institutions
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_institution            list of institutions to alloc the professional
    * %param i_rehab_area             for each institution a list of rehab environment to alloc the professional
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Nuno Neves
    * @version                        2.6.1
    * @since                          2011-03-02
    **********************************************************************************************/
    FUNCTION set_rehab_environment_prof
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_institution       IN table_number,
        i_rehab_environment IN table_table_number,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_count                  NUMBER;
        l_rehab_environment_prof table_number;
    
    BEGIN
    
        g_error := 'for each institution';
        FOR i IN 1 .. i_institution.count
        LOOP
        
            SELECT COUNT(1)
              INTO l_count
              FROM rehab_environment re
             WHERE re.id_rehab_environment IN (SELECT /*+ opt_estimate(table t rows=1) */
                                                t.*
                                                 FROM TABLE(i_rehab_environment(i)) t)
               AND re.id_rehab_environment > 0;
        
            IF l_count > 0
            THEN
                g_error := 'SELECT for institution ' || i_institution(i) || ' and environments in ' ||
                           pk_utils.concat_table(i_rehab_environment(i));
                SELECT re.id_rehab_environment
                  BULK COLLECT
                  INTO l_rehab_environment_prof
                  FROM rehab_environment re
                 WHERE re.id_institution = i_institution(i);
            
                IF l_rehab_environment_prof.count() > 0
                THEN
                    g_error := 'Delete rehab_environments not in ' || pk_utils.concat_table(l_rehab_environment_prof);
                    DELETE FROM rehab_environment_prof rep
                     WHERE rep.id_professional = i_prof.id
                       AND rep.id_rehab_environment IN
                           (SELECT re.id_rehab_environment
                              FROM rehab_environment re
                             WHERE re.id_institution = i_institution(i));
                
                    g_error := 'insert ' || pk_utils.concat_table(l_rehab_environment_prof) || ' minus already there';
                    INSERT INTO rehab_environment_prof rep
                        (id_rehab_environment_prof, id_rehab_environment, id_professional)
                        SELECT seq_rehab_environment_prof.nextval, re.id_rehab_environment, i_prof.id
                          FROM rehab_environment re
                         WHERE re.id_institution = i_institution(i)
                           AND re.id_rehab_environment IN
                               (SELECT /*+ opt_estimate(table t rows=1) */
                                 t.*
                                  FROM TABLE(i_rehab_environment(i)) t);
                
                END IF;
            ELSE
                g_error := 'Delete rehab_environments in default';
                DELETE FROM rehab_environment_prof rep
                 WHERE rep.id_professional = i_prof.id
                   AND rep.id_rehab_environment IN (SELECT re.id_rehab_environment
                                                      FROM rehab_environment re
                                                     WHERE re.id_institution = 0);
            
                g_error := 'insert default rehab_environments';
                INSERT INTO rehab_environment_prof rep
                    (id_rehab_environment_prof, id_rehab_environment, id_professional)
                    SELECT seq_rehab_environment_prof.nextval, re.id_rehab_environment, i_prof.id
                      FROM rehab_environment re
                     WHERE re.id_rehab_environment IN
                           (SELECT /*+ opt_estimate(table t rows=1) */
                             t.*
                              FROM TABLE(i_rehab_environment(i)) t);
            
            END IF;
        END LOOP;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_REHAB_ENVIRONMENT_PROF',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_rehab_environment_prof;

    /********************************************************************************************
    * Updates the field that describes the status of a referral prescription.
    *
    * @param   i_lang                Language ID
    * @param   i_prof                Professional's details
    * @param   i_id_rehab_presc       Prescription ID
    * @param   i_flg_referral        Referral flag
    * @param   o_error               Error object
    *
    * @return                        True on success, false otherwise
    *
    * @author                        Nuno Neves
    * @version                       2.6.1.1
    * @since                         2011/06/13
    ********************************************************************************************/
    FUNCTION update_flg_referral
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_flg_referral   IN rehab_presc.flg_referral%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rowids table_varchar;
    
    BEGIN
        ts_rehab_presc.upd(id_rehab_presc_in => i_id_rehab_presc,
                           flg_referral_in   => i_flg_referral,
                           flg_referral_nin  => TRUE,
                           rows_out          => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'UPDATE_FLG_REFERRAL',
                                              o_error    => o_error);
            RETURN FALSE;
    END update_flg_referral;

    /********************************************************************************************
    * Updates the field laterality
    *
    * @param   i_lang                Language ID
    * @param   i_prof                Professional's details
    * @param   i_id_rehab_presc       Prescription ID
    * @param   i_flg_referral        Referral flag
    * @param   o_error               Error object
    *
    * @return                        True on success, false otherwise
    *
    * @author                        Joana Barroso
    * @version                       2.6.1.10
    * @since                         2012/08/14
    ********************************************************************************************/
    FUNCTION update_flg_laterality
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_flg_laterality IN rehab_presc.flg_laterality%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rowids table_varchar;
    
    BEGIN
    
        g_error := 'Call ts_rehab_presc.upd / ID_REHAB_PRESC_IN=' || i_id_rehab_presc || ' flg_laterality_in=' ||
                   i_flg_laterality;
        ts_rehab_presc.upd(id_rehab_presc_in  => i_id_rehab_presc,
                           flg_laterality_in  => i_flg_laterality,
                           flg_laterality_nin => FALSE,
                           flg_referral_nin   => TRUE,
                           rows_out           => l_rowids);
    
        g_error := 'Call pk_rehab.set_rehab_presc_hist / id_rehab_presc=' || i_id_rehab_presc;
        IF NOT set_rehab_presc_hist(i_lang           => i_lang,
                                    i_prof           => i_prof,
                                    i_id_rehab_presc => i_id_rehab_presc,
                                    i_commit         => pk_alert_constant.get_no(),
                                    o_error          => o_error)
        THEN
            RAISE g_exception;
        END IF;
        g_error := 'Call t_data_gov_mnt.process_update / I_TABLE_NAME=REHAB_PRESC';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'UPDATE_FLG_LATERALITY',
                                              o_error    => o_error);
            RETURN FALSE;
    END update_flg_laterality;

    /********************************************************************************************
    * Updates the field that defines in which institution the procedure will be performed.
    *
    * @param   i_lang                Language ID
    * @param   i_prof                Professional's details
    * @param   i_id_rehab_presc      Prescription ID
    * @param   i_id_institution      Institution ID
    * @param   o_error               Error object
    *
    * @return                        True on success, false otherwise
    *
    * @author                        Nuno Neves       
    * @version                       2.6.1.1
    * @since                         2011/06/13
    ********************************************************************************************/
    FUNCTION update_exec_institution
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_id_institution IN rehab_presc.id_exec_institution%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rowids table_varchar;
    
    BEGIN
        ts_rehab_presc.upd(id_rehab_presc_in       => i_id_rehab_presc,
                           id_exec_institution_in  => i_id_institution,
                           id_exec_institution_nin => FALSE,
                           rows_out                => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'UPDATE_EXEC_INSTITUTION',
                                              o_error    => o_error);
            RETURN FALSE;
    END update_exec_institution;

    /**********************************************************************************************
    * Returns the information about schedule needs and requested/ongoing treatments
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient id
    * %param i_id_episode             current episode
    * %param o_treat                  list of treatments
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Nuno Neves
    * @version                        2.6.1.1
    * @since                          2011-06-14
    **********************************************************************************************/
    FUNCTION get_rehab_treatment_referral
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        i_id_episode IN rehab_plan.id_episode_origin%TYPE,
        o_treat      OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_TREATMENT_REFERRAL';
        l_id_schedule  rehab_schedule.id_schedule%TYPE;
        l_id_epis_type episode.id_epis_type%TYPE;
        l_prof_cat     category.id_category%TYPE;
        l_all_epis     table_number;
    
        l_id_episode_origin rehab_plan.id_episode_origin%TYPE;
    
    BEGIN
        g_error := 'BEGIN i_id_patient=' || i_id_patient;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
    
        g_error    := 'Call pk_prof_utils.get_categoyr i_prof.id=' || i_prof.id;
        l_prof_cat := pk_prof_utils.get_id_category(i_lang => i_lang, i_prof => i_prof);
    
        g_error := 'Before get_origin_episode';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        -- precisa-se do episódio de origem
        IF NOT get_origin_episode(i_lang              => i_lang,
                                  i_prof              => i_prof,
                                  i_id_episode        => i_id_episode,
                                  i_id_schedule       => NULL,
                                  o_id_episode_origin => l_id_episode_origin,
                                  o_id_schedule       => l_id_schedule,
                                  o_id_epis_type      => l_id_epis_type,
                                  o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        -- para os assistentes sociais poderem ver o deep_nav da reabilitação
        g_error := 'L_ALL_EPIS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        SELECT DISTINCT (id_episode)
          BULK COLLECT
          INTO l_all_epis
          FROM episode epis
         WHERE epis.id_visit = pk_episode.get_id_visit(i_id_episode);
    
        g_error := 'TREATMENTS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_treat FOR
            SELECT *
              FROM (SELECT x.id_intervention, --
                           pk_procedures_api_db.get_alias_translation(i_lang, i_prof, x.code_intervention, NULL) AS desc_procedure, --
                           get_rehab_area_name(i_lang, x.id_rehab_area) AS desc_area, --
                           pk_date_utils.dt_chr_date_hour_tsz(i_lang, rp.dt_rehab_presc, i_prof) AS date_req, --
                           rp.flg_status AS proc_status,
                           rsn.sessions AS total_sessions,
                           (SELECT COUNT(*)
                              FROM rehab_session r
                             WHERE r.id_rehab_presc = rp.id_rehab_presc) AS num_sessions
                      FROM rehab_presc rp
                      JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) x
                        ON x.id_rehab_area_interv = rp.id_rehab_area_interv
                      JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                      JOIN rehab_session_type rst
                        ON rsn.id_rehab_session_type = rst.id_rehab_session_type
                      LEFT JOIN institution ins
                        ON (rp.id_exec_institution = ins.id_institution)
                     WHERE ((rsn.id_episode_origin = l_id_episode_origin AND l_prof_cat <> 25) OR
                           (rsn.id_episode_origin IN ((SELECT column_value
                                                         FROM TABLE(l_all_epis))) AND l_prof_cat = 25))
                       AND rsn.flg_status <> g_rehab_sch_need_dummy
                    UNION ALL
                    -- JB 2011-05-13 Executions of treatments not prescribed
                    SELECT i.id_intervention, --
                           pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) AS desc_procedure, --
                           get_rehab_area_name(i_lang, rai.id_rehab_area) AS desc_area, ---
                           pk_date_utils.dt_chr_date_hour_tsz(i_lang, rp.dt_rehab_presc, i_prof) AS date_req, --
                           rp.flg_status AS proc_status,
                           1 AS total_sessions,
                           1 AS num_sessions
                      FROM rehab_presc rp
                      JOIN rehab_sch_need rsn
                        ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                      JOIN rehab_area_interv rai
                        ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                      JOIN intervention i
                        ON i.id_intervention = rai.id_intervention
                      LEFT JOIN rehab_session_type rst
                        ON (rst.id_rehab_session_type = rsn.id_rehab_session_type)
                      LEFT JOIN institution ins
                        ON (rp.id_exec_institution = ins.id_institution)
                     WHERE rsn.flg_status = g_rehab_sch_need_dummy --dummy sch_need for treatments without instructions
                       AND EXISTS (SELECT 0
                              FROM rehab_session rs
                             WHERE rs.id_rehab_presc = rp.id_rehab_presc
                               AND rs.id_episode = i_id_episode -- show execution of treatments not prescribed just for current episode
                            )) t;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_patient=' || i_id_patient || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_types.open_cursor_if_closed(o_treat);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_treatment_referral;

    /**********************************************************************************************
    * Returns the information about the status of a appointment considering if the patient is a contact
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient id
    * %param i_flg_status             appointment status
    *
    * @return                         the status
    *
    * @author                         Elisabete Bugalho
    * @version                        2.6.1.1
    * @since                          2011-12-16
    **********************************************************************************************/

    FUNCTION get_rehab_app_status
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN patient.id_patient%TYPE,
        i_flg_status IN rehab_epis_encounter.flg_status%TYPE
    ) RETURN VARCHAR2 IS
    
        l_is_contact VARCHAR2(1 CHAR);
    BEGIN
        l_is_contact := pk_adt.is_contact(i_lang, i_prof, i_id_patient);
        IF l_is_contact = pk_alert_constant.g_yes
           AND (i_flg_status IS NULL OR i_flg_status = g_rehab_epis_enc_status_a)
        THEN
            RETURN g_temporary_patient;
        ELSE
        
            RETURN nvl(i_flg_status, g_rehab_epis_enc_status_a);
        END IF;
    END get_rehab_app_status;

    /**********************************************************************************************
    * Returns the information about all rehab treats
    *
    * %param i_lang                   id_language
    * %param i_prof                   id_professional
    * %param i_id_patient             patient id
    * %param o_treat                  list of treatments
    * %param o_error                  error message
    *
    * @return                         TRUE on success, FALSE otherwise
    *
    * @author                         Nuno Neves
    * @version                        2.6.1.1
    * @since                          2012-02-10
    **********************************************************************************************/
    FUNCTION get_rehab_all_treat
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        o_treat      OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_REHAB_ALL_TREAT';
        l_has_notes sys_message.desc_message%TYPE;
        l_type_treatment CONSTANT VARCHAR2(30) := 'T';
    BEGIN
    
        l_has_notes := pk_message.get_message(i_lang, i_prof, 'COMMON_M097');
    
        g_error := 'TREATMENTS';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        OPEN o_treat FOR
            SELECT *
              FROM (SELECT l_type_treatment AS rec_type,
                           rp.id_rehab_presc,
                           x.id_rehab_area_interv,
                           x.id_intervention,
                           pk_procedures_api_db.get_alias_translation(i_lang, i_prof, x.code_intervention, NULL) desc_interv,
                           pk_rehab.get_rehab_area_name(i_lang, x.id_rehab_area) desc_area,
                           x.id_rehab_area,
                           pk_prof_utils.get_nickname(i_lang, rp.id_professional) prof_requested,
                           rp.id_professional id_prof_requested,
                           pk_date_utils.dt_chr_date_hour_tsz(i_lang, rp.dt_rehab_presc, i_prof) dt_requested_str,
                           rp.dt_rehab_presc dt_requested,
                           pk_rehab.get_rp_icon(i_lang, NULL, rsn.id_rehab_sch_need, rsn.sessions, rp.flg_status) icon,
                           pk_rehab.get_rp_icon_label(i_lang, rp.id_rehab_presc, rsn.sessions, rp.flg_status) AS icon_label,
                           rp.flg_status,
                           --x.id_exec_institution,
                           rp.id_exec_institution,
                           pk_rehab.get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) AS instructions,
                           nvl2(rp.notes, l_has_notes, NULL) AS has_notes,
                           rp.notes AS notes,
                           pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', rp.flg_status, i_lang) flg_status_description,
                           pk_translation.get_translation(i_lang, rst.code_rehab_session_type) session_type,
                           decode(ins.abbreviation,
                                  NULL,
                                  pk_translation.get_translation(i_lang, ins.code_institution),
                                  ins.abbreviation) execution_local,
                           pk_prof_utils.get_name(i_lang, rp.id_professional) prof_name_requested,
                           pk_prof_utils.get_spec_signature(i_lang,
                                                            i_prof,
                                                            rp.id_professional,
                                                            rp.dt_rehab_presc,
                                                            rsn.id_episode_origin) prof_speciality_requested,
                           pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, rp.id_cancel_reason) cancel_reason_desc,
                           rp.notes_cancel cancel_reason_notes,
                           pk_message.get_message(i_lang, 'DETAIL_COMMON_M006') label_cancel_reason,
                           pk_message.get_message(i_lang, 'COMMON_M073') label_reason_notes,
                           pk_ehr_common.get_visit_name_by_epis(i_lang,
                                                                i_prof,
                                                                pk_episode.get_epis_type(i_lang, rsn.id_episode_origin)) desc_epis_type,
                           pk_ehr_common.get_visit_type_by_epis(i_lang,
                                                                i_prof,
                                                                rsn.id_episode_origin,
                                                                pk_episode.get_epis_type(i_lang, rsn.id_episode_origin),
                                                                '; ') desc_epis,
                           pk_prof_utils.get_nickname(i_lang, rp.id_professional) prof_order,
                           pk_date_utils.date_char_hour_tsz(i_lang,
                                                            rp.dt_rehab_presc,
                                                            i_prof.institution,
                                                            i_prof.software) hour_target,
                           pk_date_utils.dt_chr_tsz(i_lang, rp.dt_rehab_presc, i_prof.institution, i_prof.software) date_target
                      FROM rehab_presc rp
                      JOIN TABLE(pk_rehab.find_rehab_interv(i_prof.institution, i_prof.software)) x
                        ON x.id_rehab_area_interv = rp.id_rehab_area_interv
                      JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                      JOIN rehab_session_type rst
                        ON rsn.id_rehab_session_type = rst.id_rehab_session_type
                      LEFT JOIN institution ins
                        ON (rp.id_exec_institution = ins.id_institution)
                      JOIN episode epis
                        ON epis.id_episode = rsn.id_episode_origin
                      JOIN visit v
                        ON v.id_visit = epis.id_visit
                     WHERE v.id_patient = i_id_patient
                       AND EXISTS (SELECT 1
                              FROM rehab_session n
                             WHERE n.id_rehab_presc = rp.id_rehab_presc
                               AND n.flg_status = pk_rehab.g_rehab_session_executed)
                    UNION ALL
                    -- JB 2011-05-13 Executions of treatments not prescribed
                    SELECT l_type_treatment AS rec_type,
                           rp.id_rehab_presc,
                           rp.id_rehab_area_interv,
                           i.id_intervention,
                           pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) AS desc_interv,
                           pk_rehab.get_rehab_area_name(i_lang, rai.id_rehab_area) desc_area,
                           rai.id_rehab_area,
                           pk_prof_utils.get_nickname(i_lang, rp.id_professional) prof_requested,
                           rp.id_professional id_prof_requested,
                           pk_date_utils.dt_chr_date_hour_tsz(i_lang, rp.dt_rehab_presc, i_prof) dt_requested_str,
                           rp.dt_rehab_presc dt_requested,
                           pk_rehab.get_rp_icon(i_lang, NULL, rsn.id_rehab_sch_need, rsn.sessions, rp.flg_status) icon,
                           pk_rehab.get_rp_icon_label(i_lang, rp.id_rehab_presc, rsn.sessions, rp.flg_status) AS icon_label,
                           rp.flg_status,
                           rp.id_exec_institution,
                           pk_rehab.get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) AS instructions,
                           nvl2(rp.notes, l_has_notes, NULL) AS has_notes,
                           rp.notes AS notes,
                           pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', rp.flg_status, i_lang) flg_status_description,
                           pk_translation.get_translation(i_lang, rst.code_rehab_session_type) session_type,
                           decode(ins.abbreviation,
                                  NULL,
                                  pk_translation.get_translation(i_lang, ins.code_institution),
                                  ins.abbreviation) execution_local,
                           pk_prof_utils.get_name(i_lang, rp.id_professional) prof_name_requested,
                           pk_prof_utils.get_spec_signature(i_lang,
                                                            i_prof,
                                                            rp.id_professional,
                                                            rp.dt_rehab_presc,
                                                            rsn.id_episode_origin) prof_speciality_requested,
                           pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, rp.id_cancel_reason) cancel_reason_desc,
                           rp.notes_cancel cancel_reason_notes,
                           pk_message.get_message(i_lang, 'DETAIL_COMMON_M006') label_cancel_reason,
                           pk_message.get_message(i_lang, 'COMMON_M073') label_reason_notes,
                           pk_ehr_common.get_visit_name_by_epis(i_lang,
                                                                i_prof,
                                                                pk_episode.get_epis_type(i_lang, rsn.id_episode_origin)) desc_epis_type,
                           pk_ehr_common.get_visit_type_by_epis(i_lang,
                                                                i_prof,
                                                                rsn.id_episode_origin,
                                                                pk_episode.get_epis_type(i_lang, rsn.id_episode_origin),
                                                                '; ') desc_epis,
                           pk_prof_utils.get_nickname(i_lang, rp.id_professional) prof_order,
                           pk_date_utils.date_char_hour_tsz(i_lang,
                                                            rp.dt_rehab_presc,
                                                            i_prof.institution,
                                                            i_prof.software) hour_target,
                           pk_date_utils.dt_chr_tsz(i_lang, rp.dt_rehab_presc, i_prof.institution, i_prof.software) date_target
                      FROM rehab_presc rp
                      JOIN rehab_sch_need rsn
                        ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                      JOIN rehab_area_interv rai
                        ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                      JOIN intervention i
                        ON i.id_intervention = rai.id_intervention
                      LEFT JOIN rehab_session_type rst
                        ON (rst.id_rehab_session_type = rsn.id_rehab_session_type)
                      LEFT JOIN institution ins
                        ON (rp.id_exec_institution = ins.id_institution)
                      JOIN episode epis
                        ON epis.id_episode = rsn.id_episode_origin
                      JOIN visit v
                        ON v.id_visit = epis.id_visit
                     WHERE v.id_patient = i_id_patient
                       AND rsn.flg_status = pk_rehab.g_rehab_sch_need_dummy --dummy sch_need for treatments without instructions
                       AND EXISTS (SELECT 1
                              FROM rehab_session n
                             WHERE n.id_rehab_presc = rp.id_rehab_presc
                               AND n.flg_status = pk_rehab.g_rehab_session_executed)
                       AND EXISTS (SELECT 0
                              FROM rehab_session rs
                             WHERE rs.id_rehab_presc = rp.id_rehab_presc
                               AND rs.id_episode = epis.id_episode) -- show execution of treatments not prescribed just for current episode
                    ) t
             ORDER BY decode(t.flg_status,
                             pk_rehab.g_rehab_presc_cancel,
                             10,
                             pk_rehab.g_rehab_presc_discontinued,
                             20,
                             pk_rehab.g_rehab_presc_disc_prop,
                             20,
                             pk_rehab.g_rehab_presc_finished,
                             30,
                             pk_rehab.g_rehab_presc_suspend,
                             40,
                             pk_rehab.g_rehab_presc_susp_prop,
                             40,
                             pk_rehab.g_rehab_presc_ongoing,
                             50,
                             pk_rehab.g_rehab_presc_begin,
                             60,
                             100) DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_treat);
            pk_alertlog.log_error('get_rehab_treatment_plan Parameters: i_id_patient=' || i_id_patient || ' @' ||
                                  g_error,
                                  g_package_name,
                                  l_func_name);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_rehab_all_treat;

    /**********************************************************************************************
    * Returns the information for the external prescriptions popup (if more than one for the same 
    * kind of codification).
    *
    * @param i_lang                ID language
    * @param i_prof                Professional
    * @param i_episode             Episode ID
    * @param i_id_rehab_presc      Prescription ID
    * @param o_show                Show popup?
    * @param o_messages            Titles and messages
    * @param o_interv              Cursor with the procedures
    * @param o_error               Error
    *
    * @return                      True on success, false otherwise
    *                        
    * @author                      Joana Barroso
    * @version                     2.6.1.10
    * @since                       2012/08/16
    **********************************************************************************************/
    FUNCTION get_external_req
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        o_show           OUT VARCHAR2,
        o_messages       OUT pk_types.cursor_type,
        o_rehab          OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_rehab IS
            SELECT DISTINCT i.id_intervention,
                            rp.id_rehab_presc,
                            pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) desc_interv,
                            rp.id_codification id_codification,
                            rp.id_institution id_exec_institution,
                            pk_utils.get_institution_name(i_lang, rp.id_institution) exec_institution,
                            pk_prof_utils.get_name(i_lang, rp.id_professional) prof_requested,
                            rp.flg_laterality flg_laterality,
                            pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', i.id_intervention) flg_laterality_mcdt,
                            get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need) instructions,
                            get_rehab_area_name(i_lang, x.id_rehab_area) desc_area,
                            rsn.flg_priority flg_priority
              FROM rehab_area_interv rai
              JOIN rehab_presc rp
                ON rp.id_rehab_area_interv = rai.id_rehab_area_interv
              JOIN rehab_presc_hist rph
                ON rph.id_rehab_presc = rp.id_rehab_presc
              JOIN intervention i
                ON rai.id_intervention = i.id_intervention
              JOIN (SELECT a.id_codification, a.id_institution
                      FROM rehab_presc a
                     WHERE a.id_rehab_presc = i_id_rehab_presc
                       AND a.flg_status = 'X') t
                ON (t.id_institution = rp.id_institution AND rp.id_codification = t.id_codification)
              JOIN rehab_sch_need rsn
                ON (rsn.id_rehab_sch_need = rp.id_rehab_sch_need)
              JOIN TABLE(find_rehab_interv(i_prof.institution, i_prof.software)) x
                ON x.id_rehab_area_interv = rp.id_rehab_area_interv
             WHERE rp.flg_status = 'X'
               AND rsn.id_episode_origin = i_episode
               AND nvl(rp.flg_referral, 'A') = 'A';
    
        r_rehab c_rehab%ROWTYPE;
    
    BEGIN
        o_show := pk_alert_constant.g_no;
    
        OPEN c_rehab;
        FETCH c_rehab
            INTO r_rehab;
    
        IF NOT c_rehab%FOUND
        THEN
            pk_types.open_my_cursor(o_messages);
            pk_types.open_my_cursor(o_rehab);
            CLOSE c_rehab;
            RETURN TRUE;
        ELSE
            o_show := pk_alert_constant.g_yes;
            DELETE tbl_temp;
            LOOP
                INSERT INTO tbl_temp
                    (num_1, num_2, num_3, num_4, vc_1, vc_2, vc_3, vc_4, vc_5, vc_6, vc_7, vc_8)
                VALUES
                    (r_rehab.id_intervention,
                     r_rehab.id_rehab_presc,
                     r_rehab.id_codification,
                     r_rehab.id_exec_institution,
                     --r_rehab.codification,
                     r_rehab.flg_priority,
                     r_rehab.desc_interv,
                     r_rehab.prof_requested,
                     r_rehab.exec_institution,
                     r_rehab.flg_laterality,
                     r_rehab.flg_laterality_mcdt,
                     r_rehab.instructions,
                     r_rehab.desc_area);
            
                FETCH c_rehab
                    INTO r_rehab;
                EXIT WHEN c_rehab%NOTFOUND;
            END LOOP;
            CLOSE c_rehab;
        END IF;
    
        OPEN o_rehab FOR
            SELECT num_1 id_intervention,
                   num_2 id_rehab_presc,
                   num_3 id_codification,
                   pk_translation.get_translation(i_lang, 'CODIFICATION.CODE_CODIFICATION.' || num_3) codification,
                   vc_2 desc_interv,
                   num_4 id_exec_institution,
                   vc_4 exec_institution,
                   NULL id_mcdt_codification,
                   vc_5 flg_laterality,
                   pk_sysdomain.get_domain('REHAB_PRESC.FLG_LATERALITY', vc_5, i_lang) desc_laterality,
                   vc_6 flg_laterality_mcdt,
                   vc_3 prof_requested,
                   vc_7 instructions,
                   vc_8 desc_area,
                   vc_1 flg_priority
              FROM tbl_temp;
    
        OPEN o_messages FOR
            SELECT pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T062') title,
                   pk_message.get_message(i_lang, i_prof, 'PROCEDURES_M004') main,
                   pk_message.get_message(i_lang, i_prof, 'PROCEDURES_M005') info,
                   pk_message.get_message(i_lang, i_prof, 'COMMON_M025') cancel,
                   pk_message.get_message(i_lang, i_prof, 'COMMON_M087') confirm
              FROM dual;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error_in t_error_in := t_error_in();
                l_ret      BOOLEAN;
            BEGIN
                l_error_in.set_errors(SQLCODE, SQLERRM, g_error);
                l_error_in.set_lang(i_lang);
                l_error_in.set_package_id('ALERT', 'PK_REHAB', 'GET_EXTERNAL_REQ');
                l_ret := pk_alert_exceptions.process_error(l_error_in, o_error);
            
                pk_types.open_my_cursor(o_messages);
                pk_types.open_my_cursor(o_rehab);
            
                RETURN FALSE;
            END;
    END get_external_req;
    /**********************************************************************************************
    * Returns Institutions for rehab prescriptions  
    *
    * @param i_lang                ID language
    * @param i_prof                Professional
    * @param i_intervs             Array of requested Interventions
    * @param o_inst                Cursor with institutions
    * @param o_error               Error
    *
    * @return                      True on success, false otherwise
    *                        
    * @author                      Joana Barroso
    * @version                     2.6.3.5
    * @since                       2013/05/18
    **********************************************************************************************/

    FUNCTION get_rehab_inst
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_intervs IN table_number,
        o_inst    OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_inst pk_types.cursor_type;
    
        l_id_institution           institution.id_institution%TYPE;
        l_institution_name         pk_translation.t_desc_translation;
        l_institution_abbreviation institution.abbreviation%TYPE;
    
        l_default VARCHAR2(1 CHAR);
    
    BEGIN
    
        IF NOT pk_p1_interv.get_interv_inst(i_lang    => i_lang,
                                            i_prof    => i_prof,
                                            i_intervs => i_intervs,
                                            o_inst    => l_inst,
                                            o_error   => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        DELETE tbl_temp;
    
        INSERT INTO tbl_temp
            (num_1, num_2, vc_1, vc_2, vc_3)
            SELECT /*+opt_estimate(table t rows=1)*/
             i_prof.institution,
             10,
             pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
             pk_alert_constant.g_yes,
             'I'
              FROM TABLE(i_intervs) t,
                   (SELECT rai.id_intervention
                      FROM rehab_inst_soft ris
                      JOIN rehab_area_interv rai
                        ON ris.id_rehab_area_interv = rai.id_rehab_area_interv
                     WHERE ris.flg_add_remove = 'A'
                       AND ris.id_institution = i_prof.institution
                       AND ris.id_software = i_prof.software
                       AND ris.flg_execute = pk_alert_constant.g_yes) rai
             WHERE rai.id_intervention = t.column_value;
    
        IF SQL%ROWCOUNT = 0
        THEN
            l_default := pk_alert_constant.g_yes;
        ELSE
            l_default := pk_alert_constant.g_no;
        END IF;
    
        LOOP
            FETCH l_inst
                INTO l_id_institution, l_institution_name, l_institution_abbreviation;
            EXIT WHEN l_inst%NOTFOUND;
        
            IF l_id_institution = pk_sysconfig.get_config('REF_EXTERNAL_INST', i_prof)
               AND l_default = pk_alert_constant.g_yes
            THEN
                l_default := pk_alert_constant.g_yes;
            ELSE
                l_default := pk_alert_constant.g_no;
            END IF;
        
            INSERT INTO tbl_temp
                (num_1, num_2, vc_1, vc_2, vc_3)
            VALUES
                (l_id_institution, 20, l_institution_name, l_default, 'I');
        END LOOP;
        CLOSE l_inst;
    
        g_error := 'GET CURSOR';
        OPEN o_inst FOR
            SELECT DISTINCT data, rank, label, flg_default, flg_type
              FROM (SELECT num_1 data, num_2 rank, vc_1 label, vc_2 flg_default, vc_3 flg_type
                      FROM tbl_temp)
             ORDER BY rank, label;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_REHAB_INST',
                                              o_error);
            pk_types.open_my_cursor(o_inst);
            RETURN FALSE;
    END get_rehab_inst;

    FUNCTION get_rehab_inst
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_intervs IN VARCHAR2,
        i_default IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN t_tbl_core_domain IS
    
        l_inst pk_types.cursor_type;
    
        l_intervs table_number;
    
        l_id_institution           institution.id_institution%TYPE;
        l_institution_name         pk_translation.t_desc_translation;
        l_institution_abbreviation institution.abbreviation%TYPE;
    
        l_default VARCHAR2(1 CHAR);
    
        l_ret   t_tbl_core_domain;
        l_error t_error_out;
    
    BEGIN
    
        l_intervs := pk_utils.str_split_n(i_list => i_intervs, i_delim => '|');
    
        IF NOT pk_p1_interv.get_interv_inst(i_lang    => i_lang,
                                            i_prof    => i_prof,
                                            i_intervs => l_intervs,
                                            o_inst    => l_inst,
                                            o_error   => l_error)
        THEN
            RAISE g_exception;
        END IF;
    
        DELETE tbl_temp;
    
        INSERT INTO tbl_temp
            (num_1, num_2, vc_1, vc_2, vc_3)
            SELECT /*+opt_estimate(table t rows=1)*/
             i_prof.institution,
             10,
             pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
             pk_alert_constant.g_yes,
             'I'
              FROM TABLE(l_intervs) t,
                   (SELECT rai.id_intervention
                      FROM rehab_inst_soft ris
                      JOIN rehab_area_interv rai
                        ON ris.id_rehab_area_interv = rai.id_rehab_area_interv
                     WHERE ris.flg_add_remove = 'A'
                       AND ris.id_institution = i_prof.institution
                       AND ris.id_software = i_prof.software
                       AND ris.flg_execute = pk_alert_constant.g_yes) rai
             WHERE rai.id_intervention = t.column_value;
    
        IF SQL%ROWCOUNT = 0
        THEN
            l_default := pk_alert_constant.g_yes;
        ELSE
            l_default := pk_alert_constant.g_no;
        END IF;
    
        LOOP
            FETCH l_inst
                INTO l_id_institution, l_institution_name, l_institution_abbreviation;
            EXIT WHEN l_inst%NOTFOUND;
        
            IF l_id_institution = pk_sysconfig.get_config('REF_EXTERNAL_INST', i_prof)
               AND l_default = pk_alert_constant.g_yes
            THEN
                l_default := pk_alert_constant.g_yes;
            ELSE
                l_default := pk_alert_constant.g_no;
            END IF;
        
            INSERT INTO tbl_temp
                (num_1, num_2, vc_1, vc_2, vc_3)
            VALUES
                (l_id_institution, 20, l_institution_name, l_default, 'I');
        END LOOP;
        CLOSE l_inst;
    
        g_error := 'GET L_RET';
        SELECT t_row_core_domain(internal_name => NULL,
                                 desc_domain   => label,
                                 domain_value  => data,
                                 order_rank    => NULL,
                                 img_name      => NULL)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT DISTINCT data, rank, label, flg_default, flg_type
                  FROM (SELECT num_1 data, num_2 rank, vc_1 label, vc_2 flg_default, vc_3 flg_type
                          FROM tbl_temp)
                 ORDER BY rank, label)
         WHERE ((flg_default = pk_alert_constant.g_yes AND i_default = pk_alert_constant.g_yes) OR
               i_default = pk_alert_constant.g_no);
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_REHAB_INST',
                                              l_error);
            RETURN l_ret;
    END get_rehab_inst;

    FUNCTION update_rehab_presc
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_patient          IN rehab_plan.id_patient%TYPE,
        i_id_episode          IN episode.id_episode%TYPE,
        i_id_rehab_presc      IN rehab_presc.id_rehab_presc%TYPE,
        i_id_rehab_sch_need   IN rehab_presc.id_rehab_sch_need%TYPE,
        i_id_exec_institution IN rehab_presc.id_exec_institution%TYPE,
        i_exec_per_session    IN rehab_presc.exec_per_session%TYPE,
        i_presc_notes         IN rehab_presc.notes%TYPE,
        i_sessions            IN rehab_sch_need.sessions%TYPE,
        i_frequency           IN rehab_sch_need.frequency%TYPE,
        i_flg_frequency       IN rehab_sch_need.flg_frequency%TYPE,
        i_flg_priority        IN rehab_sch_need.flg_priority%TYPE,
        i_date_begin          IN VARCHAR2,
        i_session_notes       IN rehab_sch_need.notes%TYPE,
        i_session_type        IN rehab_sch_need.id_rehab_session_type%TYPE,
        i_flg_laterality      IN rehab_presc.flg_laterality%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'UPDATE_REHAB_PRESC';
        l_rowids table_varchar;
    
        l_id_rehab_sch_need rehab_presc.id_rehab_sch_need%TYPE;
        l_message           sys_message.desc_message%TYPE;
        l_code_interv       intervention.code_intervention%TYPE;
        l_interv            intervention.id_intervention%TYPE;
        l_id_change         rehab_presc_change.id_change%TYPE;
        l_id_episode_origin rehab_plan.id_episode_origin%TYPE;
        l_id_schedule       rehab_schedule.id_schedule%TYPE;
        l_id_epis_type      episode.id_epis_type%TYPE;
    BEGIN
    
        g_sysdate_tstz := systimestamp;
        l_message      := pk_message.get_message(i_lang, 'PROCEDURES_MFR_T109');
    
        IF NOT pk_rehab.get_origin_episode(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_id_episode        => i_id_episode,
                                           i_id_schedule       => NULL,
                                           o_id_episode_origin => l_id_episode_origin,
                                           o_id_schedule       => l_id_schedule,
                                           o_id_epis_type      => l_id_epis_type,
                                           o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        l_id_change := get_next_rp_id_change(i_id_rehab_presc);
        g_error     := 'call ts_rehab_presc_change.ins';
        ts_rehab_presc_change.ins(id_rehab_presc_in    => i_id_rehab_presc,
                                  id_change_in         => l_id_change,
                                  dt_change_in         => g_sysdate_tstz,
                                  flg_status_in        => g_rehab_presc_edit_prop, -- alteração de plano
                                  flg_status_change_in => g_rehab_presc_chg_proposal, -- proposta 
                                  id_prof_req_in       => i_prof.id,
                                  dt_req_in            => g_sysdate_tstz,
                                  notes_change_in      => i_presc_notes,
                                  handle_error_in      => FALSE,
                                  rows_out             => l_rowids);
    
        SELECT id_rehab_sch_need
          INTO l_id_rehab_sch_need
          FROM rehab_presc rp
         WHERE rp.id_rehab_presc = i_id_rehab_presc;
    
        g_error := 'cancel id_rehab_sch_need';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        IF NOT cancel_rehab_sch_need_nocommit(i_lang              => i_lang,
                                              i_prof              => i_prof,
                                              i_id_rehab_sch_need => l_id_rehab_sch_need,
                                              i_notes             => '',
                                              o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        pk_alertlog.log_debug('CREATE A NEW INSTRUCTIONS!');
        IF NOT check_rehab_plan(i_lang              => i_lang,
                                i_prof              => i_prof,
                                i_id_patient        => i_id_patient,
                                i_id_episode_origin => l_id_episode_origin,
                                i_commit            => pk_alert_constant.get_no(),
                                o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
        g_error             := 'call ts_rehab_sch_need.ins';
        l_id_rehab_sch_need := ts_rehab_sch_need.next_key();
        ts_rehab_sch_need.ins(id_rehab_sch_need_in     => l_id_rehab_sch_need,
                              id_episode_origin_in     => l_id_episode_origin,
                              sessions_in              => i_sessions,
                              frequency_in             => i_frequency,
                              flg_frequency_in         => i_flg_frequency,
                              flg_priority_in          => i_flg_priority,
                              dt_begin_in              => pk_date_utils.get_string_tstz(i_lang,
                                                                                        i_prof,
                                                                                        i_date_begin,
                                                                                        NULL),
                              flg_status_in            => g_rehab_sch_need_no_sched,
                              id_professional_in       => i_prof.id,
                              dt_rehab_sch_need_in     => g_sysdate_tstz,
                              id_rehab_session_type_in => i_session_type,
                              notes_in                 => i_session_notes,
                              rows_out                 => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_SCH_NEED',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        IF NOT set_rehab_sch_need_hist(i_lang              => i_lang,
                                       i_prof              => i_prof,
                                       i_id_rehab_sch_need => l_id_rehab_sch_need,
                                       i_commit            => pk_alert_constant.get_no(),
                                       o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'update i_id_rehab_presc=' || i_id_rehab_presc;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        ts_rehab_presc.upd(id_rehab_presc_in      => i_id_rehab_presc,
                           flg_status_in          => g_rehab_presc_edit_prop,
                           id_rehab_sch_need_in   => l_id_rehab_sch_need,
                           id_exec_institution_in => i_id_exec_institution,
                           exec_per_session_in    => i_exec_per_session,
                           exec_per_session_nin   => FALSE,
                           notes_in               => i_presc_notes,
                           notes_nin              => FALSE,
                           dt_rehab_presc_in      => g_sysdate_tstz,
                           id_professional_in     => i_prof.id,
                           flg_laterality_in      => i_flg_laterality,
                           rows_out               => l_rowids);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'REHAB_PRESC',
                                      i_rowids     => l_rowids,
                                      o_error      => o_error);
    
        g_error := 'create history in rehab_presc_hist for i_id_rehab_presc=' || i_id_rehab_presc;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
        IF NOT set_rehab_presc_hist(i_lang           => i_lang,
                                    i_prof           => i_prof,
                                    i_id_rehab_presc => i_id_rehab_presc,
                                    i_commit         => pk_alert_constant.get_no(),
                                    o_error          => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_id_episode_origin,
                                      i_pat                 => i_id_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_rehab_presc=' || i_id_rehab_presc || ' @' || g_error,
                                  g_package_name,
                                  l_func_name);
            pk_utils.undo_changes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END update_rehab_presc;

    /* *******************************************************************************************
    *  Get current state of clinical indication for rehabilitation for viewer checklist 
    *             
    * @param    i_lang           Language ID
    * @param    i_prof           Logged professional structure
    * @param    i_scope_type     Scope flag | 'P' - Patient, 'E' - Episode, 'V' - Visit 
    * @param    i_id_episode     Episode ID
    * @param    i_id_patient     Patient ID
    *
    * @return VARCHAR2  Viewer checklist status | 'N' - Not started , 'C' - Complete, 'O' - On going
    * 
    * @author                     
    * @version                    
    * @since                              
    **********************************************************************************************/
    FUNCTION get_vwr_clinical_rehab
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_scope_type IN VARCHAR2,
        i_id_episode IN episode.id_episode%TYPE,
        i_id_patient IN patient.id_patient%TYPE
    ) RETURN VARCHAR2 IS
        l_status            VARCHAR2(1 CHAR) := pk_viewer_checklist.g_checklist_not_started;
        l_id_episode_origin NUMBER;
        l_id_epis_type      NUMBER;
        l_id_schedule       NUMBER;
        l_count             NUMBER;
        l_bool              BOOLEAN;
        l_error             t_error_out;
    BEGIN
    
        -- only valid for current episode
        l_bool := pk_rehab.get_origin_episode(i_lang              => i_lang,
                                              i_prof              => i_prof,
                                              i_id_episode        => i_id_episode,
                                              i_id_schedule       => NULL,
                                              o_id_episode_origin => l_id_episode_origin,
                                              o_id_schedule       => l_id_schedule,
                                              o_id_epis_type      => l_id_epis_type,
                                              o_error             => l_error);
    
        IF l_bool
        THEN
        
            SELECT COUNT(*)
              INTO l_count
              FROM rehab_diagnosis rd
             WHERE rd.id_episode_origin = l_id_episode_origin
               AND rd.flg_status != pk_rehab.g_rehab_diag_flg_status_c;
        
            IF l_count > 0
            THEN
                l_status := pk_viewer_checklist.g_checklist_completed;
            END IF;
        
        END IF;
    
        RETURN l_status;
    
    END get_vwr_clinical_rehab;

    FUNCTION get_lock_description
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_presc     IN NUMBER,
        i_id_lock_main IN NUMBER
    ) RETURN VARCHAR2 IS
    
    BEGIN
    
        RETURN pk_message.get_message(i_lang => i_lang, i_code_mess => 'MOVEMENT_M001');
    
    END get_lock_description;

    FUNCTION inactivate_rehab_tasks
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_inst        IN institution.id_institution%TYPE,
        i_ids_exclude IN OUT table_number,
        o_has_error   OUT BOOLEAN,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_cancel_cfg sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'INACTIVATE_CANCEL_REASON',
                                                                      i_prof    => i_prof);
    
        l_descontinued_cfg sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'INACTIVATE_DISCONTINUED_REASON',
                                                                            i_prof    => i_prof);
    
        l_tbl_config t_tbl_config_table := pk_core_config.get_values_by_mkt_inst_sw(i_lang => NULL,
                                                                                    i_prof => profissional(0, i_inst, 0),
                                                                                    i_area => 'REHAB_INACTIVATE');
    
        l_cancel_id cancel_reason.id_cancel_reason%TYPE := pk_cancel_reason.get_id_by_content(i_lang,
                                                                                              i_prof,
                                                                                              l_cancel_cfg);
    
        l_descontinued_id cancel_reason.id_cancel_reason%TYPE := pk_cancel_reason.get_id_by_content(i_lang,
                                                                                                    i_prof,
                                                                                                    l_descontinued_cfg);
    
        l_max_rows sys_config.value%TYPE := pk_sysconfig.get_config(i_prof    => i_prof,
                                                                    i_code_cf => 'INACTIVATE_TASKS_MAX_NUMBER_ROWS');
    
        l_rehab_presc    table_number;
        l_rehab_sch_need table_number;
        l_final_status   table_varchar;
        l_tbl_session    table_number;
    
        l_msg       VARCHAR2(1000 CHAR);
        l_flg_show  VARCHAR2(2 CHAR);
        l_msg_title VARCHAR2(200 CHAR);
    
        l_error t_error_out;
        g_other_exception EXCEPTION;
    
        l_rehab_cancel NUMBER(24);
    
        l_tbl_error_ids table_number := table_number();
    
        --The cursor will not fetch the records for the ids (id_comm_order_req) sent in i_ids_exclude        
        CURSOR c_rehab_req(ids_exclude IN table_number) IS
            SELECT DISTINCT t.id_rehab_presc, t.field_04
              FROM (SELECT rp.id_rehab_presc, cfg.field_04
                      FROM rehab_session rs
                     INNER JOIN rehab_presc rp
                        ON rs.id_rehab_presc = rp.id_rehab_presc
                     INNER JOIN episode e
                        ON e.id_episode = rs.id_episode
                      LEFT JOIN episode prev_e
                        ON prev_e.id_prev_episode = e.id_episode
                       AND e.id_visit = prev_e.id_visit
                     INNER JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                 *
                                  FROM TABLE(l_tbl_config) t) cfg
                        ON cfg.field_01 = rp.flg_status
                     WHERE e.id_institution = i_inst
                       AND e.dt_end_tstz IS NOT NULL
                       AND (prev_e.id_episode IS NULL OR prev_e.flg_status = pk_alert_constant.g_inactive)
                       AND pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                            i_timestamp => (pk_date_utils.add_to_ltstz(i_timestamp => rs.dt_rehab_session,
                                                                                                       i_amount    => cfg.field_02,
                                                                                                       i_unit      => cfg.field_03))) <=
                           pk_date_utils.trunc_insttimezone(i_prof => i_prof, i_timestamp => current_timestamp)
                    
                    UNION ALL
                    
                    SELECT rp.id_rehab_presc, cfg.field_04
                      FROM rehab_presc rp
                     INNER JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                      LEFT JOIN rehab_schedule rsch
                        ON rsch.id_rehab_sch_need = rsn.id_rehab_sch_need
                     INNER JOIN episode e
                        ON e.id_episode = rsn.id_episode_origin
                      LEFT JOIN episode prev_e
                        ON prev_e.id_prev_episode = e.id_episode
                       AND e.id_visit = prev_e.id_visit
                     INNER JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                 *
                                  FROM TABLE(l_tbl_config) t) cfg
                        ON cfg.field_01 = rp.flg_status
                     WHERE e.id_institution = i_inst
                       AND e.dt_end_tstz IS NOT NULL
                       AND rsch.id_rehab_schedule IS NULL
                       AND (prev_e.id_episode IS NULL OR prev_e.flg_status = pk_alert_constant.g_inactive)
                       AND pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                            i_timestamp => (pk_date_utils.add_to_ltstz(i_timestamp => rsn.dt_rehab_sch_need,
                                                                                                       i_amount    => cfg.field_02,
                                                                                                       i_unit      => cfg.field_03))) <=
                           pk_date_utils.trunc_insttimezone(i_prof => i_prof, i_timestamp => current_timestamp)) t
              LEFT JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                          t.column_value
                           FROM TABLE(i_ids_exclude) t) t_ids
                ON t_ids.column_value = t.id_rehab_presc
             WHERE t_ids.column_value IS NULL
               AND rownum <= l_max_rows;
    
    BEGIN
    
        o_has_error := FALSE;
    
        OPEN c_rehab_req(i_ids_exclude);
        FETCH c_rehab_req BULK COLLECT
            INTO l_rehab_presc, l_final_status;
        CLOSE c_rehab_req;
    
        IF l_rehab_presc.count > 0
        THEN
            FOR i IN 1 .. l_rehab_presc.count
            LOOP
                BEGIN
                    SAVEPOINT init_cancel;
                
                    SELECT rs.id_rehab_session
                      BULK COLLECT
                      INTO l_tbl_session
                      FROM rehab_session rs
                     INNER JOIN rehab_presc rp
                        ON rp.id_rehab_presc = rs.id_rehab_presc
                     INNER JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                  *
                                   FROM TABLE(l_tbl_config) t) cfg
                        ON cfg.field_01 = rp.flg_status
                     WHERE rs.id_rehab_presc = l_rehab_presc(i)
                       AND rs.flg_status NOT IN (pk_rehab.g_rehab_session_executed,
                                                 pk_rehab.g_rehab_session_canceled,
                                                 pk_rehab.g_rehab_session_scheduled)
                       AND pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                            i_timestamp => (pk_date_utils.add_to_ltstz(i_timestamp => rs.dt_rehab_session,
                                                                                                       i_amount    => cfg.field_02,
                                                                                                       i_unit      => cfg.field_03))) <=
                           pk_date_utils.trunc_insttimezone(i_prof => i_prof, i_timestamp => current_timestamp);
                
                    IF l_tbl_session.count > 0
                    THEN
                        FOR j IN 1 .. l_tbl_session.count
                        LOOP
                            g_error := 'ERROR CALLING PK_REHAB.CANCEL_REHAB_SESSION FOR RECORD ' || l_rehab_presc(i);
                            IF NOT pk_rehab.cancel_rehab_session(i_lang             => i_lang,
                                                                 i_prof             => i_prof,
                                                                 i_id_rehab_session => table_number(l_tbl_session(j)),
                                                                 i_id_cancel_reason => l_cancel_id,
                                                                 o_error            => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        END LOOP;
                    END IF;
                
                    SELECT rsn.id_rehab_sch_need
                      BULK COLLECT
                      INTO l_rehab_sch_need
                      FROM rehab_sch_need rsn
                     INNER JOIN rehab_presc rp
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                     INNER JOIN rehab_epis_encounter ree
                        ON ree.id_episode_origin = rsn.id_episode_origin
                     WHERE ree.id_episode_rehab IN
                           (SELECT id_episode
                              FROM rehab_session rss
                             WHERE rss.id_rehab_presc = l_rehab_presc(i))
                       AND rsn.flg_status NOT IN
                           (g_rehab_sch_need_dummy, g_rehab_sch_need_no_sched, g_rehab_sch_need_scheduled);
                
                    IF l_rehab_sch_need.count > 0
                    THEN
                        FOR z IN 1 .. l_rehab_sch_need.count
                        LOOP
                            g_error := 'ERROR CALLING PK_REHAB.CANCEL_REHAB_SCH_NEED FOR RECORD ' || l_rehab_presc(i);
                            IF NOT pk_rehab.cancel_rehab_sch_need(i_lang              => i_lang,
                                                                  i_prof              => i_prof,
                                                                  i_id_rehab_sch_need => l_rehab_sch_need(i),
                                                                  i_id_cancel_reason  => l_cancel_id,
                                                                  o_error             => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        END LOOP;
                    END IF;
                
                    SELECT COUNT(*)
                      INTO l_rehab_cancel
                      FROM rehab_session a
                     WHERE a.id_rehab_presc = l_rehab_presc(i)
                       AND a.flg_status != 'W';
                
                    IF l_rehab_cancel = 0
                    THEN
                        IF l_final_status(i) = pk_rehab.g_rehab_presc_cancel
                        THEN
                            g_error := 'ERROR CALLING PK_REHAB.CANCEL_REHAB_PRESC FOR RECORD ' || l_rehab_presc(i);
                            IF NOT pk_rehab.cancel_rehab_presc(i_lang             => i_lang,
                                                               i_prof             => i_prof,
                                                               i_id_rehab_presc   => table_number(l_rehab_presc(i)),
                                                               i_id_cancel_reason => l_cancel_id,
                                                               i_flg_auto_cancel  => pk_alert_constant.g_yes,
                                                               i_flg_commit       => pk_alert_constant.g_no,
                                                               o_error            => o_error)
                            
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        
                        ELSIF l_final_status(i) = pk_rehab.g_rehab_presc_discontinued
                        THEN
                            g_error := 'ERROR CALLING PK_REHAB.CANCEL_REHAB_PRESC FOR RECORD ' || l_rehab_presc(i);
                            IF NOT pk_rehab.cancel_rehab_presc(i_lang             => i_lang,
                                                               i_prof             => i_prof,
                                                               i_id_rehab_presc   => table_number(l_rehab_presc(i)),
                                                               i_id_cancel_reason => l_descontinued_id,
                                                               i_flg_discontinue  => pk_alert_constant.g_yes,
                                                               i_flg_auto_cancel  => pk_alert_constant.g_yes,
                                                               i_flg_commit       => pk_alert_constant.g_no,
                                                               o_error            => o_error)
                            
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        END IF;
                    END IF;
                
                EXCEPTION
                    WHEN OTHERS THEN
                        ROLLBACK TO init_cancel;
                    
                        --If, for the given id_comm_order_req, an error is generated, o_has_error is set as TRUE,
                        --this way, the loop cicle may continue, but the system will know that at least one error has happened
                        o_has_error := TRUE;
                    
                        --A log for the id_comm_order_req that raised the error must be generated 
                        pk_alert_exceptions.reset_error_state;
                        pk_alert_exceptions.process_error(i_lang,
                                                          SQLCODE,
                                                          SQLERRM,
                                                          g_error,
                                                          'ALERT',
                                                          g_package_name,
                                                          'INACTIVATE_REHAB_TASKS',
                                                          o_error);
                    
                        --The array for the ids (id_comm_order_req) that raised the error is incremented
                        l_tbl_error_ids.extend();
                        l_tbl_error_ids(l_tbl_error_ids.count) := l_rehab_presc(i);
                    
                        CONTINUE;
                END;
            END LOOP;
        
            --When the number of error ids match the max number of rows that can be processed for each call,
            --it means that no id_rehab_presc has been inactivated.
            --The next time the Job would be executed, the cursor would fetch the same set fetched on the previous call,
            --and therefore, from this point on, no more records would be inactivated.
            IF l_tbl_error_ids.count = l_max_rows
            THEN
                FOR i IN l_tbl_error_ids.first .. l_tbl_error_ids.last
                LOOP
                    --i_ids_exclude is an IN OUT parameter, and is incremented with the ids (id_rehab_presc) that could not
                    --be inactivated with the current call of the function
                    i_ids_exclude.extend();
                    i_ids_exclude(i_ids_exclude.count) := l_tbl_error_ids(i);
                END LOOP;
            
                --Since no inactivations were performed with the current call, a new call to this function is performed,
                --however, this time, the array i_ids_exclude will include a list of ids that cannot be fetched by the cursor
                --on the next call. The recursion will be perfomed until at least one record is inactivated, or the cursor
                --has no more records to fetch.
                --Note: i_ids_exclude is incremented and is an IN OUT parameter, therefore, 
                --it will hold all the ids that were not inactivated from ALL calls.            
                IF NOT pk_rehab.inactivate_rehab_tasks(i_lang        => i_lang,
                                                       i_prof        => i_prof,
                                                       i_inst        => i_inst,
                                                       i_ids_exclude => i_ids_exclude,
                                                       o_has_error   => o_has_error,
                                                       o_error       => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'INACTIVATE_REHAB_TASKS',
                                              l_error);
            RETURN FALSE;
    END inactivate_rehab_tasks;

    FUNCTION get_cross_actions_permissions
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_subject     IN action.subject%TYPE,
        i_from_state  IN table_varchar,
        i_task_type   IN task_type.id_task_type%TYPE,
        i_rehab_presc IN table_number,
        o_actions     OUT pk_types.cursor_type,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_scheduled NUMBER := 0;
    
        l_from_state          table_varchar;
        l_id_category         NUMBER;
        l_id_profile_template profile_template.id_profile_template%TYPE;
    BEGIN
    
        g_error := 'Check if task is already scheduled';
        SELECT COUNT(*)
          INTO l_scheduled
          FROM rehab_sch_need rsn
          JOIN rehab_presc rp
            ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
         WHERE rp.id_rehab_presc IN (SELECT *
                                       FROM TABLE(i_rehab_presc))
           AND rsn.flg_status = g_rehab_sch_need_scheduled;
    
        g_error               := 'Filter duplicates';
        l_from_state          := SET(i_from_state);
        l_id_category         := pk_prof_utils.get_id_category(i_lang, i_prof);
        l_id_profile_template := pk_prof_utils.get_prof_profile_template(i_prof);
    
        g_error := 'GET CURSOR o_actions';
        OPEN o_actions FOR
            SELECT MIN(id_action) id_action,
                   id_parent,
                   l AS "LEVEL",
                   to_state,
                   desc_action,
                   icon,
                   flg_default,
                   MAX(flg_active) flg_active,
                   action,
                   MIN(rank) rank
              FROM (SELECT act.id_action,
                           act.id_parent,
                           act.l,
                           act.to_state,
                           act.desc_action,
                           act.icon,
                           act.flg_default,
                           act.flg_active,
                           act.action,
                           act.from_state,
                           act.rank,
                           rank() over(ORDER BY ap.id_institution DESC, ap.id_software DESC NULLS LAST) origin_rank
                      FROM (SELECT a.id_action,
                                   a.id_parent,
                                   LEVEL AS l,
                                   a.to_state,
                                   pk_message.get_message(i_lang, i_prof, a.code_action) desc_action,
                                   a.icon,
                                   decode(flg_default,
                                          pk_action.g_flg_default,
                                          pk_alert_constant.g_yes,
                                          pk_alert_constant.g_no) flg_default,
                                   decode(a.to_state, 'B', decode(l_scheduled, 0, a.flg_status, 'I'), a.flg_status) AS flg_active,
                                   a.internal_name action,
                                   a.from_state,
                                   a. rank
                              FROM action a
                             WHERE subject = i_subject
                               AND from_state IN (SELECT *
                                                    FROM TABLE(l_from_state))
                            CONNECT BY PRIOR a.id_action = a.id_parent
                             START WITH a.id_parent IS NULL) act
                     INNER JOIN action_permission ap
                        ON ap.id_action = act.id_action
                     WHERE ap.id_profile_template = l_id_profile_template
                       AND ap.id_institution IN (0, i_prof.institution)
                       AND ap.id_software IN (0, i_prof.software)
                       AND ap.id_task_type = i_task_type
                       AND ap.id_category = l_id_category)
             WHERE origin_rank = 1
             GROUP BY id_parent, l, to_state, desc_action, icon, flg_default, action
            HAVING COUNT(from_state) = (SELECT COUNT(*)
                                          FROM TABLE(table_varchar() MULTISET UNION DISTINCT l_from_state))
             ORDER BY "LEVEL", rank, desc_action;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_REHAB',
                                              'GET_CROSS_ACTIONS_PERMISSIONS',
                                              o_error);
            pk_types.open_my_cursor(o_actions);
            RETURN FALSE;
    END get_cross_actions_permissions;

    FUNCTION get_rehab_summary
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_id_pat  IN patient.id_patient%TYPE,
        i_episode IN episode.id_episode%TYPE,
        --request
        o_rehab_request      OUT pk_types.cursor_type,
        o_rehab_request_prof OUT pk_types.cursor_type,
        --
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        --
        l_temp_cur                pk_types.cursor_type;
        l_rehab_summary_view_type VARCHAR2(1 CHAR);
        l_category                category.flg_type%TYPE;
        --
    BEGIN
    
        -- get view type
        l_rehab_summary_view_type := pk_sysconfig.get_config(i_code_cf => 'SUMMARY_VIEW_ALL', i_prof => i_prof);
        l_category                := pk_prof_utils.get_category(i_lang, i_prof);
    
        g_error := 'CALL get_dietitian_requests_summary';
        IF NOT get_rehab_requests_summary(i_lang          => i_lang,
                                          i_prof          => i_prof,
                                          i_episode       => i_episode,
                                          o_requests      => o_rehab_request,
                                          o_requests_prof => o_rehab_request_prof,
                                          o_error         => o_error)
        THEN
            RAISE g_exception;
        END IF;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_rehab_request);
            pk_types.open_my_cursor(o_rehab_request_prof);
            -- Unexpected error
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     g_package_owner,
                                                     g_package_name,
                                                     'GET_REHAB_SUMMARY',
                                                     o_error);
        
    END get_rehab_summary;

    FUNCTION get_rehab_requests_summary
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        o_requests      OUT pk_types.cursor_type,
        o_requests_prof OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        t_table_message_array pk_paramedical_prof_core.table_message_array;
        l_label_any_prof      sys_message.desc_message%TYPE := pk_message.get_message(i_lang,
                                                                                      i_prof,
                                                                                      'CONSULT_REQUEST_T021');
    BEGIN
        g_error := 'GET_SOCIAL_REQUESTS_SUMMARY BEGIN';
        pk_alertlog.log_debug(g_error);
    
        IF get_rehab_epis_origin_type(i_lang, i_prof, i_episode) = 'R'
        THEN
            IF NOT pk_paramedical_prof_core.get_message_array(i_lang         => i_lang,
                                                              i_code_msg_arr => table_varchar('DIET_T009',
                                                                                              'CONSULT_REQUEST_T003',
                                                                                              'CONSULT_REQUEST_T024',
                                                                                              'CONSULT_REQUEST_T004',
                                                                                              'SCH_T004'),
                                                              i_prof         => i_prof,
                                                              o_desc_msg_arr => t_table_message_array)
            THEN
                RAISE g_exception;
            END IF;
        
            --
            g_error := 'OPEN o_requests';
            OPEN o_requests FOR
                SELECT o.id_opinion        id,
                       o.id_episode_answer id_episode,
                       --
                       pk_paramedical_prof_core.format_str_header_w_colon(t_table_message_array('CONSULT_REQUEST_T024')) ||
                       nvl((SELECT pk_translation.get_translation(i_lang, cs.code_clinical_service)
                             FROM clinical_service cs
                            WHERE cs.id_clinical_service = o.id_clinical_service),
                           pk_paramedical_prof_core.c_dashes) request_type,
                       --reason
                       pk_paramedical_prof_core.format_str_header_w_colon(t_table_message_array('CONSULT_REQUEST_T003')) ||
                       nvl(decode(o.id_opinion_type,
                                  pk_opinion.g_ot_case_manager,
                                  pk_opinion.get_cm_req_reason(i_lang, i_prof, o.id_opinion),
                                  o.desc_problem),
                           pk_paramedical_prof_core.c_dashes) request_reason,
                       --origin
                       pk_paramedical_prof_core.format_str_header_w_colon(t_table_message_array('CONSULT_REQUEST_T004')) ||
                       pk_translation.get_translation(i_lang, et.code_epis_type) || pk_opinion.g_dash ||
                       pk_prof_utils.get_spec_signature(i_lang, i_prof, o.id_prof_questions, NULL, o.id_episode) || ' (' ||
                       nvl(pk_prof_utils.get_name_signature(i_lang, i_prof, o.id_prof_questions),
                           pk_paramedical_prof_core.c_dashes) || ')' request_origin,
                       --profissional      
                       pk_paramedical_prof_core.format_str_header_w_colon(t_table_message_array('SCH_T004')) ||
                       nvl2(o.id_prof_questioned,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, o.id_prof_questioned),
                            l_label_any_prof) name_prof_request_type,
                       --notas
                       pk_paramedical_prof_core.format_str_header_w_colon(t_table_message_array('DIET_T009')) ||
                       nvl(o.notes, pk_paramedical_prof_core.c_dashes) prof_answers,
                       pk_paramedical_prof_core.get_ehr_last_update_info(i_lang,
                                                                         i_prof,
                                                                         o.dt_problem_tstz,
                                                                         op.id_professional,
                                                                         o.dt_last_update,
                                                                         o.id_episode) last_update_info
                  FROM opinion o
                  LEFT OUTER JOIN opinion_prof op
                    ON (o.id_opinion = op.id_opinion AND op.flg_type = 'E')
                  LEFT OUTER JOIN opinion_type ot
                    ON ot.id_opinion_type = o.id_opinion_type
                  LEFT OUTER JOIN episode e
                    ON e.id_episode = o.id_episode
                  LEFT OUTER JOIN epis_type et
                    ON et.id_epis_type = e.id_epis_type
                  LEFT OUTER JOIN clinical_service cs
                    ON cs.id_clinical_service = o.id_clinical_service
                 WHERE o.id_episode_answer = i_episode
                 ORDER BY o.dt_approved DESC;
        
            --
            g_error := 'OPEN o_requests_prof';
            OPEN o_requests_prof FOR
                SELECT o.id_opinion id,
                       o.id_episode_answer id_episode,
                       pk_tools.get_prof_description(i_lang, i_prof, op.id_professional, o.dt_last_update, o.id_episode) prof_sign,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, o.dt_problem_tstz, i_prof) dt,
                       o.flg_state flg_status,
                       pk_sysdomain.get_domain('OPINION.FLG_STATE', o.flg_state, i_lang) desc_status
                  FROM opinion o
                  LEFT OUTER JOIN opinion_prof op
                    ON (o.id_opinion = op.id_opinion AND op.flg_type = 'E')
                  LEFT OUTER JOIN opinion_type ot
                    ON ot.id_opinion_type = o.id_opinion_type
                  LEFT OUTER JOIN episode e
                    ON e.id_episode = o.id_episode
                  LEFT OUTER JOIN epis_type et
                    ON et.id_epis_type = e.id_epis_type
                  LEFT OUTER JOIN clinical_service cs
                    ON cs.id_clinical_service = o.id_clinical_service
                 WHERE o.id_episode_answer = i_episode
                 ORDER BY o.dt_problem_tstz DESC;
            --
        ELSIF pk_rehab.get_rehab_epis_origin_type(i_lang, i_prof, i_episode) = 'C'
        THEN
        
            IF NOT pk_paramedical_prof_core.get_message_array(i_lang         => i_lang,
                                                              i_code_msg_arr => table_varchar('DIET_T009',
                                                                                              'CONSULT_REQ_T015',
                                                                                              'CONSULT_REQUEST_T024',
                                                                                              'SCH_T004'),
                                                              i_prof         => i_prof,
                                                              o_desc_msg_arr => t_table_message_array)
            THEN
                RAISE g_exception;
            END IF;
        
            --
            g_error := 'OPEN o_requests';
            OPEN o_requests FOR
                SELECT cr.id_consult_req id,
                       ei.id_episode     id_episode,
                       --reason
                       pk_paramedical_prof_core.format_str_header_w_colon(t_table_message_array('CONSULT_REQ_T015')) ||
                       cr.notes request_reason,
                       --profissional      
                       pk_paramedical_prof_core.format_str_header_w_colon(t_table_message_array('SCH_T004')) ||
                       nvl2(crp.id_professional,
                            pk_prof_utils.get_name_signature(i_lang, i_prof, crp.id_professional),
                            l_label_any_prof) name_prof_request_type,
                       --notas
                       pk_paramedical_prof_core.format_str_header_w_colon(t_table_message_array('DIET_T009')) ||
                       crp.denial_justif prof_answers
                  FROM epis_info ei
                  JOIN consult_req cr
                    ON (ei.id_schedule = cr.id_schedule)
                  JOIN consult_req_prof crp
                    ON (crp.id_consult_req = cr.id_consult_req AND crp.flg_status = 'A')
                 WHERE ei.id_episode = i_episode
                 ORDER BY cr.dt_scheduled_tstz DESC;
        
            --
            g_error := 'OPEN o_requests_prof';
            OPEN o_requests_prof FOR
                SELECT cr.id_consult_req id,
                       ei.id_episode id_episode,
                       pk_tools.get_prof_description(i_lang,
                                                     i_prof,
                                                     cr.id_prof_req,
                                                     crp.dt_consult_req_prof_tstz,
                                                     ei.id_episode) prof_sign,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, cr.dt_consult_req_tstz, i_prof) dt,
                       crp.flg_status flg_status,
                       pk_sysdomain.get_domain('CONSULT_REQ.FLG_STATUS', crp.flg_status, i_lang) desc_status
                  FROM epis_info ei
                  JOIN consult_req cr
                    ON (ei.id_schedule = cr.id_schedule)
                  JOIN consult_req_prof crp
                    ON (crp.id_consult_req = cr.id_consult_req AND crp.flg_status = 'A')
                 WHERE ei.id_episode = i_episode
                 ORDER BY cr.dt_scheduled_tstz DESC;
            --
        ELSE
            --this episode is an appointment
            pk_types.open_my_cursor(o_requests);
            pk_types.open_my_cursor(o_requests_prof);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_REHAB_REQUESTS_SUMMARY',
                                              o_error    => o_error);
            pk_types.open_my_cursor(o_requests);
            pk_types.open_my_cursor(o_requests_prof);
            RETURN FALSE;
    END get_rehab_requests_summary;

    FUNCTION get_rehab_epis_origin_type
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_id_epis IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
        --
        l_social_epis      VARCHAR2(1 CHAR);
        l_count            PLS_INTEGER;
        l_count_apointment PLS_INTEGER;
    BEGIN
        g_error := 'GET_REHAB_EPIS_TYPE BEGIN';
        pk_alertlog.log_debug(g_error);
        --
        SELECT COUNT(*)
          INTO l_count
          FROM opinion o
         WHERE o.id_episode_answer = i_id_epis;
        --
        SELECT COUNT(*)
          INTO l_count_apointment
          FROM epis_info ei
          JOIN consult_req cr
            ON (ei.id_schedule = cr.id_schedule)
         WHERE ei.id_episode = i_id_epis;
        --
    
        IF l_count <> 0
        THEN
            --request
            l_social_epis := pk_paramedical_prof_core.g_paramedical_epis_origin_r;
        ELSIF l_count_apointment <> 0
        THEN
            --appointment request
            l_social_epis := pk_paramedical_prof_core.g_paramedical_epis_origin_c;
        ELSE
            --appointment
            l_social_epis := pk_paramedical_prof_core.g_paramedical_epis_origin_a;
        END IF;
        RETURN l_social_epis;
    EXCEPTION
        WHEN OTHERS THEN
            --
            RETURN l_social_epis;
    END get_rehab_epis_origin_type;

    PROCEDURE init_params_patient_grids
    (
        i_filter_name   IN VARCHAR2,
        i_custom_filter IN NUMBER,
        i_context_ids   IN table_number,
        i_context_keys  IN table_varchar DEFAULT NULL,
        i_context_vals  IN table_varchar,
        i_name          IN VARCHAR2,
        o_vc2           OUT VARCHAR2,
        o_num           OUT NUMBER,
        o_id            OUT NUMBER,
        o_tstz          OUT TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
        g_lang             CONSTANT NUMBER(24) := 1;
        g_prof_id          CONSTANT NUMBER(24) := 2;
        g_prof_institution CONSTANT NUMBER(24) := 3;
        g_prof_software    CONSTANT NUMBER(24) := 4;
        l_lang             CONSTANT language.id_language%TYPE := i_context_ids(g_lang);
        l_prof             CONSTANT profissional := profissional(i_context_ids(g_prof_id),
                                                                 i_context_ids(g_prof_institution),
                                                                 pk_alert_constant.g_soft_rehab);
    
        --FILTER_BIND
        l_id_category prof_cat.id_category%TYPE;
        l_dt_begin    TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end      TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_today    TIMESTAMP(6) WITH LOCAL TIME ZONE;
    
        l_sysdate_tstz TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_sysdate_char VARCHAR(50 CHAR);
    
        l_flg_sch_type_cr      schedule.flg_sch_type%TYPE := 'CR';
        l_epis_type_rehab_ap   epis_type.id_epis_type%TYPE := 25;
        l_show_med_disch       sys_config.value%TYPE;
        l_scfg_rehab_needs_sch sys_config.value%TYPE;
    
        l_date_selected      VARCHAR2(20 CHAR);
        l_date_selected_tstz TIMESTAMP(6) WITH LOCAL TIME ZONE;
    
        l_lov_filter       NUMBER;
        l_ori_type         NUMBER;
        l_profile_template NUMBER;
    
        o_error t_error_out;
    BEGIN
    
        l_sysdate_tstz := current_timestamp;
        l_sysdate_char := pk_date_utils.date_send_tsz(l_lang, l_sysdate_tstz, l_prof);
    
        pk_context_api.set_parameter('l_is_treatment', 'N');
        pk_context_api.set_parameter('l_get_all', 'Y');
    
        l_profile_template := pk_prof_utils.get_prof_profile_template(l_prof);
    
        IF l_profile_template = g_cdc_prof_templ
        THEN
            l_flg_sch_type_cr    := 'PC'; --chemical dependency counselour appointments
            l_epis_type_rehab_ap := 28;
        ELSIF l_prof.software = pk_alert_constant.g_soft_adt
        THEN
            l_flg_sch_type_cr    := ''; --Rehab appointments
            l_epis_type_rehab_ap := g_all; --epis_type Rehab appointments
        
        ELSE
            l_flg_sch_type_cr    := l_flg_sch_type_cr; --Rehab appointments
            l_epis_type_rehab_ap := l_epis_type_rehab_ap; --epis_type Rehab appointments
        END IF;
    
        IF i_context_vals IS NOT NULL
        THEN
            IF i_context_vals.count > 0
            THEN
                l_date_selected := i_context_vals(1);
            ELSE
                l_date_selected := l_sysdate_char;
            END IF;
            IF i_context_vals.count > 1
            THEN
            
                IF i_context_vals(2) < g_filter_lov_all
                THEN
                    pk_context_api.set_parameter('l_is_treatment', 'Y');
                    pk_context_api.set_parameter('l_get_all', 'N');
                    IF i_context_vals(2) = g_all
                    THEN
                        l_ori_type := NULL;
                    ELSE
                        l_ori_type := i_context_vals(2);
                    END IF;
                
                    l_lov_filter := 0;
                ELSIF i_context_vals(2) = g_filter_lov_outp
                THEN
                    pk_context_api.set_parameter('l_get_all', 'N');
                    l_ori_type := NULL;
                    CASE l_prof.software
                        WHEN pk_alert_constant.g_soft_social THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_social;
                        WHEN pk_alert_constant.g_soft_nutritionist THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_dietitian;
                        WHEN pk_alert_constant.g_soft_psychologist THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_psychologist;
                        WHEN pk_alert_constant.g_soft_resptherap THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_resp_therapist;
                        WHEN pk_alert_constant.g_soft_rehab THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_rehab_appointment;
                        ELSE
                            l_lov_filter := i_context_vals(2);
                    END CASE;
                ELSIF i_context_vals(2) = g_filter_lov_hhc
                THEN
                    pk_context_api.set_parameter('l_get_all', 'N');
                    l_ori_type   := NULL;
                    l_lov_filter := pk_alert_constant.g_epis_type_home_health_care;
                ELSE
                    pk_context_api.set_parameter('l_get_all', 'Y');
                    l_ori_type   := NULL;
                    l_lov_filter := g_all;
                END IF;
            ELSE
                l_ori_type   := NULL;
                l_lov_filter := g_all;
            END IF;
        
        ELSE
            l_date_selected := l_sysdate_char;
        END IF;
    
        l_date_selected_tstz := pk_date_utils.get_string_tstz(l_lang, l_prof, l_date_selected, NULL);
    
        l_id_category := pk_prof_utils.get_id_category(i_lang => l_lang, i_prof => l_prof);
    
        l_dt_begin := pk_date_utils.trunc_insttimezone(l_prof, l_date_selected_tstz);
        l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
    
        l_dt_today := pk_date_utils.trunc_insttimezone(l_prof, current_timestamp);
    
        l_show_med_disch       := nvl(pk_sysconfig.get_config('SHOW_MEDICAL_DISCHARGED_GRID', l_prof),
                                      pk_alert_constant.g_yes);
        l_scfg_rehab_needs_sch := pk_sysconfig.get_config('REHAB_NEEDS_SCHEDULE', l_prof);
    
        pk_context_api.set_parameter('l_lang', l_lang);
        pk_context_api.set_parameter('l_prof_id', l_prof.id);
        pk_context_api.set_parameter('l_prof_institution', l_prof.institution);
        pk_context_api.set_parameter('l_prof_software', pk_alert_constant.g_soft_rehab);
        pk_context_api.set_parameter('l_id_category', l_id_category);
        pk_context_api.set_parameter('l_dt_begin', l_date_selected);
        pk_context_api.set_parameter('l_dt_end', l_date_selected);
        pk_context_api.set_parameter('l_flg_sch_type_cr', l_flg_sch_type_cr);
        pk_context_api.set_parameter('l_epis_type_rehab_ap', l_epis_type_rehab_ap);
        pk_context_api.set_parameter('l_show_med_disch', l_show_med_disch);
        pk_context_api.set_parameter('l_scfg_rehab_needs_sch', l_scfg_rehab_needs_sch);
        pk_context_api.set_parameter('l_dt_today', l_dt_today);
    
        CASE i_name
            WHEN 'l_lang' THEN
                o_vc2 := to_char(l_lang);
            WHEN 'l_prof_id' THEN
                o_vc2 := to_char(l_prof.id);
            WHEN 'l_prof_institution' THEN
                o_vc2 := to_char(l_prof.institution);
            WHEN 'l_prof_software' THEN
                o_vc2 := to_char(pk_alert_constant.g_soft_rehab);
            WHEN 'l_sysdate_char' THEN
                o_vc2 := l_sysdate_char;
            WHEN 'l_sysdate_tstz' THEN
                o_tstz := l_sysdate_tstz;
            WHEN 'l_id_category' THEN
                o_vc2 := to_char(l_id_category);
            WHEN 'l_dt_begin' THEN
                o_tstz := l_dt_begin;
            WHEN 'l_dt_end' THEN
                o_tstz := l_dt_end;
            WHEN 'l_ori_type' THEN
                o_vc2 := l_ori_type;
            WHEN 'l_epis_type' THEN
                o_vc2 := l_lov_filter;
            WHEN 'l_profile_template' THEN
                o_num := l_profile_template;
            ELSE
                NULL;
        END CASE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => l_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => 'ALERT',
                                              i_package  => 'PK_REHAB',
                                              i_function => 'INIT_PARAMS_PATIENT_GRIDS',
                                              o_error    => o_error);
    END init_params_patient_grids;

    FUNCTION get_extense_day_desc
    (
        i_lang IN language.id_language%TYPE,
        i_date IN VARCHAR2
    ) RETURN VARCHAR2 IS
    
        l_day_index   INTEGER;
        l_month_index INTEGER;
        l_day_desc    VARCHAR2(200);
        l_month_desc  VARCHAR2(200);
        l_day_num     VARCHAR2(200);
        l_year_num    VARCHAR2(200);
    
    BEGIN
        l_day_index   := pk_date_utils.week_day_standard(i_date => to_timestamp_tz(i_date, 'yyyymmddhh24miss'));
        l_month_index := to_char(to_date(i_date, 'yyyymmddhh24miss'), 'MM');
    
        l_day_num  := to_char(to_date(i_date, 'yyyymmddhh24miss'), 'dd');
        l_year_num := to_char(to_date(i_date, 'yyyymmddhh24miss'), 'yyyy');
    
        --------------------------------------------------------------------
        -- day name by index
        CASE l_day_index
            WHEN 1 THEN
                l_day_desc := pk_message.get_message(i_lang, 'SCH_MONTHVIEW_SEG');
            WHEN 2 THEN
                l_day_desc := pk_message.get_message(i_lang, 'SCH_MONTHVIEW_TER');
            WHEN 3 THEN
                l_day_desc := pk_message.get_message(i_lang, 'SCH_MONTHVIEW_QUA');
            WHEN 4 THEN
                l_day_desc := pk_message.get_message(i_lang, 'SCH_MONTHVIEW_QUI');
            WHEN 5 THEN
                l_day_desc := pk_message.get_message(i_lang, 'SCH_MONTHVIEW_SEX');
            WHEN 6 THEN
                l_day_desc := pk_message.get_message(i_lang, 'SCH_MONTHVIEW_SAB');
            WHEN 7 THEN
                l_day_desc := pk_message.get_message(i_lang, 'SCH_MONTHVIEW_DOM');
            ELSE
                RETURN NULL;
        END CASE;
    
        --------------------------------------------------------------------
        -- month name by index
        l_month_desc := pk_message.get_message(i_lang, 'SCH_MONTH_' || l_month_index);
    
        --------------------------------------------------------------------
        -- return result
        RETURN l_day_desc || ', ' || l_day_num || ' ' || l_month_desc || ' ' || l_year_num;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_extense_day_desc;

    FUNCTION get_grid_dates
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_all_patients     IN VARCHAR2,
        i_flg_type_profile IN VARCHAR2 DEFAULT NULL,
        o_date             OUT pk_types.cursor_type,
        o_error            OUT t_error_out
        
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PATIENTS_GRID';
    
        l_dt_begin                 TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end                   TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_count                    NUMBER;
        l_limit                    NUMBER;
        l_show_med_disch           sys_config.value%TYPE;
        l_rehab_needs_schedule     sys_config.value%TYPE;
        l_session_with_schedule    sys_message.desc_message%TYPE;
        l_session_without_schedule sys_message.desc_message%TYPE;
        l_appointment              sys_message.desc_message%TYPE;
        l_prof_rehab_groups        table_number;
        l_dt_current               VARCHAR2(200);
    
        l_flg_sch_type_cr    schedule.flg_sch_type%TYPE;
        l_epis_type_rehab_ap epis_type.id_epis_type%TYPE;
    
        k_adt_software CONSTANT NUMBER := 39;
    
        l_num_days_back    NUMBER;
        l_num_days_forward NUMBER;
    BEGIN
        g_error := 'begin';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
        g_sysdate_char := pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof);
    
        -- initiate variables
        IF i_flg_type_profile IS NULL
        THEN
            l_flg_sch_type_cr    := 'CR';
            l_epis_type_rehab_ap := 25;
        ELSE
            CASE i_flg_type_profile
                WHEN 'CDC' THEN
                    l_flg_sch_type_cr    := 'PC';
                    l_epis_type_rehab_ap := 28;
                ELSE
                    -- avoid this
                    l_flg_sch_type_cr    := NULL;
                    l_epis_type_rehab_ap := NULL;
            END CASE;
        END IF;
    
        l_num_days_back    := pk_sysconfig.get_config('NUM_DAYS_CARE_GRID_NAVIGATION_BACK', i_prof);
        l_num_days_forward := pk_sysconfig.get_config('NUM_DAYS_CARE_GRID_NAVIGATION_FORWARD', i_prof);
    
        --- INIT CMF
        OPEN o_date FOR
            SELECT pk_rehab.get_extense_day_desc(i_lang, pk_date_utils.date_send_tsz(i_lang, dt_exec, i_prof)) date_desc,
                   pk_date_utils.date_send_tsz(i_lang, dt_exec, i_prof) date_tstz,
                   --decode(date_tstz, l_dt_current, 'Y', 'N') today
                   today
              FROM (
                    -- BEFORE
                    SELECT pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz + numtodsinterval(-level, 'DAY')) dt_exec,
                            'N' today
                      FROM dual
                    CONNECT BY LEVEL <= l_num_days_back
                    UNION ALL
                    -- CURRENT DAY
                    SELECT pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz) dt_exec, 'Y' today
                      FROM dual
                    UNION ALL
                    SELECT pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz + numtodsinterval(LEVEL, 'DAY')) dt_exec,
                            'N' today
                      FROM dual
                    CONNECT BY LEVEL <= l_num_days_forward) xsql
             ORDER BY dt_exec ASC;
    
        RETURN TRUE;
        -- Propositao para nao executar resto, até nova ordem
        -- On Purpse for do you not execute on the rest
        -- END CMF
    
        IF l_num_days_back IS NULL
           OR l_num_days_back <= 0
        THEN
            l_num_days_back := 10;
        END IF;
    
        IF l_num_days_forward IS NULL
           OR l_num_days_forward <= 0
        THEN
            l_num_days_forward := 10;
        END IF;
    
        l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof,
                                                       g_sysdate_tstz + numtodsinterval(-l_num_days_back, 'DAY'));
        --l_dt_end       := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
        l_dt_end := pk_date_utils.trunc_insttimezone(i_prof,
                                                     g_sysdate_tstz + numtodsinterval(l_num_days_forward, 'DAY'));
    
        --
        l_show_med_disch := nvl(pk_sysconfig.get_config('SHOW_MEDICAL_DISCHARGED_GRID', i_prof),
                                pk_alert_constant.g_yes);
        --
        g_error := 'get profissional groups ';
        SELECT id_rehab_group
          BULK COLLECT
          INTO l_prof_rehab_groups
          FROM rehab_group_prof rgp
         WHERE rgp.id_professional = i_prof.id;
    
        g_error := 'before call';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
        l_dt_current   := pk_date_utils.date_send_tsz(i_lang,
                                                      pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz),
                                                      i_prof);
    
        IF i_all_patients = pk_alert_constant.g_no
        THEN
        
            l_rehab_needs_schedule := pk_sysconfig.get_config(i_prof => i_prof, i_code_cf => 'REHAB_NEEDS_SCHEDULE');
        
            --MY patients grid
            OPEN o_date FOR
                SELECT get_extense_day_desc(i_lang, pk_date_utils.date_send_tsz(i_lang, dt_exec, i_prof)) date_desc,
                       pk_date_utils.date_send_tsz(i_lang, dt_exec, i_prof) date_tstz,
                       decode(date_tstz, l_dt_current, 'Y', 'N') today
                  FROM (SELECT DISTINCT dt_exec, date_tstz, precedence_level
                          FROM (SELECT pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz) dt_exec,
                                       pk_date_utils.date_send_tsz(i_lang,
                                                                   pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz),
                                                                   i_prof) date_tstz,
                                       NULL precedence_level
                                  FROM dual
                                UNION ALL
                                SELECT pk_date_utils.trunc_insttimezone(i_prof, s.dt_begin_tstz) dt_exec,
                                       pk_date_utils.date_send_tsz(i_lang,
                                                                   pk_date_utils.trunc_insttimezone(i_prof,
                                                                                                    s.dt_begin_tstz),
                                                                   i_prof) date_tstz,
                                       NULL precedence_level
                                  FROM rehab_schedule rs
                                  JOIN schedule s
                                    ON s.id_schedule = rs.id_schedule
                                  JOIN rehab_sch_need rsn
                                    ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
                                  JOIN rehab_presc rpres
                                    ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                                  JOIN rehab_session_type rst
                                    ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                                  JOIN rehab_plan rp
                                    ON rp.id_episode_origin = rsn.id_episode_origin
                                  JOIN episode e
                                    ON e.id_episode = rsn.id_episode_origin -- falta este episódio
                                  LEFT JOIN rehab_environment r
                                    ON r.id_epis_type = e.id_epis_type
                                   AND r.id_institution = i_prof.institution
                                   AND r.id_rehab_environment IN
                                       (SELECT rep.id_rehab_environment
                                          FROM rehab_environment_prof rep
                                         WHERE rep.id_professional = i_prof.id)
                                  JOIN epis_info ei
                                    ON ei.id_episode = e.id_episode
                                  LEFT JOIN bed bd
                                    ON bd.id_bed = ei.id_bed
                                  LEFT JOIN room ro
                                    ON (ro.id_room = s.id_room OR ro.id_room = bd.id_room)
                                  LEFT JOIN department dpt
                                    ON dpt.id_department = ro.id_department
                                  LEFT JOIN rehab_epis_encounter re
                                    ON (re.id_episode_origin = e.id_episode AND
                                       re.id_rehab_sch_need = rsn.id_rehab_sch_need AND
                                       re.dt_creation BETWEEN l_dt_begin AND l_dt_end)
                                  JOIN rehab_area_interv rai
                                    ON rai.id_rehab_area_interv = rpres.id_rehab_area_interv
                                  JOIN (SELECT /*+ OPT_ESTIMATE(TABLE t1 ROWS=1) */
                                        t1.*
                                         FROM TABLE(pk_rehab.find_prof_rehab_areas(i_prof.id, i_prof.institution)) t1) x
                                    ON x.id_rehab_area = rai.id_rehab_area
                                 WHERE s.dt_begin_tstz BETWEEN l_dt_begin AND l_dt_end
                                   AND rs.flg_status = g_rehab_schedule_scheduled
                                   AND s.flg_status != pk_schedule.g_sched_status_temporary
                                   AND s.id_instit_requested = i_prof.institution
                                   AND s.flg_status != pk_schedule.g_sched_status_cache
                                   AND rpres.flg_status NOT IN
                                       (pk_alert_constant.g_cancelled, g_rehab_presc_discontinued)
                                   AND ((e.flg_status = pk_alert_constant.g_active AND
                                       /*pk_sysconfig.get_config(i_prof => i_prof, i_code_cf => 'REHAB_NEEDS_SCHEDULE') =*/
                                       l_rehab_needs_schedule = pk_alert_constant.g_no) OR
                                       (l_rehab_needs_schedule = pk_alert_constant.g_yes) AND s.id_schedule IS NOT NULL)
                                      -- ou o profissional responsável sou eu
                                   AND (
                                       -- adt nao precisa
                                        i_prof.software = k_adt_software OR
                                       -- resto precisa
                                        (i_prof.software != k_adt_software AND
                                        (rsn.id_resp_professional IS NOT NULL AND rsn.id_resp_professional = i_prof.id) OR
                                        -- ou o meu grupo
                                        (rsn.id_resp_rehab_group IS NOT NULL AND
                                        rsn.id_resp_rehab_group IN
                                        (SELECT /*+ OPT_ESTIMATE(TABLE t ROWS=1) */
                                            column_value
                                             FROM TABLE(l_prof_rehab_groups) t))))
                                --Rehab_appointments
                                UNION ALL
                                SELECT pk_date_utils.trunc_insttimezone(i_prof, sp.dt_target_tstz) dt_exec,
                                       pk_date_utils.date_send_tsz(i_lang,
                                                                   pk_date_utils.trunc_insttimezone(i_prof,
                                                                                                    sp.dt_target_tstz),
                                                                   i_prof) date_tstz,
                                       NULL precedence_level
                                  FROM schedule_outp sp
                                  JOIN schedule s
                                    ON s.id_schedule = sp.id_schedule
                                  JOIN sch_group sg
                                    ON sg.id_schedule = s.id_schedule
                                  JOIN epis_info ei
                                    ON s.id_schedule = ei.id_schedule
                                  JOIN sch_prof_outp spo
                                    ON spo.id_schedule_outp = sp.id_schedule_outp
                                  JOIN sch_resource scr
                                    ON s.id_schedule = scr.id_schedule
                                  JOIN epis_type et
                                    ON sp.id_epis_type = et.id_epis_type
                                  JOIN episode e
                                    ON ei.id_episode = e.id_episode
                                  LEFT JOIN rehab_epis_encounter re
                                    ON re.id_episode_origin = e.id_episode
                                  JOIN rehab_environment r
                                    ON r.id_epis_type = e.id_epis_type
                                   AND r.id_institution = i_prof.institution
                                   AND r.id_rehab_environment IN
                                       (SELECT rep.id_rehab_environment
                                          FROM rehab_environment_prof rep
                                         WHERE rep.id_professional = i_prof.id)
                                 WHERE s.flg_sch_type = l_flg_sch_type_cr
                                   AND s.flg_status != pk_schedule.g_sched_status_cache -- agendamentos temporários (SCH 3.0)
                                   AND pk_grid.get_schedule_real_state(sp.flg_state, e.flg_ehr) !=
                                       pk_grid_amb.g_sched_adm_disch
                                   AND s.flg_status != pk_alert_constant.g_flg_status_c
                                   AND s.id_instit_requested = i_prof.institution
                                   AND scr.id_professional = i_prof.id
                                   AND sp.id_epis_type = l_epis_type_rehab_ap
                                   AND sp.dt_target_tstz BETWEEN l_dt_begin AND l_dt_end
                                   AND (l_show_med_disch = pk_alert_constant.g_yes OR
                                       (l_show_med_disch = pk_alert_constant.g_no AND
                                       pk_grid.get_schedule_real_state(sp.flg_state, e.flg_ehr) !=
                                       pk_grid_amb.g_sched_med_disch))
                                UNION ALL
                                -- planos de reabilitacao
                                SELECT pk_date_utils.trunc_insttimezone(i_prof,
                                                                        nvl(re.dt_creation, rep.dt_rehab_epis_plan)) dt_exec,
                                       pk_date_utils.date_send_tsz(i_lang,
                                                                   pk_date_utils.trunc_insttimezone(i_prof,
                                                                                                    nvl(re.dt_creation,
                                                                                                        rep.dt_rehab_epis_plan)),
                                                                   i_prof) date_tstz,
                                       NULL precedence_level
                                  FROM rehab_epis_plan rep
                                  JOIN rehab_epis_plan_team rept
                                    ON (rept.id_rehab_epis_plan = rep.id_rehab_epis_plan AND rept.flg_status = 'Y')
                                  JOIN prof_cat pc
                                    ON (rept.id_prof_cat = pc.id_prof_cat AND pc.id_professional = i_prof.id)
                                  JOIN episode e
                                    ON (e.id_episode = nvl((SELECT DISTINCT ree.id_episode_origin
                                                             FROM rehab_epis_encounter ree
                                                            WHERE ree.id_episode_rehab = rep.id_episode),
                                                           rep.id_episode) AND e.id_institution = i_prof.institution)
                                  JOIN rehab_environment r
                                    ON r.id_epis_type = e.id_epis_type
                                   AND r.id_institution = i_prof.institution
                                   AND r.id_rehab_environment IN
                                       (SELECT rep.id_rehab_environment
                                          FROM rehab_environment_prof rep
                                         WHERE rep.id_professional = i_prof.id)
                                  LEFT JOIN epis_info ei
                                    ON ei.id_episode = e.id_episode
                                  LEFT JOIN bed bd
                                    ON bd.id_bed = ei.id_bed
                                  LEFT JOIN room ro
                                    ON ro.id_room = bd.id_room
                                  LEFT JOIN department dpt
                                    ON dpt.id_department = ro.id_department
                                  LEFT JOIN rehab_epis_encounter re
                                    ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND
                                       l_dt_end)
                                 WHERE rep.dt_rehab_epis_plan BETWEEN l_dt_begin AND l_dt_end
                                   AND e.id_episode NOT IN (SELECT rsn.id_episode_origin
                                                              FROM rehab_sch_need rsn)
                                   AND rep.flg_status = 'O'))
                 ORDER BY dt_exec;
        ELSE
            --All patients
            OPEN o_date FOR
                SELECT get_extense_day_desc(i_lang, pk_date_utils.date_send_tsz(i_lang, dt_exec, i_prof)) date_desc,
                       pk_date_utils.date_send_tsz(i_lang, dt_exec, i_prof) date_tstz,
                       decode(date_tstz, l_dt_current, 'Y', 'N') today
                  FROM (SELECT DISTINCT dt_exec, date_tstz, precedence_level
                          FROM (SELECT pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz) dt_exec,
                                       pk_date_utils.date_send_tsz(i_lang,
                                                                   pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz),
                                                                   i_prof) date_tstz,
                                       NULL precedence_level
                                  FROM dual
                                UNION ALL
                                SELECT pk_date_utils.trunc_insttimezone(i_prof, s.dt_begin_tstz) dt_exec,
                                       pk_date_utils.date_send_tsz(i_lang,
                                                                   pk_date_utils.trunc_insttimezone(i_prof,
                                                                                                    s.dt_begin_tstz),
                                                                   i_prof) date_tstz,
                                       NULL precedence_level
                                  FROM rehab_schedule rs
                                  JOIN schedule s
                                    ON s.id_schedule = rs.id_schedule
                                  JOIN rehab_sch_need rsn
                                    ON rsn.id_rehab_sch_need = rs.id_rehab_sch_need
                                  JOIN rehab_session_type rst
                                    ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                                  JOIN rehab_presc rpres
                                    ON rpres.id_rehab_sch_need = rsn.id_rehab_sch_need
                                  JOIN rehab_plan rp
                                    ON rp.id_episode_origin = rsn.id_episode_origin
                                  JOIN episode e
                                    ON e.id_episode = rsn.id_episode_origin -- falta este episódio
                                  JOIN rehab_environment r
                                    ON r.id_epis_type = e.id_epis_type
                                   AND r.id_institution = i_prof.institution
                                   AND r.id_rehab_environment IN
                                       (SELECT rep.id_rehab_environment
                                          FROM rehab_environment_prof rep
                                         WHERE rep.id_professional = i_prof.id)
                                  JOIN epis_info ei
                                    ON ei.id_episode = e.id_episode
                                  LEFT JOIN bed bd
                                    ON bd.id_bed = ei.id_bed
                                  LEFT JOIN room ro
                                    ON (ro.id_room = s.id_room OR ro.id_room = bd.id_room)
                                  LEFT JOIN department dpt
                                    ON dpt.id_department = ro.id_department
                                  LEFT JOIN rehab_epis_encounter re
                                    ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND
                                       l_dt_end AND re.id_rehab_sch_need = rsn.id_rehab_sch_need)
                                 WHERE s.dt_begin_tstz BETWEEN l_dt_begin AND l_dt_end
                                   AND rs.flg_status = g_rehab_schedule_scheduled
                                   AND s.id_instit_requested = i_prof.institution
                                   AND s.flg_status != pk_schedule.g_sched_status_temporary
                                   AND s.flg_status != pk_schedule.g_sched_status_cache
                                   AND rpres.flg_status NOT IN
                                       (pk_alert_constant.g_cancelled, g_rehab_presc_discontinued)
                                      --epis_origin activo
                                   AND ((e.flg_status = pk_alert_constant.g_active AND
                                       pk_sysconfig.get_config(i_prof => i_prof, i_code_cf => 'REHAB_NEEDS_SCHEDULE') =
                                       pk_alert_constant.g_no) OR
                                       (pk_sysconfig.get_config(i_prof => i_prof, i_code_cf => 'REHAB_NEEDS_SCHEDULE') =
                                       pk_alert_constant.g_yes) AND s.id_schedule IS NOT NULL)
                                --se estiver alocado à área de reabilitação
                                
                                UNION ALL
                                -- pacientes com tratamentos sem agendamento
                                SELECT dt_exec, date_tstz, precedence_level
                                  FROM (SELECT pk_date_utils.trunc_insttimezone(i_prof, nvl(re.dt_creation, rsn.dt_begin)) dt_exec,
                                               pk_date_utils.date_send_tsz(i_lang,
                                                                           pk_date_utils.trunc_insttimezone(i_prof,
                                                                                                            nvl(re.dt_creation,
                                                                                                                rsn.dt_begin)),
                                                                           i_prof) date_tstz,
                                               rank() over(PARTITION BY e.id_patient, rst.id_rehab_session_type ORDER BY rp.id_rehab_presc DESC) precedence_level
                                        
                                          FROM rehab_presc rp
                                          JOIN rehab_sch_need rsn
                                            ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                                          JOIN rehab_session_type rst
                                            ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                                          JOIN rehab_plan rbp
                                            ON rbp.id_episode_origin = rsn.id_episode_origin
                                          JOIN episode e
                                            ON e.id_episode = rsn.id_episode_origin -- falta este episódio
                                          JOIN rehab_environment r
                                            ON r.id_epis_type = e.id_epis_type
                                           AND r.id_institution = i_prof.institution
                                           AND r.id_rehab_environment IN
                                               (SELECT rep.id_rehab_environment
                                                  FROM rehab_environment_prof rep
                                                 WHERE rep.id_professional = i_prof.id)
                                          LEFT JOIN epis_info ei
                                            ON ei.id_episode = e.id_episode
                                          LEFT JOIN rehab_epis_encounter re
                                            ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND
                                               l_dt_end AND re.id_rehab_sch_need = rsn.id_rehab_sch_need)
                                          LEFT JOIN bed bd
                                            ON bd.id_bed = ei.id_bed
                                          LEFT JOIN room ro
                                            ON ro.id_room = bd.id_room
                                          LEFT JOIN department dpt
                                            ON dpt.id_department = ro.id_department
                                         WHERE rsn.flg_status = g_rehab_sch_need_no_sched
                                           AND rp.flg_status NOT IN (g_rehab_presc_referral,
                                                                     g_rehab_presc_not_order_reas,
                                                                     pk_alert_constant.g_cancelled,
                                                                     g_rehab_presc_discontinued)
                                           AND (re.flg_status IS NULL OR
                                               re.flg_status NOT IN
                                               (pk_rehab.g_rehab_epis_enc_status_o,
                                                 pk_rehab.g_rehab_epis_enc_status_c,
                                                 pk_rehab.g_rehab_epis_enc_status_f))
                                              --epis_origin activo
                                           AND e.flg_status = pk_alert_constant.g_active
                                           AND rp.id_institution = i_prof.institution
                                           AND (rsn.dt_begin IS NULL OR
                                               (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= 0 OR
                                               (pk_date_utils.get_timestamp_diff(current_timestamp, rsn.dt_begin) >= -1 AND
                                               extract(DAY FROM(current_timestamp)) >= extract(DAY FROM(rsn.dt_begin)))))
                                              --For non scheduled sessions it is necessary to stop showing on the grid
                                              --requests that have a total of concluded sessions (or sessions started, but no concluded, over 24 hours ago)
                                              --equal to the number of requested sessions                                         
                                           AND (rsn.sessions >
                                               (SELECT COUNT(1)
                                                   FROM rehab_epis_encounter ree_c
                                                  WHERE ree_c.id_episode_origin = rsn.id_episode_origin
                                                    AND ree_c.id_rehab_sch_need = rsn.id_rehab_sch_need
                                                    AND (ree_c.flg_status IN (pk_rehab.g_rehab_epis_enc_status_o) OR
                                                        (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_s AND
                                                        ree_c.dt_creation <
                                                        pk_date_utils.add_days_to_tstz(l_dt_begin, -1)) OR
                                                        (ree_c.flg_status = pk_rehab.g_rehab_epis_enc_status_f AND
                                                        ree_c.flg_rehab_workflow_type = pk_rehab.g_workflow_type_s))))) t
                                 WHERE t.precedence_level = 1
                                --Rehab_appointments
                                UNION ALL
                                SELECT pk_date_utils.trunc_insttimezone(i_prof, sp.dt_target_tstz) dt_exec,
                                       pk_date_utils.date_send_tsz(i_lang,
                                                                   pk_date_utils.trunc_insttimezone(i_prof,
                                                                                                    sp.dt_target_tstz),
                                                                   i_prof) date_tstz,
                                       
                                       NULL precedence_level
                                  FROM schedule_outp sp
                                  JOIN schedule s
                                    ON s.id_schedule = sp.id_schedule
                                  JOIN sch_group sg
                                    ON sg.id_schedule = s.id_schedule
                                  JOIN epis_info ei
                                    ON s.id_schedule = ei.id_schedule
                                  JOIN epis_type et
                                    ON sp.id_epis_type = et.id_epis_type
                                  JOIN episode e
                                    ON ei.id_episode = e.id_episode
                                  LEFT JOIN rehab_epis_encounter re
                                    ON re.id_episode_origin = e.id_episode
                                  JOIN rehab_environment r
                                    ON (r.id_epis_type = e.id_epis_type AND r.id_institution = i_prof.institution AND
                                       r.id_rehab_environment IN
                                       (SELECT rep.id_rehab_environment
                                           FROM rehab_environment_prof rep
                                          WHERE rep.id_professional = i_prof.id) OR (l_epis_type_rehab_ap = 28))
                                 WHERE s.flg_sch_type = l_flg_sch_type_cr
                                   AND s.flg_status != pk_schedule.g_sched_status_cache -- agendamentos temporários (SCH 3.0)
                                   AND pk_grid.get_schedule_real_state(sp.flg_state, e.flg_ehr) !=
                                       pk_grid_amb.g_sched_adm_disch
                                   AND s.flg_status != pk_alert_constant.g_flg_status_c
                                   AND s.id_instit_requested = i_prof.institution
                                   AND sp.id_epis_type = l_epis_type_rehab_ap
                                   AND sp.dt_target_tstz BETWEEN l_dt_begin AND l_dt_end
                                   AND (l_show_med_disch = pk_alert_constant.g_yes OR
                                       (l_show_med_disch = pk_alert_constant.g_no AND
                                       pk_grid.get_schedule_real_state(sp.flg_state, e.flg_ehr) !=
                                       pk_grid_amb.g_sched_med_disch))
                                UNION ALL
                                -- planos de reabilitacao
                                SELECT pk_date_utils.trunc_insttimezone(i_prof,
                                                                        nvl(re.dt_creation, rep.dt_rehab_epis_plan)) dt_exec,
                                       pk_date_utils.date_send_tsz(i_lang,
                                                                   pk_date_utils.trunc_insttimezone(i_prof,
                                                                                                    nvl(re.dt_creation,
                                                                                                        rep.dt_rehab_epis_plan)),
                                                                   i_prof) date_tstz,
                                       
                                       NULL precedence_level
                                  FROM rehab_epis_plan rep
                                  JOIN episode e
                                    ON (e.id_episode = nvl((SELECT DISTINCT ree.id_episode_origin
                                                             FROM rehab_epis_encounter ree
                                                            WHERE ree.id_episode_rehab = rep.id_episode),
                                                           rep.id_episode) AND e.id_institution = i_prof.institution)
                                  JOIN rehab_environment r
                                    ON r.id_epis_type = e.id_epis_type
                                   AND r.id_institution = i_prof.institution
                                   AND r.id_rehab_environment IN
                                       (SELECT rep.id_rehab_environment
                                          FROM rehab_environment_prof rep
                                         WHERE rep.id_professional = i_prof.id)
                                  LEFT JOIN epis_info ei
                                    ON ei.id_episode = e.id_episode
                                  LEFT JOIN bed bd
                                    ON bd.id_bed = ei.id_bed
                                  LEFT JOIN room ro
                                    ON ro.id_room = bd.id_room
                                  LEFT JOIN department dpt
                                    ON dpt.id_department = ro.id_department
                                  LEFT JOIN rehab_epis_encounter re
                                    ON (re.id_episode_origin = e.id_episode AND re.dt_creation BETWEEN l_dt_begin AND
                                       l_dt_end)
                                 WHERE rep.dt_rehab_epis_plan BETWEEN l_dt_begin AND l_dt_end
                                   AND e.id_episode NOT IN (SELECT rsn.id_episode_origin
                                                              FROM rehab_sch_need rsn)
                                   AND rep.flg_status = 'O'))
                 ORDER BY dt_exec;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(g_error, g_package_name, l_func_name);
            pk_types.open_cursor_if_closed(o_date);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_grid_dates;

    PROCEDURE init_params_cdc_grid
    (
        i_filter_name   IN VARCHAR2,
        i_custom_filter IN NUMBER,
        i_context_ids   IN table_number,
        i_context_keys  IN table_varchar DEFAULT NULL,
        i_context_vals  IN table_varchar,
        i_name          IN VARCHAR2,
        o_vc2           OUT VARCHAR2,
        o_num           OUT NUMBER,
        o_id            OUT NUMBER,
        o_tstz          OUT TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
        g_lang             CONSTANT NUMBER(24) := 1;
        g_prof_id          CONSTANT NUMBER(24) := 2;
        g_prof_institution CONSTANT NUMBER(24) := 3;
        g_prof_software    CONSTANT NUMBER(24) := 4;
        l_lang             CONSTANT language.id_language%TYPE := i_context_ids(g_lang);
        l_prof             CONSTANT profissional := profissional(i_context_ids(g_prof_id),
                                                                 i_context_ids(g_prof_institution),
                                                                 pk_alert_constant.g_soft_rehab);
    
        --FILTER_BIND
        l_id_category prof_cat.id_category%TYPE;
        l_dt_begin    TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end      TIMESTAMP(6) WITH LOCAL TIME ZONE;
    
        l_sysdate_tstz TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_sysdate_char VARCHAR(50 CHAR);
    
        l_flg_sch_type_cr      schedule.flg_sch_type%TYPE := 'PC';
        l_epis_type_rehab_ap   epis_type.id_epis_type%TYPE := 28;
        l_show_med_disch       sys_config.value%TYPE;
        l_scfg_rehab_needs_sch sys_config.value%TYPE;
        l_reasongrid           sys_config.value%TYPE;
    
        l_date_selected      VARCHAR2(20 CHAR);
        l_date_selected_tstz TIMESTAMP(6) WITH LOCAL TIME ZONE;
    
        l_lov_filter NUMBER;
    
        o_error t_error_out;
    BEGIN
    
        l_sysdate_tstz := systimestamp;
        l_sysdate_char := pk_date_utils.date_send_tsz(l_lang, l_sysdate_tstz, l_prof);
    
        IF i_context_vals IS NOT NULL
        THEN
            IF i_context_vals.count > 0
            THEN
                l_date_selected := i_context_vals(1);
            ELSE
                l_date_selected := l_sysdate_char;
            END IF;
        
            IF i_context_vals.count > 1
            THEN
                l_lov_filter := i_context_vals(2);
                IF l_lov_filter = 0
                THEN
                    l_lov_filter := NULL;
                END IF;
            END IF;
        
        ELSE
            l_date_selected := l_sysdate_char;
        END IF;
    
        l_date_selected_tstz := pk_date_utils.get_string_tstz(l_lang, l_prof, l_date_selected, NULL);
    
        l_id_category := pk_prof_utils.get_id_category(i_lang => l_lang, i_prof => l_prof);
    
        l_dt_begin := pk_date_utils.trunc_insttimezone(l_prof, l_date_selected_tstz);
        --l_dt_begin := pk_date_utils.trunc_insttimezone(l_prof, l_sysdate_tstz);
        l_dt_end := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
    
        l_show_med_disch       := nvl(pk_sysconfig.get_config('SHOW_MEDICAL_DISCHARGED_GRID', l_prof),
                                      pk_alert_constant.g_yes);
        l_scfg_rehab_needs_sch := pk_sysconfig.get_config('REHAB_NEEDS_SCHEDULE', l_prof);
        l_reasongrid           := pk_sysconfig.get_config('REASON_FOR_VISIT_GRID', l_prof);
        pk_context_api.set_parameter('l_lang', l_lang);
        pk_context_api.set_parameter('l_prof_id', l_prof.id);
        pk_context_api.set_parameter('l_prof_institution', l_prof.institution);
        pk_context_api.set_parameter('l_prof_software', pk_alert_constant.g_soft_rehab);
        pk_context_api.set_parameter('l_id_category', l_id_category);
        pk_context_api.set_parameter('l_dt_begin', l_dt_begin);
        pk_context_api.set_parameter('l_dt_end', l_dt_end);
        pk_context_api.set_parameter('l_flg_sch_type_cr', l_flg_sch_type_cr);
        pk_context_api.set_parameter('l_epis_type_rehab_ap', l_epis_type_rehab_ap);
        pk_context_api.set_parameter('l_show_med_disch', l_show_med_disch);
        pk_context_api.set_parameter('l_scfg_rehab_needs_sch', l_scfg_rehab_needs_sch);
        pk_context_api.set_parameter('l_reasongrid', l_reasongrid);
        pk_context_api.set_parameter('l_dt', l_date_selected);
    
        CASE i_name
            WHEN 'l_lang' THEN
                o_vc2 := to_char(l_lang);
            WHEN 'l_prof_id' THEN
                o_vc2 := to_char(l_prof.id);
            WHEN 'l_prof_institution' THEN
                o_vc2 := to_char(l_prof.institution);
            WHEN 'l_prof_software' THEN
                o_vc2 := to_char(l_prof.software);
            WHEN 'l_sysdate_char' THEN
                o_vc2 := l_sysdate_char;
            WHEN 'l_sysdate_tstz' THEN
                o_tstz := l_sysdate_tstz;
            WHEN 'l_id_category' THEN
                o_vc2 := to_char(l_id_category);
            WHEN 'l_dt_begin' THEN
                o_tstz := l_dt_begin;
            WHEN 'l_dt_end' THEN
                o_tstz := l_dt_end;
            WHEN 'l_prof_id' THEN
                o_vc2 := to_char(l_prof.id);
            WHEN 'l_prof_institution' THEN
                o_vc2 := to_char(l_prof.institution);
            WHEN 'l_prof_software' THEN
                o_vc2 := to_char(pk_alert_constant.g_soft_rehab);
            WHEN 'l_id_category' THEN
                o_vc2 := to_char(l_id_category);
            WHEN 'l_ori_type' THEN
                o_vc2 := l_lov_filter;
            WHEN 'l_prof_cat_type' THEN
                o_vc2 := pk_prof_utils.get_category(l_lang, l_prof);
            ELSE
                NULL;
        END CASE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => l_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => 'ALERT',
                                              i_package  => 'PK_REHAB',
                                              i_function => 'INIT_PARAMS_PATIENT_GRIDS',
                                              o_error    => o_error);
    END init_params_cdc_grid;

    -- CMF
    -- ************************************************
    FUNCTION get_rehab_treat_plan2
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        i_id_episode IN table_number
        --i_reports    IN VARCHAR2
    ) RETURN t_tbl_rehab_treat IS
        l_func_name      CONSTANT VARCHAR2(30) := 'GET_REHAB_TREAT_NOT_PRESC';
        l_type_session   CONSTANT VARCHAR2(30) := 'S';
        l_type_treatment CONSTANT VARCHAR2(30) := 'T';
        l_has_notes     sys_message.desc_message%TYPE;
        l_cancel_reason sys_message.desc_message%TYPE;
        l_reason_notes  sys_message.desc_message%TYPE;
        tbl_return      t_tbl_rehab_treat;
    BEGIN
    
        --g_sysdate_tstz := current_timestamp;
    
        l_has_notes     := pk_message.get_message(i_lang, i_prof, 'COMMON_M097');
        l_cancel_reason := pk_message.get_message(i_lang, 'DETAIL_COMMON_M006');
        l_reason_notes  := pk_message.get_message(i_lang, 'COMMON_M073');
    
        SELECT t_rec_rehab_treat(rec_type                  => rec_type,
                                 id_rehab_presc            => id_rehab_presc,
                                 id_rehab_sch_need         => id_rehab_sch_need,
                                 id_rehab_area_interv      => id_rehab_area_interv,
                                 id_intervention           => id_intervention,
                                 desc_interv               => desc_interv,
                                 desc_area                 => desc_area,
                                 id_rehab_area             => id_rehab_area,
                                 prof_requested            => prof_requested,
                                 id_prof_requested         => id_prof_requested,
                                 dt_requested_str          => dt_requested_str,
                                 dt_requested              => dt_requested,
                                 icon                      => icon,
                                 icon_label                => icon_label,
                                 icon_color                => icon_color,
                                 back_color                => back_color,
                                 flg_status                => flg_status,
                                 id_exec_institution       => id_exec_institution,
                                 exec_institution          => exec_institution,
                                 instructions              => instructions,
                                 has_notes                 => has_notes,
                                 notes                     => notes,
                                 flg_status_description    => flg_status_description,
                                 session_type              => session_type,
                                 execution_local           => execution_local,
                                 prof_name_requested       => prof_name_requested,
                                 prof_speciality_requested => prof_speciality_requested,
                                 cancel_reason_desc        => cancel_reason_desc,
                                 cancel_reason_notes       => cancel_reason_notes,
                                 label_cancel_reason       => label_cancel_reason,
                                 label_reason_notes        => label_reason_notes,
                                 flg_laterality            => flg_laterality,
                                 desc_laterality           => desc_laterality,
                                 flg_laterality_mcdt       => flg_laterality_mcdt,
                                 id_codification           => id_codification,
                                 codification              => codification,
                                 id_mcdt_codification      => id_mcdt_codification,
                                 flg_priority              => flg_priority,
                                 not_order_reason_desc     => not_order_reason_desc,
                                 flg_clinical_question     => flg_clinical_question)
          BULK COLLECT
          INTO tbl_return
          FROM (SELECT l_type_treatment AS rec_type,
                       t.id_rehab_presc,
                       t.id_rehab_sch_need,
                       t.id_rehab_area_interv,
                       t.id_intervention,
                       pk_procedures_api_db.get_alias_translation(i_lang, i_prof, t.code_intervention, NULL) AS desc_interv,
                       get_rehab_area_name(i_lang, t.id_rehab_area) desc_area,
                       t.id_rehab_area,
                       pk_prof_utils.get_nickname(i_lang, t.id_professional) prof_requested,
                       t.id_professional id_prof_requested,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, t.dt_rehab_presc, i_prof) dt_requested_str,
                       t.dt_rehab_presc dt_requested,
                       get_rp_icon(i_lang, NULL, t.id_rehab_sch_need, t.sessions, t.flg_status) icon,
                       CASE
                            WHEN t.flg_status <> g_rehab_presc_finished THEN
                             get_rp_icon_label(i_lang, i_prof, t.id_rehab_presc, t.sessions, t.flg_status)
                        END icon_label,
                       pk_rehab.get_rp_back_color(i_lang, i_prof, t.id_rehab_presc, t.flg_status) back_color,
                       pk_rehab.get_rp_icon_color(i_lang, i_prof, t.id_rehab_presc, t.flg_status) icon_color,
                       t.flg_status,
                       t.id_exec_institution,
                       pk_utils.get_institution_name(i_lang, t.id_exec_institution) exec_institution,
                       get_instructions(i_lang, i_prof, t.id_rehab_sch_need) AS instructions,
                       nvl2(t.notes, l_has_notes, NULL) AS has_notes,
                       t.notes AS notes,
                       pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', t.flg_status, i_lang) flg_status_description,
                       pk_translation.get_translation(i_lang, t.code_rehab_session_type) session_type,
                       decode(t.abbreviation,
                              NULL,
                              pk_translation.get_translation(i_lang, t.code_institution),
                              t.abbreviation) execution_local,
                       pk_prof_utils.get_name(i_lang, t.id_professional) prof_name_requested,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        t.id_professional,
                                                        t.dt_rehab_presc,
                                                        t.id_episode_origin) prof_speciality_requested,
                       pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, t.id_cancel_reason) cancel_reason_desc,
                       t.notes_cancel cancel_reason_notes,
                       l_cancel_reason label_cancel_reason,
                       l_reason_notes label_reason_notes,
                       t.flg_laterality flg_laterality,
                       pk_sysdomain.get_domain('REHAB_PRESC.FLG_LATERALITY', t.flg_laterality, i_lang) desc_laterality,
                       pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', t.id_intervention) flg_laterality_mcdt,
                       t.id_codification id_codification,
                       pk_translation.get_translation(i_lang, 'CODIFICATION.CODE_CODIFICATION.' || t.id_codification) codification,
                       NULL id_mcdt_codification,
                       t.flg_priority flg_priority,
                       pk_not_order_reason_db.get_not_order_reason_desc(i_lang             => i_lang,
                                                                        i_not_order_reason => t.id_not_order_reason) not_order_reason_desc,
                       flg_clinical_question
                  FROM (SELECT rp.id_rehab_presc,
                               rp.id_rehab_area_interv,
                               i.id_intervention,
                               i.code_intervention,
                               rai.id_rehab_area,
                               rp.id_professional,
                               rp.dt_rehab_presc,
                               rsn.id_rehab_sch_need,
                               rsn.sessions,
                               rp.flg_status,
                               rp.id_exec_institution,
                               rp.notes,
                               rst.code_rehab_session_type,
                               ins.abbreviation,
                               ins.code_institution,
                               rsn.id_episode_origin,
                               rp.id_cancel_reason,
                               rp.notes_cancel,
                               rp.flg_laterality,
                               rp.id_codification,
                               rsn.flg_priority,
                               rp.id_not_order_reason,
                               decode((SELECT COUNT(1)
                                        FROM rehab_question_response rqr
                                       WHERE rqr.id_rehab_presc = rp.id_rehab_presc),
                                      0,
                                      pk_alert_constant.g_no,
                                      pk_alert_constant.g_yes) flg_clinical_question
                          FROM rehab_presc rp
                          JOIN rehab_sch_need rsn
                            ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                          JOIN rehab_area_interv rai
                            ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                          JOIN intervention i
                            ON i.id_intervention = rai.id_intervention
                          LEFT JOIN rehab_session_type rst
                            ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                          LEFT JOIN institution ins
                            ON rp.id_exec_institution = ins.id_institution
                        --dummy sch_need for treatments without instructions
                         WHERE rsn.flg_status = g_rehab_sch_need_dummy
                           AND EXISTS (SELECT 0
                                  FROM rehab_session rs
                                 WHERE rs.id_rehab_presc = rp.id_rehab_presc
                                      -- show execution of treatments not prescribed just for current episode
                                   AND rs.id_episode IN (SELECT /*+ OPT_ESTIMATE(TABLE xepis ROWS=1) */
                                                          column_value
                                                           FROM TABLE(i_id_episode) xepis)
                                --= i_id_episode--
                                )) t
                
                ) xsql;
    
        RETURN tbl_return;
    
    END get_rehab_treat_plan2;

    FUNCTION get_rehab_treat_plan1
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_patient        IN rehab_plan.id_patient%TYPE,
        i_id_episode        IN table_number,
        i_id_episode_origin IN NUMBER
        --i_reports    IN VARCHAR2
    ) RETURN t_tbl_rehab_treat IS
        l_func_name      CONSTANT VARCHAR2(30) := 'get_rehab_treat_plan1';
        l_type_session   CONSTANT VARCHAR2(30) := 'S';
        l_type_treatment CONSTANT VARCHAR2(30) := 'T';
        l_has_notes     sys_message.desc_message%TYPE;
        l_dt_begin      TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end        TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_id_schedule   rehab_schedule.id_schedule%TYPE;
        l_id_epis_type  episode.id_epis_type%TYPE;
        l_prof_cat      category.id_category%TYPE;
        l_all_epis      table_number;
        l_cancel_reason sys_message.desc_message%TYPE;
        l_reason_notes  sys_message.desc_message%TYPE;
        tbl_return      t_tbl_rehab_treat;
    BEGIN
        g_error := 'BEGIN i_id_patient=' || i_id_patient;
        pk_alertlog.log_debug(g_error, g_package_name, l_func_name);
    
        g_sysdate_tstz := current_timestamp;
    
        l_has_notes     := pk_message.get_message(i_lang, i_prof, 'COMMON_M097');
        l_cancel_reason := pk_message.get_message(i_lang, 'DETAIL_COMMON_M006');
        l_reason_notes  := pk_message.get_message(i_lang, 'COMMON_M073');
    
        g_error    := 'Call pk_prof_utils.get_categoyr i_prof.id=' || i_prof.id;
        l_prof_cat := pk_prof_utils.get_id_category(i_lang => i_lang, i_prof => i_prof);
    
        l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
        l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
    
        SELECT t_rec_rehab_treat(rec_type                  => rec_type,
                                 id_rehab_presc            => id_rehab_presc,
                                 id_rehab_sch_need         => id_rehab_sch_need,
                                 id_rehab_area_interv      => id_rehab_area_interv,
                                 id_intervention           => id_intervention,
                                 desc_interv               => desc_interv,
                                 desc_area                 => desc_area,
                                 id_rehab_area             => id_rehab_area,
                                 prof_requested            => prof_requested,
                                 id_prof_requested         => id_prof_requested,
                                 dt_requested_str          => dt_requested_str,
                                 dt_requested              => dt_requested,
                                 icon                      => icon,
                                 icon_label                => icon_label,
                                 icon_color                => icon_color,
                                 back_color                => back_color,
                                 flg_status                => flg_status,
                                 id_exec_institution       => id_exec_institution,
                                 exec_institution          => exec_institution,
                                 instructions              => instructions,
                                 has_notes                 => has_notes,
                                 notes                     => notes,
                                 flg_status_description    => flg_status_description,
                                 session_type              => session_type,
                                 execution_local           => execution_local,
                                 prof_name_requested       => prof_name_requested,
                                 prof_speciality_requested => prof_speciality_requested,
                                 cancel_reason_desc        => cancel_reason_desc,
                                 cancel_reason_notes       => cancel_reason_notes,
                                 label_cancel_reason       => label_cancel_reason,
                                 label_reason_notes        => label_reason_notes,
                                 flg_laterality            => flg_laterality,
                                 desc_laterality           => desc_laterality,
                                 flg_laterality_mcdt       => flg_laterality_mcdt,
                                 id_codification           => id_codification,
                                 codification              => codification,
                                 id_mcdt_codification      => id_mcdt_codification,
                                 flg_priority              => flg_priority,
                                 not_order_reason_desc     => not_order_reason_desc,
                                 flg_clinical_question     => flg_clinical_question)
          BULK COLLECT
          INTO tbl_return
          FROM (SELECT l_type_treatment AS rec_type,
                       t.id_rehab_presc,
                       t.id_rehab_sch_need,
                       t.id_rehab_area_interv,
                       t.id_intervention,
                       pk_procedures_api_db.get_alias_translation(i_lang, i_prof, t.code_intervention, NULL) desc_interv,
                       get_rehab_area_name(i_lang, t.id_rehab_area) desc_area,
                       t.id_rehab_area,
                       pk_prof_utils.get_nickname(i_lang, t.id_professional) prof_requested,
                       t.id_professional id_prof_requested,
                       pk_date_utils.dt_chr_date_hour_tsz(i_lang, t.dt_rehab_presc, i_prof) dt_requested_str,
                       t.dt_rehab_presc dt_requested,
                       decode(t.flg_status,
                              g_rehab_presc_referral,
                              decode(t.flg_referral,
                                     NULL,
                                     get_rp_icon(i_lang, NULL, t.id_rehab_sch_need, t.sessions, t.flg_status),
                                     pk_sysdomain.get_img(i_lang, 'INTERV_PRESC_DET.FLG_REFERRAL', t.flg_referral)),
                              pk_rehab.get_rp_icon(i_lang, NULL, t.id_rehab_sch_need, t.sessions, t.flg_status)) icon,
                       CASE
                            WHEN t.flg_status <> g_rehab_presc_finished THEN
                             get_rp_icon_label(i_lang, i_prof, t.id_rehab_presc, t.sessions, t.flg_status)
                        END icon_label,
                       pk_rehab.get_rp_back_color(i_lang, i_prof, t.id_rehab_presc, t.flg_status) back_color,
                       pk_rehab.get_rp_icon_color(i_lang, i_prof, t.id_rehab_presc, t.flg_status) icon_color,
                       decode(t.flg_status,
                              g_rehab_presc_referral,
                              decode(t.flg_referral, NULL, t.flg_status, g_rehab_presc_finished),
                              t.flg_status) flg_status,
                       t.id_exec_institution,
                       pk_utils.get_institution_name(i_lang, t.id_exec_institution) exec_institution,
                       get_instructions(i_lang, i_prof, t.id_rehab_sch_need) AS instructions,
                       nvl2(t.notes, l_has_notes, NULL) AS has_notes,
                       t.notes AS notes,
                       pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', t.flg_status, i_lang) flg_status_description,
                       pk_translation.get_translation(i_lang, t.code_rehab_session_type) session_type,
                       decode(t.abbreviation,
                              NULL,
                              pk_translation.get_translation(i_lang, t.code_institution),
                              t.abbreviation) execution_local,
                       pk_prof_utils.get_name(i_lang, t.id_professional) prof_name_requested,
                       pk_prof_utils.get_spec_signature(i_lang,
                                                        i_prof,
                                                        t.id_professional,
                                                        t.dt_rehab_presc,
                                                        t.id_episode_origin) prof_speciality_requested,
                       pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, t.id_cancel_reason) cancel_reason_desc,
                       t.notes_cancel cancel_reason_notes,
                       l_cancel_reason label_cancel_reason,
                       l_reason_notes label_reason_notes,
                       t.flg_laterality flg_laterality,
                       pk_sysdomain.get_domain('REHAB_PRESC.FLG_LATERALITY', t.flg_laterality, i_lang) desc_laterality,
                       pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', t.id_intervention) flg_laterality_mcdt,
                       t.id_codification id_codification,
                       pk_translation.get_translation(i_lang, 'CODIFICATION.CODE_CODIFICATION.' || t.id_codification) codification,
                       NULL id_mcdt_codification,
                       t.flg_priority flg_priority,
                       pk_not_order_reason_db.get_not_order_reason_desc(i_lang             => i_lang,
                                                                        i_not_order_reason => t.id_not_order_reason) not_order_reason_desc,
                       flg_clinical_question
                  FROM (SELECT rp.id_rehab_presc,
                               x.id_rehab_area_interv,
                               x.id_intervention,
                               x.code_intervention,
                               x.id_rehab_area,
                               rp.id_professional,
                               rp.dt_rehab_presc,
                               rp.flg_status,
                               rp.flg_referral,
                               rsn.id_rehab_sch_need,
                               rsn.sessions,
                               rp.id_exec_institution,
                               rp.notes,
                               rst.code_rehab_session_type,
                               ins.abbreviation,
                               ins.code_institution,
                               rsn.id_episode_origin,
                               rp.id_cancel_reason,
                               rp.notes_cancel,
                               rp.flg_laterality,
                               rp.id_codification,
                               rsn.flg_priority,
                               rp.id_not_order_reason,
                               decode((SELECT COUNT(1)
                                        FROM rehab_question_response rqr
                                       WHERE rqr.id_rehab_presc = rp.id_rehab_presc),
                                      0,
                                      pk_alert_constant.g_no,
                                      pk_alert_constant.g_yes) flg_clinical_question
                          FROM rehab_presc rp
                          JOIN (SELECT /*+ opt_estimate(table xsql rows=1) */
                                xsql.*
                                 FROM TABLE(pk_rehab.find_rehab_interv(i_prof.institution, i_prof.software)) xsql) x
                            ON x.id_rehab_area_interv = rp.id_rehab_area_interv
                          JOIN rehab_sch_need rsn
                            ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                          JOIN rehab_session_type rst
                            ON rsn.id_rehab_session_type = rst.id_rehab_session_type
                          LEFT JOIN institution ins
                            ON (rp.id_exec_institution = ins.id_institution)
                         WHERE ((rsn.id_episode_origin = i_id_episode_origin AND l_prof_cat <> 25) OR
                               (rsn.id_episode_origin IN ((SELECT /*+ opt_estimate(table x2 rows=1) */
                                                            column_value
                                                             FROM TABLE(l_all_epis) x2)) AND l_prof_cat = 25))
                           AND rsn.flg_status <> g_rehab_sch_need_dummy -- To ignore created records when executed treatments not prescribed 
                           AND ((rp.flg_status != g_rehab_presc_finished OR
                               (rp.flg_status = g_rehab_presc_finished AND
                               (rp.dt_rehab_presc BETWEEN l_dt_begin AND l_dt_end))))) t) xsql;
    
        RETURN tbl_return;
    
    END get_rehab_treat_plan1;

    FUNCTION get_rehab_treat_plan_all
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_patient        IN rehab_plan.id_patient%TYPE,
        i_id_episode        IN table_number,
        i_id_episode_origin IN NUMBER
    ) RETURN t_tbl_rehab_treat IS
        tbl_part1  t_tbl_rehab_treat := t_tbl_rehab_treat();
        tbl_part2  t_tbl_rehab_treat := t_tbl_rehab_treat();
        tbl_return t_tbl_rehab_treat := t_tbl_rehab_treat();
    BEGIN
    
        tbl_part1 := pk_rehab.get_rehab_treat_plan1(i_lang              => i_lang,
                                                    i_prof              => i_prof,
                                                    i_id_patient        => i_id_patient,
                                                    i_id_episode        => i_id_episode,
                                                    i_id_episode_origin => i_id_episode_origin);
    
        tbl_part2 := pk_rehab.get_rehab_treat_plan2(i_lang       => i_lang,
                                                    i_prof       => i_prof,
                                                    i_id_patient => i_id_patient,
                                                    i_id_episode => i_id_episode);
    
        tbl_return := tbl_part1 MULTISET UNION ALL tbl_part2;
        RETURN tbl_return;
    
    END get_rehab_treat_plan_all;

    FUNCTION order_by_treat(i_flg_status IN VARCHAR2) RETURN NUMBER IS
        l_return NUMBER;
    BEGIN
    
        CASE i_flg_status
            WHEN g_rehab_presc_not_order_reas THEN
                l_return := 5;
            WHEN g_rehab_presc_cancel THEN
                l_return := 10;
            WHEN g_rehab_presc_discontinued THEN
                l_return := 20;
            WHEN g_rehab_presc_disc_prop THEN
                l_return := 20;
            WHEN g_rehab_presc_finished THEN
                l_return := 30;
            WHEN g_rehab_presc_suspend THEN
                l_return := 40;
            WHEN g_rehab_presc_susp_prop THEN
                l_return := 40;
            WHEN g_rehab_presc_ongoing THEN
                l_return := 50;
            WHEN g_rehab_presc_begin THEN
                l_return := 60;
            ELSE
                l_return := 100;
        END CASE;
    
        RETURN l_return;
    
    END order_by_treat;

    FUNCTION set_my_epis_responsability
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_prof_to    IN professional.id_professional%TYPE,
        i_id_episode IN episode.id_episode%TYPE,
        i_notes      IN epis_prof_resp.notes_clob%TYPE,
        i_prof_cat   IN epis_prof_resp.flg_type%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200 CHAR) := 'SET_MY_EPIS_RESPONSABILITY_1';
        l_internal_error EXCEPTION;
        l_flg_show  VARCHAR2(1);
        l_msg_title sys_message.desc_message%TYPE;
        l_msg_body  sys_message.desc_message%TYPE;
    BEGIN
    
        g_error := 'CALL TO PK_HAND_OFF.CREATE_EPIS_PROF_RESP';
        pk_alertlog.log_debug(g_error);
        RETURN pk_hand_off.create_epis_prof_resp(i_lang          => i_lang,
                                                 i_prof          => i_prof,
                                                 i_prof_to       => table_varchar(i_prof_to),
                                                 i_tot_epis      => table_number(1),
                                                 i_epis_pat      => table_number(i_id_episode),
                                                 i_cs_or_dept    => table_number(NULL),
                                                 i_notes         => table_varchar(i_notes),
                                                 i_flg_type      => i_prof_cat,
                                                 i_flg_resp      => 'G',
                                                 i_flg_profile   => NULL,
                                                 i_sysdate       => NULL,
                                                 i_id_speciality => NULL,
                                                 i_sbar_note     => NULL,
                                                 o_flg_show      => l_flg_show,
                                                 o_msg_title     => l_msg_title,
                                                 o_msg_body      => l_msg_body,
                                                 o_error         => o_error);
    
    END set_my_epis_responsability;

    FUNCTION set_rehab_resp
    (
        i_lang IN NUMBER,
        i_prof IN profissional,
        --i_id_view     IN VARCHAR2,
        i_id_episode  IN NUMBER,
        i_id_schedule IN NUMBER,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_ret     BOOLEAN;
        l_profile profile_template%ROWTYPE;
    BEGIN
    
        l_profile := pk_access.get_profile(i_prof => i_prof);
    
        l_ret := set_my_epis_responsability(i_lang       => i_lang,
                                            i_prof       => i_prof,
                                            i_prof_to    => i_prof.id,
                                            i_id_episode => i_id_episode,
                                            i_notes      => '',
                                            i_prof_cat   => l_profile.flg_type,
                                            o_error      => o_error);
    
        RETURN l_ret;
    
    END set_rehab_resp;

    PROCEDURE init_params_patient_grids2
    (
        i_filter_name   IN VARCHAR2,
        i_custom_filter IN NUMBER,
        i_context_ids   IN table_number,
        i_context_keys  IN table_varchar DEFAULT NULL,
        i_context_vals  IN table_varchar,
        i_name          IN VARCHAR2,
        o_vc2           OUT VARCHAR2,
        o_num           OUT NUMBER,
        o_id            OUT NUMBER,
        o_tstz          OUT TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
        g_lang             CONSTANT NUMBER(24) := 1;
        g_prof_id          CONSTANT NUMBER(24) := 2;
        g_prof_institution CONSTANT NUMBER(24) := 3;
        g_prof_software    CONSTANT NUMBER(24) := 4;
        l_lang             CONSTANT language.id_language%TYPE := i_context_ids(g_lang);
        l_prof             CONSTANT profissional := profissional(i_context_ids(g_prof_id),
                                                                 i_context_ids(g_prof_institution),
                                                                 pk_alert_constant.g_soft_rehab);
    
        --FILTER_BIND
        l_id_category prof_cat.id_category%TYPE;
        l_dt_begin    TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end      TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_today    TIMESTAMP(6) WITH LOCAL TIME ZONE;
    
        l_sysdate_tstz TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_sysdate_char VARCHAR(50 CHAR);
    
        l_flg_sch_type_cr      schedule.flg_sch_type%TYPE := 'CR';
        l_epis_type_rehab_ap   epis_type.id_epis_type%TYPE := 25;
        l_show_med_disch       sys_config.value%TYPE;
        l_scfg_rehab_needs_sch sys_config.value%TYPE;
    
        l_date_selected      VARCHAR2(20 CHAR);
        l_date_selected_tstz TIMESTAMP(6) WITH LOCAL TIME ZONE;
    
        l_lov_filter       NUMBER;
        l_ori_type         NUMBER;
        l_profile_template NUMBER;
    
        o_error t_error_out;
    
        PROCEDURE set_echo_parameter
        (
            i_name IN VARCHAR2,
            i_val  IN VARCHAR2
        ) IS
        BEGIN
        
            pk_context_api.set_parameter(i_name, i_val);
        
        END set_echo_parameter;
    
    BEGIN
    
        l_sysdate_tstz := current_timestamp; --systimestamp;
        l_sysdate_char := pk_date_utils.date_send_tsz(l_lang, l_sysdate_tstz, l_prof);
    
        l_profile_template := pk_prof_utils.get_prof_profile_template(l_prof);
    
        IF l_profile_template = g_cdc_prof_templ
        THEN
            l_flg_sch_type_cr    := 'PC'; --chemical dependency counselour appointments
            l_epis_type_rehab_ap := 28;
        ELSIF l_profile_template = g_speech_prof_templ
        THEN
            l_flg_sch_type_cr    := 'ST'; --SPEECH THERAPY appointments
            l_epis_type_rehab_ap := 29; --epis_type SPEECH appointments
        ELSIF l_profile_template = g_occupational_prof_templ
        THEN
            l_flg_sch_type_cr    := 'OT'; --OCCUPATIONAL THERAPY appointments
            l_epis_type_rehab_ap := 30; --epis_type OCCUPATIONL appointments
        ELSIF l_profile_template = g_coordinator_prof_templ
        THEN
            l_flg_sch_type_cr    := ''; --Rehab appointments
            l_epis_type_rehab_ap := g_all; --epis_type Rehab appointments
        
        ELSE
            l_flg_sch_type_cr    := 'CR'; --Rehab appointments
            l_epis_type_rehab_ap := 25; --epis_type Rehab appointments
        END IF;
    
        set_echo_parameter('l_is_treatment', 'N');
        set_echo_parameter('l_get_all', 'Y');
    
        IF i_context_vals IS NOT NULL
        THEN
            IF i_context_vals.count > 0
            THEN
                l_date_selected := i_context_vals(1);
            ELSE
                l_date_selected := l_sysdate_char;
            END IF;
            IF i_context_vals.count > 1
            THEN
            
                IF i_context_vals(2) < g_filter_lov_all
                THEN
                    pk_context_api.set_parameter('l_is_treatment', 'Y');
                    pk_context_api.set_parameter('l_get_all', 'N');
                    IF i_context_vals(2) = g_all
                    THEN
                        l_ori_type := NULL;
                    ELSE
                        l_ori_type := i_context_vals(2);
                    END IF;
                
                    l_lov_filter := 0;
                ELSIF i_context_vals(2) = g_filter_lov_outp
                THEN
                    pk_context_api.set_parameter('l_get_all', 'N');
                    l_ori_type := NULL;
                    CASE l_prof.software
                        WHEN pk_alert_constant.g_soft_social THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_social;
                        WHEN pk_alert_constant.g_soft_nutritionist THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_dietitian;
                        WHEN pk_alert_constant.g_soft_psychologist THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_psychologist;
                        WHEN pk_alert_constant.g_soft_resptherap THEN
                            l_lov_filter := pk_alert_constant.g_epis_type_resp_therapist;
                        WHEN pk_alert_constant.g_soft_rehab THEN
                            l_lov_filter := l_epis_type_rehab_ap;
                        ELSE
                            l_lov_filter := i_context_vals(2);
                    END CASE;
                ELSIF i_context_vals(2) = g_filter_lov_hhc
                THEN
                    pk_context_api.set_parameter('l_get_all', 'N');
                    l_ori_type   := NULL;
                    l_lov_filter := pk_alert_constant.g_epis_type_home_health_care;
                ELSE
                    pk_context_api.set_parameter('l_get_all', 'Y');
                    l_ori_type   := NULL;
                    l_lov_filter := g_all;
                END IF;
            ELSE
                l_ori_type   := NULL;
                l_lov_filter := g_all;
            END IF;
        
        ELSE
            l_date_selected := l_sysdate_char;
        END IF;
    
        -- l_date_selected_tstz := l_date_selected; -- pk_date_utils.get_string_tstz(l_lang, l_prof, l_date_selected, NULL);
    
        l_id_category := pk_prof_utils.get_id_category(i_lang => l_lang, i_prof => l_prof);
    
        --l_dt_begin := pk_date_utils.trunc_insttimezone(l_prof, l_date_selected_tstz);
        --l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
    
        l_dt_today := pk_date_utils.trunc_insttimezone(l_prof, current_timestamp);
    
        l_show_med_disch       := nvl(pk_sysconfig.get_config('SHOW_MEDICAL_DISCHARGED_GRID', l_prof),
                                      pk_alert_constant.g_yes);
        l_scfg_rehab_needs_sch := pk_sysconfig.get_config('REHAB_NEEDS_SCHEDULE', l_prof);
    
        set_echo_parameter('l_lang', l_lang);
        set_echo_parameter('l_prof_id', l_prof.id);
        set_echo_parameter('l_prof_institution', l_prof.institution);
        set_echo_parameter('l_prof_software', pk_alert_constant.g_soft_rehab);
        set_echo_parameter('l_id_category', l_id_category);
        set_echo_parameter('l_dt_begin', l_date_selected);
        set_echo_parameter('l_dt_end', l_date_selected);
        set_echo_parameter('l_flg_sch_type_cr', l_flg_sch_type_cr);
        set_echo_parameter('l_epis_type_rehab_ap', l_epis_type_rehab_ap);
        set_echo_parameter('l_show_med_disch', l_show_med_disch);
        set_echo_parameter('l_scfg_rehab_needs_sch', l_scfg_rehab_needs_sch);
        set_echo_parameter('l_dt_today', l_dt_today);
    
        CASE i_name
            WHEN 'l_lang' THEN
                o_vc2 := to_char(l_lang);
            WHEN 'l_prof_id' THEN
                o_vc2 := to_char(l_prof.id);
            WHEN 'l_prof_institution' THEN
                o_vc2 := to_char(l_prof.institution);
            WHEN 'l_prof_software' THEN
                o_vc2 := to_char(pk_alert_constant.g_soft_rehab);
            WHEN 'l_sysdate_char' THEN
                o_vc2 := l_sysdate_char;
            WHEN 'l_sysdate_tstz' THEN
                o_tstz := l_sysdate_tstz;
            WHEN 'l_id_category' THEN
                o_vc2 := to_char(l_id_category);
            WHEN 'l_dt_begin' THEN
                o_tstz := l_dt_begin;
            WHEN 'l_dt_end' THEN
                o_tstz := l_dt_end;
            WHEN 'l_ori_type' THEN
                o_vc2 := l_ori_type;
            WHEN 'l_epis_type' THEN
                o_vc2 := l_lov_filter;
            WHEN 'l_profile_template' THEN
                o_num := l_profile_template;
            ELSE
                NULL;
        END CASE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => l_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => 'ALERT',
                                              i_package  => 'PK_REHAB',
                                              i_function => 'INIT_PARAMS_PATIENT_GRIDS',
                                              o_error    => o_error);
        
    END init_params_patient_grids2;

    PROCEDURE init_params_rehab_search
    (
        i_filter_name   IN VARCHAR2,
        i_custom_filter IN NUMBER,
        i_context_ids   IN table_number,
        i_context_keys  IN table_varchar DEFAULT NULL,
        i_context_vals  IN table_varchar,
        i_name          IN VARCHAR2,
        o_vc2           OUT VARCHAR2,
        o_num           OUT NUMBER,
        o_id            OUT NUMBER,
        o_tstz          OUT TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
        g_lang             CONSTANT NUMBER(24) := 1;
        g_prof_id          CONSTANT NUMBER(24) := 2;
        g_prof_institution CONSTANT NUMBER(24) := 3;
        g_prof_software    CONSTANT NUMBER(24) := 4;
        g_episode          CONSTANT NUMBER(24) := 5;
        g_patient          CONSTANT NUMBER(24) := 6;
        l_lang             CONSTANT language.id_language%TYPE := i_context_ids(g_lang);
        l_prof             CONSTANT profissional := profissional(i_context_ids(g_prof_id),
                                                                 i_context_ids(g_prof_institution),
                                                                 i_context_ids(g_prof_software));
    
        l_episode    episode.id_episode%TYPE := i_context_ids(g_episode);
        l_id_patient patient.id_patient%TYPE := i_context_ids(g_patient);
    
        l_codification codification.id_codification%TYPE;
        l_keyword      VARCHAR2(200 CHAR);
    
        l_id_dept dept.id_dept%TYPE;
    
        l_error t_error_out;
    BEGIN
    
        IF i_context_vals IS NOT NULL
           AND i_context_vals.count > 0
        THEN
            l_keyword := i_context_vals(1);
            BEGIN
                l_codification := i_context_vals(2);
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
        END IF;
    
        l_id_dept := pk_complaint.get_id_department(l_lang, l_prof, l_episode) (1);
    
        pk_context_api.set_parameter('i_lang', l_lang);
        pk_context_api.set_parameter('i_prof_id', l_prof.id);
        pk_context_api.set_parameter('i_prof_institution', l_prof.institution);
        pk_context_api.set_parameter('i_prof_software', l_prof.software);
        pk_context_api.set_parameter('i_patient', l_id_patient);
        pk_context_api.set_parameter('i_codification', l_codification);
        pk_context_api.set_parameter('i_keyword', l_keyword);
        pk_context_api.set_parameter('i_department', l_id_dept);
    
        CASE i_name
            WHEN 'l_lang' THEN
                o_vc2 := to_char(l_lang);
        END CASE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => l_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => 'ALERT',
                                              i_package  => 'PK_REHAB',
                                              i_function => 'INIT_PARAMS_REHAB_SEARCH',
                                              o_error    => l_error);
        
    END init_params_rehab_search;

    FUNCTION get_rehab_treatment_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER, -- edit, new, submit
        i_root_name      IN VARCHAR2, -- root of dynamic screen
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number, -- id necessary for identifying pk for editing
        i_tbl_mkt_rel    IN table_number, -- components needed for default/edit
        i_value          IN table_table_varchar,
        i_value_mea      IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
    
        tbl_result              t_tbl_ds_get_value := t_tbl_ds_get_value();
        tbl_default_institution t_tbl_core_domain := t_tbl_core_domain();
        l_rehab_area_interv     VARCHAR2(1000 CHAR);
    
        l_curr_comp_int_name   ds_component.internal_name%TYPE;
        l_ds_internal_name     ds_component.internal_name%TYPE;
        l_id_ds_component      ds_component.id_ds_component%TYPE;
        l_ds_internal_name_aux ds_component.internal_name%TYPE;
        l_min_value            ds_cmpt_mkt_rel.min_value%TYPE;
        l_max_value            ds_cmpt_mkt_rel.max_value%TYPE;
    
        l_id_unit_measure unit_measure.id_unit_measure%TYPE;
    
        l_reason_not_ordering sys_config.id_sys_config%TYPE := pk_sysconfig.get_config(i_code_cf => 'SHOW_REASON_NOT_ORDERING',
                                                                                       i_prof    => i_prof);
    
        c_rehab_treatment    pk_types.cursor_type;
        l_tbl_treatment_edit tbl_treatment_edit;
    
        l_curr_val VARCHAR2(4000) := NULL;
        l_aux_val  VARCHAR2(4000) := NULL;
    
        l_import_data_mode  BOOLEAN := FALSE;
        l_id_rehab_sch_need rehab_sch_need.id_rehab_sch_need%TYPE;
        l_id_rehab_presc    rehab_presc.id_rehab_presc%TYPE;
    
        l_exemption_desc VARCHAR2(1000 CHAR);
        l_id_exemption   NUMBER(24);
        l_id_market      market.id_market%TYPE;
    
        --PATIENT INFORMATION
        l_pat_name                patient.name%TYPE;
        l_gender                  patient.gender%TYPE;
        l_desc_gender             VARCHAR2(100);
        l_dt_birth                VARCHAR2(100);
        l_dt_deceased             VARCHAR2(100);
        l_flg_migrator            pat_soc_attributes.flg_migrator%TYPE;
        l_id_country_nation       country.alpha2_code%TYPE;
        l_sns                     pat_health_plan.num_health_plan%TYPE;
        l_valid_sns               VARCHAR2(100);
        l_flg_occ_disease         VARCHAR2(100);
        l_flg_independent         VARCHAR2(100);
        l_hp_entity               VARCHAR2(100);
        l_flg_recm                VARCHAR2(100);
        l_main_phone              VARCHAR2(100);
        l_hp_alpha2_code          VARCHAR2(100);
        l_hp_country_desc         VARCHAR2(100);
        l_hp_national_ident_nbr   VARCHAR2(100);
        l_hp_dt_effective         VARCHAR2(100);
        l_valid_hp                VARCHAR2(100);
        l_flg_type_hp             health_plan.flg_type%TYPE;
        l_hp_id_content           health_plan.id_content%TYPE;
        l_hp_inst_ident_nbr       pat_health_plan.inst_identifier_number%TYPE;
        l_hp_inst_ident_desc      pat_health_plan.inst_identifier_desc%TYPE;
        l_hp_dt_valid             VARCHAR2(100);
        l_beneficiary_number      VARCHAR2(1000 CHAR);
        l_id_health_coverage_plan NUMBER(24);
        l_id_financial_entity     NUMBER(24);
        l_id_pat_health_plan      NUMBER(24);
    
        FUNCTION get_control_validation RETURN VARCHAR2 IS
        
            l_count          PLS_INTEGER := 0;
            l_flg_event_type ds_def_event.flg_event_type%TYPE;
            l_internal_name  ds_component.internal_name%TYPE;
        
        BEGIN
            --1 - Check if the return structure has any invalid element, or if it has any empty mandatory element
            --If there is, then return error ('E')
            FOR i IN tbl_result.first .. tbl_result.last
            LOOP
                IF tbl_result(i).flg_validation = pk_orders_constant.g_component_error
                THEN
                    RETURN pk_orders_constant.g_component_error;
                ELSIF tbl_result(i).flg_event_type = pk_orders_constant.g_component_mandatory
                       AND tbl_result(i).value IS NULL
                THEN
                    RETURN pk_orders_constant.g_component_error;
                END IF;
            END LOOP;
        
            --2 - Check for the remaining elements of the form (which are not included in the return structure)
            -- if it has any empty mandatory element, or if the frequency field is invalid
            FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
            LOOP
            
                SELECT COUNT(1)
                  INTO l_count
                  FROM TABLE(tbl_result) t
                 WHERE t.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
            
                --If l_count = 0 it means we are dealing with an element that is not included in the return structure
                IF l_count = 0
                THEN
                    SELECT def.flg_event_type
                      INTO l_flg_event_type
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) t
                      LEFT JOIN ds_def_event def
                        ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
                     WHERE t.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
                
                    IF l_flg_event_type = pk_orders_constant.g_component_mandatory
                       AND i_value(i) (1) IS NULL
                    THEN
                        RETURN pk_orders_constant.g_component_error;
                    END IF;
                
                    l_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                
                    IF l_internal_name = pk_orders_constant.g_ds_frequency_sessions
                    THEN
                        FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                        LOOP
                            IF pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j)) =
                               pk_orders_constant.g_ds_number_sessions
                            THEN
                                IF to_number(i_value(i) (1)) > to_number(i_value(j) (1))
                                THEN
                                    RETURN pk_orders_constant.g_component_error;
                                END IF;
                            END IF;
                        END LOOP;
                    ELSIF l_internal_name = pk_orders_constant.g_ds_clinical_purpose
                    THEN
                        IF to_number(i_value(i) (1)) = 0
                        THEN
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                IF pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j)) =
                                   pk_orders_constant.g_ds_clinical_purpose_ft
                                THEN
                                    IF i_value(j) (1) IS NULL
                                    THEN
                                        RETURN pk_orders_constant.g_component_error;
                                    END IF;
                                END IF;
                            END LOOP;
                        END IF;
                    ELSIF l_internal_name = pk_orders_constant.g_ds_start_date_medium
                    THEN
                        IF pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                           i_date1 => pk_date_utils.get_string_tstz(i_lang,
                                                                                                    i_prof,
                                                                                                    i_value(i) (1),
                                                                                                    NULL),
                                                           i_date2 => g_sysdate_tstz - 1) = 'L'
                        THEN
                            RETURN pk_orders_constant.g_component_error;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        
            RETURN pk_orders_constant.g_component_valid;
        EXCEPTION
            WHEN OTHERS THEN
                RETURN pk_orders_constant.g_component_valid;
        END get_control_validation;
    
    BEGIN
    
        g_sysdate_tstz := nvl(g_sysdate_tstz, current_timestamp);
    
        l_id_market := pk_utils.get_institution_market(i_lang, i_prof.institution);
    
        IF (i_action IS NULL OR i_action IN (-1))
        THEN
            FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
            LOOP
                l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                l_id_ds_component  := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
            
                IF l_ds_internal_name = pk_orders_constant.g_ds_place_service
                THEN
                    SELECT listagg(t.column_value, '|')
                      INTO l_rehab_area_interv
                      FROM TABLE(i_tbl_id_pk) t;
                
                    tbl_default_institution := pk_rehab.get_rehab_inst(i_lang    => i_lang,
                                                                       i_prof    => i_prof,
                                                                       i_intervs => pk_orders_utils.get_piped_rehab_interv(i_lang              => i_lang,
                                                                                                                           i_prof              => i_prof,
                                                                                                                           i_rehab_area_interv => l_rehab_area_interv),
                                                                       i_default => pk_alert_constant.g_yes);
                
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_exemption
                THEN
                    IF NOT pk_orders_utils.get_pat_default_exemption(i_lang           => i_lang,
                                                                     i_prof           => i_prof,
                                                                     i_id_patient     => i_patient,
                                                                     i_current_date   => NULL,
                                                                     o_id_exemption   => l_id_exemption,
                                                                     o_exemption_desc => l_exemption_desc)
                    THEN
                        RAISE g_exception;
                    END IF;
                ELSIF l_ds_internal_name IN (pk_orders_constant.g_ds_financial_entity)
                THEN
                    IF l_id_market = pk_alert_constant.g_id_market_pt
                    THEN
                        IF NOT pk_adt.get_pat_info(i_lang                    => i_lang,
                                                   i_id_patient              => i_patient,
                                                   i_prof                    => i_prof,
                                                   i_id_episode              => i_episode,
                                                   i_flg_info_for_medication => CASE l_id_market
                                                                                    WHEN pk_alert_constant.g_id_market_pt THEN
                                                                                     pk_alert_constant.g_yes --To fetch the SNS
                                                                                    ELSE
                                                                                     NULL
                                                                                END,
                                                   o_name                    => l_pat_name,
                                                   o_gender                  => l_gender,
                                                   o_desc_gender             => l_desc_gender,
                                                   o_dt_birth                => l_dt_birth,
                                                   o_dt_deceased             => l_dt_deceased,
                                                   o_flg_migrator            => l_flg_migrator,
                                                   o_id_country_nation       => l_id_country_nation,
                                                   o_sns                     => l_sns,
                                                   o_valid_sns               => l_valid_sns,
                                                   o_flg_occ_disease         => l_flg_occ_disease,
                                                   o_flg_independent         => l_flg_independent,
                                                   o_num_health_plan         => l_beneficiary_number,
                                                   o_hp_entity               => l_hp_entity,
                                                   o_id_health_plan          => l_id_health_coverage_plan,
                                                   o_flg_recm                => l_flg_recm,
                                                   o_main_phone              => l_main_phone,
                                                   o_hp_alpha2_code          => l_hp_alpha2_code,
                                                   o_hp_country_desc         => l_hp_country_desc,
                                                   o_hp_national_ident_nbr   => l_hp_national_ident_nbr,
                                                   o_hp_dt_effective         => l_hp_dt_effective,
                                                   o_valid_hp                => l_valid_hp,
                                                   o_flg_type_hp             => l_flg_type_hp,
                                                   o_hp_id_content           => l_hp_id_content,
                                                   o_hp_inst_ident_nbr       => l_hp_inst_ident_nbr,
                                                   o_hp_inst_ident_desc      => l_hp_inst_ident_desc,
                                                   o_hp_dt_valid             => l_hp_dt_valid,
                                                   o_error                   => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    
                        IF l_beneficiary_number IS NOT NULL
                           AND l_valid_hp = pk_alert_constant.g_yes
                        THEN
                            BEGIN
                                SELECT hpe.id_health_plan_entity, php.id_pat_health_plan
                                  INTO l_id_financial_entity, l_id_pat_health_plan
                                  FROM pat_health_plan php
                                  JOIN health_plan hp
                                    ON php.id_health_plan = hp.id_health_plan
                                  LEFT JOIN health_plan_entity hpe
                                    ON hp.id_health_plan_entity = hpe.id_health_plan_entity
                                 WHERE php.num_health_plan = l_beneficiary_number
                                   AND php.id_patient = i_patient
                                   AND php.id_health_plan = l_id_health_coverage_plan
                                   AND php.id_institution = i_prof.institution
                                   AND php.flg_status = pk_alert_constant.g_active;
                            EXCEPTION
                                WHEN OTHERS THEN
                                    l_beneficiary_number      := NULL;
                                    l_id_pat_health_plan      := NULL;
                                    l_id_health_coverage_plan := NULL;
                            END;
                        ELSIF l_beneficiary_number IS NOT NULL
                              AND l_valid_hp = pk_alert_constant.g_no
                        THEN
                            l_beneficiary_number := NULL;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        
            --NEW FORM
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_tbl_records THEN
                                                                  (SELECT listagg(t.column_value, '|')
                                                                     FROM TABLE(i_tbl_id_pk) t)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_place_service THEN
                                                                  tbl_default_institution(1).domain_value
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_start_date_medium THEN
                                                                  pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => g_sysdate_tstz, i_prof => i_prof)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_edition THEN
                                                                  pk_alert_constant.g_no
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_reason_not_ordering_control THEN
                                                                  CASE
                                                                      WHEN l_reason_not_ordering = pk_alert_constant.g_yes THEN
                                                                       'Y'
                                                                      ELSE
                                                                       NULL
                                                                  END
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_exemption THEN
                                                                  to_char(l_id_exemption)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_financial_entity THEN
                                                                  to_char(l_id_financial_entity)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_coverage_plan THEN
                                                                  to_char(l_id_pat_health_plan)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_plan_number THEN
                                                                  to_char(l_beneficiary_number)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_id_record THEN
                                                                  to_char(i_tbl_id_pk(i_idx))
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_root_name THEN
                                                                  i_root_name
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => t.min_value,
                                       max_value          => t.max_value,
                                       desc_value         => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_place_service THEN
                                                                  tbl_default_institution(1).desc_domain
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_exemption THEN
                                                                  l_exemption_desc
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_financial_entity THEN
                                                                  decode(l_id_pat_health_plan,
                                                                         NULL,
                                                                         NULL,
                                                                         pk_adt.get_pat_health_plan_info(i_lang, i_prof, l_id_pat_health_plan, 'F'))
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_coverage_plan THEN
                                                                  decode(l_id_pat_health_plan,
                                                                         NULL,
                                                                         NULL,
                                                                         pk_adt.get_pat_health_plan_info(i_lang, i_prof, l_id_pat_health_plan, 'H'))
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_plan_number THEN
                                                                  to_char(l_beneficiary_number)
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_ok_button_control THEN
                                                                  pk_orders_constant.g_component_error
                                                                 ELSE
                                                                  pk_orders_constant.g_component_valid
                                                             END,
                                       err_msg            => NULL,
                                       flg_event_type     => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_coverage_plan THEN
                                                                  CASE l_id_market
                                                                      WHEN pk_alert_constant.g_id_market_pt THEN
                                                                       pk_orders_constant.g_component_mandatory
                                                                      ELSE
                                                                       pk_orders_constant.g_component_active
                                                                  END
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_plan_number THEN
                                                                  CASE
                                                                      WHEN l_beneficiary_number IS NOT NULL THEN
                                                                       pk_orders_constant.g_component_read_only
                                                                      ELSE
                                                                       pk_orders_constant.g_component_inactive
                                                                  END
                                                                 ELSE
                                                                  coalesce(def.flg_event_type, pk_orders_constant.g_component_active)
                                                             END,
                                       flg_multi_status   => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_id_record THEN
                                                                  pk_alert_constant.g_yes
                                                                 ELSE
                                                                  pk_alert_constant.g_no
                                                             END,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure,
                           dc.min_value,
                           dc.max_value
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN (pk_orders_constant.g_ds_reason_not_ordering_control,
                                       pk_orders_constant.g_ds_place_service,
                                       pk_orders_constant.g_ds_frequency_sessions,
                                       pk_orders_constant.g_ds_tbl_records,
                                       pk_orders_constant.g_ds_start_date_medium,
                                       pk_orders_constant.g_ds_edition,
                                       pk_orders_constant.g_ds_ok_button_control,
                                       pk_orders_constant.g_ds_exemption,
                                       pk_orders_constant.g_ds_health_plan_number,
                                       pk_orders_constant.g_ds_financial_entity,
                                       pk_orders_constant.g_ds_health_coverage_plan,
                                       pk_orders_constant.g_ds_id_record,
                                       pk_orders_constant.g_ds_root_name);
        
        ELSIF i_action = pk_dyn_form_constant.get_submit_action
        THEN
            --Action of submiting a value on any given element of the form
        
            --but First it is necessary to check if this submit refers to the action 'Import instructions'
            FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
            LOOP
                l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
            
                IF l_ds_internal_name = pk_orders_constant.g_ds_dummy_number
                THEN
                    IF i_value(i).exists(1)
                    THEN
                        IF i_value(i) (1) IS NOT NULL
                        THEN
                            l_import_data_mode := TRUE;
                            EXIT;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        
            IF l_import_data_mode = FALSE
            THEN
                --Action of submiting a value on any given element of the form
                IF i_curr_component IS NOT NULL
                THEN
                    l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_curr_component);
                    l_id_ds_component  := pk_orders_utils.get_id_ds_component(i_curr_component);
                
                    l_curr_val := pk_orders_utils.get_value(i_internal_name_child => l_ds_internal_name,
                                                            i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                            i_value               => i_value);
                
                    IF l_ds_internal_name = pk_orders_constant.g_ds_number_sessions
                    THEN
                        IF l_curr_val IS NOT NULL
                        THEN
                            SELECT d.min_value, d.max_value
                              INTO l_min_value, l_max_value
                              FROM ds_cmpt_mkt_rel d
                             WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_curr_component,
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_curr_val,
                                                                               value_clob         => NULL,
                                                                               min_value          => l_min_value,
                                                                               max_value          => l_max_value,
                                                                               desc_value         => l_curr_val || ' ' || CASE
                                                                                                         WHEN l_curr_val = '1' THEN
                                                                                                          pk_message.get_message(i_lang, 'PROCEDURES_MFR_T065')
                                                                                                         ELSE
                                                                                                          pk_message.get_message(i_lang, 'PROCEDURES_MFR_T066')
                                                                                                     END,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        END IF;
                    
                        FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                        LOOP
                            l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                        
                            IF l_ds_internal_name = pk_orders_constant.g_ds_frequency_sessions
                            THEN
                                l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                                l_id_unit_measure := to_number(i_value_mea(i) (1));
                            
                                SELECT d.min_value, d.max_value
                                  INTO l_min_value, l_max_value
                                  FROM ds_cmpt_mkt_rel d
                                 WHERE d.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
                            
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => l_ds_internal_name,
                                                                                   VALUE              => i_value(i) (1),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => l_min_value,
                                                                                   max_value          => l_max_value,
                                                                                   desc_value         => i_value_desc(i) (1),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => l_id_unit_measure,
                                                                                   desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang,
                                                                                                                                                      i_prof,
                                                                                                                                                      10375),
                                                                                   flg_validation     => CASE
                                                                                                             WHEN i_value(i) (1) IS NOT NULL THEN
                                                                                                              CASE
                                                                                                                  WHEN to_number(i_value(i) (1)) > to_number(l_curr_val) THEN
                                                                                                                   pk_orders_constant.g_component_error
                                                                                                                  ELSE
                                                                                                                   pk_orders_constant.g_component_valid
                                                                                                              END
                                                                                                         END,
                                                                                   err_msg            => CASE
                                                                                                             WHEN i_value(i) (1) IS NOT NULL THEN
                                                                                                              CASE
                                                                                                                  WHEN to_number(i_value(i) (1)) > to_number(l_curr_val) THEN
                                                                                                                   pk_message.get_message(i_lang, 'REHAB_T180')
                                                                                                                  ELSE
                                                                                                                   NULL
                                                                                                              END
                                                                                                         END,
                                                                                   flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                                   flg_multi_status   => pk_alert_constant.g_no,
                                                                                   idx                => i_idx);
                            END IF;
                        END LOOP;
                    ELSIF l_ds_internal_name = pk_orders_constant.g_ds_frequency_sessions
                    THEN
                        IF l_curr_val IS NOT NULL
                        THEN
                            l_aux_val         := pk_orders_utils.get_value(i_internal_name_child => pk_orders_constant.g_ds_number_sessions,
                                                                           i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                                           i_value               => i_value);
                            l_id_unit_measure := to_number(pk_orders_utils.get_value(i_internal_name_child => l_ds_internal_name,
                                                                                     i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                                                     i_value               => i_value_mea));
                        
                            SELECT d.min_value, d.max_value
                              INTO l_min_value, l_max_value
                              FROM ds_cmpt_mkt_rel d
                             WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_curr_component,
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_curr_val,
                                                                               value_clob         => NULL,
                                                                               min_value          => l_min_value,
                                                                               max_value          => l_max_value,
                                                                               desc_value         => l_curr_val || ' ' || CASE
                                                                                                         WHEN l_curr_val = '1' THEN
                                                                                                          pk_message.get_message(i_lang, 'REHAB_M005')
                                                                                                         ELSE
                                                                                                          pk_message.get_message(i_lang, 'REHAB_M006')
                                                                                                     END || ' ' || CASE l_id_unit_measure
                                                                                                         WHEN 10375 THEN --week
                                                                                                          pk_message.get_message(i_lang,
                                                                                                                                 'COMMON_M120')
                                                                                                         WHEN 1127 THEN --month
                                                                                                          pk_message.get_message(i_lang,
                                                                                                                                 'COMMON_M060')
                                                                                                         WHEN 1039 THEN --day
                                                                                                          pk_message.get_message(i_lang,
                                                                                                                                 'DAY_DESC')
                                                                                                     END,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => l_id_unit_measure,
                                                                               desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang,
                                                                                                                                                  i_prof,
                                                                                                                                                  10375),
                                                                               flg_validation     => CASE
                                                                                                         WHEN to_number(l_curr_val) > to_number(l_aux_val) THEN
                                                                                                          pk_orders_constant.g_component_error
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_valid
                                                                                                     END,
                                                                               err_msg            => CASE
                                                                                                         WHEN to_number(l_curr_val) > to_number(l_aux_val) THEN
                                                                                                          pk_message.get_message(i_lang, 'REHAB_T180')
                                                                                                         ELSE
                                                                                                          NULL
                                                                                                     END,
                                                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        END IF;
                    ELSIF l_ds_internal_name = pk_orders_constant.g_ds_start_date_medium
                    THEN
                        IF pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                           i_date1 => pk_date_utils.get_string_tstz(8,
                                                                                                    i_prof,
                                                                                                    l_curr_val,
                                                                                                    NULL),
                                                           i_date2 => g_sysdate_tstz - 1) = 'L'
                        THEN
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_curr_component,
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_curr_val,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_error,
                                                                               err_msg            => pk_message.get_message(i_lang,
                                                                                                                            'REHAB_T169'),
                                                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        END IF;
                    ELSIF l_ds_internal_name = pk_orders_constant.g_ds_health_coverage_plan
                    THEN
                        FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                        LOOP
                            l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j));
                        
                            IF l_ds_internal_name IN (pk_orders_constant.g_ds_health_coverage_plan)
                            THEN
                                l_id_health_coverage_plan := i_value(j) (1);
                            END IF;
                        END LOOP;
                    
                        FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                        LOOP
                            l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j));
                        
                            IF l_ds_internal_name IN (pk_orders_constant.g_ds_financial_entity)
                            THEN
                                l_id_financial_entity := i_value(j) (1);
                                IF l_id_financial_entity IS NULL
                                   AND l_id_health_coverage_plan IS NOT NULL
                                THEN
                                    SELECT hpe.id_health_plan_entity
                                      INTO l_id_financial_entity
                                      FROM pat_health_plan php
                                      JOIN health_plan hp
                                        ON php.id_health_plan = hp.id_health_plan
                                      LEFT JOIN health_plan_entity hpe
                                        ON hp.id_health_plan_entity = hpe.id_health_plan_entity
                                     WHERE php.id_pat_health_plan = l_id_health_coverage_plan;
                                END IF;
                            END IF;
                        END LOOP;
                    
                        FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                        LOOP
                            l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                        
                            IF l_ds_internal_name IN (pk_orders_constant.g_ds_health_plan_number)
                            THEN
                            
                                l_beneficiary_number := pk_orders_utils.get_patient_beneficiary_number(i_lang               => i_lang,
                                                                                                       i_prof               => i_prof,
                                                                                                       i_patient            => i_patient,
                                                                                                       i_health_plan_entity => l_id_financial_entity,
                                                                                                       i_health_plan        => l_id_health_coverage_plan);
                                IF l_beneficiary_number IS NOT NULL
                                THEN
                                
                                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                                    tbl_result.extend();
                                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                       id_ds_component    => l_id_ds_component,
                                                                                       internal_name      => l_ds_internal_name,
                                                                                       VALUE              => l_beneficiary_number,
                                                                                       value_clob         => NULL,
                                                                                       min_value          => NULL,
                                                                                       max_value          => NULL,
                                                                                       desc_value         => l_beneficiary_number,
                                                                                       desc_clob          => NULL,
                                                                                       id_unit_measure    => NULL,
                                                                                       desc_unit_measure  => NULL,
                                                                                       flg_validation     => 'Y',
                                                                                       err_msg            => NULL,
                                                                                       flg_event_type     => 'R',
                                                                                       flg_multi_status   => NULL,
                                                                                       idx                => i_idx);
                                ELSE
                                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                                    tbl_result.extend();
                                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                       id_ds_component    => l_id_ds_component,
                                                                                       internal_name      => l_ds_internal_name,
                                                                                       VALUE              => NULL,
                                                                                       value_clob         => NULL,
                                                                                       min_value          => NULL,
                                                                                       max_value          => NULL,
                                                                                       desc_value         => NULL,
                                                                                       desc_clob          => NULL,
                                                                                       id_unit_measure    => NULL,
                                                                                       desc_unit_measure  => NULL,
                                                                                       flg_validation     => 'Y',
                                                                                       err_msg            => NULL,
                                                                                       flg_event_type     => 'I',
                                                                                       flg_multi_status   => NULL,
                                                                                       idx                => i_idx);
                                END IF;
                            ELSIF l_ds_internal_name = pk_orders_constant.g_ds_financial_entity
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => l_ds_internal_name,
                                                                                   VALUE              => to_char(l_id_financial_entity),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => pk_adt.get_pat_health_plan_info(i_lang,
                                                                                                                                         i_prof,
                                                                                                                                         l_id_health_coverage_plan,
                                                                                                                                         'F'),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_alert_constant.g_yes,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE l_id_market
                                                                                                             WHEN
                                                                                                              pk_alert_constant.g_id_market_pt THEN
                                                                                                              'M'
                                                                                                             ELSE
                                                                                                              'A'
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END IF;
                        END LOOP;
                    ELSIF l_ds_internal_name = pk_orders_constant.g_ds_financial_entity
                    THEN
                        FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                        LOOP
                            l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                        
                            IF l_ds_internal_name IN (pk_orders_constant.g_ds_health_coverage_plan)
                            THEN
                                l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => l_ds_internal_name,
                                                                                   VALUE              => NULL,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => 'Y',
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE l_id_market
                                                                                                             WHEN
                                                                                                              pk_alert_constant.g_id_market_pt THEN
                                                                                                              'M'
                                                                                                             ELSE
                                                                                                              'A'
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            ELSIF l_ds_internal_name IN (pk_orders_constant.g_ds_health_plan_number)
                            THEN
                                l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => l_ds_internal_name,
                                                                                   VALUE              => NULL,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => 'Y',
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => 'I',
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END IF;
                        END LOOP;
                    END IF;
                ELSE
                    --SELECTING/UNSELECTING ITEMS IN THE VIEWER
                    FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                    
                        IF l_ds_internal_name IN (pk_orders_constant.g_ds_clinical_indication_ft,
                                                  pk_orders_constant.g_ds_notes,
                                                  pk_orders_constant.g_ds_additional_notes,
                                                  pk_orders_constant.g_ds_dummy_number,
                                                  pk_orders_constant.g_ds_executions_sessions,
                                                  pk_orders_constant.g_ds_exemption,
                                                  pk_orders_constant.g_ds_health_plan_number,
                                                  pk_orders_constant.g_ds_financial_entity,
                                                  pk_orders_constant.g_ds_health_coverage_plan,
                                                  pk_orders_constant.g_ds_id_record)
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            IF l_ds_internal_name = pk_orders_constant.g_ds_executions_sessions
                            THEN
                                SELECT d.min_value, d.max_value
                                  INTO l_min_value, l_max_value
                                  FROM ds_cmpt_mkt_rel d
                                 WHERE d.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
                            ELSE
                                l_min_value := NULL;
                                l_max_value := NULL;
                            END IF;
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => i_value(i) (1),
                                                                               value_clob         => NULL,
                                                                               min_value          => l_min_value,
                                                                               max_value          => l_max_value,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_ds_internal_name = pk_orders_constant.g_ds_health_plan_number THEN
                                                                                                          CASE
                                                                                                              WHEN i_value(i) (1) IS NULL THEN
                                                                                                               pk_orders_constant.g_component_inactive
                                                                                                              ELSE
                                                                                                               pk_orders_constant.g_component_read_only
                                                                                                          END
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_active
                                                                                                     END,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_start_date_medium
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                            IF pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                               i_date1 => pk_date_utils.get_string_tstz(8,
                                                                                                        i_prof,
                                                                                                        i_value(i) (1),
                                                                                                        NULL),
                                                               i_date2 => g_sysdate_tstz - 1) = 'L'
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => l_ds_internal_name,
                                                                                   VALUE              => i_value(i) (1),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_error,
                                                                                   err_msg            => pk_message.get_message(i_lang,
                                                                                                                                'REHAB_T169'),
                                                                                   flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                                   flg_multi_status   => pk_alert_constant.g_no,
                                                                                   idx                => i_idx);
                            ELSE
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => l_ds_internal_name,
                                                                                   VALUE              => i_value(i) (1),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => i_value_desc(i) (1),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                                   flg_multi_status   => pk_alert_constant.g_no,
                                                                                   idx                => i_idx);
                            END IF;
                        ELSIF l_ds_internal_name IN
                              (pk_orders_constant.g_ds_clinical_indication_mw, pk_orders_constant.g_ds_icf)
                        THEN
                            IF i_value(i).count > 0
                            THEN
                                FOR j IN i_value(i).first .. i_value(i).last
                                LOOP
                                    IF i_value(i).exists(j)
                                    THEN
                                        l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                                    
                                        tbl_result.extend();
                                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                           id_ds_component    => l_id_ds_component,
                                                                                           internal_name      => l_ds_internal_name,
                                                                                           VALUE              => to_char(i_value(i) (j)),
                                                                                           value_clob         => NULL,
                                                                                           min_value          => NULL,
                                                                                           max_value          => NULL,
                                                                                           desc_value         => i_value_desc(i) (j),
                                                                                           desc_clob          => NULL,
                                                                                           id_unit_measure    => NULL,
                                                                                           desc_unit_measure  => NULL,
                                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                                           err_msg            => NULL,
                                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                                           flg_multi_status   => pk_alert_constant.g_no,
                                                                                           idx                => i_idx);
                                    END IF;
                                END LOOP;
                            END IF;
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_clinical_purpose
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => i_value(i) (1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j));
                            
                                IF l_ds_internal_name = pk_orders_constant.g_ds_clinical_purpose_ft
                                THEN
                                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j));
                                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                       id_ds_component    => l_id_ds_component,
                                                                                       internal_name      => l_ds_internal_name,
                                                                                       VALUE              => i_value(j) (1),
                                                                                       value_clob         => NULL,
                                                                                       min_value          => NULL,
                                                                                       max_value          => NULL,
                                                                                       desc_value         => i_value_desc(j) (1),
                                                                                       desc_clob          => NULL,
                                                                                       id_unit_measure    => NULL,
                                                                                       desc_unit_measure  => NULL,
                                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                                       err_msg            => NULL,
                                                                                       flg_event_type     => CASE
                                                                                                                 WHEN to_number(i_value(i) (1)) = 0 THEN
                                                                                                                  pk_orders_constant.g_component_mandatory
                                                                                                                 ELSE
                                                                                                                  pk_orders_constant.g_component_inactive
                                                                                                             END,
                                                                                       flg_multi_status   => pk_alert_constant.g_no,
                                                                                       idx                => i_idx);
                                END IF;
                            END LOOP;
                        ELSIF l_ds_internal_name IN
                              (pk_orders_constant.g_ds_laterality, pk_orders_constant.g_ds_priority)
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => i_value(i) (1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_number_sessions
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            SELECT d.min_value, d.max_value
                              INTO l_min_value, l_max_value
                              FROM ds_cmpt_mkt_rel d
                             WHERE d.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => i_value(i) (1),
                                                                               value_clob         => NULL,
                                                                               min_value          => l_min_value,
                                                                               max_value          => l_max_value,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_frequency_sessions
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                            l_id_unit_measure := to_number(i_value_mea(i) (1));
                        
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                l_ds_internal_name_aux := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j));
                            
                                IF l_ds_internal_name_aux = pk_orders_constant.g_ds_number_sessions
                                THEN
                                    l_aux_val := i_value(j) (1);
                                    EXIT;
                                END IF;
                            END LOOP;
                        
                            SELECT d.min_value, d.max_value
                              INTO l_min_value, l_max_value
                              FROM ds_cmpt_mkt_rel d
                             WHERE d.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => i_value(i) (1),
                                                                               value_clob         => NULL,
                                                                               min_value          => l_min_value,
                                                                               max_value          => l_max_value,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => l_id_unit_measure,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => CASE
                                                                                                         WHEN to_number(i_value(i) (1)) > to_number(l_aux_val) THEN
                                                                                                          pk_orders_constant.g_component_error
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_valid
                                                                                                     END,
                                                                               err_msg            => CASE
                                                                                                         WHEN to_number(i_value(i) (1)) > to_number(l_aux_val) THEN
                                                                                                          pk_message.get_message(i_lang, 'REHAB_T180')
                                                                                                         ELSE
                                                                                                          NULL
                                                                                                     END,
                                                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_place_service
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => i_value(i) (1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_reason_not_ordering
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => i_value(i) (1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_reason_not_ordering = pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_active
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_tbl_records
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                l_ds_internal_name_aux := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j));
                            
                                IF l_ds_internal_name_aux = pk_orders_constant.g_ds_edition
                                THEN
                                    l_aux_val := i_value(j) (1);
                                    EXIT;
                                END IF;
                            END LOOP;
                        
                            IF l_aux_val = pk_alert_constant.g_yes
                            THEN
                                SELECT listagg(rp.id_rehab_area_interv, '|')
                                  INTO l_rehab_area_interv
                                  FROM rehab_presc rp
                                 WHERE rp.id_rehab_presc IN (SELECT /*+ opt_estimate(table t rows=1)*/
                                                              t.column_value
                                                               FROM TABLE(i_tbl_id_pk) t);
                            ELSE
                                SELECT /*+ opt_estimate(table t rows=1)*/
                                 listagg(t.column_value, '|')
                                  INTO l_rehab_area_interv
                                  FROM TABLE(i_tbl_id_pk) t;
                            END IF;
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_rehab_area_interv,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        
                        END IF;
                    END LOOP;
                END IF;
            ELSE
                --IMPORTING DATA  
                FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                LOOP
                    l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                    l_id_ds_component  := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    IF l_ds_internal_name = pk_orders_constant.g_ds_dummy_number
                    THEN
                        l_id_rehab_sch_need := i_value(i) (1);
                    END IF;
                END LOOP;
            
                IF l_id_rehab_sch_need IS NOT NULL
                THEN
                    SELECT rp.id_rehab_presc
                      INTO l_id_rehab_presc
                      FROM rehab_presc rp
                     WHERE rp.id_rehab_sch_need = l_id_rehab_sch_need
                       AND rownum = 1;
                
                    g_error := 'Calling pk_rehab.get_treatments_edit';
                    IF NOT pk_rehab.get_treatments_edit(i_lang            => i_lang,
                                                        i_prof            => i_prof,
                                                        i_id_rehab_presc  => l_id_rehab_presc,
                                                        o_rehab_treatment => c_rehab_treatment,
                                                        o_error           => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    g_error := 'Fetching c_rehab_treatment';
                    FETCH c_rehab_treatment BULK COLLECT
                        INTO l_tbl_treatment_edit;
                END IF;
            
                IF l_tbl_treatment_edit.exists(1)
                THEN
                    FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                        l_id_ds_component  := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                    
                        IF l_ds_internal_name IN (pk_orders_constant.g_ds_priority,
                                                  pk_orders_constant.g_ds_number_sessions,
                                                  pk_orders_constant.g_ds_frequency_sessions,
                                                  pk_orders_constant.g_ds_start_date_medium,
                                                  pk_orders_constant.g_ds_executions_sessions,
                                                  pk_orders_constant.g_ds_notes,
                                                  pk_orders_constant.g_ds_additional_notes,
                                                  pk_orders_constant.g_ds_dummy_number)
                        THEN
                            IF l_ds_internal_name IN
                               (pk_orders_constant.g_ds_number_sessions,
                                pk_orders_constant.g_ds_frequency_sessions,
                                pk_orders_constant.g_ds_executions_sessions)
                            THEN
                                SELECT d.min_value, d.max_value
                                  INTO l_min_value, l_max_value
                                  FROM ds_cmpt_mkt_rel d
                                 WHERE d.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
                            ELSE
                                l_min_value := NULL;
                                l_max_value := NULL;
                            END IF;
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => CASE l_ds_internal_name
                                                                                                         WHEN pk_orders_constant.g_ds_priority THEN
                                                                                                          l_tbl_treatment_edit(1).priority_data
                                                                                                         WHEN pk_orders_constant.g_ds_number_sessions THEN
                                                                                                          to_char(l_tbl_treatment_edit(1).num_sessions)
                                                                                                         WHEN pk_orders_constant.g_ds_frequency_sessions THEN
                                                                                                          to_char(l_tbl_treatment_edit(1).frequency_num)
                                                                                                         WHEN pk_orders_constant.g_ds_start_date_medium THEN
                                                                                                          CASE
                                                                                                              WHEN pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                                                                                                   i_date1 => pk_date_utils.get_string_tstz(8,
                                                                                                                                                                                            i_prof,
                                                                                                                                                                                            l_tbl_treatment_edit(1).dt_begin,
                                                                                                                                                                                            NULL),
                                                                                                                                                   i_date2 => g_sysdate_tstz - 1) != 'L' THEN
                                                                                                               to_char(l_tbl_treatment_edit(1).dt_begin)
                                                                                                              ELSE
                                                                                                               NULL
                                                                                                          END
                                                                                                         WHEN pk_orders_constant.g_ds_executions_sessions THEN
                                                                                                          to_char(l_tbl_treatment_edit(1).exec_session_data)
                                                                                                         WHEN pk_orders_constant.g_ds_notes THEN
                                                                                                          l_tbl_treatment_edit(1).notes
                                                                                                         WHEN pk_orders_constant.g_ds_additional_notes THEN
                                                                                                          l_tbl_treatment_edit(1).session_notes
                                                                                                         WHEN pk_orders_constant.g_ds_dummy_number THEN
                                                                                                          NULL
                                                                                                         WHEN pk_orders_constant.g_ds_id_record THEN
                                                                                                          to_char(l_tbl_treatment_edit(1).id_rehab_area_interv)
                                                                                                     END,
                                                                               value_clob         => NULL,
                                                                               min_value          => l_min_value,
                                                                               max_value          => l_max_value,
                                                                               desc_value         => CASE l_ds_internal_name
                                                                                                         WHEN pk_orders_constant.g_ds_priority THEN
                                                                                                          l_tbl_treatment_edit(1).priority_desc
                                                                                                         WHEN pk_orders_constant.g_ds_number_sessions THEN
                                                                                                          to_char(l_tbl_treatment_edit(1).num_sessions_desc)
                                                                                                         WHEN
                                                                                                          pk_orders_constant.g_ds_frequency_sessions THEN
                                                                                                          to_char(l_tbl_treatment_edit(1).frequency_desc)
                                                                                                         WHEN
                                                                                                          pk_orders_constant.g_ds_executions_sessions THEN
                                                                                                          to_char(l_tbl_treatment_edit(1).exec_session_desc)
                                                                                                         WHEN pk_orders_constant.g_ds_notes THEN
                                                                                                          l_tbl_treatment_edit(1).notes
                                                                                                         WHEN pk_orders_constant.g_ds_additional_notes THEN
                                                                                                          l_tbl_treatment_edit(1).session_notes
                                                                                                         WHEN pk_orders_constant.g_ds_dummy_number THEN
                                                                                                          NULL
                                                                                                     END,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => CASE l_ds_internal_name
                                                                                                         WHEN pk_orders_constant.g_ds_frequency_sessions THEN
                                                                                                          CASE
                                                                                                              WHEN l_tbl_treatment_edit(1).frequency_time_unit = 'W' THEN
                                                                                                               10375
                                                                                                              WHEN l_tbl_treatment_edit(1).frequency_time_unit = 'M' THEN
                                                                                                               1127
                                                                                                          END
                                                                                                     END,
                                                                               desc_unit_measure  => CASE l_ds_internal_name
                                                                                                         WHEN pk_orders_constant.g_ds_frequency_sessions THEN
                                                                                                          CASE
                                                                                                              WHEN l_tbl_treatment_edit(1).frequency_time_unit = 'W' THEN
                                                                                                               pk_unit_measure.get_unit_measure_description(i_lang, i_prof, 10375)
                                                                                                          END
                                                                                                     END,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_ds_internal_name IN
                                                                                                              (pk_orders_constant.g_ds_number_sessions,
                                                                                                               pk_orders_constant.g_ds_frequency_sessions,
                                                                                                               pk_orders_constant.g_ds_start_date_medium,
                                                                                                               pk_orders_constant.g_ds_place_service) THEN
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_active
                                                                                                     END,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        
            --OK BUTTON CONTROL 
            FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
            LOOP
                l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
            
                IF l_ds_internal_name = pk_orders_constant.g_ds_ok_button_control
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => NULL,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => NULL,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => get_control_validation(),
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                       flg_multi_status   => pk_alert_constant.g_no,
                                                                       idx                => i_idx);
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            --EDIÇÃO  
            g_error := 'Calling pk_rehab.get_treatments_edit';
            IF NOT pk_rehab.get_treatments_edit(i_lang            => i_lang,
                                                i_prof            => i_prof,
                                                i_id_rehab_presc  => i_tbl_id_pk(i_idx),
                                                o_rehab_treatment => c_rehab_treatment,
                                                o_error           => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'Fetching c_rehab_treatment';
            FETCH c_rehab_treatment BULK COLLECT
                INTO l_tbl_treatment_edit;
        
            FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
            LOOP
                l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
                l_id_ds_component  := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
            
                IF l_ds_internal_name IN (pk_orders_constant.g_ds_clinical_indication_ft,
                                          pk_orders_constant.g_ds_clinical_purpose,
                                          pk_orders_constant.g_ds_laterality,
                                          pk_orders_constant.g_ds_priority,
                                          pk_orders_constant.g_ds_number_sessions,
                                          pk_orders_constant.g_ds_frequency_sessions,
                                          pk_orders_constant.g_ds_executions_sessions,
                                          pk_orders_constant.g_ds_place_service,
                                          pk_orders_constant.g_ds_reason_not_ordering,
                                          pk_orders_constant.g_ds_notes,
                                          pk_orders_constant.g_ds_additional_notes,
                                          pk_orders_constant.g_ds_root_name)
                   OR
                   (l_ds_internal_name = pk_orders_constant.g_ds_clinical_purpose_ft AND l_tbl_treatment_edit(1).clinical_purpose_notes IS NOT NULL)
                THEN
                    IF l_ds_internal_name IN (pk_orders_constant.g_ds_number_sessions,
                                              pk_orders_constant.g_ds_frequency_sessions,
                                              pk_orders_constant.g_ds_executions_sessions)
                    THEN
                        SELECT d.min_value, d.max_value
                          INTO l_min_value, l_max_value
                          FROM ds_cmpt_mkt_rel d
                         WHERE d.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
                    ELSE
                        l_min_value := NULL;
                        l_max_value := NULL;
                    END IF;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => CASE l_ds_internal_name
                                                                                                 WHEN pk_orders_constant.g_ds_laterality THEN
                                                                                                  l_tbl_treatment_edit(1).flg_laterality
                                                                                                 WHEN pk_orders_constant.g_ds_priority THEN
                                                                                                  l_tbl_treatment_edit(1).priority_data
                                                                                                 WHEN pk_orders_constant.g_ds_number_sessions THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).num_sessions)
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_frequency_sessions THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).frequency_num)
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_start_date_medium THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).dt_begin)
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_executions_sessions THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).exec_session_data)
                                                                                                 WHEN pk_orders_constant.g_ds_place_service THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).exec_institution_data)
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_reason_not_ordering THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).not_order_reason_data)
                                                                                                 WHEN pk_orders_constant.g_ds_notes THEN
                                                                                                  l_tbl_treatment_edit(1).notes
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_clinical_indication_ft THEN
                                                                                                  l_tbl_treatment_edit(1).diagnosis_notes
                                                                                                 WHEN pk_orders_constant.g_ds_clinical_purpose THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).id_clinical_purpose)
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_clinical_purpose_ft THEN
                                                                                                  l_tbl_treatment_edit(1).clinical_purpose_notes
                                                                                                 WHEN pk_orders_constant.g_ds_additional_notes THEN
                                                                                                  l_tbl_treatment_edit(1).session_notes
                                                                                                 WHEN pk_orders_constant.g_ds_root_name THEN
                                                                                                  i_root_name
                                                                                             END,
                                                                       value_clob         => NULL,
                                                                       min_value          => l_min_value,
                                                                       max_value          => l_max_value,
                                                                       desc_value         => CASE l_ds_internal_name
                                                                                                 WHEN pk_orders_constant.g_ds_laterality THEN
                                                                                                  l_tbl_treatment_edit(1).desc_laterality
                                                                                                 WHEN pk_orders_constant.g_ds_priority THEN
                                                                                                  l_tbl_treatment_edit(1).priority_desc
                                                                                                 WHEN pk_orders_constant.g_ds_number_sessions THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).num_sessions_desc)
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_frequency_sessions THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).frequency_desc)
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_executions_sessions THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).exec_session_desc)
                                                                                                 WHEN pk_orders_constant.g_ds_place_service THEN
                                                                                                  l_tbl_treatment_edit(1).exec_institution_desc
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_reason_not_ordering THEN
                                                                                                  to_char(l_tbl_treatment_edit(1).not_order_reason_desc)
                                                                                                 WHEN pk_orders_constant.g_ds_notes THEN
                                                                                                  l_tbl_treatment_edit(1).notes
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_clinical_indication_ft THEN
                                                                                                  l_tbl_treatment_edit(1).diagnosis_notes
                                                                                                 WHEN pk_orders_constant.g_ds_clinical_purpose THEN
                                                                                                  pk_multichoice.get_multichoice_option_desc(i_lang,
                                                                                                                                             i_prof,
                                                                                                                                             l_tbl_treatment_edit(1).id_clinical_purpose)
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_clinical_purpose_ft THEN
                                                                                                  l_tbl_treatment_edit(1).clinical_purpose_notes
                                                                                                 WHEN pk_orders_constant.g_ds_additional_notes THEN
                                                                                                  l_tbl_treatment_edit(1).session_notes
                                                                                             END,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => CASE l_ds_internal_name
                                                                                                 WHEN pk_orders_constant.g_ds_frequency_sessions THEN
                                                                                                  CASE
                                                                                                      WHEN l_tbl_treatment_edit(1).frequency_time_unit = 'W' THEN
                                                                                                       10375
                                                                                                      WHEN l_tbl_treatment_edit(1).frequency_time_unit = 'M' THEN
                                                                                                       1127
                                                                                                  END
                                                                                             END,
                                                                       desc_unit_measure  => CASE l_ds_internal_name
                                                                                                 WHEN pk_orders_constant.g_ds_frequency_sessions THEN
                                                                                                  CASE
                                                                                                      WHEN l_tbl_treatment_edit(1).frequency_time_unit = 'W' THEN
                                                                                                       pk_unit_measure.get_unit_measure_description(i_lang, i_prof, 10375)
                                                                                                  END
                                                                                             END,
                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => CASE
                                                                                                 WHEN l_ds_internal_name = pk_orders_constant.g_ds_reason_not_ordering THEN
                                                                                                  CASE
                                                                                                      WHEN l_reason_not_ordering = pk_alert_constant.g_yes THEN
                                                                                                       pk_alert_constant.g_active
                                                                                                      ELSE
                                                                                                       pk_alert_constant.g_inactive
                                                                                                  END
                                                                                                 WHEN l_ds_internal_name IN
                                                                                                      (pk_orders_constant.g_ds_number_sessions,
                                                                                                       pk_orders_constant.g_ds_frequency_sessions,
                                                                                                       pk_orders_constant.g_ds_start_date_medium,
                                                                                                       pk_orders_constant.g_ds_place_service) THEN
                                                                                                  pk_orders_constant.g_component_mandatory
                                                                                                 ELSE
                                                                                                  pk_orders_constant.g_component_active
                                                                                             END,
                                                                       flg_multi_status   => pk_alert_constant.g_no,
                                                                       idx                => i_idx);
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_clinical_indication_mw
                      AND l_tbl_treatment_edit(1).id_alert_diagnosis.count > 0
                THEN
                    IF l_tbl_treatment_edit(1).id_alert_diagnosis.count = l_tbl_treatment_edit(1).tbl_diagnosis_desc.count
                    THEN
                        FOR j IN l_tbl_treatment_edit(1).id_alert_diagnosis.first .. l_tbl_treatment_edit(1).id_alert_diagnosis.last
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => to_char(l_tbl_treatment_edit(1).id_alert_diagnosis(j)),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => l_tbl_treatment_edit(1).tbl_diagnosis_desc(j),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        END LOOP;
                    END IF;
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_icf
                      AND l_tbl_treatment_edit(1).tbl_id_rehab_diagnosis.count > 0
                THEN
                    IF l_tbl_treatment_edit(1).tbl_id_rehab_diagnosis.count = l_tbl_treatment_edit(1).tbl_rehab_diagnosis_desc.count
                    THEN
                        FOR j IN l_tbl_treatment_edit(1).tbl_id_rehab_diagnosis.first .. l_tbl_treatment_edit(1).tbl_id_rehab_diagnosis.last
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => to_char(l_tbl_treatment_edit(1).tbl_id_rehab_diagnosis(j)),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => l_tbl_treatment_edit(1).tbl_rehab_diagnosis_desc(j),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => pk_alert_constant.g_no,
                                                                               idx                => i_idx);
                        END LOOP;
                    END IF;
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_tbl_records
                THEN
                
                    SELECT listagg(rp.id_rehab_area_interv, '|')
                      INTO l_rehab_area_interv
                      FROM rehab_presc rp
                     WHERE rp.id_rehab_presc IN (SELECT /*+ opt_estimate(table t rows=1)*/
                                                  t.column_value
                                                   FROM TABLE(i_tbl_id_pk) t);
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => l_rehab_area_interv,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => NULL,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                       flg_multi_status   => pk_alert_constant.g_no,
                                                                       idx                => i_idx);
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_edition
                THEN
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => pk_alert_constant.g_yes,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => NULL,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                       flg_multi_status   => pk_alert_constant.g_no,
                                                                       idx                => i_idx);
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_financial_entity
                      AND l_tbl_treatment_edit(1).id_pat_health_plan IS NOT NULL
                THEN
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => to_char(l_tbl_treatment_edit(1).id_health_plan_entity),
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => pk_adt.get_pat_health_plan_info(i_lang,
                                                                                                                             i_prof,
                                                                                                                             l_tbl_treatment_edit(1).id_pat_health_plan,
                                                                                                                             'F'),
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => CASE l_id_market
                                                                                                 WHEN
                                                                                                  pk_alert_constant.g_id_market_pt THEN
                                                                                                  'M'
                                                                                                 ELSE
                                                                                                  'A'
                                                                                             END,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_health_coverage_plan
                      AND l_tbl_treatment_edit(1).id_pat_health_plan IS NOT NULL
                THEN
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => to_char(l_tbl_treatment_edit(1).id_pat_health_plan),
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => pk_adt.get_pat_health_plan_info(i_lang,
                                                                                                                             i_prof,
                                                                                                                             l_tbl_treatment_edit(1).id_pat_health_plan,
                                                                                                                             'H'),
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => CASE l_id_market
                                                                                                 WHEN
                                                                                                  pk_alert_constant.g_id_market_pt THEN
                                                                                                  'M'
                                                                                                 ELSE
                                                                                                  'A'
                                                                                             END,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_health_plan_number
                      AND l_tbl_treatment_edit(1).num_health_plan IS NOT NULL
                THEN
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => l_tbl_treatment_edit(1).num_health_plan,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => l_tbl_treatment_edit(1).num_health_plan,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => 'R',
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_exemption
                      AND l_tbl_treatment_edit(1).id_pat_exemption IS NOT NULL
                THEN
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => to_char(l_tbl_treatment_edit(1).id_pat_exemption),
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => pk_adt.get_pat_exemption_detail(i_lang,
                                                                                                                             i_prof,
                                                                                                                             l_tbl_treatment_edit(1).id_pat_exemption),
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => 'A',
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_start_date_medium
                THEN
                    IF pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                       i_date1 => pk_date_utils.get_string_tstz(i_lang,
                                                                                                i_prof,
                                                                                                l_tbl_treatment_edit(1).dt_begin,
                                                                                                NULL),
                                                       i_date2 => g_sysdate_tstz - 1) = 'L'
                    THEN
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => l_ds_internal_name,
                                                                           VALUE              => to_char(l_tbl_treatment_edit(1).dt_begin),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => NULL,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_error,
                                                                           err_msg            => pk_message.get_message(i_lang,
                                                                                                                        'REHAB_T169'),
                                                                           flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                           flg_multi_status   => pk_alert_constant.g_no,
                                                                           idx                => i_idx);
                    ELSE
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => l_ds_internal_name,
                                                                           VALUE              => to_char(l_tbl_treatment_edit(1).dt_begin),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => NULL,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                           flg_multi_status   => pk_alert_constant.g_no,
                                                                           idx                => i_idx);
                    END IF;
                END IF;
            END LOOP;
        
            --OK BUTTON CONTROL 
            FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
            LOOP
                l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(i));
            
                IF l_ds_internal_name = pk_orders_constant.g_ds_ok_button_control
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => l_ds_internal_name,
                                                                       VALUE              => NULL,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => NULL,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => get_control_validation(),
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                       flg_multi_status   => pk_alert_constant.g_no,
                                                                       idx                => i_idx);
                
                    EXIT;
                END IF;
            END LOOP;
        END IF;
    
        RETURN tbl_result;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_REHAB_TREATMENT_VALUES',
                                              o_error);
            RETURN t_tbl_ds_get_value();
    END get_rehab_treatment_values;

    FUNCTION get_rehab_treatment_detail
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_id      IN rehab_presc.id_rehab_presc%TYPE,
        i_area    IN dd_area.area%TYPE,
        i_reports IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        o_detail  OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        c_rehab_treatment      pk_types.cursor_type;
        l_tbl_rehab_treatments tbl_treatment_edit;
    
        l_tab_dd_block_order t_tab_dd_block_data := t_tab_dd_block_data();
    
        l_tab_dd_data      t_tab_dd_data := t_tab_dd_data();
        l_data_source_list table_varchar := table_varchar();
    
        l_id_rehab_presc            rehab_presc.id_rehab_presc%TYPE;
        l_interv_presc_desc_session VARCHAR2(4000 CHAR);
        l_sch_need_status           VARCHAR2(200 CHAR);
    
        l_count_cq          PLS_INTEGER := 0;
        l_tbl_questionnaire t_tbl_clinical_question;
    
    BEGIN
    
        g_error := 'Fetching l_id_rehab_presc';
        IF i_area = pk_dynamic_detail.g_rehab_treatment
        THEN
            l_id_rehab_presc := i_id;
        ELSIF i_area = pk_dynamic_detail.g_rehab_session
        THEN
            BEGIN
                SELECT rp.id_rehab_presc
                  INTO l_id_rehab_presc
                  FROM rehab_presc rp
                 WHERE rp.id_rehab_sch_need = i_id
                   AND rownum = 1;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE g_exception;
            END;
        
            BEGIN
                SELECT listagg(t.desc_interv, '; ') within GROUP(ORDER BY desc_interv)
                  INTO l_interv_presc_desc_session
                  FROM (SELECT pk_procedures_api_db.get_alias_translation(i_lang, i_prof, i.code_intervention, NULL) desc_interv
                          FROM rehab_presc rp
                          JOIN rehab_sch_need rsn
                            ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                          JOIN rehab_session_type rst
                            ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                          JOIN rehab_area_interv rai
                            ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                          JOIN intervention i
                            ON i.id_intervention = rai.id_intervention
                         WHERE rp.id_rehab_sch_need = i_id) t;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE g_exception;
            END;
        
            BEGIN
                SELECT pk_sysdomain.get_domain('REHAB_SCH_NEED.FLG_STATUS', rsn.flg_status, i_lang)
                  INTO l_sch_need_status
                  FROM rehab_sch_need rsn
                 WHERE rsn.id_rehab_sch_need = i_id;
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE g_exception;
            END;
        END IF;
    
        g_error := 'Calling pk_rehab.get_treatments_edit';
        IF NOT pk_rehab.get_treatments_edit(i_lang            => i_lang,
                                            i_prof            => i_prof,
                                            i_id_rehab_presc  => l_id_rehab_presc,
                                            o_rehab_treatment => c_rehab_treatment,
                                            o_error           => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'Fetching c_rehab_treatment';
        FETCH c_rehab_treatment BULK COLLECT
            INTO l_tbl_rehab_treatments;
    
        SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                   ddb.rank,
                                   NULL,
                                   NULL,
                                   ddb.condition_val,
                                   NULL,
                                   NULL,
                                   dd.data_source,
                                   dd.data_source_val,
                                   NULL)
          BULK COLLECT
          INTO l_tab_dd_block_order
          FROM (SELECT data_source, data_source_val
                  FROM (SELECT *
                          FROM (SELECT NULL header,
                                       NULL AS action,
                                       CASE
                                            WHEN t.diagnosis_notes IS NOT NULL
                                                 OR t.diagnosis_desc IS NOT NULL
                                                 OR t.id_clinical_purpose IS NOT NULL
                                                 OR t.rehab_diagnosis_desc_concat IS NOT NULL
                                                 OR t.desc_laterality IS NOT NULL THEN
                                             ' '
                                        END clinical_purpose_title,
                                       t.diagnosis_desc clinical_indication,
                                       t.diagnosis_notes clinical_indication_ft,
                                       pk_multichoice.get_multichoice_option_desc(i_lang, i_prof, t.id_clinical_purpose) || CASE
                                            WHEN t.clinical_purpose_notes IS NOT NULL THEN
                                             ' - ' || t.clinical_purpose_notes
                                        END AS clinical_purpose,
                                       t.rehab_diagnosis_desc_concat icf,
                                       t.desc_laterality AS laterality,
                                       ' ' AS instructions,
                                       t.desc_interv AS treatment,
                                       l_interv_presc_desc_session AS treatments_session,
                                       (SELECT pk_translation.get_translation(i_lang, r.code_rehab_area)
                                          FROM rehab_area r
                                         WHERE r.id_rehab_area = t.id_rehab_area) AS rehab_area,
                                       t.desc_rehab_session_type session_type,
                                       t.priority_desc AS priority,
                                       t.num_sessions_desc AS number_sessions,
                                       t.frequency_desc AS frequency,
                                       t.dt_begin_desc AS start_date,
                                       to_char(t.exec_session_desc) ||
                                       nvl2(t.exec_session_desc,
                                            decode(i_reports,
                                                   pk_alert_constant.g_yes,
                                                   pk_message.get_message(i_lang, 'REHAB_T192')),
                                            NULL) AS execution_session,
                                       ' ' AS execution,
                                       t.exec_institution_desc AS exec_institution,
                                       t.not_order_reason_desc AS not_order_reason,
                                       t.notes,
                                       t.session_notes additional_notes,
                                       CASE
                                            WHEN i_area = pk_dynamic_detail.g_rehab_treatment THEN
                                             t.status_desc
                                            ELSE
                                             l_sch_need_status
                                        END status,
                                       t.scheduled_sessions,
                                       t.therapist,
                                       CASE
                                            WHEN t.id_pat_health_plan IS NOT NULL
                                                 OR t.id_pat_exemption IS NOT NULL
                                                 OR t.id_health_plan_entity IS NOT NULL
                                                 OR t.num_health_plan IS NOT NULL THEN
                                             ' '
                                        END healthcare_insurance,
                                       CASE
                                            WHEN t.cancel_reason_desc IS NOT NULL
                                                 OR t.cancel_reason_notes IS NOT NULL THEN
                                             ' '
                                        END cancel_reason_title,
                                       CASE
                                            WHEN t.id_pat_health_plan IS NOT NULL THEN
                                             pk_adt.get_pat_health_plan_info(i_lang, i_prof, t.id_pat_health_plan, 'F')
                                            ELSE
                                             NULL
                                        END healthplan_entity,
                                       CASE
                                            WHEN t.id_pat_health_plan IS NOT NULL THEN
                                             pk_adt.get_pat_health_plan_info(i_lang, i_prof, t.id_pat_health_plan, 'H')
                                            ELSE
                                             NULL
                                        END health_coverage_plan,
                                       CASE
                                            WHEN t.id_pat_health_plan IS NOT NULL THEN
                                             t.num_health_plan
                                            ELSE
                                             NULL
                                        END beneficiary_number,
                                       CASE
                                            WHEN t.id_pat_exemption IS NOT NULL THEN
                                             pk_adt.get_pat_exemption_detail(i_lang, i_prof, t.id_pat_exemption)
                                            ELSE
                                             NULL
                                        END exemption,
                                       t.cancel_reason_desc,
                                       t.cancel_reason_notes,
                                       t.registry,
                                       ' ' white_line
                                  FROM TABLE(l_tbl_rehab_treatments) t) unpivot include NULLS(data_source_val FOR data_source IN(header,
                                                                                                                                 action,
                                                                                                                                 clinical_indication,
                                                                                                                                 clinical_indication_ft,
                                                                                                                                 clinical_purpose,
                                                                                                                                 clinical_purpose_title,
                                                                                                                                 icf,
                                                                                                                                 laterality,
                                                                                                                                 instructions,
                                                                                                                                 treatment,
                                                                                                                                 treatments_session,
                                                                                                                                 rehab_area,
                                                                                                                                 session_type,
                                                                                                                                 priority,
                                                                                                                                 number_sessions,
                                                                                                                                 frequency,
                                                                                                                                 start_date,
                                                                                                                                 execution_session,
                                                                                                                                 execution,
                                                                                                                                 exec_institution,
                                                                                                                                 not_order_reason,
                                                                                                                                 notes,
                                                                                                                                 additional_notes,
                                                                                                                                 status,
                                                                                                                                 scheduled_sessions,
                                                                                                                                 therapist,
                                                                                                                                 healthcare_insurance,
                                                                                                                                 healthplan_entity,
                                                                                                                                 health_coverage_plan,
                                                                                                                                 beneficiary_number,
                                                                                                                                 exemption,
                                                                                                                                 cancel_reason_title,
                                                                                                                                 cancel_reason_desc,
                                                                                                                                 cancel_reason_notes,
                                                                                                                                 registry,
                                                                                                                                 white_line)))) dd
          JOIN dd_block ddb
            ON ddb.area = i_area
           AND ddb.internal_name = 'ORDER'
           AND ddb.flg_available = pk_alert_constant.g_yes;
    
        --Clinical questions
        l_tbl_questionnaire := pk_rehab.tf_get_clinical_questions(i_lang           => i_lang,
                                                                  i_prof           => i_prof,
                                                                  i_id_rehab_presc => i_id,
                                                                  i_flg_time       => 'O');
        --Check if there are CQs in order to know if the label 'Clinical questions' should be displayed    
        l_count_cq := l_tbl_questionnaire.count;
    
        SELECT t_rec_dd_data(CASE
                                  WHEN i_reports = pk_alert_constant.g_yes
                                       AND flg_show_label = pk_alert_constant.g_no THEN
                                   NULL
                                  WHEN i_reports = pk_alert_constant.g_yes
                                       AND data_code_message_reports IS NOT NULL
                                       AND flg_type <> 'L3CQ' THEN
                                   pk_message.get_message(i_lang => i_lang, i_code_mess => data_code_message_reports)
                                  WHEN data_code_message IS NOT NULL
                                       AND flg_type <> 'L3CQ' THEN
                                   pk_message.get_message(i_lang => i_lang, i_code_mess => data_code_message)
                                  WHEN flg_type = 'L3CQ' THEN
                                   data_code_message || ':'
                                  ELSE
                                   NULL
                              END, --DESCR
                              CASE
                                  WHEN flg_type = 'L1' THEN
                                   NULL
                                  ELSE
                                   data_source_val
                              END, --VAL                              
                              decode(i_reports,
                                     pk_alert_constant.g_yes,
                                     nvl(flg_type_reports, decode(flg_type, 'L3CQ', 'L3B', flg_type)),
                                     decode(flg_type, 'L3CQ', 'L3B', flg_type)), -- TYPE
                              flg_html,
                              NULL,
                              flg_clob),
               data_source
          BULK COLLECT
          INTO l_tab_dd_data, l_data_source_list
          FROM (SELECT ddc.data_code_message,
                       ddc.data_code_message_reports,
                       flg_type,
                       data_source_val,
                       ddc.data_source,
                       db.rnk,
                       decode(i_reports, pk_alert_constant.g_no, ddc.rank, nvl(ddc.rank_reports, ddc.rank)) rank,
                       db.id_dd_block,
                       0 AS rank_cq,
                       flg_html,
                       flg_clob,
                       ddc.flg_show_label,
                       ddc.flg_type_reports
                  FROM TABLE(l_tab_dd_block_order) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ((ddc.flg_available = pk_alert_constant.g_yes AND i_reports = pk_alert_constant.g_no) OR
                       (ddc.flg_available_reports = pk_alert_constant.g_yes AND i_reports = pk_alert_constant.g_yes))
                   AND ddc.area = i_area
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L1', /*'L2B',*/ 'LH'))
                UNION ALL
                --Clinical questions
                 (SELECT ddc.data_code_message,
                        ddc.data_code_message_reports,
                        'L2B' flg_type,
                        NULL data_source_val,
                        ddc.data_source,
                        (1) AS rnk,
                        decode(i_reports, pk_alert_constant.g_no, ddc.rank, nvl(ddc.rank_reports, ddc.rank)) rank,
                        ddc.id_dd_block,
                        0 AS rank_cq,
                        flg_html,
                        flg_clob,
                        ddc.flg_show_label,
                        ddc.flg_type_reports
                   FROM dd_content ddc
                  WHERE ddc.data_source = 'CLINICAL_QUESTIONS_TITLE'
                    AND ((ddc.flg_available = pk_alert_constant.g_yes AND i_reports = pk_alert_constant.g_no) OR
                        (ddc.flg_available_reports = pk_alert_constant.g_yes AND i_reports = pk_alert_constant.g_yes))
                    AND ddc.area = i_area
                    AND flg_type IN ('L2CQ')
                    AND l_count_cq > 0
                 UNION ALL
                 SELECT t_cq.desc_clinical_question data_code_message,
                        NULL data_code_message_reports,
                        flg_type,
                        t_cq.desc_response data_source_val,
                        ddc.data_source,
                        (1) AS rnk,
                        decode(i_reports, pk_alert_constant.g_no, ddc.rank, nvl(ddc.rank_reports, ddc.rank)) rank,
                        ddc.id_dd_block,
                        t_cq.rank AS rank_cq,
                        flg_html,
                        flg_clob,
                        ddc.flg_show_label,
                        ddc.flg_type_reports
                   FROM TABLE(l_tbl_questionnaire) t_cq
                   JOIN dd_content ddc
                     ON ddc.data_source = 'CLINICAL_QUESTIONS'
                    AND ((ddc.flg_available = pk_alert_constant.g_yes AND i_reports = pk_alert_constant.g_no) OR
                        (ddc.flg_available_reports = pk_alert_constant.g_yes AND i_reports = pk_alert_constant.g_yes))
                    AND ddc.area = i_area
                  WHERE flg_type IN ('L3CQ')))
         ORDER BY rank, rank_cq;
    
        OPEN o_detail FOR
            SELECT descr, val, flg_type, flg_html, val_clob, flg_clob
              FROM (SELECT CASE
                                WHEN d.val IS NULL THEN
                                 d.descr
                                WHEN d.descr IS NULL THEN
                                 NULL
                                ELSE
                                 d.descr || ' '
                            END descr,
                           d.val,
                           d.flg_type,
                           flg_html,
                           val_clob,
                           flg_clob,
                           d.rn
                      FROM (SELECT rownum rn, descr, val, flg_type, flg_html, val_clob, flg_clob
                              FROM TABLE(l_tab_dd_data)) d
                      JOIN (SELECT rownum rn, column_value data_source
                             FROM TABLE(l_data_source_list)) ds
                        ON ds.rn = d.rn);
    
        RETURN TRUE;
    END get_rehab_treatment_detail;

    FUNCTION get_rehab_treatment_history
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        o_detail         OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_msg_del sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M106');
    
        CURSOR c_rehab_hist IS
            SELECT tt.rn,
                   CASE
                        WHEN tt.rn = tt.cnt THEN
                         (SELECT pk_procedures_api_db.get_alias_translation(i_lang, i_prof, tt.code_intervention, NULL)
                            FROM dual)
                    END desc_interv,
                   CASE
                        WHEN tt.rn = tt.cnt THEN
                         (SELECT pk_translation.get_translation(i_lang, r.code_rehab_area)
                            FROM rehab_area r
                           WHERE r.id_rehab_area = tt.id_rehab_area)
                    END AS rehab_area,
                   CASE
                        WHEN tt.rn = tt.cnt THEN
                         (SELECT pk_translation.get_translation(i_lang, tt.code_rehab_session_type)
                            FROM dual)
                    END desc_rehab_session_type,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.diagnosis_notes, NULL, NULL, tt.diagnosis_notes),
                          decode(tt.diagnosis_notes,
                                 tt.diagnosis_notes_old,
                                 NULL,
                                 decode(tt.diagnosis_notes_old, NULL, NULL, tt.diagnosis_notes_old))) diagnosis_notes,
                   decode(tt.diagnosis_notes, tt.diagnosis_notes_old, NULL, NULL, l_msg_del, tt.diagnosis_notes) diagnosis_notes_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.clinical_purpose, NULL, NULL, tt.clinical_purpose),
                          decode(tt.clinical_purpose,
                                 tt.clinical_purpose_old,
                                 NULL,
                                 decode(tt.clinical_purpose_old, NULL, NULL, tt.clinical_purpose_old))) clinical_purpose,
                   decode(tt.clinical_purpose, tt.clinical_purpose_old, NULL, NULL, l_msg_del, tt.clinical_purpose) clinical_purpose_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.rehab_diagnosis_desc_concat, NULL, NULL, tt.rehab_diagnosis_desc_concat),
                          decode(tt.rehab_diagnosis_desc_concat,
                                 tt.rehab_diagnosis_desc_concat_old,
                                 NULL,
                                 decode(tt.rehab_diagnosis_desc_concat_old,
                                        NULL,
                                        NULL,
                                        tt.rehab_diagnosis_desc_concat_old))) icf,
                   decode(tt.rehab_diagnosis_desc_concat,
                          tt.rehab_diagnosis_desc_concat_old,
                          NULL,
                          NULL,
                          l_msg_del,
                          tt.rehab_diagnosis_desc_concat) icf_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.flg_laterality,
                                 NULL,
                                 NULL,
                                 pk_sysdomain.get_domain('REHAB_PRESC.FLG_LATERALITY', tt.flg_laterality, i_lang)),
                          decode(tt.flg_laterality,
                                 tt.flg_laterality_old,
                                 NULL,
                                 decode(tt.flg_laterality_old,
                                        NULL,
                                        NULL,
                                        pk_sysdomain.get_domain('REHAB_PRESC.FLG_LATERALITY',
                                                                tt.flg_laterality_old,
                                                                i_lang)))) desc_laterality,
                   decode(tt.flg_laterality,
                          tt.flg_laterality_old,
                          NULL,
                          NULL,
                          l_msg_del,
                          pk_sysdomain.get_domain('REHAB_PRESC.FLG_LATERALITY', tt.flg_laterality, i_lang)) desc_laterality_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.priority_data,
                                 NULL,
                                 NULL,
                                 pk_rehab.get_instructions(i_lang, i_prof, tt.id_rehab_sch_need, 'P')),
                          decode(tt.priority_data,
                                 tt.priority_data_old,
                                 NULL,
                                 decode(tt.priority_data_old,
                                        NULL,
                                        NULL,
                                        pk_rehab.get_instructions(i_lang, i_prof, tt.id_rehab_sch_need_old, 'P')))) priority_desc,
                   decode(tt.priority_data,
                          tt.priority_data_old,
                          NULL,
                          NULL,
                          l_msg_del,
                          pk_rehab.get_instructions(i_lang, i_prof, tt.id_rehab_sch_need, 'P')) priority_desc_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.num_sessions,
                                 NULL,
                                 NULL,
                                 pk_rehab.get_instructions(i_lang, i_prof, tt.id_rehab_sch_need, 'S')),
                          decode(tt.num_sessions,
                                 tt.num_sessions_old,
                                 NULL,
                                 decode(tt.num_sessions_old,
                                        NULL,
                                        NULL,
                                        pk_rehab.get_instructions(i_lang, i_prof, tt.id_rehab_sch_need_old, 'S')))) num_sessions_desc,
                   decode(tt.num_sessions,
                          tt.num_sessions_old,
                          NULL,
                          NULL,
                          l_msg_del,
                          pk_rehab.get_instructions(i_lang, i_prof, tt.id_rehab_sch_need, 'S')) num_sessions_desc_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.frequency_desc, NULL, NULL, tt.frequency_desc),
                          decode(tt.frequency_desc,
                                 tt.frequency_desc_old,
                                 NULL,
                                 decode(tt.frequency_desc_old, NULL, NULL, tt.frequency_desc_old))) frequency_desc,
                   decode(tt.frequency_desc, tt.frequency_desc_old, NULL, NULL, l_msg_del, tt.frequency_desc) frequency_desc_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.dt_begin, NULL, NULL, pk_date_utils.dt_chr_tsz(i_lang, tt.dt_begin, i_prof)),
                          decode(tt.dt_begin,
                                 tt.dt_begin_old,
                                 NULL,
                                 decode(tt.dt_begin_old,
                                        NULL,
                                        NULL,
                                        pk_date_utils.dt_chr_tsz(i_lang, tt.dt_begin_old, i_prof)))) dt_begin,
                   decode(tt.dt_begin,
                          tt.dt_begin_old,
                          NULL,
                          NULL,
                          l_msg_del,
                          pk_date_utils.dt_chr_tsz(i_lang, tt.dt_begin, i_prof)) dt_begin_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.exec_session_desc, NULL, NULL, tt.exec_session_desc),
                          decode(tt.exec_session_desc,
                                 tt.exec_session_desc_old,
                                 NULL,
                                 decode(tt.exec_session_desc_old, NULL, NULL, tt.exec_session_desc_old))) exec_session_desc,
                   decode(tt.exec_session_desc, tt.exec_session_desc_old, NULL, NULL, l_msg_del, tt.exec_session_desc) exec_session_desc_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.exec_institution_data, NULL, NULL, tt.exec_institution_data),
                          decode(tt.exec_institution_data,
                                 tt.exec_institution_data_old,
                                 NULL,
                                 decode(tt.exec_institution_data_old, NULL, NULL, tt.exec_institution_data_old))) exec_institution_data,
                   decode(tt.exec_institution_data,
                          tt.exec_institution_data_old,
                          NULL,
                          NULL,
                          l_msg_del,
                          tt.exec_institution_data) exec_institution_data_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.id_not_order_reason,
                                 NULL,
                                 NULL,
                                 pk_not_order_reason_db.get_not_order_reason_desc(i_lang             => i_lang,
                                                                                  i_not_order_reason => tt.id_not_order_reason)),
                          decode(tt.id_not_order_reason,
                                 tt.id_not_order_reason_old,
                                 NULL,
                                 decode(tt.id_not_order_reason_old,
                                        NULL,
                                        NULL,
                                        pk_not_order_reason_db.get_not_order_reason_desc(i_lang             => i_lang,
                                                                                         i_not_order_reason => tt.id_not_order_reason_old)))) not_order_reason_desc,
                   decode(tt.id_not_order_reason,
                          tt.id_not_order_reason_old,
                          NULL,
                          NULL,
                          l_msg_del,
                          pk_not_order_reason_db.get_not_order_reason_desc(i_lang             => i_lang,
                                                                           i_not_order_reason => tt.id_not_order_reason)) not_order_reason_desc_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.notes, NULL, NULL, tt.notes),
                          decode(tt.notes, tt.notes_old, NULL, decode(tt.notes_old, NULL, NULL, tt.notes_old))) notes,
                   decode(tt.notes, tt.notes_old, NULL, NULL, l_msg_del, tt.notes) notes_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.additional_notes, NULL, NULL, tt.additional_notes),
                          decode(tt.additional_notes,
                                 tt.additional_notes_old,
                                 NULL,
                                 decode(tt.additional_notes_old, NULL, NULL, tt.additional_notes_old))) additional_notes,
                   decode(tt.additional_notes, tt.additional_notes_old, NULL, NULL, l_msg_del, tt.additional_notes) additional_notes_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.diagnosis_desc, NULL, NULL, tt.diagnosis_desc),
                          decode(tt.diagnosis_desc,
                                 tt.diagnosis_desc_old,
                                 NULL,
                                 decode(tt.diagnosis_desc_old, NULL, NULL, tt.diagnosis_desc_old))) diagnosis_desc,
                   decode(tt.diagnosis_desc, tt.diagnosis_desc_old, NULL, NULL, l_msg_del, tt.diagnosis_desc) diagnosis_desc_new,
                   decode(tt.cnt,
                          tt.rn,
                          decode(tt.flg_status,
                                 NULL,
                                 NULL,
                                 pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', tt.flg_status, i_lang)),
                          decode(tt.flg_status,
                                 tt.flg_status_old,
                                 NULL,
                                 decode(tt.flg_status_old,
                                        NULL,
                                        NULL,
                                        pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', tt.flg_status_old, i_lang)))) status,
                   decode(tt.flg_status,
                          tt.flg_status_old,
                          NULL,
                          NULL,
                          l_msg_del,
                          pk_sysdomain.get_domain('REHAB_PRESC.FLG_STATUS', tt.flg_status, i_lang)) status_new,
                   tt.cancel_reason_desc cancel_reason_desc_new,
                   tt.cancel_reason_notes cancel_reason_notes_new,
                   tt.registry
              FROM (SELECT row_number() over(ORDER BY t.dt_rehab_presc_hist DESC) rn,
                           MAX(rownum) over() cnt,
                           t.*,
                           pk_multichoice.get_multichoice_option_desc(i_lang, i_prof, t.id_clinical_purpose) || CASE
                                WHEN t.clinical_purpose_notes IS NOT NULL THEN
                                 ' - ' || t.clinical_purpose_notes
                            END AS clinical_purpose,
                           pk_multichoice.get_multichoice_option_desc(i_lang, i_prof, t.id_clinical_purpose_old) || CASE
                                WHEN t.clinical_purpose_notes_old IS NOT NULL THEN
                                 ' - ' || t.clinical_purpose_notes_old
                            END AS clinical_purpose_old,
                           pk_rehab.get_instructions(i_lang, i_prof, t.id_rehab_sch_need, 'F') frequency_desc,
                           pk_rehab.get_instructions(i_lang, i_prof, t.id_rehab_sch_need_old, 'F') frequency_desc_old,
                           decode(i_prof.institution,
                                  t.id_exec_institution,
                                  pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                                  pk_translation.get_translation(i_lang,
                                                                 'AB_INSTITUTION.CODE_INSTITUTION.' ||
                                                                 t.id_exec_institution)) exec_institution_data,
                           decode(i_prof.institution,
                                  t.id_exec_institution_old,
                                  pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                                  pk_translation.get_translation(i_lang,
                                                                 'AB_INSTITUTION.CODE_INSTITUTION.' ||
                                                                 t.id_exec_institution_old)) exec_institution_data_old,
                           pk_rehab.get_diagnosis(i_lang, i_prof, t.id_rehab_presc, t.id_rehab_presc_hist) diagnosis_desc,
                           pk_rehab.get_diagnosis(i_lang, i_prof, t.id_rehab_presc, t.id_rehab_presc_hist_old) diagnosis_desc_old,
                           (SELECT listagg(regexp_replace((SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                                                            FROM icf i
                                                           WHERE i.id_icf = rd.id_icf
                                                             AND i.flg_available = pk_alert_constant.g_yes
                                                          CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                                                           START WITH i.id_icf IN
                                                                      (SELECT id_icf
                                                                         FROM icf
                                                                        WHERE flg_type = pk_interv_mfr.g_flg_icf_component)),
                                                          '^(\s-\s*)$',
                                                          NULL) ||
                                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                            FROM icf_qualif_scale_rel iqsr
                                                           WHERE iqsr.id_icf_qualification = rd.id_iq_initial_incapacity
                                                             AND iqsr.id_icf_qualification_scale =
                                                                 rd.id_iqs_initial_incapacity),
                                                          '^(\s*)$',
                                                          NULL) ||
                                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                            FROM icf_qualif_scale_rel iqsr
                                                           WHERE iqsr.id_icf_qualification = rd.id_iq_expected_result
                                                             AND iqsr.id_icf_qualification_scale =
                                                                 rd.id_iqs_expected_result),
                                                          '^(\s*)$',
                                                          NULL) ||
                                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                            FROM icf_qualif_scale_rel iqsr
                                                           WHERE iqsr.id_icf_qualification = rd.id_iq_active_incapacity
                                                             AND iqsr.id_icf_qualification_scale =
                                                                 rd.id_iqs_active_incapacity),
                                                          '^(\s*)$',
                                                          NULL) || ' - ' ||
                                           pk_translation.get_translation(i_lang, i.code_icf),
                                           ', ') within GROUP(ORDER BY rpi.id_rehab_presc_icf_hist ASC)
                              FROM rehab_diagnosis rd
                             INNER JOIN icf i
                                ON rd.id_icf = i.id_icf
                              JOIN rehab_presc_icf_hist rpi
                                ON rpi.id_rehab_diagnosis = rd.id_rehab_diagnosis
                             WHERE rpi.id_rehab_presc = t.id_rehab_presc
                               AND rpi.dt_rehab_presc_icf_hist = t.dt_rehab_presc_hist) AS rehab_diagnosis_desc_concat,
                           (SELECT listagg(regexp_replace((SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                                                            FROM icf i
                                                           WHERE i.id_icf = rd.id_icf
                                                             AND i.flg_available = pk_alert_constant.g_yes
                                                          CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                                                           START WITH i.id_icf IN
                                                                      (SELECT id_icf
                                                                         FROM icf
                                                                        WHERE flg_type = pk_interv_mfr.g_flg_icf_component)),
                                                          '^(\s-\s*)$',
                                                          NULL) ||
                                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                            FROM icf_qualif_scale_rel iqsr
                                                           WHERE iqsr.id_icf_qualification = rd.id_iq_initial_incapacity
                                                             AND iqsr.id_icf_qualification_scale =
                                                                 rd.id_iqs_initial_incapacity),
                                                          '^(\s*)$',
                                                          NULL) ||
                                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                            FROM icf_qualif_scale_rel iqsr
                                                           WHERE iqsr.id_icf_qualification = rd.id_iq_expected_result
                                                             AND iqsr.id_icf_qualification_scale =
                                                                 rd.id_iqs_expected_result),
                                                          '^(\s*)$',
                                                          NULL) ||
                                           regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                            FROM icf_qualif_scale_rel iqsr
                                                           WHERE iqsr.id_icf_qualification = rd.id_iq_active_incapacity
                                                             AND iqsr.id_icf_qualification_scale =
                                                                 rd.id_iqs_active_incapacity),
                                                          '^(\s*)$',
                                                          NULL) || ' - ' ||
                                           pk_translation.get_translation(i_lang, i.code_icf),
                                           ', ') within GROUP(ORDER BY rpi.id_rehab_presc_icf_hist ASC)
                              FROM rehab_diagnosis rd
                             INNER JOIN icf i
                                ON rd.id_icf = i.id_icf
                              JOIN rehab_presc_icf_hist rpi
                                ON rpi.id_rehab_diagnosis = rd.id_rehab_diagnosis
                             WHERE rpi.id_rehab_presc = t.id_rehab_presc
                               AND rpi.dt_rehab_presc_icf_hist = t.dt_rehab_presc_hist_old) AS rehab_diagnosis_desc_concat_old
                      FROM (SELECT rph.id_rehab_presc,
                                   rph.dt_rehab_presc_hist,
                                   first_value(rph.dt_rehab_presc_hist) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_rehab_presc_hist_old,
                                   rph.id_rehab_presc_hist,
                                   first_value(rph.id_rehab_presc_hist) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_rehab_presc_hist_old,
                                   i.code_intervention,
                                   rst.code_rehab_session_type,
                                   i.id_intervention,
                                   rsn.id_rehab_sch_need id_rehab_sch_need,
                                   first_value(rsn.id_rehab_sch_need) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_rehab_sch_need_old,
                                   rsn.sessions num_sessions,
                                   first_value(rsn.sessions) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) num_sessions_old,
                                   rsn.flg_priority AS priority_data,
                                   first_value(rsn.flg_priority) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) priority_data_old,
                                   rsn.dt_begin,
                                   first_value(rsn.dt_begin) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_begin_old,
                                   rph.exec_per_session exec_session_desc,
                                   first_value(rph.exec_per_session) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) exec_session_desc_old,
                                   rph.id_exec_institution,
                                   first_value(rph.id_exec_institution) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_exec_institution_old,
                                   rph.notes,
                                   first_value(rph.notes) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_old,
                                   rsn.notes additional_notes,
                                   first_value(rsn.notes) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) additional_notes_old,
                                   rph.flg_laterality,
                                   first_value(rph.flg_laterality) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_laterality_old,
                                   rph.id_not_order_reason,
                                   first_value(rph.id_not_order_reason) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_not_order_reason_old,
                                   rph.diagnosis_notes,
                                   first_value(rph.diagnosis_notes) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) diagnosis_notes_old,
                                   rph.id_clinical_purpose,
                                   first_value(rph.id_clinical_purpose) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_clinical_purpose_old,
                                   rph.clinical_purpose_notes,
                                   first_value(rph.clinical_purpose_notes) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) clinical_purpose_notes_old,
                                   rai.id_rehab_area,
                                   rph.flg_status,
                                   first_value(rph.flg_status) over(ORDER BY rph.dt_rehab_presc_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_status_old,
                                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, rph.id_cancel_reason) cancel_reason_desc,
                                   rph.notes_cancel cancel_reason_notes,
                                   pk_prof_utils.get_name_signature(i_lang, i_prof, rph.id_professional) ||
                                   decode(pk_prof_utils.get_spec_signature(i_lang,
                                                                           i_prof,
                                                                           rph.id_professional,
                                                                           rph.dt_rehab_presc,
                                                                           rsn.id_episode_origin),
                                          NULL,
                                          '; ',
                                          ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                                   i_prof,
                                                                                   rph.id_professional,
                                                                                   rph.dt_rehab_presc,
                                                                                   rsn.id_episode_origin) || '); ') ||
                                   pk_date_utils.date_char_tsz(i_lang,
                                                               rph.dt_rehab_presc,
                                                               i_prof.institution,
                                                               i_prof.software) registry
                              FROM rehab_presc_hist rph
                              JOIN rehab_sch_need rsn
                                ON rph.id_rehab_sch_need = rsn.id_rehab_sch_need
                              JOIN rehab_session_type rst
                                ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                              JOIN rehab_area_interv rai
                                ON rai.id_rehab_area_interv = rph.id_rehab_area_interv
                              JOIN intervention i
                                ON i.id_intervention = rai.id_intervention
                             WHERE rph.id_rehab_presc = i_id_rehab_presc) t) tt;
    
        l_rec_rehab_hist     c_rehab_hist%ROWTYPE;
        l_index              PLS_INTEGER := 0;
        l_tab_dd_block_order t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_dd_block_aux   t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_dd_data        t_tab_dd_data := t_tab_dd_data();
        l_data_source_list   table_varchar := table_varchar();
    
        l_tbl_questionnaire t_tbl_clinical_question;
        l_count_cq          PLS_INTEGER := 0;
        l_tbl_cq_order      table_number := table_number();
    
    BEGIN
    
        g_error := 'OPEN c_rehab_hist';
        OPEN c_rehab_hist;
        LOOP
            g_error := 'Fetching c_rehab_hist into l_rec_rehab_hist';
            FETCH c_rehab_hist
                INTO l_rec_rehab_hist;
            EXIT WHEN c_rehab_hist%NOTFOUND;
        
            l_tab_dd_block_aux := t_tab_dd_block_data();
        
            l_index := l_index + 1;
        
            g_error := 'Fetching l_tab_dd_block_aux';
            SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                       (ddb.rank * 100) + l_index,
                                       NULL,
                                       NULL,
                                       ddb.condition_val,
                                       NULL,
                                       NULL,
                                       dd.data_source,
                                       dd.data_source_val,
                                       NULL)
              BULK COLLECT
              INTO l_tab_dd_block_aux
              FROM (SELECT data_source, data_source_val
                      FROM (SELECT *
                              FROM (SELECT NULL AS action,
                                           CASE
                                                WHEN l_rec_rehab_hist.diagnosis_notes IS NOT NULL
                                                     OR l_rec_rehab_hist.diagnosis_notes_new IS NOT NULL
                                                     OR l_rec_rehab_hist.diagnosis_desc IS NOT NULL
                                                     OR l_rec_rehab_hist.diagnosis_desc_new IS NOT NULL
                                                     OR l_rec_rehab_hist.clinical_purpose IS NOT NULL
                                                     OR l_rec_rehab_hist.clinical_purpose_new IS NOT NULL
                                                     OR l_rec_rehab_hist.icf IS NOT NULL
                                                     OR l_rec_rehab_hist.icf_new IS NOT NULL
                                                     OR l_rec_rehab_hist.desc_laterality IS NOT NULL
                                                     OR l_rec_rehab_hist.desc_laterality_new IS NOT NULL THEN
                                                 ' '
                                            END clinical_purpose_title,
                                           l_rec_rehab_hist.diagnosis_notes clinical_indication_ft,
                                           l_rec_rehab_hist.diagnosis_notes_new clinical_indication_ft_new,
                                           l_rec_rehab_hist.diagnosis_desc clinical_indication,
                                           l_rec_rehab_hist.diagnosis_desc_new clinical_indication_new,
                                           l_rec_rehab_hist.clinical_purpose,
                                           l_rec_rehab_hist.clinical_purpose_new,
                                           l_rec_rehab_hist.icf,
                                           l_rec_rehab_hist.icf_new,
                                           l_rec_rehab_hist.desc_laterality AS laterality,
                                           l_rec_rehab_hist.desc_laterality_new AS laterality_new,
                                           CASE
                                                WHEN l_rec_rehab_hist.desc_interv IS NOT NULL
                                                     OR l_rec_rehab_hist.rehab_area IS NOT NULL
                                                     OR l_rec_rehab_hist.desc_rehab_session_type IS NOT NULL
                                                     OR l_rec_rehab_hist.priority_desc IS NOT NULL
                                                     OR l_rec_rehab_hist.priority_desc_new IS NOT NULL
                                                     OR l_rec_rehab_hist.num_sessions_desc IS NOT NULL
                                                     OR l_rec_rehab_hist.num_sessions_desc_new IS NOT NULL
                                                     OR l_rec_rehab_hist.frequency_desc IS NOT NULL
                                                     OR l_rec_rehab_hist.frequency_desc_new IS NOT NULL
                                                     OR l_rec_rehab_hist.dt_begin IS NOT NULL
                                                     OR l_rec_rehab_hist.dt_begin_new IS NOT NULL
                                                     OR l_rec_rehab_hist.exec_session_desc IS NOT NULL
                                                     OR l_rec_rehab_hist.exec_session_desc_new IS NOT NULL
                                                     OR l_rec_rehab_hist.status IS NOT NULL
                                                     OR l_rec_rehab_hist.status_new IS NOT NULL THEN
                                                 ' '
                                                ELSE
                                                 NULL
                                            END AS instructions,
                                           l_rec_rehab_hist.desc_interv treatment,
                                           l_rec_rehab_hist.rehab_area,
                                           l_rec_rehab_hist.desc_rehab_session_type session_type,
                                           l_rec_rehab_hist.priority_desc priority,
                                           l_rec_rehab_hist.priority_desc_new priority_new,
                                           l_rec_rehab_hist.num_sessions_desc number_sessions,
                                           l_rec_rehab_hist.num_sessions_desc_new number_sessions_new,
                                           l_rec_rehab_hist.frequency_desc frequency,
                                           l_rec_rehab_hist.frequency_desc_new frequency_new,
                                           l_rec_rehab_hist.dt_begin start_date,
                                           l_rec_rehab_hist.dt_begin_new start_date_new,
                                           l_rec_rehab_hist.exec_session_desc execution_session,
                                           l_rec_rehab_hist.exec_session_desc_new execution_session_new,
                                           CASE
                                                WHEN l_rec_rehab_hist.exec_institution_data IS NOT NULL
                                                     OR l_rec_rehab_hist.exec_institution_data_new IS NOT NULL
                                                     OR l_rec_rehab_hist.not_order_reason_desc IS NOT NULL
                                                     OR l_rec_rehab_hist.not_order_reason_desc_new IS NOT NULL
                                                     OR l_rec_rehab_hist.notes IS NOT NULL
                                                     OR l_rec_rehab_hist.notes_new IS NOT NULL THEN
                                                 ' '
                                                ELSE
                                                 NULL
                                            END AS execution,
                                           l_rec_rehab_hist.exec_institution_data AS exec_institution,
                                           l_rec_rehab_hist.exec_institution_data_new AS exec_institution_new,
                                           l_rec_rehab_hist.not_order_reason_desc AS not_order_reason,
                                           l_rec_rehab_hist.not_order_reason_desc_new AS not_order_reason_new,
                                           l_rec_rehab_hist.notes,
                                           l_rec_rehab_hist.notes_new,
                                           l_rec_rehab_hist.additional_notes,
                                           l_rec_rehab_hist.additional_notes_new,
                                           l_rec_rehab_hist.status,
                                           l_rec_rehab_hist.status_new,
                                           CASE
                                                WHEN l_rec_rehab_hist.cancel_reason_desc_new IS NOT NULL
                                                     OR l_rec_rehab_hist.cancel_reason_notes_new IS NOT NULL THEN
                                                 ' '
                                            END cancel_reason_title,
                                           l_rec_rehab_hist.cancel_reason_desc_new,
                                           l_rec_rehab_hist.cancel_reason_notes_new,
                                           l_rec_rehab_hist.registry,
                                           ' ' white_line
                                      FROM dual) unpivot include NULLS(data_source_val FOR data_source IN(action,
                                                                                                          clinical_purpose_title,
                                                                                                          clinical_indication_ft,
                                                                                                          clinical_indication_ft_new,
                                                                                                          clinical_indication,
                                                                                                          clinical_indication_new,
                                                                                                          clinical_purpose,
                                                                                                          clinical_purpose_new,
                                                                                                          icf,
                                                                                                          icf_new,
                                                                                                          laterality,
                                                                                                          laterality_new,
                                                                                                          instructions,
                                                                                                          treatment,
                                                                                                          rehab_area,
                                                                                                          session_type,
                                                                                                          priority,
                                                                                                          priority_new,
                                                                                                          number_sessions,
                                                                                                          number_sessions_new,
                                                                                                          frequency,
                                                                                                          frequency_new,
                                                                                                          start_date,
                                                                                                          start_date_new,
                                                                                                          execution_session,
                                                                                                          execution_session_new,
                                                                                                          execution,
                                                                                                          exec_institution,
                                                                                                          exec_institution_new,
                                                                                                          not_order_reason,
                                                                                                          not_order_reason_new,
                                                                                                          notes,
                                                                                                          notes_new,
                                                                                                          additional_notes,
                                                                                                          additional_notes_new,
                                                                                                          status_new,
                                                                                                          status,
                                                                                                          cancel_reason_title,
                                                                                                          cancel_reason_desc_new,
                                                                                                          cancel_reason_notes_new,
                                                                                                          registry,
                                                                                                          white_line)))) dd
              JOIN dd_block ddb
                ON ddb.area = 'REHAB_TREATMENT'
               AND ddb.internal_name = 'ORDER'
               AND ddb.flg_available = pk_alert_constant.g_yes;
        
            FOR j IN l_tab_dd_block_aux.first .. l_tab_dd_block_aux.last
            LOOP
                l_tab_dd_block_order.extend();
                l_tab_dd_block_order(l_tab_dd_block_order.count) := l_tab_dd_block_aux(j);
            END LOOP;
        END LOOP;
        CLOSE c_rehab_hist;
    
        --Clinical questions
        l_tbl_questionnaire := pk_rehab.tf_get_clinical_questions(i_lang           => i_lang,
                                                                  i_prof           => i_prof,
                                                                  i_id_rehab_presc => i_id_rehab_presc,
                                                                  i_flg_time       => 'O',
                                                                  i_flg_history    => pk_alert_constant.g_yes);
    
        --Check if there are CQs in order to know if the label 'Clinical questions' should be displayed
        l_count_cq := l_tbl_questionnaire.count;
        --l_tbl_qc_order is used for the ranking of the clinical questions labels
        FOR i IN 1 .. l_index
        LOOP
            l_tbl_cq_order.extend();
            l_tbl_cq_order(i) := i;
        END LOOP;
    
        SELECT t_rec_dd_data(CASE
                                  WHEN data_code_message IS NOT NULL
                                       AND flg_type NOT IN ('L3CQ', 'L3CQN') THEN
                                   pk_message.get_message(i_lang => i_lang, i_code_mess => data_code_message)
                                  WHEN flg_type IN ('L3CQ') THEN
                                   data_code_message || ':'
                                  WHEN flg_type IN ('L3CQN') THEN
                                   data_code_message
                                  ELSE
                                   NULL
                              END, --DESCR
                              CASE
                                  WHEN flg_type = 'L1' THEN
                                   NULL
                                  ELSE
                                   data_source_val
                              END, --VAL
                              decode(flg_type, 'L3CQ', 'L3B', 'L3CQN', 'L3N', flg_type), -- TYPE
                              flg_html,
                              NULL,
                              flg_clob),
               data_source
          BULK COLLECT
          INTO l_tab_dd_data, l_data_source_list
          FROM (SELECT ddc.data_code_message,
                       flg_type,
                       data_source_val,
                       ddc.data_source,
                       db.rnk,
                       ddc.rank,
                       db.id_dd_block,
                       0 rank_cq,
                       flg_html,
                       flg_clob
                  FROM TABLE(l_tab_dd_block_order) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = 'REHAB_TREATMENT'
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L1' /*, 'L2B'*/))
                UNION ALL
                --Clinical qestions
                 (SELECT ddc.data_code_message,
                        'L2B' flg_type,
                        NULL data_source_val,
                        ddc.data_source,
                        (ddb.rank * 100) + t.column_value AS rnk,
                        ddc.rank,
                        ddc.id_dd_block,
                        0 rank_cq,
                        flg_html,
                        flg_clob
                   FROM TABLE(l_tbl_cq_order) t
                   JOIN dd_content ddc
                     ON ddc.data_source = 'CLINICAL_QUESTIONS_TITLE'
                    AND ddc.flg_available = pk_alert_constant.g_yes
                    AND ddc.area = 'REHAB_TREATMENT'
                    AND flg_type IN ('L2CQ')
                   JOIN dd_block ddb
                     ON ddb.area = ddc.area
                  WHERE l_count_cq > 0
                 UNION ALL
                 SELECT data_code_message,
                        flg_type,
                        data_source_val,
                        data_source,
                        rnk,
                        rank,
                        id_dd_block,
                        rank_qc,
                        flg_html,
                        flg_clob
                   FROM (( --Original/Previous clinical questions
                          SELECT t_cq.desc_clinical_question data_code_message,
                                  flg_type,
                                  t_cq.desc_response data_source_val,
                                  ddc.data_source,
                                  (ddb.rank * 100) + t_cq.num_order AS rnk,
                                  ddc.rank,
                                  ddc.id_dd_block,
                                  t_cq.num_order,
                                  t_cq.rank + 1 AS rank_qc, --+1 to assure that they are shown afer the new CQ
                                  flg_html,
                                  flg_clob
                            FROM TABLE(l_tbl_questionnaire) t_cq
                            JOIN dd_content ddc
                              ON ddc.data_source = 'CLINICAL_QUESTIONS'
                             AND ddc.flg_available = pk_alert_constant.g_yes
                             AND ddc.area = 'REHAB_TREATMENT'
                            JOIN dd_block ddb
                              ON ddb.area = ddc.area
                           WHERE flg_type IN ('L3CQ')
                          UNION ALL
                          --Edited Clinical questions
                          SELECT t_cq.desc_clinical_question_new data_code_message,
                                  flg_type,
                                  t_cq.desc_response_new data_source_val,
                                  ddc.data_source,
                                  (ddb.rank * 100) + t_cq.num_order AS rnk,
                                  ddc.rank,
                                  ddc.id_dd_block,
                                  t_cq.num_order,
                                  t_cq.rank AS rank_qc,
                                  flg_html,
                                  flg_clob
                            FROM TABLE(l_tbl_questionnaire) t_cq
                            JOIN dd_content ddc
                              ON ddc.data_source = 'CLINICAL_QUESTIONS_NEW'
                             AND ddc.flg_available = pk_alert_constant.g_yes
                             AND ddc.area = 'REHAB_TREATMENT'
                            JOIN dd_block ddb
                              ON ddb.area = ddc.area
                           WHERE flg_type IN ('L3CQN')
                             AND t_cq.desc_clinical_question_new IS NOT NULL))))
         ORDER BY rnk, rank, rank_cq;
    
        OPEN o_detail FOR
            SELECT descr, val, flg_type, flg_html, val_clob, flg_clob
              FROM (SELECT CASE
                                WHEN d.val IS NULL THEN
                                 d.descr
                                WHEN d.descr IS NULL THEN
                                 NULL
                                ELSE
                                 d.descr || ' '
                            END descr,
                           d.val,
                           d.flg_type,
                           flg_html,
                           val_clob,
                           flg_clob,
                           d.rn
                      FROM (SELECT rownum rn, descr, val, flg_type, flg_html, val_clob, flg_clob
                              FROM TABLE(l_tab_dd_data)) d
                      JOIN (SELECT rownum rn, column_value data_source
                             FROM TABLE(l_data_source_list)) ds
                        ON ds.rn = d.rn);
    
        RETURN TRUE;
    END get_rehab_treatment_history;

    FUNCTION get_diagnosis
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_rehab_presc      IN rehab_presc.id_rehab_presc%TYPE,
        i_id_rehab_presc_hist IN rehab_presc_hist.id_rehab_presc_hist%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_tbl_diag table_varchar;
        l_desc     VARCHAR2(4000);
        l_first    BOOLEAN := TRUE;
    
        l_ret VARCHAR2(4000);
    BEGIN
    
        IF i_id_rehab_presc_hist IS NULL
        THEN
            SELECT pk_string_utils.chop(concatenate(description || '; '), 2)
              INTO l_ret
              FROM (SELECT (SELECT pk_diagnosis.concat_diag(i_lang                   => i_lang,
                                                            i_exam_req_det           => NULL,
                                                            i_analysis_req_det       => NULL,
                                                            i_interv_presc_det       => NULL,
                                                            i_prof                   => i_prof,
                                                            i_nurse_tea_req          => NULL,
                                                            i_exam_result            => NULL,
                                                            i_blood_product_det      => NULL,
                                                            i_rehab_presc            => i_id_rehab_presc,
                                                            i_flg_terminology_server => pk_alert_constant.g_yes)
                              FROM dual) description
                      FROM rehab_presc rp
                     WHERE rp.id_rehab_presc = i_id_rehab_presc)
             WHERE description IS NOT NULL;
        ELSE
        
            SELECT t.desc_diagnosis
              BULK COLLECT
              INTO l_tbl_diag
              FROM (SELECT coalesce(ed.desc_epis_diagnosis,
                                    pk_diagnosis.concat_diag(i_lang                   => i_lang,
                                                             i_exam_req_det           => NULL,
                                                             i_analysis_req_det       => NULL,
                                                             i_interv_presc_det       => NULL,
                                                             i_prof                   => i_prof,
                                                             i_nurse_tea_req          => NULL,
                                                             i_exam_result            => NULL,
                                                             i_blood_product_det      => NULL,
                                                             i_rehab_presc            => id_rehab_presc,
                                                             i_flg_terminology_server => pk_alert_constant.g_yes)) desc_diagnosis
                      FROM (WITH rph AS (SELECT rph.id_rehab_presc, rph.dt_rehab_presc_hist
                                           FROM rehab_presc_hist rph
                                          WHERE rph.id_rehab_presc_hist = i_id_rehab_presc_hist)
                               SELECT mr.*
                                 FROM mcdt_req_diagnosis mr, rph r
                                WHERE mr.id_rehab_presc = r.id_rehab_presc
                                  AND (mr.id_rehab_presc_hist <= i_id_rehab_presc_hist AND
                                      (mr.dt_cancel_tstz IS NULL OR mr.dt_cancel_tstz > r.dt_rehab_presc_hist))) mrd
                                 LEFT JOIN epis_diagnosis ed
                                   ON ed.id_epis_diagnosis = mrd.id_epis_diagnosis
                                 JOIN diagnosis d
                                   ON d.id_diagnosis = mrd.id_diagnosis
                                ORDER BY desc_diagnosis
                    ) t
             WHERE t.desc_diagnosis IS NOT NULL;
        
            IF l_tbl_diag IS NOT NULL
               AND l_tbl_diag.count > 0
            THEN
                FOR i IN l_tbl_diag.first .. l_tbl_diag.last
                LOOP
                    IF l_first
                    THEN
                        l_first := FALSE;
                    ELSE
                        l_desc := l_desc || '; ';
                    END IF;
                    l_desc := l_desc || l_tbl_diag(i);
                END LOOP;
            END IF;
        
            SELECT pk_string_utils.chop(concatenate(description || '; '), 2)
              INTO l_ret
              FROM (SELECT l_desc AS description
                      FROM dual);
        END IF;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_diagnosis;

    FUNCTION get_rehab_area_interv_hash
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_rehab_area_interv IN rehab_area_interv.id_rehab_area_interv%TYPE
    ) RETURN NUMBER IS
    
        l_hash_aux VARCHAR2(30 CHAR);
        l_ret_hash NUMBER(24);
    BEGIN
        l_hash_aux := i_id_rehab_area_interv || i_prof.id;
        l_ret_hash := dbms_utility.get_hash_value(l_hash_aux, 37, 1073741824);
        RETURN l_ret_hash;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_rehab_area_interv_hash;

    FUNCTION manage_most_frequent_rehab
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_rehab_area_interv IN rehab_area_interv.id_rehab_area_interv%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN AS
        l_hash  NUMBER(24);
        l_count NUMBER(24);
    BEGIN
        l_hash := get_rehab_area_interv_hash(i_lang, i_prof, i_id_rehab_area_interv);
    
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_most_frequent rf
         WHERE rf.id_rehab_area_interv = i_id_rehab_area_interv
           AND rf.id_universe = 8
           AND rf.rehab_interv_hash = l_hash;
    
        IF l_count > 0
        THEN
            UPDATE rehab_most_frequent
               SET rank = rank + 1
             WHERE id_rehab_area_interv = i_id_rehab_area_interv
               AND rehab_interv_hash = l_hash;
        ELSE
            INSERT INTO rehab_most_frequent
                (id_rehab_most_frequent, id_universe, id_value, id_rehab_area_interv, rehab_interv_hash, rank)
            VALUES
                (seq_rehab_most_frequent.nextval, 8, i_prof.id, i_id_rehab_area_interv, l_hash, 1);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'MANAGE_MOST_FREQUENT_REHAB',
                                              o_error);
            RETURN FALSE;
    END manage_most_frequent_rehab;

    FUNCTION set_rehab_favorite
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_rehab_area_interv IN rehab_area_interv.id_rehab_area_interv%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN AS
        l_count NUMBER;
    BEGIN
    
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_interv_favorites rei
         WHERE rei.id_rehab_area_interv = i_id_rehab_area_interv
           AND rei.id_professional = i_prof.id;
    
        IF l_count > 0
        THEN
            DELETE FROM rehab_interv_favorites rei
             WHERE rei.id_rehab_area_interv = i_id_rehab_area_interv
               AND rei.id_professional = i_prof.id;
        ELSE
            INSERT INTO rehab_interv_favorites
                (id_rehab_interv_favorites, id_rehab_area_interv, id_professional)
            VALUES
                (seq_rehab_interv_favorites.nextval, i_id_rehab_area_interv, i_prof.id);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_REHAB_FAVORITE',
                                              o_error);
            RETURN FALSE;
    END set_rehab_favorite;

    FUNCTION get_flg_favorite
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_rehab_area_interv IN rehab_area_interv.id_rehab_area_interv%TYPE
    ) RETURN VARCHAR2 AS
        l_count NUMBER;
    BEGIN
        SELECT COUNT(*)
          INTO l_count
          FROM rehab_interv_favorites rei
         WHERE rei.id_rehab_area_interv = i_id_rehab_area_interv
           AND rei.id_professional = i_prof.id;
    
        IF l_count > 0
        THEN
            RETURN pk_alert_constant.g_yes;
        ELSE
            RETURN pk_alert_constant.g_no;
        END IF;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_constant.g_no;
    END get_flg_favorite;

    FUNCTION get_actions
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_subject        IN action.subject%TYPE,
        i_from_state     IN action.from_state%TYPE,
        i_episode_origin IN episode.id_episode%TYPE,
        o_actions        OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_error := 'GET CURSOR o_actions';
        OPEN o_actions FOR
            SELECT t.id_action,
                   t.id_parent,
                   LEVEL,
                   t.from_state,
                   t.to_state,
                   t.desc_action,
                   t.icon,
                   t.flg_default,
                   t.flg_active,
                   t.action
              FROM (WITH action_children AS (SELECT rsn.id_rehab_sch_need id_action,
                                                    a.id_parent,
                                                    NULL from_state,
                                                    NULL to_state,
                                                    get_instructions(i_lang, i_prof, rsn.id_rehab_sch_need, 'PFSD') desc_action,
                                                    a.icon,
                                                    NULL flg_default,
                                                    'A' flg_active,
                                                    NULL action,
                                                    row_number() over(PARTITION BY rsn.id_rehab_sch_need ORDER BY rsn.dt_rehab_sch_need DESC) AS rank
                                               FROM rehab_sch_need rsn
                                               JOIN action a
                                                 ON a.subject = 'REHAB_TREATMENT_INSTRUCTIONS'
                                              WHERE rsn.id_episode_origin = i_episode_origin
                                                AND rsn.flg_status = g_rehab_sch_need_wait_sch
                                                AND rsn.id_rehab_sch_need IN
                                                    (SELECT t.id_rehab_sch_need
                                                       FROM (SELECT rsn_i.id_rehab_sch_need,
                                                                    row_number() over(PARTITION BY rsn_i.sessions, rsn_i.frequency, rsn_i.flg_frequency, rsn_i.flg_priority, rsn_i.dt_begin, rsn_i.notes ORDER BY rsn_i.id_rehab_sch_need ASC) AS rn
                                                               FROM rehab_sch_need rsn_i
                                                              WHERE rsn_i.id_episode_origin = i_episode_origin
                                                                AND rsn_i.flg_status = g_rehab_sch_need_wait_sch) t
                                                      WHERE t.rn = 1))
                       SELECT /*+opt_estimate(table act rows=1)*/
                        a.id_action,
                        a.id_parent,
                        a.from_state,
                        a.to_state,
                        a.desc_action,
                        a.icon,
                        a.flg_default,
                        CASE
                             WHEN (SELECT COUNT(1)
                                     FROM action_children) > 0 THEN
                              a.flg_active
                             ELSE
                              'I'
                         END flg_active,
                        a.action,
                        NULL rank
                         FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, i_subject, i_from_state)) a
                       UNION ALL
                       SELECT ac.*
                         FROM action_children ac) t
                       CONNECT BY PRIOR t.id_action = t.id_parent
                        START WITH t.id_parent IS NULL
                        ORDER BY LEVEL, t.rank, t.desc_action;
    
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ACTIONS',
                                              o_error);
        
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_actions);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_actions;

    FUNCTION get_rehab_prof_name
    (
        i_lang                IN NUMBER,
        i_prof                IN profissional,
        i_id_prof             IN NUMBER,
        i_id_resp_prof        IN NUMBER,
        i_id_resp_rehab_group IN NUMBER,
        i_flg_type            IN VARCHAR2,
        i_id_episode_rehab    IN NUMBER,
        i_id_episode          IN NUMBER,
        i_id_patient          IN NUMBER,
        i_id_software         IN NUMBER
    ) RETURN VARCHAR2 IS
    
        l_return VARCHAR2(4000);
    
    BEGIN
    
        CASE
            WHEN i_id_prof IS NULL
                 AND i_id_resp_prof IS NOT NULL THEN
            
                l_return := pk_rehab.get_rehab_sch_need_resp(i_lang, i_id_resp_prof, i_id_resp_rehab_group);
            WHEN i_id_prof IS NOT NULL
                 AND i_id_resp_prof IS NULL THEN
            
                l_return := pk_prof_utils.get_name(i_lang, i_id_prof);
            
            WHEN i_id_prof IS NOT NULL
                 AND i_id_resp_prof IS NULL
                 AND i_flg_type != 'W' THEN
            
                IF i_id_software = 36
                THEN
                    l_return := pk_cdoc_filters.transform(i_lang  => i_lang,
                                                          i_prof  => i_prof,
                                                          i_code  => 'PROF_IN_CHARGE',
                                                          i_num01 => table_number(nvl(i_id_episode_rehab, i_id_episode),
                                                                                  i_id_patient),
                                                          i_var01 => table_varchar());
                ELSE
                    l_return := pk_prof_utils.get_name(i_lang, i_id_prof);
                END IF;
            
            WHEN i_id_prof IS NOT NULL
                 AND i_id_resp_prof IS NULL
                 AND i_flg_type = 'W' THEN
            
                l_return := pk_prof_utils.get_name(i_lang, i_id_resp_prof);
            ELSE
                l_return := pk_prof_utils.get_name(i_lang, i_id_prof);
        END CASE;
    
        RETURN l_return;
    
    END get_rehab_prof_name;

    FUNCTION get_questionnaire_id_content
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_questionnaire IN questionnaire.id_questionnaire%TYPE,
        i_response      IN response.id_response%TYPE
    ) RETURN VARCHAR2 IS
    
        l_content VARCHAR2(200 CHAR);
    
    BEGIN
    
        IF i_response IS NOT NULL
        THEN
            g_error := 'SELECT QUESTIONNAIRE_RESPONSE';
            SELECT id_content
              INTO l_content
              FROM questionnaire_response qr
             WHERE qr.id_questionnaire = i_questionnaire
               AND qr.id_response = i_response
               AND qr.flg_available = pk_alert_constant.g_yes;
        ELSE
            g_error := 'SELECT QUESTIONNAIRE';
            SELECT id_content
              INTO l_content
              FROM questionnaire q
             WHERE q.id_questionnaire = i_questionnaire
               AND q.flg_available = pk_alert_constant.g_yes;
        END IF;
    
        RETURN l_content;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_questionnaire_id_content;

    FUNCTION get_rehab_response
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_patient       IN patient.id_patient%TYPE,
        i_questionnaire IN questionnaire_response.id_questionnaire%TYPE,
        i_intervention  IN intervention.id_intervention%TYPE,
        i_flg_time      IN VARCHAR2,
        i_inst_dest     IN institution.id_institution%TYPE
    ) RETURN table_varchar IS
    
        CURSOR c_patient IS
            SELECT gender, trunc(months_between(SYSDATE, dt_birth) / 12) age
              FROM patient
             WHERE id_patient = i_patient;
    
        l_patient c_patient%ROWTYPE;
    
        l_response table_varchar;
    
    BEGIN
    
        g_error := 'OPEN C_PATIENT';
        OPEN c_patient;
        FETCH c_patient
            INTO l_patient;
        CLOSE c_patient;
    
        g_error := 'SELECT QUESTIONNAIRE_RESPONSE';
        SELECT qr.id_response || '|' || qr.desc_response || '|' || qr.flg_free_text
          BULK COLLECT
          INTO l_response
          FROM (SELECT qr.id_response,
                       pk_mcdt.get_response_alias(i_lang, i_prof, 'RESPONSE.CODE_RESPONSE.' || qr.id_response) desc_response,
                       r.flg_free_text,
                       qr.rank
                  FROM questionnaire_response qr, response r
                 WHERE qr.id_questionnaire = i_questionnaire
                   AND qr.flg_available = pk_alert_constant.g_available
                   AND qr.id_response = r.id_response
                   AND r.flg_available = pk_alert_constant.g_available
                   AND EXISTS (SELECT 1
                          FROM interv_questionnaire rq
                         WHERE rq.id_intervention = i_intervention
                           AND rq.flg_time = i_flg_time
                           AND rq.id_questionnaire = qr.id_questionnaire
                           AND rq.id_response = qr.id_response
                           AND rq.id_institution = nvl(i_inst_dest, i_prof.institution)
                           AND rq.flg_available = pk_procedures_constant.g_available)
                   AND (((l_patient.gender IS NOT NULL AND
                       coalesce(r.gender, 'I', 'U', 'N') IN ('I', 'U', 'N', l_patient.gender)) OR
                       l_patient.gender IS NULL OR l_patient.gender IN ('I', 'U', 'N')) AND
                       (nvl(l_patient.age, 0) BETWEEN nvl(r.age_min, 0) AND
                       nvl(r.age_max, nvl(l_patient.age, 0)) OR nvl(l_patient.age, 0) = 0))) qr
         ORDER BY qr.rank, qr.desc_response;
    
        RETURN l_response;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_rehab_response;

    FUNCTION get_rehab_response
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        i_notes IN interv_question_response.notes%TYPE
    ) RETURN interv_question_response.notes%TYPE IS
    
        l_ret interv_question_response.notes%TYPE;
    
    BEGIN
        -- Heuristic to minimize attempts to parse an invalid date
        IF dbms_lob.getlength(i_notes) = length('YYYYMMDDHHMMSS')
           AND pk_utils.is_number(char_in => i_notes) = pk_procedures_constant.g_yes -- This is the size of a stored serialized date, not a mask (HH vs HH24).-- This is the size of a stored serialized date, not a mask (HH vs HH24).
        THEN
            -- We try to parse the note as a serialized date
            l_ret := pk_date_utils.dt_chr_str(i_lang     => i_lang,
                                              i_date     => i_notes,
                                              i_inst     => i_prof.institution,
                                              i_soft     => i_prof.software,
                                              i_timezone => NULL);
        ELSE
            l_ret := i_notes;
        END IF;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            -- Ignore parse errors and return original content
            RETURN i_notes;
    END get_rehab_response;

    FUNCTION tf_get_clinical_questions
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_rehab_presc IN rehab_presc.id_rehab_presc%TYPE,
        i_flg_time       IN bp_question_response.flg_time%TYPE,
        i_flg_history    IN VARCHAR DEFAULT pk_alert_constant.g_no
    ) RETURN t_tbl_clinical_question IS
    
        l_ret t_tbl_clinical_question := t_tbl_clinical_question();
    
    BEGIN
    
        IF i_flg_history = pk_alert_constant.g_no
        THEN
            SELECT t_rec_clinical_question(desc_clinical_question, NULL, desc_response, NULL, 1, rank)
              BULK COLLECT
              INTO l_ret
              FROM (SELECT flg_time, desc_clinical_question, desc_response, rank
                      FROM (SELECT DISTINCT bqr1.id_rehab_presc,
                                            bqr1.id_content,
                                            bqr1.flg_time,
                                            bqr1.id_questionnaire,
                                            pk_mcdt.get_questionnaire_alias(i_lang,
                                                                            i_prof,
                                                                            'QUESTIONNAIRE.CODE_QUESTIONNAIRE.' ||
                                                                            bqr1.id_questionnaire) desc_clinical_question,
                                            dbms_lob.substr(decode(dbms_lob.getlength(bqr.notes),
                                                                   NULL,
                                                                   to_clob(decode(bqr1.desc_response,
                                                                                  NULL,
                                                                                  '---',
                                                                                  bqr1.desc_response)),
                                                                   pk_rehab.get_rehab_response(i_lang, i_prof, bqr.notes)),
                                                            3800) desc_response,
                                            pk_rehab.get_rehab_presc_quest_rank(i_lang,
                                                                                i_prof,
                                                                                rai.id_intervention,
                                                                                bqr.id_questionnaire,
                                                                                bqr.flg_time) rank
                              FROM (SELECT bqr.id_rehab_presc,
                                           bqr.id_questionnaire,
                                           listagg(pk_rehab.get_questionnaire_id_content(i_lang,
                                                                                         i_prof,
                                                                                         bqr.id_questionnaire,
                                                                                         bqr.id_response),
                                                   '; ') within GROUP(ORDER BY bqr.id_response) id_content,
                                           bqr.flg_time,
                                           listagg(pk_mcdt.get_response_alias(i_lang,
                                                                              i_prof,
                                                                              'RESPONSE.CODE_RESPONSE.' || bqr.id_response),
                                                   '; ') within GROUP(ORDER BY bqr.id_response) desc_response,
                                           bqr.dt_last_update_tstz,
                                           row_number() over(PARTITION BY bqr.id_questionnaire, bqr.flg_time ORDER BY bqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                      FROM rehab_question_response bqr
                                     WHERE bqr.id_rehab_presc = i_id_rehab_presc
                                     GROUP BY bqr.id_rehab_presc,
                                              bqr.id_questionnaire,
                                              bqr.flg_time,
                                              bqr.dt_last_update_tstz) bqr1,
                                   rehab_question_response bqr,
                                   rehab_presc rp,
                                   rehab_area_interv rai
                             WHERE bqr1.rn = 1
                               AND bqr1.id_rehab_presc = bqr.id_rehab_presc
                               AND bqr1.id_questionnaire = bqr.id_questionnaire
                               AND bqr1.dt_last_update_tstz = bqr.dt_last_update_tstz
                               AND bqr1.flg_time = bqr.flg_time
                               AND bqr1.flg_time = i_flg_time
                               AND rp.id_rehab_presc = bqr.id_rehab_presc
                               AND rai.id_rehab_area_interv = rp.id_rehab_area_interv)
                     ORDER BY flg_time, rank);
        ELSE
            SELECT t_rec_clinical_question(desc_clinical_question     => desc_clinical_question,
                                           desc_clinical_question_new => desc_clinical_question_new,
                                           desc_response              => desc_response,
                                           desc_response_new          => desc_response_new,
                                           num_order                  => num_order,
                                           rank                       => rank)
              BULK COLLECT
              INTO l_ret
              FROM (SELECT flg_time,
                           id_questionnaire,
                           desc_clinical_question,
                           desc_clinical_question_new,
                           desc_response,
                           desc_response_new,
                           rank,
                           row_number() over(PARTITION BY id_questionnaire ORDER BY dt_last_update_tstz DESC) AS num_order
                      FROM (SELECT bqro.id_rehab_presc,
                                   qst.id_content,
                                   bqro.flg_time,
                                   pk_translation.get_translation(i_lang, qst.code_questionnaire) desc_clinical_question,
                                   CASE
                                        WHEN bqro.previous_rownum IS NULL THEN
                                        --Primeiro questionário
                                         NULL
                                    --EDIÇÕES
                                        WHEN bqro.flg_new = pk_alert_constant.g_yes THEN
                                         pk_translation.get_translation(i_lang, qst.code_questionnaire) || ' ' ||
                                         lower(pk_message.get_message(i_lang, i_prof, 'LAB_TESTS_T236'))
                                    --ANTIGO
                                        ELSE
                                         NULL
                                    END desc_clinical_question_new,
                                   CASE
                                        WHEN bqro.previous_rownum IS NULL THEN
                                        --Primeiro questionário                                           
                                         CASE
                                             WHEN bqro.current_questionnaire IS NULL THEN
                                              '---'
                                             ELSE
                                              to_char(bqro.current_questionnaire)
                                         END
                                    --EDIÇÕES
                                        WHEN bqro.flg_new = pk_alert_constant.g_yes THEN
                                        --NOVO
                                         CASE
                                             WHEN bqro.previous_questionnaire IS NULL THEN
                                              '---'
                                             ELSE
                                              to_char(bqro.previous_questionnaire)
                                         END
                                    --ANTIGO
                                        ELSE --WHEN THE ANSWER HAS NOT BEEN CHANGED => SHOW NONTHELESS
                                         CASE
                                             WHEN bqro.previous_questionnaire IS NULL THEN
                                              '---'
                                             ELSE
                                              to_char(bqro.previous_questionnaire)
                                         END
                                    END desc_response,
                                   CASE
                                        WHEN bqro.previous_rownum IS NULL THEN
                                         NULL
                                    --EDIÇÕES
                                        WHEN bqro.flg_new = pk_alert_constant.g_yes THEN
                                        --NOVO
                                         CASE
                                             WHEN bqro.current_questionnaire IS NULL THEN
                                              '---'
                                             ELSE
                                              to_char(bqro.current_questionnaire)
                                         END
                                    --ANTIGO
                                        ELSE --WHEN THE ANSWER HAS NOT BEEN CHANGED => SHOW NONTHELESS
                                         NULL
                                    END desc_response_new,
                                   bqro.current_rownum,
                                   bqro.id_questionnaire,
                                   bqro.dt_last_update_tstz,
                                   bqro.rank
                              FROM (SELECT erd1.id_questionnaire,
                                           erd1.id_rehab_presc,
                                           pk_rehab.get_rehab_response(i_lang, i_prof, erd1.notes) current_questionnaire,
                                           erd1.flg_time,
                                           erd1.dt_last_update_tstz,
                                           erd1.rn current_rownum,
                                           erd2.notes previous_questionnaire,
                                           erd2.rn previous_rownum,
                                           CASE
                                                WHEN erd2.rn IS NULL THEN
                                                 pk_alert_constant.g_yes
                                                WHEN to_char(erd1.notes) IS NULL
                                                     AND to_char(erd2.notes) IS NULL THEN
                                                 pk_alert_constant.g_no
                                                WHEN to_char(erd1.notes) = to_char(erd2.notes) THEN
                                                 pk_alert_constant.g_no
                                                ELSE
                                                 pk_alert_constant.g_yes
                                            END AS flg_new,
                                           pk_rehab.get_rehab_presc_quest_rank(i_lang,
                                                                               i_prof,
                                                                               rai.id_intervention,
                                                                               erd1.id_questionnaire,
                                                                               erd1.flg_time) rank
                                      FROM (SELECT id_questionnaire,
                                                   id_rehab_presc,
                                                   notes,
                                                   flg_time,
                                                   dt_last_update_tstz,
                                                   row_number() over(PARTITION BY id_questionnaire ORDER BY id_questionnaire ASC, dt_last_update_tstz DESC) rn,
                                                   dt_last_update
                                              FROM (SELECT *
                                                      FROM (SELECT bqr.id_rehab_question_response,
                                                                   bqr.id_rehab_presc,
                                                                   bqr.id_questionnaire,
                                                                   bqr.dt_last_update_tstz,
                                                                   bqr.notes,
                                                                   bqr.flg_time flg_time,
                                                                   row_number() over(PARTITION BY bqr.id_questionnaire, bqr.dt_last_update_tstz ORDER BY bqr.id_rehab_question_response) AS rn,
                                                                   pk_date_utils.date_send_tsz(i_lang,
                                                                                               bqr.dt_last_update_tstz,
                                                                                               i_prof) dt_last_update
                                                              FROM rehab_question_response bqr
                                                             WHERE bqr.id_rehab_presc = i_id_rehab_presc)
                                                     WHERE rn = 1)) erd1
                                      LEFT JOIN (SELECT id_questionnaire,
                                                       id_rehab_presc,
                                                       notes,
                                                       dt_last_update_tstz,
                                                       row_number() over(PARTITION BY id_questionnaire ORDER BY id_questionnaire ASC, dt_last_update_tstz DESC) rn
                                                  FROM (SELECT *
                                                          FROM (SELECT bqr.id_rehab_question_response,
                                                                       bqr.id_rehab_presc,
                                                                       bqr.id_questionnaire,
                                                                       bqr.dt_last_update_tstz,
                                                                       bqr.notes,
                                                                       row_number() over(PARTITION BY bqr.id_questionnaire, bqr.dt_last_update_tstz ORDER BY bqr.id_rehab_question_response) AS rn --Because of multichoice options
                                                                  FROM rehab_question_response bqr
                                                                 WHERE bqr.id_rehab_presc = i_id_rehab_presc)
                                                         WHERE rn = 1)) erd2
                                        ON erd2.id_questionnaire = erd1.id_questionnaire
                                       AND erd2.id_rehab_presc = erd1.id_rehab_presc
                                       AND erd1.rn = (erd2.rn - 1)
                                      JOIN rehab_presc rp
                                        ON rp.id_rehab_presc = erd1.id_rehab_presc
                                      JOIN rehab_area_interv rai
                                        ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                                     ORDER BY erd1.rn ASC, rank ASC) bqro
                              JOIN questionnaire qst
                                ON qst.id_questionnaire = bqro.id_questionnaire)
                     ORDER BY dt_last_update_tstz, rank);
        END IF;
    
        RETURN l_ret;
    
    END tf_get_clinical_questions;

    FUNCTION get_full_items_by_screen
    (
        i_lang        IN NUMBER,
        i_prof        IN profissional,
        i_patient     IN NUMBER,
        i_episode     IN NUMBER,
        i_screen_name IN VARCHAR2,
        i_action      IN NUMBER,
        o_components  OUT pk_types.cursor_type,
        o_ds_target   OUT pk_types.cursor_type,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_patient IS
            SELECT gender, trunc(months_between(SYSDATE, dt_birth) / 12) age
              FROM patient
             WHERE id_patient = i_patient;
    
        l_patient c_patient%ROWTYPE;
    
        l_intervention table_number;
    
    BEGIN
    
        IF i_patient IS NOT NULL
        THEN
            g_error := 'OPEN C_PAT';
            OPEN c_patient;
            FETCH c_patient
                INTO l_patient;
            CLOSE c_patient;
        END IF;
    
        l_intervention := pk_utils.str_split_n(i_list => i_screen_name, i_delim => '|');
    
        OPEN o_components FOR
            SELECT 0 id_ds_cmpt_mkt_rel,
                   NULL id_ds_component_parent,
                   NULL code_alt_desc,
                   pk_message.get_message(i_lang, 'PROCEDURES_T163') desc_component,
                   i_screen_name internal_name,
                   NULL flg_data_type,
                   NULL internal_sample_text_type,
                   0 id_ds_component_child,
                   1 rank,
                   NULL max_len,
                   NULL min_len,
                   NULL min_value,
                   NULL max_value,
                   1 position,
                   NULL flg_multichoice,
                   NULL comp_size,
                   NULL flg_wrap_text,
                   NULL multichoice_code,
                   NULL service_params,
                   NULL flg_event_type,
                   NULL flg_exp_type,
                   NULL input_expression,
                   NULL input_mask,
                   NULL comp_offset,
                   NULL flg_hidden,
                   NULL placeholder,
                   NULL validation_message,
                   NULL flg_clearable,
                   NULL crate_identifier,
                   1 rn,
                   NULL flg_repeatable,
                   NULL flg_data_type2
              FROM dual
            UNION ALL
            SELECT /*+ opt_estimate(table t rows=1) */
             to_number(t.column_value) id_ds_cmpt_mkt_rel,
             0 id_ds_component_parent,
             NULL code_alt_desc,
             pk_translation.get_translation(i_lang, 'INTERVENTION.CODE_INTERVENTION.' || to_number(t.column_value)) desc_component,
             pk_translation.get_translation(i_lang, 'INTERVENTION.CODE_INTERVENTION.' || to_number(t.column_value)) internal_name,
             NULL flg_data_type,
             NULL internal_sample_text_type,
             to_number(t.column_value) id_ds_component_child,
             rownum rank,
             NULL max_len,
             NULL min_len,
             NULL min_value,
             NULL max_value,
             rownum position,
             NULL flg_multichoice,
             NULL comp_size,
             NULL flg_wrap_text,
             NULL multichoice_code,
             NULL service_params,
             NULL flg_event_type,
             NULL flg_exp_type,
             NULL input_expression,
             NULL input_mask,
             NULL comp_offset,
             NULL flg_hidden,
             NULL placeholder,
             NULL validation_message,
             NULL flg_clearable,
             NULL crate_identifier,
             rownum rn,
             NULL flg_repeatable,
             NULL flg_data_type2
              FROM TABLE(l_intervention) t
            UNION ALL
            SELECT (q.id_questionnaire + q.id_intervention) id_ds_cmpt_mkt_rel,
                   q.id_intervention id_ds_component_parent,
                   NULL code_alt_desc,
                   pk_mcdt.get_questionnaire_alias(i_lang,
                                                   i_prof,
                                                   'QUESTIONNAIRE.CODE_QUESTIONNAIRE.' || q.id_questionnaire) desc_component,
                   to_char(q.id_questionnaire) internal_name,
                   decode(q.flg_type, 'D', 'DT', 'ME', 'MS', 'MI', 'MM', 'N', 'K', NULL) flg_data_type,
                   NULL internal_sample_text_type,
                   q.id_questionnaire id_ds_component_child,
                   q.id_questionnaire rank,
                   NULL max_len,
                   NULL min_len,
                   NULL min_value,
                   NULL max_value,
                   rownum + 1000 position,
                   decode(q.flg_type, 'ME', 'SRV', 'MI', 'SRV', NULL) flg_multichoice,
                   NULL comp_size,
                   NULL flg_wrap_text,
                   decode(q.flg_type, 'ME', 'GET_MULTICHOICE_CQ', 'MI', 'GET_MULTICHOICE_CQ', NULL) multichoice_code,
                   (q.id_questionnaire + q.id_intervention) service_params,
                   decode(q.id_questionnaire_parent, NULL, decode(q.flg_mandatory, 'Y', 'M', NULL), 'I') flg_event_type,
                   NULL flg_exp_type,
                   NULL input_expression,
                   decode(q.flg_type, 'D', 'mediumDate', NULL) input_mask,
                   NULL comp_offset,
                   pk_alert_constant.g_no flg_hidden,
                   NULL placeholder,
                   NULL validation_message,
                   pk_alert_constant.g_yes flg_clearable,
                   NULL crate_identifier,
                   rownum + 100 rn,
                   NULL flg_repeatable,
                   NULL flg_data_type2
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure
                      FROM interv_questionnaire iq,
                           questionnaire_response qr,
                           (SELECT /*+ opt_estimate(table t rows=1) */
                             t.column_value id_intervention
                              FROM TABLE(l_intervention) t) i
                     WHERE iq.id_intervention = i.id_intervention
                       AND iq.flg_time = 'O'
                       AND iq.id_institution = i_prof.institution
                       AND iq.flg_available = pk_procedures_constant.g_available
                       AND iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND EXISTS
                     (SELECT 1
                              FROM questionnaire q
                             WHERE q.id_questionnaire = iq.id_questionnaire
                               AND q.flg_available = pk_procedures_constant.g_available
                               AND (((l_patient.gender IS NOT NULL AND coalesce(q.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                   ('I', 'U', 'N', 'C', 'A', 'B', l_patient.gender)) OR l_patient.gender IS NULL OR
                                   l_patient.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                   (nvl(l_patient.age, 0) BETWEEN nvl(q.age_min, 0) AND
                                   nvl(q.age_max, nvl(l_patient.age, 0)) OR nvl(l_patient.age, 0) = 0)))) q
             ORDER BY rank;
    
        OPEN o_ds_target FOR
            SELECT (q.id_questionnaire + q.id_intervention) id_cmpt_mkt_origin,
                   q.id_questionnaire id_cmpt_origin,
                   q.id_questionnaire id_ds_event,
                   'S' flg_type,
                   NULL VALUE,
                   NULL id_cmpt_mkt_dest,
                   NULL id_cmpt_dest,
                   NULL field_mask,
                   NULL flg_event_target_type,
                   NULL validation_message,
                   1 rn
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure,
                                    iq.rank
                      FROM interv_questionnaire iq, questionnaire_response qr
                     WHERE iq.id_intervention IN (SELECT /*+ opt_estimate(table t rows=1) */
                                                   *
                                                    FROM TABLE(l_intervention) t)
                       AND iq.flg_time = 'O'
                       AND iq.id_institution = i_prof.institution
                       AND iq.flg_available = pk_procedures_constant.g_available
                       AND iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND EXISTS
                     (SELECT 1
                              FROM questionnaire q
                             WHERE q.id_questionnaire = iq.id_questionnaire
                               AND q.flg_available = pk_procedures_constant.g_available
                               AND (((l_patient.gender IS NOT NULL AND coalesce(q.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                   ('I', 'U', 'N', 'C', 'A', 'B', l_patient.gender)) OR l_patient.gender IS NULL OR
                                   l_patient.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                   (nvl(l_patient.age, 0) BETWEEN nvl(q.age_min, 0) AND
                                   nvl(q.age_max, nvl(l_patient.age, 0)) OR nvl(l_patient.age, 0) = 0)))) q
             WHERE q.id_response_parent IS NULL
               AND q.flg_type IN ('ME', 'MI')
             ORDER BY rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              'g_error',
                                              'g_package_owner',
                                              'g_package_name',
                                              'GET_FULL_ITEMS_BY_SCREEN',
                                              o_error);
            RETURN FALSE;
    END get_full_items_by_screen;

    FUNCTION get_rehab_presc_quest_rank
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_intervention  IN interv_questionnaire.id_intervention%TYPE,
        i_questionnaire IN questionnaire.id_questionnaire%TYPE,
        i_flg_time      IN interv_questionnaire.flg_time%TYPE
    ) RETURN NUMBER IS
    
        l_rank NUMBER;
    
    BEGIN
    
        g_error := 'SELECT REHAB_QUESTIONNAIRE';
        SELECT MAX(rq.rank)
          INTO l_rank
          FROM interv_questionnaire rq
         WHERE rq.id_intervention = i_intervention
           AND rq.id_questionnaire = i_questionnaire
           AND rq.flg_time = i_flg_time
           AND rq.id_institution = i_prof.institution
           AND rq.flg_available = pk_alert_constant.g_available;
    
        RETURN l_rank;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_rehab_presc_quest_rank;

    FUNCTION get_patient_icf
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_patient IN patient.id_patient%TYPE
    ) RETURN t_tbl_core_domain IS
    
        l_list t_tbl_core_domain;
    
        l_error t_error_out;
    
    BEGIN
    
        g_error := 'OPEN L_LIST';
        SELECT *
          BULK COLLECT
          INTO l_list
          FROM (SELECT t_row_core_domain(NULL, t.label, t.data, t.rank, NULL)
                  FROM (SELECT rd.id_rehab_diagnosis data,
                               regexp_replace((SELECT REPLACE(sys_connect_by_path(i.coding, '/'), '/', '') coding
                                                FROM icf i
                                               WHERE i.id_icf = rd.id_icf
                                                 AND i.flg_available = pk_alert_constant.g_yes
                                              CONNECT BY PRIOR i.id_icf = i.id_icf_parent
                                               START WITH i.id_icf IN
                                                          (SELECT id_icf
                                                             FROM icf
                                                            WHERE flg_type = pk_interv_mfr.g_flg_icf_component)),
                                              '^(\s-\s*)$',
                                              NULL) ||
                               regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                FROM icf_qualif_scale_rel iqsr
                                               WHERE iqsr.id_icf_qualification = rd.id_iq_initial_incapacity
                                                 AND iqsr.id_icf_qualification_scale = rd.id_iqs_initial_incapacity),
                                              '^(\s*)$',
                                              NULL) ||
                               regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                FROM icf_qualif_scale_rel iqsr
                                               WHERE iqsr.id_icf_qualification = rd.id_iq_expected_result
                                                 AND iqsr.id_icf_qualification_scale = rd.id_iqs_expected_result),
                                              '^(\s*)$',
                                              NULL) ||
                               regexp_replace((SELECT iqsr.flg_code || iqsr.value
                                                FROM icf_qualif_scale_rel iqsr
                                               WHERE iqsr.id_icf_qualification = rd.id_iq_active_incapacity
                                                 AND iqsr.id_icf_qualification_scale = rd.id_iqs_active_incapacity),
                                              '^(\s*)$',
                                              NULL) || ' - ' || pk_translation.get_translation(i_lang, i.code_icf) label,
                               rownum rank
                          FROM rehab_diagnosis rd
                         INNER JOIN icf i
                            ON rd.id_icf = i.id_icf
                         WHERE rd.id_patient = i_patient
                           AND rd.flg_status != pk_rehab.g_rehab_diag_flg_status_c) t);
    
        RETURN l_list;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PATIENT_ICF',
                                              l_error);
            RETURN l_list;
    END get_patient_icf;

    FUNCTION get_request_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER, -- edit, new, submit
        i_root_name      IN VARCHAR2, -- root of dynamic screen
        i_curr_component IN NUMBER,
        i_tbl_int_name   IN table_varchar,
        i_tbl_id_pk      IN table_number, -- id necessary for identifying pk for editing
        i_tbl_mkt_rel    IN table_number, -- components needed for default/edit
        i_value          IN table_table_varchar,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'get_positioning_request_values';
    
        l_ds_pos_rot_internal_name CONSTANT VARCHAR2(100) := 'DS_POSITIONING_ROTATION';
    
        l_index                  NUMBER := 0;
        l_default_rotation_time  VARCHAR2(50) := '00000101010000';
        l_submited_rotation_time VARCHAR2(50);
    
        l_start_date        epis_positioning.dt_creation_tstz%TYPE;
        l_rotation_interval epis_positioning.rot_interval%TYPE;
        l_rotation_time     VARCHAR2(50);
        l_therapy_massage   epis_positioning.flg_massage%TYPE;
        l_notes             epis_positioning.notes%TYPE;
    
        l_posit_count      NUMBER := 0;
        l_limb_count       NUMBER := 0;
        l_protection_count NUMBER := 0;
    
        l_posit_tag              VARCHAR2(50);
        l_count_epis_positioning NUMBER := 0;
    
        /*PEDRO*/
        l_req_id    NUMBER;
        l_int_n     NUMBER;
        l_id_interv NUMBER;
        l_patient   patient%ROWTYPE;
    BEGIN
    
        SELECT p.*
          INTO l_patient
          FROM patient p
         WHERE id_patient = i_patient;
    
        IF i_action = pk_dyn_form_constant.get_submit_action()
        THEN
        
            FOR i IN 1 .. i_tbl_mkt_rel.count
            LOOP
                IF i_tbl_mkt_rel(i) = i_curr_component
                THEN
                    l_req_id := i_value(i) (1);
                    l_int_n  := to_number(i_tbl_int_name(i));
                END IF;
            END LOOP;
        
            l_id_interv := i_curr_component - l_int_n;
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => (q.id_questionnaire + q.id_intervention),
                                       id_ds_component    => NULL, --t.id_ds_component_child,
                                       internal_name      => NULL, --t.internal_name_child,
                                       VALUE              => NULL,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => NULL,
                                       desc_clob          => NULL,
                                       id_unit_measure    => NULL,
                                       desc_unit_measure  => NULL,
                                       flg_validation     => pk_alert_constant.g_yes,
                                       err_msg            => NULL,
                                       flg_event_type     => CASE
                                                                 WHEN q.id_response_parent = l_req_id THEN
                                                                  'A'
                                                                 ELSE
                                                                  'I'
                                                             END,
                                       flg_multi_status   => NULL,
                                       idx                => 1)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure,
                                    iq.rank
                      FROM interv_questionnaire iq, questionnaire_response qr
                     WHERE iq.id_intervention = l_id_interv
                       AND iq.flg_time = 'O'
                       AND iq.id_institution = i_prof.institution
                       AND iq.flg_available = pk_procedures_constant.g_available
                       AND iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                          --AND qr.id_response_parent = l_req_id
                       AND qr.id_questionnaire_parent = l_int_n
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND EXISTS
                     (SELECT 1
                              FROM questionnaire q
                             WHERE q.id_questionnaire = iq.id_questionnaire
                               AND q.flg_available = pk_procedures_constant.g_available
                               AND (((l_patient.gender IS NOT NULL AND coalesce(q.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                   ('I', 'U', 'N', 'C', 'A', 'B', l_patient.gender)) OR l_patient.gender IS NULL OR
                                   l_patient.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                   (nvl(l_patient.age, 0) BETWEEN nvl(q.age_min, 0) AND
                                   nvl(q.age_max, nvl(l_patient.age, 0)) OR nvl(l_patient.age, 0) = 0)))) q;
        ELSIF i_action = 70
        THEN
        
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => (q.id_questionnaire + q.id_intervention),
                                      id_ds_component    => NULL, --t.id_ds_component_child,
                                      internal_name      => NULL, --t.internal_name_child,
                                      VALUE              => decode(is_text,
                                                                   pk_alert_constant.g_yes,
                                                                   desc_response,
                                                                   q.id_response),
                                      value_clob         => NULL,
                                      min_value          => NULL,
                                      max_value          => NULL,
                                      desc_value         => desc_response,
                                      desc_clob          => NULL,
                                      id_unit_measure    => NULL,
                                      desc_unit_measure  => NULL,
                                      flg_validation     => 'Y',
                                      err_msg            => NULL,
                                      flg_event_type     => decode(q.id_response,
                                                                   NULL,
                                                                   decode(q.id_questionnaire_parent,
                                                                          NULL,
                                                                          decode(q.flg_mandatory, 'Y', 'M', NULL),
                                                                          'I'),
                                                                   'A'),
                                      flg_multi_status   => NULL,
                                      idx                => 1)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure,
                                    iq.rank,
                                    t.id_response,
                                    decode(dbms_lob.getlength(t.notes),
                                           NULL,
                                           pk_alert_constant.g_no,
                                           pk_alert_constant.g_yes) is_text,
                                    decode(dbms_lob.getlength(t.notes),
                                           NULL,
                                           pk_mcdt.get_response_alias(i_lang,
                                                                      i_prof,
                                                                      'RESPONSE.CODE_RESPONSE.' || t.id_response),
                                           dbms_lob.substr(t.notes, 3800)) AS desc_response
                      FROM interv_questionnaire iq
                      JOIN questionnaire_response qr
                        ON iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                      LEFT JOIN (SELECT *
                                  FROM (SELECT rp.*,
                                               row_number() over(PARTITION BY rp.id_rehab_presc, rp.id_questionnaire, rp.id_response ORDER BY rp.dt_last_update_tstz DESC) AS rn
                                          FROM rehab_question_response rp
                                         WHERE rp.id_rehab_presc = i_tbl_id_pk(1))) t
                        ON t.id_questionnaire = iq.id_questionnaire
                       AND t.id_response = iq.id_response
                       AND t.rn = 1
                     WHERE iq.id_intervention IN (SELECT rai.id_intervention
                                                    FROM rehab_presc rps
                                                    JOIN rehab_area_interv rai
                                                      ON rps.id_rehab_area_interv = rai.id_rehab_area_interv
                                                   WHERE rps.id_rehab_presc = i_tbl_id_pk(1))
                       AND iq.flg_time = 'O'
                       AND iq.id_institution = i_prof.institution
                       AND iq.flg_available = pk_procedures_constant.g_available
                          --AND qr.id_questionnaire_parent = l_int_n
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND t.rn = 1
                       AND dbms_lob.getlength(t.notes) IS NOT NULL) q;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_request_values;

    FUNCTION get_rehab_treatment_plan
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN rehab_plan.id_patient%TYPE,
        i_id_episode IN rehab_plan.id_episode_origin%TYPE,
        i_reports    IN VARCHAR2,
        o_treat      OUT pk_types.cursor_type,
        o_sch_need   OUT pk_types.cursor_type,
        o_notes      OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_prof_cat          prof_cat.id_prof_cat%TYPE;
        l_id_schedule       rehab_schedule.id_schedule%TYPE;
        l_id_epis_type      episode.id_epis_type%TYPE;
        l_id_episode_origin NUMBER;
        l_dt_begin          TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_dt_end            TIMESTAMP(6) WITH LOCAL TIME ZONE;
        l_cursor            pk_types.cursor_type;
    
        l_descr    VARCHAR2(1000 CHAR);
        l_val      VARCHAR2(4000 CHAR);
        l_flg_type VARCHAR2(10char);
        l_flg_html VARCHAR2(1char);
        l_val_clob CLOB;
        l_flg_clob VARCHAR2(1 CHAR);
    
        l_tbl_sch_need          table_number := table_number();
        l_tbl_distinct_sch_need table_number;
    
        l_sch_need_status rehab_sch_need.flg_status%TYPE;
    
        l_tbl_detail_rehab_presc t_tab_dd_data_reports := t_tab_dd_data_reports();
        l_tbl_detail_sch_need    t_tab_dd_data_reports := t_tab_dd_data_reports();
    
        l_index       PLS_INTEGER := 0;
        l_count_notes PLS_INTEGER := 0;
    
        CURSOR c_rehab_presc(i_id_episode_origin IN episode.id_episode%TYPE) IS
            SELECT id_rehab_presc, flg_status, id_rehab_sch_need
              FROM (SELECT rp.id_rehab_presc, rp.flg_status, rp.dt_rehab_presc, rp.id_rehab_sch_need
                      FROM rehab_presc rp
                      JOIN rehab_sch_need rsn
                        ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                      JOIN rehab_session_type rst
                        ON rsn.id_rehab_session_type = rst.id_rehab_session_type
                      LEFT JOIN institution ins
                        ON (rp.id_exec_institution = ins.id_institution)
                     WHERE ((rsn.id_episode_origin = i_id_episode_origin AND l_prof_cat <> 25) OR
                           (rsn.id_episode_origin IN
                           ((SELECT /*+ opt_estimate(table x2 rows=1) */
                               column_value
                                FROM TABLE(table_number(i_id_episode)) x2)) AND l_prof_cat = 25))
                       AND rsn.flg_status <> g_rehab_sch_need_dummy -- To ignore created records when executed treatments not prescribed 
                       AND ((rp.flg_status != g_rehab_presc_finished OR
                           (rp.flg_status = g_rehab_presc_finished AND
                           (rp.dt_rehab_presc BETWEEN l_dt_begin AND l_dt_end)) OR
                           (rp.flg_status = g_rehab_presc_finished AND i_reports = pk_alert_constant.g_yes)))
                    UNION
                    SELECT rp.id_rehab_presc, rp.flg_status, rp.dt_rehab_presc, rp.id_rehab_sch_need
                      FROM rehab_presc rp
                      JOIN rehab_sch_need rsn
                        ON rp.id_rehab_sch_need = rsn.id_rehab_sch_need
                      JOIN rehab_area_interv rai
                        ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                      JOIN intervention i
                        ON i.id_intervention = rai.id_intervention
                      LEFT JOIN rehab_session_type rst
                        ON rst.id_rehab_session_type = rsn.id_rehab_session_type
                      LEFT JOIN institution ins
                        ON rp.id_exec_institution = ins.id_institution
                     WHERE rsn.flg_status = g_rehab_sch_need_dummy
                       AND EXISTS
                     (SELECT 0
                              FROM rehab_session rs
                             WHERE rs.id_rehab_presc = rp.id_rehab_presc
                                  -- show execution of treatments not prescribed just for current episode
                               AND rs.id_episode IN (SELECT /*+ opt_estimate(table xepis rows=1) */
                                                      column_value
                                                       FROM TABLE(table_number(i_id_episode)) xepis)))
             ORDER BY pk_rehab.order_by_treat(i_flg_status => flg_status) DESC, dt_rehab_presc ASC;
    
    BEGIN
    
        g_error    := 'Call pk_prof_utils.get_categoyr i_prof.id=' || i_prof.id;
        l_prof_cat := pk_prof_utils.get_id_category(i_lang => i_lang, i_prof => i_prof);
    
        g_error := 'Before get_origin_episode';
        -- precisa-se do episódio de origem
        IF NOT get_origin_episode(i_lang              => i_lang,
                                  i_prof              => i_prof,
                                  i_id_episode        => i_id_episode,
                                  i_id_schedule       => NULL,
                                  o_id_episode_origin => l_id_episode_origin,
                                  o_id_schedule       => l_id_schedule,
                                  o_id_epis_type      => l_id_epis_type,
                                  o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz);
        l_dt_end   := pk_date_utils.add_days_to_tstz(l_dt_begin, 1);
    
        FOR c IN c_rehab_presc(l_id_episode_origin)
        LOOP
            g_error := 'Calling pk_rehab.get_rehab_treatment_detail';
            IF NOT pk_rehab.get_rehab_treatment_detail(i_lang    => i_lang,
                                                       i_prof    => i_prof,
                                                       i_id      => c.id_rehab_presc,
                                                       i_area    => 'REHAB_TREATMENT',
                                                       i_reports => i_reports,
                                                       o_detail  => l_cursor,
                                                       o_error   => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            LOOP
                FETCH l_cursor
                    INTO l_descr, l_val, l_flg_type, l_flg_html, l_val_clob, l_flg_clob;
                EXIT WHEN l_cursor%NOTFOUND;
            
                l_index := l_index + 1;
            
                --The LH type is the header to be used in reports, however, it should only be shown on the first record
                IF l_flg_type <> 'LH'
                   OR (l_flg_type = 'LH' AND l_index = 1)
                THEN
                    l_tbl_detail_rehab_presc.extend();
                    l_tbl_detail_rehab_presc(l_tbl_detail_rehab_presc.count) := t_rec_dd_data_reports(id_record  => CASE
                                                                                                                     l_flg_type
                                                                                                                        WHEN 'LH' THEN
                                                                                                                         NULL
                                                                                                                        ELSE
                                                                                                                         c.id_rehab_presc
                                                                                                                    END,
                                                                                                      descr      => l_descr,
                                                                                                      val        => l_val,
                                                                                                      flg_type   => l_flg_type,
                                                                                                      flg_html   => l_flg_html,
                                                                                                      val_clob   => l_val_clob,
                                                                                                      flg_clob   => l_flg_clob,
                                                                                                      flg_status => CASE
                                                                                                                     l_flg_type
                                                                                                                        WHEN 'LH' THEN
                                                                                                                         NULL
                                                                                                                        ELSE
                                                                                                                         c.flg_status
                                                                                                                    END);
                END IF;
            END LOOP;
        
            l_tbl_sch_need.extend();
            l_tbl_sch_need(l_tbl_sch_need.count) := c.id_rehab_sch_need;
        END LOOP;
    
        IF l_tbl_sch_need.count > 0
        THEN
            g_error := 'BUILD l_tbl_distinct_sch_need';
            SELECT /*+ opt_estimate(table t rows=1) */
            DISTINCT t.column_value
              BULK COLLECT
              INTO l_tbl_distinct_sch_need
              FROM TABLE(l_tbl_sch_need) t
             WHERE t.column_value IS NOT NULL;
        
            l_index := 0;
        
            FOR i IN l_tbl_distinct_sch_need.first .. l_tbl_distinct_sch_need.last
            LOOP
                g_error := 'Calling pk_rehab.get_rehab_treatment_detail';
                IF NOT pk_rehab.get_rehab_treatment_detail(i_lang    => i_lang,
                                                           i_prof    => i_prof,
                                                           i_id      => l_tbl_distinct_sch_need(i),
                                                           i_area    => pk_dynamic_detail.g_rehab_session,
                                                           i_reports => i_reports,
                                                           o_detail  => l_cursor,
                                                           o_error   => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                LOOP
                    FETCH l_cursor
                        INTO l_descr, l_val, l_flg_type, l_flg_html, l_val_clob, l_flg_clob;
                    EXIT WHEN l_cursor%NOTFOUND;
                
                    SELECT rsn.flg_status
                      INTO l_sch_need_status
                      FROM rehab_sch_need rsn
                     WHERE rsn.id_rehab_sch_need = l_tbl_distinct_sch_need(i);
                
                    l_index := l_index + 1;
                
                    --The LH type is the header to be used in reports, however, it should only be shown on the first record
                    IF l_flg_type <> 'LH'
                       OR (l_flg_type = 'LH' AND l_index = 1)
                    THEN
                        l_tbl_detail_sch_need.extend();
                        l_tbl_detail_sch_need(l_tbl_detail_sch_need.count) := t_rec_dd_data_reports(id_record  => CASE
                                                                                                                   l_flg_type
                                                                                                                      WHEN 'LH' THEN
                                                                                                                       NULL
                                                                                                                      ELSE
                                                                                                                       l_tbl_distinct_sch_need(i)
                                                                                                                  END,
                                                                                                    descr      => l_descr,
                                                                                                    val        => l_val,
                                                                                                    flg_type   => l_flg_type,
                                                                                                    flg_html   => l_flg_html,
                                                                                                    val_clob   => l_val_clob,
                                                                                                    flg_clob   => l_flg_clob,
                                                                                                    flg_status => CASE
                                                                                                                   l_flg_type
                                                                                                                      WHEN 'LH' THEN
                                                                                                                       NULL
                                                                                                                      ELSE
                                                                                                                       l_sch_need_status
                                                                                                                  END);
                    END IF;
                END LOOP;
            END LOOP;
        END IF;
    
        g_error := 'OPEN o_treat';
        OPEN o_treat FOR
            SELECT /*+ opt_estimate(table t rows=1) */
             *
              FROM TABLE(l_tbl_detail_rehab_presc) t;
    
        g_error := 'OPEN o_sch_need';
        OPEN o_sch_need FOR
            SELECT /*+ opt_estimate(table t rows=1) */
             *
              FROM TABLE(l_tbl_detail_sch_need) t;
    
        SELECT COUNT(1)
          INTO l_count_notes
          FROM rehab_notes rn
          JOIN rehab_plan rp
            ON rp.id_episode_origin = rn.id_episode_origin
         WHERE ((rp.id_episode_origin = l_id_episode_origin AND l_prof_cat <> 25) OR
               ((rp.id_episode_origin IN ((SELECT column_value
                                             FROM TABLE(table_number(i_id_episode)))) AND l_prof_cat = 25)));
        IF l_count_notes > 0
        THEN
            g_error := 'NOTES';
            OPEN o_notes FOR
                SELECT id_record,
                       descr,
                       val,
                       flg_type,
                       pk_alert_constant.g_no flg_html,
                       to_clob(NULL) val_clob,
                       pk_alert_constant.g_no flg_clob,
                       flg_status
                  FROM (SELECT id_record,
                               pk_message.get_message(i_lang, data_source) descr,
                               data_source_val val,
                               CASE data_source
                                   WHEN 'COMMON_M107' THEN
                                    'LP'
                                   ELSE
                                    'L2'
                               END flg_type,
                               rownum rank,
                               flg_status
                          FROM (SELECT *
                                  FROM (SELECT rn.id_rehab_notes id_record,
                                               rn.notes common_m044,
                                               pk_prof_utils.get_name_signature(i_lang, i_prof, rn.id_professional) ||
                                               decode(pk_prof_utils.get_spec_signature(i_lang,
                                                                                       i_prof,
                                                                                       rn.id_professional,
                                                                                       rn.dt_rehab_notes,
                                                                                       rn.id_episode_origin),
                                                      NULL,
                                                      '; ',
                                                      ' (' ||
                                                      pk_prof_utils.get_spec_signature(i_lang,
                                                                                       i_prof,
                                                                                       rn.id_professional,
                                                                                       rn.dt_rehab_notes,
                                                                                       rn.id_episode_origin) || '); ') ||
                                               pk_date_utils.date_char_tsz(i_lang,
                                                                           rn.dt_rehab_notes,
                                                                           i_prof.institution,
                                                                           i_prof.software) common_m107,
                                               rp.flg_status
                                          FROM rehab_notes rn
                                          JOIN rehab_plan rp
                                            ON rp.id_episode_origin = rn.id_episode_origin
                                         WHERE ((rp.id_episode_origin = l_id_episode_origin AND l_prof_cat <> 25) OR
                                               ((rp.id_episode_origin IN
                                               ((SELECT column_value
                                                     FROM TABLE(table_number(i_id_episode)))) AND l_prof_cat = 25)))
                                         ORDER BY rn.dt_rehab_notes DESC) unpivot include NULLS(data_source_val FOR data_source IN(common_m044,
                                                                                                                                   common_m107)))
                        UNION
                        SELECT NULL id_record,
                               pk_message.get_message(i_lang, 'REHAB_T034') descr,
                               NULL val,
                               'LH' flg_type,
                               0 rank,
                               NULL flg_status
                          FROM dual)
                 ORDER BY rank;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error('Parameters: i_id_episode=' || i_id_episode || ' @' || g_error,
                                  g_package_name,
                                  'GET_REHAB_TREATMENT_PLAN');
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_REHAB_TREATMENT_PLAN',
                                              o_error);
            RETURN FALSE;
    END get_rehab_treatment_plan;

    FUNCTION get_visit_type_by_epis
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
        l_name VARCHAR2(1000 CHAR);
    BEGIN
    
        SELECT pk_translation.get_translation(i_lang, rst.code_rehab_session_type)
          INTO l_name
          FROM rehab_sch_need rsn
          JOIN rehab_session_type rst
            ON rsn.id_rehab_session_type = rst.id_rehab_session_type
          JOIN rehab_epis_encounter ree
            ON ree.id_rehab_sch_need = rsn.id_rehab_sch_need
          JOIN episode epis
            ON epis.id_episode = ree.id_episode_rehab
          JOIN epis_info ei
            ON epis.id_episode = ei.id_episode
        
         WHERE epis.id_episode = i_id_episode;
        RETURN l_name;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_visit_type_by_epis;

    FUNCTION get_visit_prof_by_epis
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
        l_name VARCHAR2(1000 CHAR);
    BEGIN
        SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, rsn.id_resp_professional)
          INTO l_name
          FROM rehab_sch_need rsn
          JOIN rehab_session_type rst
            ON rsn.id_rehab_session_type = rst.id_rehab_session_type
          JOIN rehab_epis_encounter ree
            ON ree.id_rehab_sch_need = rsn.id_rehab_sch_need
          JOIN episode epis
            ON epis.id_episode = ree.id_episode_rehab
          JOIN epis_info ei
            ON epis.id_episode = ei.id_episode
         WHERE epis.id_episode = i_id_episode;
        RETURN l_name;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_visit_prof_by_epis;

    FUNCTION get_rsn_icon_tooltip
    (
        i_lang              IN language.id_language%TYPE,
        i_id_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_flg_status        IN rehab_sch_need.flg_status%TYPE,
        i_sessions          IN rehab_sch_need.sessions%TYPE
    ) RETURN VARCHAR2 IS
        l_ret        VARCHAR2(20) := '';
        l_count      NUMBER;
        l_status     VARCHAR2(200);
        l_count_disc NUMBER;
        l_flg_status VARCHAR2(2 CHAR);
    BEGIN
        IF i_sessions IS NOT NULL
           AND i_flg_status != g_rehab_sch_need_cancel
        THEN
            SELECT COUNT(*)
              INTO l_count
              FROM rehab_schedule rs
             WHERE rs.id_rehab_sch_need = i_id_rehab_sch_need
               AND rs.flg_status = pk_alert_constant.g_active;
        
            IF l_count = 0
            THEN
                SELECT COUNT(*)
                  INTO l_count
                  FROM sch_rehab_group srg
                 INNER JOIN rehab_sch_need rsn
                    ON rsn.id_rehab_sch_need = srg.id_rehab_sch_need
                 WHERE rsn.id_rehab_sch_need = i_id_rehab_sch_need
                   AND srg.flg_status = pk_alert_constant.g_active;
            END IF;
        
            IF l_count = 0
            THEN
                -- ainda não foi agendada nenhuma sessão
                l_ret := i_sessions || '/' || i_sessions;
            ELSIF l_count = i_sessions
            THEN
                -- todas as sessões agendadas
                l_ret := '  ' || i_sessions;
            ELSIF l_count > i_sessions
            THEN
                -- agendadas mais sessões do que as originalmente pedidas
                l_ret := '  ' || l_count;
            ELSE
                l_ret := (i_sessions - l_count) || '/' || i_sessions;
            END IF;
        
            IF l_count < i_sessions
            THEN
                -- se o número de sessões agendadas é menor que número requisitado o icon é igual ao do por agendar
            
                SELECT COUNT(*)
                  INTO l_count_disc
                  FROM rehab_presc a
                 WHERE a.id_rehab_sch_need = i_id_rehab_sch_need
                   AND a.flg_status = g_rehab_presc_discontinued;
                IF l_count_disc > 0
                THEN
                    l_status := '';
                ELSE
                
                    l_flg_status := g_rehab_sch_need_wait_sch;
                    l_status     := pk_sysdomain.get_domain(g_rehab_sch_need_flg_status, l_flg_status, i_lang);
                END IF;
            ELSIF l_count = i_sessions
            THEN
                l_flg_status := g_rehab_sch_need_scheduled;
                l_status     := pk_sysdomain.get_domain(g_rehab_sch_need_flg_status, l_flg_status, i_lang);
            END IF;
        END IF;
    
        RETURN l_status || chr(10) || l_ret;
    END get_rsn_icon_tooltip;

    FUNCTION get_status_icon
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_rehab_sch_need IN rehab_sch_need.id_rehab_sch_need%TYPE,
        i_num_sessions   IN rehab_sch_need.sessions%TYPE,
        i_flg_status     IN rehab_sch_need.flg_status%TYPE
    ) RETURN VARCHAR2 IS
        l_return VARCHAR2(1000 CHAR);
        t_error  t_error_out;
    BEGIN
        l_return := pk_utils.get_status_string_immediate(i_lang         => i_lang,
                                                         i_prof         => i_prof,
                                                         i_display_type => 'TI',
                                                         i_flg_state    => i_flg_status,
                                                         i_value_text   => pk_rehab.get_rsn_icon_label(i_lang,
                                                                                                       i_rehab_sch_need,
                                                                                                       i_flg_status,
                                                                                                       i_num_sessions),
                                                         i_value_icon   => pk_rehab.get_rsn_icon(i_lang,
                                                                                                 i_rehab_sch_need,
                                                                                                 i_num_sessions,
                                                                                                 i_flg_status),
                                                         i_back_color   => NULL, --'0xC86464',
                                                         i_icon_color   => NULL, --'0xEBEBC8',
                                                         i_tooltip_text => pk_rehab.get_rsn_icon_tooltip(i_lang,
                                                                                                         i_rehab_sch_need,
                                                                                                         i_flg_status,
                                                                                                         i_num_sessions));
        l_return := '|TI||' || pk_rehab.get_rsn_icon_label(i_lang, i_rehab_sch_need, i_flg_status, i_num_sessions) || '|' ||
                    pk_rehab.get_rsn_icon(i_lang, i_rehab_sch_need, i_num_sessions, i_flg_status) ||
                    '|0xC86464||0xEBEBC8|0xEBEBC8|' || pk_date_utils.date_send_tsz(i_lang, current_timestamp, i_prof) ||
                    '||N|' || pk_rehab.get_rsn_icon_tooltip(i_lang, i_rehab_sch_need, i_flg_status, i_num_sessions);
        RETURN l_return;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_STATUS_ICON',
                                              t_error);
            RETURN NULL;
    END get_status_icon;

BEGIN
    pk_alertlog.who_am_i(g_package_owner, g_package_name);
    pk_alertlog.log_init(g_package_name);
END pk_rehab;
/
